/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/js/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/js/index.ts":
/*!****************************!*\
  !*** ./public/js/index.ts ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var webix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webix */ "C:\\Users\\resow\\AppData\\Roaming\\npm\\node_modules\\webix\\webix.js");
/* harmony import */ var webix__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webix__WEBPACK_IMPORTED_MODULE_0__);

var render = function () {
    webix.ui({
        container: "form-place",
        view: "form",
        id: "login_form",
        width: 600,
        elements: [
            { view: "text", name: "login", label: "Login" },
            { view: "text", name: "password", type: "password", label: "Password" },
            {
                cols: [
                    {
                        view: "button",
                        value: "Login",
                        type: "form",
                        on: {
                            "onItemClick": function () {
                                var data = JSON.stringify($$("login_form").getValues());
                                webix.ajax().post("/auth", data, function () {
                                    webix.message("success");
                                });
                            }
                        },
                    },
                    { view: "button", value: "Cancel" }
                ]
            }
        ]
    });
    console.log("it's all good");
};
document.addEventListener("DOMContentLoaded", render);


/***/ }),

/***/ "C:\\Users\\resow\\AppData\\Roaming\\npm\\node_modules\\webix\\webix.js":
/*!**********************************************************************!*\
  !*** C:/Users/resow/AppData/Roaming/npm/node_modules/webix/webix.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @license
 * webix UI v.6.2.0
 * This software is allowed to use under GPL or you need to obtain Commercial License
 * to use it in non-GPL project. Please contact sales@webix.com for details
 */

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

	var state = {
	  codebase: "./",
	  cdn: "//cdn.webix.com",
	  top_views: [],
	  _global_scope: null,
	  _global_collection: null,
	  _child_sizing_active: null,
	  _responsive_exception: null,
	  _responsive_tinkery: null,
	  _freeze_resize: null,
	  _parent_cell: null,
	  _focus_time: null,
	  _ui_creation: 0,
	  _edit_open_time: null,
	  _final_destruction: null,
	  _events: [],
	  destructors: [],
	  securityKey: "",
	  _noselect_element: null,
	  _modality: 0,
	  _wait_animate: null,
	  noanimate: false
	};

	var env = {};
	env.cdn = "//cdn.webix.com/";
	env.codebase = "";
	env.zIndexBase = 100;
	env.scrollSize = 17;
	env.strict = !!window.webix_strict;
	env.https = document.location.protocol === "https:";
	var agent = navigator.userAgent;
	env.isMac = agent.indexOf("Mac") != -1;
	if (agent.indexOf("Mobile") != -1 || agent.indexOf("Windows Phone") != -1) env.mobile = true;
	if (env.mobile || agent.indexOf("iPad") != -1 || agent.indexOf("Android") != -1) env.touch = true;
	if (agent.indexOf("Opera") != -1) env.isOpera = true;else {
	  //very rough detection, but it is enough for current goals
	  env.isIE = !!document.all || agent.indexOf("Trident") !== -1;

	  if (env.isIE) {
	    var version = parseFloat(navigator.appVersion.split("MSIE")[1]);
	    if (version == 8) env.isIE8 = true;
	  }

	  env.isEdge = agent.indexOf("Edge") != -1;
	  env.isFF = agent.indexOf("Firefox") != -1;
	  env.isWebKit = agent.indexOf("KHTML") != -1;
	  env.isSafari = env.isWebKit && env.isMac && agent.indexOf("Chrome") == -1; //maximum height/width for HTML elements in pixels (rough), bigger values will be ignored by browser

	  if (env.isIE || env.isEdge || env.isFF) env.maxHTMLElementSize = 10000000;
	  if (env.isSafari) env.maxHTMLElementSize = 100000000;
	}

	if (agent.toLowerCase().indexOf("android") != -1) {
	  env.isAndroid = true;

	  if (agent.toLowerCase().indexOf("trident") != -1) {
	    env.isAndroid = false;
	    env.isIEMobile = true;
	  }
	}

	env.transform = false;
	env.transition = false;
	var found_index = -1;
	var js_list = ["", "webkit", "Moz", "O", "ms"];
	var css_list = ["", "-webkit-", "-Moz-", "-o-", "-ms-"];
	var d = document.createElement("DIV");

	for (var j = 0; j < js_list.length; j++) {
	  var name = js_list[j] ? js_list[j] + "Transform" : "transform";

	  if (typeof d.style[name] != "undefined") {
	    found_index = j;
	    break;
	  }
	}

	if (found_index > -1) {
	  env.cssPrefix = css_list[found_index];
	  var jp = env.jsPrefix = js_list[found_index];
	  env.transform = jp ? jp + "Transform" : "transform";
	  env.transition = jp ? jp + "Transition" : "transition";
	  env.transitionDuration = jp ? jp + "TransitionDuration" : "transitionDuration";
	  d.style[env.transform] = "translate3d(0,0,0)";
	  env.translate = d.style[env.transform] ? "translate3d" : "translate";
	  env.transitionEnd = env.cssPrefix == "-Moz-" ? "transitionend" : jp ? jp + "TransitionEnd" : "transitionend";
	}

	env.pointerevents = !env.isIE || new RegExp("Trident/.*rv:11").exec(agent) !== null; //touch events that can be prevented

	env.passiveEventListeners = false;

	try {
	  var opts = Object.defineProperty({}, "passive", {
	    get: function () {
	      // eslint-disable-line
	      env.passiveEventListeners = true;
	    }
	  });
	  window.addEventListener("testPassive", null, opts);
	  window.removeEventListener("testPassive", null, opts);
	} catch (e) {} // eslint-disable-line


	env.svg = function () {
	  return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
	}();

	env.svganimation = function () {
	  return document.implementation.hasFeature("https://www.w3.org/TR/SVG11/feature#SVG-animation", "1.1");
	}();

	function _typeof(obj) {
	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	// resolves circular dependencies
	// quick solution, must be removed in the next versions
	var services = {};
	function define(name, value) {
	  services[name] = value;
	}
	function use(name) {
	  return services[name];
	}

	function assert(test, msg) {
	  if (!test) {
	    log("error", msg);
	    var message = use("message");
	    if (message && typeof msg == "string") message({
	      type: "debug",
	      text: msg,
	      expire: -1
	    });
	    debugger; // eslint-disable-line
	  }
	} //show log message

	function log(type, message, details) {
	  if (arguments.length == 1) {
	    message = type;
	    type = "log";
	  }

	  if (window.console && window.console.log) {
	    type = type.toLowerCase();
	    if (window.console[type]) window.console[type](message || "unknown error");else window.console.log(type + ": " + message);
	    if (details) window.console.log(details);
	  }
	}
	var debug_mode = {};
	function debug(mode) {
	  if (!mode) debug_mode = {};else if (_typeof(mode) !== "object") debug_mode = {
	    events: true
	  };else for (var key in mode) {
	    debug_mode[key] = mode[key];
	  }
	}
	var debug_size_indent = 0;

	function debug_size_step() {
	  var str = "";

	  for (var i = 0; i < debug_size_indent; i++) {
	    str += "|  ";
	  }

	  return str;
	}

	function debug_size_box_start(comp, get) {
	  if (!debug_mode.size) return;
	  if (!debug_size_indent) log(get ? "--- get sizes ---" : "--- set sizes ---");
	  log(debug_size_step() + comp.name + "@" + comp.config.id);
	  debug_size_indent++;
	}
	function debug_size_box_end(comp, sizes) {
	  if (!debug_mode.size) return;
	  debug_size_indent--;
	  log(debug_size_step() + sizes.join(","));
	}
	function debug_size_box(comp, sizes, get) {
	  if (!debug_mode.size) return;
	  if (!debug_size_indent) log(get ? "--- get sizes ---" : "--- set sizes ---");
	  log(debug_size_step() + comp.name + "@" + comp.config.id + " " + sizes.join(","));
	}

	var level = 0;
	function level_in() {
	  level++;
	  assert(level !== 100, "Attempt to copy object with self reference");
	}
	function level_out() {
	  level--;
	} //coding helpers

	function clone(source) {
	  var f = clone._function;
	  f.prototype = source;
	  return new f();
	}

	clone._function = function () {}; //copies methods and properties from source to the target


	exports.extend = function (base, source, force) {
	  assert(base, "Invalid mixing target");
	  assert(source, "Invalid mixing source");

	  if (base.$protoWait) {
	    PowerArray.insertAt.call(base.$protoWait, source, 1);
	    return base;
	  } //copy methods, overwrite existing ones in case of conflict


	  for (var method in source) {
	    if (!(method in base) || force) base[method] = source[method];
	  } //in case of defaults - preffer top one


	  if (source.defaults) exports.extend(base.defaults, source.defaults); //if source object has init code - call init against target

	  if (source.$init) source.$init.call(base);
	  return base;
	}; //copies methods and properties from source to the target from all levels


	function copy(source) {
	  assert(source, "Invalid mixing target");
	  level_in();
	  var esModern = !!window.Map && !!window.Set && !!window.WeakMap && !!window.WeakSet;
	  var target;

	  if (arguments.length > 1) {
	    target = arguments[0];
	    source = arguments[1];
	  } else target = isArray(source) ? [] : {};

	  for (var method in source) {
	    var from = source[method];

	    if (from && _typeof(from) == "object" && !(from instanceof RegExp)) {
	      if (isDate(from)) target[method] = new Date(from);
	      /* jshint ignore:start */
	      else if (esModern && (from instanceof Map || from instanceof Set || from instanceof WeakMap || from instanceof WeakSet)) target[method] = from;
	        /* jshint ignore:end */
	        else {
	            target[method] = isArray(from) ? [] : {};
	            copy(target[method], from);
	          }
	    } else {
	      target[method] = from;
	    }
	  }

	  level_out();
	  return target;
	}
	function single(source) {
	  var instance = null;

	  var t = function () {
	    if (!instance) instance = new source({});
	    if (instance._reinit) instance._reinit.apply(instance, arguments);
	    return instance;
	  };

	  return t;
	} //creates function with specified "this" pointer

	function bind(functor, object) {
	  return function () {
	    return functor.apply(object, arguments);
	  };
	} //evaluate javascript code in the global scoope

	function exec(code) {
	  if (window.execScript) //special handling for IE
	    window.execScript(code);else window.eval(code);
	}
	function wrap(code, wrap) {
	  if (!code) return wrap;
	  return function () {
	    var result = code.apply(this, arguments);
	    wrap.apply(this, arguments);
	    return result;
	  };
	} //check === undefined

	function isUndefined(a) {
	  return typeof a == "undefined";
	} //delay call to after-render time

	function delay(method, obj, params, delay) {
	  return window.setTimeout(function () {
	    if (!(obj && obj.$destructed)) {
	      var ret = method.apply(obj, params || []);
	      method = obj = params = null;
	      return ret;
	    }
	  }, delay || 1);
	}
	function once(method) {
	  var flag = true;
	  return function () {
	    if (flag) {
	      flag = false;
	      method.apply(this, arguments);
	    }
	  };
	} //common helpers
	//generates unique ID (unique per window, nog GUID)

	var _seed = new Date().valueOf();

	function uid() {
	  _seed++;
	  return _seed;
	} //resolve ID as html object

	function toNode(node) {
	  if (typeof node == "string") return document.getElementById(node);
	  return node;
	} //adds extra methods for the array

	function toArray(array) {
	  return exports.extend(array || [], PowerArray, true);
	} //resolve function name

	function toFunctor(str, scope) {
	  if (typeof str == "string") {
	    var method = str.replace("()", "");
	    if (scope && scope[method]) return scope[method];
	    return window[method] || window.eval(str);
	  }

	  return str;
	}
	/*checks where an object is instance of Array*/

	function isArray(obj) {
	  return Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === "[object Array]";
	}
	function isDate(obj) {
	  return obj instanceof Date;
	} //can be used by toArray()

	var PowerArray = {
	  //remove element at specified position
	  removeAt: function (pos, len) {
	    if (pos >= 0) this.splice(pos, len || 1);
	  },
	  //find element in collection and remove it 
	  remove: function (value) {
	    this.removeAt(this.find(value));
	  },
	  //add element to collection at specific position
	  insertAt: function (data, pos) {
	    if (!pos && pos !== 0) //add to the end by default
	      this.push(data);else {
	      this.splice(pos, 0, data);
	    }
	  },
	  //return index of element, -1 if it doesn't exists
	  find: function (data) {
	    for (var i = 0; i < this.length; i++) {
	      if (data == this[i]) return i;
	    }

	    return -1;
	  },
	  //execute some method for each element of array
	  each: function (functor, master) {
	    for (var i = 0; i < this.length; i++) {
	      functor.call(master || this, this[i]);
	    }
	  },
	  //create new array from source, by using results of functor 
	  map: function (functor, master) {
	    for (var i = 0; i < this.length; i++) {
	      this[i] = functor.call(master || this, this[i]);
	    }

	    return this;
	  },
	  filter: function (functor, master) {
	    for (var i = 0; i < this.length; i++) {
	      if (!functor.call(master || this, this[i])) {
	        this.splice(i, 1);
	        i--;
	      }
	    }

	    return this;
	  }
	}; //hook for documentation generator

	{
	  if (window.webix_on_core_ready) {
	    exports.extend = window.webix_on_core_ready({
	      extend: exports.extend
	    }).extend;
	  }
	}

	var EventSystem = {
	  $init: function () {
	    if (!this._evs_events) {
	      this._evs_events = {}; //hash of event handlers, name => handler

	      this._evs_handlers = {}; //hash of event handlers, ID => handler

	      this._evs_map = {};
	    }
	  },
	  //temporary block event triggering
	  blockEvent: function () {
	    this._evs_events._block = true;
	  },
	  //re-enable event triggering
	  unblockEvent: function () {
	    this._evs_events._block = false;
	  },
	  mapEvent: function (map) {
	    exports.extend(this._evs_map, map, true);
	  },
	  on_setter: function (config) {
	    if (config) {
	      for (var i in config) {
	        var method = toFunctor(config[i], this.$scope);
	        var sub = i.indexOf("->");

	        if (sub !== -1) {
	          this[i.substr(0, sub)].attachEvent(i.substr(sub + 2), bind(method, this));
	        } else this.attachEvent(i, method);
	      }
	    }
	  },
	  //trigger event
	  callEvent: function (type, params) {
	    var master = this._event_master || this;
	    if (this._evs_events._block) return true;
	    type = type.toLowerCase();

	    var event_stack = this._evs_events[type.toLowerCase()]; //all events for provided name


	    var return_value = true;
	    if ((debug_mode.events || this.debug) && type !== "onmousemoving") //can slowdown a lot
	      log("info", "[" + this.name + "@" + (this._settings || {}).id + "] event:" + type, params);
	    if (event_stack) for (var i = 0; i < event_stack.length; i++) {
	      /*
	      	Call events one by one
	      	If any event return false - result of whole event will be false
	      	Handlers which are not returning anything - counted as positive
	      */
	      if (event_stack[i].apply(master, params || []) === false) return_value = false;
	    }

	    if (this._evs_map[type]) {
	      var target = this._evs_map[type];
	      target.$eventSource = this;
	      if (!target.callEvent(type, params)) return_value = false;
	      target.$eventSource = null;
	    }

	    return return_value;
	  },
	  //assign handler for some named event
	  attachEvent: function (type, functor, id) {
	    assert(functor, "Invalid event handler for " + type);
	    type = type.toLowerCase();
	    id = id || uid(); //ID can be used for detachEvent

	    functor = toFunctor(functor, this.$scope); //functor can be a name of method

	    var event_stack = this._evs_events[type] || toArray(); //save new event handler

	    if (arguments[3]) event_stack.unshift(functor);else event_stack.push(functor);
	    this._evs_events[type] = event_stack;
	    this._evs_handlers[id] = {
	      f: functor,
	      t: type
	    };
	    return id;
	  },
	  //remove event handler
	  detachEvent: function (id) {
	    if (!this._evs_handlers[id]) {
	      var name = (id + "").toLowerCase();

	      if (this._evs_events[name]) {
	        this._evs_events[name] = toArray();
	      }

	      return;
	    }

	    var type = this._evs_handlers[id].t;
	    var functor = this._evs_handlers[id].f; //remove from all collections

	    var event_stack = this._evs_events[type];
	    event_stack.remove(functor);
	    delete this._evs_handlers[id];
	  },
	  hasEvent: function (type) {
	    type = type.toLowerCase();
	    var stack = this._evs_events[type];
	    if (stack && stack.length) return true;
	    var parent = this._evs_map[type];
	    if (parent) return parent.hasEvent(type);
	    return false;
	  }
	};

	var evs = {};
	exports.extend(evs, EventSystem, true);
	var callEvent = function (a, b) {
	  return evs.callEvent(a, b);
	};
	var attachEvent = function (a, b, c, d) {
	  return evs.attachEvent(a, b, c, d);
	};
	var detachEvent = function (a) {
	  return evs.detachEvent(a);
	};
	var blockEvent = function () {
	  return evs.blockEvent();
	};
	var unblockEvent = function () {
	  return evs.unblockEvent();
	};
	var mapEvent = function (map) {
	  return evs.mapEvent(map);
	};
	var hasEvent = function (type) {
	  return evs.hasEvent(type);
	};

	var _native_on_selectstart = 0;
	var _style_element = {};
	var _style_cache = {};
	function denySelect() {
	  if (!_native_on_selectstart) _native_on_selectstart = document.onselectstart;
	  document.onselectstart = stopEvent;
	}
	function allowSelect() {
	  if (_native_on_selectstart !== 0) {
	    document.onselectstart = _native_on_selectstart || null;
	  }

	  _native_on_selectstart = 0;
	}
	function index(node) {
	  var k = 0; //must be =, it is not a comparation!

	  while (node = node.previousSibling) {
	    k++;
	  }

	  return k;
	}
	function createCss(rule, sufix) {
	  var text = "";
	  sufix = sufix || "";

	  for (var key in rule) {
	    text += key + ":" + rule[key] + ";";
	  }

	  var name = _style_cache[text + sufix];

	  if (!name) {
	    name = "s" + uid();
	    addStyle("." + name + (sufix || "") + "{" + text + "}");
	    _style_cache[text + sufix] = name;
	  }

	  return name;
	}
	function addStyle(rule, group) {
	  var style = group ? _style_element[group] : _style_element["default"];

	  if (!style) {
	    style = document.createElement("style");
	    style.setAttribute("type", "text/css");
	    style.setAttribute("media", "screen,print");
	    document.getElementsByTagName("head")[0].appendChild(style);
	    if (group) _style_element[group] = style;else _style_element["default"] = style;
	  }
	  /*IE8*/


	  if (style.styleSheet) style.styleSheet.cssText += rule;else style.appendChild(document.createTextNode(rule));
	}
	function removeStyle(group) {
	  var box = _style_element[group || "default"];
	  if (box) box.innerHTML = "";
	}
	function create(name, attrs, html) {
	  attrs = attrs || {};
	  var node = document.createElement(name);

	  for (var attr_name in attrs) {
	    node.setAttribute(attr_name, attrs[attr_name]);
	  }

	  if (attrs.style) node.style.cssText = attrs.style;
	  if (attrs["class"]) node.className = attrs["class"];
	  if (html) node.innerHTML = html;
	  return node;
	} //return node value, different logic for different html elements

	function getValue(node) {
	  node = toNode(node);
	  if (!node) return "";
	  return isUndefined(node.value) ? node.innerHTML : node.value;
	} //remove html node, can process an array of nodes at once

	function remove(node) {
	  if (node instanceof Array) for (var i = 0; i < node.length; i++) {
	    remove(node[i]);
	  } else if (node && node.parentNode) node.parentNode.removeChild(node);
	} //insert new node before sibling, or at the end if sibling doesn't exist

	function insertBefore(node, before, rescue) {
	  if (!node) return;
	  if (before && before.parentNode) before.parentNode.insertBefore(node, before);else rescue.appendChild(node);
	} //return custom ID from html element 
	//will check all parents starting from event's target

	function locate(e, id) {
	  var trg;
	  if (e.tagName) trg = e;else {
	    e = e || event;
	    trg = e.target || e.srcElement;
	  }

	  while (trg) {
	    if (trg.getAttribute) {
	      //text nodes has not getAttribute
	      var test = trg.getAttribute(id);
	      if (test) return test;
	    }

	    trg = trg.parentNode;
	  }

	  return null;
	} //returns position of html element on the page

	function offset(elem) {
	  if (elem.getBoundingClientRect) {
	    //HTML5 method
	    var box = elem.getBoundingClientRect();
	    var body = document.body;
	    var docElem = document.documentElement;
	    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
	    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
	    var clientTop = docElem.clientTop || body.clientTop || 0;
	    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
	    var top = box.top + scrollTop - clientTop;
	    var left = box.left + scrollLeft - clientLeft;
	    return {
	      y: Math.round(top),
	      x: Math.round(left),
	      width: elem.offsetWidth,
	      height: elem.offsetHeight
	    };
	  } else {
	    //fallback to naive approach
	    var _top = 0,
	        _left = 0;

	    while (elem) {
	      _top = _top + parseInt(elem.offsetTop, 10);
	      _left = _left + parseInt(elem.offsetLeft, 10);
	      elem = elem.offsetParent;
	    }

	    return {
	      y: _top,
	      x: _left,
	      width: elem.offsetHeight,
	      height: elem.offsetWidth
	    };
	  }
	} //returns relative position of event

	function posRelative(ev) {
	  ev = ev || event;
	  if (!isUndefined(ev.offsetX)) return {
	    x: ev.offsetX,
	    y: ev.offsetY
	  }; //ie, webkit
	  else return {
	      x: ev.layerX,
	      y: ev.layerY
	    }; //firefox
	} //returns position of event

	function pos(ev) {
	  ev = ev || event;
	  if (ev.touches && ev.touches[0]) ev = ev.touches[0];
	  if (ev.pageX || ev.pageY) //FF, KHTML
	    return {
	      x: ev.pageX,
	      y: ev.pageY
	    }; //IE

	  var d = env.isIE && document.compatMode != "BackCompat" ? document.documentElement : document.body;
	  return {
	    x: ev.clientX + d.scrollLeft - d.clientLeft,
	    y: ev.clientY + d.scrollTop - d.clientTop
	  };
	} //prevent event action

	function preventEvent(e) {
	  if (e && e.preventDefault) e.preventDefault();
	  if (e) e.returnValue = false;
	  return stopEvent(e);
	} //stop event bubbling

	function stopEvent(e) {
	  e = e || event;
	  if (e.stopPropagation) e.stopPropagation();
	  e.cancelBubble = true;
	  return false;
	}
	function triggerEvent(node, type, name) {
	  if (document.createEventObject) {
	    var ev = document.createEventObject();
	    if (node.fireEvent) node.fireEvent("on" + name, ev);
	  } else {
	    var _ev = document.createEvent(type);

	    _ev.initEvent(name, true, true);

	    if (node.dispatchEvent) node.dispatchEvent(_ev);
	  }
	} //add css class to the node

	function addCss(node, name, check) {
	  if (!check || node.className.indexOf(name) === -1) node.className += " " + name;
	} //remove css class from the node

	function removeCss(node, name) {
	  node.className = node.className.replace(RegExp(" " + name, "g"), "");
	}
	function getTextSize(text, css, basewidth) {
	  var d = create("DIV", {
	    "class": "webix_view webix_measure_size " + (css || "")
	  }, "");
	  d.style.cssText = "height:auto;visibility:hidden; position:absolute; top:0px; left:0px; overflow:hidden;" + (basewidth ? "width:" + basewidth + "px;" : "width:auto;white-space:nowrap;");
	  document.body.appendChild(d);
	  var all = _typeof(text) !== "object" ? [text] : text;
	  var width = 0;
	  var height = 0;

	  for (var i = 0; i < all.length; i++) {
	    d.innerHTML = all[i];
	    width = Math.max(width, d.offsetWidth);
	    height = Math.max(height, d.offsetHeight);
	  }

	  remove(d);
	  return {
	    width: width,
	    height: height
	  };
	}
	function download(data, filename) {
	  var objUrl = false;

	  if (_typeof(data) == "object") {
	    //blob
	    if (window.navigator.msSaveBlob) return window.navigator.msSaveBlob(data, filename);else {
	      data = window.URL.createObjectURL(data);
	      objUrl = true;
	    }
	  } //data url or blob url


	  var link = document.createElement("a");
	  link.href = data;
	  link.download = filename;
	  document.body.appendChild(link);
	  link.click();
	  delay(function () {
	    if (objUrl) window.URL.revokeObjectURL(data);
	    document.body.removeChild(link);
	    link.remove();
	  });
	}
	function _getClassName(node) {
	  if (!node) return "";
	  var className = node.className || "";
	  if (className.baseVal) //'className' exist but not a string - IE svg element in DOM
	    className = className.baseVal;
	  if (!className.indexOf) className = "";
	  return className;
	}
	function setSelectionRange(node, start, end) {
	  start = start || 0;
	  end = end || start;
	  node.focus();
	  if (node.setSelectionRange) node.setSelectionRange(start, end);else {
	    //ie8
	    var textRange = node.createTextRange();
	    textRange.collapse(true);
	    textRange.moveEnd("character", end);
	    textRange.moveStart("character", start);
	    textRange.select();
	  }
	}
	function getSelectionRange(node) {
	  if ("selectionStart" in node) return {
	    start: node.selectionStart || 0,
	    end: node.selectionEnd || 0
	  };else {
	    //ie8
	    node.focus();
	    var selection = document.selection.createRange();
	    var bookmark = selection.getBookmark();
	    var textRange = node.createTextRange();
	    textRange.moveToBookmark(bookmark);
	    var length = textRange.text.length;
	    textRange.collapse(true);
	    textRange.moveStart("character", -node.value.length);
	    var start = textRange.text.length;
	    return {
	      start: start,
	      end: start + length
	    };
	  }
	}
	function addMeta(name, value) {
	  document.getElementsByTagName("head").item(0).appendChild(create("meta", {
	    name: name,
	    content: value
	  }));
	}

	var i18n = {
	  parseFormat: "%Y-%m-%d %H:%i:%s",
	  parseTimeFormat: "%H:%i:%s"
	};

	function stringify(obj) {
	  var origin = Date.prototype.toJSON;

	  Date.prototype.toJSON = function () {
	    return i18n.parseFormatStr(this);
	  };

	  var result;
	  if (obj instanceof Date) result = obj.toJSON();else result = JSON.stringify(obj);
	  Date.prototype.toJSON = origin;
	  return result;
	}

	var global = window;
	var queueId = 1;
	var queue = {};
	var isRunningTask = false;
	if (!global.setImmediate && global.addEventListener) global.addEventListener("message", function (e) {
	  if (e.source == global) {
	    if (isRunningTask) nextTick(queue[e.data]);else {
	      isRunningTask = true;

	      try {
	        queue[e.data]();
	      } catch (e) {// eslint-disable-line
	      }

	      delete queue[e.data];
	      isRunningTask = false;
	    }
	  }
	});

	function nextTick(fn) {
	  if (global.setImmediate) global.setImmediate(fn); // if inside of web worker
	  else if (global.importScripts || !global.addEventListener) setTimeout(fn);else {
	      queueId++;
	      queue[queueId] = fn;
	      global.postMessage(queueId, "*");
	    }
	}

	Deferred.resolve = function (value) {
	  if (!(this._d == 1)) throw TypeError();
	  if (value instanceof Deferred) return value;
	  return new Deferred(function (resolve) {
	    resolve(value);
	  });
	};

	Deferred.reject = function (value) {
	  if (!(this._d == 1)) throw TypeError();
	  return new Deferred(function (resolve, reject) {
	    reject(value);
	  });
	};

	Deferred.all = function (arr) {
	  if (!(this._d == 1)) throw TypeError();
	  if (!(arr instanceof Array)) return Deferred.reject(TypeError());
	  var d = new Deferred();

	  function done(e, v) {
	    if (v) return d.resolve(v);
	    if (e) return d.reject(e);
	    var unresolved = arr.reduce(function (cnt, v) {
	      if (v && v.then) return cnt + 1;
	      return cnt;
	    }, 0);
	    if (unresolved == 0) d.resolve(arr);
	    arr.map(function (v, i) {
	      if (v && v.then) v.then(function (r) {
	        arr[i] = r;
	        done();
	        return r;
	      }, done);
	    });
	  }

	  done();
	  return d;
	};

	Deferred.race = function (arr) {
	  if (!(this._d == 1)) throw TypeError();
	  if (!(arr instanceof Array)) return Deferred.reject(TypeError());
	  if (arr.length == 0) return new Deferred();
	  var d = new Deferred();

	  function done(e, v) {
	    if (v) return d.resolve(v);
	    if (e) return d.reject(e);
	    var unresolved = arr.reduce(function (cnt, v) {
	      if (v && v.then) return cnt + 1;
	      return cnt;
	    }, 0);
	    if (unresolved == 0) d.resolve(arr);
	    arr.map(function (v) {
	      if (v && v.then) v.then(function (r) {
	        done(null, r);
	      }, done);
	    });
	  }

	  done();
	  return d;
	};

	Deferred._d = 1;
	/**
	 * @constructor
	 */

	function Deferred(resolver) {

	  if (typeof resolver != "function" && resolver != undefined) throw TypeError();
	  if (_typeof(this) != "object" || this && this.then) throw TypeError(); // states
	  // 0: pending
	  // 1: resolving
	  // 2: rejecting
	  // 3: resolved
	  // 4: rejected

	  var self = this,
	      state = 0,
	      val = 0,
	      next = [],
	      fn,
	      er;
	  self["promise"] = self;

	  self["resolve"] = function (v) {
	    fn = self.fn;
	    er = self.er;

	    if (!state) {
	      val = v;
	      state = 1;
	      nextTick(fire);
	    }

	    return self;
	  };

	  self["reject"] = function (v) {
	    fn = self.fn;
	    er = self.er;

	    if (!state) {
	      val = v;
	      state = 2;
	      nextTick(fire);
	    }

	    return self;
	  };

	  self["_d"] = 1;

	  self["then"] = function (_fn, _er) {
	    if (!(this._d == 1)) throw TypeError();
	    var d = new Deferred();
	    d.fn = _fn;
	    d.er = _er;

	    if (state == 3) {
	      d.resolve(val);
	    } else if (state == 4) {
	      d.reject(val);
	    } else {
	      next.push(d);
	    }

	    return d;
	  };

	  self["finally"] = function (_handler) {
	    var _value;

	    var handler = function (value) {
	      _value = value;
	      return _handler();
	    };

	    var value = function () {
	      return _value;
	    };

	    return self.then(handler, handler).then(value, value);
	  };

	  self["catch"] = function (_er) {
	    return self["then"](null, _er);
	  }; //compatibility with old version of promiz lib


	  self["fail"] = function (_er) {
	    return self["then"](null, _er);
	  };

	  var finish = function (type) {
	    state = type || 4;

	    for (var i = 0; i < next.length; i++) {
	      var p = next[i];
	      state == 3 && p.resolve(val) || p.reject(val);
	    }
	  };

	  try {
	    if (typeof resolver == "function") resolver(self["resolve"], self["reject"]);
	  } catch (e) {
	    self["reject"](e);
	  }

	  return self; // ref : reference to 'then' function
	  // cb, ec, cn : successCallback, failureCallback, notThennableCallback

	  function thennable(ref, cb, ec, cn) {
	    // Promises can be rejected with other promises, which should pass through
	    if (state == 2) {
	      return cn();
	    }

	    if ((_typeof(val) == "object" || typeof val == "function") && typeof ref == "function") {
	      try {
	        // cnt protects against abuse calls from spec checker
	        var cnt = 0;
	        ref.call(val, function (v) {
	          if (cnt++) return;
	          val = v;
	          cb();
	        }, function (v) {
	          if (cnt++) return;
	          val = v;
	          ec();
	        });
	      } catch (e) {
	        val = e;
	        ec();
	      }
	    } else {
	      cn();
	    }
	  }

	  function fire() {
	    // check if it's a thenable
	    var ref;

	    try {
	      ref = val && val.then;
	    } catch (e) {
	      val = e;
	      state = 2;
	      return fire();
	    }

	    thennable(ref, function () {
	      state = 1;
	      fire();
	    }, function () {
	      state = 2;
	      fire();
	    }, function () {
	      try {
	        if (state == 1 && typeof fn == "function") {
	          val = fn(val);
	        } else if (state == 2 && typeof er == "function") {
	          val = er(val);
	          state = 1;
	        }
	      } catch (e) {
	        val = e;
	        return finish();
	      }

	      if (val == self) {
	        val = TypeError();
	        finish();
	      } else thennable(ref, function () {
	        finish(3);
	      }, finish, function () {
	        finish(state == 1 && 3);
	      });
	    });
	  }
	} // promise factory


	Deferred.defer = function () {
	  return new Deferred(null);
	};

	var xml = {
	  _isValidXML: function (data) {
	    if (!data || !data.documentElement) return null;
	    if (data.getElementsByTagName("parsererror").length) return null;
	    return data;
	  },
	  //convert xml string to xml object if necessary
	  toObject: function (text, response) {
	    var data = response ? response.rawxml ? response.rawxml() : response : null;
	    if (this._isValidXML(data)) return data;
	    if (typeof text == "string") data = this.fromString(text.replace(/^[\s]+/, ""));else data = text;
	    if (this._isValidXML(data)) return data;
	    return null;
	  },
	  //get array of records
	  getRecords: function (data) {
	    return this.xpath(data, this.records);
	  },
	  records: "/*/item",
	  child: "item",
	  config: "/*/config",
	  //get hash of properties for single record
	  getDetails: function (data) {
	    return this.tagToObject(data, {});
	  },
	  getOptions: function () {
	    return false;
	  },
	  //get count of data and position at which new data_loading need to be inserted
	  getInfo: function (data) {
	    var config = this.xpath(data, this.config);
	    if (config.length) config = this.assignTypes(this.tagToObject(config[0], {}));else config = null;
	    return {
	      size: data.documentElement.getAttribute("total_count") || 0,
	      from: data.documentElement.getAttribute("pos"),
	      parent: data.documentElement.getAttribute("parent") || 0,
	      config: config,
	      key: data.documentElement.getAttribute("webix_security") || null
	    };
	  },
	  //xpath helper
	  xpath: function (xml, path) {
	    if (window.XPathResult) {
	      //FF, KHTML, Opera
	      var node = xml;
	      if (xml.nodeName.indexOf("document") == -1) xml = xml.ownerDocument;
	      var res = [];
	      var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
	      var temp = col.iterateNext();

	      while (temp) {
	        res.push(temp);
	        temp = col.iterateNext();
	      }

	      return res;
	    } else {
	      var test = true;

	      try {
	        if (typeof xml.selectNodes == "undefined") test = false;
	      } catch (e) {}
	      /*IE7 and below can't operate with xml object*/
	      //IE


	      if (test) return xml.selectNodes(path);else {
	        //there is no interface to do XPath
	        //use naive approach
	        var name = path.split("/").pop();
	        return xml.getElementsByTagName(name);
	      }
	    }
	  },
	  assignTypes: function (obj) {
	    for (var k in obj) {
	      var test = obj[k];
	      if (_typeof(test) == "object") this.assignTypes(test);else if (typeof test == "string") {
	        if (test === "") continue;
	        if (test == "true") obj[k] = true;else if (test == "false") obj[k] = false;else if (test == test * 1) obj[k] = obj[k] * 1;
	      }
	    }

	    return obj;
	  },
	  //convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	  tagToObject: function (tag, z) {
	    var isArray = tag.nodeType == 1 && tag.getAttribute("stack");
	    var hasSubTags = 0;

	    if (!isArray) {
	      z = z || {}; //map attributes

	      var a = tag.attributes;
	      if (a && a.length) for (var i = 0; i < a.length; i++) {
	        z[a[i].name] = a[i].value;
	        hasSubTags = 1;
	      } //map subtags

	      var b = tag.childNodes;

	      for (var _i = 0; _i < b.length; _i++) {
	        if (b[_i].nodeType == 1) {
	          var name = b[_i].tagName;

	          if (z[name]) {
	            if (typeof z[name].push != "function") z[name] = [z[name]];
	            z[name].push(this.tagToObject(b[_i], {}));
	          } else z[name] = this.tagToObject(b[_i], {}); //sub-object for complex subtags


	          hasSubTags = 2;
	        }
	      }

	      if (!hasSubTags) return this.nodeValue(tag); //each object will have its text content as "value" property
	      //only if has not sub tags

	      if (hasSubTags < 2) z.value = z.value || this.nodeValue(tag);
	    } else {
	      z = [];
	      var _b = tag.childNodes;

	      for (var _i2 = 0; _i2 < _b.length; _i2++) {
	        if (_b[_i2].nodeType == 1) z.push(this.tagToObject(_b[_i2], {}));
	      }
	    }

	    return z;
	  },
	  //get value of xml node 
	  nodeValue: function (node) {
	    if (node.firstChild) {
	      return node.firstChild.wholeText || node.firstChild.data;
	    }

	    return "";
	  },
	  //convert XML string to XML object
	  fromString: function (xmlString) {
	    try {
	      if (window.DOMParser) // FF, KHTML, Opera
	        return new DOMParser().parseFromString(xmlString, "text/xml");
	      /* global ActiveXObject */

	      if (window.ActiveXObject) {
	        // IE, utf-8 only 
	        var temp = new ActiveXObject("Microsoft.xmlDOM");
	        temp.loadXML(xmlString);
	        return temp;
	      }
	    } catch (e) {
	      assert(0, e);
	      return null;
	    }

	    assert(0, "Load from xml string is not supported");
	  }
	};

	var json = {
	  //convert json string to json object if necessary
	  toObject: function (data) {
	    if (!data) return null;

	    if (typeof data == "string") {
	      try {
	        if (this.parseDates) {
	          var isodate = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(.\d{1-3})?Z/;
	          data = JSON.parse(data, function (key, value) {
	            if (typeof value == "string") {
	              if (isodate.test(value)) return new Date(value);
	            }

	            return value;
	          });
	        } else {
	          data = JSON.parse(data);
	        }
	      } catch (e) {
	        log(e);
	        log(data);
	        assert(0, "Invalid JSON data for parsing");
	        return null;
	      }
	    }

	    return data;
	  },
	  //get array of records
	  getRecords: function (data) {
	    if (data && data.data) data = data.data;
	    if (data && !isArray(data)) return [data];
	    return data;
	  },
	  //get hash of properties for single record
	  getDetails: function (data) {
	    if (typeof data == "string") return {
	      id: data || uid(),
	      value: data
	    };
	    return data;
	  },
	  getOptions: function (data) {
	    return data.collections;
	  },
	  //get count of data and position at which new data need to be inserted
	  getInfo: function (data) {
	    return {
	      size: data.total_count || 0,
	      from: data.pos,
	      parent: data.parent || 0,
	      config: data.config,
	      key: data.webix_security
	    };
	  },
	  child: "data",
	  parseDates: false
	};

	var _xhr_aborted = toArray();
	function ajax(url, params, call) {
	  //if parameters was provided - made fast call
	  if (arguments.length !== 0) {
	    return new ajax().get(url, params, call);
	  }

	  if (!this || !this.getXHR) return new ajax(); //allow to create new instance without direct new declaration

	  return this;
	}
	ajax.count = 0;
	ajax.prototype = {
	  master: null,
	  //creates xmlHTTP object
	  getXHR: function () {
	    return new XMLHttpRequest();
	  },
	  stringify: function (obj) {
	    return stringify(obj);
	  },

	  /*
	  	send data to the server
	  	params - hash of properties which will be added to the url
	  	call - callback, can be an object with success and error functions
	  */
	  _send: function (url, params, call, mode) {
	    var master; //webix.ajax(url, callback) - can be called only by user

	    if (params && (isArray(params) || typeof (params.success || params.error || params) == "function")) {
	      master = call;
	      call = params;
	      params = null;
	    }

	    var defer = Deferred.defer();
	    var x = this.getXHR();
	    var headers = this._header || {};
	    if (!callEvent("onBeforeAjax", [mode, url, params, x, headers, null, defer])) return; //add content-type to POST|PUT|DELETE

	    var json_mode = false;

	    if (mode !== "GET") {
	      var found = false;

	      for (var key in headers) {
	        if (key.toString().toLowerCase() == "content-type") {
	          found = true;
	          if (headers[key] == "application/json") json_mode = true;
	        }
	      }

	      if (!found && !(window.FormData && params instanceof window.FormData)) headers["Content-Type"] = "application/x-www-form-urlencoded";
	    } //add extra params to the url


	    if (_typeof(params) == "object" && !(window.FormData && params instanceof window.FormData)) {
	      if (json_mode) params = this.stringify(params);else {
	        var t = [];

	        for (var a in params) {
	          var value = params[a];
	          if (value === null || value === undefined) value = "";
	          if (_typeof(value) === "object") value = this.stringify(value);
	          t.push(a + "=" + encodeURIComponent(value)); // utf-8 escaping
	        }

	        params = t.join("&");
	      }
	    }

	    if (params && mode === "GET") {
	      url = url + (url.indexOf("?") != -1 ? "&" : "?") + params;
	      params = null;
	    }

	    x.open(mode, url, !this._sync);
	    var type = this._response;
	    if (type) x.responseType = type; //if header was provided - use it

	    for (var _key in headers) {
	      x.setRequestHeader(_key, headers[_key]);
	    } //async mode, define loading callback


	    var self = this;
	    this.master = this.master || master;

	    x.onreadystatechange = function () {
	      if (!x.readyState || x.readyState == 4) {
	        ajax.count++;

	        if (!x.aborted) {
	          //IE8 and IE9, handling .abort call
	          if (_xhr_aborted.find(x) != -1) return _xhr_aborted.remove(x);
	          var is_error = x.status >= 400 || x.status === 0;
	          var text, data;

	          if (x.responseType == "blob" || x.responseType == "arraybuffer") {
	            text = "";
	            data = x.response;
	          } else {
	            text = x.responseText || "";
	            data = self._data(x);
	          }

	          if (is_error) {
	            callEvent("onAjaxError", [x]);
	            defer.reject(x);
	            if (call) ajax.$callback(self.master || window, call, text, data, x, is_error);
	          } else {
	            defer.resolve(data);
	            if (call) ajax.$callback(self.master || window, call, text, data, x, is_error);
	          }
	        } else {
	          //anti-leak
	          self.master = null;
	          call = self = master = null;
	        }
	      }
	    };

	    if (this._timeout) x.timeout = this._timeout; //IE can use sync mode sometimes, fix it

	    if (!this._sync) setTimeout(function () {
	      if (!x.aborted) {
	        //abort handling in IE9
	        if (_xhr_aborted.find(x) != -1) _xhr_aborted.remove(x);else {
	          x.send(params || null);
	        }
	      }
	    }, 1);else x.send(params || null);

	    if (this.master && this.master._ajax_queue && !this._sync) {
	      this.master._ajax_queue.push(x);

	      defer.then(function (data) {
	        self.master._ajax_queue.remove(x); //anti-leak


	        self.master = null;
	        call = self = master = null;
	        return data;
	      });
	    }

	    return this._sync ? x : defer; //return XHR, which can be used in case of sync. mode
	  },
	  _data: function (x) {
	    return {
	      xml: function () {
	        try {
	          return xml.tagToObject(xml.toObject(x.responseText, this));
	        } catch (e) {
	          log(x.responseText);
	          log(e.toString());
	          assert(0, "Invalid xml data for parsing");
	        }
	      },
	      rawxml: function () {
	        if (!window.XPathResult) return xml.fromString(x.responseText);
	        return x.responseXML;
	      },
	      text: function () {
	        return x.responseText;
	      },
	      json: function () {
	        return json.toObject(x.responseText, false);
	      }
	    };
	  },
	  //GET request
	  get: function (url, params, call) {
	    return this._send(url, params, call, "GET");
	  },
	  //POST request
	  post: function (url, params, call) {
	    return this._send(url, params, call, "POST");
	  },
	  //PUT request
	  put: function (url, params, call) {
	    return this._send(url, params, call, "PUT");
	  },
	  //DELETE request
	  del: function (url, params, call) {
	    return this._send(url, params, call, "DELETE");
	  },
	  //PATCH request
	  patch: function (url, params, call) {
	    return this._send(url, params, call, "PATCH");
	  },
	  sync: function () {
	    this._sync = true;
	    return this;
	  },
	  timeout: function (num) {
	    this._timeout = num;
	    return this;
	  },
	  response: function (value) {
	    this._response = value;
	    return this;
	  },
	  headers: function (header) {
	    this._header = exports.extend(this._header || {}, header);
	    return this;
	  },
	  bind: function (master) {
	    this.master = master;
	    return this;
	  }
	};

	ajax.$callback = function (owner, call, text, data, x, is_error) {
	  if (owner.$destructed) return;
	  if (x === -1 && data && typeof data.json == "function") data = data.json();
	  if (is_error) callEvent("onAjaxError", [x]);

	  if (call) {
	    var method = call.success || call;
	    if (is_error) method = call.error;
	    if (method && method.call) method.call(owner, text, data, x);
	  }
	};

	var CodeParser = {
	  //converts a complex object into an object with primitives properties
	  collapseNames: function (base, prefix, data) {
	    data = data || {};
	    prefix = prefix || "";
	    if (!base || _typeof(base) != "object") return null;

	    for (var prop in base) {
	      if (base[prop] && _typeof(base[prop]) == "object" && !isDate(base[prop]) && !isArray(base[prop])) {
	        CodeParser.collapseNames(base[prop], prefix + prop + ".", data);
	      } else {
	        data[prefix + prop] = base[prop];
	      }
	    }

	    return data;
	  },
	  //converts an object with primitive properties into an object with complex properties
	  expandNames: function (base) {
	    var data = {},
	        i,
	        lastIndex,
	        name,
	        obj,
	        prop;

	    for (prop in base) {
	      name = prop.split(".");
	      lastIndex = name.length - 1;
	      obj = data;

	      for (i = 0; i < lastIndex; i++) {
	        if (!obj[name[i]]) obj[name[i]] = {};
	        obj = obj[name[i]];
	      }

	      obj[name[lastIndex]] = base[prop];
	    }

	    return data;
	  }
	};

	/*
		Template - handles html templates
	*/
	var _cache = {};
	var _csp_cache = {};
	var newlines = new RegExp("(\\r\\n|\\n)", "g");
	var quotes = new RegExp("(\\\")", "g");
	var slashes = new RegExp("(\\\\)", "g");
	var escape$1 = {
	  "&": "&amp;",
	  "<": "&lt;",
	  ">": "&gt;",
	  "\"": "&quot;",
	  "'": "&#x27;",
	  "`": "&#x60;"
	};
	var badChars = /[&<>"'`]/g;

	var escapeChar = function (chr) {
	  return escape$1[chr] || "&amp;";
	};

	function template(str) {
	  if (typeof str == "function") return str;
	  if (_cache[str]) return _cache[str];
	  str = (str || "").toString();

	  if (str.indexOf("->") != -1) {
	    var teststr = str.split("->");

	    switch (teststr[0]) {
	      case "html":
	        //load from some container on the page
	        str = getValue(teststr[1]);
	        break;

	      case "http":
	        //load from external file
	        str = new ajax().sync().get(teststr[1], {
	          uid: uid()
	        }).responseText;
	        break;

	      default:
	        //do nothing, will use template as is
	        break;
	    }
	  } //supported idioms
	  // {obj.attr} => named attribute or value of sub-tag in case of xml


	  str = (str || "").toString(); // Content Security Policy enabled

	  if (env.strict) {
	    if (!_csp_cache[str]) {
	      _csp_cache[str] = []; // get an array of objects (not sorted by position)

	      var temp_res = [];
	      str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g, function (search, s1, s2, s3, pos$$1) {
	        temp_res.push({
	          pos: pos$$1,
	          str: search,
	          fn: function (obj) {
	            return obj[s1] ? s2 : s3;
	          }
	        });
	      });
	      str.replace(/\{common\.([^}(]*)\}/g, function (search, s, pos$$1) {
	        temp_res.push({
	          pos: pos$$1,
	          str: search,
	          fn: function (_, common) {
	            return common[s] || "";
	          }
	        });
	      });
	      str.replace(/\{common\.([^}(]*)\(\)\}/g, function (search, s, pos$$1) {
	        temp_res.push({
	          pos: pos$$1,
	          str: search,
	          fn: function (obj, common) {
	            return common[s] ? common[s].apply(this, arguments) : "";
	          }
	        });
	      });
	      str.replace(/\{obj\.([^:}]*)\}/g, function (search, s, pos$$1) {
	        temp_res.push({
	          pos: pos$$1,
	          str: search,
	          fn: function (obj) {
	            return obj[s];
	          }
	        });
	      });
	      str.replace("{obj}", function (search, pos$$1) {
	        temp_res.push({
	          pos: pos$$1,
	          str: search,
	          fn: function (obj) {
	            return obj;
	          }
	        });
	      });
	      str.replace(/#([^#'";, ]+)#/gi, function (search, s, pos$$1) {
	        if (s.charAt(0) == "!") {
	          s = s.substr(1);
	          temp_res.push({
	            pos: pos$$1,
	            str: search,
	            fn: function (obj) {
	              if (s.indexOf(".") != -1) obj = CodeParser.collapseNames(obj); // apply complex properties

	              return template.escape(obj[s]);
	            }
	          });
	        } else {
	          temp_res.push({
	            pos: pos$$1,
	            str: search,
	            fn: function (obj) {
	              if (s.indexOf(".") != -1) obj = CodeParser.collapseNames(obj); // apply complex properties

	              return obj[s];
	            }
	          });
	        }
	      }); // sort template parts by position

	      temp_res.sort(function (a, b) {
	        return a.pos > b.pos ? 1 : -1;
	      }); // create an array of functions that return parts of html string

	      if (temp_res.length) {
	        var lastPos = 0;

	        var addStr = function (str, n0, n1) {
	          _csp_cache[str].push(function () {
	            return str.slice(n0, n1);
	          });
	        };

	        for (var i = 0; i < temp_res.length; i++) {
	          var pos$$1 = temp_res[i].pos;
	          addStr(str, lastPos, pos$$1);

	          _csp_cache[str].push(temp_res[i].fn);

	          lastPos = pos$$1 + temp_res[i].str.length;
	        }

	        addStr(str, lastPos, str.length);
	      } else _csp_cache[str].push(function () {
	        return str;
	      });
	    }

	    return function () {
	      var s = "";

	      for (var i = 0; i < _csp_cache[str].length; i++) {
	        s += _csp_cache[str][i].apply(this, arguments);
	      }

	      return s;
	    };
	  }

	  var helpers = false;
	  str = str.replace(slashes, "\\\\");
	  str = str.replace(newlines, "\\n");
	  str = str.replace(quotes, "\\\"");
	  str = str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g, "\"+(obj.$1?\"$2\":\"$3\")+\"");
	  str = str.replace(/\{common\.([^}(]*)\}/g, "\"+(common.$1||'')+\"");
	  str = str.replace(/\{common\.([^}(]*)\(\)\}/g, "\"+(common.$1?common.$1.apply(this, arguments):\"\")+\"");
	  str = str.replace(/\{obj\.([^}]*)\}/g, "\"+(obj.$1)+\"");
	  str = str.replace("{obj}", "\"+obj+\"");
	  str = str.replace(/#([^#'";, ]+)#/gi, function (str, key) {
	    if (key.charAt(0) == "!") {
	      helpers = true;
	      return "\"+template.escape(obj." + key.substr(1) + ")+\"";
	    } else return "\"+(obj." + key + ")+\"";
	  });

	  try {
	    if (helpers) {
	      var temp = Function("obj", "common", "marks", "value", "template", "return \"" + str + "\";");

	      _cache[str] = function (a, b, c, d) {
	        return temp(a, b, c, d, template);
	      };
	    } else {
	      _cache[str] = Function("obj", "common", "return \"" + str + "\";");
	    }
	  } catch (e) {
	    assert(0, "Invalid template:" + str);
	  }

	  return _cache[str];
	}

	template.escape = function (str) {
	  if (str === undefined || str === null) return "";
	  return (str.toString() || "").replace(badChars, escapeChar);
	};

	template.empty = function () {
	  return "";
	};

	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/

	function type(obj, data) {
	  if (obj.$protoWait) {
	    if (!obj._webix_type_wait) obj._webix_type_wait = [];

	    obj._webix_type_wait.push(data);

	    return;
	  } //auto switch to prototype, if name of class was provided


	  if (typeof obj == "function") obj = obj.prototype;

	  if (!obj.types) {
	    obj.types = {
	      "default": obj.type
	    };
	    obj.type.name = "default";
	  }

	  var name = data.name;
	  var type = obj.type;
	  if (name) type = obj.types[name] = clone(data.baseType ? obj.types[data.baseType] : obj.type);

	  for (var key in data) {
	    if (key.indexOf("template") === 0) type[key] = template(data[key]);else type[key] = data[key];
	  }

	  return name;
	}

	var views = {};

	function ui(config, parent, id) {
	  var res;
	  state._ui_creation++; // save old value of global scope

	  var temp = state._global_scope; // set global scope to the scope of new UI or to previous value
	  // as result inner webix.ui calls will have access the scope of master view
	  // mainly necessary for suggests

	  state._global_scope = config.$scope || temp;

	  try {
	    res = _ui_creator(config, parent, id);
	  } finally {
	    state._ui_creation--; // restore global scope

	    state._global_scope = temp;
	  }

	  return res;
	}

	ui.views = views;

	function _ui_creator(config, parent, id) {
	  var multiset = isArray(config);
	  var node = toNode(config.container || parent || document.body); // solve problem with non-unique ids

	  if (node._settings) id = _correctId(node, multiset, id);
	  var top_node;
	  var moving = false;
	  var body_child = node == document.body;

	  if (config._settings || node && multiset) {
	    top_node = config;
	    moving = true;
	  } else {
	    if (node && body_child) config.$topView = true;
	    if (!config._inner) config._inner = {};

	    if (parent && parent.getParentView) {
	      state._parent_cell = !id && id !== 0 ? parent.getParentView() : parent;
	    }

	    top_node = _view(config);
	  }

	  if (body_child && !top_node.setPosition && !top_node.$apiOnly) use("_fixHeight")();

	  if (top_node._settings && top_node._settings._hidden && !node.$view) {
	    top_node._settings._container = node;
	  } else if (!top_node.$apiOnly) {
	    if (node.appendChild) _appendDom(node, top_node, config);else if (node.destructor) {
	      var target = node; //addView or view moving with target id

	      if (!id && id !== 0 && !isArray(top_node)) {
	        id = node;
	        node = node.getParentView();
	      } //if target supports view adding


	      if (node && node._replace) {
	        if (moving && top_node.getParentView) {
	          //if source supports view removing
	          var _parent = top_node.getParentView();

	          if (_parent && _parent._remove) {
	            _parent._remove(top_node);
	          } //adjust parent link and scope


	          top_node._parent_cell = node;
	          top_node.$scope = node.$scope;
	        }

	        node._replace(top_node, id);
	      } else {
	        var _parent2 = target.$view.parentNode;
	        target.destructor();

	        _appendDom(_parent2, top_node, config);
	      }
	    } else assert(0, "Not existing parent:" + config.container);
	  }

	  return top_node;
	}

	function _appendDom(node, top_node, config) {
	  node.appendChild(top_node._viewobj);
	  if (top_node.getParentView()) return; //resize window with position center or top
	  //do not resize other windows and elements
	  // which are attached to custom html containers

	  if ((!top_node.setPosition || top_node._settings.fullscreen) && node == document.body || top_node._settings.position) state.top_views.push(top_node._destructor_handler);
	  if (!config.skipResize) top_node.adjust();
	}

	function _correctId(target, multiset, id) {
	  //replace view
	  var views = [target]; //replace content of layout

	  if (multiset) views = target.getChildViews(); //replace content of window
	  else if (target._body_cell) views = [target._body_cell]; //add cell in layout by number
	    else if (typeof id == "number") {
	        return id; //replace cell in layout by id
	      } else if (id) {
	        views = [$$(id)];

	        _deleteIds(views);

	        return views[0].config.id;
	      }

	  _deleteIds(views);

	  return id;
	}

	function _deleteIds(uis) {
	  for (var i = uis.length - 1; i >= 0; i--) {
	    var current = uis[i]; //remove original id

	    delete views[current.config.id]; //create temp id

	    current.config.id = "x" + uid();
	    views[current.config.id] = current; //process childs

	    if (current.getChildViews) _deleteIds(current.getChildViews()); //process related UI

	    if (current._destroy_with_me) _deleteIds(current._destroy_with_me);
	  }
	}

	function hasMethod(view, method) {
	  var obj = ui[view];
	  if (!obj) return false;
	  if (obj.$protoWait) obj = obj.call(-1);
	  return !!ui[view].prototype[method];
	}

	function _view(config) {
	  {
	    // check for trailing comma
	    var coll = config.cells || config.rows || config.elements || config.cols;
	    if (coll) for (var i = 0; i < coll.length; i++) {
	      if (coll[i] === null || typeof coll[i] === "undefined") assert(0, "You have trailing comma or Null element in collection's configuration");
	    }
	  }

	  if (config.view) {
	    var view = config.view;
	    assert(ui[view], "unknown view:" + view);
	    return new ui[view](config);
	  } else if (config.rows || config.cols) {
	    var cells = config.rows || config.cols;
	    var accordion = false;

	    for (var _i = 0; _i < cells.length; _i++) {
	      if (cells[_i].body && !cells[_i].view && !cells[_i].align) accordion = true;
	    }

	    if (accordion) {
	      return new ui.headerlayout(config);
	    } else return new ui.layout(config);
	  } else if (config.cells) return new ui.multiview(config);else if (config.template || config.content) return new ui.template(config);else if (config.align && config.body) {
	    return new ui.align(config);
	  } else return new ui.spacer(config);
	} //FIXME


	ui._view = _view;

	function $$(id) {
	  if (!id) return null;
	  if (views[id]) return views[id];
	  var name = id;

	  if (_typeof(id) == "object") {
	    if (id._settings) return id;
	    name = id.target || id.srcElement || id;
	  }

	  return views[locate({
	    target: toNode(name)
	  }, "view_id")];
	}

	if (typeof window.$$ === "undefined") window.$$ = $$;

	exports.protoUI = function () {
	  var origins = arguments;
	  var selfname = origins[0].name;

	  var t = function (data) {
	    if (!t) return ui[selfname].prototype;
	    var origins = t.$protoWait;

	    if (origins) {
	      var params = [origins[0]];

	      for (var i = 1; i < origins.length; i++) {
	        params[i] = origins[i];
	        if (params[i].$protoWait) params[i] = params[i].call(-1, params[i].name);
	        if (params[i].prototype && params[i].prototype.name) ui[params[i].prototype.name] = params[i];
	      }

	      ui[selfname] = exports.proto.apply(-1, params);
	      if (t._webix_type_wait) for (var _i2 = 0; _i2 < t._webix_type_wait.length; _i2++) {
	        type(ui[selfname], t._webix_type_wait[_i2]);
	      }
	      t = origins = null;
	    }

	    if (this != -1) return new ui[selfname](data);else return ui[selfname];
	  };

	  t.$protoWait = Array.prototype.slice.call(arguments, 0);
	  return ui[selfname] = t;
	};

	exports.proto = function () {
	  var origins = arguments;
	  var compilation = origins[0];
	  var has_constructor = !!compilation.$init;
	  var construct = [];
	  assert(compilation, "Invalid mixing target");

	  for (var i = origins.length - 1; i > 0; i--) {
	    assert(origins[i], "Invalid mixing source");
	    if (typeof origins[i] == "function") origins[i] = origins[i].prototype;
	    if (origins[i].$init) construct.push(origins[i].$init);

	    if (origins[i].defaults) {
	      var defaults = origins[i].defaults;
	      if (!compilation.defaults) compilation.defaults = {};

	      for (var def in defaults) {
	        if (isUndefined(compilation.defaults[def])) compilation.defaults[def] = defaults[def];
	      }
	    }

	    if (origins[i].type && compilation.type) {
	      for (var _def in origins[i].type) {
	        if (!compilation.type[_def]) compilation.type[_def] = origins[i].type[_def];
	      }
	    }

	    for (var key in origins[i]) {
	      if (!compilation[key] && compilation[key] !== false) compilation[key] = origins[i][key];
	    }
	  }

	  if (has_constructor) construct.push(compilation.$init);

	  compilation.$init = function () {
	    for (var i = 0; i < construct.length; i++) {
	      construct[i].apply(this, arguments);
	    }
	  };

	  if (compilation.$skin) compilation.$skin();

	  var result = function (config) {
	    this.$ready = [];
	    assert(this.$init, "object without init method");
	    this.$init(config);
	    if (this._parseSettings) this._parseSettings(config, this.defaults);

	    for (var i = 0; i < this.$ready.length; i++) {
	      this.$ready[i].call(this);
	    }
	  };

	  result.prototype = compilation;
	  compilation = origins = null;
	  return result;
	};

	attachEvent("onClick", function (e) {
	  var element = $$(e);

	  if (element && element.touchable) {
	    use("UIManager").applyChanges(element); //for inline elements - restore pointer to the master element

	    element.getNode(e); //reaction on custom css elements in buttons

	    var trg = e.target || e.srcElement;
	    if (trg.className == "webix_disabled") return;
	    var css = "";
	    if (trg.className && trg.className.toString().indexOf("webix_view") === 0) return;
	    if (element) use("UIManager")._focus_action(element); //loop through all parents

	    while (trg && trg.parentNode) {
	      if (trg.getAttribute) {
	        if (trg.getAttribute("view_id")) break;
	        css = trg.className;

	        if (css) {
	          css = css.toString().split(" ");

	          for (var i = 0; i < css.length; i++) {
	            if (element.on_click[css[i]]) {
	              var res = element.on_click[css[i]].call(element, e, element._settings.id, trg);
	              if (res === false) return;
	            }
	          }
	        }
	      }

	      trg = trg.parentNode;
	    }

	    if (element._settings.click) {
	      var code = toFunctor(element._settings.click, element.$scope);
	      if (code && code.call) code.call(element, element._settings.id, e);
	    }

	    var popup = element._settings.popup;

	    if (element._settings.popup && !element._settings.readonly) {
	      if (_typeof(popup) == "object" && !popup.name) popup = element._settings.popup = ui(popup)._settings.id;
	      popup = $$(popup);
	      assert(popup, "Unknown popup");

	      if (!popup.isVisible()) {
	        popup._settings.master = element._settings.id;
	        popup.show(element.getInputNode() || element.getNode(), null, true);
	      }
	    }

	    element.callEvent("onItemClick", [element._settings.id, e]);
	  }
	}); //hook for documentation generator

	{
	  if (window.webix_on_core_ready) {
	    var mod = window.webix_on_core_ready({
	      proto: exports.proto,
	      protoUI: exports.protoUI
	    });
	    exports.proto = mod.proto;
	    exports.protoUI = mod.protoUI;
	  }
	}

	var _events = {};
	function _events_final_destructor() {
	  //detach all known DOM events
	  for (var a in _events) {
	    eventRemove(a);
	  }
	} //private version of API, do not register ID for event detaching

	function _event(a, b, c, d) {
	  d = d || {};
	  d.inner = true;
	  event$1(a, b, c, d);
	} //attach event to the DOM element

	function event$1(node, event, handler, context) {
	  context = context || {};
	  node = toNode(node);
	  assert(node, "Invalid node as target for webix.event");
	  var id = context.id || uid();
	  if (context.bind) handler = bind(handler, context.bind);
	  var info = [node, event, handler, context.capture];
	  if (!context.inner) _events[id] = info; //store event info, for detaching

	  var capture = !!context.capture;
	  if (!isUndefined(context.passive) && env.passiveEventListeners) //blockable touch events
	    capture = {
	      passive: context.passive,
	      capture: capture
	    }; //use IE's of FF's way of event's attaching

	  if (node.addEventListener) node.addEventListener(event, handler, capture);else if (node.attachEvent) node.attachEvent("on" + event, info[2] = function () {
	    return handler.apply(node, arguments); //IE8 fix
	  });
	  return id; //return id of newly created event, can be used in eventRemove
	} //remove previously attached event

	function eventRemove(id) {
	  if (!id) return;
	  assert(_events[id], "Removing non-existing event");
	  var ev = _events[id]; //browser specific event removing

	  if (ev[0].removeEventListener) ev[0].removeEventListener(ev[1], ev[2], !!ev[3]);else if (ev[0].detachEvent) ev[0].detachEvent("on" + ev[1], ev[2]);
	  delete _events[id]; //delete all traces
	}

	var ActiveContent = {
	  $init: function (config) {
	    if (config.activeContent) {
	      this.$ready.push(this._init_active_content_list);
	      this._active_holders = {};
	      this._active_holders_item = {};
	      this._active_holders_values = {};
	      this._active_references = {};

	      for (var key in config.activeContent) {
	        this[key] = this._bind_active_content(key);

	        if (config.activeContent[key].earlyInit) {
	          var temp = state._parent_cell;
	          state._parent_cell = null;
	          this[key].call(this, {}, this, config.activeContent);
	          state._parent_cell = temp;
	        }
	      }
	    }
	  },
	  _destructActiveContent: function () {
	    for (var key in this._active_references) {
	      var elem = this._active_references[key];
	      if (elem.destructor) elem.destructor();
	    }
	  },
	  _init_active_content_list: function () {
	    this.attachEvent("onDestruct", bind(this._destructActiveContent, this));

	    _event(this.$view, "blur", function (ev) {
	      var target = ev.target || ev.srcElement; // for inputs only

	      if (target.tagName != "BUTTON") {
	        var el = $$(ev);

	        if (el && el !== this && el.getValue && el.setValue) {
	          el.getNode(ev);
	          var newvalue = el.getValue();
	          if (newvalue != el._settings.value) el.setValue(newvalue);
	        }
	      }
	    }, {
	      bind: this,
	      capture: true
	    });

	    if (this.filter) {
	      for (var key in this._settings.activeContent) {
	        this.type[key] = this[key];
	        this[key] = this._locate_active_content_by_id(key);
	      } //really bad!


	      this.attachEvent("onBeforeRender", function () {
	        this.type.masterUI = this;
	      });
	      this.type.masterUI = this;
	    }
	  },
	  _locate_active_content_by_id: function (key) {
	    return function (id) {
	      var button = this._active_references[key];
	      var button_id = button._settings.id;
	      var html = this.getItemNode(id).getElementsByTagName("DIV");

	      for (var i = 0; i < html.length; i++) {
	        if (html[i].getAttribute("view_id") == button_id) {
	          button._viewobj = button._dataobj = html[i];
	          break;
	        }
	      }

	      return button;
	    };
	  },
	  _get_active_node: function (el, key, master) {
	    return function (e) {
	      if (e) {
	        var trg = e.target || e.srcElement;

	        while (trg) {
	          if (trg.getAttribute && trg.getAttribute("view_id")) {
	            master._setActiveContentView(el, trg);

	            if (master.locate) {
	              var id = master.locate(trg.parentNode);
	              var value = master._active_holders_values[key][id];
	              el._settings.value = value;
	              el._settings.$masterId = id;
	            }

	            return trg;
	          }

	          trg = trg.parentNode;
	        }
	      }

	      return el._viewobj;
	    };
	  },
	  _set_new_active_value: function (key, master) {
	    return function (value) {
	      var data = master.data;

	      if (master.filter) {
	        var id = master.locate(this._viewobj.parentNode);
	        data = master.getItem(id); //XMLSerializer - FF "feature"

	        this.refresh();
	        master._active_holders_item[key][id] = this._viewobj.outerHTML || new XMLSerializer().serializeToString(this._viewobj);
	        master._active_holders_values[key][id] = value;
	      }

	      if (data) data[key] = value;
	    };
	  },
	  _bind_active_content: function (key) {
	    return function (obj, common, active) {
	      var object = common._active_holders ? common : common.masterUI;

	      if (!object._active_holders[key]) {
	        var d = document.createElement("DIV");
	        active = active || object._settings.activeContent;
	        var el = ui(active[key], d);

	        if (env.isIE8) {
	          d.firstChild.setAttribute("onclick", "event.processed = true; event.srcElement.w_view = '" + el._settings.id + "';");
	        } else {
	          d.firstChild.setAttribute("onclick", "event.processed = true; ");
	        }

	        el.getNode = object._get_active_node(el, key, object);
	        el.attachEvent("onChange", object._set_new_active_value(key, object));
	        object._active_references[key] = el;
	        object._active_holders[key] = d.innerHTML;
	        object._active_holders_item[key] = {};
	        object._active_holders_values[key] = {};
	        el.$activeEl = el.$view;
	      }

	      if (object.filter && obj[key] != object._active_holders_values[key] && !isUndefined(obj[key])) {
	        var _el = object._active_references[key];

	        _el.blockEvent();

	        object._setActiveContentView(_el, _el.$activeEl); //in IE we can lost content of active element during parent repainting


	        if (!_el.$view.firstChild) _el.refresh();

	        _el.setValue(obj[key]);

	        _el.refresh();

	        _el.unblockEvent();

	        object._active_holders_values[key][obj.id] = obj[key];
	        object._active_holders_item[key][obj.id] = _el._viewobj.outerHTML || new XMLSerializer().serializeToString(_el._viewobj);
	      }

	      return object._active_holders_item[key][obj.id] || object._active_holders[key];
	    };
	  },
	  _setActiveContentView: function (el, view) {
	    el._dataobj = el._viewobj = el.$view = view;
	  }
	};

	var proxy = {
	  $proxy: true,
	  load: function () {
	    var parts = this.source.split("@");
	    var ext = parts[0].split(".").pop();
	    return ajax().response("arraybuffer").get(parts[0]).then(function (res) {
	      var options = {
	        ext: ext,
	        dataurl: parts[1]
	      };
	      return {
	        data: res,
	        options: options
	      };
	    });
	  }
	};

	var proxy$1 = {
	  $proxy: true,
	  connectorName: "!nativeeditor_status",
	  load: function () {
	    return ajax(this.source);
	  },
	  saveAll: function (view, updates) {
	    var url = this.source;
	    var data = {};
	    var ids = [];

	    for (var i = 0; i < updates.length; i++) {
	      var action = updates[i];
	      ids.push(action.id);

	      for (var j in action.data) {
	        if (j.indexOf("$") !== 0) data[action.id + "_" + j] = action.data[j];
	      }

	      data[action.id + "_" + this.connectorName] = action.operation;
	    }

	    data.ids = ids.join(",");
	    data.webix_security = state.securityKey;
	    url += url.indexOf("?") == -1 ? "?" : "&";
	    url += "editing=true";
	    return ajax().post(url, data).then(function (data) {
	      data = data.xml();
	      if (!data) throw "Data loading error";
	      var actions = data.data.action;
	      if (!actions.length) actions = [actions];
	      var hash = [];

	      for (var i = 0; i < actions.length; i++) {
	        var obj = actions[i];
	        obj.status = obj.type;
	        obj.id = obj.sid;
	        obj.newid = obj.tid;
	        hash.push(obj);
	      }

	      return hash;
	    });
	  }
	};

	var proxy$2 = {
	  $proxy: true,
	  load: function () {},
	  save: function (v, u, d) {
	    delay(function () {
	      window.console.log("[DP] " + u.id + " -> " + u.operation, u.data);
	      var data = {
	        id: u.data.id,
	        newid: u.data.id,
	        status: u.data.operation
	      };
	      d.processResult(data, data);
	    });
	  }
	};

	var proxy$3 = {
	  $proxy: true,
	  init: function () {
	    this.clientId = this.clientId || uid();
	  },
	  load: function (view) {
	    var selfid = this.clientId;
	    this.client.subscribe(this.source, function (update) {
	      if (update.clientId == selfid) return;
	      use("dp")(view).ignore(function () {
	        if (update.operation == "delete") view.remove(update.data.id);else if (update.operation == "insert") view.add(update.data);else if (update.operation == "update") {
	          var item = view.getItem(update.data.id);

	          if (item) {
	            exports.extend(item, update.data, true);
	            view.refresh(item.id);
	          }
	        }
	      });
	    });
	  },
	  save: function (view, update) {
	    update.clientId = this.clientId;
	    this.client.publish(this.source, update);
	  }
	};

	var indexdb = {
	  $proxy: true,
	  create: function (db, config, version, callback) {
	    this.source = db + "/";

	    this._get_db(callback, version, function (e) {
	      var db = e.target.result;

	      for (var key in config) {
	        var data = config[key];
	        var store = db.createObjectStore(key, {
	          keyPath: "id",
	          autoIncrement: true
	        });

	        for (var i = 0; i < data.length; i++) {
	          store.put(data[i]);
	        }
	      }
	    });
	  },
	  _get_db: function (callback, version, upgrade) {
	    if (this.source.indexOf("/") != -1) {
	      var parts = this.source.split("/");
	      this.source = parts[1];
	      version = version || parts[2];

	      var _index = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB;

	      var db;
	      if (version) db = _index.open(parts[0], version);else db = _index.open(parts[0]);
	      if (upgrade) db.onupgradeneeded = upgrade;

	      db.onerror = function () {};

	      db.onblocked = function () {};

	      db.onsuccess = bind(function (e) {
	        this.db = e.target.result;
	        if (callback) callback.call(this);
	      }, this);
	    } else if (this.db) callback.call(this);else delay(this._get_db, this, [callback], 50);
	  },
	  load: function () {
	    var waitData = Deferred.defer();

	    this._get_db(function () {
	      var store = this.db.transaction(this.source).objectStore(this.source);
	      var data = [];
	      var req = store.openCursor();

	      req.onsuccess = function (e) {
	        var result = e.target.result;

	        if (result) {
	          data.push(result.value);
	          result["continue"]();
	        } else {
	          waitData.resolve(data);
	        }
	      };

	      req.onerror = function (e) {
	        waitData.reject(e);
	      };
	    });

	    return waitData;
	  },
	  save: function (view, update) {
	    var waitData = Deferred.defer();

	    this._get_db(function () {
	      var mode = update.operation;
	      var data = update.data;
	      var id = update.id;
	      var store = this.db.transaction([this.source], "readwrite").objectStore(this.source);
	      var req;
	      if (mode == "delete") req = store["delete"](id);else if (mode == "update") req = store.put(data);else if (mode == "insert") {
	        delete data.id;
	        req = store.add(data);
	      }

	      req.onsuccess = function (e) {
	        var result = {
	          status: mode,
	          id: update.id
	        };
	        if (mode == "insert") result.newid = e.target.result;
	        waitData.resolve(result);
	      };

	      req.onerror = function (e) {
	        waitData.reject(e);
	      };
	    });

	    return waitData;
	  }
	};

	var proxy$4 = {
	  $proxy: true,
	  load: function () {
	    return ajax(this.source);
	  },
	  save: function (view, update) {
	    return proxy$4._save_logic.call(this, update, ajax());
	  },
	  _save_logic: function (update, ajax$$1) {
	    var url = this.source;
	    var query = "";
	    var mark = url.indexOf("?");

	    if (mark !== -1) {
	      query = url.substr(mark);
	      url = url.substr(0, mark);
	    }

	    url += url.charAt(url.length - 1) == "/" ? "" : "/";
	    var mode = update.operation;
	    var data = update.data;
	    if (mode == "insert") delete data.id; //call rest URI

	    if (mode == "update") {
	      return ajax$$1.put(url + data.id + query, data);
	    } else if (mode == "delete") {
	      return ajax$$1.del(url + data.id + query, data);
	    } else {
	      return ajax$$1.post(url + query, data);
	    }
	  }
	};

	var proxy$5 = {
	  $proxy: true,
	  load: function () {
	    return ajax(this.source);
	  },
	  save: function (view, update) {
	    var xhr = ajax().headers({
	      "Content-Type": "application/json"
	    });
	    return proxy$4._save_logic.call(this, update, xhr);
	  }
	};

	var proxy$6 = {
	  $proxy: true,
	  load: function (view, params) {
	    params = exports.extend(params || {}, this.params || {}, true);
	    return ajax().post(this.source, params);
	  }
	};

	var jsarray = {
	  //parse jsarray string to jsarray object if necessary
	  toObject: function (data) {
	    if (typeof data == "string") return JSON.parse(data);
	    return data;
	  },
	  //get array of records
	  getRecords: function (data) {
	    if (data && data.data) data = data.data;
	    return data;
	  },
	  //get hash of properties for single record, in case of array they will have names as "data{index}"
	  getDetails: function (data) {
	    var result = {};

	    for (var i = 0; i < data.length; i++) {
	      result["data" + i] = data[i];
	    }

	    if (this.idColumn !== null) result.id = data[this.idColumn];
	    return result;
	  },
	  getOptions: function () {
	    return false;
	  },
	  //dyn loading is not supported by js-array data source
	  getInfo: function () {
	    return {
	      size: 0
	    };
	  },
	  idColumn: null
	};

	var csv = {
	  //incoming data always a string
	  toObject: function (data) {
	    return data;
	  },
	  //get array of records
	  getRecords: function (data) {
	    return data.split(this.row);
	  },
	  //get hash of properties for single record, data named as "data{index}"
	  getDetails: function (data) {
	    data = this.stringToArray(data);
	    var result = {};

	    for (var i = 0; i < data.length; i++) {
	      result["data" + i] = data[i];
	    }

	    if (this.idColumn !== null) result.id = data[this.idColumn];
	    return result;
	  },
	  getOptions: function () {
	    return false;
	  },
	  //dyn loading is not supported by csv data source
	  getInfo: function () {
	    return {
	      size: 0
	    };
	  },
	  //split string in array, takes string surrounding quotes in account
	  stringToArray: function (data) {
	    data = data.split(this.cell);

	    for (var i = 0; i < data.length; i++) {
	      data[i] = data[i].replace(/^[ \t\n\r]*("|)/g, "").replace(/("|)[ \t\n\r]*$/g, "");
	    }

	    return data;
	  },
	  idColumn: null,
	  row: "\n",
	  //default row separator
	  cell: "," //default cell separator

	};

	var html = {
	  /*
	  	incoming data can be
	  	 - ID of parent container
	  	 - HTML text
	  */
	  toObject: function (data) {
	    if (typeof data == "string") {
	      var t = null;
	      if (data.indexOf("<") == -1) //if no tags inside - probably its an ID
	        t = toNode(data);

	      if (!t) {
	        t = document.createElement("DIV");
	        t.innerHTML = data;
	      }

	      return t.firstChild;
	    }

	    return data;
	  },
	  //get array of records
	  getRecords: function (node) {
	    return node.getElementsByTagName(this.tag);
	  },
	  //get hash of properties for single record
	  getDetails: function (data) {
	    return xml.tagToObject(data);
	  },
	  getOptions: function () {
	    return false;
	  },
	  //dyn loading is not supported by HTML data source
	  getInfo: function () {
	    return {
	      size: 0
	    };
	  },
	  tag: "LI"
	};

	var htmltable = {
	  //convert json string to json object if necessary
	  toObject: function (data) {
	    data = toNode(data);
	    assert(data, "table is not found");
	    assert(data.tagName.toLowerCase() === "table", "Incorrect table object");
	    var tr = data.rows;
	    remove(data);
	    return tr;
	  },
	  //get array of records
	  getRecords: function (data) {
	    var new_data = []; //skip header rows if necessary

	    var i = data[0] && data[0]._webix_skip ? 1 : 0;

	    for (; i < data.length; i++) {
	      new_data.push(data[i]);
	    }

	    return new_data;
	  },
	  //get hash of properties for single record
	  getDetails: function (data) {
	    var td = data.getElementsByTagName("td");
	    data = {}; //get hash of properties for single record, data named as "data{index}"

	    for (var i = 0; i < td.length; i++) {
	      data["data" + i] = td[i].innerHTML;
	    }

	    return data;
	  },
	  //get count of data and position at which new data need to be inserted
	  getInfo: function () {
	    // dyn loading is not supported for htmltable
	    return {
	      size: 0
	    };
	  },
	  getOptions: function () {},

	  /*! gets header from first table row
	   **/
	  getConfig: function (data) {
	    var columns = [];
	    var td = data[0].getElementsByTagName("th");
	    if (td.length) data[0]._webix_skip = true;

	    for (var i = 0; i < td.length; i++) {
	      var col = {
	        id: "data" + i,
	        header: this._de_json(td[i].innerHTML)
	      };

	      var attrs = this._get_attrs(td[i]);

	      col = exports.extend(col, attrs);
	      columns.push(col);
	    }

	    return columns;
	  },
	  _de_json: function (str) {
	    var pos$$1 = str.indexOf("json://");
	    if (pos$$1 != -1) str = JSON.parse(str.substr(pos$$1 + 7));
	    return str;
	  },

	  /*! gets hash of html-element attributes
	   **/
	  _get_attrs: function (el) {
	    var attr = el.attributes;
	    var hash = {};

	    for (var i = 0; i < attr.length; i++) {
	      hash[attr[i].nodeName] = this._de_json(attr[i].nodeValue);
	    }

	    hash.width = parseInt(hash.width, 10);
	    return hash;
	  }
	};

	var _modules = {}; //hash of already loaded modules
	//loads module from external js file

	function require(module, callback, master) {
	  var promise = Deferred.defer();
	  if (callback && callback !== true) promise = promise.then(function () {
	    callback.call(master || this);
	  });

	  if (require.disabled) {
	    promise.resolve();
	    return promise;
	  } //multiple files required at once


	  if (typeof module != "string") {
	    var count = module.length || 0;

	    if (!count) {
	      // { file: true, other: true }
	      for (var file in module) {
	        count++;
	      } // eslint-disable-line


	      var callback2 = function () {
	        count--;
	        if (count === 0) promise.resolve();
	      };

	      for (var _file in module) {
	        require(_file, callback2, master);
	      }
	    } else {
	      // [ file, other ]
	      var _callback = function () {
	        if (count) {
	          count--;

	          require(module[module.length - count - 1], _callback, master);
	        } else {
	          promise.resolve();
	        }
	      };

	      _callback();
	    }

	    return promise;
	  }

	  if (_modules[module] !== true) {
	    var fullpath = module; //css, async, no waiting

	    var parts = module.split("?");

	    if (parts[0].substr(parts[0].length - 4) == ".css") {
	      var link = create("LINK", {
	        type: "text/css",
	        rel: "stylesheet",
	        href: fullpath
	      });
	      document.getElementsByTagName("head")[0].appendChild(link);
	      promise.resolve();
	      return promise;
	    } //js, async, waiting


	    if (callback === true) {
	      //sync mode
	      exec(ajax().sync().get(fullpath).responseText);
	      _modules[module] = true;
	    } else {
	      if (!_modules[module]) {
	        //first call
	        _modules[module] = [promise];
	        var newScript = document.createElement("script");
	        var calls = _modules[module]; //callbacks

	        newScript.onerror = function () {
	          _modules[module] = false;

	          for (var i = 0; i < calls.length; i++) {
	            calls[i].reject();
	          }
	        };

	        newScript.onload = function () {
	          _modules[module] = true;

	          for (var i = 0; i < calls.length; i++) {
	            calls[i].resolve();
	          }
	        };

	        document.getElementsByTagName("head")[0].appendChild(newScript);
	        newScript.src = fullpath;
	      } else //module already loading
	        _modules[module].push(promise);
	    }
	  } else promise.resolve();

	  return promise;
	}

	var excel = exports.extend({
	  toObject: function (data) {
	    if (!data.excel) {
	      var opts = data.options || {};
	      if (opts.dataurl) exports.extend(opts, this._urlToOptions(opts.dataurl));
	      data = data.data || data;
	      var promise = Deferred.defer();

	      if (data.name) {
	        //file
	        opts.ext = data.name.split(".").pop();
	        var reader = new FileReader();
	        reader.onload = bind(function (e) {
	          promise.resolve(this.parseData(e.target.result, opts));
	        }, this);
	        reader.readAsArrayBuffer(data);
	      } else //arraybuffer
	        promise.resolve(this.parseData(data, opts));

	      return promise;
	    } //plain jsarray or hash


	    return data;
	  },
	  parseData: function (data, options) {
	    data = new Uint8Array(data);
	    var arr = [];

	    for (var i = 0; i != data.length; ++i) {
	      arr[i] = String.fromCharCode(data[i]);
	    }

	    var ext = (options.ext || options).toLowerCase();
	    if (ext != "xls") ext = "xlsx";
	    return require(env.cdn + "/extras/xlsx.core.styles.min.js").then(bind(function () {
	      /* global XLS, XLSX */
	      var wb = ext == "xls" ? XLS.read(arr.join(""), {
	        type: "binary",
	        cellStyles: true,
	        cellDates: true
	      }) : XLSX.read(arr.join(""), {
	        type: "binary",
	        cellStyles: true,
	        cellDates: true
	      });
	      var res = {
	        sheets: wb.Sheets,
	        names: wb.SheetNames,
	        options: options,
	        ranges: wb.Workbook ? wb.Workbook.Names || [] : []
	      };
	      return exports.extend(this.getSheet(res, options), res);
	    }, this));
	  },
	  getSheet: function (data, options) {
	    var name = options.name || data.names[0];
	    data = this.sheetToArray(data.sheets[name], options);
	    if (options.rows && options.rows.length) data.data = data.data.splice(options.rows[0], Math.min(options.rows[1], data.data.length) - options.rows[0]);
	    return data;
	  },
	  sheetToArray: function (sheet, options) {
	    var all = [];
	    var spans = [];
	    var styles = [];
	    var sizes = [];

	    if (sheet && sheet["!ref"]) {
	      var range = XLS.utils.decode_range(sheet["!ref"]),
	          row,
	          col,
	          cellCoord,
	          cell,
	          xCorrection = range.s.c,
	          yCorrection = range.s.r + (options.rows ? options.rows[0] : 0);

	      for (row = range.s.r; row <= range.e.r; row++) {
	        var nrow = [];

	        for (col = range.s.c; col <= range.e.c; col++) {
	          cellCoord = XLS.utils.encode_cell({
	            r: row,
	            c: col
	          });
	          cell = sheet[cellCoord];
	          if (!cell) nrow.push("");else {
	            var ncell = "";
	            if (options.math && cell.f) // get formula
	              ncell = cell.f.charAt(0) == "=" ? cell.f : "=" + cell.f;else if (cell.t == "d" && isDate(cell.v)) ncell = i18n.dateFormatStr(cell.v);else ncell = cell.v;
	            nrow.push(ncell);
	            if (cell.s) styles.push([row - yCorrection, col - xCorrection, cell.s]);
	          }
	        }

	        all.push(nrow);
	      }

	      if (sheet["!merges"]) {
	        var merges = sheet["!merges"];

	        for (var i = 0; i < merges.length; i++) {
	          var s = merges[i].s;
	          var e = merges[i].e;
	          if (!options.rows || s.r - yCorrection >= 0 && e.r - yCorrection <= options.rows[1]) spans.push([s.r - yCorrection, s.c - xCorrection, e.c - s.c + 1, e.r - s.r + 1]);
	        }
	      }

	      if (sheet["!cols"]) {
	        var widths = sheet["!cols"];

	        for (var _i = 0; _i < widths.length; _i++) {
	          if (widths[_i]) sizes.push(["column", _i - xCorrection, Math.round(widths[_i].wch / (8.43 / 70))]);
	        } //mode, colind, value

	      }

	      if (sheet["!rows"]) {
	        var heights = sheet["!rows"];

	        for (var _i2 = 0; _i2 < heights.length; _i2++) {
	          if (heights[_i2]) sizes.push(["row", _i2 - yCorrection, heights[_i2].hpx]);
	        } //mode ("row", "column"), rowind, value

	      }
	    }

	    return {
	      data: all,
	      spans: spans,
	      styles: styles,
	      sizes: sizes,
	      excel: true
	    };
	  },
	  _urlToOptions: function (details) {
	    var parts = details.split("[");
	    var options = {};
	    options.name = parts[0];

	    if (parts[1]) {
	      var rows = parts[1].split(/[^0-9]+/g);
	      rows[0] = rows[0] * 1 || 0;
	      rows[1] = rows[1] * 1 || 9999999;
	      options.rows = rows;
	    }

	    return options;
	  }
	}, jsarray);

	var DataDriver = {
	  json: json,
	  jsarray: jsarray,
	  xml: xml,
	  csv: csv,
	  html: html,
	  htmltable: htmltable,
	  excel: excel
	};

	var storage = {};

	storage.prefix = function (scope, storage) {
	  scope = scope + ".";
	  return {
	    put: function (name, data) {
	      return storage.put(scope + name, data);
	    },
	    get: function (name) {
	      return storage.get(scope + name);
	    },
	    remove: function (name) {
	      return storage.remove(scope + name);
	    }
	  };
	};

	storage.local = {
	  put: function (name, data) {
	    if (name && window.JSON && window.localStorage) {
	      window.localStorage.setItem(name, stringify(data));
	    }
	  },
	  get: function (name) {
	    if (name && window.JSON && window.localStorage) {
	      var json = window.localStorage.getItem(name);
	      if (!json) return null;
	      return DataDriver.json.toObject(json);
	    } else return null;
	  },
	  remove: function (name) {
	    if (name && window.JSON && window.localStorage) {
	      window.localStorage.removeItem(name);
	    }
	  },
	  clear: function () {
	    window.localStorage.clear();
	  }
	};
	storage.session = {
	  put: function (name, data) {
	    if (name && window.JSON && window.sessionStorage) {
	      window.sessionStorage.setItem(name, stringify(data));
	    }
	  },
	  get: function (name) {
	    if (name && window.JSON && window.sessionStorage) {
	      var json = window.sessionStorage.getItem(name);
	      if (!json) return null;
	      return DataDriver.json.toObject(json);
	    } else return null;
	  },
	  remove: function (name) {
	    if (name && window.JSON && window.sessionStorage) {
	      window.sessionStorage.removeItem(name);
	    }
	  },
	  clear: function () {
	    window.sessionStorage.clear();
	  }
	};
	storage.cookie = {
	  put: function (name, data, domain, expires) {
	    if (name && window.JSON) {
	      document.cookie = name + "=" + escape(stringify(data)) + (expires && expires instanceof Date ? ";expires=" + expires.toUTCString() : "") + (domain ? ";domain=" + domain : "") + (env.https ? ";secure" : "");
	    }
	  },
	  getRaw: function (check_name) {
	    // first we'll split this cookie up into name/value pairs
	    // note: document.cookie only returns name=value, not the other components
	    var a_all_cookies = document.cookie.split(";");
	    var a_temp_cookie = "";
	    var cookie_name = "";
	    var cookie_value = "";
	    var b_cookie_found = false; // set boolean t/f default f

	    for (var i = 0; i < a_all_cookies.length; i++) {
	      // now we'll split apart each name=value pair
	      a_temp_cookie = a_all_cookies[i].split("="); // and trim left/right whitespace while we're at it

	      cookie_name = a_temp_cookie[0].replace(/^\s+|\s+$/g, ""); // if the extracted name matches passed check_name

	      if (cookie_name == check_name) {
	        b_cookie_found = true; // we need to handle case where cookie has no value but exists (no = sign, that is):

	        if (a_temp_cookie.length > 1) {
	          cookie_value = unescape(a_temp_cookie[1].replace(/^\s+|\s+$/g, ""));
	        } // note that in cases where cookie is initialized but no value, null is returned


	        return cookie_value;
	      }

	      a_temp_cookie = null;
	      cookie_name = "";
	    }

	    if (!b_cookie_found) {
	      return null;
	    }

	    return null;
	  },
	  get: function (name) {
	    if (name && window.JSON) {
	      var json = this.getRaw(name);
	      if (!json) return null;
	      return DataDriver.json.toObject(unescape(json));
	    } else return null;
	  },
	  remove: function (name, domain) {
	    if (name && this.getRaw(name)) document.cookie = name + "=" + (domain ? ";domain=" + domain : "") + ";expires=Thu, 01-Jan-1970 00:00:01 GMT";
	  },
	  clear: function (domain) {
	    var cookies = document.cookie.split(";");

	    for (var i = 0; i < cookies.length; i++) {
	      document.cookie = /^[^=]+/.exec(cookies[i])[0] + "=" + (domain ? ";domain=" + domain : "") + ";expires=Thu, 01-Jan-1970 00:00:01 GMT";
	    }
	  }
	};

	var proxy$7 = {
	  $proxy: true,
	  storage: storage.local,
	  cache: false,
	  local: false,
	  data: "",
	  _is_offline: function () {
	    if (!this.cache && !env.offline) {
	      callEvent("onOfflineMode", []);
	      env.offline = true;
	    }
	  },
	  _is_online: function () {
	    if (!this.cache && env.offline) {
	      env.offline = false;
	      callEvent("onOnlineMode", []);
	    }
	  },
	  _on_success: function (text) {
	    this._is_online();

	    this.setCache(text);
	  },
	  _on_error: function (view) {
	    //assuming offline mode
	    this._is_offline();

	    var text = this.getCache() || this.data;
	    view.parse(text);
	  },
	  load: function (view) {
	    var _this = this;

	    //in cache mode - always load data from cache
	    if (this.cache && this.getCache()) {
	      this._on_error(view);
	    } //else try to load actual data first
	    else {
	        var result;
	        if (this.source.$proxy) result = this.source.load(view);else result = ajax().get(this.source);

	        if (result && result.then) {
	          result.then(function (data) {
	            _this._on_success(data.text());
	          }, function () {
	            _this._on_error(view);
	          });
	        }

	        return result;
	      }
	  },
	  getCache: function () {
	    return this.storage.get(this._data_name());
	  },
	  clearCache: function () {
	    this.storage.remove(this._data_name());
	  },
	  setCache: function (text) {
	    this.storage.put(this._data_name(), text);
	  },
	  _data_name: function () {
	    if (this.source.$proxy) return this.source.source + "_$proxy$_data";else return this.source + "_$proxy$_data";
	  },
	  save: function (master, data, view) {
	    if (!env.offline && !this.cache) {
	      if (this.source.$proxy) {
	        return this.source.save(master, data, view);
	      } else {
	        return ajax().post(this.source, data.data);
	      }
	    }
	  },
	  saveAll: function (view, update) {
	    this.setCache(view.serialize());
	    update = this.cache || env.offline ? update : [];

	    for (var i = 0; i < update.length; i++) {
	      update[i] = {
	        id: update[i].id,
	        status: update[i].operation
	      };
	    }

	    return Deferred.resolve(update);
	  }
	};

	var proxy$8 = {
	  init: function () {
	    exports.extend(this, proxy$7);
	  },
	  cache: true
	};

	var proxy$9 = {
	  init: function () {
	    exports.extend(this, proxy$7);
	  },
	  cache: true,
	  local: true,
	  data: []
	};

	function unbox(data) {
	  if (!data || !_typeof(data) === "object" || Array.isArray(data)) return data;
	  var lkey = "";
	  var count = 0;

	  for (var key in data) {
	    count++;
	    if (count == 2) return data;
	    lkey = key;
	  }

	  return data[lkey];
	}

	var GraphQL = {
	  $proxy: true,
	  save: function (data) {
	    return this.load(data);
	  },
	  load: function (view) {
	    var params = {
	      query: this.source
	    };

	    if (arguments.length === 1) {
	      params.variables = view;
	    }

	    return ajax().headers({
	      "Content-type": "application/json"
	    }).post(this.url, params).then(function (data) {
	      return unbox(data.json().data);
	    });
	  }
	};

	function proxy$a(name, source, extra) {
	  assert(proxy$a[name], "Invalid proxy name: " + name);
	  var copy$$1 = copy(proxy$a[name]);
	  copy$$1.source = source;
	  if (extra) exports.extend(copy$$1, extra, true);
	  if (copy$$1.init) copy$$1.init();
	  return copy$$1;
	}

	proxy$a.$parse = function (value) {
	  if (typeof value == "string" && value.indexOf("->") != -1) {
	    var parts = value.split("->");
	    return proxy$a(parts[0], parts[1]);
	  }

	  return value;
	};

	proxy$a.binary = proxy;
	proxy$a.connector = proxy$1;
	proxy$a.debug = proxy$2;
	proxy$a.faye = proxy$3;
	proxy$a.indexdb = indexdb;
	proxy$a.json = proxy$5;
	proxy$a.post = proxy$6;
	proxy$a.rest = proxy$4;
	proxy$a.offline = proxy$7;
	proxy$a.cache = proxy$8;
	proxy$a.local = proxy$9;
	proxy$a.local = proxy$9;
	proxy$a.GraphQL = GraphQL;

	var AtomDataLoader = {
	  $init: function (config) {
	    //prepare data store
	    this.data = {};
	    this.waitData = Deferred.defer();
	    if (config) this._settings.datatype = config.datatype || "json";
	    this.$ready.push(this._load_when_ready);
	  },
	  _load_when_ready: function () {
	    this._ready_for_data = true;
	    if (this._settings.url) this.url_setter(this._settings.url);
	    if (this._settings.data) this.data_setter(this._settings.data);
	  },
	  url_setter: function (value) {
	    value = proxy$a.$parse(value);
	    if (!this._ready_for_data) return value;
	    this.load(value, this._settings.datatype);
	    return value;
	  },
	  data_setter: function (value) {
	    if (!this._ready_for_data) return value;
	    this.parse(value, this._settings.datatype);
	    return true;
	  },
	  //loads data from external URL
	  load: function (url, call) {
	    var _this = this;

	    var details = arguments[2] || null;
	    if (!this.callEvent("onBeforeLoad", [])) return Deferred.reject();

	    if (typeof call == "string") {
	      //second parameter can be a loading type or callback
	      //we are not using setDriver as data may be a non-datastore here
	      this.data.driver = DataDriver[call];
	      call = arguments[2];
	    } else if (!this.data.driver) this.data.driver = DataDriver.json;

	    var result; //proxy	

	    url = proxy$a.$parse(url);

	    if (url.$proxy && url.load) {
	      result = url.load(this, details);
	    } //promize
	    else if (typeof url === "function") {
	        result = url.call(this, details);
	      } //normal url
	      else {
	          result = ajax().bind(this).get(url);
	        } //we wrap plain data in promise to keep the same processing for it


	    if (result && !result.then) {
	      result = Deferred.resolve(result);
	    }

	    if (result && result.then) {
	      result.then(function (data) {
	        if (_this.$destructed) return;

	        _this._onLoad(data);

	        if (call) ajax.$callback(_this, call, "", data, -1);
	      }, function (x) {
	        _this._onLoadError(x);
	      });
	    }

	    return result;
	  },
	  //loads data from object
	  parse: function (data, type) {
	    if (data && typeof data.then == "function") {
	      return data.then(bind(function (data) {
	        this.parse(data, type);
	      }, this));
	    } //loading data from other component


	    if (data && data.sync && this.sync) return this._syncData(data);
	    if (!this.callEvent("onBeforeLoad", [])) return Deferred.reject();
	    this.data.driver = DataDriver[type || "json"];

	    this._onLoad(data);
	  },
	  _syncData: function (data) {
	    if (this.data) this.data.attachEvent("onSyncApply", bind(function () {
	      if (this._call_onready) this._call_onready();
	    }, this));
	    this.sync(data);
	  },
	  _parse: function (data) {
	    var parsed,
	        record,
	        driver = this.data.driver;
	    record = driver.getRecords(data)[0];
	    parsed = record ? driver.getDetails(record) : {};
	    if (this.setValues) this.setValues(parsed);else this.data = parsed;
	  },
	  _onLoadContinue: function (data) {
	    if (data) {
	      if (!this.$onLoad || !this.$onLoad(data, this.data.driver)) {
	        if (this.data && this.data._parse) this.data._parse(data); //datastore
	        else this._parse(data);
	      }
	    } else this._onLoadError(data); //data loaded, view rendered, call onready handler


	    if (this._call_onready) this._call_onready();
	    this.callEvent("onAfterLoad", []);
	    this.waitData.resolve();
	  },
	  //default after loading callback
	  _onLoad: function (data) {
	    var _this2 = this;

	    if (data && typeof data.text === "function") {
	      data = data.text();
	    }

	    data = this.data.driver.toObject(data);
	    if (data && data.then) data.then(function (data) {
	      _this2._onLoadContinue(data);
	    });else this._onLoadContinue(data);
	  },
	  _onLoadError: function (xhttp) {
	    this.callEvent("onAfterLoad", []);
	    this.callEvent("onLoadError", arguments);
	    callEvent("onLoadError", [xhttp, this]);
	  },
	  _check_data_feed: function (data) {
	    if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
	    var url = this._settings.dataFeed;
	    if (typeof url == "function") return url.call(this, data.id || data, data);
	    url = url + (url.indexOf("?") == -1 ? "?" : "&") + "action=get&id=" + encodeURIComponent(data.id || data);
	    if (!this.callEvent("onBeforeLoad", [])) return false;
	    ajax(url, function (text, xml, loader) {
	      this._ignore_feed = true;
	      var driver = DataDriver.json;
	      var data = driver.toObject(text, xml);
	      if (data) this.setValues(driver.getDetails(driver.getRecords(data)[0]));else this._onLoadError(loader);
	      this._ignore_feed = false;
	      this.callEvent("onAfterLoad", []);
	    }, this);
	    return false;
	  }
	};

	var AtomRender = {
	  //convert item to the HTML text
	  _toHTML: function (obj) {
	    if (obj.$empty) return "";
	    return this._settings.template(obj, this);
	  },
	  //render self, by templating data object
	  render: function () {
	    var cfg = this._settings;

	    if (this.isVisible(cfg.id)) {
	      if (!this.callEvent || this.callEvent("onBeforeRender", [this.data])) {
	        if (this.data && !cfg.content) {
	          //it is critical to have this as two commands
	          //its prevent destruction race in Chrome
	          this._dataobj.innerHTML = "";
	          this._dataobj.innerHTML = this._toHTML(this.data);
	        }

	        if (this.callEvent) this.callEvent("onAfterRender", []);
	      }

	      return true;
	    }

	    return false;
	  },
	  sync: function (source) {
	    this._backbone_sync = false;

	    if (source.name != "DataStore") {
	      if (source.data && source.name == "DataStore") {
	        source = source.data;
	      } else {
	        this._backbone_sync = true;
	      }
	    }

	    if (this._backbone_sync) source.bind("change", bind(function (data) {
	      if (data.id == this.data.id) {
	        this.data = data.attributes;
	        this.refresh();
	      }
	    }, this));else source.attachEvent("onStoreUpdated", bind(function (id) {
	      if (!id || id == this.data.id) {
	        this.data = source.pull[id];
	        this.refresh();
	      }
	    }, this));
	  },
	  template_setter: template
	};

	var AutoScroll = {
	  _auto_scroll: function (pos$$1) {
	    var yscroll = 1;
	    var xscroll = 0;
	    var mode = this._settings.dragscroll;

	    if (typeof mode == "string") {
	      xscroll = mode.indexOf("x") != -1;
	      yscroll = mode.indexOf("y") != -1;
	    }

	    var data = this._body || this.$view;
	    var box = offset(data);
	    var top = box.y;
	    var bottom = top + data.offsetHeight;
	    var left = box.x;
	    var right = left + data.offsetWidth;
	    var scroll = this.getScrollState();
	    var reset = false;
	    var sense = Math.max(this.type && !isNaN(parseFloat(this.type.height)) ? this.type.height + 5 : 0, 40); //dnd auto-scroll sensivity

	    if (yscroll) {
	      var config = this._settings;

	      if (config.topSplit) {
	        var topSplitPos = this._cellPosition(this.getIdByIndex(config.topSplit - 1), this.columnId(0));

	        top += topSplitPos.top + topSplitPos.height;
	      }

	      if (pos$$1.y < top + sense) {
	        this._auto_scrollTo(scroll.x, scroll.y - sense * 2, pos$$1);

	        reset = true;
	      } else if (pos$$1.y > bottom - sense) {
	        this._auto_scrollTo(scroll.x, scroll.y + sense * 2, pos$$1);

	        reset = true;
	      }
	    }

	    if (xscroll) {
	      if (pos$$1.x < left + sense) {
	        this._auto_scrollTo(scroll.x - sense * 2, scroll.y, pos$$1);

	        reset = true;
	      } else if (pos$$1.x > right - sense) {
	        this._auto_scrollTo(scroll.x + sense * 2, scroll.y, pos$$1);

	        reset = true;
	      }
	    }

	    if (reset) this._auto_scroll_delay = delay(this._auto_scroll, this, [pos$$1], 100);
	  },
	  _auto_scrollTo: function (x, y, pos$$1) {
	    if (this.callEvent("onBeforeAutoScroll", [pos$$1])) this.scrollTo(x, y);
	  }
	};

	var TooltipControl = {
	  _tooltip_masters: toArray(["dummy"]),
	  _tooltip_exist: 0,
	  delay: 400,
	  addTooltip: function (target, config) {
	    var node, ctrl;
	    target = toNode(target);
	    assert(target, "Target isn't defined");

	    if (target instanceof Element) {
	      node = target;
	      if (typeof config === "string") node.setAttribute("webix_tooltip", config);else ctrl = config;
	    } else {
	      node = target.$view;
	      ctrl = target;
	    }

	    ctrl = ctrl || this;

	    var index$$1 = this._tooltip_masters.find(ctrl);

	    if (index$$1 === -1) {
	      index$$1 = this._tooltip_masters.length;

	      this._tooltip_masters.push(ctrl);
	    }

	    node.webix_tooltip = index$$1;
	    this._tooltip_exist++;

	    if (!this._tooltip) {
	      this._tooltip = new ui.tooltip({});
	      this._webix_tooltip_mm = event$1(document, "mousemove", this._move_tooltip, {
	        bind: this
	      });
	      this._webix_tooltip_ml = event$1(document, "mouseleave", this._hide_tooltip, {
	        bind: this
	      });
	      this._drag_event = attachEvent("onDragMode", function () {
	        if (TooltipControl._tooltip_exist) TooltipControl._hide_tooltip();
	      });
	    }
	  },
	  getTooltip: function () {
	    return this._tooltip;
	  },
	  _move_tooltip: function (e) {
	    var node = e.target || e.srcElement;
	    var text;

	    while (node && node.tagName != "HTML") {
	      if (node.webix_tooltip) {
	        if (this._last && this._last != node) {
	          this.$tooltipOut(this._last, node, e);
	          this._last = null;
	          return;
	        }

	        if (!this._last) this._last = this.$tooltipIn(node, e);
	        this.$tooltipMove(node, e, text);
	        return;
	      }

	      text = text || node.getAttribute("webix_tooltip");
	      node = node.parentNode;
	    }

	    if (this._last) this._last = this.$tooltipOut(this._last, null, e);
	  },
	  _hide_tooltip: function () {
	    clearTimeout(this._before_show_delay);

	    this._tooltip.hide();
	  },
	  getMaster: function (t) {
	    return this._tooltip_masters[t.webix_tooltip];
	  },
	  removeTooltip: function (target) {
	    var node;
	    assert(target, "Target isn't defined");
	    target = toNode(target);
	    if (target instanceof Element) node = target;else node = target.$view;

	    if (node.webix_tooltip) {
	      delete node.webix_tooltip;
	      this._tooltip_exist--;
	    }

	    if (!this._tooltip_exist && this._tooltip) {
	      this._webix_tooltip_mm = eventRemove(this._webix_tooltip_mm);
	      this._webix_tooltip_ml = eventRemove(this._webix_tooltip_ml);
	      this._drag_event = detachEvent(this._drag_event);

	      this._tooltip.destructor();

	      this._tooltip = this._last = null;
	      this._tooltip_masters = toArray(["dummy"]);
	    }
	  },
	  $tooltipIn: function (t, e) {
	    var m = this._tooltip_masters[t.webix_tooltip];
	    if (m.$tooltipIn && m != this) return m.$tooltipIn(t, e);

	    this._tooltip.define({
	      dx: 20,
	      dy: 0,
	      template: t.getAttribute("webix_tooltip") || "",
	      css: ""
	    });

	    return t;
	  },
	  $tooltipOut: function (t, n, e) {
	    var m = this._tooltip_masters[t.webix_tooltip];
	    if (m.$tooltipOut && m != this) return m.$tooltipOut(t, n, e);

	    this._hide_tooltip();

	    return null;
	  },
	  $tooltipMove: function (t, e, text) {
	    var m = this._tooltip_masters[t.webix_tooltip];
	    if (m.$tooltipMove && m != this) return m.$tooltipMove(t, e, text);

	    this._tooltip.hide();

	    clearTimeout(this._before_show_delay);
	    this._before_show_delay = delay(this._tooltip.show, this._tooltip, [text || {}, pos(e)], this.delay);
	  }
	};

	function _uid(name) {
	  return "$" + name + (_namecount[name] = (_namecount[name] || 0) + 1);
	}
	var _namecount = {};
	var _freeze_resize = false;
	function freeze(handler, trigger) {
	  _freeze_resize = true;
	  var res = handler();

	  if (res && res.then) {
	    res = res.then(function (any) {
	      _freeze_resize = false;
	      if (trigger !== false) resize();
	      return any;
	    });
	  } else {
	    _freeze_resize = false;
	    if (trigger !== false) resize();
	  }

	  return res;
	}
	function resize() {
	  use("UIManager").applyChanges();
	  callEvent("onClick", []);
	  state._force_resize = true;
	  if (!_freeze_resize) for (var i = state.top_views.length - 1; i >= 0; i--) {
	    if (state.top_views[i].obj) state.top_views[i].obj.resize();
	  }
	  state._force_resize = false;
	}
	function each(parent, logic, master, include) {
	  if (parent) {
	    var children = include ? [parent] : parent.getChildViews();

	    for (var i = 0; i < children.length; i++) {
	      if (logic.call(master, children[i]) !== false) each(children[i], logic, master);
	    }
	  }
	}
	function zIndex() {
	  return env.zIndexBase++;
	}
	event$1(window, "resize", function () {
	  // check for virtual keyboard
	  if (env.touch && (state._focus_time && new Date() - state._focus_time < 1000)) {
	    return;
	  } else {
	    resize();
	  }
	});

	function ready(code) {
	  if (_ready) code.call();else _ready_code.push(code);
	}

	var _ready = false;
	var _ready_code = []; //autodetect codebase folder

	var temp = document.getElementsByTagName("SCRIPT"); //current script, most probably

	assert(temp.length, "Can't locate codebase");

	if (temp.length) {
	  //full path to script
	  temp = (temp[temp.length - 1].getAttribute("src") || "").split("/"); //get folder name

	  temp.splice(temp.length - 1, 1);
	  env.codebase = temp.slice(0, temp.length).join("/") + "/";
	}

	var handler = function () {
	  if (env.isIE) document.body.className += " webix_ie";
	  callEvent("onReady", []);
	};

	var doit = function () {
	  _ready = true;
	  /* global webix_ready */

	  if (window.webix_ready && isArray(webix_ready)) _ready_code = webix_ready.concat(_ready_code);

	  for (var i = 0; i < _ready_code.length; i++) {
	    _ready_code[i].call();
	  }

	  _ready_code = [];
	};

	attachEvent("onReady", function (force) {
	  if (force) doit();else delay(doit);
	});
	if (document.readyState == "complete") handler();else event$1(window, "load", handler);
	ready(function () {
	  event$1(document.body, "click", function (e) {
	    callEvent("onClick", [e || event$1]);
	  });
	});

	var UIManager = {
	  _view: null,
	  _hotkeys: {},
	  _focus_time: 0,
	  _tab_time: 0,
	  _mouse_time: 0,
	  _controls: {
	    "enter": 13,
	    "tab": 9,
	    "esc": 27,
	    "escape": 27,
	    "up": 38,
	    "down": 40,
	    "left": 37,
	    "right": 39,
	    "pgdown": 34,
	    "pagedown": 34,
	    "pgup": 33,
	    "pageup": 33,
	    "end": 35,
	    "home": 36,
	    "insert": 45,
	    "delete": 46,
	    "backspace": 8,
	    "space": 32,
	    "meta": 91,
	    "win": 91,
	    "mac": 91,
	    "multiply": 106,
	    "add": 107,
	    "subtract": 109,
	    "decimal": 110,
	    "divide": 111,
	    "scrollock": 145,
	    "pausebreak": 19,
	    "numlock": 144,
	    "5numlocked": 12,
	    "shift": 16,
	    "capslock": 20
	  },
	  _inputs: {
	    "input": 1,
	    "button": 1,
	    "textarea": 1,
	    "select": 1
	  },
	  _enable: function () {
	    // attaching events here
	    event$1(document.body, "click", bind(this._focus_click, this));
	    event$1(document, "keydown", bind(this._keypress, this));

	    _event(document.body, "mousedown", bind(function () {
	      this._mouse_time = new Date();
	    }, this));

	    if (document.body.addEventListener) event$1(document.body, "focus", this._focus_tab, {
	      capture: true,
	      bind: this
	    });
	    state.destructors.push({
	      obj: this
	    });
	  },
	  destructor: function () {
	    UIManager._view = null;
	  },
	  getFocus: function () {
	    return this._view;
	  },
	  _focus_action: function (view) {
	    this._focus_was_there = this._focus_was_there || view._settings.id;
	  },
	  setFocus: function (view, only_api, tab) {
	    //view can be empty
	    view = $$(view); //unfocus if view is hidden

	    if (view && !view.$view) view = null; //store last click time, it is necessary to prevent refocusing
	    //for example when user moves focus from onclick handler somewher
	    //and we want to prevent autofocusing, when event will reach document.body

	    this._focus_time = state._focus_time = new Date();
	    if (this._view === view) return true;
	    if (this._view && this._view.callEvent) this._view.callEvent("onBlur", [this._view]);

	    if (view && view.callEvent) {
	      view.callEvent("onFocus", [view, this._view]);
	      if (tab) view.callEvent("onTabFocus", [view, this._view]);
	    }

	    callEvent("onFocusChange", [view, this._view]);
	    if (this._view && this._view.blur && !only_api) this._view.blur();
	    this._view = view;
	    if (view && view.focus && !only_api) view.focus();
	    return true;
	  },
	  applyChanges: function (element) {
	    var view = this.getFocus();
	    if (view && view != element && view._applyChanges) view._applyChanges(element);
	  },
	  hasFocus: function (view) {
	    return view === this._view ? true : false;
	  },
	  _focus: function (e, dont_clear) {
	    var view = locate(e, "view_id") || this._focus_was_there; //if html was repainted we can miss the view, so checking last processed one


	    view = $$(view);
	    this._focus_was_there = null; //set timer, to fix issue with Android input focusin

	    state._focus_time = new Date();
	    if (view == this._view) return;
	    if (!dont_clear) this._focus_was_there = null;

	    if (view) {
	      view = $$(view);

	      if (this.canFocus(view)) {
	        //[ACTIVECONTENT] focus operations for active content
	        if (view.getNode) view.getNode(e);
	        this.setFocus(view);
	      }
	    } else if (!dont_clear) this.setFocus(null);

	    return true;
	  },
	  _focus_click: function (e) {
	    // if it was onfocus/onclick less then 100ms behore then we ignore it
	    if (new Date() - this._focus_time < 100) {
	      this._focus_was_there = null;
	      return false;
	    }

	    return this._focus(e);
	  },
	  _focus_tab: function (e) {
	    if (!this._inputs[e.target.nodeName.toLowerCase()]) return false;
	    return this._focus(e, true);
	  },
	  canFocus: function (view) {
	    return view.isVisible() && view.isEnabled() && !view.queryView({
	      disabled: true
	    }, "parent");
	  },
	  _moveChildFocus: function (check_view) {
	    var focus = this.getFocus(); //we have not focus inside of closing item

	    if (check_view && !this._is_child_of(check_view, focus)) return false;
	    if (!this._focus_logic("getPrev", check_view)) this._view = null;
	  },
	  _translation_table: {},
	  _is_child_of: function (parent, child) {
	    if (!parent) return false;
	    if (!child) return false;

	    while (child) {
	      if (child === parent) return true;
	      child = child.getParentView();
	    }

	    return false;
	  },
	  _keypress_timed: function () {
	    if (this && this.callEvent) this.callEvent("onTimedKeyPress", []);
	  },
	  _isNumPad: function (code) {
	    return code < 112 && code > 105;
	  },
	  _keypress: function (e) {
	    var code = e.which || e.keyCode;
	    if (code > 95 && code < 106) code -= 48; //numpad support (numbers)

	    code = this._translation_table[code] || code;
	    var ctrl = e.ctrlKey;
	    var shift = e.shiftKey;
	    var alt = e.altKey;
	    var meta = e.metaKey;

	    var codeid = this._keycode(code, ctrl, shift, alt, meta);

	    var view = this.getFocus();

	    if (view && view.callEvent) {
	      if (view.callEvent("onKeyPress", [code, e]) === false) preventEvent(e);

	      if (view.hasEvent("onTimedKeyPress")) {
	        clearTimeout(view._key_press_timeout);
	        view._key_press_timeout = delay(this._keypress_timed, view, [], view._settings.keyPressTimeout || 250);
	      }
	    }

	    if (!this._isNumPad(code)) codeid = this._keycode(String.fromCharCode(code), ctrl, shift, alt, meta); //flag, that some non-special key was pressed

	    var is_any = !ctrl && !alt && !meta && code != 9 && code != 27 && code != 13;

	    if (this._check_keycode(codeid, is_any, e) === false) {
	      preventEvent(e);
	      return false;
	    }
	  },
	  // dir - getNext or getPrev
	  _focus_logic: function (dir) {
	    if (!this.getFocus()) return null;
	    dir = dir || "getNext";
	    var next = this.getFocus();
	    var start = next;
	    var marker = uid();

	    while (true) {
	      // eslint-disable-line
	      next = this[dir](next); // view with focus ability

	      if (next && this.canFocus(next)) return this.setFocus(next); // elements with focus ability not found

	      if (next === start || next.$fmarker == marker) return null; //prevents infinity loop

	      next.$fmarker = marker;
	    }
	  },
	  _tab_logic: function (view, e) {
	    var mode = !e.shiftKey;
	    UIManager._tab_time = new Date();
	    if (view && view._custom_tab_handler && !view._custom_tab_handler(mode, e)) return false;

	    if (view && view._in_edit_mode) {
	      if (view.editNext) return view.editNext(mode);else if (view.editStop) {
	        view.editStop();
	        return true;
	      }
	    } else delay(function () {
	      UIManager.setFocus($$(document.activeElement), true, true);
	    }, 1);
	  },
	  getTop: function (id) {
	    var next,
	        view = $$(id);

	    while (view && (next = view.getParentView())) {
	      view = next;
	    }

	    return view;
	  },
	  getNext: function (view, _inner_call) {
	    var cells = view.getChildViews(); //tab to first children

	    if (cells.length && !_inner_call) return cells[0]; //unique case - single view without child and parent

	    var parent = view.getParentView();
	    if (!parent) return view;
	    var p_cells = parent.getChildViews();

	    if (p_cells.length) {
	      var index$$1 = PowerArray.find.call(p_cells, view) + 1;

	      while (index$$1 < p_cells.length) {
	        //next visible child
	        if (this.canFocus(p_cells[index$$1])) return p_cells[index$$1];
	        index$$1++;
	      }
	    } //sibling of parent


	    return this.getNext(parent, true);
	  },
	  getPrev: function (view, _inner_call) {
	    var cells = view.getChildViews(); //last child of last child

	    if (cells.length && _inner_call) return this.getPrev(cells[cells.length - 1], true);
	    if (_inner_call) return view; //fallback from top to bottom

	    var parent = view.getParentView();
	    if (!parent) return this.getPrev(view, true);
	    var p_cells = parent.getChildViews();

	    if (p_cells) {
	      var index$$1 = PowerArray.find.call(p_cells, view) - 1;

	      while (index$$1 >= 0) {
	        if (this.canFocus(p_cells[index$$1])) return this.getPrev(p_cells[index$$1], true);
	        index$$1--;
	      }
	    }

	    return parent;
	  },
	  addHotKey: function (keys, handler, view) {
	    assert(handler, "Hot key handler is not defined");

	    var pack = this._parse_keys(keys);

	    assert(pack.letter, "Unknown key code");
	    if (!view) view = null;
	    pack.handler = handler;
	    pack.view = view;

	    var code = this._keycode(pack.letter, pack.ctrl, pack.shift, pack.alt, pack.meta);

	    if (!this._hotkeys[code]) this._hotkeys[code] = [];

	    this._hotkeys[code].push(pack);

	    return keys;
	  },
	  removeHotKey: function (keys, func, view) {
	    var pack = this._parse_keys(keys);

	    var code = this._keycode(pack.letter, pack.ctrl, pack.shift, pack.alt, pack.meta);

	    if (!func && !view) delete this._hotkeys[code];else {
	      var t = this._hotkeys[code];

	      if (t) {
	        for (var i = t.length - 1; i >= 0; i--) {
	          if (view && t[i].view !== view) continue;
	          if (func && t[i].handler !== func) continue;
	          t.splice(i, 1);
	        }

	        if (!t.length) delete this._hotkeys[code];
	      }
	    }
	  },
	  _keycode: function (code, ctrl, shift, alt, meta) {
	    return code + "_" + ["", ctrl ? "1" : "0", shift ? "1" : "0", alt ? "1" : "0", meta ? "1" : "0"].join("");
	  },
	  _check_keycode: function (code, is_any, e) {
	    var focus = this.getFocus();
	    if (this._hotkeys[code]) return this._process_calls(this._hotkeys[code], focus, e);else if (is_any && this._hotkeys["ANY_0000"]) return this._process_calls(this._hotkeys["ANY_0000"], focus, e);
	    return true;
	  },
	  _process_calls: function (calls, focus, e) {
	    for (var i = 0; i < calls.length; i++) {
	      var key = calls[i];
	      if (key.view !== null && //common hot-key
	      focus !== key.view && ( //hot-key for current view
	      //hotkey for current type of view
	      typeof key.view !== "string" || !focus || focus.name !== key.view)) continue;
	      var temp_result = key.handler(focus, e);
	      if (!!temp_result === temp_result) return temp_result;
	    }

	    return true;
	  },
	  _parse_keys: function (keys) {
	    var controls = this._controls;
	    var parts = keys.toLowerCase().split(/[+\-_]/);
	    var ctrl, shift, alt, meta;
	    ctrl = shift = alt = meta = 0;
	    var letter = "";

	    for (var i = 0; i < parts.length; i++) {
	      if (parts[i] === "ctrl") ctrl = 1;else if (parts[i] === "shift") shift = 1;else if (parts[i] === "alt") alt = 1;else if (parts[i] === "command") meta = 1;else {
	        if (controls[parts[i]]) {
	          var code = controls[parts[i]];
	          if (this._isNumPad(code)) letter = code.toString();else letter = String.fromCharCode(code);
	        } else {
	          letter = parts[i];
	        }
	      }
	    }

	    return {
	      letter: letter.toUpperCase(),
	      ctrl: ctrl,
	      shift: shift,
	      alt: alt,
	      meta: meta,
	      debug: keys
	    };
	  },
	  getState: function (node, children) {
	    children = children || false;
	    node = $$(node);
	    var state$$1 = {
	      id: node.config.id,
	      width: node.config.width,
	      height: node.config.height,
	      gravity: node.config.gravity
	    };
	    if (!isUndefined(node.config.collapsed)) state$$1.collapsed = node.config.collapsed;
	    if (node.name === "tabs" || node.name === "tabbar") state$$1.activeCell = node.getValue();

	    if (children) {
	      state$$1 = [state$$1];

	      if (node._cells) {
	        for (var i = 0; i < node._cells.length; i++) {
	          state$$1 = state$$1.concat(this.getState(node._cells[i], children));
	        }
	      }
	    }

	    return state$$1;
	  },
	  setState: function (states) {
	    if (!isArray(states)) states = [states];

	    for (var i = 0; i < states.length; i++) {
	      var state$$1 = states[i];
	      var node = $$(state$$1.id);
	      if (!node) continue;
	      if (!isUndefined(state$$1.collapsed)) node.define("collapsed", state$$1.collapsed);
	      if (!isUndefined(state$$1.activeCell)) node.setValue(state$$1.activeCell);
	      node.define("width", state$$1.width);
	      node.define("height", state$$1.height);
	      node.define("gravity", state$$1.gravity);
	    }

	    var top = $$(states[0].id);
	    if (top) top.resize();
	  }
	};
	ready(function () {
	  UIManager._enable();

	  UIManager.addHotKey("enter", function (view, ev) {
	    if (view && view.callEvent) view.callEvent("onEnter", [ev]);

	    if (view && view.editStop && view._in_edit_mode) {
	      view.editStop();
	      return true;
	    } else if (view && view.touchable) {
	      var form = view.getFormView();
	      if (form && !view._skipSubmit) form.callEvent("onSubmit", [view, ev]);
	    }
	  });
	  UIManager.addHotKey("esc", function (view) {
	    if (view) {
	      if (view.editCancel && view._in_edit_mode) {
	        view.editCancel();
	        return true;
	      }

	      var top = view.getTopParentView();
	      if (top && top.setPosition) top._hide();
	    }
	  });
	  UIManager.addHotKey("shift+tab", UIManager._tab_logic);
	  UIManager.addHotKey("tab", UIManager._tab_logic);
	});
	define("UIManager", UIManager);

	var Settings = {
	  $init: function () {
	    /* 
	    	property can be accessed as this.config.some
	    	in same time for inner call it have sense to use _settings
	    	because it will be minified in final version
	    */
	    this._settings = this.config = {};
	  },
	  define: function (property, value) {
	    if (_typeof(property) == "object") return this._parseSeetingColl(property);
	    return this._define(property, value);
	  },
	  _define: function (property, value) {
	    //method with name {prop}_setter will be used as property setter
	    //setter is optional
	    var setter = this[property + "_setter"];
	    return this._settings[property] = setter ? setter.call(this, value, property) : value;
	  },
	  //process configuration object
	  _parseSeetingColl: function (coll) {
	    if (coll) {
	      for (var a in coll) {
	        //for each setting
	        this._define(a, coll[a]);
	      } //set value through config

	    }
	  },
	  //helper for object initialization
	  _parseSettings: function (obj, initial) {
	    //initial - set of default values
	    var settings = {};
	    if (initial) settings = exports.extend(settings, initial); //code below will copy all properties over default one

	    if (_typeof(obj) == "object" && !obj.tagName) exports.extend(settings, obj, true); //call config for each setting

	    this._parseSeetingColl(settings);
	  },
	  _mergeSettings: function (config, defaults) {
	    for (var key in defaults) {
	      switch (_typeof(config[key])) {
	        case "object":
	          config[key] = this._mergeSettings(config[key] || {}, defaults[key]);
	          break;

	        case "undefined":
	          config[key] = defaults[key];
	          break;

	        default:
	          //do nothing
	          break;
	      }
	    }

	    return config;
	  }
	};

	var Destruction = {
	  $init: function () {
	    //wrap in object to simplify removing self-reference
	    var t = this._destructor_handler = {
	      obj: this
	    }; //register self in global list of destructors

	    state.destructors.push(t);
	  },
	  //will be called automatically on unload, can be called manually
	  //simplifies job of GC
	  destructor: function () {
	    var config = this._settings;
	    if (this._last_editor) this.editCancel();
	    if (this.callEvent) this.callEvent("onDestruct", []); //destructor can be called only once

	    this.destructor = function () {}; //remove self reference from global destructions collection


	    this._destructor_handler.obj = null; //destroy child and related cells

	    if (this.getChildViews) {
	      var cells = this.getChildViews();
	      if (cells) for (var i = 0; i < cells.length; i++) {
	        cells[i].destructor();
	      }
	      if (this._destroy_with_me) for (var _i = 0; _i < this._destroy_with_me.length; _i++) {
	        this._destroy_with_me[_i].destructor();
	      }
	    }

	    delete ui.views[config.id];

	    if (config.$id) {
	      var top = this.getTopParentView();
	      if (top && top._destroy_child) top._destroy_child(config.$id);
	    } //html collection


	    this._htmlmap = null;
	    this._htmlrows = null;
	    this._html = null;

	    if (this._contentobj) {
	      this._contentobj.innerHTML = "";
	      this._contentobj._htmlmap = null;
	    } //removes view container


	    if (this._viewobj && this._viewobj.parentNode) {
	      this._viewobj.parentNode.removeChild(this._viewobj);
	    }

	    if (this.data && this.data.destructor) this.data.destructor();
	    if (this.unbind) this.unbind();
	    this.data = null;
	    this._viewobj = this.$view = this._contentobj = this._dataobj = null;
	    this._evs_events = this._evs_handlers = {}; //remove focus from destructed view

	    if (UIManager._view == this) UIManager._view = null;
	    var url = config.url;
	    if (url && url.$proxy && url.release) url.release();
	    this.$scope = null; // this flag is checked in delay method

	    this.$destructed = true;
	  }
	}; //global list of destructors

	event$1(window, "unload", function () {
	  callEvent("unload", []);
	  state._final_destruction = true; //call all registered destructors

	  for (var i = 0; i < state.destructors.length; i++) {
	    var obj = state.destructors[i].obj;
	    if (obj) obj.destructor();
	  }

	  state.destructors = [];
	  state._popups = toArray();

	  _events_final_destructor();
	});

	var CollectionBind = {
	  $init: function () {
	    this._cursor = null;
	    this.attachEvent("onSelectChange", function () {
	      var sel = this.getSelectedId();
	      this.setCursor(sel ? sel.id || sel : null);
	    });
	    this.attachEvent("onAfterCursorChange", this._update_binds);
	    this.attachEvent("onAfterDelete", function (id) {
	      if (id == this.getCursor()) this.setCursor(null);
	    });
	    this.data.attachEvent("onStoreUpdated", bind(function (id, data, mode) {
	      //paint - ignored
	      //delete - handled by onAfterDelete above
	      if (id && id == this.getCursor() && mode != "paint" && mode != "delete") this._update_binds();
	    }, this));
	    this.data.attachEvent("onClearAll", bind(function () {
	      this._cursor = null;
	    }, this));
	    this.data.attachEvent("onIdChange", bind(function (oldid, newid) {
	      if (this._cursor == oldid) {
	        this._cursor = newid;

	        this._update_binds();
	      }
	    }, this));
	  },
	  refreshCursor: function () {
	    if (this._cursor) this.callEvent("onAfterCursorChange", [this._cursor]);
	  },
	  setCursor: function (id) {
	    if (id == this._cursor || id !== null && !this.getItem(id)) return;
	    this.callEvent("onBeforeCursorChange", [this._cursor]);
	    this._cursor = id;
	    this.callEvent("onAfterCursorChange", [id]);
	  },
	  getCursor: function () {
	    return this._cursor;
	  },
	  _bind_update: function (target, rule, format) {
	    if (rule == "$level" && this.data.getBranch) return (target.data || target).importData(this.data.getBranch(this.getCursor()));
	    var data = this.getItem(this.getCursor()) || this._settings.defaultData || null;

	    if (rule == "$data") {
	      if (typeof format === "function") format.call(target, data, this);else target.data.importData(data ? data[format] : []);
	      target.callEvent("onBindApply", [data, rule, this]);
	    } else {
	      if (format) data = format(data);

	      this._bind_update_common(target, rule, data);
	    }
	  }
	};

	var ValueBind = {
	  $init: function () {
	    this.attachEvent("onChange", this._update_binds);
	  },
	  _bind_update: function (target, rule, format) {
	    rule = rule || "value";
	    var data = this.getValue() || "";
	    if (format) data = format(data);
	    if (target.setValue) target.setValue(data);else if (!target.filter) {
	      var pod = {};
	      pod[rule] = data;
	      if (target._check_data_feed(data)) target.setValues(pod);
	    } else {
	      target.data.silent(function () {
	        this.filter(rule, data);
	      });
	    }
	    target.callEvent("onBindApply", [data, rule, this]);
	  }
	};

	var RecordBind = {
	  $init: function () {
	    this.attachEvent("onChange", this._update_binds);
	  },
	  _bind_update: function (target, rule, format) {
	    var data = this.getValues() || null;
	    if (format) data = format(data);

	    this._bind_update_common(target, rule, data);
	  }
	};

	var BindSource = {
	  $init: function () {
	    this._bind_hash = {}; //rules per target

	    this._bind_updated = {}; //update flags

	    this._ignore_binds = {}; //apply specific bind extension

	    this._bind_specific_rules(this);
	  },
	  saveBatch: function (code) {
	    this._do_not_update_binds = true;
	    code.call(this);
	    this._do_not_update_binds = false;

	    this._update_binds();
	  },
	  setBindData: function (data, key) {
	    //save called, updating master data
	    if (key) this._ignore_binds[key] = true;
	    if (this.setValue) this.setValue(data);else if (this.setValues) this.setValues(data);else {
	      var id = this.getCursor();
	      if (id) this.updateItem(id, data);else this.add(data);
	    }
	    this.callEvent("onBindUpdate", [data, key]);
	    if (this.save) this.save();
	    if (key) this._ignore_binds[key] = false;
	  },
	  //fill target with data
	  getBindData: function (key, update) {
	    //fire only if we have data updates from the last time
	    if (this._bind_updated[key]) return false;
	    var target = $$(key); //fill target only when it visible

	    if (target.isVisible(target._settings.id)) {
	      this._bind_updated[key] = true;

	      this._bind_update(target, this._bind_hash[key][0], this._bind_hash[key][1]); //trigger component specific updating logic


	      if (update && target.filter) target.refresh();
	    }
	  },
	  //add one more bind target
	  addBind: function (source, rule, format) {
	    this._bind_hash[source] = [rule, format];
	  },
	  removeBind: function (source) {
	    delete this._bind_hash[source];
	    delete this._bind_updated[source];
	    delete this._ignore_binds[source];
	  },
	  //returns true if object belong to "collection" type
	  _bind_specific_rules: function (obj) {
	    if (obj.filter) exports.extend(this, CollectionBind);else if (obj.setValue) exports.extend(this, ValueBind);else exports.extend(this, RecordBind);
	  },
	  //inform all binded objects, that source data was updated
	  _update_binds: function () {
	    if (!this._do_not_update_binds) for (var key in this._bind_hash) {
	      if (this._ignore_binds[key]) continue;
	      this._bind_updated[key] = false;
	      this.getBindData(key, true);
	    }
	  },
	  //copy data from source to the target
	  _bind_update_common: function (target, rule, data) {
	    if (target.setValue) target.setValue(data && rule ? data[rule] : data);else if (!target.filter) {
	      if (!data && target.clear) target.clear();else {
	        if (target._check_data_feed(data)) target.setValues(clone(data));
	      }
	    } else {
	      target.data.silent(function () {
	        this.filter(rule, data);
	      });
	    }
	    target.callEvent("onBindApply", [data, rule, this]);
	  }
	};

	var BaseBind = {
	  bind: function (target, rule, format) {
	    if (!this.attachEvent) exports.extend(this, EventSystem);
	    if (typeof target == "string") target = $$(target);
	    if (target._initBindSource) target._initBindSource();
	    if (this._initBindSource) this._initBindSource();
	    if (!target.getBindData) exports.extend(target, BindSource);

	    this._bind_ready();

	    target.addBind(this._settings.id, rule, format);
	    this._bind_source = target._settings.id;
	    var target_id = this._settings.id; //FIXME - check for touchable is not the best solution, to detect necessary event

	    this._bind_refresh_handler = this.attachEvent(this.touchable ? "onAfterRender" : "onBindRequest", function () {
	      return target.getBindData(target_id);
	    });
	    if (this.refresh && this.isVisible(this._settings.id)) this.refresh();
	  },
	  unbind: function () {
	    if (this._bind_source) {
	      var target = $$(this._bind_source);
	      if (target) target.removeBind(this._settings.id);
	      this.detachEvent(this._bind_refresh_handler);
	      this._bind_source = null;
	    }
	  },
	  _bind_ready: function () {
	    var config = this._settings;

	    if (this.filter) {
	      var key = config.id;
	      this.data._on_sync = bind(function () {
	        $$(this._bind_source)._bind_updated[key] = false;
	      }, this);
	    }

	    var old_render = this.render;

	    this.render = function () {
	      if (this._in_bind_processing) return;
	      this._in_bind_processing = true;
	      var result = this.callEvent("onBindRequest");
	      this._in_bind_processing = false;
	      return old_render.apply(this, result === false ? arguments : []);
	    };

	    if (this.getValue || this.getValues) this.save = function (data) {
	      var source = $$(this._bind_source);
	      if (data) source.setBindData(data);else {
	        if (this.validate && !this.validate()) return false;
	        var values = this.getValue ? this.getValue : this.getValues();
	        source.setBindData(values, this._settings.id); //reset form, so it will be counted as saved

	        if (this.setDirty) this.setDirty(false);
	      }
	    };

	    this._bind_ready = function () {};
	  }
	};

	var UIExtension = window.webix_view || {};
	var api = {
	  name: "baseview",
	  //attribute , which will be used for ID storing
	  $init: function (config) {
	    if (!config.id) config.id = _uid(this.name);
	    this._parent_cell = state._parent_cell;
	    state._parent_cell = null; // if scope not provided directly, and there is no parent view
	    // check if we have a global scope

	    this.$scope = config.$scope || (this._parent_cell ? this._parent_cell.$scope : state._global_scope);

	    if (!this._viewobj) {
	      this._contentobj = this._viewobj = create("DIV", {
	        "class": "webix_view"
	      });
	      this.$view = this._viewobj;
	    }
	  },
	  $skin: false,
	  defaults: {
	    width: 0,
	    height: 0,
	    gravity: 1
	  },
	  getNode: function () {
	    return this._viewobj;
	  },
	  getParentView: function () {
	    return this._parent_cell || null;
	  },
	  getTopParentView: function () {
	    var parent = this.getParentView();
	    return parent ? parent.getTopParentView() : this;
	  },
	  getFormView: function () {
	    var parent = this.getParentView();
	    return !parent || parent.setValues ? parent : parent.getFormView();
	  },
	  getChildViews: function () {
	    return [];
	  },
	  queryView: function (search, all) {
	    var confirm;
	    if (typeof search === "string") search = {
	      view: search
	    };

	    if (_typeof(search) === "object") {
	      //IE8 compatibility
	      confirm = function (test) {
	        var config = test.config;

	        for (var key in search) {
	          if (config[key] != search[key]) return false;
	        }

	        return true;
	      };
	    } else confirm = search;

	    if (all === "self" && confirm(this)) return this;
	    var results = all === "all" ? [] : false;
	    var direction = all === "parent" ? this._queryGoUp : this._queryGoDown;

	    var found = this._queryView(confirm, direction, results);

	    return all === "all" ? results : found;
	  },
	  _queryGoDown: function (node) {
	    return node.getChildViews();
	  },
	  _queryGoUp: function (node) {
	    var parent = node.getParentView();
	    return parent ? [parent] : [];
	  },
	  _queryView: function (confirm, next, all) {
	    var kids = next(this);

	    for (var i = 0; i < kids.length; i++) {
	      if (confirm(kids[i])) {
	        if (all) all.push(kids[i]);else return kids[i];
	      }

	      var sub = kids[i]._queryView(confirm, next, all);

	      if (sub && !all) {
	        return sub;
	      }
	    }

	    return null;
	  },
	  isVisible: function (base_id) {
	    if (this._settings.hidden) {
	      if (base_id) {
	        if (!this._hidden_render) {
	          this._hidden_render = [];
	          this._hidden_hash = {};
	        }

	        if (!this._hidden_hash[base_id]) {
	          this._hidden_hash[base_id] = true;

	          this._hidden_render.push(base_id);
	        }
	      }

	      return false;
	    }

	    var parent = this.getParentView();
	    if (parent) return parent.isVisible(base_id, this._settings.id);
	    return true;
	  },
	  isEnabled: function () {
	    if (this._disable_cover) return false;
	    var parent = this.getParentView();
	    if (parent) return parent.isEnabled();
	    return true;
	  },
	  disable: function () {
	    remove(this._disable_cover);
	    this._settings.disabled = true;
	    this._disable_cover = create("div", {
	      "class": "webix_disabled"
	    });

	    this._viewobj.appendChild(this._disable_cover);

	    this._viewobj.setAttribute("aria-disabled", "true");

	    addCss(this._viewobj, "webix_disabled_view", true);

	    UIManager._moveChildFocus(this);
	  },
	  enable: function () {
	    this._settings.disabled = false;

	    if (this._disable_cover) {
	      remove(this._disable_cover);
	      removeCss(this._viewobj, "webix_disabled_view");

	      this._viewobj.removeAttribute("aria-disabled");

	      this._disable_cover = null;
	    }
	  },
	  disabled_setter: function (value) {
	    if (value) this.disable();else this.enable();
	    return value;
	  },
	  container_setter: function (value) {
	    assert(toNode(value), "Invalid container");
	    return true;
	  },
	  css_setter: function (value) {
	    if (_typeof(value) == "object") value = createCss(value);
	    this._viewobj.className += " " + value;
	    return value;
	  },
	  id_setter: function (value) {
	    if (state._global_collection && (state._global_collection != this || this._prev_global_col)) {
	      var oldvalue = this.config.$id = value;
	      (this._prev_global_col || state._global_collection)._elements[value] = this;
	      value = _uid(this.name);
	      (this._prev_global_col || state._global_collection)._translate_ids[value] = oldvalue;
	    }

	    assert(!ui.views[value], "Non unique view id: " + value);
	    ui.views[value] = this;

	    this._viewobj.setAttribute("view_id", value);

	    return value;
	  },
	  $setSize: function (x, y) {
	    var last = this._last_size;

	    if (last && last[0] == x && last[1] == y) {
	      debug_size_box(this, [x, y, "not changed"]);
	      return false;
	    }

	    debug_size_box(this, [x, y]);
	    this._last_size = [x, y];
	    this.$width = this._content_width = x - (this._scroll_y ? env.scrollSize : 0);
	    this.$height = this._content_height = y - (this._scroll_x ? env.scrollSize : 0);
	    var config = this._settings;

	    if (!config.flex) {
	      this._viewobj.style.width = x + "px";
	      this._viewobj.style.height = y + "px";
	    }

	    return true;
	  },
	  $getSize: function (dx, dy) {
	    var s = this._settings;
	    var size = [(s.width || s.minWidth || 0) * 1, (s.width || s.maxWidth || 100000) * 1, (s.height || s.minHeight || 0) * 1, (s.height || s.maxHeight || 100000) * 1, s.gravity];

	    if (assert) {
	      var check = isNaN(size[0]) || isNaN(size[1]) || isNaN(size[2]) || isNaN(size[3]);

	      if (check) {
	        assert(false, "Size is not a number " + this._settings.id);
	        s.width = s.height = s.maxWidth = s.maxHeight = s.minWidth = s.minHeight = 0;
	        size = [0, 0, 100000, 100000, 1];
	      }
	    }

	    size[0] += dx;
	    size[1] += dx;
	    size[2] += dy;
	    size[3] += dy;
	    return size;
	  },
	  show: function (force, animate_settings) {
	    var parent = this.getParentView();
	    var show = !arguments[2];

	    if (parent) {
	      if (!animate_settings && animate_settings !== false && this._settings.animate) if (parent._settings.animate) animate_settings = exports.extend(parent._settings.animate ? exports.extend({}, parent._settings.animate) : {}, this._settings.animate, true);
	      if (show ? parent._show : parent._hide) (show ? parent._show : parent._hide).call(parent, this, animate_settings);
	      if (show) this._render_hidden_views(); //force show of parent view
	      //stop further processing is view is a part of isolated scope

	      if (force && show) parent.show(parent.$$ ? false : force);
	    } else {
	      if (this._settings.hidden) {
	        if (show) {
	          var node = toNode(this._settings._container || document.body);
	          node.appendChild(this._viewobj);
	          this._settings.hidden = false;
	          this.adjust();

	          this._render_hidden_views();
	        }
	      } else {
	        if (!show) {
	          this._settings.hidden = this._settings._hidden = true;

	          if (this._viewobj) {
	            this._settings._container = this._viewobj.parentNode;
	            remove(this._viewobj);
	          }
	        }
	      }
	    }
	  },
	  _render_hidden_views: function () {
	    if (this._hidden_render) {
	      for (var i = 0; i < this._hidden_render.length; i++) {
	        var ui_to_render = $$(this._hidden_render[i]);
	        if (ui_to_render) ui_to_render.render();
	      }

	      this._hidden_render = [];
	      this._hidden_hash = {};
	    }
	  },
	  _onKeyPress: function (code, e) {
	    var target = e.srcElement || e.target,
	        role = target.getAttribute("role");

	    if ((code === 13 || code === 32) && (role == "button" || role == "tab") && !this._settings.disabled) {
	      triggerEvent(target, "MouseEvents", "click");
	      preventEvent(e);
	    }
	  },
	  hidden_setter: function (value) {
	    if (value) this.hide();
	    return this._settings.hidden;
	  },
	  hide: function () {
	    this.show(null, null, true);

	    UIManager._moveChildFocus(this);
	  },
	  adjust: function () {
	    if (!this._viewobj.parentNode) return false;
	    var x = this._viewobj.parentNode.clientWidth || 0;
	    var y = this._viewobj.parentNode.clientHeight || 0;
	    var sizes = this.$getSize(0, 0);
	    var fullscreen = this._viewobj.parentNode == document.body && !this.setPosition; //minWidth

	    if (sizes[0] > x) x = sizes[0]; //minHeight

	    if (sizes[2] > y) y = sizes[2]; //maxWidth rule

	    if ((!fullscreen || this._settings.width) && x > sizes[1]) x = sizes[1]; //maxHeight rule

	    if ((!fullscreen || this._settings.height) && y > sizes[3]) y = sizes[3];
	    this.$setSize(x, y);

	    if (state._responsive_exception) {
	      state._responsive_exception = false;
	      this.adjust();
	    }
	  },
	  resize: function () {
	    if (state._child_sizing_active || state._freeze_resize || state._responsive_tinkery) return;
	    var parent = this.getParentView();

	    if (parent) {
	      if (parent.resizeChildren) parent.resizeChildren();else parent.resize();
	    } else {
	      this.adjust();
	      callEvent("onResize", []);
	    }
	  }
	};
	var view = exports.protoUI(api, Settings, Destruction, BaseBind, UIExtension);
	var baseview = {
	  api: api,
	  view: view
	};

	var api$1 = {
	  name: "view",
	  $init: function (config) {
	    this._set_inner(config);
	  },
	  //deside, will component use borders or not
	  _set_inner: function (config) {
	    var border_not_set = isUndefined(config.borderless);

	    if (border_not_set && !this.setPosition && config.$topView) {
	      config.borderless = true;
	      border_not_set = false;
	    }

	    if (border_not_set && this.defaults.borderless || config.borderless) {
	      //button and custom borderless
	      config._inner = {
	        top: true,
	        left: true,
	        bottom: true,
	        right: true
	      };
	    } else {
	      //default borders
	      if (!config._inner) config._inner = {};
	      this._contentobj.style.borderWidth = "1px";
	    }
	  },
	  $getSize: function (dx, dy) {
	    var _borders = this._settings._inner;

	    if (_borders) {
	      dx += (_borders.left ? 0 : 1) + (_borders.right ? 0 : 1);
	      dy += (_borders.top ? 0 : 1) + (_borders.bottom ? 0 : 1);
	    }

	    var size = baseview.api.$getSize.call(this, dx, dy);
	    debug_size_box(this, size, true);
	    return size;
	  },
	  $setSize: function (x, y) {
	    debug_size_box(this, [x, y]);
	    var _borders = this._settings._inner;

	    if (_borders) {
	      x -= (_borders.left ? 0 : 1) + (_borders.right ? 0 : 1);
	      y -= (_borders.top ? 0 : 1) + (_borders.bottom ? 0 : 1);
	    }

	    return baseview.api.$setSize.call(this, x, y);
	  }
	};
	var view$1 = exports.protoUI(api$1, baseview.view);
	var base = {
	  api: api$1,
	  view: view$1
	}; //not necessary anymore
	//preserving for backward compatibility

	view$1.call(-1);

	/*
		REnders single item. 
		Can be used for elements without datastore, or with complex custom rendering logic
		
		@export
			render
	*/

	var SingleRender = exports.proto({
	  template_setter: function (value) {
	    this.type.template = template(value);
	  },
	  //convert item to the HTML text
	  _toHTML: function (obj) {
	    var type$$1 = this.type;
	    return (type$$1.templateStart ? type$$1.templateStart(obj, type$$1) : "") + type$$1.template(obj, type$$1) + (type$$1.templateEnd ? type$$1.templateEnd(obj, type$$1) : "");
	  },
	  customize: function (obj) {
	    type(this, obj);
	  }
	}, AtomRender);

	/*
		UI: Tooltip
		
		@export
			show
			hide
	*/
	// #include core/template.js
	// #include core/single_render.js

	var api$2 = {
	  name: "tooltip",
	  defaults: {
	    dy: 0,
	    dx: 20
	  },
	  $init: function (container) {
	    if (typeof container == "string") {
	      container = {
	        template: container
	      };
	    } //create  container for future tooltip


	    this.$view = this._viewobj = this._contentobj = this._dataobj = create("DIV", {
	      role: "alert",
	      "aria-atomic": "true"
	    });
	    this._contentobj.className = "webix_tooltip";
	    insertBefore(this._contentobj, document.body.firstChild, document.body);
	    this._hideHandler = attachEvent("onClick", bind(function (e) {
	      if (this._visible && $$(e) != this) this.hide();
	    }, this)); //detach global event handler on destruction

	    this.attachEvent("onDestruct", function () {
	      detachEvent(this._hideHandler);
	    });
	  },
	  adjust: function () {},
	  //show tooptip
	  //pos - object, pos.x - left, pox.y - top
	  isVisible: function () {
	    return this._visible;
	  },
	  _alt_render: function (text) {
	    if (this.callEvent("onBeforeRender", [text])) {
	      //it is critical to have this as two commands
	      //its prevent destruction race in Chrome
	      this._dataobj.innerHTML = "";
	      this._dataobj.innerHTML = text;
	      this.callEvent("onAfterRender", []);
	    }
	  },
	  css_setter: function (value) {
	    if (_typeof(value) === "object") value = createCss(value);
	    this._viewobj.className = "webix_tooltip " + value;
	    return value;
	  },
	  show: function (data, pos$$1) {
	    if (this._disabled) return;
	    this._visible = true;
	    if (typeof data === "string") this._alt_render(data);else {
	      this.data = exports.extend({}, data);
	      this.render();
	    }

	    if (this._dataobj.firstChild) {
	      //show at specified position
	      var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	      var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	      var positionX = w - pos$$1.x;
	      var positionY = h - pos$$1.y;
	      this._contentobj.style.display = "block";
	      if (positionX - this._settings.dx > this._contentobj.offsetWidth) positionX = pos$$1.x;else {
	        positionX = pos$$1.x - this._settings.dx * 2 - this._contentobj.offsetWidth;
	        if (positionX <= 0) positionX = 0;
	      }
	      if (positionY - this._settings.dy > this._contentobj.offsetHeight) positionY = pos$$1.y;else positionY = pos$$1.y - this._settings.dy - this._contentobj.offsetHeight;
	      this._contentobj.style.left = positionX + this._settings.dx + "px";
	      this._contentobj.style.top = positionY + this._settings.dy + "px";
	    } else this.hide();
	  },
	  //hide tooltip
	  hide: function () {
	    this.data = null; //nulify, to be sure that on next show it will be fresh-rendered

	    this._contentobj.style.display = "none";
	    this._visible = false;
	  },
	  disable: function () {
	    this._disabled = true;
	  },
	  enable: function () {
	    this._disabled = false;
	  },
	  type: {
	    template: template("{obj.value}"),
	    templateStart: template.empty,
	    templateEnd: template.empty
	  }
	};
	var view$2 = exports.protoUI(api$2, SingleRender, Settings, EventSystem, base.view);

	/*
		Behavior: AutoTooltip - links tooltip to data driven item
	*/

	var AutoTooltip = {
	  tooltip_setter: function (value) {
	    if (value) {
	      if (typeof value === "function" || typeof value === "string") value = {
	        template: value
	      };
	      if (_typeof(value) !== "object") value = {};
	      TooltipControl.addTooltip(this);
	      this.attachEvent("onDestruct", function () {
	        TooltipControl.removeTooltip(this);
	      });
	      this.attachEvent("onAfterScroll", function () {
	        if (TooltipControl._tooltip_exist) TooltipControl._hide_tooltip();
	      });
	      return value;
	    }
	  },
	  $tooltipIn: function (t) {
	    var tooltip = TooltipControl._tooltip;
	    var def = exports.extend({
	      dx: 20,
	      dy: 0,
	      template: "{obj.value}",
	      css: ""
	    }, this._settings.tooltip, true);
	    tooltip.define(def);
	    return t;
	  },
	  $tooltipOut: function () {
	    TooltipControl._hide_tooltip();

	    delete TooltipControl._tooltip.type.column;
	    return null;
	  },
	  $tooltipMove: function (t, e, text) {
	    TooltipControl._tooltip.hide();

	    clearTimeout(TooltipControl._before_show_delay);
	    TooltipControl._before_show_delay = delay(this._show_tooltip, this, [t, e, text], TooltipControl.delay);
	  },
	  _show_tooltip: function (t, e, text) {
	    var data = text || this._get_tooltip_data(t, e);

	    if (!data) return;

	    TooltipControl._tooltip.show(data, pos(e));
	  },
	  _get_tooltip_data: function (t, e) {
	    if (this.locate && this.getItem) {
	      var id = this.locate(e);
	      if (!id) return null;
	      return this.getItem(id);
	    }

	    return this._settings;
	  }
	};

	var Canvas = exports.proto({
	  $init: function (container) {
	    this._canvas_labels = [];
	    this._canvas_series = !isUndefined(container.series) ? container.series : container.name;
	    this._obj = toNode(container.container || container);
	    var width = container.width * (window.devicePixelRatio || 1);
	    var height = container.height * (window.devicePixelRatio || 1);
	    var style = container.style || "";
	    style += ";width:" + container.width + "px;height:" + container.height + "px;";

	    this._prepareCanvas(container.name, style, width, height, container.title);
	  },
	  _prepareCanvas: function (name, style, x, y, title) {
	    //canvas has the same size as master object
	    this._canvas = create("canvas", {
	      title: title,
	      width: x,
	      height: y,
	      canvas_id: name,
	      style: style || ""
	    });

	    this._obj.appendChild(this._canvas); //use excanvas in IE


	    if (!this._canvas.getContext) {
	      if (env.isIE) {
	        require("legacy/excanvas/excanvas.js", true); //sync loading

	        /* global G_vmlCanvasManager */


	        G_vmlCanvasManager.init_(document);
	        G_vmlCanvasManager.initElement(this._canvas);
	      } else //some other not supported browser
	        assert(this._canvas.getContext, "Canvas is not supported in the browser");
	    }

	    return this._canvas;
	  },
	  getCanvas: function (context) {
	    var ctx = (this._canvas || this._prepareCanvas(this._contentobj)).getContext(context || "2d");

	    if (!this._webixDevicePixelRatio) {
	      this._webixDevicePixelRatio = true;
	      ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);
	    }

	    return ctx;
	  },
	  _resizeCanvas: function (x, y) {
	    if (this._canvas) {
	      this._canvas.setAttribute("width", x * (window.devicePixelRatio || 1));

	      this._canvas.setAttribute("height", y * (window.devicePixelRatio || 1));

	      this._canvas.style.width = x + "px";
	      this._canvas.style.height = y + "px";
	      this._webixDevicePixelRatio = false;
	    }
	  },
	  renderText: function (x, y, text, css, w) {
	    if (!text) return; //ignore empty text

	    if (w) w = Math.max(w, 0);
	    if (y) y = Math.max(y, 0);
	    var t = create("DIV", {
	      "class": "webix_canvas_text" + (css ? " " + css : ""),
	      "style": "left:" + x + "px; top:" + y + "px;",
	      "aria-hidden": "true"
	    }, text);

	    this._obj.appendChild(t);

	    this._canvas_labels.push(t); //destructor?


	    if (w) t.style.width = w + "px";
	    return t;
	  },
	  renderTextAt: function (valign, align, x, y, t, c, w) {
	    var text = this.renderText.call(this, x, y, t, c, w);

	    if (text) {
	      if (valign) {
	        if (valign == "middle") text.style.top = parseInt(y - text.offsetHeight / 2, 10) + "px";else text.style.top = y - text.offsetHeight + "px";
	      }

	      if (align) {
	        if (align == "left") text.style.left = x - text.offsetWidth + "px";else text.style.left = parseInt(x - text.offsetWidth / 2, 10) + "px";
	      }
	    }

	    return text;
	  },
	  clearCanvas: function (skipMap) {
	    var areas = [];
	    remove(this._canvas_labels);
	    this._canvas_labels = [];

	    if (!skipMap && this._obj._htmlmap) {
	      //areas that correspond this canvas layer
	      areas = this._getMapAreas(); //removes areas of this canvas

	      while (areas.length) {
	        areas[0].parentNode.removeChild(areas[0]);
	        areas.splice(0, 1);
	      }

	      areas = null; //removes _htmlmap object if all its child nodes are removed

	      if (!this._obj._htmlmap.getElementsByTagName("AREA").length) {
	        this._obj._htmlmap.parentNode.removeChild(this._obj._htmlmap);

	        this._obj._htmlmap = null;
	      }
	    } //FF breaks, when we are using clear canvas and call clearRect without parameters
	    //width|height are used insead of offsetWidth|offsetHeight for hidden canvas (series)


	    this.getCanvas().clearRect(0, 0, this._canvas.offsetWidth || Math.floor(this._canvas.width / (window.devicePixelRatio || 1)), this._canvas.offsetHeight || Math.floor(this._canvas.height / (window.devicePixelRatio || 1)));
	  },
	  toggleCanvas: function () {
	    this._toggleCanvas(this._canvas.style.display == "none");
	  },
	  showCanvas: function () {
	    this._toggleCanvas(true);
	  },
	  hideCanvas: function () {
	    this._toggleCanvas(false);
	  },
	  _toggleCanvas: function (show) {
	    var areas, i;

	    for (i = 0; i < this._canvas_labels.length; i++) {
	      this._canvas_labels[i].style.display = show ? "" : "none";
	    }

	    if (this._obj._htmlmap) {
	      areas = this._getMapAreas();

	      for (i = 0; i < areas.length; i++) {
	        if (show) areas[i].removeAttribute("disabled");else areas[i].setAttribute("disabled", "true");
	      }
	    } //FF breaks, when we are using clear canvas and call clearRect without parameters


	    this._canvas.style.display = show ? "" : "none";
	  },
	  _getMapAreas: function () {
	    var res = [],
	        areas,
	        i;
	    areas = this._obj._htmlmap.getElementsByTagName("AREA");

	    for (i = 0; i < areas.length; i++) {
	      if (areas[i].getAttribute("userdata") == this._canvas_series) {
	        res.push(areas[i]);
	      }
	    }

	    return res;
	  }
	});

	var animate = function (html_element, config) {
	  var animation = config;

	  if (isArray(html_element)) {
	    for (var i = 0; i < html_element.length; i++) {
	      if (isArray(config)) animation = config[i];

	      if (animation.type == "slide") {
	        if (animation.subtype == "out" && i === 0) {
	          // next
	          continue;
	        }

	        if (animation.subtype == "in" && i == 1) {
	          // current
	          continue;
	        }
	      }

	      if (animation.type == "flip") {
	        var animation_copy = clone(animation);

	        if (i === 0) {
	          // next
	          animation_copy.type = "flipback";
	        }

	        if (i == 1) {
	          // current
	          animation_copy.callback = null;
	        }

	        animate(html_element[i], animation_copy);
	        continue;
	      }

	      animate(html_element[i], animation);
	    }

	    return;
	  }

	  var node = toNode(html_element);
	  if (node._has_animation) animate.end(node, animation);else animate.start(node, animation);
	};

	animate.end = function (node, animation) {
	  //stop animation
	  node.style[env.transitionDuration] = "1ms";
	  node._has_animation = null; //clear animation wait order, if any

	  if (state._wait_animate) window.clearTimeout(state._wait_animate); //plan next animation, if any

	  state._wait_animate = delay(animate, this, [node, animation], 10);
	};

	animate.isSupported = function () {
	  return !state.noanimate && env.transform && env.transition && !env.isOpera;
	};

	animate.formLine = function (next, current, animation) {
	  var direction = animation.direction; //sometimes user can initiate animation multiple times ( fast clicking )
	  //as result animation may be called against already removed from the dom node

	  if (current.parentNode) current.parentNode.style.position = "relative";
	  current.style.position = "absolute";
	  next.style.position = "absolute"; //this is initial shift of second view in animation
	  //normally we need to have this value as 0
	  //but FF has bug with animation initially invisible elements
	  //so we are adjusting this value, to make 1px of second view visible

	  var defAniPos = env.isFF ? direction == "top" || direction == "left" ? -1 : 1 : 0;

	  if (direction == "top" || direction == "bottom") {
	    next.style.left = "0px";
	    next.style.top = (animation.top || defAniPos) + (direction == "top" ? 1 : -1) * current.offsetHeight + "px";
	  } else {
	    next.style.top = (animation.top || 0) + "px";
	    next.style.left = defAniPos + (direction == "left" ? 1 : -1) * current.offsetWidth + "px";
	  } // apply 'keepViews' mode, iframe, datatable with x scroll solution
	  //( keepViews won't work in case of "in" and "out" subtypes )


	  if (current.parentNode == next.parentNode && animation.keepViews) next.style.display = "";else insertBefore(next, current.nextSibling, current.parentNode);

	  if (animation.type == "slide" && animation.subtype == "out") {
	    next.style.left = "0px";
	    next.style.top = (animation.top || 0) + "px";
	    current.parentNode.removeChild(current);
	    insertBefore(current, next.nextSibling, next.parentNode);
	  }

	  return [next, current];
	};

	animate.breakLine = function (line) {
	  if (arguments[1]) line[1].style.display = "none"; // 'keepViews' multiview mode
	  else remove(line[1]); // 1 = current

	  animate.clear(line[0]);
	  animate.clear(line[1]);
	  line[0].style.position = "";
	};

	animate.clear = function (node) {
	  node.style[env.transform] = "none";
	  node.style[env.transition] = "none";
	  node.style.top = node.style.left = "";
	};

	animate.defaults = {
	  type: "slide",
	  delay: "0",
	  duration: "500",
	  timing: "ease-in-out",
	  x: 0,
	  y: 0
	};

	animate.start = function (node, animation) {
	  //getting config object by merging specified and default options
	  if (typeof animation == "string") animation = {
	    type: animation
	  };
	  animation = Settings._mergeSettings(animation, animate.defaults);
	  var prefix = env.cssPrefix;
	  var settings = node._has_animation = animation;
	  var skew_options, scale_type; //jshint -W086:true

	  switch (settings.type == "slide" && settings.direction) {
	    // getting new x, y in case it is slide with direction
	    case "right":
	      settings.x = node.offsetWidth;
	      break;

	    case "left":
	      settings.x = -node.offsetWidth;
	      break;

	    case "top":
	      settings.y = -node.offsetHeight;
	      break;

	    case "bottom":
	    default:
	      settings.y = settings.y || node.offsetHeight;
	      break;
	  }

	  if (settings.type == "flip" || settings.type == "flipback") {
	    skew_options = [0, 0];
	    scale_type = "scaleX";

	    if (settings.subtype == "vertical") {
	      skew_options[0] = 20;
	      scale_type = "scaleY";
	    } else skew_options[1] = 20;

	    if (settings.direction == "right" || settings.direction == "bottom") {
	      skew_options[0] *= -1;
	      skew_options[1] *= -1;
	    }
	  }

	  var duration = settings.duration + "ms " + settings.timing + " " + settings.delay + "ms";
	  var css_general = prefix + "TransformStyle: preserve-3d;"; // general css rules

	  var css_transition = "";
	  var css_transform = "";

	  switch (settings.type) {
	    case "fade":
	      // changes opacity to 0
	      css_transition = "opacity " + duration;
	      css_general = "opacity: 0;";
	      break;

	    case "show":
	      // changes opacity to 1
	      css_transition = "opacity " + duration;
	      css_general = "opacity: 1;";
	      break;

	    case "flip":
	      duration = settings.duration / 2 + "ms " + settings.timing + " " + settings.delay + "ms";
	      css_transform = "skew(" + skew_options[0] + "deg, " + skew_options[1] + "deg) " + scale_type + "(0.00001)";
	      css_transition = "all " + duration;
	      break;

	    case "flipback":
	      settings.delay += settings.duration / 2;
	      duration = settings.duration / 2 + "ms " + settings.timing + " " + settings.delay + "ms";
	      node.style[env.transform] = "skew(" + -1 * skew_options[0] + "deg, " + -1 * skew_options[1] + "deg) " + scale_type + "(0.00001)";
	      node.style.left = "0";
	      css_transform = "skew(0deg, 0deg) " + scale_type + "(1)";
	      css_transition = "all " + duration;
	      break;

	    case "slide":
	      // moves object to specified location
	      var x = settings.x + "px";
	      var y = settings.y + "px"; // translate(x, y) OR translate3d(x, y, 0)

	      css_transform = env.translate + "(" + x + ", " + y + (env.translate == "translate3d" ? ", 0" : "") + ")";
	      css_transition = prefix + "transform " + duration;
	      break;

	    default:
	      break;
	  } //set styles only after applying transition settings


	  delay(function () {
	    node.style[env.transition] = css_transition;
	    delay(function () {
	      if (css_general) node.style.cssText += css_general;
	      if (css_transform) node.style[env.transform] = css_transform;
	      var transitionEnded = false;
	      var tid = event$1(node, env.transitionEnd, function (ev) {
	        node._has_animation = null;
	        if (settings.callback) settings.callback.call(settings.master || window, node, settings, ev);
	        transitionEnded = true;
	        eventRemove(tid);
	      });
	      window.setTimeout(function () {
	        if (!transitionEnded) {
	          node._has_animation = null;
	          if (settings.callback) settings.callback.call(settings.master || window, node, settings);
	          transitionEnded = true;
	          eventRemove(tid);
	        }
	      }, (settings.duration * 1 + settings.delay * 1) * 1.3);
	    });
	  });
	};

	var skin = {
	  topLayout: "space",
	  //bar in accordion
	  barHeight: 44,
	  //!!!Set the same in skin.less!!!
	  tabbarHeight: 42,
	  sidebarTitleHeight: 44,
	  rowHeight: 36,
	  toolbarHeight: 44,
	  listItemHeight: 36,
	  //list, grouplist, dataview, etc.
	  inputHeight: 38,
	  buttonHeight: 38,
	  inputPadding: 3,
	  menuHeight: 36,
	  labelTopHeight: 22,
	  propertyItemHeight: 28,
	  unitHeaderHeight: 36,
	  inputSpacing: 4,
	  borderWidth: 1,
	  sliderHandleWidth: 14,
	  sliderPadding: 10,
	  sliderBorder: 1,
	  vSliderPadding: 15,
	  vSliderHeight: 100,
	  switchHeight: 22,
	  switchWidth: 50,
	  //margin - distance between cells
	  layoutMargin: {
	    space: 10,
	    wide: 10,
	    clean: 0,
	    head: 4,
	    line: -1,
	    toolbar: 4,
	    form: 8,
	    accordion: 2
	  },
	  //padding - distance inside cell between cell border and cell content
	  layoutPadding: {
	    space: 10,
	    wide: 0,
	    clean: 0,
	    head: 0,
	    line: 0,
	    toolbar: 2,
	    form: 17,
	    accordion: 0
	  },
	  //space between tabs in tabbar
	  tabMargin: 0,
	  tabOffset: 0,
	  tabBottomOffset: 0,
	  tabTopOffset: 0,
	  tabBorder: true,
	  customCheckbox: true,
	  customRadio: true,
	  sidebarMarkAll: true,
	  popupNoPoint: true,
	  borderlessPopup: true,
	  popupPadding: 0,
	  calendar: {
	    timepickerHeight: 24
	  },
	  calendarHeight: 70,
	  padding: 0,
	  accordionType: "accordion",
	  optionHeight: 32,
	  organogramLineColor: "#CCD7E6"
	};

	var skin$1 = {
	  topLayout: "space",
	  //bar in accordion
	  barHeight: 36,
	  //!!!Set the same in skin.less!!!
	  tabbarHeight: 34,
	  sidebarTitleHeight: 36,
	  rowHeight: 28,
	  toolbarHeight: 36,
	  listItemHeight: 28,
	  //list, grouplist, dataview, etc.
	  inputHeight: 30,
	  buttonHeight: 30,
	  inputPadding: 3,
	  menuHeight: 28,
	  labelTopHeight: 16,
	  propertyItemHeight: 24,
	  unitHeaderHeight: 28,
	  inputSpacing: 4,
	  borderWidth: 1,
	  sliderHandleWidth: 12,
	  sliderPadding: 10,
	  sliderBorder: 1,
	  vSliderPadding: 13,
	  vSliderHeight: 100,
	  switchHeight: 20,
	  switchWidth: 40,
	  //margin - distance between cells
	  layoutMargin: {
	    space: 5,
	    wide: 5,
	    clean: 0,
	    head: 4,
	    line: -1,
	    toolbar: 4,
	    form: 8,
	    accordion: 2
	  },
	  //padding - distance inside cell between cell border and cell content
	  layoutPadding: {
	    space: 5,
	    wide: 0,
	    clean: 0,
	    head: 0,
	    line: 0,
	    toolbar: 2,
	    form: 12,
	    accordion: 0
	  },
	  //space between tabs in tabbar
	  tabMargin: 0,
	  tabOffset: 0,
	  tabBottomOffset: 0,
	  tabTopOffset: 0,
	  tabBorder: true,
	  customCheckbox: true,
	  customRadio: true,
	  sidebarMarkAll: true,
	  popupNoPoint: true,
	  borderlessPopup: true,
	  popupPadding: 0,
	  calendar: {
	    timepickerHeight: 24
	  },
	  calendarHeight: 70,
	  padding: 0,
	  accordionType: "accordion",
	  optionHeight: 24,
	  organogramLineColor: "#CCD7E6"
	};

	var skin$2 = {
	  topLayout: "space",
	  //bar in accordion
	  barHeight: 46,
	  //!!!Set the same in skin.less!!!
	  tabbarHeight: 46,
	  rowHeight: 34,
	  toolbarHeight: 46,
	  sidebarTitleHeight: 45,
	  listItemHeight: 34,
	  //list, grouplist, dataview, etc.
	  inputHeight: 38,
	  buttonHeight: 38,
	  inputPadding: 3,
	  menuHeight: 34,
	  labelTopHeight: 22,
	  unitHeaderHeight: 20,
	  propertyItemHeight: 28,
	  inputSpacing: 4,
	  borderWidth: 1,
	  sliderHandleWidth: 14,
	  sliderPadding: 10,
	  sliderBorder: 1,
	  vSliderPadding: 15,
	  vSliderHeight: 100,
	  switchHeight: 22,
	  switchWidth: 50,
	  //margin - distance between cells
	  layoutMargin: {
	    space: 10,
	    wide: 10,
	    clean: 0,
	    head: 4,
	    line: -1,
	    toolbar: 4,
	    form: 8,
	    accordion: 10
	  },
	  //padding - distance insede cell between cell border and cell content
	  layoutPadding: {
	    space: 10,
	    wide: 0,
	    clean: 0,
	    head: 0,
	    line: 0,
	    toolbar: 3,
	    form: 17,
	    accordion: 0
	  },
	  //space between tabs in tabbar
	  tabMargin: 4,
	  tabOffset: 0,
	  tabBottomOffset: 6,
	  tabTopOffset: 1,
	  customCheckbox: true,
	  customRadio: true,
	  popupPadding: 8,
	  calendarHeight: 70,
	  padding: 0,
	  accordionType: "accordion",
	  optionHeight: 32
	};

	var skin$3 = {
	  topLayout: "space",
	  //bar in accordion
	  barHeight: 34,
	  //!!!Set the same in skin.less!!!
	  tabbarHeight: 34,
	  sidebarTitleHeight: 34,
	  rowHeight: 24,
	  toolbarHeight: 34,
	  listItemHeight: 28,
	  //list, grouplist, dataview, etc.
	  unitHeaderHeight: 20,
	  propertyItemHeight: 24,
	  inputHeight: 30,
	  buttonHeight: 30,
	  inputPadding: 3,
	  menuHeight: 28,
	  labelTopHeight: 16,
	  inputSpacing: 4,
	  borderWidth: 1,
	  sliderHandleWidth: 12,
	  sliderPadding: 10,
	  sliderBorder: 1,
	  vSliderPadding: 13,
	  vSliderHeight: 100,
	  switchHeight: 20,
	  switchWidth: 40,
	  //margin - distance between cells
	  layoutMargin: {
	    space: 5,
	    wide: 5,
	    clean: 0,
	    head: 4,
	    line: -1,
	    toolbar: 4,
	    form: 4,
	    accordion: 5
	  },
	  //padding - distance inside cell between cell border and cell content
	  layoutPadding: {
	    space: 5,
	    wide: 0,
	    clean: 0,
	    head: 0,
	    line: 0,
	    toolbar: 1,
	    form: 12,
	    accordion: 0
	  },
	  //space between tabs in tabbar
	  tabMargin: 3,
	  tabOffset: 0,
	  tabBottomOffset: 3,
	  tabTopOffset: 1,
	  customCheckbox: true,
	  customRadio: true,
	  popupPadding: 8,
	  calendarHeight: 70,
	  padding: 0,
	  accordionType: "accordion",
	  optionHeight: 23
	};

	var skin$4 = {
	  topLayout: "space",
	  //bar in accordion
	  barHeight: 46,
	  // !!!Set the same in skin.less!!!
	  tabbarHeight: 46,
	  rowHeight: 34,
	  toolbarHeight: 46,
	  sidebarTitleHeight: 45,
	  listItemHeight: 34,
	  // list, grouplist, dataview, etc.
	  unitHeaderHeight: 20,
	  inputHeight: 38,
	  buttonHeight: 38,
	  inputPadding: 3,
	  menuHeight: 34,
	  labelTopHeight: 22,
	  propertyItemHeight: 28,
	  inputSpacing: 4,
	  borderWidth: 1,
	  sliderHandleWidth: 14,
	  sliderPadding: 10,
	  sliderBorder: 1,
	  vSliderPadding: 15,
	  vSliderHeight: 100,
	  switchHeight: 22,
	  switchWidth: 50,
	  //margin - distance between cells
	  layoutMargin: {
	    space: 10,
	    wide: 10,
	    clean: 0,
	    head: 4,
	    line: -1,
	    toolbar: 8,
	    form: 8,
	    accordion: 10
	  },
	  //padding - distance inside cell between cell border and cell content
	  layoutPadding: {
	    space: 10,
	    wide: 0,
	    clean: 0,
	    head: 0,
	    line: 0,
	    toolbar: 3,
	    form: 17,
	    accordion: 0
	  },
	  //space between tabs in tabbar
	  tabMargin: 4,
	  tabOffset: 0,
	  tabBottomOffset: 6,
	  tabTopOffset: 1,
	  customCheckbox: true,
	  customRadio: true,
	  popupPadding: 8,
	  calendarHeight: 70,
	  padding: 0,
	  accordionType: "accordion",
	  optionHeight: 32
	};

	var $active, $name;
	function set$1(name) {
	  assert(skin$5[name], "Incorrect skin name: " + name);
	  if ($name === name) return;
	  skin$5.$active = $active = skin$5[name];
	  skin$5.$name = $name = name;

	  if (ui) {
	    for (var key in ui) {
	      var view = ui[key];
	      if (view && view.prototype && view.prototype.$skin) view.prototype.$skin(view.prototype);
	    }
	  }
	}
	var skin$5 = {
	  set: set$1,
	  material: skin,
	  mini: skin$1,
	  flat: skin$2,
	  compact: skin$3,
	  contrast: skin$4
	};
	set$1(window.webix_skin || "material"); //necessary for skin builder

	var Touch = {
	  config: {
	    longTouchDelay: 1000,
	    scrollDelay: 150,
	    gravity: 500,
	    deltaStep: 30,
	    speed: "0ms",
	    finish: 1500,
	    ellastic: true,
	    fastClick: true
	  },
	  limit: function (value) {
	    Touch._limited = value !== false;
	  },
	  disable: function () {
	    Touch._disabled = true;
	  },
	  enable: function () {
	    Touch._disabled = false;
	  },
	  $init: function () {
	    Touch.$init = function () {};

	    event$1(document.body, mouse.down, Touch._touchstart, {
	      passive: false
	    });
	    event$1(document.body, mouse.move, Touch._touchmove, {
	      passive: false
	    });
	    event$1(document.body, mouse.up, Touch._touchend);
	    event$1(document.body, "dragstart", function (e) {
	      if (Touch._disabled || Touch._limited) return;
	      return preventEvent(e);
	    });
	    event$1(document.body, "touchstart", function (e) {
	      if (Touch._disabled || Touch._limited || !Touch.config.fastClick) return; //fast click mode for iOS
	      //To have working form elements Android must not block event - so there are no fast clicks for Android
	      //Selects still don't work with fast clicks

	      if (env.isSafari) {
	        var tag = e.srcElement.tagName.toLowerCase();
	        if (tag == "input" || tag == "textarea" || tag == "select" || tag == "label") return true;
	        Touch._fire_fast_event = true;
	        return preventEvent(e);
	      }
	    }, {
	      passive: false
	    });

	    Touch._clear_artefacts();

	    Touch._scroll = [null, null];
	    Touch.$active = true;
	  },
	  _clear_artefacts: function () {
	    Touch._start_context = Touch._current_context = Touch._prev_context = Touch._scroll_context = null;
	    Touch._scroll_mode = Touch._scroll_node = Touch._scroll_stat = this._long_touched = null; //remove(Touch._scroll);
	    //Touch._scroll = [null, null];

	    Touch._delta = {
	      _x_moment: 0,
	      _y_moment: 0,
	      _time: 0
	    };

	    if (Touch._css_button_remove) {
	      removeCss(Touch._css_button_remove, "webix_touch");
	      Touch._css_button_remove = null;
	    }

	    window.clearTimeout(Touch._long_touch_timer);
	    Touch._was_not_moved = true;
	    Touch._axis_x = true;
	    Touch._axis_y = true;
	    if (!Touch._active_transion) Touch._scroll_end();
	  },
	  _touchend: function (e) {
	    if (Touch._start_context) {
	      if (!Touch._scroll_mode) {
	        if (!this._long_touched) {
	          if (Touch._axis_y && !Touch._axis_x) {
	            Touch._translate_event("onSwipeX");
	          } else if (Touch._axis_x && !Touch._axis_y) {
	            Touch._translate_event("onSwipeY");
	          } else {
	            if (env.isSafari && Touch._fire_fast_event) {
	              //need to test for mobile ff and blackbery
	              Touch._fire_fast_event = false;
	              var target = Touch._start_context.target; //dark iOS magic, without delay it can skip repainting

	              delay(function () {
	                var click_event = document.createEvent("MouseEvents");
	                click_event.initEvent("click", true, true);
	                target.dispatchEvent(click_event);
	              });
	            }
	          }
	        }
	      } else {
	        var temp = Touch._get_matrix(Touch._scroll_node);

	        var x = temp.e;
	        var y = temp.f;
	        var finish = Touch.config.finish;

	        var delta = Touch._get_delta(e, true);

	        var view = $$(Touch._scroll_node);
	        var gravity = view && view.$scroll ? view.$scroll.gravity : Touch.config.gravity;

	        if (delta._time) {
	          var nx = x + gravity * delta._x_moment / delta._time;
	          var ny = y + gravity * delta._y_moment / delta._time;
	          var cnx = Touch._scroll[0] ? Touch._correct_minmax(nx, false, false, Touch._scroll_stat.dx, Touch._scroll_stat.px) : x;
	          var cny = Touch._scroll[1] ? Touch._correct_minmax(ny, false, false, Touch._scroll_stat.dy, Touch._scroll_stat.py) : y;
	          var size = Math.max(Math.abs(cnx - x), Math.abs(cny - y));
	          if (size < 150) finish = finish * size / 150;
	          if (cnx != x || cny != y) finish = Math.round(finish * Math.max((cnx - x) / (nx - x), (cny - y) / (ny - y)));
	          var result = {
	            e: cnx,
	            f: cny
	          };
	          view = $$(Touch._scroll_node);
	          if (view && view.adjustScroll) view.adjustScroll(result); //finish = Math.max(100,(Touch._fast_correction?100:finish));

	          finish = Math.max(100, finish);

	          if (x != result.e || y != result.f) {
	            Touch._set_matrix(Touch._scroll_node, result.e, result.f, finish + "ms");

	            if (Touch._scroll_master) Touch._scroll_master._sync_scroll(result.e, result.f, finish + "ms");

	            Touch._set_scroll(result.e, result.f, finish + "ms");
	          } else {
	            Touch._scroll_end();
	          }
	        } else Touch._scroll_end();
	      }

	      Touch._translate_event("onTouchEnd");

	      Touch._clear_artefacts();
	    }
	  },
	  _touchmove: function (e) {
	    if (!Touch._scroll_context || !Touch._start_context) return;

	    var delta = Touch._get_delta(e);

	    Touch._translate_event("onTouchMove");

	    if (Touch._scroll_mode) {
	      Touch._set_scroll_pos(delta);
	    } else {
	      Touch._axis_x = Touch._axis_check(delta._x, "x", Touch._axis_x);
	      Touch._axis_y = Touch._axis_check(delta._y, "y", Touch._axis_y);

	      if (Touch._scroll_mode) {
	        var view = Touch._get_event_view("onBeforeScroll", true);

	        if (view) {
	          var data = {};
	          view.callEvent("onBeforeScroll", [data]);

	          if (data.update) {
	            Touch.config.speed = data.speed;
	            Touch.config.scale = data.scale;
	          }
	        }

	        Touch._init_scroller(delta); //apply scrolling

	      }
	    }

	    return preventEvent(e);
	  },
	  _set_scroll_pos: function () {
	    if (!Touch._scroll_node) return;

	    var temp = Touch._get_matrix(Touch._scroll_node);

	    var prev = Touch._prev_context || Touch._start_context;
	    var view = $$(Touch._scroll_node);
	    var ellastic = view && view.$scroll ? view.$scroll.ellastic : Touch.config.ellastic;
	    if (Touch._scroll[0]) temp.e = Touch._correct_minmax(temp.e - prev.x + Touch._current_context.x, ellastic, temp.e, Touch._scroll_stat.dx, Touch._scroll_stat.px);
	    if (Touch._scroll[1]) temp.f = Touch._correct_minmax(temp.f - prev.y + Touch._current_context.y, ellastic, temp.f, Touch._scroll_stat.dy, Touch._scroll_stat.py);

	    Touch._set_matrix(Touch._scroll_node, temp.e, temp.f, "0ms");

	    if (Touch._scroll_master) Touch._scroll_master._sync_scroll(temp.e, temp.f, "0ms");

	    Touch._set_scroll(temp.e, temp.f, "0ms");
	  },
	  _set_scroll: function (dx, dy, speed) {
	    var edx = Touch._scroll_stat.px / Touch._scroll_stat.dx * -dx;
	    var edy = Touch._scroll_stat.py / Touch._scroll_stat.dy * -dy;
	    if (Touch._scroll[0]) Touch._set_matrix(Touch._scroll[0], edx, 0, speed);
	    if (Touch._scroll[1]) Touch._set_matrix(Touch._scroll[1], 0, edy, speed);
	  },
	  scrollTo: function (node, x, y, speed) {
	    Touch._set_matrix(node, x, y, speed);
	  },
	  _set_matrix: function (node, xv, yv, speed) {
	    if (!Touch._in_anim_frame && window.setAnimationFrame) {
	      window.setAnimationFrame(function () {
	        Touch._in_anim_frame = true;
	        return Touch._set_matrix(node, xv, yv, speed);
	      });
	    }

	    Touch._in_anim_frame = null;
	    Touch._active_transion = true;

	    if (node) {
	      var trans = Touch.config.translate || env.translate;
	      node.style[env.transform] = trans + "(" + Math.round(xv) + "px, " + Math.round(yv) + "px" + (trans == "translate3d" ? ", 0" : "") + ")";
	      node.style[env.transitionDuration] = speed;
	    }
	  },
	  _get_matrix: function (node) {
	    var matrix = window.getComputedStyle(node)[env.transform];
	    var tmatrix;
	    if (matrix == "none") tmatrix = {
	      e: 0,
	      f: 0
	    };else {
	      if (window.WebKitCSSMatrix)
	        /* global WebKitCSSMatrix */
	        tmatrix = new WebKitCSSMatrix(matrix);else if (window.MSCSSMatrix)
	        /* global MSCSSMatrix */
	        tmatrix = new MSCSSMatrix(matrix);else {
	        // matrix(1, 0, 0, 1, 0, 0) --> 1, 0, 0, 1, 0, 0
	        var _tmatrix = matrix.replace(/(matrix\()(.*)(\))/gi, "$2"); // 1, 0, 0, 1, 0, 0 --> 1,0,0,1,0,0


	        _tmatrix = _tmatrix.replace(/\s/gi, "");
	        _tmatrix = _tmatrix.split(",");
	        tmatrix = {};
	        var tkey = ["a", "b", "c", "d", "e", "f"];

	        for (var i = 0; i < tkey.length; i++) {
	          tmatrix[tkey[i]] = parseInt(_tmatrix[i], 10);
	        }
	      }
	    }
	    if (Touch._scroll_master) Touch._scroll_master._sync_pos(tmatrix);
	    return tmatrix;
	  },
	  _correct_minmax: function (value, allow, current, dx, px) {
	    if (value === current) return value;
	    var delta = Math.abs(value - current);
	    var sign = delta / (value - current); //	Touch._fast_correction = true;

	    if (value > 0) return allow ? current + sign * Math.sqrt(delta) : 0;
	    var max = dx - px;
	    if (max + value < 0) return allow ? current - Math.sqrt(-(value - current)) : -max; //	Touch._fast_correction = false;

	    return value;
	  },
	  _init_scroll_node: function (node) {
	    if (!node.scroll_enabled) {
	      node.scroll_enabled = true;
	      node.parentNode.style.position = "relative";
	      var prefix = env.cssPrefix;
	      node.style.cssText += prefix + "transition: " + prefix + "transform; " + prefix + "user-select:none; " + prefix + "transform-style:flat;";
	      node.addEventListener(env.transitionEnd, Touch._scroll_end, false);
	    }
	  },
	  _init_scroller: function () {
	    if (Touch._scroll_mode.indexOf("x") != -1) Touch._scroll[0] = Touch._create_scroll("x", Touch._scroll_stat.dx, Touch._scroll_stat.px, "width");
	    if (Touch._scroll_mode.indexOf("y") != -1) Touch._scroll[1] = Touch._create_scroll("y", Touch._scroll_stat.dy, Touch._scroll_stat.py, "height");

	    Touch._init_scroll_node(Touch._scroll_node);

	    window.setTimeout(Touch._set_scroll_pos, 1);
	  },
	  _create_scroll: function (mode, dy, py, dim) {
	    if (dy - py < 2) {
	      var matrix = Touch._get_matrix(Touch._scroll_node);

	      var e = mode == "y" ? matrix.e : 0;
	      var f = mode == "y" ? 0 : matrix.f;
	      if (!Touch._scroll_master) Touch._set_matrix(Touch._scroll_node, e, f, "0ms");
	      Touch._scroll_mode = Touch._scroll_mode.replace(mode, "");
	      return "";
	    }

	    var scroll = create("DIV", {
	      "class": "webix_scroll_" + mode
	    }, "");
	    scroll.style[dim] = Math.max(py * py / dy - 7, 10) + "px";
	    if (Touch._scroll_stat.left) if (mode === "x") scroll.style.left = Touch._scroll_stat.left + "px";else scroll.style.right = -Touch._scroll_stat.left + "px";
	    if (Touch._scroll_stat.hidden) scroll.style.visibility = "hidden";

	    Touch._scroll_node.parentNode.appendChild(scroll);

	    return scroll;
	  },
	  _axis_check: function (value, mode, old) {
	    if (value > Touch.config.deltaStep) {
	      if (Touch._was_not_moved) {
	        Touch._long_move(mode);

	        Touch._locate(mode);

	        if ((Touch._scroll_mode || "").indexOf(mode) == -1) Touch._scroll_mode = "";
	      }

	      return false;
	    }

	    return old;
	  },
	  _scroll_end: function () {
	    //sending event to the owner of the scroll only
	    var result, state, view;
	    view = $$(Touch._scroll_node || this);

	    if (view) {
	      if (Touch._scroll_node) result = Touch._get_matrix(Touch._scroll_node);else if (view.getScrollState) {
	        state = view.getScrollState();
	        result = {
	          e: state.x,
	          f: state.y
	        };
	      }
	      callEvent("onAfterScroll", [result]);
	      if (view.callEvent) view.callEvent("onAfterScroll", [result]);
	    }

	    if (!Touch._scroll_mode) {
	      remove(Touch._scroll);
	      Touch._scroll = [null, null];
	    }

	    Touch._active_transion = false;
	  },
	  _long_move: function () {
	    window.clearTimeout(Touch._long_touch_timer);
	    Touch._was_not_moved = false;
	  },
	  _stop_old_scroll: function (e) {
	    if (Touch._scroll[0] || Touch._scroll[1]) {
	      Touch._stop_scroll(e, Touch._scroll[0] ? "x" : "y");
	    } else return true;
	  },
	  _touchstart: function (e) {
	    var target = e.target || event$1.srcElement;
	    if (Touch._disabled || target.tagName && target.tagName.toLowerCase() == "textarea" && target.offsetHeight < target.scrollHeight) return;
	    Touch._long_touched = null;
	    Touch._scroll_context = Touch._start_context = mouse.context(e); // in "limited" mode we should have possibility to use slider

	    var element = $$(e);

	    if (Touch._limited && !Touch._is_scroll() && !(element && element.$touchCapture)) {
	      Touch._scroll_context = null;
	    }

	    Touch._translate_event("onTouchStart");

	    if (Touch._stop_old_scroll(e)) Touch._long_touch_timer = window.setTimeout(Touch._long_touch, Touch.config.longTouchDelay);

	    if (element && element.touchable && (!target.className || target.className.indexOf("webix_view") !== 0)) {
	      Touch._css_button_remove = element.getNode(e);
	      addCss(Touch._css_button_remove, "webix_touch");
	    }
	  },
	  _long_touch: function () {
	    if (Touch._start_context) {
	      Touch._translate_event("onLongTouch");

	      callEvent("onClick", [Touch._start_context]);
	      Touch._long_touched = true; //Touch._clear_artefacts();
	    }
	  },
	  _stop_scroll: function (e, stop_mode) {
	    Touch._locate(stop_mode);

	    var scroll = Touch._scroll[0] || Touch._scroll[1];

	    if (scroll) {
	      var view = Touch._get_event_view("onBeforeScroll", true);

	      if (view) view.callEvent("onBeforeScroll", [Touch._start_context, Touch._current_context]);
	    }

	    if (scroll && (!Touch._scroll_node || scroll.parentNode != Touch._scroll_node.parentNode)) {
	      Touch._clear_artefacts();

	      Touch._scroll_end();

	      Touch._start_context = mouse.context(e);
	    }

	    Touch._touchmove(e);
	  },
	  _get_delta: function (e) {
	    Touch._prev_context = Touch._current_context;
	    Touch._current_context = mouse.context(e);
	    Touch._delta._x = Math.abs(Touch._start_context.x - Touch._current_context.x);
	    Touch._delta._y = Math.abs(Touch._start_context.y - Touch._current_context.y);

	    if (Touch._prev_context) {
	      if (Touch._current_context.time - Touch._prev_context.time < Touch.config.scrollDelay) {
	        Touch._delta._x_moment = Touch._delta._x_moment / 1.3 + Touch._current_context.x - Touch._prev_context.x;
	        Touch._delta._y_moment = Touch._delta._y_moment / 1.3 + Touch._current_context.y - Touch._prev_context.y;
	      } else {
	        Touch._delta._y_moment = Touch._delta._x_moment = 0;
	      }

	      Touch._delta._time = Touch._delta._time / 1.3 + (Touch._current_context.time - Touch._prev_context.time);
	    }

	    return Touch._delta;
	  },
	  _get_sizes: function (node) {
	    Touch._scroll_stat = {
	      dx: node.offsetWidth,
	      dy: node.offsetHeight,
	      px: node.parentNode.offsetWidth,
	      py: node.parentNode.offsetHeight
	    };
	  },
	  _is_scroll: function (locate_mode) {
	    var node = Touch._start_context.target;
	    if (!env.touch && !env.transition && !env.transform) return null;

	    while (node && node.tagName != "BODY") {
	      if (node.getAttribute) {
	        var mode = node.getAttribute("touch_scroll");
	        if (mode && (!locate_mode || mode.indexOf(locate_mode) != -1)) return [node, mode];
	      }

	      node = node.parentNode;
	    }

	    return null;
	  },
	  _locate: function (locate_mode) {
	    var state = this._is_scroll(locate_mode);

	    if (state) {
	      Touch._scroll_mode = state[1];
	      Touch._scroll_node = state[0];

	      Touch._get_sizes(state[0]);
	    }

	    return state;
	  },
	  _translate_event: function (name) {
	    callEvent(name, [Touch._start_context, Touch._current_context]);

	    var view = Touch._get_event_view(name);

	    if (view) view.callEvent(name, [Touch._start_context, Touch._current_context]);
	  },
	  _get_event_view: function (name, active) {
	    var view = $$(active ? Touch._scroll_node : Touch._start_context);
	    if (!view) return null;

	    while (view) {
	      if (view.hasEvent && view.hasEvent(name)) return view;
	      view = view.getParentView();
	    }

	    return null;
	  },
	  _get_context: function (e) {
	    if (!e.touches[0]) {
	      var temp = Touch._current_context;
	      temp.time = new Date();
	      return temp;
	    }

	    return {
	      target: e.target,
	      x: e.touches[0].pageX,
	      y: e.touches[0].pageY,
	      time: new Date()
	    };
	  },
	  _get_context_m: function (e) {
	    return {
	      target: e.target || e.srcElement,
	      x: e.pageX,
	      y: e.pageY,
	      time: new Date()
	    };
	  }
	};

	function touchInit() {
	  if (env.touch) {
	    Touch.$init(); //not full screen mode

	    if (document.body.className.indexOf("webix_full_screen") == -1) Touch.limit(true);
	    if (window.MSCSSMatrix) addStyle(".webix_view{ -ms-touch-action: none; }");
	  } else {
	    var id = event$1(document.body, "touchstart", function (ev) {
	      if (ev.touches.length && ev.touches[0].radiusX > 4) {
	        env.touch = true;
	        setMouse(mouse);
	        touchInit();

	        for (var key in ui.views) {
	          var view = ui.views[key];
	          if (view && view.$touch) view.$touch();
	        }
	      }

	      eventRemove(id);
	    }, {
	      capture: true
	    });
	  }
	}

	function setMouse(mouse) {
	  mouse.down = "touchstart";
	  mouse.move = "touchmove";
	  mouse.up = "touchend";
	  mouse.context = Touch._get_context;
	}

	ready(touchInit);
	var mouse = env.mouse = {
	  down: "mousedown",
	  up: "mouseup",
	  move: "mousemove",
	  context: Touch._get_context_m
	};

	if (window.navigator.pointerEnabled) {
	  mouse.down = "pointerdown";
	  mouse.move = "pointermove";
	  mouse.up = "pointerup";
	} else if (window.navigator.msPointerEnabled) {
	  mouse.down = "MSPointerDown";
	  mouse.move = "MSPointerMove";
	  mouse.up = "MSPointerUp";
	} else if (env.touch) setMouse(mouse);

	/*
		Behavior:DND - low-level dnd handling
		@export
			getContext
			addDrop
			addDrag
			
		DND master can define next handlers
			onCreateDrag
			onDragIng
			onDragOut
			onDrag
			onDrop
		all are optional
	*/

	var DragControl = {
	  //has of known dnd masters
	  _drag_masters: toArray(["dummy"]),

	  /*
	  	register drop area
	  	@param node 			html node or ID
	  	@param ctrl 			options dnd master
	  	@param master_mode 		true if you have complex drag-area rules
	  */
	  addDrop: function (node, ctrl, master_mode) {
	    node = toNode(node);
	    node.webix_drop = this._getCtrl(ctrl);
	    if (master_mode) node.webix_master = true;
	  },
	  //return index of master in collection
	  //it done in such way to prevent dnd master duplication
	  //probably useless, used only by addDrop and addDrag methods
	  _getCtrl: function (ctrl) {
	    ctrl = ctrl || DragControl;

	    var index$$1 = this._drag_masters.find(ctrl);

	    if (index$$1 < 0) {
	      index$$1 = this._drag_masters.length;

	      this._drag_masters.push(ctrl);
	    }

	    return index$$1;
	  },
	  _createTouchDrag: function (e) {
	    var dragCtrl = DragControl;

	    var master = this._getActiveDragMaster(); // for data items only


	    if (master && master._getDragItemPos) {
	      if (!dragCtrl._html) dragCtrl.createDrag(e);
	      var ctx = dragCtrl._drag_context;
	      dragCtrl._html.style.left = e.x + dragCtrl.left + (ctx.x_offset || 0) + "px";
	      dragCtrl._html.style.top = e.y + dragCtrl.top + (ctx.y_offset || 0) + "px";
	    }
	  },

	  /*
	  	register drag area
	  	@param node 	html node or ID
	  	@param ctrl 	options dnd master
	  */
	  addDrag: function (node, ctrl) {
	    node = toNode(node);
	    node.webix_drag = this._getCtrl(ctrl);

	    _event(node, env.mouse.down, this._preStart, {
	      bind: node
	    });

	    _event(node, "dragstart", preventEvent);
	  },
	  //logic of drag - start, we are not creating drag immediately, instead of that we hears mouse moving
	  _preStart: function (e) {
	    if (DragControl._active) {
	      //if we have nested drag areas, use the top one and ignore the inner one
	      if (DragControl._saved_event == e) return;

	      DragControl._preStartFalse();

	      DragControl.destroyDrag(e);
	    }

	    DragControl._active = this;
	    var evobj = env.mouse.context(e);
	    DragControl._start_pos = evobj;
	    DragControl._saved_event = e;
	    DragControl._webix_drag_mm = event$1(document.body, env.mouse.move, DragControl._startDrag);
	    DragControl._webix_drag_mu = event$1(document, env.mouse.up, DragControl._preStartFalse); //need to run here, or will not work in IE

	    addCss(document.body, "webix_noselect", 1);
	  },
	  //if mouse was released before moving - this is not a dnd, remove event handlers
	  _preStartFalse: function () {
	    DragControl._clean_dom_after_drag();
	  },
	  //mouse was moved without button released - dnd started, update event handlers
	  _startDrag: function (e) {
	    //prevent unwanted dnd
	    var pos$$1 = env.mouse.context(e);

	    var master = DragControl._getActiveDragMaster(); // only long-touched elements can be dragged


	    var longTouchLimit = master && env.touch && master._getDragItemPos && !Touch._long_touched;
	    if (longTouchLimit || Math.abs(pos$$1.x - DragControl._start_pos.x) < 5 && Math.abs(pos$$1.y - DragControl._start_pos.y) < 5) return;

	    DragControl._clean_dom_after_drag(true);

	    if (!DragControl._html) if (!DragControl.createDrag(DragControl._saved_event)) return;
	    DragControl.sendSignal("start"); //useless for now

	    DragControl._webix_drag_mm = event$1(document.body, env.mouse.move, DragControl._moveDrag);
	    DragControl._webix_drag_mu = event$1(document, env.mouse.up, DragControl._stopDrag);

	    DragControl._moveDrag(e);

	    if (env.touch) return preventEvent(e);
	  },
	  //mouse was released while dnd is active - process target
	  _stopDrag: function (e) {
	    DragControl._clean_dom_after_drag();

	    DragControl._saved_event = null;

	    if (DragControl._last) {
	      //if some drop target was confirmed
	      DragControl.$drop(DragControl._active, DragControl._last, e);
	      DragControl.$dragOut(DragControl._active, DragControl._last, null, e);
	    }

	    DragControl.destroyDrag(e);
	    DragControl.sendSignal("stop"); //useless for now
	  },
	  _clean_dom_after_drag: function (still_drag) {
	    this._webix_drag_mm = eventRemove(this._webix_drag_mm);
	    this._webix_drag_mu = eventRemove(this._webix_drag_mu);
	    if (!still_drag) removeCss(document.body, "webix_noselect");
	  },
	  //dnd is active and mouse position was changed
	  _moveDrag: function (e) {
	    var dragCtrl = DragControl;
	    var pos$$1 = pos(e); //give possibility to customize drag position

	    var customPos = dragCtrl.$dragPos(pos$$1, e); //adjust drag marker position

	    var ctx = dragCtrl._drag_context;
	    dragCtrl._html.style.top = pos$$1.y + dragCtrl.top + (customPos || !ctx.y_offset ? 0 : ctx.y_offset) + "px";
	    dragCtrl._html.style.left = pos$$1.x + dragCtrl.left + (customPos || !ctx.x_offset ? 0 : ctx.x_offset) + "px";
	    var evobj = e;
	    if (dragCtrl._skip) dragCtrl._skip = false;else {
	      if (env.touch) {
	        var context = env.mouse.context(e);
	        var target = document.elementFromPoint(context.x, context.y);
	        evobj = new Proxy(e, {
	          get: function (obj, prop) {
	            if (prop === "target") {
	              return target;
	            }

	            var res = obj[prop];

	            if (typeof res === "function") {
	              return res.bind(e);
	            }

	            return res;
	          }
	        });
	      }

	      dragCtrl._checkLand(evobj.target || evobj.srcElement, evobj);
	    }
	    return preventEvent(e);
	  },
	  //check if item under mouse can be used as drop landing
	  _checkLand: function (node, e) {
	    while (node && node.tagName != "BODY") {
	      if (node.webix_drop) {
	        //if drop area registered
	        if (this._last && (this._last != node || node.webix_master)) //if this area with complex dnd master
	          this.$dragOut(this._active, this._last, node, e); //inform master about possible mouse-out

	        if (!this._last || this._last != node || node.webix_master) {
	          //if this is new are or area with complex dnd master
	          this._last = null; //inform master about possible mouse-in

	          this._landing = this.$dragIn(DragControl._active, node, e);
	          if (this._landing) //landing was rejected
	            this._last = node;
	          return;
	        }

	        return;
	      }

	      node = node.parentNode;
	    }

	    if (this._last) //mouse was moved out of previous landing, and without finding new one 
	      this._last = this._landing = this.$dragOut(this._active, this._last, null, e);
	  },
	  //mostly useless for now, can be used to add cross-frame dnd
	  sendSignal: function (signal) {
	    DragControl.active = signal == "start";
	    callEvent("onDragMode", [signal]);
	  },
	  //return master for html area
	  getMaster: function (t) {
	    return this._drag_masters[t.webix_drag || t.webix_drop];
	  },
	  //return dhd-context object
	  getContext: function () {
	    return this._drag_context;
	  },
	  getNode: function () {
	    return this._html;
	  },
	  //called when dnd is initiated, must create drag representation
	  createDrag: function (e) {
	    var dragCtl = DragControl;
	    var a = dragCtl._active;
	    dragCtl._drag_context = {};
	    var master = this._drag_masters[a.webix_drag];
	    var drag_container; //if custom method is defined - use it

	    if (master.$dragCreate) {
	      drag_container = master.$dragCreate(a, e);
	      if (!drag_container) return false;

	      this._setDragOffset(e);

	      drag_container.style.position = "absolute";
	    } else {
	      //overvise use default one
	      var text = dragCtl.$drag(a, e);

	      dragCtl._setDragOffset(e);

	      if (!text) return false;
	      drag_container = document.createElement("DIV");
	      drag_container.innerHTML = text;
	      drag_container.className = "webix_drag_zone";
	      document.body.appendChild(drag_container);
	      var context = dragCtl._drag_context;

	      if (context.html && env.pointerevents) {
	        context.x_offset = -Math.round(drag_container.offsetWidth * 0.5);
	        context.y_offset = -Math.round(drag_container.offsetHeight * 0.75);
	      }
	    }
	    /*
	    	dragged item must have topmost z-index
	    	in some cases item already have z-index
	    	so we will preserve it if possible
	    */


	    drag_container.style.zIndex = Math.max(drag_container.style.zIndex, zIndex());
	    DragControl._skipDropH = event$1(drag_container, env.mouse.move, DragControl._skip_mark);
	    if (!DragControl._drag_context.from) DragControl._drag_context = {
	      source: a,
	      from: a
	    };
	    DragControl._html = drag_container;
	    return true;
	  },
	  //helper, prevents unwanted mouse-out events
	  _skip_mark: function () {
	    DragControl._skip = true;
	  },
	  //after dnd end, remove all traces and used html elements
	  destroyDrag: function (e) {
	    var a = DragControl._active;
	    var master = this._drag_masters[a.webix_drag];

	    if (master && master.$dragDestroy) {
	      DragControl._skipDropH = eventRemove(DragControl._skipDropH);
	      if (DragControl._html) master.$dragDestroy(a, DragControl._html, e);
	    } else {
	      remove(DragControl._html);
	    }

	    if (DragControl._dropHTML) remove(DragControl._dropHTML);
	    DragControl._landing = DragControl._active = DragControl._last = DragControl._html = DragControl._dropHTML = null; //DragControl._x_offset = DragControl._y_offset = null;
	  },
	  _getActiveDragMaster: function () {
	    return DragControl._drag_masters[DragControl._active.webix_drag];
	  },
	  top: 0,
	  //relative position of drag marker to mouse cursor
	  left: 0,
	  _setDragOffset: function (e) {
	    var dragCtl = DragControl;
	    var pos$$1 = dragCtl._start_pos;
	    var ctx = dragCtl._drag_context;
	    if (typeof ctx.x_offset != "undefined" && typeof ctx.y_offset != "undefined") return null;
	    ctx.x_offset = ctx.y_offset = 0;

	    if (env.pointerevents) {
	      var m = DragControl._getActiveDragMaster();

	      if (m._getDragItemPos && m !== this) {
	        var itemPos = m._getDragItemPos(pos$$1, e);

	        if (itemPos) {
	          ctx.x_offset = itemPos.x - pos$$1.x;
	          ctx.y_offset = itemPos.y - pos$$1.y;
	        }
	      }
	    }
	  },
	  $dragPos: function (pos$$1, e) {
	    var m = this._drag_masters[DragControl._active.webix_drag];

	    if (m.$dragPos && m != this) {
	      m.$dragPos(pos$$1, e, DragControl._html);
	      return true;
	    }
	  },
	  //called when mouse was moved in drop area
	  $dragIn: function (s, t, e) {
	    var m = this._drag_masters[t.webix_drop];
	    if (m.$dragIn && m != this) return m.$dragIn(s, t, e);
	    t.className = t.className + " webix_drop_zone";
	    return t;
	  },
	  //called when mouse was moved out drop area
	  $dragOut: function (s, t, n, e) {
	    var m = this._drag_masters[t.webix_drop];
	    if (m.$dragOut && m != this) return m.$dragOut(s, t, n, e);
	    t.className = t.className.replace("webix_drop_zone", "");
	    return null;
	  },
	  //called when mouse was released over drop area
	  $drop: function (s, t, e) {
	    var m = this._drag_masters[t.webix_drop];
	    DragControl._drag_context.from = DragControl.getMaster(s);
	    if (m.$drop && m != this) return m.$drop(s, t, e);
	    t.appendChild(s);
	  },
	  //called when dnd just started
	  $drag: function (s, e) {
	    var m = this._drag_masters[s.webix_drag];
	    if (m.$drag && m != this) return m.$drag(s, e);
	    return "<div style='" + s.style.cssText + "'>" + s.innerHTML + "</div>";
	  }
	}; //global touch-drag handler

	attachEvent("onLongTouch", function (ev) {
	  if (DragControl._active) DragControl._createTouchDrag(ev);
	});

	var Movable = {
	  move_setter: function (value) {
	    if (value) {
	      this._move_admin = clone(this._move_admin);
	      this._move_admin.master = this;
	      DragControl.addDrag(this._headobj ? this._headobj : this.$view, this._move_admin);
	    }

	    return value;
	  },
	  _move_admin: {
	    $dragCreate: function (object, e) {
	      if (this.master.config.move) {
	        var elOffset = offset(object);
	        var elPos = pos(e);
	        DragControl.top = elOffset.y - elPos.y;
	        DragControl.left = elOffset.x - elPos.x;
	        return toNode(this.master._viewobj);
	      }
	    },
	    $dragDestroy: function (node, drag) {
	      var view = this.master;

	      if (view._settings) {
	        view._settings.top = parseInt(drag.style.top, 10);
	        view._settings.left = parseInt(drag.style.left, 10);
	      }

	      DragControl.top = DragControl.left = 0;
	      this.master.callEvent("onViewMoveEnd", []);
	      return;
	    },
	    $dragPos: function (pos$$1, e) {
	      this.master.callEvent("onViewMove", [pos$$1, e]);
	    }
	  }
	};

	var Modality = {
	  _modal_set: function (value) {
	    if (value) {
	      if (!this._modal_cover) {
	        this._modal_cover = create("div", {
	          "class": "webix_modal"
	        });
	        /*	with below code we will have the same zIndex for modal layer as for the previous 
	        	abs positioned element, but because of attaching order modal layer will be on top anyway
	        */

	        var index$$1 = this._settings.zIndex || zIndex(); //set topmost modal layer

	        this._previous_modality = state._modality;
	        state._modality = index$$1;
	        this._modal_cover.style.zIndex = index$$1 - 1;
	        this._viewobj.style.zIndex = index$$1;
	        document.body.appendChild(this._modal_cover);
	        document.body.style.overflow = "hidden";

	        _event(this._modal_cover, "click", bind(this._ignore_clicks, this));
	      }
	    } else {
	      if (this._modal_cover) {
	        remove(this._modal_cover);
	        document.body.style.overflow = ""; //restore topmost modal layer
	        //set delay, as current window closing may have not finished click event
	        //need to wait while it is not fully processed

	        var topmost = this._previous_modality;
	        setTimeout(function () {
	          state._modality = topmost;
	        }, 1);
	        this._modal_cover = null;
	      }
	    }

	    return value;
	  }
	};

	var ResizeArea = {
	  resize_setter: function (value) {
	    if (value && !this._resizeHandlers) this._renderResizeHandler();
	    return value;
	  },
	  _renderResizeHandler: function () {
	    if (!this._rwHandle) {
	      var rp = this._viewobj;

	      if (rp.firstChild) {
	        rp = rp.firstChild;
	        rp.style.position = "relative";
	      }

	      this._rwHandle = create("DIV", {
	        "class": "webix_resize_handle",
	        "webix_disable_drag": "true"
	      });
	      rp.appendChild(this._rwHandle);

	      _event(this._rwHandle, env.mouse.down, this._wrDown, {
	        bind: this
	      });
	    }
	  },
	  _showResizeFrame: function (width, height) {
	    if (!this._resizeFrame) {
	      this._resizeFrame = create("div", {
	        "class": "webix_resize_frame"
	      }, "");
	      document.body.appendChild(this._resizeFrame);
	      var elPos = offset(this._viewobj);
	      this._resizeFrame.style.left = elPos.x + "px";
	      this._resizeFrame.style.top = elPos.y + "px";
	      this._resizeFrame.style.zIndex = zIndex();
	    }

	    this._resizeFrame.style.width = width + "px";
	    this._resizeFrame.style.height = height + "px";
	  },
	  _wrDown: function () {
	    if (this.config.resize) {
	      addCss(document.body, "webix_noselect webix_resize_cursor");
	      this._wsReady = offset(this._viewobj);
	      this._resizeHandlersMove = event$1(document.body, env.mouse.move, this._wrMove, {
	        bind: this
	      });
	      this._resizeHandlersUp = event$1(document.body, env.mouse.up, this._wrUp, {
	        bind: this
	      });
	    }
	  },
	  _wrMove: function (e) {
	    if (this._wsReady !== false) {
	      var elPos = pos(e);
	      var progress = {
	        x: elPos.x - this._wsReady.x + 10,
	        y: elPos.y - this._wsReady.y + 10
	      };
	      if (this.$resizeMove) this.$resizeMove(progress);else {
	        var width = Math.abs(this._wsReady.x - elPos.x),
	            height = Math.abs(this._wsReady.y - elPos.y);
	        if (width < (this.config.minWidth || 100) || height < (this.config.minHeight || 100) || width > this._settings.maxWidth || height > this._settings.maxHeight) return;
	      }
	      this._wsProgress = progress;

	      this._showResizeFrame(progress.x, progress.y);
	    }
	  },
	  _wrUp: function () {
	    // remove resize frame and css styles
	    if (this._resizeFrame) this._resizeFrame = remove(this._resizeFrame);
	    removeCss(document.body, "webix_resize_cursor");
	    removeCss(document.body, "webix_noselect");
	    eventRemove(this._resizeHandlersMove);
	    eventRemove(this._resizeHandlersUp); // set Window sizes

	    if (this._wsProgress) {
	      if (this.$resizeEnd) this.$resizeEnd(this._wsProgress);else {
	        this.config.width = this._wsProgress.x;
	        this.config.height = this._wsProgress.y;
	        this.resize();
	      }
	    }

	    this._wsReady = this._wsProgress = false;
	    this.callEvent("onViewResize", []);
	  }
	};

	state._popups = toArray();
	var api$3 = {
	  name: "window",
	  $init: function (config) {
	    this._viewobj.innerHTML = "<div class='webix_win_content'><div class='webix_win_head'></div><div class='webix_win_body'></div></div>";
	    this._contentobj = this._viewobj.firstChild;
	    this._headobj = this._contentobj.childNodes[0];
	    this._dataobj = this._bodyobj = this._contentobj.childNodes[1];
	    this._viewobj.className += " webix_window";

	    this._viewobj.setAttribute("role", "dialog");

	    this._viewobj.setAttribute("tabindex", "0");

	    this._head_cell = this._body_cell = null;
	    this._settings._inner = {
	      top: false,
	      left: false,
	      right: false,
	      bottom: false
	    }; //set border flags

	    if (!config.id) config.id = uid();

	    _event(this._contentobj, "click", bind(this._ignore_clicks, this)); // IE8 does not allow to define event capturing


	    if (this._contentobj.addEventListener) _event(this._contentobj, "click", function () {
	      // brings a window to the front of other windows
	      if (!this._settings.zIndex && this._settings.toFront) {
	        this._viewobj.style.zIndex = zIndex();
	      }
	    }, {
	      bind: this,
	      capture: true
	    }); // hidden_setter handling

	    if (config.modal) this._modal = true;
	    this.attachEvent("onViewMoveEnd", function () {
	      if (this._settings.position) delete this._settings.position;
	    });
	  },
	  _ignore_clicks: function (e) {
	    var popups = state._popups;
	    var index$$1 = popups.find(this);
	    if (index$$1 == -1) index$$1 = popups.length - 1;
	    e.click_view = index$$1;
	    if (env.isIE8) e.srcElement.click_view = index$$1;
	  },
	  getChildViews: function () {
	    if (this._head_cell) return [this._head_cell, this._body_cell];else return [this._body_cell];
	  },
	  zIndex_setter: function (value) {
	    this._viewobj.style.zIndex = value;
	    return value;
	  },
	  _remove: function () {
	    this._body_cell = {
	      destructor: function () {}
	    };
	  },
	  _replace: function (new_view) {
	    this._body_cell.destructor();

	    this._body_cell = new_view;

	    this._bodyobj.appendChild(this._body_cell._viewobj);

	    var cell = this._body_cell._viewobj.style;
	    cell.borderTopWidth = cell.borderBottomWidth = cell.borderLeftWidth = cell.borderRightWidth = "1px";
	    this._body_cell._settings._inner = clone(this._settings._inner);
	    this.resize(true);
	  },
	  show: function (node, mode, point) {
	    if (node === true) {
	      //recursive call from some child item
	      if (!this._settings.hidden) return;
	      node = null;
	    }

	    if (!this.callEvent("onBeforeShow", arguments)) return false;
	    this._settings.hidden = false;
	    this._viewobj.style.zIndex = this._settings.zIndex || zIndex();

	    if (this._settings.modal || this._modal) {
	      this._modal_set(true);

	      this._modal = null; // hidden_setter handling
	    }

	    var elPos, dx, dy;
	    mode = mode || {};
	    if (!mode.pos) mode.pos = this._settings.relative; //get position of source html node
	    //we need to show popup which pointing to that node

	    if (node) {
	      //if event was provided - get node info from it
	      if (_typeof(node) == "object" && !node.tagName) {
	        /*below logic is far from ideal*/
	        if (node.target || node.srcElement) {
	          elPos = pos(node);
	          dx = 20;
	          dy = 5;
	        } else elPos = node;
	      } else {
	        node = toNode(node);
	        assert(node, "Not existing target for window:show");
	        elPos = offset(node);
	      } //size of body, we need to fit popup inside


	      var x = Math.max(window.innerWidth || 0, document.body.offsetWidth);
	      var y = Math.max(window.innerHeight || 0, document.body.offsetHeight); //size of node, near which popup will be rendered

	      dx = dx || node.offsetWidth || 0;
	      dy = dy || node.offsetHeight || 0; //size of popup element

	      var size = this._last_size;
	      var fin_x = elPos.x;
	      var fin_y = elPos.y;
	      var point_y = 0;
	      var point_x = 0;
	      var scrollLeft = 0,
	          scrollTop = 0;
	      var fit = this._settings.autofit;

	      if (fit) {
	        var nochange = fit === "node";
	        var delta_x = 6;
	        var delta_y = 6;
	        var delta_point = 6;
	        if (!this._settings.point) delta_x = delta_y = delta_point = 0; //default pointer position - top 

	        point = "top";
	        fin_y = 0;
	        fin_x = 0;
	        scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft; //if we want to place menu at righ, but there is no place move it to left instead

	        if (x - elPos.x - dx < size[0] && mode.pos == "right" && !nochange) mode.pos = "left";

	        if (mode.pos == "right") {
	          fin_x = elPos.x + delta_x + dx;
	          delta_y = -dy;
	          point = "left";
	          point_y = Math.round(elPos.y + dy / 2);
	          point_x = fin_x - delta_point;
	        } else if (mode.pos == "left") {
	          fin_x = elPos.x - delta_x - size[0] - 1;
	          delta_y = -dy;
	          point = "right";
	          point_y = Math.round(elPos.y + dy / 2);
	          point_x = fin_x + size[0] + 1;
	        } else {
	          //left border of screen
	          if (elPos.x < scrollLeft) {
	            fin_x = scrollLeft; //popup exceed the right border of screen
	          } else if (x + scrollLeft - elPos.x > size[0]) {
	            fin_x = elPos.x; //aligned
	          } else {
	            fin_x = x + scrollLeft - delta_x - size[0]; //not aligned
	          }

	          point_x = Math.round(elPos.x + dx / 2); //when we have a small popup, point need to be rendered at center of popup

	          point_x = Math.min(point_x, fin_x + size[0] - delta_point * 3);
	        } //if height is not fixed - use default position


	        scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;

	        if ((!size[1] || y + scrollTop - dy - elPos.y - delta_y > size[1] || nochange) && mode.pos != "top") {
	          //bottom	
	          fin_y = dy + elPos.y + delta_y - (!this._settings.point ? 0 : 4);

	          if (!point_y) {
	            point = "top";
	            point_y = fin_y - delta_point;
	          }
	        } else {
	          //top
	          fin_y = elPos.y - delta_y - size[1];

	          if (fin_y < 0) {
	            fin_y = 0; //left|right point can be used, but there is no place for top point

	            if (point == "top") point = false;
	          } else if (!point_y) {
	            point = "bottom";
	            fin_y--;
	            point_y = fin_y + size[1] + 1;
	          }
	        }
	      }

	      var deltax = mode.x || 0;
	      var deltay = mode.y || 0;

	      var fixed = this._checkFixedPosition();

	      if (fixed) {
	        fin_y = fin_y - scrollTop;
	        point_y = point_y - scrollTop;
	      }

	      this.setPosition(fin_x + deltax, fin_y + deltay);

	      if (this._set_point) {
	        if (point && this._settings.point) this._set_point(point, point_x + deltax, point_y + deltay, fixed);else this._hide_point();
	      }
	    } else this._setPosition(this._settings.left, this._settings.top);

	    this._viewobj.style.display = "block";
	    this._hide_timer = 1;
	    delay(function () {
	      this._hide_timer = 0;
	    }, this, [], env.touch ? 400 : 100);

	    this._render_hidden_views();

	    if (this.config.autofocus) {
	      this._prev_focus = UIManager.getFocus();
	      UIManager.setFocus(this);
	    }

	    if (-1 == state._popups.find(this)) state._popups.push(this);
	    this.callEvent("onShow", []);
	  },
	  _hide: function (e) {
	    //do not hide modal windows
	    if (this._settings.hidden || this._settings.modal || this._hide_timer || e && e.showpopup) return; //do not hide popup, when we have modal layer above the popup

	    if (state._modality && this._settings.zIndex <= state._modality) return; //ignore inside clicks and clicks in child-popups

	    if (e) {
	      var index$$1 = env.isIE8 ? e.srcElement.click_view : e.click_view;
	      if (!index$$1 && index$$1 !== 0) index$$1 = -1;

	      var myindex = state._popups.find(this);

	      if (myindex <= index$$1) return;
	    }

	    this.hide();
	  },
	  hidden_setter: function (value) {
	    if (value) this.hide();else this.show();
	    return !!value;
	  },
	  hide: function (force) {
	    if (this.$destructed) return;
	    if (!force) if (this._settings.hidden) return;
	    if (this._settings.modal) this._modal_set(false);

	    if (this._settings.position == "top") {
	      animate(this._viewobj, {
	        type: "slide",
	        x: 0,
	        y: -(this._content_height + 20),
	        duration: 300,
	        callback: this._hide_callback,
	        master: this
	      });
	    } else this._hide_callback();

	    if (this._settings.autofocus) {
	      var el = document.activeElement; //as result of hotkey, we can have a activeElement set to document.body

	      if (el && this._viewobj && (this._viewobj.contains(el) || el === document.body)) {
	        UIManager.setFocus(this._prev_focus);
	        this._prev_focus = null;
	      }
	    }

	    this._hide_sub_popups();
	  },
	  //hide all child-popups
	  _hide_sub_popups: function () {
	    var order = state._popups;
	    var index$$1 = order.find(this);
	    var size = order.length - 1;
	    if (index$$1 > -1) for (var i = size; i > index$$1; i--) {
	      if (order[i]._hide_point) //hide only popups, skip windows
	        order[i].hide();
	    }
	    order.removeAt(index$$1);
	  },
	  destructor: function () {
	    this._modal_set(false);

	    remove(this._viewobj);

	    if (this._settings.autofocus) {
	      if (!state._final_destruction) UIManager.setFocus(this._prev_focus);
	      this._prev_focus = null;
	    }

	    this._hide_sub_popups();

	    if (this._hide_point) this._hide_point();
	    Destruction.destructor.apply(this, []);
	  },
	  _hide_callback: function () {
	    if (!this.$destructed) {
	      this._viewobj.style.display = "none";
	      this._settings.hidden = true;
	      this.callEvent("onHide", []);
	    }
	  },
	  close: function () {
	    this.destructor();
	  },
	  _inner_body_set: function (value) {
	    if (typeof value.borderless == "undefined") value.borderless = true;
	  },
	  body_setter: function (value) {
	    if (_typeof(value) != "object") value = {
	      template: value
	    };

	    this._inner_body_set(value);

	    state._parent_cell = this;
	    this._body_cell = ui._view(value);

	    this._bodyobj.appendChild(this._body_cell._viewobj);

	    return value;
	  },
	  head_setter: function (value) {
	    if (value === false) return value;

	    if (_typeof(value) != "object") {
	      this._viewobj.setAttribute("aria-label", value);

	      value = {
	        template: value,
	        padding: 0
	      };
	    }

	    value.borderless = true;
	    state._parent_cell = this;
	    this._head_cell = ui._view(value);

	    this._headobj.appendChild(this._head_cell._viewobj);

	    return value;
	  },
	  getBody: function () {
	    return this._body_cell;
	  },
	  getHead: function () {
	    return this._head_cell;
	  },
	  adjust: function () {
	    return this.resize();
	  },
	  resizeChildren: function () {
	    if (this._body_cell) this.resize();
	  },
	  resize: function () {
	    baseview.api.adjust.call(this);

	    if (this.isVisible()) {
	      this._setPosition(this._settings.left, this._settings.top);
	    }
	  },
	  _checkFixedPosition: function () {
	    if (this._settings.master) {
	      var top = $$(this._settings.master).getTopParentView().$view;
	      return top && top.style.position === "fixed";
	    }

	    return false;
	  },
	  _setPosition: function (x, y) {
	    if (this._settings.position || this._checkFixedPosition()) {
	      this.$view.style.position = "fixed";
	      var width = this._content_width;
	      var height = this._content_height;
	      if (width <= 0 || height <= 0) return;
	      var maxWidth = window.innerWidth || document.documentElement.offsetWidth;
	      var maxHeight = window.innerHeight || document.documentElement.offsetHeight;
	      var left = Math.round((maxWidth - width) / 2);
	      var top = Math.round((maxHeight - height) / 2);

	      if (typeof this._settings.position == "function") {
	        var state$$1 = {
	          left: left,
	          top: top,
	          width: width,
	          height: height,
	          maxWidth: maxWidth,
	          maxHeight: maxHeight
	        };

	        this._settings.position.call(this, state$$1);

	        if (state$$1.width != width || state$$1.height != height) this.$setSize(state$$1.width, state$$1.height);
	        this.setPosition(state$$1.left, state$$1.top);
	      } else {
	        if (this._settings.position == "top") {
	          if (animate.isSupported()) top = -1 * height;else top = 10;
	        } //popup inside a fixed win


	        if (!this._settings.position) {
	          left = this._settings.left || left;
	          top = this._settings.top || top;
	        }

	        this.setPosition(left, top);
	      }

	      if (this._settings.position == "top") animate(this._viewobj, {
	        type: "slide",
	        x: 0,
	        y: height - (this._settings.padding || 0) * 2,
	        duration: 300,
	        callback: this._topPositionCallback,
	        master: this
	      });
	    } else this.setPosition(x, y);
	  },
	  _topPositionCallback: function (node) {
	    animate.clear(node);
	    this._settings.top = -((this._settings.padding || 0) * 2);
	    this.setPosition(this._settings.left, this._settings.top);
	  },
	  setPosition: function (x, y) {
	    this._viewobj.style.top = y + "px";
	    this._viewobj.style.left = x + "px";
	    this._settings.left = x;
	    this._settings.top = y;
	  },
	  $getSize: function (dx, dy) {
	    var _borders = this._settings._inner;

	    if (_borders) {
	      dx += (_borders.left ? 0 : 1) + (_borders.right ? 0 : 1);
	      dy += (_borders.top ? 0 : 1) + (_borders.bottom ? 0 : 1);
	    } //line between head and body


	    if (this._settings.head) dy += 1;

	    var size = this._body_cell.$getSize(0, 0);

	    var headMinWidth = 0;

	    if (this._head_cell) {
	      var head_size = this._head_cell.$getSize(0, 0);

	      if (head_size[3] == head_size[2]) this._settings.headHeight = head_size[3];
	      dy += this._settings.headHeight;
	      headMinWidth = head_size[0];
	    }

	    if (this._settings.fullscreen) {
	      var width = window.innerWidth || document.body.clientWidth;
	      var height = window.innerHeight || document.body.clientHeight;
	      return [width, width, height, height];
	    } //get layout sizes


	    var self_size = base.api.$getSize.call(this, 0, 0); //use child settings if layout's one was not defined

	    if (headMinWidth && size[1] > 100000) size[0] = Math.max(headMinWidth, size[0]);
	    self_size[1] = Math.min(self_size[1], (size[1] >= 100000 && self_size[1] >= 100000 ? Math.max(size[0], self_size[0]) : size[1]) + dx);
	    self_size[3] = Math.min(self_size[3], (size[3] >= 100000 && self_size[3] >= 100000 ? Math.max(size[2], self_size[2]) : size[3]) + dy);
	    self_size[0] = Math.min(Math.max(self_size[0], size[0] + dx), self_size[1]);
	    self_size[2] = Math.min(Math.max(self_size[2], size[2] + dy), self_size[3]);
	    return self_size;
	  },
	  $setSize: function (x, y) {
	    base.api.$setSize.call(this, x, y);
	    x = this._content_width;
	    y = this._content_height;

	    if (this._settings.head === false) {
	      this._headobj.style.display = "none";

	      this._body_cell.$setSize(x, y);
	    } else {
	      this._head_cell.$setSize(x, this._settings.headHeight);

	      this._body_cell.$setSize(x, y - this._settings.headHeight);
	    }
	  },
	  $skin: function () {
	    this.defaults.headHeight = $active.barHeight;
	  },
	  defaults: {
	    top: 0,
	    left: 0,
	    autofit: true,
	    relative: "bottom",
	    body: "",
	    head: "",
	    hidden: true,
	    autofocus: true,
	    minWidth: 300,
	    minHeight: 200
	  }
	};
	var view$3 = exports.protoUI(api$3, base.view, Movable, Modality, EventSystem, ResizeArea);
	var window$1 = {
	  api: api$3,
	  view: view$3
	};

	var ContextHelper = {
	  defaults: {
	    padding: "4",
	    hidden: true
	  },
	  body_setter: function (value) {
	    value = window$1.api.body_setter.call(this, value);
	    this._body_cell._viewobj.style.borderWidth = "0px";
	    return value;
	  },
	  attachTo: function (obj) {
	    assert(obj, "Invalid target for Context::attach");
	    var id;
	    if (obj.on_context) id = obj.attachEvent("onAfterContextMenu", bind(this._show_at_ui, this));else id = event$1(obj, "contextmenu", this._show_at_node, {
	      bind: this
	    });
	    this.attachEvent("onDestruct", function () {
	      if (obj.callEvent) obj.detachEvent(id);else eventRemove(id);
	      obj = null;
	    });
	  },
	  getContext: function () {
	    return this._area;
	  },
	  setContext: function (area) {
	    this._area = area;
	  },
	  _show_at_node: function (e) {
	    this._area = toNode(e || event$1);
	    return this._show_at(e);
	  },
	  _show_at_ui: function (id, e) {
	    this._area = {
	      obj: $$(e),
	      id: id
	    };
	    return this._show_at(e);
	  },
	  _show_at: function (e) {
	    var result = this.show(e, null, true);
	    if (result === false) return result; //event forced to close other popups|context menus

	    callEvent("onClick", []);
	    return preventEvent(e);
	  },
	  _show_on_mouse_out: true,
	  master_setter: function (value) {
	    this.attachTo(value);
	    return null;
	  }
	};

	var clipbuffer = {
	  _area: null,
	  _blur_id: null,
	  _ctrl: 0,

	  /*! create textarea or returns existing
	   **/
	  init: function () {
	    // returns existing textarea
	    if (this._area !== null) return this._area;
	    state.destructors.push({
	      obj: this
	    }); // creates new textarea

	    this._area = document.createElement("textarea");
	    this._area.className = "webix_clipbuffer";

	    this._area.setAttribute("webixignore", 1);

	    this._area.setAttribute("spellcheck", "false");

	    this._area.setAttribute("autocapitalize", "off");

	    this._area.setAttribute("autocorrect", "off");

	    this._area.setAttribute("autocomplete", "off");

	    document.body.appendChild(this._area);
	    event$1(document.body, "keydown", bind(function (e) {
	      var key = e.keyCode;
	      var ctrl = !!(e.ctrlKey || e.metaKey);

	      if (key === 86 && ctrl) {
	        this._area.value = "";
	        delay(this._paste, this, [e], 100);
	      }
	    }, this));
	    return this._area;
	  },
	  destructor: function () {
	    this._area = null;
	  },

	  /*! set text into buffer
	   **/
	  set: function (text) {
	    this.init();
	    text = text === "" ? "\n" : text;
	    this._area.value = text;
	    this.focus();
	  },

	  /*! select text in textarea
	   **/
	  focus: function () {
	    // if there is native browser selection, skip focus
	    if (!this._isSelectRange()) {
	      this.init();

	      this._area.focus();

	      this._area.select();
	    }
	  },

	  /*! checks document selection
	   **/
	  _isSelectRange: function () {
	    var text = "";

	    if (typeof window.getSelection != "undefined") {
	      text = window.getSelection().toString();
	    } else if (typeof document.selection != "undefined" && document.selection.type == "Text") {
	      text = document.selection.createRange().text;
	    }

	    return !!text;
	  },

	  /*! process ctrl+V pressing
	   **/
	  _paste: function (e) {
	    var trg = e.target || e.srcElement;

	    if (trg === this._area) {
	      var text = this._area.value;
	      var last_active = UIManager.getFocus();

	      if (last_active && (!last_active.getEditor || !last_active.getEditor())) {
	        last_active.callEvent("onPaste", [text]);

	        this._area.select();
	      }
	    }
	  }
	};

	var CopyPaste = {
	  clipboard_setter: function (value) {
	    if (value === true || value === 1) value = "modify";
	    this.attachEvent("onAfterSelect", function (id) {
	      var item = this.getItem(id);
	      var text = this.type.templateCopy(item);
	      clipbuffer.set(text, this);
	      clipbuffer.focus();
	      UIManager.setFocus(this);
	    });
	    this.attachEvent("onPaste", function (text) {
	      if (!isUndefined(this._paste[this._settings.clipboard])) this._paste[this._settings.clipboard].call(this, text);
	    });
	    this.attachEvent("onFocus", function () {
	      clipbuffer.focus();
	    }); // solution for clicks on selected items

	    this.attachEvent("onItemClick", function (id) {
	      if (!this._selected || this._selected.find(id) !== -1) {
	        clipbuffer.focus();
	        UIManager.setFocus(this);
	      }
	    });
	    return value;
	  },
	  _paste: {
	    // insert new item with pasted value
	    insert: function (text) {
	      this.add({
	        value: text
	      });
	    },
	    // change value of each selected item
	    modify: function (text) {
	      var sel = this.getSelectedId(true);

	      for (var i = 0; i < sel.length; i++) {
	        this.getItem(sel[i]).value = text;
	        this.refresh(sel[i]);
	      }
	    },
	    // do nothing
	    custom: function () {}
	  },
	  templateCopy_setter: function (value) {
	    this.type.templateCopy = template(value);
	  },
	  type: {
	    templateCopy: function (item) {
	      return this.template(item);
	    }
	  }
	};

	var CustomPrint = {
	  $customPrint: function (options, htmlOnly) {
	    if (this._prePrint(options, htmlOnly)) return true;

	    var tableData = this._getTableArray(options);

	    var table = this._getTableHTML(tableData, options);

	    if (htmlOnly) return table;
	    var doc = create("div", {
	      "class": "webix_ui_print"
	    });
	    doc.appendChild(table);
	    insertBefore(doc, options.docFooter, document.body);
	    window.print();
	    remove(doc);
	  },
	  _prePrint: function (options, htmlOnly) {
	    if (!htmlOnly && (this.config.layout == "y" || options.scroll || this.config.prerender || this.config.autoheight)) return true;
	    if (this.config.layout == "x") exports.extend(options || {}, {
	      xCount: this.count(),
	      nobreaks: true
	    }, true);
	  },
	  _getPageWidth: function (options) {
	    if (options.fit == "page") return Infinity;
	    var size = options.size;
	    var width = size[options.mode == "portrait" ? "width" : "height"];
	    return Math.min(width * env.printPPI - 2 * env.printMargin);
	  },
	  _getTableArray: function (options, base, start) {
	    var maxWidth = this._getPageWidth(options);

	    var xCount = options.xCount || this._getVisibleRange()._dx;

	    var tableArray = [];
	    var colrow = [];
	    var width = 0;
	    var newTableStart, rownum, colnum;
	    start = start || 0;
	    base = base || [];

	    for (var i = 0; i < this.data.order.length;) {
	      var obj = this.data.pull[this.data.order[i]];
	      rownum = parseInt(i / xCount);
	      colnum = i - rownum * xCount;

	      if (obj && colnum >= start) {
	        width += this.type.width; //start a new table, if cells do not fit page width

	        if (width > maxWidth && colnum > start) {
	          // 'colnum>start' ensures that a single long cell will have to fit the page
	          newTableStart = colrow.length + start;
	          tableArray.push(colrow);
	          i = i + (xCount - colrow.length);
	          colrow = [];
	          width = 0;
	          continue;
	        }

	        var cellValue = this.type.template(obj, this.type);
	        var className = this._itemClassName;
	        var style = {
	          display: "table-cell",
	          height: this.type.height + "px",
	          width: this.type.width + "px"
	        }; //push a cell to a row

	        colrow.push({
	          txt: cellValue,
	          className: className + " " + (obj.$css || ""),
	          style: style
	        }); //push a row to a table and start a new row

	        if ((i + 1) % xCount === 0) {
	          tableArray.push(colrow);
	          colrow = [];
	          width = 0;
	        }
	      }

	      i++;
	    }

	    base.push(tableArray);
	    if (newTableStart) this._getTableArray(options, base, newTableStart);
	    return base;
	  },
	  _getTableHTML: function (tableData, options) {
	    var container = create("div");
	    tableData.forEach(bind(function (table, i) {
	      var tableHTML = create("table", {
	        "class": "webix_table_print " + this.$view.className,
	        "style": "border-collapse:collapse"
	      });
	      table.forEach(function (row) {
	        var tr = create("tr");
	        row.forEach(function (column) {
	          var td = create("td");
	          if (column.txt) td.innerHTML = column.txt;
	          if (column.className) td.className = column.className;

	          if (column.style) {
	            var keys = Object.keys(column.style);
	            keys.forEach(function (key) {
	              if (column.style[key]) td.style[key] = column.style[key];
	            });
	          }

	          if (column.span) {
	            if (column.span.colspan > 1) td.colSpan = column.span.colspan;
	            if (column.span.rowspan > 1) td.rowSpan = column.span.rowspan;
	          }

	          tr.appendChild(td);
	        });
	        tableHTML.appendChild(tr);
	      });
	      container.appendChild(tableHTML);

	      if (!options.nobreaks && i + 1 < tableData.length) {
	        var br = create("DIV", {
	          "class": "webix_print_pagebreak"
	        });
	        container.appendChild(br);
	      }
	    }, this));
	    return container;
	  }
	};

	var temp$1 = null;

	var DataMarks = {
	  addCss: function (id, css, silent) {
	    if (!this.addRowCss && !silent) {
	      if (!this.hasCss(id, css)) {
	        var node = this.getItemNode(id);

	        if (node) {
	          node.className += " " + css;
	          silent = true;
	        }
	      }
	    }

	    return this.data.addMark(id, css, 1, 1, silent);
	  },
	  removeCss: function (id, css, silent) {
	    if (!this.addRowCss && !silent) {
	      if (this.hasCss(id, css)) {
	        var node = this.getItemNode(id);

	        if (node) {
	          node.className = node.className.replace(css, "").replace("  ", " ");
	          silent = true;
	        }
	      }
	    }

	    return this.data.removeMark(id, css, 1, silent);
	  },
	  hasCss: function (id, mark) {
	    return this.data.getMark(id, mark);
	  },
	  clearCss: function (css, silent) {
	    return this.data.clearMark(css, 1, silent);
	  }
	};

	/*
		Behavior:DataMove - allows to move and copy elements, heavily relays on DataStore.move
		@export
			copy
			move
	*/

	var DataMove = {
	  //creates a copy of the item
	  copy: function (sid, tindex, tobj, details) {
	    details = details || {};
	    var new_id = details.newId || sid;
	    tobj = tobj || this;
	    var data = this.getItem(sid);
	    assert(data, "Incorrect ID in DataMove::copy"); //make data conversion between objects

	    if (tobj) data = tobj._externalData(data); //adds new element same as original

	    return tobj.data.add(tobj._externalData(data, new_id), tindex, details.parent || 0);
	  },
	  _next_move_index: function (nid, next, source) {
	    if (next && nid) {
	      var new_index = this.getIndexById(nid);
	      return new_index + (source == this && source.getIndexById(next) < new_index ? 0 : 1);
	    }
	  },
	  //move item to the new position
	  move: function (sid, tindex, tobj, details) {
	    details = details || {};
	    var new_id = details.newId || sid;
	    tobj = tobj || this;
	    assert(tobj.data, "moving attempt to component without datastore");
	    if (!tobj.data) return; //can process an arrya - it allows to use it from onDrag 

	    if (isArray(sid)) {
	      //block separate repaint operations
	      if (sid.length > 3) //heuristic value, duplicated below
	        this.$blockRender = tobj.$blockRender = true;

	      for (var i = 0; i < sid.length; i++) {
	        //increase index for each next item in the set, so order of insertion will be equal to order in the array
	        var _nid = this.move(sid[i], tindex, tobj, details);

	        tindex = tobj._next_move_index(_nid, sid[i + 1], this);
	      }

	      this.$blockRender = tobj.$blockRender = false;

	      if (sid.length > 3) {
	        //repaint whole component
	        this.refresh();
	        if (tobj != this) tobj.refresh();
	      }

	      return;
	    }

	    var nid = sid; //id after moving

	    var data = this.getItem(sid);
	    assert(data, "Incorrect ID in DataMove::move");

	    if (!tobj || tobj == this) {
	      if (tindex < 0) tindex = this.data.order.length - 1;
	      this.data.move(this.getIndexById(sid), tindex); //move inside the same object

	      this.data.callEvent("onDataMove", [sid, tindex, null, this.data.order[tindex + 1]]);
	    } else {
	      //copy to the new object
	      nid = tobj.data.add(tobj._externalData(data, new_id), tindex, details.parent || 0);
	      this.data.remove(sid); //delete in old object
	    }

	    return nid; //return ID of item after moving
	  },
	  //move item on one position up
	  moveUp: function (id, step) {
	    return this.move(id, this.getIndexById(id) - (step || 1));
	  },
	  //move item on one position down
	  moveDown: function (id, step) {
	    return this.moveUp(id, (step || 1) * -1);
	  },
	  //move item to the first position
	  moveTop: function (id) {
	    return this.move(id, 0);
	  },
	  //move item to the last position
	  moveBottom: function (id) {
	    return this.move(id, this.data.count() - 1);
	  },

	  /*
	  	this is a stub for future functionality
	  	currently it just makes a copy of data object, which is enough for current situation
	  */
	  _externalData: function (data, id) {
	    var newdata = exports.extend({}, data);
	    newdata.id = !id || this.data.pull[id] ? uid() : id;
	    newdata.$template = null;
	    if (this._settings.externalData) newdata = this._settings.externalData.call(this, newdata, id, data);
	    return newdata;
	  }
	};

	var rules = {
	  isEmail: function (value) {
	    return /\S+@[^@\s]+\.[^@\s]+$/.test((value || "").toString());
	  },
	  isNumber: function (value) {
	    return parseFloat(value) == value;
	  },
	  isChecked: function (value) {
	    return !!value || value === "0";
	  },
	  isNotEmpty: function (value) {
	    return value === 0 || value;
	  }
	};

	var ValidateData = {
	  $init: function () {
	    if (this._events) this.attachEvent("onChange", this.clearValidation);
	  },
	  clearValidation: function () {
	    if (this.elements) {
	      for (var id in this.elements) {
	        this._clear_invalid(id);
	      }
	    }
	  },
	  validate: function (mode, obj) {
	    assert(this.callEvent, "using validate for eventless object");
	    this.callEvent("onBeforeValidate", []);
	    var failed = this._validate_details = {}; //optimistic by default :) 

	    var result = true;
	    var rules$$1 = this._settings.rules;
	    var isHidden = this.isVisible && !this.isVisible();
	    var validateHidden = mode && mode.hidden;
	    var validateDisabled = mode && mode.disabled; //prevent validation of hidden elements

	    var elements = {},
	        hidden = {};

	    for (var i in this.elements) {
	      var name = this.elements[i].config.name; //we are ignoring hidden and disabled fields during validation
	      //if mode doesn not instruct us otherwise
	      //if form itself is hidden, we can't separate hidden fiels,
	      //so we will vaidate all fields

	      if ((isHidden || this.elements[i].isVisible() || validateHidden) && (this.elements[i].isEnabled() || validateDisabled)) elements[name] = this.elements[i];else {
	        hidden[name] = true;
	      }
	    }

	    if (rules$$1 || elements) if (!obj && this.getValues) obj = this.getValues();

	    if (rules$$1) {
	      //complex rule, which may chcek all properties of object
	      if (rules$$1.$obj) result = this._validate(rules$$1.$obj, obj, obj, "") && result; //all - applied to all fields

	      var all = rules$$1.$all;
	      var data = obj;
	      if (this._settings.complexData) data = CodeParser.collapseNames(obj);
	      if (all) for (var _key in obj) {
	        if (hidden[_key]) continue;

	        var subresult = this._validate(all, data[_key], obj, _key);

	        if (!subresult) failed[_key] = true;
	        result = subresult && result;
	      } //per-field rules

	      for (var _key2 in rules$$1) {
	        if (hidden[_key2]) continue;

	        if (_key2.indexOf("$") !== 0 && !failed[_key2]) {
	          assert(rules$$1[_key2], "Invalid rule for:" + _key2);

	          var _subresult = this._validate(rules$$1[_key2], data[_key2], obj, _key2);

	          if (!_subresult) failed[_key2] = true;
	          result = _subresult && result;
	        }
	      }
	    } //check personal validation rules


	    if (elements) {
	      for (var key in elements) {
	        if (failed[key]) continue;
	        var subview = elements[key];

	        if (subview.validate) {
	          var _subresult2 = subview.validate();

	          result = _subresult2 && result;
	          if (!_subresult2) failed[key] = true;
	        } else {
	          var input = subview._settings;

	          if (input) {
	            //ignore non webix inputs
	            var validator = input.validate;
	            if (!validator && input.required) validator = rules$$1.isNotEmpty;

	            if (validator) {
	              var _subresult3 = this._validate(validator, obj[key], obj, key);

	              if (!_subresult3) failed[key] = true;
	              result = _subresult3 && result;
	            }
	          }
	        }
	      }
	    }

	    this.callEvent("onAfterValidation", [result, this._validate_details]);
	    return result;
	  },
	  _validate: function (rule, data, obj, key) {
	    if (typeof rule == "string") rule = rules[rule];

	    if (rule.call(this, data, obj, key)) {
	      if (this.callEvent("onValidationSuccess", [key, obj]) && this._clear_invalid) this._clear_invalid(key);
	      return true;
	    } else {
	      if (this.callEvent("onValidationError", [key, obj]) && this._mark_invalid) this._mark_invalid(key);
	    }

	    return false;
	  }
	};

	var _pull = {};
	function dp(name, getOnly) {
	  if (_typeof(name) == "object" && name._settings) name = name._settings.id;
	  if (_pull[name] || getOnly) return _pull[name];
	  if (typeof name == "string" || typeof name == "number") name = {
	    master: $$(name)
	  };
	  var dp = new DataProcessor(name);
	  var masterId = dp._settings.master._settings.id;
	  _pull[masterId] = dp;
	  $$(masterId).attachEvent("onDestruct", function () {
	    _pull[this._settings.id] = null;
	    delete _pull[this._settings.id];
	  });
	  return dp;
	}
	define("dp", dp);

	dp.$$ = function (id) {
	  return _pull[id];
	};

	var DataProcessor = exports.proto({
	  defaults: {
	    autoupdate: true,
	    updateFromResponse: false,
	    mode: "post",
	    operationName: "webix_operation",
	    trackMove: false
	  },

	  /*! constructor
	   **/
	  $init: function () {
	    this.reset();
	    this._ignore = false;
	    this.name = "DataProcessor";
	    this.$ready.push(this._after_init_call);
	  },
	  reset: function () {
	    this._updates = [];
	  },
	  url_setter: function (value) {
	    /*
	    	we can use simple url or mode->url
	    */
	    var mode = "";

	    if (typeof value == "string") {
	      var parts = value.split("->");

	      if (parts.length > 1) {
	        value = parts[1];
	        mode = parts[0];
	      }
	    } else if (value && value.mode) {
	      mode = value.mode;
	      value = value.url;
	    }

	    if (mode) return proxy$a(mode, value);
	    return value;
	  },
	  master_setter: function (value) {
	    var store = value;
	    if (value.name != "DataStore") store = value.data;
	    this._settings.store = store;
	    return value;
	  },

	  /*! attaching onStoreUpdated event
	   **/
	  _after_init_call: function () {
	    assert(this._settings.store, "store or master need to be defined for the dataprocessor");

	    this._settings.store.attachEvent("onStoreUpdated", bind(this._onStoreUpdated, this));

	    this._settings.store.attachEvent("onDataMove", bind(this._onDataMove, this));
	  },
	  ignore: function (code, master) {
	    var temp = this._ignore;
	    this._ignore = true;
	    code.call(master || this);
	    this._ignore = temp;
	  },
	  off: function () {
	    this._ignore = true;
	  },
	  on: function () {
	    this._ignore = false;
	  },
	  _copy_data: function (source) {
	    var obj = {};

	    for (var key in source) {
	      if (key.indexOf("$") !== 0) obj[key] = source[key];
	    }

	    return obj;
	  },
	  save: function (id, operation, obj) {
	    operation = operation || "update";

	    this._save_inner(id, obj || this._settings.store.getItem(id), operation);
	  },
	  _save_inner: function (id, obj, operation) {
	    if (_typeof(id) == "object") id = id.toString();
	    if (!id || this._ignore === true || !operation || operation == "paint") return true;
	    var store = this._settings.store;
	    if (store && store._scheme_serialize) obj = store._scheme_serialize(obj);
	    var update = {
	      id: id,
	      data: this._copy_data(obj),
	      operation: operation
	    }; //save parent id

	    if (!isUndefined(obj.$parent)) update.data.parent = obj.$parent;

	    if (update.operation != "delete") {
	      //prevent saving of not-validated records
	      var master = this._settings.master;
	      if (master && master.data && master.data.getMark && master.data.getMark(id, "webix_invalid")) update._invalid = true;
	      if (!this.validate(null, update.data)) update._invalid = true;
	    }

	    if (this._check_unique(update)) this._updates.push(update);
	    if (this._settings.autoupdate) this.send();
	    return true;
	  },
	  _onDataMove: function (sid, tindex, parent, targetid) {
	    if (this._settings.trackMove) {
	      var obj = copy(this._settings.store.getItem(sid));
	      obj.webix_move_index = tindex;
	      obj.webix_move_id = targetid;
	      obj.webix_move_parent = parent;

	      this._save_inner(sid, obj, "order");
	    }
	  },
	  _onStoreUpdated: function (id, obj, operation) {
	    switch (operation) {
	      case "save":
	        operation = "update";
	        break;

	      case "update":
	        operation = "update";
	        break;

	      case "add":
	        operation = "insert";
	        break;

	      case "delete":
	        operation = "delete";
	        break;

	      default:
	        return true;
	    }

	    return this._save_inner(id, obj, operation);
	  },
	  _check_unique: function (check) {
	    for (var i = 0; i < this._updates.length; i++) {
	      var one = this._updates[i];

	      if (one.id == check.id && !one._in_progress) {
	        if (check.operation == "delete") {
	          if (one.operation == "insert") this._updates.splice(i, 1);else one.operation = "delete";
	        }

	        one.data = check.data;
	        one._invalid = check._invalid;
	        return false;
	      }
	    }

	    return true;
	  },
	  send: function () {
	    this._sendData();
	  },
	  _sendData: function () {
	    var _this = this;

	    if (!this._settings.url) return;
	    var marked = this._updates;
	    var to_send = [];
	    var url = this._settings.url;

	    for (var i = 0; i < marked.length; i++) {
	      var tosave = marked[i];
	      if (tosave._in_progress) continue;
	      if (tosave._invalid) continue;
	      var id = tosave.id;
	      var operation = tosave.operation;
	      var precise_url = proxy$a.$parse(_typeof(url) == "object" && !url.$proxy ? url[operation] : url);
	      var custom = precise_url && (precise_url.$proxy || typeof precise_url === "function");
	      if (!precise_url) continue;
	      if (this._settings.store._scheme_save) this._settings.store._scheme_save(tosave.data);
	      if (!this.callEvent("onBefore" + operation, [id, tosave])) continue;
	      tosave._in_progress = true;
	      if (!this.callEvent("onBeforeDataSend", [tosave])) return;
	      tosave.data = this._updatesData(tosave.data);

	      var callback = this._send_callback({
	        id: tosave.id,
	        status: tosave.operation
	      });

	      if (precise_url.$proxy) {
	        if (precise_url.save) {
	          //proxy
	          var result = precise_url.save(this.config.master, tosave, this);

	          this._proxy_on_save(result, callback);
	        }

	        to_send.push(tosave);
	      } else {
	        if (operation == "insert") delete tosave.data.id;

	        if (custom) {
	          //save function
	          var _result = precise_url.call(this.config.master, tosave.id, tosave.operation, tosave.data);

	          this._proxy_on_save(_result, callback);
	        } else {
	          //normal url
	          tosave.data[this._settings.operationName] = operation;

	          this._send(precise_url, tosave.data, this._settings.mode, operation, callback);
	        }
	      }

	      this.callEvent("onAfterDataSend", [tosave]);
	    }

	    if (url.$proxy && url.saveAll && to_send.length) {
	      var _result2 = url.saveAll(this.config.master, to_send, this);

	      if (_result2) {
	        if (!_result2.then) _result2 = Deferred.resolve(_result2);

	        _result2.then(function (data) {
	          if (data && typeof data.json == "function") data = data.json();

	          _this._processResult(data);
	        }, function (x) {
	          _this._processError(null, "", null, x);
	        });
	      }
	    }
	  },
	  _proxy_on_save: function (result, callback) {
	    if (result) {
	      if (!result.then) result = Deferred.resolve(result);
	      result.then(function (data) {
	        if (data && typeof data.json == "function") data = data.json();
	        callback.success("", data, -1); //text, data, loader
	      }, function (x) {
	        callback.error("", null, x);
	      });
	    }
	  },

	  /*! process updates list to POST and GET params according dataprocessor protocol
	   *	@param updates
	   *		list of objects { id: "item id", data: "data hash", operation: "type of operation"}
	   *	@return
	   *		object { post: { hash of post params as name: value }, get: { hash of get params as name: value } }
	   **/
	  _updatesData: function (source) {
	    var target = {};

	    for (var j in source) {
	      if (j.indexOf("$") !== 0) target[j] = source[j];
	    }

	    return target;
	  },

	  /*! send dataprocessor query to server
	   *	and attach event to process result
	   *	@param url
	   *		server url
	   *	@param get
	   *		hash of get params
	   *	@param post
	   *		hash of post params
	   *	@mode
	   *		'post' or 'get'
	   **/
	  _send: function (url, post, mode, operation, callback) {
	    assert(url, "url was not set for DataProcessor");
	    if (typeof url == "function") return url(post, operation, callback);
	    ajax()[mode](url, post, callback);
	  },
	  _send_callback: function (id) {
	    var self = this;
	    return {
	      success: function (t, d, l) {
	        return self._processResult(id, t, d, l);
	      },
	      error: function (t, d, l) {
	        return self._processError(id, t, d, l);
	      }
	    };
	  },
	  attachProgress: function (start, end, error) {
	    this.attachEvent("onBeforeDataSend", start);
	    this.attachEvent("onAfterSync", end);
	    this.attachEvent("onAfterSaveError", error);
	    this.attachEvent("onLoadError", error);
	  },
	  _processError: function (id, text, data, loader) {
	    if (id) this._innerProcessResult(true, id.id, false, id.status, false, {
	      text: text,
	      data: data,
	      loader: loader
	    });else {
	      this.callEvent("onLoadError", arguments);
	      callEvent("onLoadError", [text, data, loader, this]);
	    }
	  },
	  _innerProcessResult: function (error, id, newid, status, obj, details) {
	    var master = this._settings.master;
	    var update = this.getItemState(id);
	    update._in_progress = false;

	    if (error) {
	      if (this.callEvent("onBeforeSaveError", [id, status, obj, details])) {
	        update._invalid = true;

	        if (this._settings.undoOnError && master._settings.undo) {
	          this.ignore(function () {
	            master.undo(id);
	          });
	          this.setItemState(id, false);
	        }

	        this.callEvent("onAfterSaveError", [id, status, obj, details]);
	      }

	      return;
	    } else this.setItemState(id, false); //update from response


	    if (newid && id != newid) this._settings.store.changeId(id, newid);
	    if (obj && status != "delete" && this._settings.updateFromResponse) this.ignore(function () {
	      this._settings.store.updateItem(newid || id, obj);
	    }); //clean undo history, for the saved record

	    if (this._settings.undoOnError && master._settings.undo) master.removeUndo(newid || id);
	    this.callEvent("onAfterSave", [obj, id, details]);
	    this.callEvent("onAfter" + status, [obj, id, details]);
	  },
	  processResult: function (state, hash, details) {
	    //compatibility with custom json response
	    var error = hash && (hash.status == "error" || hash.status == "invalid");
	    var newid = hash ? hash.newid || hash.id : false;

	    this._innerProcessResult(error, state.id, newid, state.status, hash, details);
	  },
	  // process saving from result
	  _processResult: function (state, text, data, loader) {
	    var _this2 = this;

	    this.callEvent("onBeforeSync", [state, text, data, loader]);

	    if (isArray(state)) {
	      //saveAll results
	      state.forEach(function (one) {
	        _this2.processResult(one, one, {});
	      });
	    } else {
	      if (loader === -1) {
	        //callback from promise
	        this.processResult(state, data, {});
	      } else {
	        var proxy = this._settings.url;
	        if (proxy.$proxy && proxy.result) proxy.result(state, this._settings.master, this, text, data, loader);else {
	          var hash;

	          if (text) {
	            hash = data.json(); //invalid response

	            if (text && (hash === null || typeof hash == "undefined")) hash = {
	              status: "error"
	            };
	          }

	          this.processResult(state, hash, {
	            text: text,
	            data: data,
	            loader: loader
	          });
	        }
	      }
	    }

	    this.callEvent("onAfterSync", [state, text, data, loader]);
	  },

	  /*! if it's defined escape function - call it
	   *	@param value
	   *		value to escape
	   *	@return
	   *		escaped value
	   **/
	  escape: function (value) {
	    if (this._settings.escape) return this._settings.escape(value);else return encodeURIComponent(value);
	  },
	  getState: function () {
	    if (!this._updates.length) return false;

	    for (var i = this._updates.length - 1; i >= 0; i--) {
	      if (this._updates[i]._in_progress) return "saving";
	    }

	    return true;
	  },
	  getItemState: function (id) {
	    var index = this._get_stack_index(id);

	    return this._updates[index] || null;
	  },
	  setItemState: function (id, state) {
	    if (state) this.save(id, state);else {
	      var index = this._get_stack_index(id);

	      if (index > -1) this._updates.splice(index, 1);
	    }
	  },
	  _get_stack_index: function (id) {
	    var index = -1;

	    for (var i = 0; i < this._updates.length; i++) {
	      if (this._updates[i].id == id) {
	        index = i;
	        break;
	      }
	    }

	    return index;
	  }
	}, Settings, EventSystem, ValidateData);

	/*
		DataStore is not a behavior, it standalone object, which represents collection of data.
		Call provideAPI to map data API

		@export
			exists
			getIdByIndex
			getIndexById
			get
			set
			refresh
			count
			sort
			filter
			next
			previous
			clearAll
			first
			last
	*/

	function DataStore() {
	  this.name = "DataStore";
	  exports.extend(this, EventSystem);
	  this.setDriver("json"); //default data source is an

	  this.pull = {}; //hash of IDs

	  this.order = toArray(); //order of IDs

	  this._marks = {};
	}

	DataStore.prototype = {
	  //defines type of used data driver
	  //data driver is an abstraction other different data formats - xml, json, csv, etc.
	  setDriver: function (type) {
	    assert(DataDriver[type], "incorrect DataDriver");
	    this.driver = DataDriver[type];
	  },
	  //process incoming raw data
	  _parse: function (data) {
	    this.callEvent("onParse", [this.driver, data]);
	    if (this._filter_order) this.filter(); //get size and position of data

	    var info = this.driver.getInfo(data); //generated by connectors only

	    if (info.key) state.securityKey = info.key;
	    if (info.config) this.callEvent("onServerConfig", [info.config]);
	    var options = this.driver.getOptions(data);
	    if (options) this.callEvent("onServerOptions", [options]); //get array of records

	    var recs = this.driver.getRecords(data);

	    this._inner_parse(info, recs); //in case of tree store we may want to group data


	    if (this._scheme_group && this._group_processing && !this._not_grouped_order) this._group_processing(this._scheme_group); //optional data sorting

	    if (this._scheme_sort) {
	      this.blockEvent();
	      this.sort(this._scheme_sort);
	      this.unblockEvent();
	    }

	    this.callEvent("onStoreLoad", [this.driver, data]); //repaint self after data loading

	    this.refresh();
	  },
	  _inner_parse: function (info, recs) {
	    var from = info.from;
	    var subload = true;
	    var marks = false; //some data is loaded and new data doesn't have "pos" - assuming update

	    if (!from && from !== 0 && this.order[0]) {
	      if (this._removeMissed) {
	        //update mode, create kill list
	        marks = {};

	        for (var i = 0; i < this.order.length; i++) {
	          marks[this.order[i]] = true;
	        }
	      }

	      subload = false;
	      from = this.order.length;
	    } else from = (from || 0) * 1;

	    var j = 0;

	    for (var _i = 0; _i < recs.length; _i++) {
	      //get hash of details for each record
	      var temp = this.driver.getDetails(recs[_i]);
	      var id = this.id(temp); //generate ID for the record

	      if (!this.pull[id]) {
	        //if such ID already exists - update instead of insert
	        this.order[j + from] = id;
	        j++;
	      } else if (subload && this.order[j + from]) j++;

	      if (this.pull[id]) {
	        exports.extend(this.pull[id], temp, true); //add only new properties

	        if (this._scheme_update) this._scheme_update(this.pull[id]); //update mode, remove item from kill list

	        if (marks) delete marks[id];
	      } else {
	        this.pull[id] = temp;
	        if (this._scheme_init) this._scheme_init(temp);
	      }
	    } //update mode, delete items which are not existing in the new xml


	    if (marks) {
	      this.blockEvent();

	      for (var delid in marks) {
	        this.remove(delid);
	      }

	      this.unblockEvent();
	    }

	    var endpos = info.size * 1;

	    if (endpos) {
	      if (!this.order[endpos - 1]) this.order[endpos - 1] = undefined;
	      if (endpos < this.order.length) this.order = this.order.slice(0, endpos);
	    }
	  },
	  //generate id for data object
	  id: function (data) {
	    return data.id || (data.id = uid());
	  },
	  changeId: function (old, newid) {
	    //assert(this.pull[old],"Can't change id, for non existing item: "+old);
	    if (old == newid) return;
	    if (this.pull[old]) this.pull[newid] = this.pull[old];
	    this.pull[newid].id = newid;
	    this.order[this.order.find(old)] = newid;
	    if (this._filter_order) this._filter_order[this._filter_order.find(old)] = newid;

	    if (this._marks[old]) {
	      this._marks[newid] = this._marks[old];
	      delete this._marks[old];
	    }

	    this.callEvent("onIdChange", [old, newid]);
	    if (this._render_change_id) this._render_change_id(old, newid);
	    delete this.pull[old];
	  },
	  //get data from hash by id
	  getItem: function (id) {
	    return this.pull[id];
	  },
	  //assigns data by id
	  updateItem: function (id, update, mode) {
	    if (_typeof(id) === "object") id = id.toString();
	    var data = this.getItem(id);
	    var old = null; //check is change tracking active

	    var changeTrack = this.hasEvent("onDataUpdate");
	    assert(data, "Invalid ID for updateItem");
	    assert(!update || !update.id || update.id == id, "Attempt to change ID in updateItem");

	    if (!isUndefined(update) && data !== update) {
	      //preserve original object
	      if (changeTrack) old = copy(data);
	      id = data.id; //preserve id

	      exports.extend(data, update, true);
	      data.id = id;
	    }

	    if (this._scheme_update) this._scheme_update(data);
	    this.callEvent("onStoreUpdated", [id, data, mode || "update"]);
	    if (changeTrack) this.callEvent("onDataUpdate", [id, data, old]);
	  },
	  //sends repainting signal
	  refresh: function (id) {
	    if (this._skip_refresh) return;

	    if (id) {
	      if (this.exists(id)) this.callEvent("onStoreUpdated", [id, this.pull[id], "paint"]);
	    } else this.callEvent("onStoreUpdated", [null, null, null]);
	  },
	  silent: function (code, master) {
	    this._skip_refresh = true;
	    code.call(master || this);
	    this._skip_refresh = false;
	  },
	  //converts range IDs to array of all IDs between them
	  getRange: function (from, to) {
	    //if some point is not defined - use first or last id
	    //BEWARE - do not use empty or null ID
	    if (from) from = this.getIndexById(from);else from = this.$min || this.startOffset || 0;
	    if (to) to = this.getIndexById(to);else {
	      to = this.$max === 0 ? 0 : Math.min(this.$max ? this.$max - 1 : this.endOffset || Infinity, this.count() - 1);
	      if (to < 0) to = 0; //we have not data in the store
	    }

	    if (from > to) {
	      //can be in case of backward shift-selection
	      var a = to;
	      to = from;
	      from = a;
	    }

	    return this.getIndexRange(from, to);
	  },
	  //converts range of indexes to array of all IDs between them
	  getIndexRange: function (from, to) {
	    to = Math.min(to === 0 ? 0 : to || Infinity, this.count() - 1);
	    var ret = toArray(); //result of method is rich-array

	    for (var i = from || 0; i <= to; i++) {
	      ret.push(this.getItem(this.order[i]));
	    }

	    return ret;
	  },
	  //returns total count of elements
	  count: function () {
	    return this.order.length;
	  },
	  //returns truy if item with such ID exists
	  exists: function (id) {
	    return !!this.pull[id];
	  },
	  //nextmethod is not visible on component level, check DataMove.move
	  //moves item from source index to the target index
	  move: function (sindex, tindex) {
	    assert(sindex >= 0 && tindex >= 0, "DataStore::move", "Incorrect indexes");
	    if (sindex == tindex) return;
	    var id = this.getIdByIndex(sindex);
	    var obj = this.getItem(id);
	    if (this._filter_order) this._move_inner(this._filter_order, 0, 0, this.getIdByIndex(sindex), this.getIdByIndex(tindex));

	    this._move_inner(this.order, sindex, tindex); //repaint signal


	    this.callEvent("onStoreUpdated", [id, obj, "move"]);
	  },
	  _move_inner: function (col, sindex, tindex, sid, tid) {
	    if (sid || tid) {
	      sindex = tindex = -1;

	      for (var i = 0; i < col.length; i++) {
	        if (col[i] == sid && sindex < 0) sindex = i;
	        if (col[i] == tid && tindex < 0) tindex = i;
	      }
	    }

	    var id = col[sindex];
	    col.removeAt(sindex); //remove at old position

	    col.insertAt(id, Math.min(col.length, tindex)); //insert at new position
	  },
	  scheme: function (config) {
	    this._scheme = {};
	    this._scheme_save = config.$save;
	    this._scheme_init = config.$init || config.$change;
	    this._scheme_update = config.$update || config.$change;
	    this._scheme_serialize = config.$serialize;
	    this._scheme_group = config.$group;
	    this._scheme_sort = config.$sort;
	    this._scheme_export = config.$export; //ignore $-starting properties, as they have special meaning

	    for (var key in config) {
	      if (key.substr(0, 1) != "$") this._scheme[key] = config[key];
	    }
	  },
	  importData: function (target, silent) {
	    var data = target ? target.data || target : [];
	    this._filter_order = null;

	    if (typeof data.serialize == "function") {
	      this.order = toArray([].concat(data.order)); //make full copy, to preserve object properties
	      //[WE-CAN-DO-BETTER]

	      if (this._make_full_copy) {
	        this._make_full_copy = false;
	        var oldpull = this.pull;
	        this.pull = {};

	        for (var _key in data.pull) {
	          var old = oldpull[_key];
	          this.pull[_key] = copy(data.pull[_key]);
	          if (old && old.open) this.pull[_key].open = true;
	        }
	      } else this.pull = data.pull;

	      if (data.branch && this.branch) {
	        this.branch = copy(data.branch);
	        this._filter_branch = null;
	      }
	    } else {
	      this.order = toArray();
	      this.pull = {};
	      var id, obj;
	      if (isArray(target)) for (var _key2 = 0; _key2 < target.length; _key2++) {
	        obj = id = target[_key2];
	        if (_typeof(obj) == "object") obj.id = obj.id || uid();else obj = {
	          id: id,
	          value: id
	        };
	        this.order.push(obj.id);
	        if (this._scheme_init) this._scheme_init(obj);
	        this.pull[obj.id] = obj;
	      } else for (var _key3 in data) {
	        this.order.push(_key3);
	        this.pull[_key3] = {
	          id: _key3,
	          value: data[_key3]
	        };
	      }
	    }

	    if (this._extraParser && !data.branch) {
	      this.branch = {
	        0: []
	      };
	      if (!this._datadriver_child) this._set_child_scheme("data");

	      for (var i = 0; i < this.order.length; i++) {
	        var key = this.order[i];

	        this._extraParser(this.pull[key], 0, 0, false);
	      }
	    }

	    this.callEvent("onStoreLoad", []);
	    if (!silent) this.callEvent("onStoreUpdated", []);
	  },
	  sync: function (source, filter, silent) {
	    this.unsync();

	    var type = _typeof(source);

	    if (type == "string") source = $$(source);

	    if (type != "function" && type != "object") {
	      silent = filter;
	      filter = null;
	    }

	    if (source.name != "DataStore") {
	      if (source.data && (source.data.name === "DataStore" || source.data.name === "TreeStore")) source = source.data;else {
	        this._sync_source = source;
	        return callEvent("onSyncUnknown", [this, source, filter]);
	      }
	    }

	    var sync_logic = bind(function (id, data, mode) {
	      if (this._skip_next_sync) return; //sync of tree-structure with after-filtering
	      //we need to make a full copy, to preserve $count
	      //[WE-CAN-DO-BETTER]

	      if (filter && this.branch) this._make_full_copy = true;
	      this.importData(source, true);
	      if (filter) this.silent(filter);
	      if (this._on_sync) this._on_sync();
	      if (!(id && data && mode)) //clearall
	        this._marks = {};
	      if (mode == "delete" && this._marks[id]) delete this._marks[id];
	      this.callEvent("onSyncApply", []);
	      if (!silent) this.refresh();else silent = false;
	    }, this);
	    this._sync_events = [source.attachEvent("onStoreUpdated", sync_logic), source.attachEvent("onIdChange", bind(function (old, nid) {
	      this.changeId(old, nid);
	      this.refresh(nid);
	    }, this))];
	    this._sync_source = source; //backward data saving

	    this._back_sync_handler = this.attachEvent("onStoreUpdated", function (id, data, mode) {
	      if (mode == "update" || mode == "save") {
	        this._skip_next_sync = 1;
	        source.updateItem(id, data);
	        this._skip_next_sync = 0;
	      }
	    });
	    sync_logic();
	  },
	  unsync: function () {
	    if (this._sync_source) {
	      var source = this._sync_source;

	      if (source.name != "DataStore" && (!source.data || source.data.name != "DataStore")) {
	        //data sync with external component
	        callEvent("onUnSyncUnknown", [this, source]);
	      } else {
	        //data sync with webix component
	        for (var i = 0; i < this._sync_events.length; i++) {
	          source.detachEvent(this._sync_events[i]);
	        }

	        this.detachEvent(this._back_sync_handler);
	      }

	      this._sync_source = null;
	    }
	  },
	  destructor: function () {
	    this.unsync();
	    this.pull = this.order = this._marks = null;
	    this._evs_events = this._evs_handlers = {};
	  },
	  //adds item to the store
	  add: function (obj, index) {
	    //default values		
	    if (this._scheme) for (var key in this._scheme) {
	      if (isUndefined(obj[key])) obj[key] = this._scheme[key];
	    }
	    if (this._scheme_init) this._scheme_init(obj); //generate id for the item

	    var id = this.id(obj); //in case of treetable order is sent as 3rd parameter

	    var order = arguments[2] || this.order; //by default item is added to the end of the list

	    var data_size = order.length;
	    if (isUndefined(index) || index < 0) index = data_size; //check to prevent too big indexes			

	    if (index > data_size) {
	      assert(0, "Warning", "DataStore:add", "Index of out of bounds");
	      index = Math.min(order.length, index);
	    }

	    if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;
	    assert(!this.exists(id), "Not unique ID");
	    this.pull[id] = obj;
	    order.insertAt(id, index);

	    if (this._filter_order) {
	      //adding during filtering
	      //we can't know the location of new item in full dataset, making suggestion
	      //put at end of original dataset by default
	      var original_index = this._filter_order.length; //if some data exists, put at the same position in original and filtered lists

	      if (this.order.length) original_index = Math.min(index || 0, original_index);

	      this._filter_order.insertAt(id, original_index);
	    } //repaint signal


	    this.callEvent("onStoreUpdated", [id, obj, "add"]);
	    this.callEvent("onAfterAdd", [id, index]);
	    return obj.id;
	  },
	  //removes element from datastore
	  remove: function (id) {
	    //id can be an array of IDs - result of getSelect, for example
	    if (isArray(id)) {
	      for (var i = 0; i < id.length; i++) {
	        this.remove(id[i]);
	      }

	      return;
	    }

	    if (this.callEvent("onBeforeDelete", [id]) === false) return false;
	    assert(this.exists(id), "Not existing ID in remove command" + id);
	    var obj = this.getItem(id); //save for later event
	    //clear from collections

	    this.order.remove(id);
	    if (this._filter_order) this._filter_order.remove(id);
	    delete this.pull[id];
	    if (this._marks[id]) delete this._marks[id]; //repaint signal

	    this.callEvent("onStoreUpdated", [id, obj, "delete"]);
	    this.callEvent("onAfterDelete", [id]);
	  },
	  //deletes all records in datastore
	  clearAll: function (soft) {
	    //instead of deleting one by one - just reset inner collections
	    this.pull = {};
	    this._marks = {};
	    this.order = toArray(); //this.feed = null;

	    this._filter_order = null;
	    if (!soft) this.url = null;
	    this.callEvent("onClearAll", [soft]);
	    this.refresh();
	  },
	  //converts id to index
	  getIdByIndex: function (index) {
	    assert(index >= 0, "DataStore::getIdByIndex Incorrect index");
	    return this.order[index];
	  },
	  //converts index to id
	  getIndexById: function (id) {
	    if (!this.pull[id]) return -1;else return this.order.find(id); //slower than getIdByIndex
	  },
	  //returns ID of next element
	  getNextId: function (id, step) {
	    return this.order[this.getIndexById(id) + (step || 1)];
	  },
	  //returns ID of first element
	  getFirstId: function () {
	    return this.order[0];
	  },
	  //returns ID of last element
	  getLastId: function () {
	    return this.order[this.order.length - 1];
	  },
	  //returns ID of previous element
	  getPrevId: function (id, step) {
	    return this.order[this.getIndexById(id) - (step || 1)];
	  },

	  /*
	  	sort data in collection
	  		by - settings of sorting
	  	
	  	or
	  	
	  		by - sorting function
	  		dir - "asc" or "desc"
	  		
	  	or
	  	
	  		by - property
	  		dir - "asc" or "desc"
	  		as - type of sortings
	  	
	  	Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	  */
	  sort: function (by, dir, as) {
	    var sort = by;
	    if (typeof by == "function") sort = {
	      as: by,
	      dir: dir
	    };else if (typeof by == "string") sort = {
	      by: by.replace(/#/g, ""),
	      dir: dir,
	      as: as
	    };
	    var parameters = [sort.by, sort.dir, sort.as, sort];
	    if (!this.callEvent("onBeforeSort", parameters)) return;
	    this.order = this._sort_core(sort, this.order);
	    if (this._filter_order && this._filter_order.length != this.order.length) this._filter_order = this._sort_core(sort, this._filter_order); //repaint self

	    this.refresh();
	    this.callEvent("onAfterSort", parameters);
	  },
	  _sort_core: function (sort, order) {
	    var sorter = this.sorting.create(sort);

	    if (this.order.length) {
	      var pre = order.splice(0, this.$freeze); //get array of IDs

	      var neworder = toArray();

	      for (var i = order.length - 1; i >= 0; i--) {
	        neworder[i] = this.pull[order[i]];
	      }

	      neworder.sort(sorter);
	      return toArray(pre.concat(neworder.map(function (obj) {
	        assert(obj, "Client sorting can't be used with dynamic loading");
	        return this.id(obj);
	      }, this)));
	    }

	    return order;
	  },

	  /*
	  	Filter datasource
	  	
	  	text - property, by which filter
	  	value - filter mask
	  	
	  	or
	  	
	  	text  - filter method
	  	
	  	Filter method will receive data object and must return true or false
	  */
	  _filter_reset: function (preserve) {
	    //remove previous filtering , if any
	    if (this._filter_order && !preserve) {
	      this.order = this._filter_order;
	      delete this._filter_order;
	    }
	  },
	  _filter_core: function (filter, value, preserve) {
	    var neworder = toArray();
	    var freeze = this.$freeze || 0;

	    for (var i = 0; i < this.order.length; i++) {
	      var id = this.order[i];
	      if (i < freeze || filter(this.getItem(id), value)) neworder.push(id);
	    } //set new order of items, store original


	    if (!preserve || !this._filter_order) this._filter_order = this.order;
	    this.order = neworder;
	  },
	  find: function (config, first) {
	    var result = [];

	    for (var i in this.pull) {
	      var data = this.pull[i];
	      var match = true;

	      if (_typeof(config) == "object") {
	        for (var key in config) {
	          if (data[key] != config[key]) {
	            match = false;
	            break;
	          }
	        }
	      } else if (!config(data)) match = false;

	      if (match) result.push(data);
	      if (first && result.length) return result[0];
	    }

	    return first ? null : result;
	  },
	  filter: function (text, value, preserve) {
	    //unfilter call but we already in not-filtered state
	    if (!text && !this._filter_order && !this._filter_branch) return;
	    if (!this.callEvent("onBeforeFilter", [text, value])) return;

	    this._filter_reset(preserve);

	    if (!this.order.length) return; //if text not define -just unfilter previous state and exit

	    if (text) {
	      var filter = text;
	      value = value || "";

	      if (typeof text == "string") {
	        text = text.replace(/#/g, "");
	        if (typeof value == "function") filter = function (obj) {
	          return value(obj[text]);
	        };else {
	          value = value.toString().toLowerCase();

	          filter = function (obj, value) {
	            //default filter - string start from, case in-sensitive
	            assert(obj, "Client side filtering can't be used with dynamic loading");
	            return (obj[text] || "").toString().toLowerCase().indexOf(value) != -1;
	          };
	        }
	      }

	      this._filter_core(filter, value, preserve, this._filterMode);
	    } //repaint self


	    this.refresh();
	    this.callEvent("onAfterFilter", []);
	  },

	  /*
	  	Iterate through collection
	  */
	  _obj_array: function () {
	    var data = [];

	    for (var i = this.order.length - 1; i >= 0; i--) {
	      data[i] = this.pull[this.order[i]];
	    }

	    return data;
	  },
	  each: function (method, master, all) {
	    var order = this.order;
	    if (all) order = this._filter_order || order;

	    for (var i = 0; i < order.length; i++) {
	      if (order[i]) method.call(master || this, this.getItem(order[i]), i);
	    }
	  },
	  _methodPush: function (object, method) {
	    return function () {
	      return object[method].apply(object, arguments);
	    };
	  },

	  /*
	  	map inner methods to some distant object
	  */
	  provideApi: function (target, eventable) {
	    if (eventable) {
	      this.mapEvent({
	        onbeforesort: target,
	        onaftersort: target,
	        onbeforeadd: target,
	        onafteradd: target,
	        onbeforedelete: target,
	        onafterdelete: target,
	        ondataupdate: target
	        /*,
	        onafterfilter:	target,
	        onbeforefilter:	target*/

	      });
	    }

	    var list = ["sort", "add", "remove", "exists", "getIdByIndex", "getIndexById", "getItem", "updateItem", "refresh", "count", "filter", "find", "getNextId", "getPrevId", "clearAll", "getFirstId", "getLastId", "serialize", "sync"];

	    for (var i = 0; i < list.length; i++) {
	      target[list[i]] = this._methodPush(this, list[i]);
	    }
	  },
	  addMark: function (id, mark, css, value, silent) {
	    var obj = this._marks[id] || {};
	    this._marks[id] = obj;

	    if (!obj[mark]) {
	      obj[mark] = value || true;

	      if (css) {
	        var old_css = obj.$css || "";
	        obj.$css = old_css + " " + mark;
	      }

	      if (!silent) this.refresh(id);
	    }

	    return obj[mark];
	  },
	  removeMark: function (id, mark, css, silent) {
	    var obj = this._marks[id];

	    if (obj) {
	      if (obj[mark]) delete obj[mark];

	      if (css) {
	        var current_css = obj.$css;

	        if (current_css) {
	          obj.$css = current_css.replace(mark, "").replace("  ", " ");
	        }
	      }

	      if (!silent) this.refresh(id);
	    }
	  },
	  getMark: function (id, mark) {
	    var obj = this._marks[id];
	    return obj ? obj[mark] : false;
	  },
	  clearMark: function (name, css, silent) {
	    for (var id in this._marks) {
	      var obj = this._marks[id];

	      if (obj[name]) {
	        delete obj[name];
	        if (css && obj.$css) obj.$css = obj.$css.replace(name, "").replace("  ", " ");
	        if (!silent) this.refresh(id);
	      }
	    }
	  },

	  /*
	  	serializes data to a json object
	  */
	  serialize: function (all) {
	    var ids = this.order;
	    if (all && this._filter_order) ids = this._filter_order;
	    var result = [];

	    for (var i = 0; i < ids.length; i++) {
	      var el = this.pull[ids[i]];

	      if (this._scheme_serialize) {
	        el = this._scheme_serialize(el);
	        if (el === false) continue;
	      }

	      result.push(el);
	    }

	    return result;
	  },
	  sorting: {
	    create: function (config) {
	      return this._dir(config.dir, this._by(config.by, config.as));
	    },
	    as: {
	      //handled by dataFeed
	      "server": function () {
	        return false;
	      },
	      "date": function (a, b) {
	        a = a - 0;
	        b = b - 0;
	        return a > b ? 1 : a < b ? -1 : 0;
	      },
	      "int": function (a, b) {
	        a = a * 1;
	        b = b * 1;
	        return a > b ? 1 : a < b ? -1 : 0;
	      },
	      "string_strict": function (a, b) {
	        a = a.toString();
	        b = b.toString();
	        return a > b ? 1 : a < b ? -1 : 0;
	      },
	      "string": function (a, b) {
	        if (!b) return 1;
	        if (!a) return -1;
	        a = a.toString().toLowerCase();
	        b = b.toString().toLowerCase();
	        return a > b ? 1 : a < b ? -1 : 0;
	      },
	      "raw": function (a, b) {
	        return a > b ? 1 : a < b ? -1 : 0;
	      }
	    },
	    _by: function (prop, method) {
	      if (!prop) return method;
	      if (typeof method != "function") method = this.as[method || "string"];
	      assert(method, "Invalid sorting method");
	      return function (a, b) {
	        return method(a[prop], b[prop]);
	      };
	    },
	    _dir: function (prop, method) {
	      if (prop == "asc" || !prop) return method;
	      return function (a, b) {
	        return method(a, b) * -1;
	      };
	    }
	  }
	};

	/*
		Behavior:DataLoader - load data in the component
		
		@export
			load
			parse
	*/

	var DataLoader = exports.proto({
	  $init: function (config) {
	    //prepare data store
	    config = config || ""; //list of all active ajax requests

	    this._ajax_queue = toArray();
	    this._feed_last = {};
	    this.data = new DataStore();
	    this.data.attachEvent("onClearAll", bind(this._call_onclearall, this));
	    this.data.attachEvent("onServerConfig", bind(this._call_on_config, this));
	    this.attachEvent("onDestruct", this._call_onclearall);
	    this.data.feed = this._feed;
	    this.data.owner = config.id;
	  },
	  _feed: function (from, count, callback) {
	    //allow only single request at same time
	    if (this._load_count) return this._load_count = [from, count, callback]; //save last ignored request
	    else this._load_count = true;
	    this._feed_last.from = from;
	    this._feed_last.count = count;
	    return this._feed_common.call(this, from, count, callback);
	  },
	  _feed_common: function (from, count, callback, url, details) {
	    var _this = this;

	    var state = null;
	    url = url || this.data.url;
	    if (from < 0) from = 0;
	    if (!details) details = {
	      start: from,
	      count: count
	    };
	    if (this.count()) details["continue"] = "true";
	    if (this.getState) state = this.getState(); // proxy

	    if (url && typeof url != "string") {
	      if (state) {
	        if (state.sort) details.sort = state.sort;
	        if (state.filter) details.filter = state.filter;
	      }

	      return this.load(url, 0, details).then(function (data) {
	        _this._feed_callback();

	        if (callback) ajax.$callback(_this, callback, data);
	        return data;
	      });
	    } else {
	      // GET
	      url = url + (url.indexOf("?") == -1 ? "?" : "&");
	      var params = [];

	      for (var d in details) {
	        params.push(d + "=" + details[d]);
	      }

	      if (state) {
	        if (state.sort) params.push("sort[" + state.sort.id + "]=" + encodeURIComponent(state.sort.dir));
	        if (state.filter) for (var key in state.filter) {
	          var filterValue = state.filter[key];
	          if (_typeof(filterValue) == "object") filterValue = ajax().stringify(filterValue); //server daterangefilter

	          params.push("filter[" + key + "]=" + encodeURIComponent(filterValue));
	        }
	      }

	      url += params.join("&");

	      if (this._feed_last.url !== url) {
	        this._feed_last.url = url;
	        return this.load(url).then(function (data) {
	          _this._feed_callback();

	          if (callback) ajax.$callback(_this, callback, data);
	          return data;
	        });
	      } else {
	        this._load_count = false;
	      }
	    }
	  },
	  _feed_callback: function () {
	    //after loading check if we have some ignored requests
	    var temp = this._load_count;
	    this._load_count = false;
	    if (_typeof(temp) == "object") this.data.feed.apply(this, temp); //load last ignored request
	  },
	  //loads data from external URL
	  load: function (url) {
	    url = proxy$a.$parse(url);
	    var ajax$$1 = AtomDataLoader.load.apply(this, arguments); //prepare data feed for dyn. loading

	    if (!this.data.url) this.data.url = url;
	    return ajax$$1;
	  },
	  //load next set of data rows
	  loadNext: function (count, start, callback, url, now) {
	    var config = this._settings;

	    if (config.datathrottle && !now) {
	      if (this._throttle_request) window.clearTimeout(this._throttle_request);
	      this._throttle_request = delay(function () {
	        this.loadNext(count, start, callback, url, true);
	      }, this, 0, config.datathrottle);
	      return;
	    }

	    if (!start && start !== 0) start = this.count();
	    if (!count) count = config.datafetch || this.count();
	    this.data.url = this.data.url || url;
	    if (this.callEvent("onDataRequest", [start, count, callback, url]) && this.data.url) return this.data.feed.call(this, start, count, callback);
	  },
	  _maybe_loading_already: function (count, from) {
	    var last = this._feed_last;

	    if (this._load_count && last.url) {
	      if (last.from <= from && last.count + last.from >= count + from) return true;
	    }

	    return false;
	  },
	  removeMissed_setter: function (value) {
	    return this.data._removeMissed = value;
	  },
	  //init of dataprocessor delayed after all settings processing
	  //because it need to be the last in the event processing chain
	  //to get valid validation state
	  _init_dataprocessor: function () {
	    var url = this._settings.save;
	    if (url === true) url = this._settings.save = this._settings.url;
	    var obj = {
	      master: this
	    };
	    if (url && url.url) exports.extend(obj, url);else obj.url = url;
	    dp(obj);
	  },
	  save_setter: function (value) {
	    if (value) this.$ready.push(this._init_dataprocessor);
	    return value;
	  },
	  scheme_setter: function (value) {
	    this.data.scheme(value);
	  },
	  dataFeed_setter: function (value) {
	    value = proxy$a.$parse(value);
	    this.data.attachEvent("onBeforeFilter", bind(function (text, filtervalue) {
	      var _this2 = this;

	      //complex filtering, can't be routed to dataFeed
	      if (typeof text == "function") return true; //we have dataFeed and some text

	      if (this._settings.dataFeed && (text || filtervalue)) {
	        text = text || "id";
	        if (filtervalue && _typeof(filtervalue) == "object") filtervalue = filtervalue.id;
	        this.clearAll();
	        var url = this._settings.dataFeed; //url data feed

	        if (typeof url == "string") {
	          var urldata = "filter[" + text + "]=" + encodeURIComponent(filtervalue);
	          this.load(url + (url.indexOf("?") < 0 ? "?" : "&") + urldata, this._settings.datatype);
	        } //js data feed
	        else {
	            var filter = {};
	            filter[text] = filtervalue;

	            if (typeof url == "function") {
	              url.call(this, filtervalue, filter);
	            } else if (url.$proxy) {
	              if (url.load) {
	                url.load(this, {
	                  filter: filter
	                }).then(function (data) {
	                  _this2._onLoad(data);
	                }, function (x) {
	                  _this2._onLoadError(x);
	                });
	              }
	            }
	          }

	        return false;
	      }
	    }, this));
	    return value;
	  },
	  _call_onready: function () {
	    if (this._settings.ready && !this._ready_was_used) {
	      var code = toFunctor(this._settings.ready, this.$scope);
	      if (code) delay(code, this, arguments);
	      if (this.callEvent) delay(this.callEvent, this, ["onReady", []]);
	      this._ready_was_used = true;
	    }
	  },
	  _call_onclearall: function (soft) {
	    for (var i = 0; i < this._ajax_queue.length; i++) {
	      var xhr = this._ajax_queue[i]; //IE9 and IE8 deny extending of ActiveX wrappers

	      try {
	        xhr.aborted = true;
	      } catch (e) {
	        _xhr_aborted.push(xhr);
	      }

	      xhr.abort();
	    }

	    if (!soft) {
	      this._load_count = false;
	      this._feed_last = {};
	      this._ajax_queue = toArray();
	      this.waitData = Deferred.defer();
	    }
	  },
	  _call_on_config: function (config) {
	    this._parseSeetingColl(config);
	  }
	}, AtomDataLoader);

	var DataState = {
	  getState: function () {
	    var cols_n = this.config.columns.length;
	    var columns = this.config.columns;
	    var settings = {
	      ids: [],
	      size: [],
	      select: this.getSelectedId(true),
	      scroll: this.getScrollState()
	    };

	    for (var i = 0; i < cols_n; i++) {
	      var col = columns[i];
	      settings.ids.push(col.id);
	      settings.size.push(col.fillspace || col.adjust ? -1 : col.width);
	    }

	    settings.order = [].concat(this._hidden_column_order.length ? this._hidden_column_order : settings.ids);

	    if (this._last_sorted) {
	      settings.sort = {
	        id: this._last_sorted,
	        dir: this._last_order
	      };
	    } //this method will try to access the rendered values
	    //just ignore it if grid is not rendered yet


	    if (this._filter_elements && this._dtable_fully_ready) {
	      var filter = {};
	      var any_filter = 0;

	      for (var key in this._filter_elements) {
	        if (this._hidden_column_hash[key]) continue;
	        var f = this._filter_elements[key];
	        f[1].value = filter[key] = f[2].getValue(f[0]);
	        any_filter = 1;
	      }

	      if (any_filter) settings.filter = filter;
	    }

	    settings.hidden = [];

	    for (var _key in this._hidden_column_hash) {
	      settings.hidden.push(_key);
	    }

	    return settings;
	  },
	  setState: function (obj) {
	    var columns = this.config.columns;
	    if (!obj) return;
	    this._last_sorted = null;
	    this.blockEvent();

	    if (obj.order && obj.order.length) {
	      this._hidden_column_order = [].concat(obj.order);
	      this._hidden_split = [this._settings.leftSplit, obj.order.length - this._settings.rightSplit];
	    }

	    if (obj.hidden) {
	      var hihash = {};

	      for (var i = 0; i < obj.hidden.length; i++) {
	        hihash[obj.hidden[i]] = true;
	        if (!this._hidden_column_order.length) this.hideColumn(obj.hidden[i]);
	      }

	      if (this._hidden_column_order.length) {
	        for (var _i = 0; _i < this._hidden_column_order.length; _i++) {
	          var hikey = this._hidden_column_order[_i];
	          if (!!hihash[hikey] == !this._hidden_column_hash[hikey]) this.hideColumn(hikey, {}, false, !!hihash[hikey]);
	        }
	      }
	    }

	    if (obj.ids) {
	      var reorder = false;
	      var cols = this.config.columns;

	      for (var _i2 = 0; _i2 < cols.length; _i2++) {
	        if (cols[_i2].id != obj.ids[_i2]) reorder = true;
	      }

	      if (reorder) {
	        for (var _i3 = 0; _i3 < obj.ids.length; _i3++) {
	          cols[_i3] = this.getColumnConfig(obj.ids[_i3]) || cols[_i3];
	        }

	        this.refreshColumns();
	      }
	    }

	    if (obj.size) {
	      var cols_n = Math.min(obj.size.length, columns.length);

	      for (var _i4 = 0; _i4 < cols_n; _i4++) {
	        var col = columns[_i4];

	        if (col && obj.size[_i4] > 0 && col.width != obj.size[_i4]) {
	          delete col.fillspace;
	          delete col.adjust;

	          this._setColumnWidth(_i4, obj.size[_i4], true);
	        }
	      }
	    }

	    this.unblockEvent();
	    var silent = !(this._settings.leftSplit || this._settings.rightSplit);

	    this._updateColsSizeSettings(silent);

	    this.callEvent("onStructureUpdate", []);

	    if (obj.sort) {
	      var column = columns[this.getColumnIndex(obj.sort.id)];
	      if (column) this._sort(obj.sort.id, obj.sort.dir, column.sort);
	    }

	    if (obj.filter) {
	      //temporary disable filtering 
	      var temp = this.filterByAll;

	      this.filterByAll = function () {}; //apply defined filters


	      for (var key in obj.filter) {
	        var value = obj.filter[key];
	        if (!value) continue;
	        if (!this._filter_elements[key]) continue;
	        var f = this._filter_elements[key];
	        f[2].setValue(f[0], value);
	        var contentid = f[1].contentId;
	        if (contentid) this._active_headers[contentid].value = value;
	      } //remove old filters


	      for (var _key2 in this._filter_elements) {
	        if (!obj.filter[_key2]) {
	          var _f = this._filter_elements[_key2];

	          _f[2].setValue(_f[0], "");
	        }
	      } //restore and apply filtering


	      this.filterByAll = temp;
	      this.filterByAll();
	    }

	    if (obj.select && this.select) {
	      var select = obj.select;
	      this.unselect();

	      for (var _i5 = 0; _i5 < select.length; _i5++) {
	        if (!select[_i5].row || this.exists(select[_i5].row)) this._select(select[_i5], true);
	      }
	    }

	    if (obj.scroll) this.scrollTo(obj.scroll.x, obj.scroll.y);
	  }
	};

	/*
		Behavior:DragItem - adds ability to move items by dnd
		
		dnd context can have next properties
			from - source object
			to - target object
			source - id of dragged item(s)
			target - id of drop target, null for drop on empty space
			start - id from which DND was started
	*/

	var DragItem = {
	  //helper - defines component's container as active zone for dragging and for dropping
	  _initHandlers: function (obj, source, target) {
	    if (!source) DragControl.addDrop(obj._contentobj, obj, true);
	    if (!target) DragControl.addDrag(obj._contentobj, obj);
	    this.attachEvent("onDragOut", function (a, b) {
	      this.$dragMark(a, b);
	    });
	    this.attachEvent("onBeforeAutoScroll", function () {
	      var context = DragControl.getContext();
	      return !!(DragControl._active && context && (context.to === this || this._auto_scroll_force));
	    });
	  },
	  drag_setter: function (value) {
	    if (value) {
	      exports.extend(this, AutoScroll, true);
	      if (value == "order" || value == "move") exports.extend(this, use("DragOrder"), true);
	      if (value == "inner" || value == "order") this._inner_drag_only = true;

	      this._initHandlers(this, value == "source", value == "target");

	      delete this.drag_setter; //prevent double initialization
	    }

	    return value;
	  },

	  /*
	  	s - source html element
	  	t - target html element
	  	d - drop-on html element ( can be not equal to the target )
	  	e - native html event 
	  */
	  //called when drag moved over possible target
	  $dragIn: function (s, t, e) {
	    var id = this.locate(e) || null;
	    var context = DragControl._drag_context; //in inner drag mode - ignore dnd from other components

	    if ((this._inner_drag_only || context.from._inner_drag_only) && context.from !== this) return false;
	    var to = DragControl.getMaster(t); //previous target

	    var html = this.getItemNode(id, e) || this._dataobj; //prevent double processing of same target


	    if (html == DragControl._landing) return html;
	    context.target = id;
	    context.to = to;
	    if (this._auto_scroll_delay) this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	    this._auto_scroll_delay = delay(function (pos$$1, id) {
	      this._drag_pause(id);

	      this._auto_scroll(pos$$1, id);
	    }, this, [pos(e), id], 250);

	    if (!this.$dropAllow(context, e) || !this.callEvent("onBeforeDragIn", [context, e])) {
	      context.to = context.target = null;
	      if (this._auto_scroll_delay) this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	      return null;
	    } //mark target only when landing confirmed


	    this.$dragMark(context, e);
	    return html;
	  },
	  $dropAllow: function () {
	    return true;
	  },
	  _drag_pause: function () {//may be reimplemented in some components
	    // tree for example
	  },
	  _target_to_id: function (target) {
	    return target && _typeof(target) === "object" ? target.toString() : target;
	  },
	  //called when drag moved out from possible target
	  $dragOut: function (s, t, n, e) {
	    var id = (this._viewobj.contains(n) ? this.locate(e) : null) || null;
	    var context = DragControl._drag_context; //still over previous target

	    if ((context.target || "").toString() == (id || "").toString()) return null;

	    if (this._auto_scroll_delay) {
	      this._auto_scroll_force = null;
	      this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	    } //unmark previous target


	    context.target = context.to = null;
	    this.callEvent("onDragOut", [context, e]);
	    return null;
	  },
	  //called when drag moved on target and button is released
	  $drop: function (s, t, e) {
	    if (this._auto_scroll_delay) this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	    var context = DragControl._drag_context; //finalize context details

	    context.to = this;

	    this._define_index(s, t, context); //unmark last target


	    this.$dragMark({}, e);

	    if (context.from && context.from != context.to && context.from.callEvent) {
	      context.from.callEvent("onBeforeDropOut", [context, e]);
	    }

	    if (!this.callEvent("onBeforeDrop", [context, e])) return; //moving

	    this._context_to_move(context, e);

	    this.callEvent("onAfterDrop", [context, e]);
	  },
	  _define_index: function (s, t, context) {
	    var target = this._target_to_id(context.target);

	    if (this.getBranchIndex) {
	      if (target) {
	        context.parent = this.getParentId(target);
	        context.index = this.getBranchIndex(target);
	      } else context.index = -1;
	    } else context.index = target ? this.getIndexById(target) : this.count();
	  },
	  _context_to_move: function (context) {
	    assert(context.from, "Unsopported d-n-d combination");

	    if (context.from && context.from.move) {
	      //from different component with item dnd
	      var details = {
	        parent: context.parent,
	        mode: context.pos
	      };
	      context.from.move(context.source, context.index, context.to, details);
	    }
	  },
	  _getDragItemPos: function (pos$$1, e) {
	    if (this.getItemNode) {
	      var id = this.locate(e, true); //in some case, node may be outiside of dom ( spans in datatable for example )
	      //so getItemNode can return null

	      var node = id ? this.getItemNode(id) : null;
	      return node ? offset(node) : node;
	    }
	  },
	  //called when drag action started
	  $drag: function (s, e) {
	    var id = this.locate(e, true);

	    if (id) {
	      var list = [id];

	      if (this.getSelectedId) {
	        //has selection model
	        //if dragged item is one of selected - drag all selected
	        var selection = this.getSelectedId(true, true);

	        if (selection && selection.length > 1 && PowerArray.find.call(selection, id) != -1) {
	          var hash = {};
	          list = [];

	          for (var i = 0; i < selection.length; i++) {
	            hash[selection[i]] = true;
	          }

	          for (var _i = 0; _i < this.data.order.length; _i++) {
	            var hash_id = this.data.order[_i];
	            if (hash[hash_id]) list.push(hash_id);
	          }
	        }
	      } //save initial dnd params


	      var context = DragControl._drag_context = {
	        source: list,
	        start: id
	      };
	      context.fragile = this.addRowCss && env.touch && (env.isWebKit || env.isFF);
	      context.from = this;

	      if (this.callEvent("onBeforeDrag", [context, e])) {
	        if (Touch) Touch._start_context = null; //set drag representation

	        return context.html || this.$dragHTML(this.getItem(id), e, context);
	      }
	    }

	    return null;
	  },
	  $dragHTML: function (obj, e, context) {
	    var html = this._toHTML(obj);

	    if (isArray(context.source) && context.source.length > 1) html = this._toMultipleHTML(html, context.source.length);
	    return html;
	  },
	  _toMultipleHTML: function (html, len) {
	    html = "<div class='webix_drag_main'>" + html + "</div>";
	    var multiple = "<div class='webix_drag_multiple'></div>";
	    if (len > 2) multiple = "<div class='webix_drag_multiple_last'></div>" + multiple;
	    return multiple + html + "<span class='webix_badge'>" + len + "</span>";
	  },
	  $dragMark: function (context) {
	    var target = null;
	    if (context.target) target = this._target_to_id(context.target); //touch webkit will stop touchmove event if source node removed
	    //datatable can't repaint rows without repainting

	    if (this._marked && this._marked != target) {
	      if (!context.fragile) this.removeCss(this._marked, "webix_drag_over");
	      this._marked = null;
	    }

	    if (!this._marked && target) {
	      this._marked = target;
	      if (!context.fragile) this.addCss(target, "webix_drag_over");
	      return target;
	    }

	    if (context.to) {
	      return true;
	    } else return false;
	  },
	  // methods used in order/move modes
	  $dropHTML: function () {
	    return "";
	  },
	  _set_drop_area: function (target, t) {
	    var node = this.getItemNode(target);

	    if (node) {
	      node.parentNode.insertBefore(DragControl._dropHTML[0], node);
	    } else t.children[0].appendChild(DragControl._dropHTML[0]);
	  }
	};

	var DragOrder = {
	  $drag: function (s, e) {
	    var html = DragItem.$drag.apply(this, arguments);
	    if (!html) return html;
	    var context = DragControl._drag_context;
	    if (this._close_branches) this._close_branches(context);
	    if (this._inner_drag_only && this.getBranchIndex) this._drag_order_stored_left = this._drag_order_complex ? (this.getItem(context.start).$level + 1) * 20 + 8 : 0;

	    if (isArray(context.source) && !context.fragile) {
	      DragControl._setDragOffset(e);

	      this._add_css(context.source);
	    }

	    return html;
	  },
	  _add_css: function (source) {
	    for (var i = 0; i < source.length; i++) {
	      this.addCss(source[i], "webix_invisible");
	    }
	  },
	  _remove_css: function (source) {
	    for (var i = 0; i < source.length; i++) {
	      this.removeCss(source[i], "webix_invisible");
	    }
	  },
	  $dragIn: function (s, t, e) {
	    var html = DragItem.$dragIn.apply(this, arguments);
	    if (!html) return html;
	    if (!DragControl._dropHTML) DragControl._dropHTML = this._init_drop_area();
	    var context = DragControl._drag_context;
	    var target = "$webix-last";
	    if (context.target) target = this._target_to_id(context.target);

	    if (target != "$webix-last" && target != "$webix-drop") {
	      var settings = {
	        direction: this._settings.layout || this._drag_direction || "y",
	        x: "width",
	        y: "height"
	      };
	      var ofs = offset(html);
	      var direction = pos(e)[settings.direction] - ofs[settings.direction];
	      if (direction * 2 > ofs[settings[settings.direction]]) target = this.getNextId(target) || "$webix-last";
	    }

	    if (target == this._marked_item_id || target == "$webix-drop") return html;
	    this._marked_item_id = target;

	    this._set_drop_area(target, t);

	    return html;
	  },
	  $dragPos: function (pos$$1) {
	    if (!this._inner_drag_only) {
	      var context = DragControl._drag_context;
	      pos$$1.y += context.y_offset;
	      pos$$1.x += context.x_offset;
	      return;
	    }

	    var box = offset(this.$view);
	    var xdrag = this._settings.layout == "x";

	    if (xdrag) {
	      box.x -= 12;
	      pos$$1.y = box.y - 8;
	      pos$$1.x = pos$$1.x - 18;
	      if (pos$$1.x < box.x) pos$$1.x = box.x;else {
	        var max = box.x + box.width;
	        if (pos$$1.x > max) pos$$1.x = max;
	      }
	    } else {
	      box.y += (this._header_height || 0) - 12;
	      pos$$1.x = (this._drag_order_stored_left || box.x) + 8;
	      pos$$1.y = pos$$1.y - 18;
	      if (pos$$1.y < box.y) pos$$1.y = box.y;else {
	        var _max = box.y + box.height - (this._header_height || 0);

	        if (pos$$1.y > _max) pos$$1.y = _max;
	      }
	    }
	  },
	  $dragOut: function (s, ot, nt) {
	    if (ot != nt) {
	      remove(DragControl._dropHTML);
	      this._marked_item_id = DragControl._dropHTML = null;
	    }

	    return DragItem.$dragOut.apply(this, arguments);
	  },
	  _define_index: function (s, t, context) {
	    var target = this._marked_item_id == "$webix-last" ? null : this._marked_item_id;

	    if (this.getBranchIndex) {
	      if (target) {
	        context.parent = this.getParentId(target);
	        context.index = this.getBranchIndex(target);
	        if (s == t && this.getParentId(context.start) == context.parent && this.getBranchIndex(context.start) < context.index) context.index -= 1;
	      } else context.index = -1;
	    } else {
	      context.index = target ? this.getIndexById(target) : this.count();
	      context.index -= s == t && this.getIndexById(context.start) < context.index ? 1 : 0;
	    }
	  },
	  $dragDestroy: function () {
	    var context = DragControl._drag_context;
	    if (isArray(context.source) && !context.fragile) this._remove_css(context.source);
	    remove(DragControl._html);
	  },
	  _init_drop_area: function () {
	    var node = document.createElement("div");
	    node.className = "webix_drop_area";
	    node.style.width = this.type.width + "px";
	    node.style.height = this.type.height + "px";
	    node.innerHTML = this.$dropHTML();
	    node.setAttribute(this._id, "$webix-drop");
	    return [node];
	  },
	  $dragMark: function () {
	    return false;
	  }
	};
	define("DragOrder", DragOrder);

	var Undo = {
	  $init: function () {
	    this._undoHistory = exports.extend([], PowerArray, true);
	    this._undoCursor = -1;
	  },
	  undo_setter: function (value) {
	    if (value) {
	      this._init_undo();

	      this._init_undo = function () {};
	    }

	    return value;
	  },
	  _init_undo: function () {
	    var view = this; // drag-n-drop

	    this.attachEvent("onBeforeDrop", function (context) {
	      if (context.from == context.to) {
	        var item = view._draggedItem = copy(this.getItem(context.start));

	        if (this.data.branch) {
	          item.$index = this.getBranchIndex(item.id);
	        } else item.$index = this.getIndexById(item.id);
	      }
	    });
	    this.data.attachEvent("onDataMove", function (sid) {
	      if (view._draggedItem && view._draggedItem.id == sid) {
	        var data = view._draggedItem;
	        view._draggedItem = null;

	        view._addToHistory(sid, data, "move");
	      }
	    }); // add, remove

	    this.data.attachEvent("onBeforeDelete", function (id) {
	      if (this.getItem(id)) {
	        var item = view._deletedItem = copy(this.getItem(id));

	        if (this.branch) {
	          item.$index = this.getBranchIndex(id);
	          if (this.branch[id]) item.$branch = copy(this.serialize(id));
	        } else item.$index = this.getIndexById(id);
	      }
	    });
	    this.data.attachEvent("onDataUpdate", function (id, data, old) {
	      view._addToHistory(id + "", old, "update");
	    });
	    this.data.attachEvent("onStoreUpdated", function (id, item, mode) {
	      var data = null;

	      if (id) {
	        if (mode == "add") {
	          data = copy(item);
	        } else if (mode == "delete") {
	          data = view._deletedItem;
	        }

	        if (data) view._addToHistory(id, data, mode);
	      }
	    }); // id change

	    this.data.attachEvent("onIdChange", function (oldId, newId) {
	      if (_typeof(oldId) == "object") oldId = oldId.row;

	      for (var i = 0; i < view._undoHistory.length; i++) {
	        if (view._undoHistory[i].id == oldId) {
	          view._undoHistory[i].id = newId;
	        }
	      }
	    });
	  },
	  _addToHistory: function (id, data, action) {
	    if (!this._skipHistory && this._settings.undo) {
	      this._undoHistory.push({
	        id: id,
	        action: action,
	        data: data
	      });

	      if (this._undoHistory.length == 20) this._undoHistory.splice(0, 1);
	      if (!this._skipCursorInc) this._undoCursor = this._undoHistory.length - 1;
	    }
	  },
	  ignoreUndo: function (func, master) {
	    this._skipHistory = true;
	    func.call(master || this);
	    this._skipHistory = false;
	  },
	  removeUndo: function (id) {
	    for (var i = this._undoHistory.length - 1; i >= 0; i--) {
	      if (this._undoHistory[i].id == id) {
	        if (this._undoHistory[i].action == "id") {
	          id = this._undoHistory[i].data;
	        }

	        this._undoHistory.removeAt(i);
	      }
	    }

	    this._undoCursor = this._undoHistory.length - 1;
	  },
	  undo: function (id) {
	    if (id) {
	      this.ignoreUndo(function () {
	        var data, i;

	        for (i = this._undoHistory.length - 1; !data && i >= 0; i--) {
	          if (this._undoHistory[i].id == id) data = this._undoHistory[i];
	        }

	        if (data) {
	          /*if(data.action == "id")
	          	id = data.data;*/
	          this._undoAction(data);

	          this._undoHistory.removeAt(i + 1);

	          this._undoCursor = this._undoHistory.length - 1;
	        }
	      });
	    } else {
	      var data = this._undoHistory[this._undoCursor];

	      if (data) {
	        this.ignoreUndo(function () {
	          this._undoAction(data);

	          this._undoHistory.removeAt(this._undoCursor);
	        });
	        this._undoCursor--;
	        /*if(data.action == "id")
	        	this.undo();*/
	      }
	    }
	  },
	  _undoAction: function (obj) {
	    if (obj.action == "delete") {
	      var branch = null,
	          parentId = obj.data.$parent;

	      if (obj.data.$branch) {
	        branch = {
	          parent: obj.id,
	          data: copy(obj.data.$branch)
	        };
	        delete obj.data.$branch;
	        if (parentId && !this.data.branch[parentId]) parentId = 0;
	      }

	      this.add(obj.data, obj.data.$index, parentId);

	      if (branch) {
	        this.parse(branch);
	      }
	    } else if (obj.action == "add") {
	      this.remove(obj.id);
	    } else if (obj.action == "update") {
	      this.updateItem(obj.id, obj.data);
	    } else if (obj.action == "move") {
	      if (obj.data.$parent) {
	        if (this.getItem(obj.data.$parent)) this.move(obj.id, obj.data.$index, null, {
	          parent: obj.data.$parent
	        });
	      } else this.move(obj.id, obj.data.$index);
	    }
	    /*else if(obj.action == "id"){
	    	this.data.changeId(obj.id, obj.data);
	    }*/

	  }
	};

	function init_suggest(editor, input) {
	  var suggest = editor.config.suggest;

	  if (suggest) {
	    var box = editor.config.suggest = create_suggest(suggest);
	    var boxobj = $$(box);
	    if (boxobj && input) boxobj.linkInput(input);
	  }
	}

	function create_suggest(config) {
	  if (typeof config == "string") return config;
	  if (config.linkInput) return config._settings.id;

	  if (_typeof(config) == "object") {
	    if (isArray(config)) config = {
	      data: config
	    };
	    config.view = config.view || "suggest";
	  } else if (config === true) config = {
	    view: "suggest"
	  };

	  var obj = ui(config);
	  return obj.config.id;
	}

	function getLabel(config) {
	  var text = config.header && config.header[0] ? config.header[0].text : config.editValue || config.label;
	  return (text || "").toString().replace(/<[^>]*>/g, "");
	}
	/*
	this.node - html node, available after render call
	this.config - editor config
	this.value - original value
	this.popup - id of popup 
	*/


	var editors = {
	  "text": {
	    focus: function () {
	      this.getInputNode(this.node).focus();
	      this.getInputNode(this.node).select();
	    },
	    getValue: function () {
	      return this.getInputNode(this.node).value;
	    },
	    setValue: function (value) {
	      var input = this.getInputNode(this.node);
	      input.value = value;
	      init_suggest(this, input);
	    },
	    getInputNode: function () {
	      return this.node.firstChild;
	    },
	    render: function () {
	      return create("div", {
	        "class": "webix_dt_editor"
	      }, "<input type='text' aria-label='" + getLabel(this.config) + "'>");
	    }
	  },
	  "inline-checkbox": {
	    render: function () {
	      return {};
	    },
	    getValue: function () {
	      return this.node.checked;
	    },
	    setValue: function () {},
	    focus: function () {
	      this.node.focus();
	    },
	    getInputNode: function () {},
	    $inline: true
	  },
	  "inline-text": {
	    render: function () {
	      return {};
	    },
	    getValue: function () {
	      return this.node.value;
	    },
	    setValue: function () {},
	    focus: function () {
	      try {
	        //IE9
	        this.node.select();
	        this.node.focus();
	      } catch (e) {} //eslint-disable-line

	    },
	    getInputNode: function () {},
	    $inline: true
	  },
	  "checkbox": {
	    focus: function () {
	      this.getInputNode().focus();
	    },
	    getValue: function () {
	      return this.getInputNode().checked;
	    },
	    setValue: function (value) {
	      this.getInputNode().checked = !!value;
	    },
	    getInputNode: function () {
	      return this.node.firstChild.firstChild;
	    },
	    render: function () {
	      return create("div", {
	        "class": "webix_dt_editor"
	      }, "<div><input type='checkbox' aria-label='" + getLabel(this.config) + "'></div>");
	    }
	  },
	  "select": {
	    focus: function () {
	      this.getInputNode().focus();
	    },
	    getValue: function () {
	      return this.getInputNode().value;
	    },
	    setValue: function (value) {
	      this.getInputNode().value = value;
	    },
	    getInputNode: function () {
	      return this.node.firstChild;
	    },
	    render: function () {
	      var html = "";
	      var options = this.config.options || this.config.collection;
	      assert(options, "options not defined for select editor");
	      if (options.data && options.data.each) options.data.each(function (obj) {
	        html += "<option value='" + obj.id + "'>" + obj.value + "</option>";
	      });else {
	        if (isArray(options)) {
	          for (var i = 0; i < options.length; i++) {
	            var rec = options[i];
	            var isplain = isUndefined(rec.id);
	            var id = isplain ? rec : rec.id;
	            var label = isplain ? rec : rec.value;
	            html += "<option value='" + id + "'>" + label + "</option>";
	          }
	        } else for (var key in options) {
	          html += "<option value='" + key + "'>" + options[key] + "</option>";
	        }
	      }
	      return create("div", {
	        "class": "webix_dt_editor"
	      }, "<select aria-label='" + getLabel(this.config) + "'>" + html + "</select>");
	    }
	  },
	  popup: {
	    focus: function () {
	      this.getInputNode().focus();
	    },
	    destroy: function () {
	      this.getPopup().hide();
	    },
	    getValue: function () {
	      return this.getInputNode().getValue() || "";
	    },
	    setValue: function (value) {
	      this.getPopup().show(this.node);
	      this.getInputNode().setValue(value);
	    },
	    getInputNode: function () {
	      return this.getPopup().getChildViews()[0];
	    },
	    getPopup: function () {
	      if (!this.config.$popup) this.config.$popup = this.createPopup();
	      return $$(this.config.$popup);
	    },
	    createPopup: function () {
	      var popup = this.config.popup || this.config.suggest;

	      if (popup) {
	        var pobj;

	        if (_typeof(popup) == "object" && !popup.name) {
	          popup.view = popup.view || "suggest";
	          pobj = ui(copy(popup));
	        } else pobj = $$(popup); //custom popup may be linked already


	        if (!pobj._linked) {
	          if (pobj.linkInput) pobj.linkInput(document.body);else if (this.linkInput) this.linkInput(document.body);
	          pobj._linked = true;
	        }

	        return pobj;
	      }

	      var type = editors.$popup[this.popupType];

	      if (typeof type != "string" && !type.name) {
	        type = editors.$popup[this.popupType] = ui(type);
	        this.popupInit(type);
	        if (!type.linkInput) this.linkInput(document.body);
	      }

	      return type._settings.id;
	    },
	    linkInput: function (node) {
	      _event(toNode(node), "keydown", bind(function (e) {
	        //abort, when editor was not initialized yet
	        if (!this.config.$popup) return;
	        var code = e.which || e.keyCode,
	            list = this.getInputNode();
	        if (!list.isVisible()) return;

	        if (list.moveSelection && code < 41 && code > 32) {
	          var dir;
	          if (code == 33) dir = "pgup";
	          if (code == 34) dir = "pgdown";
	          if (code == 35) dir = "bottom";
	          if (code == 36) dir = "top";
	          if (code == 37) dir = "left";
	          if (code == 38) dir = "up";
	          if (code == 39) dir = "right";
	          if (code == 40) dir = "down";
	          list.moveSelection(dir);
	        } // shift+enter support for 'popup' editor
	        else if (code === 13 && (e.target.nodeName !== "TEXTAREA" || !e.shiftKey)) callEvent("onEditEnd", []);
	      }, this));
	    },
	    popupInit: function () {},
	    popupType: "text",
	    render: function () {
	      return {};
	    },
	    $inline: true
	  }
	};
	editors.color = exports.extend({
	  focus: function () {},
	  popupType: "color",
	  popupInit: function (popup) {
	    popup.getChildViews()[0].attachEvent("onItemClick", function (value) {
	      callEvent("onEditEnd", [value]);
	    });
	  }
	}, editors.popup);
	editors.date = exports.extend({
	  focus: function () {},
	  popupType: "date",
	  setValue: function (value) {
	    this._is_string = this.config.stringResult || value && typeof value == "string";
	    editors.popup.setValue.call(this, value);
	  },
	  getValue: function () {
	    return this.getInputNode().getValue(this._is_string ? i18n.parseFormatStr : "") || "";
	  },
	  popupInit: function (popup) {
	    popup.getChildViews()[0].attachEvent("onDateSelect", function (value) {
	      callEvent("onEditEnd", [value]);
	    });
	  }
	}, editors.popup);
	editors.combo = exports.extend({
	  _create_suggest: function (config) {
	    if (this.config.popup) {
	      return this.config.popup.config.id;
	    } else if (config) {
	      return create_suggest(config);
	    } else return this._shared_suggest(config);
	  },
	  _shared_suggest: function () {
	    var e = editors.combo;
	    return e._suggest = e._suggest || this._create_suggest(true);
	  },
	  render: function () {
	    var node = create("div", {
	      "class": "webix_dt_editor"
	    }, "<input type='text' role='combobox' aria-label='" + getLabel(this.config) + "'>"); //save suggest id for future reference		

	    var suggest = this.config.suggest = this._create_suggest(this.config.suggest);

	    if (suggest) {
	      $$(suggest).linkInput(node.firstChild, true);

	      _event(node.firstChild, "click", bind(this.showPopup, this));
	    }

	    return node;
	  },
	  getPopup: function () {
	    return $$(this.config.suggest);
	  },
	  showPopup: function () {
	    var popup = this.getPopup();
	    var list = popup.getList();
	    var input = this.getInputNode();
	    var value = this._initial_value;
	    popup.show(input);
	    input.setAttribute("aria-expanded", "true");

	    if (value) {
	      assert(list.exists(value), "Option with ID " + value + " doesn't exist");

	      if (list.exists(value)) {
	        list.select(value);
	        list.showItem(value);
	      }
	    } else {
	      list.unselect();
	      list.showItem(list.getFirstId());
	    }

	    popup._last_input_target = input;
	  },
	  afterRender: function () {
	    this.showPopup();
	  },
	  setValue: function (value) {
	    this._initial_value = value;

	    if (this.config.suggest) {
	      var sobj = $$(this.config.suggest);
	      var data = this.config.collection || this.config.options;
	      if (data) sobj.getList().data.importData(data);
	      this.getInputNode(this.node).value = sobj.getItemText(value);
	    }
	  },
	  getValue: function () {
	    var value = this.getInputNode().value;

	    if (this.config.suggest) {
	      var suggest = $$(this.config.suggest),
	          list = suggest.getList();
	      if (value || list.getSelectedId && list.getSelectedId()) value = suggest.getSuggestion(value);
	    }

	    return value;
	  }
	}, editors.text);
	editors.richselect = exports.extend({
	  focus: function () {},
	  getValue: function () {
	    return this.getPopup().getValue();
	  },
	  setValue: function (value) {
	    var suggest = this.config.collection || this.config.options;
	    this.getInputNode();
	    if (suggest) this.getPopup().getList().data.importData(suggest);
	    this.getPopup().show(this.node);
	    this.getPopup().setValue(value);
	  },
	  getInputNode: function () {
	    return this.getPopup().getList();
	  },
	  popupInit: function (popup) {
	    popup.linkInput(document.body);
	  },
	  popupType: "richselect"
	}, editors.popup);
	editors.password = exports.extend({
	  render: function () {
	    return create("div", {
	      "class": "webix_dt_editor"
	    }, "<input type='password' aria-label='" + getLabel(this.config) + "'>");
	  }
	}, editors.text);
	editors.$popup = {
	  text: {
	    view: "popup",
	    width: 250,
	    height: 150,
	    body: {
	      view: "textarea"
	    }
	  },
	  color: {
	    view: "popup",
	    body: {
	      view: "colorboard"
	    }
	  },
	  date: {
	    view: "popup",
	    width: 250,
	    height: 250,
	    padding: 0,
	    body: {
	      view: "calendar",
	      icons: true,
	      borderless: true
	    }
	  },
	  richselect: {
	    view: "suggest",
	    body: {
	      view: "list",
	      select: true
	    }
	  },
	  multiselect: {
	    view: "multisuggest",
	    suggest: {
	      button: true
	    }
	  }
	};

	/*
		Behavior:EditAbility - enables item operation for the items
		
		@export
			edit
			stopEdit
	*/

	var EditAbility = {
	  defaults: {
	    editaction: "click"
	  },
	  $init: function (config) {
	    this._editors = {};
	    this._in_edit_mode = 0;
	    this._edit_open_time = 0;
	    this._contentobj.style.position = "relative";
	    if (config) config.onDblClick = config.onDblClick || {};
	    this.attachEvent("onAfterRender", this._refocus_inline_editor); //when we call extend the editable prop can be already set

	    if (this._settings.editable) this._init_edit_events_once();
	    exports.extend(this, Undo);
	  },
	  _refocus_try: function (newnode) {
	    try {
	      //Chrome throws an error if selectionStart is not accessible
	      if (typeof newnode.selectionStart == "number") {
	        newnode.selectionStart = newnode.selectionEnd = newnode.value.length;
	      } else if (typeof newnode.createTextRange != "undefined") {
	        var range = newnode.createTextRange();
	        range.collapse(false);
	        range.select();
	      }
	    } catch (e) {} // eslint-disable-line

	  },
	  _refocus_inline_editor: function () {
	    var editor = this.getEditor();

	    if (editor && editor.$inline && !editor.getPopup) {
	      var newnode = this._locateInput(editor);

	      if (newnode && newnode != editor.node) {
	        var text = editor.node.value;
	        editor.node = newnode;
	        newnode.value = text;
	        newnode.focus();

	        this._refocus_try(newnode);
	      } else this.editStop();
	    }
	  },
	  editable_setter: function (value) {
	    if (value) this._init_edit_events_once();
	    return value;
	  },
	  _init_edit_events_once: function () {
	    //will close editor on any click outside
	    attachEvent("onEditEnd", bind(function () {
	      if (this._in_edit_mode) this.editStop();
	    }, this));
	    attachEvent("onClick", bind(function (e) {
	      //but ignore click which opens editor
	      if (this._in_edit_mode && new Date() - this._edit_open_time > 200) {
	        if (!this._last_editor || this._last_editor.popupType || !e || !this._last_editor.node || !this._last_editor.node.contains(e.target || e.srcElement)) this.editStop();
	      }
	    }, this)); //property sheet has simple data object, without events

	    if (this.data.attachEvent) this.data.attachEvent("onIdChange", bind(function (oldid, newid) {
	      this._changeEditorId(oldid, newid);
	    }, this)); //when clicking on row - will start editor

	    this.attachEvent("onItemClick", function (id) {
	      if (this._settings.editable && this._settings.editaction == "click") this.edit(id);
	    });
	    this.attachEvent("onItemDblClick", function (id) {
	      if (this._settings.editable && this._settings.editaction == "dblclick") this.edit(id);
	    }); //each time when we clicking on input, reset timer to prevent self-closing

	    this._reset_active_editor = bind(function () {
	      this._edit_open_time = new Date();
	    }, this);

	    this._init_edit_events_once = function () {};

	    if (this._component_specific_edit_init) this._component_specific_edit_init();
	  },
	  _handle_live_edits: function () {
	    delay(function () {
	      var editor = this.getEditor();

	      if (editor && editor.config.liveEdit) {
	        var state$$1 = {
	          value: editor.getValue(),
	          old: editor.value
	        };
	        if (state$$1.value == state$$1.old) return;
	        editor.value = state$$1.value;

	        this._set_new_value(editor, state$$1.value, false);

	        this.callEvent("onLiveEdit", [state$$1, editor]);
	      }
	    }, this);
	  },
	  _show_editor_form: function (id) {
	    var form = this._settings.form;
	    if (typeof form != "string") this._settings.form = form = ui(form).config.id;
	    form = $$(form);
	    var realform = form.setValues ? form : form.getChildViews()[0];
	    realform.setValues(this.getItem(id.row || id));
	    form.config.master = this.config.id;
	    form.show(this.getItemNode(id));
	    var first = realform.getChildViews()[0];
	    if (first.focus) first.focus();
	  },
	  edit: function (id, preserve, show) {
	    if (!this._settings.editable || !this.callEvent("onBeforeEditStart", [id])) return;
	    if (this._settings.form) return this._show_editor_form(id);

	    var editor = this._get_editor_type(id);

	    if (editor) {
	      if (this.getEditor(id)) return;
	      if (!preserve) this.editStop(); //render html input

	      assert(editors[editor], "Invalid editor type: " + editor);
	      var type = exports.extend({}, editors[editor]);

	      var node = this._init_editor(id, type, show);

	      if (type.config.liveEdit) this._live_edits_handler = this.attachEvent("onKeyPress", this._handle_live_edits);
	      var area = type.getPopup ? type.getPopup(node)._viewobj : node;
	      if (area) _event(area, "click", this._reset_active_editor);
	      if (node) _event(node, "change", this._on_editor_change, {
	        bind: {
	          view: this,
	          id: id
	        }
	      });
	      if (show !== false) type.focus();
	      if (this.$fixEditor) this.$fixEditor(type); //save time of creation to prevent instant closing from the same click

	      this._edit_open_time = state.edit_open_time = new Date();
	      UIManager.setFocus(this, true);
	      this.callEvent("onAfterEditStart", [id]);
	      return type;
	    }

	    return null;
	  },
	  getEditor: function (id) {
	    if (!id) return this._last_editor;
	    return this._editors[id];
	  },
	  _changeEditorId: function (oldid, newid) {
	    var editor = this._editors[oldid];

	    if (editor) {
	      this._editors[newid] = editor;
	      editor.id = newid;
	      delete this._editors[oldid];
	    }
	  },
	  _on_editor_change: function () {
	    if (this.view.hasEvent("onEditorChange")) this.view.callEvent("onEditorChange", [this.id, this.view.getEditorValue(this.id)]);
	  },
	  _get_edit_config: function () {
	    return this._settings;
	  },
	  _init_editor: function (id, type, show) {
	    type.config = this._get_edit_config(id);
	    var node = type.render();
	    if (type.$inline) node = this._locateInput(id);
	    type.node = node;
	    var item = this.getItem(id); //value can be configured by editValue option

	    var value = item[this._settings.editValue || "value"]; //if property was not defined - use empty value

	    if (isUndefined(value)) value = "";
	    type.setValue(value, item);
	    type.value = value;

	    this._addEditor(id, type); //show it over cell


	    if (show !== false) this.showItem(id);
	    if (!type.$inline) this._sizeToCell(id, node, true);
	    if (type.afterRender) type.afterRender();
	    return node;
	  },
	  _locate_cell: function (id) {
	    return this.getItemNode(id);
	  },
	  _locateInput: function (id) {
	    var cell = this._locate_cell(id);

	    if (cell) cell = cell.getElementsByTagName("input")[0] || cell;
	    return cell;
	  },
	  _get_editor_type: function () {
	    return this._settings.editor;
	  },
	  _addEditor: function (id, type) {
	    type.id = id;
	    this._editors[id] = this._last_editor = type;
	    this._in_edit_mode++;
	  },
	  _removeEditor: function (editor) {
	    if (this._last_editor == editor) this._last_editor = 0;
	    if (editor.destroy) editor.destroy();
	    delete editor.popup;
	    delete editor.node;
	    delete this._editors[editor.id];
	    this._in_edit_mode--;
	  },
	  focusEditor: function () {
	    var editor = this.getEditor.apply(this, arguments);
	    if (editor && editor.focus) editor.focus();
	  },
	  editCancel: function () {
	    this.editStop(null, null, true);
	  },
	  _applyChanges: function (el) {
	    if (el) {
	      var ed = this.getEditor();
	      if (ed && ed.getPopup && ed.getPopup() == el.getTopParentView()) return;
	    }

	    this.editStop();
	  },
	  editStop: function (id) {
	    if (this._edit_stop) return;
	    this._edit_stop = 1;
	    var cancel = arguments[2];
	    var result = 1;

	    if (!id) {
	      this._for_each_editor(function (editor) {
	        result = result * this._editStop(editor, cancel);
	      });
	    } else result = this._editStop(this._editors[id], cancel);

	    this._edit_stop = 0;
	    return result;
	  },
	  _cellPosition: function (id) {
	    var html = this.getItemNode(id);
	    return {
	      left: html.offsetLeft,
	      top: html.offsetTop,
	      height: html.offsetHeight,
	      width: html.offsetWidth,
	      parent: this._contentobj
	    };
	  },
	  _sizeToCell: function (id, node, inline) {
	    //fake inputs
	    if (!node.style) return;

	    var pos$$1 = this._cellPosition(id);

	    node.style.top = pos$$1.top + "px";
	    node.style.left = pos$$1.left + "px";
	    node.style.width = pos$$1.width - 1 + "px";
	    node.style.height = pos$$1.height - 1 + "px";
	    node.top = pos$$1.top; //later will be used during y-scrolling

	    if (inline) pos$$1.parent.appendChild(node);
	  },
	  _for_each_editor: function (handler) {
	    for (var editor in this._editors) {
	      handler.call(this, this._editors[editor]);
	    }
	  },
	  _editStop: function (editor, ignore) {
	    if (!editor || state._final_destruction) return;
	    var state$$1 = {
	      value: this._get_new_value(editor),
	      old: editor.value
	    };

	    if (this.callEvent("onBeforeEditStop", [state$$1, editor, ignore])) {
	      if (!ignore) {
	        //special case, state.old = 0, state.value = ""
	        //we need to state.old to string, to detect the change
	        var old = state$$1.old;
	        if (typeof state$$1.value == "string") old += "";

	        if (old != state$$1.value || editor.config.liveEdit) {
	          var item = this._set_new_value(editor, state$$1.value, true);

	          this.updateItem(editor.row || editor.id, item);
	        }
	      }

	      if (editor.$inline) editor.node = null;else remove(editor.node);
	      var popup = editor.config.suggest;
	      if (popup && typeof popup == "string") $$(popup).hide();

	      this._removeEditor(editor);

	      if (this._live_edits_handler) this.detachEvent(this._live_edits_handler);
	      this.callEvent("onAfterEditStop", [state$$1, editor, ignore]);
	      return 1;
	    }

	    return 0;
	  },
	  validateEditor: function (id) {
	    var result = true;

	    if (this._settings.rules) {
	      var editor = this.getEditor(id);
	      var key = editor.column || this._settings.editValue || "value";
	      var rule = this._settings.rules[key];
	      var all = this._settings.rules.$all;

	      if (rule || all) {
	        var obj = this.data.getItem(editor.row || editor.id);
	        var value = editor.getValue();
	        var input = editor.getInputNode();
	        if (rule) result = rule.call(this, value, obj, key);
	        if (all) result = all.call(this, value, obj, key) && result;
	        if (result) removeCss(input, "webix_invalid");else addCss(input, "webix_invalid");
	        callEvent("onLiveValidation", [editor, result, obj, value]);
	      }
	    }

	    return result;
	  },
	  getEditorValue: function (id) {
	    var editor;
	    if (arguments.length === 0) editor = this._last_editor;else editor = this.getEditor(id);
	    if (editor) return editor.getValue();
	  },
	  getEditState: function () {
	    return this._last_editor || false;
	  },
	  editNext: function (next, from) {
	    next = next !== false; //true by default

	    if (this._in_edit_mode == 1 || from) {
	      //only if one editor is active
	      var editor_next = this._find_cell_next(this._last_editor || from, function (id) {
	        if (this._get_editor_type(id)) return true;
	        return false;
	      }, next);

	      if (this.editStop()) {
	        //if we was able to close previous editor
	        if (editor_next) {
	          //and there is a new target
	          this.edit(editor_next); //init new editor

	          this._after_edit_next(editor_next);
	        }

	        return false;
	      }
	    }
	  },
	  //stab, used in datatable
	  _after_edit_next: function () {},
	  _find_cell_next: function (start, check, direction) {
	    var row = this.getIndexById(start.id);
	    var order = this.data.order;

	    if (direction) {
	      for (var i = row + 1; i < order.length; i++) {
	        if (check.call(this, order[i])) return order[i];
	      }
	    } else {
	      for (var _i = row - 1; _i >= 0; _i--) {
	        if (check.call(this, order[_i])) return order[_i];
	      }
	    }

	    return null;
	  },
	  _get_new_value: function (editor) {
	    return editor.getValue();
	  },
	  _set_new_value: function (editor, new_value, copy$$1) {
	    var item = copy$$1 ? {} : this.getItem(editor.id);
	    item[this._settings.editValue || "value"] = new_value;
	    return item;
	  }
	};

	var FlexLayout = {
	  $init: function () {
	    this.$view.className += " webix_flexlayout";
	  },
	  _fix_vertical_layout: function () {},
	  _beforeResetBorders: function () {},
	  _afterResetBorders: function () {},
	  $getSize: function () {
	    debug_size_box_start(this, true);
	    var w = 0,
	        h = 0,
	        g = this._settings.gravity;
	    this._sizes = [];

	    for (var i = 0; i < this._cells.length; i++) {
	      var size = this._cells[i].$getSize(0, 0);

	      this._sizes.push(size);

	      w = Math.max(w, size[0]);
	      h = Math.max(h, size[2]);
	    }

	    w += this._padding.left + this._padding.right;
	    h += this._padding.top + this._padding.bottom;
	    if (this._settings.width) w = Math.max(w, this._settings.width);
	    if (this._settings.height) h = Math.max(h, this._settings.height);
	    var self_size = [w, 100000, h, 100000, g];
	    debug_size_box_end(this, self_size);
	    return self_size;
	  },
	  render: function () {
	    this.resize();
	  },
	  _set_child_size: function () {
	    if (!this.isVisible(this._settings.id)) return;
	    var st = this.$view.style;
	    var margin = Math.round(this._margin / 2);
	    st.paddingTop = this._padding.top - margin + "px";
	    st.paddingBottom = this._padding.bottom - margin + "px";
	    st.paddingLeft = this._padding.left - margin + "px";
	    st.paddingRight = this._padding.right - margin + "px";

	    for (var i = 0; i < this._cells.length; i++) {
	      if (this._cells[i]._settings.hidden) continue;
	      var view = this._cells[i].$view;
	      var size = this._sizes[i];
	      var config = this._cells[i]._settings;

	      if (view) {
	        view.style.minWidth = size[0] + "px";
	        if (size[1] < 100000 && size[1] != size[0]) view.style.maxWidth = size[1] + "px";
	        view.style.flexBasis = config.flexBasis || size[0] + "px";
	        view.style.flexGrow = config.flexGrow || (size[1] != size[0] ? size[4] : 0);
	        view.style.height = size[3] != size[2] ? "auto" : size[2] + "px";
	        view.style.minHeight = size[2] + "px";
	        if (size[3] < 100000 && size[3] != size[2]) view.style.maxHeight = size[3] + "px";
	        view.style.margin = margin + "px";
	      }
	    }

	    var whs = [];

	    for (var _i = 0; _i < this._cells.length; _i++) {
	      if (this._cells[_i]._settings.hidden) continue;
	      var _view = this._cells[_i].$view;
	      whs[_i] = [_view.offsetWidth, _view.offsetHeight];
	    }

	    for (var _i2 = 0; _i2 < this._cells.length; _i2++) {
	      if (this._cells[_i2]._settings.hidden) continue;
	      var cell = this._cells[_i2];
	      var _view2 = cell.$view;

	      if (_view2) {
	        cell._settings.flex = true;
	        var _size = this._sizes[_i2];
	        var h = _size[2] == _size[3] ? _size[2] : whs[_i2][1];
	        cell.$setSize(whs[_i2][0], h);
	        cell._settings.flex = false;
	      }
	    }

	    this.$height = this._content_height = this.$view.scrollHeight;
	    this.$view.style.height = this._content_height + "px";
	  }
	};

	var GroupMethods = {
	  sum: function (property, data) {
	    data = data || this;
	    var summ = 0;

	    for (var i = 0; i < data.length; i++) {
	      var num = parseFloat(property(data[i]), 10);
	      if (!isNaN(num)) summ += num;
	    }

	    return summ;
	  },
	  min: function (property, data) {
	    data = data || this;
	    var min = Infinity;

	    for (var i = 0; i < data.length; i++) {
	      var num = parseFloat(property(data[i]), 10);
	      if (isNaN(num)) continue;
	      if (num < min) min = num;
	    }

	    return min === Infinity ? 0 : min * 1;
	  },
	  max: function (property, data) {
	    data = data || this;
	    var max = -Infinity;

	    for (var i = 0; i < data.length; i++) {
	      var num = parseFloat(property(data[i]), 10);
	      if (isNaN(num)) continue;
	      if (num > max) max = num;
	    }

	    return max === -Infinity ? 0 : max * 1;
	  },
	  count: function (property, data) {
	    var count = 0;

	    for (var i = 0; i < data.length; i++) {
	      var some = property(data[i]);
	      if (some !== null && typeof some !== "undefined") count++;
	    }

	    return count;
	  },
	  any: function (property, data) {
	    return property(data[0]);
	  },
	  string: function (property) {
	    return property.$name;
	  }
	};

	var GroupStore = {
	  $init: function () {
	    this.attachEvent("onClearAll", this._reset_groups);
	  },
	  _reset_groups: function () {
	    this._not_grouped_order = this._not_grouped_pull = null;
	    this._group_level_count = 0;
	  },
	  ungroup: function (skipRender) {
	    if (this.getBranchIndex) return this._ungroup_tree.apply(this, arguments);

	    if (this._not_grouped_order) {
	      this.order = this._not_grouped_order;
	      this.pull = this._not_grouped_pull;
	      this._not_grouped_pull = this._not_grouped_order = null;
	      if (!skipRender) this.callEvent("onStoreUpdated", []);
	    }
	  },
	  _group_processing: function (scheme) {
	    this.blockEvent();
	    this.group(scheme);
	    this.unblockEvent();
	  },
	  _group_prop_accessor: function (val) {
	    if (typeof val == "function") return val;

	    var acc = function (obj) {
	      return obj[val];
	    };

	    acc.$name = val;
	    return acc;
	  },
	  group: function (stats) {
	    if (this.getBranchIndex) return this._group_tree.apply(this, arguments);
	    if (typeof stats == "string") stats = {
	      by: stats,
	      map: {}
	    };
	    var input = typeof stats.by == "function" ? "value" : stats.by;

	    var key = this._group_prop_accessor(stats.by);

	    if (!stats.map[input]) stats.map[input] = [input, this._any];
	    var groups = {};
	    var labels = [];
	    this.each(function (data) {
	      var current = key(data);

	      if (!groups[current]) {
	        labels.push({
	          id: current,
	          $group: true,
	          $row: stats.row
	        });
	        groups[current] = toArray();
	      }

	      groups[current].push(data);
	    });

	    for (var prop in stats.map) {
	      var functor = stats.map[prop][1] || "any";

	      var property = this._group_prop_accessor(stats.map[prop][0]);

	      if (typeof functor != "function") {
	        assert(GroupMethods[functor], "unknown grouping rule: " + functor);
	        functor = GroupMethods[functor];
	      }

	      for (var i = 0; i < labels.length; i++) {
	        labels[i][prop] = functor.call(this, property, groups[labels[i].id]);
	      }
	    }

	    this._not_grouped_order = this.order;
	    this._not_grouped_pull = this.pull;
	    this.order = toArray();
	    this.pull = {};

	    for (var _i = 0; _i < labels.length; _i++) {
	      var id = this.id(labels[_i]);
	      this.pull[id] = labels[_i];
	      this.order.push(id);
	      if (this._scheme_init) this._scheme_init(labels[_i]);
	    }

	    this.callEvent("onStoreUpdated", []);
	  },
	  _group_tree: function (input, parent) {
	    this._group_level_count = (this._group_level_count || 0) + 1; //supports simplified group by syntax

	    var stats;

	    if (typeof input == "string") {
	      stats = {
	        by: this._group_prop_accessor(input),
	        map: {}
	      };
	      stats.map[input] = [input];
	    } else if (typeof input == "function") {
	      stats = {
	        by: input,
	        map: {}
	      };
	    } else stats = input; //prepare


	    var level;
	    if (parent) level = this.getItem(parent).$level;else {
	      parent = 0;
	      level = 0;
	    }
	    var order = this.branch[parent];

	    var key = this._group_prop_accessor(stats.by); //run


	    var topbranch = [];
	    var labels = [];

	    for (var i = 0; i < order.length; i++) {
	      var data = this.getItem(order[i]);
	      var current = key(data);
	      var current_id = level + "$" + current;
	      var ancestor = this.branch[current_id];

	      if (!ancestor) {
	        var newitem = this.pull[current_id] = {
	          id: current_id,
	          value: current,
	          $group: true,
	          $row: stats.row
	        };
	        if (this._scheme_init) this._scheme_init(newitem);
	        labels.push(newitem);
	        ancestor = this.branch[current_id] = [];
	        ancestor._formath = [];
	        topbranch.push(current_id);
	      }

	      ancestor.push(data.id);

	      ancestor._formath.push(data);
	    }

	    this.branch[parent] = topbranch;

	    for (var prop in stats.map) {
	      var functor = stats.map[prop][1] || "any";

	      var property = this._group_prop_accessor(stats.map[prop][0]);

	      if (typeof functor != "function") {
	        assert(GroupMethods[functor], "unknown grouping rule: " + functor);
	        functor = GroupMethods[functor];
	      }

	      for (var _i2 = 0; _i2 < labels.length; _i2++) {
	        labels[_i2][prop] = functor.call(this, property, this.branch[labels[_i2].id]._formath);
	      }
	    }

	    for (var _i3 = 0; _i3 < labels.length; _i3++) {
	      var group = labels[_i3];
	      if (this.hasEvent("onGroupCreated")) this.callEvent("onGroupCreated", [group.id, group.value, this.branch[group.id]._formath]);

	      if (stats.footer) {
	        var id = "footer$" + group.id;
	        var footer = this.pull[id] = {
	          id: id,
	          $footer: true,
	          value: group.value,
	          $level: level,
	          $count: 0,
	          $parent: group.id,
	          $row: stats.footer.row
	        };

	        for (var _prop in stats.footer) {
	          var _functor = stats.footer[_prop][1] || "any";

	          var _property = this._group_prop_accessor(stats.footer[_prop][0]);

	          if (typeof _functor != "function") {
	            assert(GroupMethods[_functor], "unknown grouping rule: " + _functor);
	            _functor = GroupMethods[_functor];
	          }

	          footer[_prop] = _functor.call(this, _property, this.branch[labels[_i3].id]._formath);
	        }

	        this.branch[group.id].push(footer.id);
	        this.callEvent("onGroupFooter", [footer.id, footer.value, this.branch[group.id]._formath]);
	      }

	      delete this.branch[group.id]._formath;
	    }

	    this._fix_group_levels(topbranch, parent, level + 1);

	    this.callEvent("onStoreUpdated", []);
	  },
	  _ungroup_tree: function (skipRender, parent, force) {
	    //not grouped
	    if (!force && !this._group_level_count) return;
	    this._group_level_count = Math.max(0, this._group_level_count - 1);
	    parent = parent || 0;
	    var order = [];
	    var toporder = this.branch[parent];

	    for (var i = 0; i < toporder.length; i++) {
	      var id = toporder[i];
	      var branch = this.branch[id];
	      if (branch) order = order.concat(branch);
	      delete this.pull[id];
	      delete this.branch[id];
	    }

	    this.branch[parent] = order;

	    for (var _i4 = order.length - 1; _i4 >= 0; _i4--) {
	      if (this.pull[order[_i4]].$footer) order.splice(_i4, 1);
	    }

	    this._fix_group_levels(order, 0, 1);

	    if (!skipRender) this.callEvent("onStoreUpdated", []);
	  },
	  _fix_group_levels: function (branch, parent, level) {
	    if (parent) this.getItem(parent).$count = branch.length;

	    for (var i = 0; i < branch.length; i++) {
	      var item = this.pull[branch[i]];
	      item.$level = level;
	      item.$parent = parent;
	      var next = this.branch[item.id];
	      if (next) this._fix_group_levels(next, item.id, level + 1);
	    }
	  }
	};

	var Group = {
	  $init: function () {
	    exports.extend(this.data, GroupStore); //in case of plain store we need to remove store original dataset

	    this.data.attachEvent("onClearAll", bind(function () {
	      this.data._not_grouped_order = this.data._not_grouped_pull = null;
	      this._group_level_count = 0;
	    }, this));
	  },
	  group: function (config) {
	    this.data.ungroup(true);
	    this.data.group(config);
	  },
	  ungroup: function (skipRender) {
	    this.data.ungroup(skipRender);
	  }
	};

	/*aria-style handling for options of multiple-value controls (radio, segmented, tabbar)*/

	var HTMLOptions = {
	  $init: function () {
	    var _this = this;

	    if ($active.customRadio || this.addOption) this.$ready.push(function () {
	      _event(_this.$view, "keydown", _this._moveSelection, {
	        bind: _this
	      });
	    });
	  },
	  _focus: function () {
	    if (!UIManager.canFocus(this)) return false;

	    var input = this._getInputNode();

	    if (input) {
	      for (var i = 0; i < input.length; i++) {
	        if (input[i].getAttribute("tabindex") == "0") {
	          input[i].focus();
	        }
	      }
	    }
	  },
	  _blur: function () {
	    var input = this._getInputNode();

	    if (input) for (var i = 0; i < input.length; i++) {
	      if (input[i].getAttribute("tabindex") == "0") input[i].blur();
	    }
	  },
	  _moveSelection: function (e) {
	    var code = e.which || e.keyCode;
	    var startCode = this.addOption ? 34 : 36;

	    if (code > startCode && code < 41) {
	      preventEvent(e);
	      var index$$1;

	      var inp = this._getInputNode();

	      if (code == 35) index$$1 = inp.length - 1;else if (code === 36) index$$1 = 0;else {
	        var dir = code === 37 || code === 38 ? -1 : 1;

	        for (var i = 0; i < inp.length; i++) {
	          if (inp[i].getAttribute("tabindex") == "0") {
	            index$$1 = i + dir;
	            if (index$$1 < 0) index$$1 = inp.length - 1;else if (index$$1 >= inp.length) index$$1 = 0;
	            break;
	          }
	        }
	      }

	      if (!isUndefined(index$$1)) {
	        var id = inp[index$$1].getAttribute("button_id");
	        this.setValue(id);
	        inp[index$$1].focus();
	      }
	    }
	  },
	  _get_tooltip_data: function (t, e) {
	    var node = e.target || e.srcElement;

	    while (node && !node.webix_tooltip) {
	      var id = node.getAttribute("webix_t_id");
	      if (id) return this.getOption(id);
	      node = node.parentNode;
	    }

	    return null;
	  },
	  getOption: function (id) {
	    var options = this._check_options(this._settings.options);

	    for (var i = 0; i < options.length; i++) {
	      if (options[i].id == id) return options[i];
	    }

	    return null;
	  }
	};

	var HtmlMap = exports.proto({
	  $init: function (key) {
	    this._id = "map_" + uid();
	    this._key = key;
	    this._map = [];
	    this._areas = [];
	  },
	  addRect: function (id, points, userdata) {
	    this._createMapArea(id, "RECT", points, userdata);
	  },
	  addPoly: function (id, points, userdata) {
	    this._createMapArea(id, "POLY", points, userdata);
	  },
	  _createMapArea: function (id, shape, coords, userdata) {
	    var extra_data = "";
	    if (arguments.length == 4) extra_data = "userdata='" + userdata + "'";

	    this._map.push("<area " + this._key + "='" + id + "' shape='" + shape + "' coords='" + coords.join() + "' " + extra_data + "></area>");

	    this._areas.push({
	      index: userdata,
	      points: coords
	    });
	  },
	  addSector: function (id, alpha0, alpha1, x, y, R, ky, userdata) {
	    var points = [];
	    points.push(x);
	    points.push(Math.floor(y * ky));

	    for (var i = alpha0; i < alpha1; i += Math.PI / 18) {
	      points.push(Math.floor(x + R * Math.cos(i)));
	      points.push(Math.floor((y + R * Math.sin(i)) * ky));
	    }

	    points.push(Math.floor(x + R * Math.cos(alpha1)));
	    points.push(Math.floor((y + R * Math.sin(alpha1)) * ky));
	    points.push(x);
	    points.push(Math.floor(y * ky));
	    return this.addPoly(id, points, userdata);
	  },
	  hide: function (obj, data, mode) {
	    if (obj.querySelectorAll) {
	      var nodes = obj.querySelectorAll("area[userdata=\"" + data + "\"]");

	      for (var i = 0; i < nodes.length; i++) {
	        var nod = nodes[i];

	        if (mode) {
	          if (nod.getAttribute("coords")) {
	            nod.coordsdis = nod.getAttribute("coords");
	            nod.setAttribute("coords", "");
	            nod.coords = "";
	          }
	        } else if (!mode) {
	          if (nod.coordsdis) {
	            nod.setAttribute("coords", nod.coordsdis);
	            nod.coords = nod.coordsdis;
	            nod.coordsdis = "";
	          }
	        }

	        nodes[i].style.display = mode ? "none" : "";
	      }
	    }
	  },
	  render: function (obj) {
	    var d = create("DIV");
	    d.style.cssText = "position:absolute; width:100%; height:100%; top:0px; left:0px;";
	    obj.appendChild(d);
	    var src = env.isIE ? "" : "src='data:image/gif;base64,R0lGODlhEgASAIAAAP///////yH5BAUUAAEALAAAAAASABIAAAIPjI+py+0Po5y02ouz3pwXADs='";
	    d.innerHTML = "<map id='" + this._id + "' name='" + this._id + "'>" + this._map.join("\n") + "</map><img " + src + " class='webix_map_img' usemap='#" + this._id + "'>";
	    obj._htmlmap = d; //for clearing routine

	    this._map = [];
	  }
	});

	var IdSpace = {
	  $init: function () {
	    this._elements = {};
	    this._translate_ids = {};
	    this.getTopParentView = this._get_self = bind(function () {
	      return this;
	    }, this);

	    this._run_inner_init_logic();

	    this.$ready.push(this._run_after_inner_init_logic);
	  },
	  $$: function (id) {
	    return this._elements[id];
	  },
	  innerId: function (id) {
	    return this._translate_ids[id];
	  },
	  _run_inner_init_logic: function () {
	    this._prev_global_col = state._global_collection;
	    state._global_collection = this;
	  },
	  _run_after_inner_init_logic: function () {
	    for (var name in this._elements) {
	      var input = this._elements[name];
	      if (this.callEvent && input.mapEvent && !input._evs_map.onitemclick) input.mapEvent({
	        onitemclick: this
	      });
	      input.getTopParentView = this._get_self;
	    }

	    state._global_collection = this._prev_global_col;
	    this._prev_global_col = 0;
	  },
	  _destroy_child: function (id) {
	    delete this._elements[id];
	  },
	  ui: function () {
	    this._run_inner_init_logic();

	    var temp = ui.apply(this, arguments);

	    this._run_after_inner_init_logic();

	    return temp;
	  }
	};

	var KeysNavigation = {
	  $init: function () {
	    if (this.getSelectedId) this.attachEvent("onAfterRender", this._set_focusable_item);
	    if (this.moveSelection) this.attachEvent("onTabFocus", this._set_item_focus);
	  },
	  _set_item_focus: function () {
	    if (this.getSelectedId) {
	      var sel = this.getSelectedId(true);
	      if (!sel.length || !this.getItemNode(sel[0])) this.moveSelection("down"); //select and show
	    }
	  },
	  _set_focusable_item: function () {
	    var sel = this.getSelectedId(true);

	    if (!sel.length || !this.getItemNode(sel[0])) {
	      var node = this._dataobj.querySelector("[" + this._id + "]");

	      if (node) node.setAttribute("tabindex", "0");
	    }
	  },
	  _navigation_helper: function (mode) {
	    return function (view, e) {
	      var tag = e.srcElement || e.target; //ignore clipboard listener

	      if (!tag.getAttribute("webixignore")) {
	        //ignore hotkeys if focus in the common input
	        //to allow normal text edit operations
	        var name = tag.tagName;
	        if (name == "INPUT" || name == "TEXTAREA" || name == "SELECT") return true;
	      }

	      if (view && view.moveSelection && view.config.navigation && !view._in_edit_mode) {
	        preventEvent(e);
	        return view.moveSelection(mode, {
	          shift: e.shiftKey,
	          ctrl: e.ctrlKey
	        });
	      }

	      return true;
	    };
	  },
	  moveSelection: function (mode, details, focus) {
	    var config = this._settings;
	    if (config.disabled) return; //get existing selection

	    var selected = this.getSelectedId(true);
	    var x_layout = this.count && (config.layout == "x" || config.xCount > 1);

	    if ((mode == "right" || mode == "left") && this._parent_menu) {
	      var parent = $$(this._parent_menu);

	      parent._hide_sub_menu(true);

	      if (parent.config.layout === "x") parent.moveSelection(mode);else UIManager.setFocus(parent);
	      return;
	    }

	    if (!selected.length && this.count()) {
	      if (mode == "down" || mode == "right" && x_layout) mode = "top";else if (mode == "up" || mode == "left" && x_layout) mode = "bottom";else return;
	      selected = [this.getFirstId()];
	    }

	    if (selected.length == 1) {
	      //if we have a selection
	      selected = selected[0];
	      var prev = selected;
	      if (mode == "left" && this.close) return this.close(selected);
	      if (mode == "right" && this.open) return this.open(selected);else if (mode == "top") {
	        selected = this.getFirstId();
	      } else if (mode == "bottom") {
	        selected = this.getLastId();
	      } else if (mode == "up" || mode == "left" || mode == "pgup") {
	        var index$$1 = this.getIndexById(selected);
	        var step = mode == "pgup" ? 10 : 1;
	        selected = this.getIdByIndex(Math.max(0, index$$1 - step));
	      } else if (mode == "down" || mode == "right" || mode == "pgdown") {
	        var _index = this.getIndexById(selected);

	        var _step = mode == "pgdown" ? 10 : 1;

	        selected = this.getIdByIndex(Math.min(this.count() - 1, _index + _step));
	      } else {
	        assert(false, "Not supported selection moving mode");
	        return;
	      }
	      if (this._skip_item) selected = this._skip_item(selected, prev, mode);
	      this.showItem(selected);
	      this.select(selected);
	      if (this.getSubMenu && this.getSubMenu(selected)) this._mouse_move_activation(selected, this.getItemNode(selected));

	      if (!this.config.clipboard && focus !== false) {
	        var node = this.getItemNode(selected);
	        if (node) node.focus();
	      }
	    }

	    return false;
	  },
	  navigation_setter: function (value) {
	    //using global flag to apply hotkey only once
	    if (value && !UIManager._global_nav_grid_hotkeys) {
	      UIManager._global_nav_grid_hotkeys = true; //hotkeys will react on any component but will not work in edit mode
	      //you can define moveSelection method to handle navigation keys

	      UIManager.addHotKey("up", this._navigation_helper("up"));
	      UIManager.addHotKey("down", this._navigation_helper("down"));
	      UIManager.addHotKey("right", this._navigation_helper("right"));
	      UIManager.addHotKey("left", this._navigation_helper("left"));
	      UIManager.addHotKey("shift+up", this._navigation_helper("up"));
	      UIManager.addHotKey("shift+down", this._navigation_helper("down"));
	      UIManager.addHotKey("shift+right", this._navigation_helper("right"));
	      UIManager.addHotKey("shift+left", this._navigation_helper("left"));
	      UIManager.addHotKey("ctrl+shift+up", this._navigation_helper("up"));
	      UIManager.addHotKey("ctrl+shift+down", this._navigation_helper("down"));
	      UIManager.addHotKey("ctrl+shift+right", this._navigation_helper("right"));
	      UIManager.addHotKey("ctrl+shift+left", this._navigation_helper("left"));
	      UIManager.addHotKey("pageup", this._navigation_helper("pgup"));
	      UIManager.addHotKey("pagedown", this._navigation_helper("pgdown"));
	      UIManager.addHotKey("home", this._navigation_helper("top"));
	      UIManager.addHotKey("end", this._navigation_helper("bottom"));
	    }

	    return value;
	  }
	};

	/*Data collection mapping logic */

	var MapCollection = {
	  $init: function () {
	    this.$ready.push(this._create_scheme_init);
	    this.attachEvent("onStructureUpdate", this._create_scheme_init);
	    this.attachEvent("onStructureLoad", function () {
	      if (!this._scheme_init_order.length) this._create_scheme_init();
	    });
	  },
	  _create_scheme_init: function () {
	    var stack = this._scheme_init_order = [];
	    var config = this._settings;
	    if (config.columns) this._build_data_map(config.columns);
	    if (this._settings.map) this._process_field_map(config.map);

	    if (stack.length) {
	      this.data._scheme_init = function (obj) {
	        for (var i = 0; i < stack.length; i++) {
	          stack[i](obj);
	        }
	      };
	    }
	  },
	  _process_field_map: function (map) {
	    for (var key in map) {
	      this._scheme_init_order.push(this._process_single_map(key, map[key]));
	    }
	  },
	  _process_single_map: function (target, map, extra) {
	    var source = map.replace(/^(\s|)\((date|number)\)/, "");
	    var getSource;

	    if (source === "") {
	      getSource = function (a) {
	        return a[target];
	      };
	    } else {
	      if (source.indexOf("#") === -1 && source.indexOf("{") === -1) {
	        source = "#" + source + "#";
	      }

	      getSource = template(source);
	    }

	    if (map.indexOf("(date)") === 0) {
	      if (extra && !extra.format) extra.format = i18n.dateFormatStr;
	      return function (obj) {
	        var dateStr = (getSource(obj) || "").toString();
	        obj[target] = i18n.parseFormatDate(dateStr);
	      };
	    } else if (map.indexOf("(number)") === 0) {
	      return function (obj) {
	        obj[target] = getSource(obj) * 1;
	      };
	    } else {
	      return function (obj) {
	        obj[target] = getSource(obj) || "";
	      };
	    }
	  },
	  _build_data_map: function (columns) {
	    //for datatable
	    for (var i = 0; i < columns.length; i++) {
	      var map = columns[i].map;
	      var id = columns[i].id;

	      if (!id) {
	        id = columns[i].id = "i" + uid();
	        if (!columns[i].header) columns[i].header = "";
	      }

	      if (map) this._scheme_init_order.push(this._process_single_map(id, map, columns[i]));

	      this._map_options(columns[i]);
	    }
	  },
	  _map_options: function (element) {
	    var options = element.options || element.collection;

	    if (options) {
	      if (typeof options === "string") {
	        //id of some other view
	        var options_view = $$(options); //or url

	        if (!options_view) {
	          options_view = new (use("DataCollection"))({
	            url: options
	          });

	          this._destroy_with_me.push(options_view);
	        } //if it was a view, special check for suggests


	        if (options_view.getBody) options_view = options_view.getBody();

	        this._bind_collection(options_view, element);
	      } else if (!options.loadNext) {
	        if (options[0] && _typeof(options[0]) == "object") {
	          //[{ id:1, value:"one"}, ...]
	          options = new (use("DataCollection"))({
	            data: options
	          });

	          this._bind_collection(options, element);

	          this._destroy_with_me.push(options);
	        } else {
	          //["one", "two"]
	          //or
	          //{ 1: "one", 2: "two"}
	          if (isArray(options)) {
	            var data = {};

	            for (var ij = 0; ij < options.length; ij++) {
	              data[options[ij]] = options[ij];
	            }

	            element.options = options = data;
	          }

	          element.template = element.template || this._collection_accesser(options, element.id, element.optionslist);
	        }
	      } else {
	        //data collection or view
	        this._bind_collection(options, element);
	      }
	    }
	  },
	  _bind_collection: function (options, element) {
	    if (element) {
	      delete element.options;
	      element.collection = options;
	      element.template = element.template || this._bind_accesser(options, element.id, element.optionslist);
	      var id = options.data.attachEvent("onStoreUpdated", bind(function () {
	        this.refresh();
	        if (this.refreshFilter) this.refreshFilter(element.id);
	      }, this));
	      this.attachEvent("onDestruct", function () {
	        if (!options.$destructed) options.data.detachEvent(id);
	      });
	    }
	  },
	  _collection_accesser: function (options, id, multi) {
	    if (multi) {
	      var separator = typeof multi == "string" ? multi : ",";
	      return function (obj) {
	        var value = obj[id] || obj.value;
	        if (!value) return "";
	        var ids = value.split(separator);

	        for (var i = 0; i < ids.length; i++) {
	          ids[i] = options[ids[i]] || "";
	        }

	        return ids.join(", ");
	      };
	    } else {
	      return function (obj) {
	        return options[obj[id]] || obj.value || "";
	      };
	    }
	  },
	  _bind_accesser: function (col, id, multi) {
	    if (multi) {
	      var separator = typeof multi == "string" ? multi : ",";
	      return function (obj) {
	        var value = obj[id] || obj.value;
	        if (!value) return "";
	        var ids = value.split(separator);

	        for (var i = 0; i < ids.length; i++) {
	          var data = col.data.pull[ids[i]];
	          ids[i] = data ? data.value || "" : "";
	        }

	        return ids.join(", ");
	      };
	    } else {
	      return function (obj) {
	        var prop = obj[id] || obj.value,
	            data = col.data.pull[prop];
	        if (data && (data.value || data.value === 0)) return data.value;
	        return "";
	      };
	    }
	  }
	};

	var MouseEvents = {
	  $init: function (config) {
	    config = config || {};
	    this._clickstamp = 0;
	    this._dbl_sensetive = 300;
	    this._item_clicked = null;

	    this._mouse_action_extend(config.onClick, "on_click");

	    this._mouse_action_extend(config.onContext, "on_context");

	    this._mouse_action_extend(config.onDblClick, "on_dblclick");

	    this._mouse_action_extend(config.onMouseMove, "on_mouse_move"); //attach dom events if related collection is defined


	    if (this.on_click) {
	      _event(this._contentobj, "click", this._onClick, {
	        bind: this
	      });

	      if (env.isIE8 && this.on_dblclick) _event(this._contentobj, "dblclick", this._onDblClick, {
	        bind: this
	      });
	    }

	    if (this.on_context) _event(this._contentobj, "contextmenu", this._onContext, {
	      bind: this
	    });
	    if (this.on_mouse_move) this._enable_mouse_move();
	  },
	  _enable_mouse_move: function () {
	    if (!this._mouse_move_enabled) {
	      this.on_mouse_move = this.on_mouse_move || {};

	      _event(this._contentobj, "mousemove", this._onMouse, {
	        bind: this
	      });

	      _event(this._contentobj, env.isIE ? "mouseleave" : "mouseout", this._onMouse, {
	        bind: this
	      });

	      this._mouse_move_enabled = 1;
	      this.attachEvent("onDestruct", function () {
	        if (this._mouse_move_timer) window.clearTimeout(this._mouse_move_timer);
	      });
	    }
	  },
	  _mouse_action_extend: function (config, key) {
	    if (config) {
	      var now = this[key];
	      var step = now ? exports.extend({}, now) : {};
	      this[key] = exports.extend(step, config);
	    }
	  },
	  //inner onclick object handler
	  _onClick: function (e) {
	    if (!this.isEnabled()) return false;

	    UIManager._focus_action(this);

	    if (this.on_dblclick) {
	      // emulates double click
	      var stamp = new Date().valueOf();

	      if (stamp - this._clickstamp <= this._dbl_sensetive && this.locate) {
	        var item = this.locate(e);

	        if ("" + item == "" + this._item_clicked) {
	          this._clickstamp = 0;
	          return this._onDblClick(e);
	        }
	      }

	      this._clickstamp = stamp;
	    }

	    var result = this._mouseEvent(e, this.on_click, "ItemClick");

	    return result;
	  },
	  //inner ondblclick object handler
	  _onDblClick: function (e) {
	    return this._mouseEvent(e, this.on_dblclick, "ItemDblClick");
	  },
	  //process oncontextmenu events
	  _onContext: function (e) {
	    this._mouseEvent(e, this.on_context, "BeforeContextMenu", "AfterContextMenu");
	  },

	  /*
	  	event throttler - ignore events which occurs too fast
	  	during mouse moving there are a lot of event firing - we need no so much
	  	also, mouseout can fire when moving inside the same html container - we need to ignore such fake calls
	  */
	  _onMouse: function (e) {
	    if (this.$destructed) return;
	    if (document.createEventObject) //make a copy of event, will be used in timed call
	      e = document.createEventObject(event);else if (!isUndefined(e.movementY) && !e.movementY && !e.movementX) return; //logitech mouse driver can send false signals in Chrome

	    if (this._mouse_move_timer) //clear old event timer
	      window.clearTimeout(this._mouse_move_timer); //this event just inform about moving operation, we don't care about details

	    this.callEvent("onMouseMoving", [e]); //set new event timer

	    this._mouse_move_timer = window.setTimeout(bind(function () {
	      //called only when we have at least 100ms after previous event
	      if (e.type == "mousemove") this._onMouseMove(e);else this._onMouseOut(e);
	    }, this), this._settings.mouseEventDelay || 500);
	  },
	  //inner mousemove object handler
	  _onMouseMove: function (e) {
	    if (!this._mouseEvent(e, this.on_mouse_move, "MouseMove")) this.callEvent("onMouseOut", [e || event]);
	  },
	  //inner mouseout object handler
	  _onMouseOut: function (e) {
	    this.callEvent("onMouseOut", [e || event]);
	  },
	  //common logic for click and dbl-click processing
	  _mouseEvent: function (e, hash, name, pair) {
	    e = e || event;
	    if (e.processed || !this._viewobj) return;
	    e.processed = true;
	    var trg = e.target || e.srcElement; //IE8 can't modify event object
	    //so we need to stop event bubbling to prevent double processing

	    if (env.isIE8) {
	      var vid = this._settings.id;
	      var wid = trg.w_view;
	      if (!wid) trg.w_view = vid;else if (wid !== vid) return;
	    }

	    var css = "";
	    var id = null;
	    var found = false; //loop through all parents
	    //we need to check for this._viewobj as some handler can destroy the view

	    while (trg && trg.parentNode && this._viewobj && trg != this._viewobj.parentNode) {
	      if (!found && trg.getAttribute) {
	        //if element with ID mark is not detected yet
	        id = trg.getAttribute(this._id); //check id of current one

	        if (id) {
	          this._item_clicked = id;

	          if (this.callEvent) {
	            //it will be triggered only for first detected ID, in case of nested elements
	            if (!this.callEvent("on" + name, [id, e, trg])) return;
	            if (pair) this.callEvent("on" + pair, [id, e, trg]);
	          } //set found flag


	          found = true;
	        }
	      }

	      css = _getClassName(trg);

	      if (css) {
	        //check if pre-defined reaction for element's css name exists
	        css = css.toString().split(" ");

	        for (var i = 0; i < css.length; i++) {
	          if (hash[css[i]]) {
	            var functor = toFunctor(hash[css[i]], this.$scope);
	            var res = functor.call(this, e, id || locate(e, this._id), trg);
	            if (res === false) return found;
	          }
	        }
	      }

	      trg = trg.parentNode;
	    }

	    return found; //returns true if item was located and event was triggered
	  }
	};

	/*
	    UI: navigation control
	*/

	var NavigationButtons = {
	  $init: function () {
	    this.$ready.push(function () {
	      this.attachEvent("onKeyPress", this._onKeyPress);
	    });
	  },
	  _moveActive: function (code, e) {
	    if (code === 37 || code === 39) {
	      preventEvent(e);

	      this._showNavItem(code === 37 ? -1 : 1);

	      var node = this._navPanel.querySelector("[tabindex='0']");

	      if (node) node.focus();
	    }
	  },
	  _renderPanel: function () {
	    remove(this._navPanel);
	    this._navPanel = create("DIV", {
	      "class": "webix_nav_panel " + "webix_nav_panel_" + this._settings.navigation.type,
	      "role": "tablist"
	    }, "");

	    this._viewobj.appendChild(this._navPanel);

	    this._renderNavItems();

	    this._renderNavButtons();

	    this._setLinkEventHandler();
	  },
	  _setLinkEventHandler: function () {
	    var h = [];
	    if (this._navPanel) h[0] = event$1(this._navPanel, "click", bind(function (e) {
	      var elem = e.srcElement || e.target;
	      var found = false;

	      while (elem != this._navPanel && !found) {
	        var bindId = elem.getAttribute(this._linkAttr);

	        if (bindId) {
	          found = true;

	          this._showPanelBind(bindId);
	        }

	        elem = elem.parentNode;
	      }
	    }, this));
	    if (this._prevNavButton) h[1] = event$1(this._prevNavButton, "click", bind(function () {
	      this._showNavItem(-1);
	    }, this));
	    if (this._nextNavButton) h[1] = event$1(this._nextNavButton, "click", bind(function () {
	      this._showNavItem(1);
	    }, this));
	    this.attachEvent("onDestruct", function () {
	      for (var i = 0; i < h.length; i++) {
	        this.detachEvent(h[i]);
	      }

	      h = null;
	    });
	  },
	  _showNavItem: function (inc) {
	    if (this._cells) {
	      var index$$1 = this._active_cell + inc;

	      if (index$$1 >= this._cells.length || index$$1 < 0) {
	        index$$1 = index$$1 < 0 ? this._cells.length - 1 : 0;
	      }

	      this.setActiveIndex(index$$1);
	    }
	  },
	  _showPanelBind: function (id) {
	    if (this._cells) $$(id).show();
	  },
	  _renderNavItems: function () {
	    var item, config;
	    config = this._settings.navigation;

	    if (config.items) {
	      this._linkAttr = config.linkAttr || "bind_id";
	      if (!this._navPanel) this._renderPanel();else this._clearPanel();
	      var data = this._cells ? this._cells : this.data.order;

	      if (data.length > 1) {
	        for (var i = 0; i < data.length; i++) {
	          item = create("DIV", {
	            "class": "webix_nav_item webix_nav_" + (i == this._active_cell ? "active" : "inactive"),
	            "role": "tab",
	            "tabindex": i == this._active_cell ? "0" : "-1"
	          });
	          var id = this._cells ? this._cells[i]._settings.id : data[i];
	          if (id) item.setAttribute(this._linkAttr, id);

	          this._navPanel.appendChild(item);
	        }
	      }
	    }
	  },
	  _clearPanel: function () {
	    if (this._navPanel) {
	      var coll = this._navPanel.childNodes;

	      for (var i = coll.length - 1; i >= 0; i--) {
	        remove(coll[i]);
	      }
	    }
	  },
	  _renderNavButtons: function () {
	    var config = this._settings.navigation;

	    if (config.buttons) {
	      if (this._prevNavButton) remove(this._prevNavButton);
	      if (this._prevNavButton) remove(this._nextNavButton);
	      this._prevNavButton = create("DIV", {
	        "class": "webix_nav_button_" + config.type + " webix_nav_button_prev "
	      }, "<div role=\"button\" tabindex=\"0\" aria-label=\"" + i18n.aria.prevTab + "\" class=\"webix_nav_button_inner\"></div>");

	      this._viewobj.appendChild(this._prevNavButton);

	      this._nextNavButton = create("DIV", {
	        "class": "webix_nav_button_" + config.type + " webix_nav_button_next "
	      }, "<div role=\"button\" tabindex=\"0\" aria-label=\"" + i18n.aria.prevTab + "\" class=\"webix_nav_button_inner\"></div>");

	      this._viewobj.appendChild(this._nextNavButton);
	    }
	  }
	};

	var OverlayBox = {
	  showOverlay: function (message) {
	    if (!this._overlay) {
	      this._overlay = create("DIV", {
	        "class": "webix_overlay"
	      }, message || "");
	      insertBefore(this._overlay, this._viewobj.firstChild, this._viewobj);
	      this._viewobj.style.position = "relative";
	    } else this._overlay.innerHTML = message;
	  },
	  hideOverlay: function () {
	    if (this._overlay) {
	      remove(this._overlay);
	      this._overlay = null;
	    }
	  }
	};

	var PagingAbility = {
	  pager_setter: function (pager) {
	    if (typeof pager == "string") {
	      var ui_pager = $$(pager);

	      if (!ui_pager) {
	        this.$blockRender = true;
	        delay(function () {
	          var obj = $$(pager);
	          this._settings.pager = this.pager_setter(obj);
	          var s = obj._settings;
	          s.count = this.data._count_pager_total(s.level);
	          obj.refresh();
	          this.$blockRender = false;
	          this.render();
	        }, this);
	        return null;
	      }

	      pager = ui_pager;
	    }

	    function check_pager_sizes(repeat) {
	      if (pager.config.autosize && this.getVisibleCount) {
	        var count = this.getVisibleCount();

	        if (isNaN(count)) {
	          pager.config.size = 1;
	          delay(check_pager_sizes, this, [true]);
	        } else if (count != pager.config.size) {
	          pager.config.size = count;
	          pager.refresh();
	          if (repeat === true) this.refresh();
	        }
	      }

	      var s = this._settings.pager; //initial value of pager = -1, waiting for real value

	      if (s.page == -1) return false;
	      this.data.$min = this._count_pager_index(0, s.page * s.size); //affect data.getRange

	      this.data.$max = this._count_pager_index(this.data.$min, s.size);
	      this.data.$pagesize = this.data.$max - this.data.$min;
	      return true;
	    }

	    this.attachEvent("onBeforeRender", check_pager_sizes);

	    if (!pager.$view) {
	      pager.view = "pager";
	      pager = ui(pager);
	    }

	    this._pager = pager;
	    pager.$master = this;
	    this.data.attachEvent("onStoreUpdated", function () {
	      var s = pager._settings;
	      s.count = this._count_pager_total(s.level);
	      pager.refresh();
	    });
	    this.data._count_pager_total = this._count_pager_total;
	    return pager._settings;
	  },
	  _count_pager_total: function (level) {
	    if (level && level !== 0) {
	      var count = 0;
	      this.each(function (obj) {
	        if (obj.$level == level) count++;
	      });
	      return count;
	    } else return this.count();
	  },
	  _count_pager_index: function (start, count) {
	    var s = this._settings.pager;

	    if (s.level && s.level !== 0) {
	      var end = start;
	      var max = this.data.order.length;
	      if (count) while (end < max) {
	        if (this.data.order[end] && this.data.getItem(this.data.order[end]).$level == s.level) {
	          if (count === 0) break;else count--;
	        }

	        end++;
	      }
	      return end;
	    } else return start + count;
	  },
	  setPage: function (value) {
	    if (this._pager) this._pager.select(value);
	  },
	  getPage: function () {
	    return this._pager._settings.page;
	  },
	  getPager: function () {
	    return this._pager;
	  }
	};

	var ProgressBar = {
	  $init: function () {
	    if (isUndefined(this._progress) && this.attachEvent) {
	      this.attachEvent("onBeforeLoad", this.showProgress);
	      this.attachEvent("onAfterLoad", this.hideProgress);
	      this._progress = null;
	    }
	  },
	  showProgress: function (config) {
	    // { position: 0 - 1, delay: 2000ms by default, css : name of css class to use }
	    if (!this._progress) {
	      config = exports.extend({
	        position: 0,
	        delay: 2000,
	        type: "icon",
	        icon: "wxi-sync",
	        hide: false
	      }, config || {}, true);
	      var incss = config.type == "icon" ? config.icon + " webix_spin" : "";
	      this._progress = create("DIV", {
	        "class": "webix_progress_" + config.type,
	        "role": "progressbar",
	        "aria-valuemin": "0",
	        "aria-valuemax": "100",
	        "tabindex": "0"
	      }, "<div class='webix_progress_state " + incss + "'></div>");
	      if (!this.setPosition) this._viewobj.style.position = "relative";
	      insertBefore(this._progress, this._viewobj.firstChild, this._viewobj);

	      this._viewobj.setAttribute("aria-busy", "true");

	      if (!Touch.$active) {
	        if (this.getScrollState) {
	          var scroll = this.getScrollState();

	          if (this._viewobj.scrollWidth != this.$width) {
	            this._progress.style.left = scroll.x + "px";
	          }

	          if (this._viewobj.scrollHeight != this.$height) {
	            if (config.type != "bottom") {
	              this._progress.style.top = scroll.y + "px";
	            } else {
	              this._progress.style.top = scroll.y + this.$height - this._progress.offsetHeight + "px";
	            }
	          }
	        }
	      }

	      this._progress_delay = 1;
	    }

	    if (config && config.type != "icon") delay(function () {
	      if (this._progress) {
	        var position = config.position || 1; //check for css-transition support

	        if (this._progress.style[env.transitionDuration] !== undefined || !config.delay) {
	          this._progress.firstChild.style.width = position * 100 + "%";
	          if (config.delay) this._progress.firstChild.style[env.transitionDuration] = config.delay + "ms";
	        } else {
	          //if animation is not supported fallback to timeouts [IE9]
	          var count = 0,
	              start = 0,
	              step = position / config.delay * 30,
	              view = this;

	          if (this._progressTimer) {
	            //reset the existing progress
	            window.clearInterval(this._progressTimer);
	            start = this._progress.firstChild.offsetWidth / this._progress.offsetWidth * 100;
	          }

	          this._progressTimer = window.setInterval(function () {
	            if (count * 30 == config.delay) {
	              window.clearInterval(view._progressTimer);
	            } else {
	              if (view._progress && view._progress.firstChild) view._progress.firstChild.style.width = start + count * step * position * 100 + "%";
	              count++;
	            }
	          }, 30);
	        }

	        if (config.hide) delay(this.hideProgress, this, [1], config.delay);
	      }

	      this._progress_delay = 0;
	    }, this);else if (config && config.type == "icon" && config.hide) delay(this.hideProgress, this, [1], config.delay);
	  },
	  hideProgress: function (now) {
	    if (this._progress_delay) now = true;

	    if (this._progress) {
	      if (now) {
	        if (this._progressTimer) window.clearInterval(this._progressTimer);
	        remove(this._progress);
	        this._progress = null;

	        this._viewobj.removeAttribute("aria-busy");
	      } else {
	        this.showProgress({
	          position: 1.1,
	          delay: 300,
	          hide: true
	        });
	      }
	    }
	  }
	};

	var RenderStack = {
	  $init: function () {
	    assert(this.data, "RenderStack :: Component doesn't have DataStore");
	    assert(template, "template :: template is not accessible"); //used for temporary HTML elements
	    //automatically nulified during destruction

	    this._html = document.createElement("DIV");
	    this.data.attachEvent("onIdChange", bind(this._render_change_id, this));
	    this.attachEvent("onItemClick", this._call_onclick); //create copy of default type, and set it as active one

	    if (!this.types) {
	      this.types = {
	        "default": this.type
	      };
	      this.type.name = "default";
	    }

	    this.type = clone(this.type);
	  },
	  customize: function (obj) {
	    type(this, obj);
	  },
	  item_setter: function (value) {
	    return this.type_setter(value);
	  },
	  type_setter: function (value) {
	    if (!this.types[value]) this.customize(value);else {
	      this.type = clone(this.types[value]);
	      if (this.type.css) this._contentobj.className += " " + this.type.css;
	    }
	    if (this.type.on_click) exports.extend(this.on_click, this.type.on_click);
	    return value;
	  },
	  template_setter: function (value) {
	    this.type.template = template(value);
	  },
	  //convert single item to HTML text (templating)
	  _toHTML: function (obj) {
	    var mark = this.data._marks[obj.id]; //check if related template exist

	    assert(!obj.$template || this.type["template" + obj.$template], "RenderStack :: Unknown template: " + obj.$template);
	    this.callEvent("onItemRender", [obj]);
	    return this.type.templateStart(obj, this.type, mark) + (obj.$template ? this.type["template" + obj.$template] : this.type.template)(obj, this.type, mark) + this.type.templateEnd(obj, this.type, mark);
	  },
	  //convert item to HTML object (templating)
	  _toHTMLObject: function (obj) {
	    this._html.innerHTML = this._toHTML(obj);
	    return this._html.firstChild;
	  },
	  _render_change_id: function (old, newid) {
	    var obj = this.getItemNode(old);

	    if (obj) {
	      obj.setAttribute(this._id, newid);
	      this._htmlmap[newid] = this._htmlmap[old];
	      delete this._htmlmap[old];
	    }
	  },
	  //calls function that is set in onclick property
	  _call_onclick: function () {
	    if (this._settings.click) {
	      var code = toFunctor(this._settings.click, this.$scope);
	      if (code && code.call) code.apply(this, arguments);
	    }
	  },
	  //return html container by its ID
	  //can return undefined if container doesn't exists
	  getItemNode: function (search_id) {
	    if (this._htmlmap) return this._htmlmap[search_id]; //fill map if it doesn't created yet

	    this._htmlmap = {};
	    var t = this._dataobj.childNodes;

	    for (var i = 0; i < t.length; i++) {
	      var id = t[i].getAttribute(this._id); //get item's

	      if (id) this._htmlmap[id] = t[i];
	    } //call locator again, when map is filled


	    return this.getItemNode(search_id);
	  },
	  //return id of item from html event
	  locate: function (e) {
	    return locate(e, this._id);
	  },

	  /*change scrolling state of top level container, so related item will be in visible part*/
	  showItem: function (id) {
	    var html = this.getItemNode(id);

	    if (html && this.scrollTo) {
	      var txmin = html.offsetLeft;
	      var txmax = txmin + html.offsetWidth;
	      var tymin = html.offsetTop;
	      var tymax = tymin + html.offsetHeight;
	      var state = this.getScrollState();
	      var x = state.x;
	      if (x > txmin || x + this._content_width < txmax) x = txmin;
	      var y = state.y;
	      if (y > tymin || y + this._content_height < tymax) y = tymin;
	      this.scrollTo(x, y);
	      if (this._setItemActive) this._setItemActive(id);
	    }
	  },
	  //update view after data update
	  //method calls low-level rendering for related items
	  //when called without parameters - all view refreshed
	  render: function (id, data, type$$1) {
	    if (!this.isVisible(this._settings.id) || this.$blockRender) return;

	    if (id) {
	      var cont = this.getItemNode(id); //get html element of updated item

	      switch (type$$1) {
	        case "paint":
	        case "update":
	          //in case of update - replace existing html with updated one
	          if (!cont) return;

	          var t1 = this._htmlmap[id] = this._toHTMLObject(data);

	          insertBefore(t1, cont);
	          remove(cont);
	          break;

	        case "delete":
	          //in case of delete - remove related html
	          if (!cont) return;
	          remove(cont);
	          delete this._htmlmap[id];
	          break;

	        case "add":
	          //in case of add - put new html at necessary position
	          var t2 = this._htmlmap[id] = this._toHTMLObject(data);

	          insertBefore(t2, this.getItemNode(this.data.getNextId(id)), this._dataobj);
	          break;

	        case "move":
	          //moving without repainting the item
	          insertBefore(this.getItemNode(id), this.getItemNode(this.data.getNextId(id)), this._dataobj);
	          break;

	        default:
	          assert(0, "Unknown render command: " + type$$1);
	          break;
	      }
	    } else {
	      //full reset
	      if (this.callEvent("onBeforeRender", [this.data])) {
	        //getRange - returns all elements
	        (this._renderobj || this._dataobj).innerHTML = this.data.getRange().map(this._toHTML, this).join("");
	        this._htmlmap = null; //clear map, it will be filled at first getItemNode

	        this.callEvent("onAfterRender", []);
	      }
	    }
	  }
	};

	var Scrollable = {
	  $init: function (config) {
	    //do not spam unwanted scroll containers for templates 
	    if (config && !config.scroll && this._one_time_scroll) return this._dataobj = this._dataobj || this._contentobj;

	    (this._dataobj || this._contentobj).appendChild(create("DIV", {
	      "class": "webix_scroll_cont"
	    }, ""));

	    this._dataobj = (this._dataobj || this._contentobj).firstChild;
	    if (!env.touch || env.touch === "native") _event(this._viewobj, "scroll", bind(function () {
	      if (this.callEvent) delay(function () {
	        this.callEvent("onAfterScroll", []);
	      }, this);
	    }, this));
	  },

	  /*defaults:{
	  	scroll:true
	  },*/
	  scroll_setter: function (value) {
	    if (!value) return false;
	    var auto = value === "auto";
	    var marker = value == "x" ? "x" : value == "xy" ? "xy" : auto ? "xy" : "y";

	    if (Touch.$active && env.touch != "native") {
	      this._dataobj.setAttribute("touch_scroll", marker);

	      if (this.attachEvent) this.attachEvent("onAfterRender", bind(this._refresh_scroll, this));
	      this._touch_scroll = true;
	    } else {
	      if (env.$customScroll) {
	        temp$1.enable(this, marker);
	      } else {
	        var node = this._dataobj.parentNode.style;

	        if (auto) {
	          node.overflowX = node.overflowY = "auto";
	        } else {
	          if (marker.indexOf("x") != -1) {
	            this._scroll_x = true;
	            node.overflowX = "scroll";
	          }

	          if (marker.indexOf("y") != -1) {
	            this._scroll_y = true;
	            node.overflowY = "scroll";
	          }
	        }
	      }
	    }

	    return marker;
	  },
	  _onoff_scroll: function (mode, dir) {
	    if (!!this._settings.scroll == !!mode) return;

	    if (!env.$customScroll) {
	      var style = this._dataobj.parentNode.style;
	      style[dir === "x" ? "overflowX" : "overflowY"] = mode ? "auto" : "hidden";
	    }

	    if (dir === "x") {
	      this._scroll_x = mode;
	    } else {
	      this._scroll_y = mode;
	    }

	    this._settings.scroll = mode ? dir : false;
	  },
	  getScrollState: function () {
	    if (Touch.$active) {
	      var temp = Touch._get_matrix(this._dataobj);

	      return {
	        x: -temp.e,
	        y: -temp.f
	      };
	    } else return {
	      x: this._dataobj.parentNode.scrollLeft,
	      y: this._dataobj.parentNode.scrollTop
	    };
	  },
	  scrollTo: function (x, y) {
	    if (Touch.$active && env.touch != "native") {
	      y = Math.max(0, Math.min(y, this._dataobj.offsetHeight - this._content_height));
	      x = Math.max(0, Math.min(x, this._dataobj.offsetWidth - this._content_width));

	      Touch._set_matrix(this._dataobj, -x, -y, this._settings.scrollSpeed || "100ms");
	    } else {
	      this._dataobj.parentNode.scrollLeft = x;
	      this._dataobj.parentNode.scrollTop = y;
	    }
	  },
	  _refresh_scroll: function () {
	    if (this._settings.scroll.toString().indexOf("x") != -1) {
	      var x = this._dataobj.scrollWidth;

	      if (x) {
	        //in hidden state we will have a Zero scrollWidth
	        this._dataobj.style.width = "100%";
	        this._dataobj.style.width = this._dataobj.scrollWidth + "px";
	      }
	    }

	    if (Touch.$active && this._touch_scroll) {
	      Touch._clear_artefacts();

	      Touch._scroll_end();

	      var s = this.getScrollState();
	      var dx = this._dataobj.offsetWidth - this.$width - s.x;
	      var dy = this._dataobj.offsetHeight - this.$height - s.y; //if current scroll is outside of data area

	      if (dx < 0 || dy < 0) {
	        //scroll to the end of data area
	        var _x = dx < 0 ? Math.min(-dx - s.x, 0) : -s.x;

	        var y = dy < 0 ? Math.min(-dy - s.y, 0) : -s.y;

	        Touch._set_matrix(this._dataobj, _x, y, 0);
	      }
	    }
	  }
	};

	/*
		Behavior:SelectionModel - manage selection states
		@export
			select
			unselect
			selectAll
			unselectAll
			isSelected
			getSelectedId
	*/

	var SelectionModel = {
	  $init: function () {
	    //collection of selected IDs
	    this._selected = toArray();
	    assert(this.data, "SelectionModel :: Component doesn't have DataStore"); //remove selection from deleted items

	    this.data.attachEvent("onStoreUpdated", bind(this._data_updated, this));
	    this.data.attachEvent("onStoreLoad", bind(this._data_loaded, this));
	    this.data.attachEvent("onAfterFilter", bind(this._data_filtered, this));
	    this.data.attachEvent("onSyncApply", bind(this._select_check, this));
	    this.data.attachEvent("onIdChange", bind(this._id_changed, this));
	    this.$ready.push(this._set_noselect);
	  },
	  _set_noselect: function () {
	    if (this._settings.select == "multiselect" || this._settings.multiselect || this._settings.select == "area") _event(this.$view, "mousedown", function (e) {
	      var shiftKey = (e || event$1).shiftKey;

	      if (shiftKey) {
	        state._noselect_element = this;
	        addCss(this, "webix_noselect", 1);
	      }
	    });
	  },
	  _id_changed: function (oldid, newid) {
	    for (var i = this._selected.length - 1; i >= 0; i--) {
	      if (this._selected[i] == oldid) this._selected[i] = newid;
	    }
	  },
	  _data_filtered: function () {
	    for (var i = this._selected.length - 1; i >= 0; i--) {
	      if (this.data.getIndexById(this._selected[i]) < 0) {
	        var id = this._selected[i];
	        this.removeCss(id, "webix_selected", true);

	        this._selected.splice(i, 1);

	        this.callEvent("onSelectChange", [id]);
	      }
	    }
	  },
	  //helper - linked to onStoreUpdated
	  _data_updated: function (id, obj, type) {
	    if (type == "delete") {
	      //remove selection from deleted items
	      if (this.loadBranch) {
	        //hierarchy, need to check all
	        this._select_check();
	      } else this._selected.remove(id);
	    } else if (!id && !this.data.count() && !this.data._filter_order) {
	      //remove selection for clearAll
	      this._selected = toArray();
	    }
	  },
	  _data_loaded: function () {
	    if (this._settings.select) this.data.each(function (obj) {
	      if (obj && obj.$selected) this.select(obj.id);
	    }, this);
	  },
	  _select_check: function () {
	    for (var i = this._selected.length - 1; i >= 0; i--) {
	      if (!this.exists(this._selected[i])) this._selected.splice(i, 1);
	    }
	  },
	  //helper - changes state of selection for some item
	  _select_mark: function (id, state$$1, refresh, need_unselect) {
	    var sname = state$$1 ? "onBeforeSelect" : "onBeforeUnSelect";
	    if (!this.callEvent(sname, [id, state$$1])) return false;

	    if (need_unselect) {
	      this._silent_selection = true;
	      this.unselectAll();
	      this._silent_selection = false;
	    }

	    if (state$$1) this.addCss(id, "webix_selected", true);else this.removeCss(id, "webix_selected", true);
	    if (refresh) refresh.push(id); //if we in the mass-select mode - collect all changed IDs
	    else {
	        if (state$$1) this._selected.push(id); //then add to list of selected items
	        else this._selected.remove(id);

	        this._refresh_selection(id); //othervise trigger repainting

	      }
	    var ename = state$$1 ? "onAfterSelect" : "onAfterUnSelect";
	    this.callEvent(ename, [id]);
	    return true;
	  },
	  //select some item
	  select: function (id, preserve) {
	    var ctrlKey = arguments[2];
	    var shiftKey = arguments[3]; //if id not provide - works as selectAll

	    if (!id) return this.selectAll(); //allow an array of ids as parameter

	    if (isArray(id)) {
	      for (var i = 0; i < id.length; i++) {
	        this.select(id[i], i ? 1 : preserve, ctrlKey, shiftKey);
	      }

	      return;
	    }

	    assert(this.data.exists(id), "Incorrect id in select command: " + id); //block selection mode

	    if (shiftKey && this._selected.length) return this.selectAll(this._selected[this._selected.length - 1], id); //single selection mode

	    var need_unselect = false;
	    if (!ctrlKey && !preserve && (this._selected.length != 1 || this._selected[0] != id)) need_unselect = true;

	    if (!need_unselect && this.isSelected(id)) {
	      if (ctrlKey) this.unselect(id); //ctrl-selection of already selected item

	      return;
	    }

	    this._select_mark(id, true, null, need_unselect);
	  },
	  //unselect some item
	  unselect: function (id) {
	    //if id is not provided  - unselect all items
	    if (!id) return this.unselectAll();
	    if (!this.isSelected(id)) return;

	    this._select_mark(id, false);
	  },
	  //select all items, or all in defined range
	  selectAll: function (from, to) {
	    var range;
	    var refresh = [];
	    if (from || to) range = this.data.getRange(from || null, to || null); //get limited set if bounds defined
	    else range = this.data.getRange(); //get all items in other case
	    //in case of paging - it will be current page only

	    range.each(function (obj) {
	      if (!this.data.getMark(obj.id, "webix_selected")) {
	        this._selected.push(obj.id);

	        this._select_mark(obj.id, true, refresh);
	      }
	    }, this); //repaint self

	    this._refresh_selection(refresh);
	  },
	  //remove selection from all items
	  unselectAll: function () {
	    var refresh = [];

	    this._selected.each(function (id) {
	      this._select_mark(id, false, refresh); //unmark selected only

	    }, this);

	    this._selected = toArray();

	    this._refresh_selection(refresh); //repaint self

	  },
	  //returns true if item is selected
	  isSelected: function (id) {
	    return this._selected.find(id) != -1;
	  },

	  /*
	  	returns ID of selected items or array of IDs
	  	to make result predictable - as_array can be used, 
	  		with such flag command will always return an array 
	  		empty array in case when no item was selected
	  */
	  getSelectedId: function (as_array) {
	    switch (this._selected.length) {
	      case 0:
	        return as_array ? [] : "";

	      case 1:
	        return as_array ? [this._selected[0]] : this._selected[0];

	      default:
	        return [].concat(this._selected);
	      //isolation
	    }
	  },
	  getSelectedItem: function (as_array) {
	    var sel = this.getSelectedId(true);

	    if (sel.length > 1 || as_array) {
	      for (var i = sel.length - 1; i >= 0; i--) {
	        sel[i] = this.getItem(sel[i]);
	      }

	      return sel;
	    } else if (sel.length) return this.getItem(sel[0]);
	  },
	  //detects which repainting mode need to be used
	  _is_mass_selection: function (obj) {
	    // crappy heuristic, but will do the job
	    return obj.length > 100 || obj.length > this.data.count / 2;
	  },
	  _refresh_selection: function (refresh) {
	    if (_typeof(refresh) != "object") refresh = [refresh];
	    if (!refresh.length) return; //nothing to repaint

	    if (this._is_mass_selection(refresh)) this.data.refresh(); //many items was selected - repaint whole view
	    else for (var i = 0; i < refresh.length; i++) {
	        //repaint only selected
	        this.render(refresh[i], this.data.getItem(refresh[i]), "update");
	      }
	    if (!this._silent_selection) this.callEvent("onSelectChange", [refresh]);
	  }
	};
	ready(function () {
	  event$1(document.body, "mouseup", function () {
	    if (state._noselect_element) {
	      removeCss(state._noselect_element, "webix_noselect");
	      state._noselect_element = null;
	    }
	  });
	});

	var color = {
	  _toHex: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"],
	  toHex: function (number, length) {
	    number = parseInt(number, 10);
	    var str = "";

	    while (number > 0) {
	      str = this._toHex[number % 16] + str;
	      number = Math.floor(number / 16);
	    }

	    while (str.length < length) {
	      str = "0" + str;
	    }

	    return str;
	  },
	  rgbToHex: function (rgb) {
	    var arr = [];
	    if (typeof rgb === "string") rgb.replace(/[\d+.]+/g, function (v) {
	      arr.push(parseFloat(v));
	    });else if (isArray(rgb)) arr = rgb; //transparent

	    if (arr[3] === 0) return "";
	    return arr.slice(0, 3).map(function (n) {
	      return color.toHex(Math.floor(n), 2);
	    }).join("");
	  },
	  hexToDec: function (hex) {
	    return parseInt(hex, 16);
	  },
	  toRgb: function (rgb) {
	    var r, g, b, rgbArr;

	    if (typeof rgb != "string") {
	      r = rgb[0];
	      g = rgb[1];
	      b = rgb[2];
	    } else if (rgb.indexOf("rgb") != -1) {
	      rgbArr = rgb.substr(rgb.indexOf("(") + 1, rgb.lastIndexOf(")") - rgb.indexOf("(") - 1).split(",");
	      r = rgbArr[0];
	      g = rgbArr[1];
	      b = rgbArr[2];
	    } else {
	      if (rgb.substr(0, 1) == "#") {
	        rgb = rgb.substr(1);
	      }

	      r = this.hexToDec(rgb.substr(0, 2));
	      g = this.hexToDec(rgb.substr(2, 2));
	      b = this.hexToDec(rgb.substr(4, 2));
	    }

	    r = parseInt(r, 10) || 0;
	    g = parseInt(g, 10) || 0;
	    b = parseInt(b, 10) || 0;
	    if (r < 0 || r > 255) r = 0;
	    if (g < 0 || g > 255) g = 0;
	    if (b < 0 || b > 255) b = 0;
	    return [r, g, b];
	  },
	  hsvToRgb: function (h, s, v) {
	    var hi, f, p, q, t, r, g, b;
	    hi = Math.floor(h / 60) % 6;
	    f = h / 60 - hi;
	    p = v * (1 - s);
	    q = v * (1 - f * s);
	    t = v * (1 - (1 - f) * s);
	    r = 0;
	    g = 0;
	    b = 0;

	    switch (hi) {
	      case 0:
	        r = v;
	        g = t;
	        b = p;
	        break;

	      case 1:
	        r = q;
	        g = v;
	        b = p;
	        break;

	      case 2:
	        r = p;
	        g = v;
	        b = t;
	        break;

	      case 3:
	        r = p;
	        g = q;
	        b = v;
	        break;

	      case 4:
	        r = t;
	        g = p;
	        b = v;
	        break;

	      case 5:
	        r = v;
	        g = p;
	        b = q;
	        break;

	      default:
	        break;
	    }

	    r = Math.floor(r * 255);
	    g = Math.floor(g * 255);
	    b = Math.floor(b * 255);
	    return [r, g, b];
	  },
	  rgbToHsv: function (r, g, b) {
	    var r0, g0, b0, min0, max0, s, h, v;
	    r0 = r / 255;
	    g0 = g / 255;
	    b0 = b / 255;
	    min0 = Math.min(r0, g0, b0);
	    max0 = Math.max(r0, g0, b0);
	    h = 0;
	    s = max0 === 0 ? 0 : 1 - min0 / max0;
	    v = max0;

	    if (max0 == min0) {
	      h = 0;
	    } else if (max0 == r0 && g0 >= b0) {
	      h = 60 * (g0 - b0) / (max0 - min0) + 0;
	    } else if (max0 == r0 && g0 < b0) {
	      h = 60 * (g0 - b0) / (max0 - min0) + 360;
	    } else if (max0 == g0) {
	      h = 60 * (b0 - r0) / (max0 - min0) + 120;
	    } else if (max0 == b0) {
	      h = 60 * (r0 - g0) / (max0 - min0) + 240;
	    }

	    return [h, s, v];
	  }
	};

	function joinAttributes(attrs) {
	  var result = " ";
	  if (attrs) for (var a in attrs) {
	    result += a + "=\"" + attrs[a] + "\" ";
	  }
	  return result;
	} // SVG


	var SVG = {};

	SVG.draw = function (content, width, height, css) {
	  var attrs = {
	    xmlns: "http://www.w3.org/2000/svg",
	    version: "1.1",
	    height: "100%",
	    width: "100%",
	    viewBox: "0 0 " + width + " " + height,
	    "class": css || ""
	  };
	  return "<svg " + joinAttributes(attrs) + ">" + content + "</svg>";
	};

	SVG.styleMap = {
	  "lineColor": "stroke",
	  "color": "fill"
	};

	SVG.group = function (path) {
	  return "<g>" + path + "</g>";
	};

	SVG._handlers = {
	  // MoveTo: {x:px,y:py}
	  "M": function (p) {
	    return " M " + p.x + " " + p.y;
	  },
	  // LineTo: {x:px,y:py}
	  "L": function (p) {
	    return " L " + p.x + " " + p.y;
	  },
	  // Curve: 3 points {x:px,y:py}: two control points and an end point
	  "C": function (cp0, cp1, p) {
	    return " C " + cp0.x + " " + cp0.y + " " + cp1.x + " " + cp1.y + " " + p.x + " " + p.y;
	  },
	  // Arc: center point {x:px,y:py}, radius, angle0, angle1
	  "A": function (p, radius, angle0, angle1) {
	    var x = p.x + Math.cos(angle1) * radius;
	    var y = p.y + Math.sin(angle1) * radius;
	    var bigCircle = angle1 - angle0 >= Math.PI;
	    return " A " + radius + " " + radius + " 0 " + (bigCircle ? 1 : 0) + " 1 " + x + " " + y;
	  }
	}; // points is an array of an array with two elements: {string} line type, {array}

	SVG.definePath = function (points, close) {
	  var path = "";

	  for (var i = 0; i < points.length; i++) {
	    assert(points[i][0] && typeof points[i][0] == "string", "Path type must be a string");
	    var type = points[i][0].toUpperCase();
	    assert(this._handlers[type], "Incorrect path type");
	    path += this._handlers[type].apply(this, points[i].slice(1));
	  }

	  if (close) path += " Z";
	  return path;
	};

	SVG._linePoints = function (points) {
	  var result = [];

	  for (var i = 0; i < points.length; i++) {
	    result.push([i ? "L" : "M", points[i]]);
	  }

	  return result;
	};

	SVG.setOpacity = function (rawColor, opacity) {
	  var rgbColor = color.toRgb(rawColor);
	  rgbColor.push(opacity);
	  return "rgba(" + rgbColor.join(",") + ")";
	};

	SVG._curvePoints = function (points) {
	  var result = [];

	  for (var i = 0; i < points.length; i++) {
	    var p = points[i];

	    if (!i) {
	      result.push(["M", p[0]]);
	    }

	    result.push(["C", p[1], p[2], p[3]]);
	  }

	  return result;
	};

	SVG.getPath = function (path, css, attrs) {
	  attrs = joinAttributes(attrs);
	  return "<path class=\"" + css + "\" vector-effect=\"non-scaling-stroke\" d=\"" + path + "\" " + attrs + "/>";
	};

	SVG.getSector = function (p, radius, angle0, angle1, css, attrs) {
	  attrs = joinAttributes(attrs);
	  var x0 = p.x + Math.cos(angle0) * radius;
	  var y0 = p.y + Math.sin(angle0) * radius;
	  var lines = [["M", p], ["L", {
	    x: x0,
	    y: y0
	  }], ["A", p, radius, angle0, angle1], ["L", p]];
	  return "<path class=\"" + css + "\" vector-effect=\"non-scaling-stroke\" d=\"" + SVG.definePath(lines, true) + "\" " + attrs + "/>";
	};

	SVG.getCurve = function (points, css, attrs) {
	  attrs = joinAttributes(attrs);
	  var path = this.definePath(this._curvePoints(points));
	  return "<path fill=\"none\" class=\"" + css + "\" vector-effect=\"non-scaling-stroke\" d=\"" + path + "\" " + attrs + "/>";
	};

	SVG.getLine = function (p0, p1, css, attrs) {
	  return this.getPath(this.definePath(this._linePoints([p0, p1]), true), css, attrs);
	};

	SVG.getCircle = function (p, radius, css, attrs) {
	  attrs = joinAttributes(attrs);
	  return "<circle class=\"" + css + "\" cx=\"" + p.x + "\" cy=\"" + p.y + "\" r=\"" + radius + "\" " + attrs + "/>";
	};

	SVG.getRect = function (x, y, width, height, css, attrs) {
	  attrs = joinAttributes(attrs);
	  return "<rect class=\"" + css + "\" rx=\"0\" ry=\"0\" x=\"" + x + "\" y=\"" + y + "\" width=\"" + width + "\" height=\"" + height + "\" " + attrs + "/>";
	};

	var defaults = {
	  paddingX: 6,
	  paddingY: 6,
	  radius: 2,
	  minHeight: 4,
	  eventRadius: 8
	};

	function Line(config) {
	  this.config = exports.extend(copy(defaults), config || {}, true);
	}

	Line.prototype.draw = function (data, width, height) {
	  var points = this.getPoints(data, width, height);
	  var config = this.config;
	  var renderer = SVG;
	  var styles = config.color ? this._applyColor(renderer, config.color) : null; // draw line

	  var path = renderer.definePath(this._getLinePoints(points));
	  var graph = renderer.group(renderer.getPath(path, "webix_sparklines_line" + (styles ? " " + styles.line : ""))); // draw items

	  graph += this._drawItems(renderer, points, config.radius, "webix_sparklines_item" + (styles ? " " + styles.item : "")); // draw event items

	  var eventRadius = Math.min(data.length ? (width - 2 * (config.paddingX || 0)) / data.length : 0, config.eventRadius);
	  graph += this._drawEventItems(renderer, points, eventRadius);
	  return renderer.draw(graph, width, height, "webix_sparklines_line_chart" + (config.css ? " " + config.css : ""));
	};

	Line.prototype._applyColor = function (renderer, color) {
	  var config = {
	    "line": {},
	    "item": {}
	  },
	      map = renderer.styleMap;

	  if (color) {
	    config.line[map.lineColor] = color;
	    config.item[map.color] = color;

	    for (var name in config) {
	      config[name] = createCss(config[name]);
	    }
	  }

	  return config;
	};

	Line.prototype._drawItems = function (renderer, points, radius, css, attrs) {
	  var items = [];

	  for (var i = 0; i < points.length; i++) {
	    items.push(renderer.getCircle(points[i], radius, css, attrs));
	  }

	  return renderer.group(items.join(""));
	};

	Line.prototype._drawEventItems = function (renderer, points, radius) {
	  var items = [];

	  for (var i = 0; i < points.length; i++) {
	    items.push(renderer.getCircle(points[i], radius, "webix_sparklines_event_area", {
	      webix_area: i
	    }));
	  }

	  return renderer.group(items.join(""));
	};

	Line.prototype._getLinePoints = function (points) {
	  var i,
	      type,
	      result = [];

	  for (i = 0; i < points.length; i++) {
	    type = i ? "L" : "M";
	    result.push([type, points[i]]);
	  }

	  return result;
	};

	Line.prototype.getPoints = function (data, width, height) {
	  var config = this.config;
	  var minValue = Math.min.apply(null, data);
	  if (typeof config.origin !== "undefined") minValue = Math.min(config.origin, minValue);
	  var maxValue = Math.max.apply(null, data);
	  var result = [];
	  var x = config.paddingX || 0;
	  var y = config.paddingY || 0;
	  width = (width || 100) - x * 2;
	  var minHeight = config.minHeight || 0;
	  height = (height || 100) - y * 2;

	  if (data.length) {
	    if (data.length == 1) result.push({
	      x: width / 2 + x,
	      y: height / 2 + x
	    });else {
	      var unitX = width / (data.length - 1);
	      var yNum = config.scale || maxValue - minValue;
	      var unitY = (height - minHeight) / (yNum ? yNum : 1);
	      if (!yNum) height /= 2;

	      for (var i = 0; i < data.length; i++) {
	        result.push({
	          x: Math.ceil(unitX * i) + x,
	          y: height - Math.ceil(unitY * (data[i] - minValue)) + y - minHeight
	        });
	      }
	    }
	  }

	  return result;
	};

	var defaults$1 = {
	  paddingX: 3,
	  paddingY: 4,
	  radius: 1,
	  minHeight: 4,
	  eventRadius: 8
	};

	function Area(config) {
	  this.config = exports.extend(copy(defaults$1), config || {}, true);
	}

	Area.prototype.draw = function (data, width, height) {
	  var eventRadius,
	      graph,
	      path,
	      points,
	      styles,
	      config = this.config,
	      Line$$1 = Line.prototype,
	      renderer = SVG; // draw area

	  points = this.getPoints(data, width, height);
	  path = renderer.definePath(Line$$1._getLinePoints(points), true);
	  if (config.color) styles = this._applyColor(renderer, config.color);
	  graph = renderer.group(renderer.getPath(path, "webix_sparklines_area" + (styles ? " " + styles.area : ""))); // draw line

	  points.splice(points.length - 3, 3);
	  path = renderer.definePath(Line$$1._getLinePoints(points));
	  graph += renderer.group(renderer.getPath(path, "webix_sparklines_line" + (styles ? " " + styles.line : ""))); // draw items

	  graph += Line$$1._drawItems(renderer, points, config.radius, "webix_sparklines_item" + (styles ? " " + styles.item : "")); // draw event areas

	  eventRadius = Math.min(data.length ? (width - 2 * (config.paddingX || 0)) / data.length : 0, config.eventRadius);
	  graph += Line$$1._drawEventItems(renderer, points, eventRadius);
	  return renderer.draw(graph, width, height, "webix_sparklines_area_chart" + (config.css ? " " + config.css : ""));
	};

	Area.prototype._applyColor = function (renderer, color) {
	  var config = {
	    "area": {},
	    "line": {},
	    "item": {}
	  },
	      map = renderer.styleMap;

	  if (color) {
	    config.area[map.color] = renderer.setOpacity(color, 0.2);
	    config.line[map.lineColor] = color;
	    config.item[map.color] = color;

	    for (var name in config) {
	      config[name] = createCss(config[name]);
	    }
	  }

	  return config;
	};

	Area.prototype.getPoints = function (data, width, height) {
	  var Line$$1 = Line.prototype;
	  var points = Line$$1.getPoints.call(this, data, width, height);
	  var x = this.config.paddingX || 0;
	  var y = this.config.paddingY || 0;
	  points.push({
	    x: width - x,
	    y: height - y
	  }, {
	    x: x,
	    y: height - y
	  }, {
	    x: x,
	    y: points[0].y
	  });
	  return points;
	};

	var defaults$2 = {
	  paddingX: 3,
	  paddingY: 4,
	  width: 20,
	  margin: 4,
	  minHeight: 4,
	  eventRadius: 8,
	  origin: 0,
	  itemCss: function (value) {
	    return value < (this.config.origin || 0) ? " webix_sparklines_bar_negative" : "";
	  }
	};

	function Bar(config) {
	  this.config = exports.extend(copy(defaults$2), config || {}, true);
	}

	Bar.prototype.draw = function (data, width, height) {
	  var i,
	      css,
	      p,
	      y,
	      padding,
	      config = this.config,
	      graph = "",
	      items = [],
	      points = this.getPoints(data, width, height),
	      renderer = SVG; // draw bars

	  for (i = 0; i < points.length; i++) {
	    css = typeof config.itemCss == "function" ? config.itemCss.call(this, data[i]) : config.itemCss || "";
	    if (config.negativeColor && data[i] < config.origin) css += " " + this._applyColor(renderer, config.negativeColor);else if (config.color) css += " " + this._applyColor(renderer, config.color);
	    p = points[i];
	    items.push(renderer.getRect(p.x, p.y, p.width, p.height, "webix_sparklines_bar " + css));
	  }

	  graph += renderer.group(items.join("")); // origin)

	  y = parseInt(this._getOrigin(data, width, height), 10) + 0.5;
	  padding = config.paddingX || 0;
	  graph += renderer.group(renderer.getLine({
	    x: padding,
	    y: y
	  }, {
	    x: width - padding,
	    y: y
	  }, "webix_sparklines_origin")); // event areas

	  var evPoints = this._getEventPoints(data, width, height);

	  var evItems = [];

	  for (i = 0; i < evPoints.length; i++) {
	    p = evPoints[i];
	    evItems.push(renderer.getRect(p.x, p.y, p.width, p.height, "webix_sparklines_event_area ", {
	      "webix_area": i
	    }));
	  }

	  graph += renderer.group(evItems.join(""));
	  return renderer.draw(graph, width, height, "webix_sparklines_bar_chart" + (config.css ? " " + config.css : ""));
	};

	Bar.prototype._applyColor = function (renderer, color) {
	  var config = {},
	      map = renderer.styleMap;
	  if (color) config[map.color] = color;
	  return createCss(config);
	};

	Bar.prototype._getOrigin = function (data, width, height) {
	  var config = this.config;
	  var y = config.paddingY || 0;
	  height = (height || 100) - y * 2;
	  var pos$$1 = y + height;

	  if (config.origin !== false) {
	    var minValue = Math.min.apply(null, data);
	    var maxValue = Math.max.apply(null, data);
	    var origin = config.origin || -0.000001;

	    if (origin >= maxValue) {
	      pos$$1 = y;
	    } else if (origin > minValue) {
	      var unitY = height / (maxValue - minValue);
	      pos$$1 -= unitY * (origin - minValue);
	    }
	  }

	  return pos$$1;
	};

	Bar.prototype._getEventPoints = function (data, width, height) {
	  var result = [];
	  var x = this.config.paddingX || 0;
	  var y = this.config.paddingY || 0;
	  width = (width || 100) - x * 2;
	  height = (height || 100) - y * 2;

	  if (data.length) {
	    var unitX = width / data.length;

	    for (var i = 0; i < data.length; i++) {
	      result.push({
	        x: Math.ceil(unitX * i) + x,
	        y: y,
	        height: height,
	        width: unitX
	      });
	    }
	  }

	  return result;
	};

	Bar.prototype.getPoints = function (data, width, height) {
	  var config = this.config;
	  var minValue = Math.min.apply(null, data);
	  if (config.origin < minValue) minValue = config.origin;
	  var maxValue = Math.max.apply(null, data);
	  var result = [];
	  var x = config.paddingX;
	  var y = config.paddingY;
	  var margin = config.margin;
	  var barWidth = config.width || 20;

	  var originY = this._getOrigin(data, width, height);

	  width = (width || 100) - x * 2;
	  height = (height || 100) - y * 2;

	  if (data.length) {
	    var unitX = width / data.length;
	    var yNum = config.scale || maxValue - minValue;
	    barWidth = Math.min(unitX - margin, barWidth);
	    margin = unitX - barWidth;
	    var minHeight = 0;
	    var origin = minValue;
	    if (config.origin !== false && config.origin > minValue) origin = config.origin || 0;else minHeight = config.minHeight;
	    var unitY = (height - minHeight) / (yNum ? yNum : 1);

	    for (var i = 0; i < data.length; i++) {
	      var h = Math.ceil(unitY * (data[i] - origin));
	      result.push({
	        x: Math.ceil(unitX * i) + x + margin / 2,
	        y: originY - (data[i] >= origin ? h : 0) - minHeight,
	        height: Math.abs(h) + minHeight,
	        width: barWidth
	      });
	    }
	  }

	  return result;
	};

	var defaults$3 = {
	  paddingY: 2
	};

	function Pie(config) {
	  this.config = exports.extend(defaults$3, config || {}, true);
	}

	Pie.prototype._defColorsCursor = 0;
	Pie.prototype._defColors = ["#f55b50", "#ff6d3f", "#ffa521", "#ffc927", "#ffee54", "#d3e153", "#9acb61", "#63b967", "#21a497", "#21c5da", "#3ea4f5", "#5868bf", "#7b53c0", "#a943ba", "#ec3b77", "#9eb0b8"];

	Pie.prototype._getColor = function (i, data) {
	  var count = data.length;
	  var colorsCount = this._defColors.length;

	  if (colorsCount > count) {
	    if (i) {
	      if (i < colorsCount - count) i = this._defColorsCursor + 2;else i = this._defColorsCursor + 1;
	    }

	    this._defColorsCursor = i;
	  } else i = i % colorsCount;

	  return this._defColors[i];
	};

	Pie.prototype.draw = function (data, width, height) {
	  var attrs,
	      graph,
	      i,
	      sectors,
	      config = this.config,
	      color = config.color || this._getColor,
	      points = this.getAngles(data),
	      renderer = SVG,
	      y = config.paddingY || 0,
	      // radius
	  r = height / 2 - y,
	      // center
	  x0 = width / 2,
	      y0 = height / 2; // draw sectors

	  if (typeof color != "function") color = function () {
	    return color;
	  };
	  sectors = "";

	  for (i = 0; i < points.length; i++) {
	    attrs = {};
	    attrs[renderer.styleMap["color"]] = color.call(this, i, data, this._context);
	    sectors += renderer.getSector({
	      x: x0,
	      y: y0
	    }, r, points[i][0], points[i][1], "webix_sparklines_sector", attrs);
	  }

	  graph = renderer.group(sectors); // draw event areas

	  sectors = "";

	  for (i = 0; i < points.length; i++) {
	    sectors += renderer.getSector({
	      x: x0,
	      y: y0
	    }, r, points[i][0], points[i][1], "webix_sparklines_event_area", {
	      "webix_area": i
	    });
	  }

	  graph += renderer.group(sectors);
	  return renderer.draw(graph, width, height, "webix_sparklines_pie_chart" + (config.css ? " " + config.css : ""));
	};

	Pie.prototype.getAngles = function (data) {
	  var a0 = -Math.PI / 2,
	      a1,
	      i,
	      result = [];

	  var ratios = this._getRatios(data);

	  for (i = 0; i < data.length; i++) {
	    a1 = -Math.PI / 2 + ratios[i] - 0.0001;
	    result.push([a0, a1]);
	    a0 = a1;
	  }

	  return result;
	};

	Pie.prototype._getTotalValue = function (data) {
	  var t = 0;

	  for (var i = 0; i < data.length; i++) {
	    t += data[i] * 1;
	  }

	  return t;
	};

	Pie.prototype._getRatios = function (data) {
	  var i,
	      value,
	      ratios = [],
	      prevSum = 0,
	      totalValue = this._getTotalValue(data);

	  for (i = 0; i < data.length; i++) {
	    value = data[i] * 1;
	    ratios[i] = Math.PI * 2 * (totalValue ? (value + prevSum) / totalValue : 1 / data.length);
	    prevSum += value;
	  }

	  return ratios;
	};

	var defaults$4 = {
	  paddingX: 3,
	  paddingY: 6,
	  radius: 2,
	  minHeight: 4,
	  eventRadius: 8
	};

	function Spline(config) {
	  this.config = exports.extend(copy(defaults$4), config || {}, true);
	}

	Spline.prototype.draw = function (data, width, height) {
	  var config = this.config,
	      graph = "",
	      Line$$1 = Line.prototype,
	      points = this.getPoints(data, width, height),
	      renderer = SVG,
	      styles = config.color ? this._applyColor(renderer, config.color) : null; // draw spline

	  graph += renderer.group(renderer.getCurve(points, "webix_sparklines_line" + (styles ? " " + styles.line : "")));
	  var linePoints = Line$$1.getPoints.call(this, data, width, height); // draw items

	  graph += Line$$1._drawItems(renderer, linePoints, config.radius, "webix_sparklines_item" + (styles ? " " + styles.item : "")); // draw event items

	  var eventRadius = Math.min(data.length ? (width - 2 * (config.paddingX || 0)) / data.length : 0, config.eventRadius);
	  graph += Line$$1._drawEventItems(renderer, linePoints, eventRadius);
	  return renderer.draw(graph, width, height, "webix_sparklines_line_chart" + (config.css ? " " + config.css : ""));
	};

	Spline.prototype._applyColor = function (renderer, color) {
	  var config = {
	    "line": {},
	    "item": {}
	  },
	      map = renderer.styleMap;

	  if (color) {
	    config.line[map.lineColor] = color;
	    config.item[map.color] = color;

	    for (var name in config) {
	      config[name] = createCss(config[name]);
	    }
	  }

	  return config;
	};

	Spline.prototype.getPoints = function (data, width, height) {
	  var i,
	      points,
	      px,
	      py,
	      result = [],
	      x = [],
	      y = [],
	      Line$$1 = Line.prototype;
	  points = Line$$1.getPoints.call(this, data, width, height);

	  for (i = 0; i < points.length; i++) {
	    x.push(points[i].x);
	    y.push(points[i].y);
	  }

	  px = this._getControlPoints(x);
	  py = this._getControlPoints(y);
	  /*updates path settings, the browser will draw the new spline*/

	  for (i = 0; i < points.length - 1; i++) {
	    result.push([points[i], {
	      x: px[0][i],
	      y: py[0][i]
	    }, {
	      x: px[1][i],
	      y: py[1][i]
	    }, points[i + 1]]);
	  }

	  return result;
	};
	/* code from https://www.particleincell.com/2012/bezier-splines/ */


	Spline.prototype._getControlPoints = function (points) {
	  var a = [],
	      b = [],
	      c = [],
	      r = [],
	      p1 = [],
	      p2 = [],
	      i,
	      m,
	      n = points.length - 1;
	  a[0] = 0;
	  b[0] = 2;
	  c[0] = 1;
	  r[0] = points[0] + 2 * points[1];

	  for (i = 1; i < n - 1; i++) {
	    a[i] = 1;
	    b[i] = 4;
	    c[i] = 1;
	    r[i] = 4 * points[i] + 2 * points[i + 1];
	  }

	  a[n - 1] = 2;
	  b[n - 1] = 7;
	  c[n - 1] = 0;
	  r[n - 1] = 8 * points[n - 1] + points[n];

	  for (i = 1; i < n; i++) {
	    m = a[i] / b[i - 1];
	    b[i] = b[i] - m * c[i - 1];
	    r[i] = r[i] - m * r[i - 1];
	  }

	  p1[n - 1] = r[n - 1] / b[n - 1];

	  for (i = n - 2; i >= 0; --i) {
	    p1[i] = (r[i] - c[i] * p1[i + 1]) / b[i];
	  }

	  for (i = 0; i < n - 1; i++) {
	    p2[i] = 2 * points[i + 1] - p1[i + 1];
	  }

	  p2[n - 1] = 0.5 * (points[n] + p1[n - 1]);
	  return [p1, p2];
	};

	var defaultsArea = {
	  paddingX: 3,
	  paddingY: 6,
	  radius: 1,
	  minHeight: 4,
	  eventRadius: 8
	}; // spline area

	function SplineArea(config) {
	  this.config = exports.extend(copy(defaultsArea), config || {}, true);
	}

	SplineArea.prototype = copy(Spline.prototype);

	SplineArea.prototype.draw = function (data, width, height) {
	  var config = this.config,
	      Line$$1 = Line.prototype,
	      renderer = SVG,
	      styles = config.color ? this._applyColor(renderer, config.color) : null;
	  var points = this.getPoints(data, width, height); // draw area

	  var linePoints = points.splice(points.length - 3, 3);

	  var linePath = renderer._linePoints(linePoints);

	  linePath[0][0] = "L";

	  var areaPoints = renderer._curvePoints(points).concat(linePath);

	  var graph = renderer.group(renderer.getPath(renderer.definePath(areaPoints), "webix_sparklines_area" + (styles ? " " + styles.area : ""), true)); // draw line

	  graph += renderer.group(renderer.getPath(renderer.definePath(renderer._curvePoints(points)), "webix_sparklines_line" + (styles ? " " + styles.line : "")));
	  var itemPoints = Line$$1.getPoints.call(this, data, width, height); // draw items

	  graph += Line$$1._drawItems(renderer, itemPoints, config.radius, "webix_sparklines_item" + (styles ? " " + styles.item : "")); // draw event items

	  var eventRadius = Math.min(data.length ? (width - 2 * (config.paddingX || 0)) / data.length : 0, config.eventRadius);
	  graph += Line$$1._drawEventItems(renderer, itemPoints, eventRadius);
	  return renderer.draw(graph, width, height, "webix_sparklines_splinearea_chart" + (config.css ? " " + config.css : ""));
	};

	SplineArea.prototype._applyColor = function (renderer, color) {
	  var config = {
	    "area": {},
	    "line": {},
	    "item": {}
	  },
	      map = renderer.styleMap;

	  if (color) {
	    config.area[map.color] = renderer.setOpacity(color, 0.2);
	    config.line[map.lineColor] = color;
	    config.item[map.color] = color;

	    for (var name in config) {
	      config[name] = createCss(config[name]);
	    }
	  }

	  return config;
	};

	SplineArea.prototype.getPoints = function (data, width, height) {
	  var points = Spline.prototype.getPoints.call(this, data, width, height);
	  var x = this.config.paddingX || 0;
	  var y = this.config.paddingY || 0;
	  points.push({
	    x: width - x,
	    y: height - y
	  }, {
	    x: x,
	    y: height - y
	  }, {
	    x: x,
	    y: points[0][0].y
	  });
	  return points;
	};

	function Sparklines() {}

	function getData(data) {
	  var values = [];

	  for (var i = data.length - 1; i >= 0; i--) {
	    var value = data[i];
	    values[i] = _typeof(value) === "object" ? value.value : value;
	  }

	  return values;
	}

	Sparklines.types = {};

	Sparklines.getTemplate = function (customConfig) {
	  var config = customConfig || {};
	  if (typeof customConfig == "string") config = {
	    type: customConfig
	  };
	  exports.extend(config, {
	    type: "line"
	  });
	  var slConstructor = this.types[config.type];
	  assert(slConstructor, "Unknown sparkline type");
	  return bind(this._template, new slConstructor(config));
	};

	Sparklines._template = function (item, common, data, column) {
	  if (column) return this.draw(getData(data), column.width, 33);else return this.draw(item.data || item, common.width, common.height);
	}; // add "sparklines" type


	attachEvent("onDataTable", function (table) {
	  table.type.sparklines = Sparklines.getTemplate();
	});
	Sparklines.types["area"] = Area;
	Sparklines.types["bar"] = Bar;
	Sparklines.types["line"] = Line;
	Sparklines.types["pie"] = Pie;
	Sparklines.types["spline"] = Spline;
	Sparklines.types["splineArea"] = SplineArea;

	var csv$1 = {
	  escape: true,
	  delimiter: {
	    rows: "\n",
	    cols: "\t"
	  },
	  parse: function (text, sep) {
	    sep = sep || this.delimiter;
	    if (!this.escape) return this._split_clip_data(text, sep);
	    var lines = text.replace(/\n$/, "").split(sep.rows);
	    var i = 0;

	    while (i < lines.length - 1) {
	      if (this._substr_count(lines[i], "\"") % 2 === 1) {
	        lines[i] += sep.rows + lines[i + 1];
	        delete lines[i + 1];
	        i++;
	      }

	      i++;
	    }

	    var csv = [];

	    for (i = 0; i < lines.length; i++) {
	      if (typeof lines[i] !== "undefined") {
	        var tline = lines[i];
	        var start = 0;
	        var line = [];
	        var quoted = false;

	        for (var j = 0; j <= tline.length; j++) {
	          if (!quoted && tline[j] === sep.cols || j === tline.length) {
	            var chunk = tline.substr(start, j - start);

	            if (chunk[0] === chunk[chunk.length - 1] && chunk[0] === "\"") {
	              chunk = chunk.substr(1, chunk.length - 2).replace("\"\"", "\"");
	            }

	            line.push(chunk);
	            start = j + 1;
	          }

	          if (tline[j] === "\"") {
	            quoted = !quoted;
	            continue;
	          }
	        }

	        csv.push(line);
	      }
	    }

	    return csv;
	  },
	  _split_clip_data: function (text, sep) {
	    var lines = text.split(sep.rows);

	    for (var i = 0; i < lines.length; i++) {
	      lines[i] = lines[i].split(sep.cols);
	    }

	    return lines;
	  },

	  /*! counts how many occurances substring in string **/
	  _substr_count: function (string, substring) {
	    var arr = string.split(substring);
	    return arr.length - 1;
	  },
	  stringify: function (data, sep) {
	    sep = sep || this.delimiter;

	    if (!this.escape) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = data[i].join(sep.cols);
	      }

	      return data.join(sep.rows);
	    }

	    var reg = /\n|"|;|,/;

	    for (var _i = 0; _i < data.length; _i++) {
	      for (var j = 0; j < data[_i].length; j++) {
	        var chunk = data[_i][j];
	        if (chunk instanceof Date) data[_i][j] = i18n.parseFormatStr(chunk);else if (reg.test(chunk)) data[_i][j] = "\"" + chunk.toString().replace(/"/g, "\"\"") + "\"";
	      }

	      data[_i] = data[_i].join(sep.cols);
	    }

	    data = data.join(sep.rows);
	    return data;
	  }
	};

	var TablePaste = {
	  clipboard_setter: function (value) {
	    if (value === true || value === 1) value = "block";
	    clipbuffer.init();
	    this.attachEvent("onSelectChange", this._sel_to_clip); // solution for clicks on selected items

	    this.attachEvent("onItemClick", function () {
	      if (document.activeElement && this.$view.contains(document.activeElement)) {
	        clipbuffer.focus();
	        UIManager.setFocus(this);
	      }
	    });
	    this.attachEvent("onPaste", this._clip_to_sel);
	    return value;
	  },
	  templateCopy_setter: template,
	  _sel_to_clip: function () {
	    var data = this._get_sel_text();

	    clipbuffer.set(data);
	    UIManager.setFocus(this);
	  },
	  _get_sel_text: function () {
	    var data = [];
	    var filter = this._settings.templateCopy;
	    this.mapSelection(function (value, row, col, row_ind) {
	      if (!data[row_ind]) data[row_ind] = [];
	      var newvalue = filter ? filter(value, row, col) : value;
	      data[row_ind].push(newvalue);
	      return value;
	    });
	    var value = data.length === 1 && data[0].length === 1 ? data[0][0] : csv$1.stringify(data, this._settings.delimiter);
	    return value;
	  },
	  _clip_to_sel: function (text) {
	    if (!isUndefined(this._paste[this._settings.clipboard])) {
	      var data = csv$1.parse(text, this._settings.delimiter);

	      this._paste[this._settings.clipboard].call(this, data);
	    }
	  },
	  _paste: {
	    block: function (data) {
	      var leftTop = this.mapSelection(null);
	      if (!leftTop) return; // filling cells with data

	      this.mapCells(leftTop.row, leftTop.column, data.length, null, function (value, row, col, row_ind, col_ind) {
	        if (data[row_ind] && data[row_ind].length > col_ind) {
	          return data[row_ind][col_ind];
	        }

	        return value;
	      });
	      this.render();
	    },
	    selection: function (data) {
	      this.mapSelection(function (value, row, col, row_ind, col_ind) {
	        if (data[row_ind] && data[row_ind].length > col_ind) return data[row_ind][col_ind];
	        return value;
	      });
	      this.render();
	    },
	    repeat: function (data) {
	      this.mapSelection(function (value, row, col, row_ind, col_ind) {
	        row = data[row_ind % data.length];
	        value = row[col_ind % row.length];
	        return value;
	      });
	      this.render();
	    },
	    custom: function () {}
	  }
	};

	var TreeAPI = {
	  open: function (id, show) {
	    if (!id) return; //ignore open for leaf items

	    var item = this.getItem(id);
	    assert(item, "Incorrect ID to open: " + id);
	    if (!item.$count || item.open) return;

	    if (this.callEvent("onBeforeOpen", [id])) {
	      item.open = true;
	      this.data.callEvent("onStoreUpdated", [id, 0, "branch"]);
	      this.callEvent("onAfterOpen", [id]);
	    }

	    if (show && id != "0") this.open(this.getParentId(id), show);
	  },
	  close: function (id) {
	    if (!id) return;
	    var item = this.getItem(id);
	    if (!item.open) return;

	    if (this.callEvent("onBeforeClose", [id])) {
	      item.open = false;
	      this.data.callEvent("onStoreUpdated", [id, 0, "branch"]);
	      this.callEvent("onAfterClose", [id]);
	    }
	  },
	  openAll: function (id) {
	    this.data.eachSubItem(id || 0, function (obj, branch) {
	      if (branch) obj.open = true;
	    });
	    this.data.refresh();
	  },
	  closeAll: function (id) {
	    this.data.eachSubItem(id || 0, function (obj, branch) {
	      if (branch) obj.open = false;
	    });
	    this.data.refresh();
	  },
	  _tree_check_uncheck: function (id, mode, e) {
	    if (this._settings.threeState) return this._tree_check_uncheck_3(id, mode !== null ? mode : "");
	    var value,
	        item = this.getItem(id),
	        trg = e ? e.target || e.srcElement : null; //read actual value from HTML tag when possible
	    //as it can be affected by dbl-clicks

	    if (trg && trg.type == "checkbox") value = trg.checked ? true : false;else value = mode !== null ? mode : !item.checked;
	    item.checked = value;
	    this.callEvent("onItemCheck", [id, item.checked, e]);
	  },
	  isBranchOpen: function (search_id) {
	    if (search_id == "0") return true;
	    var item = this.getItem(search_id);
	    if (item.open) return this.isBranchOpen(item.$parent);
	    return false;
	  },
	  getOpenItems: function () {
	    var open = [];

	    for (var id in this.data.branch) {
	      if (this.exists(id) && this.getItem(id).open) open.push(id);
	    }

	    return open;
	  },
	  getState: function () {
	    return {
	      open: this.getOpenItems(),
	      select: this.getSelectedId(true)
	    };
	  },
	  _repeat_set_state: function (tree, open) {
	    var event = this.data.attachEvent("onStoreLoad", function () {
	      tree.setState.call(tree, open);
	      tree.data.detachEvent(event);
	      tree = null;
	    });
	  },
	  setState: function (state) {
	    if (state.open) {
	      this.closeAll();
	      var open = state.open;

	      for (var i = 0; i < open.length; i++) {
	        var item = this.getItem(open[i]);

	        if (item && item.$count) {
	          item.open = true; //dynamic loading

	          if (item.$count == -1) {
	            //call the same method after data loading
	            this._repeat_set_state(this, state);

	            this.refresh();
	            return 0; //end processing
	          }
	        }
	      }

	      this.refresh();
	    }

	    if (state.select && this.select) {
	      var select = state.select;
	      this.unselect();

	      for (var _i = 0; _i < select.length; _i++) {
	        if (this.exists(select[_i])) this.select(select[_i], true);
	      }
	    }

	    return 1;
	  }
	};

	var TreeClick = {
	  webix_tree_open: function (e, id) {
	    this.close(id);
	    return false;
	  },
	  webix_tree_close: function (e, id) {
	    this.open(id);
	    return false;
	  },
	  webix_tree_checkbox: function (e, id) {
	    this._tree_check_uncheck(id, null, e);

	    return false;
	  }
	};

	var TreeDataLoader = {
	  $init: function () {
	    this.data.attachEvent("onStoreUpdated", bind(this._sync_hierarchy, this), null, true); //redefine methods

	    this._feed_common = this._feed_commonA;
	  },
	  _feed_commonA: function (id, count, callback, url) {
	    // branch loading
	    var details = count === 0 ? {
	      parent: encodeURIComponent(id)
	    } : null;

	    DataLoader.prototype._feed_common.call(this, id, count, callback, url, details);
	  },
	  //load next set of data rows
	  loadBranch: function (id, callback, url) {
	    id = id || 0;
	    this.data.url = url || this.data.url;
	    if (this.callEvent("onDataRequest", [id, callback, this.data.url]) && this.data.url) this.data.feed.call(this, id, 0, callback, url);
	  },
	  _sync_hierarchy: function (id, data, mode) {
	    if (!mode || mode == "add" || mode == "delete" || mode == "branch") {
	      this.data._sync_to_order(this);
	    }
	  }
	};

	/*
		Behavior:DataMove - allows to move and copy elements, heavily relays on DataStore.move
		@export
			copy
			move
	*/

	var TreeDataMove = {
	  $init: function () {
	    assert(this.data, "DataMove :: Component doesn't have DataStore");
	  },
	  //creates a copy of the item
	  copy: function (sid, tindex, tobj, details) {
	    details = details || {};
	    details.copy = true;
	    return this.move(sid, tindex, tobj, details);
	  },
	  _next_move_index: function (nid, next, source) {
	    if (next && nid) {
	      var new_index = this.getBranchIndex(nid);
	      return new_index + (source == this && source.getBranchIndex(next) < new_index ? 0 : 1);
	    }
	  },
	  _check_branch_child: function (parent, child) {
	    var t = this.data.branch[parent];

	    if (t && t.length) {
	      for (var i = 0; i < t.length; i++) {
	        if (t[i] == child) return true;
	        if (this._check_branch_child(t[i], child)) return true;
	      }
	    }

	    return false;
	  },
	  //move item to the new position
	  move: function (sid, tindex, tobj, details) {
	    details = details || {};
	    tindex = tindex || 0;
	    var new_id = details.newId || sid;
	    var target_parent = details.parent || 0;
	    tobj = tobj || this;
	    assert(tobj.data, "moving attempt to component without datastore");
	    if (!tobj.data) return;

	    if (isArray(sid)) {
	      for (var i = 0; i < sid.length; i++) {
	        //increase index for each next item in the set, so order of insertion will be equal to order in the array
	        var nid = this.move(sid[i], tindex, tobj, details);
	        tindex = tobj._next_move_index(nid, sid[i + 1], this);
	      }

	      return;
	    }

	    if (this != tobj || details.copy) {
	      new_id = tobj.data.add(tobj._externalData(this.getItem(sid), new_id), tindex, target_parent || 0);

	      if (this.data.branch[sid] && tobj.getBranchIndex) {
	        var temp = this.data._scheme_serialize;

	        this.data._scheme_serialize = function (obj) {
	          var copy$$1 = copy(obj);
	          delete copy$$1.$parent;
	          delete copy$$1.$level;
	          delete copy$$1.$child;
	          if (tobj.data.pull[copy$$1.id]) copy$$1.id = uid();
	          return copy$$1;
	        };

	        var copy_data = {
	          data: this.serialize(sid, true),
	          parent: new_id
	        };
	        this.data._scheme_serialize = temp;
	        tobj.parse(copy_data);
	      }

	      if (!details.copy) this.data.remove(sid);
	    } else {
	      //move in self
	      if (sid == target_parent || this._check_branch_child(sid, target_parent)) return;
	      var source = this.getItem(sid);
	      var tbranch = this.data.branch[target_parent];
	      if (!tbranch) tbranch = this.data.branch[target_parent] = [];
	      var sbranch = this.data.branch[source.$parent];
	      var sindex = PowerArray.find.call(sbranch, sid);
	      if (tindex < 0) tindex = tbranch.length; //in the same branch

	      if (sbranch === tbranch && tindex === sindex) return; //same position

	      PowerArray.removeAt.call(sbranch, sindex);
	      PowerArray.insertAt.call(tbranch, sid, Math.min(tbranch.length, tindex));
	      if (!sbranch.length) delete this.data.branch[source.$parent];
	      if (source.$parent && source.$parent != "0") this.getItem(source.$parent).$count--;

	      if (target_parent && target_parent != "0") {
	        var target = tobj.getItem(target_parent);
	        target.$count++;

	        this._set_level_rec(source, target.$level + 1);
	      } else this._set_level_rec(source, 1);

	      source.$parent = target_parent;
	      tobj.data.callEvent("onDataMove", [sid, tindex, target_parent, tbranch[tindex + 1]]);
	    }

	    this.refresh();
	    return new_id; //return ID of item after moving
	  },
	  _set_level_rec: function (item, value) {
	    item.$level = value;
	    var branch = this.data.branch[item.id];
	    if (branch) for (var i = 0; i < branch.length; i++) {
	      this._set_level_rec(this.getItem(branch[i]), value + 1);
	    }
	  },
	  //reaction on pause during dnd
	  _drag_pause: function (id) {
	    if (id && !id.header && this.exists(id) && this._target_to_id(id) != DragControl._drag_context.start) //ignore drag other header
	      this.open(id);
	  },
	  $dropAllow: function (context) {
	    if (context.from != context.to) return true;

	    for (var i = 0; i < context.source.length; i++) {
	      if (this._check_branch_child(context.source, context.target)) return false;
	    }

	    return true;
	  },

	  /*
	  	this is a stub for future functionality
	  	currently it just makes a copy of data object, which is enough for current situation
	  */
	  _externalData: function (data, id) {
	    var new_data = DataMove._externalData.call(this, data, id);

	    delete new_data.open;
	    return new_data;
	  }
	};

	var TreeRenderStack = {
	  $init: function () {
	    assert(this.render, "TreeRenderStack :: Object must use RenderStack first");
	  },
	  _toHTMLItem: function (obj) {
	    var mark = this.data._marks[obj.id];
	    this.callEvent("onItemRender", [obj]);
	    return this.type.templateStart(obj, this.type, mark) + (obj.$template ? this.type["template" + obj.$template](obj, this.type, mark) : this.type.template(obj, this.type, mark)) + this.type.templateEnd();
	  },
	  _toHTMLItemObject: function (obj) {
	    this._html.innerHTML = this._toHTMLItem(obj);
	    return this._html.firstChild;
	  },
	  //convert single item to HTML text (templating)
	  _toHTML: function (obj) {
	    //check if related template exist
	    assert(!obj.$template || this.type["template" + obj.$template], "RenderStack :: Unknown template: " + obj.$template);

	    var html = "<div role='presentation' class='webix_tree_branch_" + obj.$level + "'>" + this._toHTMLItem(obj);

	    if (obj.open) html += this._toHTMLLevel(obj.id);
	    html += "</div>";
	    return html;
	  },
	  _toHTMLLevel: function (id) {
	    var html = "";
	    var leaves = this.data.branch[id];

	    if (leaves) {
	      html += "<div role='presentation' class='webix_tree_leaves'>";
	      var last = leaves.length - 1;

	      for (var i = 0; i <= last; i++) {
	        var obj = this.getItem(leaves[i]);
	        var state = this.type._tree_branch_render_state;
	        if (state !== 0) state[obj.$level] = i == last;
	        html += this._toHTML(obj);
	      }

	      html += "</div>";
	    }

	    return html;
	  },
	  //return true when some actual rendering done
	  render: function (id, data, type) {
	    TreeRenderStack._obj = this; //can be used from complex render

	    if (!this.isVisible(this._settings.id) || this.$blockRender) return;

	    if (id) {
	      var cont, node;
	      var item = this.getItem(id);

	      if (type != "add") {
	        cont = this.getItemNode(id);
	        if (!cont) return;
	      }

	      switch (type) {
	        case "branch":
	          var branch = cont.parentNode;
	          node = this._toHTMLObject(item);
	          insertBefore(node, branch);
	          remove(branch);
	          this._htmlmap = null;
	          break;

	        case "paint":
	        case "update":
	          node = this._htmlmap[id] = this._toHTMLItemObject(item);
	          insertBefore(node, cont);
	          remove(cont);
	          break;

	        case "delete":
	          //deleting not item , but full branch
	          remove(cont.parentNode);
	          break;

	        case "add":
	          var parent; //we want process both empty value and 0 as string
	          //jshint -W041:true

	          if (item.$parent == 0) {
	            parent = this._dataobj.firstChild;
	          } else if (this.getItem(item.$parent).open) {
	            parent = this.getItemNode(item.$parent);

	            if (parent) {
	              //when item created by the script, it will miss the container for child notes
	              //create it on demand
	              if (!parent.nextSibling) {
	                var leafs = create("DIV", {
	                  "class": "webix_tree_leaves"
	                }, "");
	                parent.parentNode.appendChild(leafs);
	              }

	              parent = parent.nextSibling;
	            }
	          }

	          if (parent) {
	            var next = this.data.getNextSiblingId(id);
	            next = this.getItemNode(next);
	            if (next) next = next.parentNode;
	            node = this._toHTMLObject(item);
	            this._htmlmap[id] = node.firstChild;
	            insertBefore(node, next, parent);
	          }

	          break;

	        default:
	          return false;
	      }

	      this.callEvent("onPartialRender", [id, data, type]);
	    } else {
	      //full reset
	      if (this.callEvent("onBeforeRender", [this.data])) {
	        //will be used for lines management
	        this.type._tree_branch_render_state = []; //getTopRange - returns all elements on top level

	        this._dataobj.innerHTML = this._toHTMLLevel(0);
	        this._htmlmap = null; //clear map, it will be filled at first getItemNode

	        this.callEvent("onAfterRender", []);
	      }
	    } //clear after usage


	    this.type._tree_branch_render_state = 0;
	    TreeRenderStack._obj = null;
	    return true;
	  },
	  getItemNode: function (search_id) {
	    if (this._htmlmap) return this._htmlmap[search_id]; //fill map if it doesn't created yet

	    this._htmlmap = {};

	    var t = this._dataobj.getElementsByTagName("DIV");

	    for (var i = 0; i < t.length; i++) {
	      var id = t[i].getAttribute(this._id); //get item's

	      if (id) this._htmlmap[id] = t[i];
	    } //call locator again, when map is filled


	    return this.getItemNode(search_id);
	  },
	  _branch_render_supported: 1
	};

	var TreeStateCheckbox = {
	  _init_render_tree_state: function () {
	    if (this._branch_render_supported) {
	      var old_render = this.render;

	      this.render = function (id, data) {
	        var updated = old_render.apply(this, arguments);
	        if (this._settings.threeState && updated && data != "checkbox") this._setThirdState.apply(this, arguments);
	      };

	      this._init_render_tree_state = function () {};
	    }
	  },
	  threeState_setter: function (value) {
	    if (value) this._init_render_tree_state();
	    return value;
	  },
	  _setThirdState: function (id) {
	    var i, leaves, parents, checkedParents, tree;
	    parents = [];
	    tree = this;
	    /*if item was removed*/

	    if (id && !tree.data.pull[id]) {
	      id = 0;
	    }
	    /*sets checkbox states*/

	    /*if branch or full reloading*/


	    if (!id || tree.data.pull[id].$count) {
	      leaves = this._getAllLeaves(id);
	      leaves.sort(function (a, b) {
	        return tree.data.pull[b].$level - tree.data.pull[a].$level;
	      });

	      for (i = 0; i < leaves.length; i++) {
	        if (!i || tree.data.pull[leaves[i]].$parent != tree.data.pull[leaves[i - 1]].$parent) parents = parents.concat(tree._setParentThirdState(leaves[i]));
	      }
	    } else {
	      /*an item is a leaf */
	      parents = parents.concat(tree._setParentThirdState(id));
	    }

	    checkedParents = {};

	    for (i = 0; i < parents.length; i++) {
	      if (!checkedParents[parents[i]]) {
	        checkedParents[parents[i]] = 1;

	        this._setCheckboxIndeterminate(parents[i]);
	      }
	    }

	    tree = null;
	  },
	  _setCheckboxIndeterminate: function (id) {
	    var chElem, elem;
	    elem = this.getItemNode(id);

	    if (elem) {
	      this.render(id, "checkbox", "update");
	      /*needed to get the new input obj and to set indeterminate state*/

	      if (this.getItem(id).indeterminate) {
	        elem = this.getItemNode(id);
	        chElem = elem.getElementsByTagName("input")[0];
	        if (chElem) chElem.indeterminate = this.getItem(id).indeterminate;
	      }
	    }
	  },
	  _setParentThirdState: function (itemId) {
	    //we need to use dynamic function creating
	    //jshint -W083:true
	    var checked, checkedCount, indeterminate, parentId, result, unsureCount, needrender;
	    parentId = this.getParentId(itemId);
	    result = [];

	    while (parentId && parentId != "0") {
	      unsureCount = 0;
	      checkedCount = 0;
	      this.data.eachChild(parentId, function (obj) {
	        if (obj.indeterminate) {
	          unsureCount++;
	        } else if (obj.checked) {
	          checkedCount++;
	        }
	      });
	      checked = indeterminate = needrender = false;
	      var item = this.getItem(parentId);

	      if (checkedCount == item.$count) {
	        checked = true;
	      } else if (checkedCount > 0 || unsureCount > 0) {
	        indeterminate = true;
	      } //we need to reset indeterminate in any case :(


	      if (indeterminate || indeterminate != item.indeterminate) needrender = true;
	      item.indeterminate = indeterminate;
	      if (checked || item.checked != checked) needrender = true;
	      item.checked = checked;

	      if (needrender) {
	        result.push(parentId);
	        parentId = this.getParentId(parentId);
	      } else parentId = 0;
	    }

	    return result;
	  },

	  /*get all checked items in tree*/
	  getChecked: function () {
	    var result = [];
	    var tree = this;
	    this.data.eachSubItem(0, function (obj) {
	      if (tree.isChecked(obj.id)) result.push(obj.id);
	    });
	    return result;
	  },
	  _tree_check_uncheck_3: function (id, mode) {
	    var item = this.getItem(id);

	    if (item) {
	      if (mode === "") mode = !item.checked;

	      if (item.checked != mode || item.indeterminate) {
	        item.checked = mode;

	        this._correctThreeState(id);

	        var parents = this._setParentThirdState(id);

	        if (this._branch_render_supported && parents.length < 5) {
	          for (var i = 0; i < parents.length; i++) {
	            this._setCheckboxIndeterminate(parents[i]);
	          }
	        } else this.refresh();

	        this.callEvent("onItemCheck", [id, mode]);
	      }
	    }
	  },

	  /*set checked state for item checkbox*/
	  checkItem: function (id) {
	    this._tree_check_uncheck(id, true);

	    this.updateItem(id);
	  },

	  /*uncheckes an item checkbox*/
	  uncheckItem: function (id) {
	    this._tree_check_uncheck(id, false);

	    this.updateItem(id);
	  },
	  _checkUncheckAll: function (id, mode, all) {
	    var method = mode ? "checkItem" : "uncheckItem";
	    if (!id) id = 0;else this[method](id);

	    if (this._settings.threeState) {
	      if (!id) this.data.eachChild(0, function (item) {
	        this[method](item.id);
	      }, this, all);
	    } else this.data.each(function (item) {
	      this[method](item.id);
	    }, this, all, id);
	  },

	  /*checkes checkboxes of all items in a branch/tree*/
	  checkAll: function (id, all) {
	    this._checkUncheckAll(id, true, all);
	  },

	  /*uncheckes checkboxes of all items in a branch/tree*/
	  uncheckAll: function (id, all) {
	    this._checkUncheckAll(id, false, all);
	  },
	  _correctThreeState: function (id) {
	    var state;
	    var item = this.getItem(id);
	    item.indeterminate = false;
	    state = item.checked;
	    this.data.eachSubItem(id, function (child) {
	      child.indeterminate = false;
	      child.checked = state;
	    });

	    if (this._branch_render_supported && this.isBranchOpen(item.$parent)) {
	      //for tree-render only
	      this.render(id, 0, "branch");
	    }
	  },

	  /*returns checked state of item checkbox*/
	  isChecked: function (id) {
	    return this.getItem(id).checked;
	  },

	  /*gets all leaves in a certain branch (in the whole tree if id is not set)*/
	  _getAllLeaves: function (parentId) {
	    var result = [];
	    this.data.eachSubItem(parentId, function (obj, branch) {
	      if (!branch) result.push(obj.id);
	    });
	    return result;
	  }
	};

	// #include core/bind.js
	// #include core/treemove.js

	var TreeStore = {
	  name: "TreeStore",
	  $init: function () {
	    this._filterMode = {
	      //level:1,
	      showSubItems: true
	    };
	    this.branch = {
	      0: []
	    };
	    this.attachEvent("onParse", function (driver) {
	      this._set_child_scheme(driver.child);
	    });
	    this.attachEvent("onClearAll", bind(function () {
	      this._filter_branch = null;
	    }, this));
	  },
	  filterMode_setter: function (mode) {
	    return exports.extend(this._filterMode, mode, true);
	  },
	  _filter_reset: function (preserve) {
	    //remove previous filtering , if any
	    if (this._filter_branch && !preserve) {
	      this.branch = this._filter_branch;
	      this.order = toArray(copy(this.branch[0]));

	      for (var key in this.branch) {
	        if (key != "0") //exclude 0 - virtual root
	          this.getItem(key).$count = this.branch[key].length;
	      }

	      delete this._filter_branch;
	    }
	  },
	  _filter_core: function (filter, value, preserve, filterMode) {
	    //for tree we have few filtering options
	    //- filter leafs only
	    //- filter data on specific level
	    //- filter data on all levels
	    //- in all cases we can show or hide empty folder
	    //- in all cases we can show or hide childs for matched item
	    //set new order of items, store original
	    if (!preserve || !this._filter_branch) {
	      this._filter_branch = this.branch;
	      this.branch = clone(this.branch);
	    }

	    this.branch[0] = this._filter_branch_rec(filter, value, this.branch[0], 1, filterMode || {});
	  },
	  _filter_branch_rec: function (filter, value, branch, level, config) {
	    //jshint -W041
	    var neworder = [];
	    var allow = config.level && config.level != level;

	    for (var i = 0; i < branch.length; i++) {
	      var id = branch[i];
	      var item = this.getItem(id);
	      var child_run = false;
	      var sub = this.branch[id];

	      if (allow) {
	        child_run = true;
	      } else if (filter(this.getItem(id), value)) {
	        neworder.push(id); // open all parents of the found item

	        if (config.openParents !== false) {
	          var parentId = this.getParentId(id);

	          while (parentId && parentId != "0") {
	            this.getItem(parentId).open = 1;
	            parentId = this.getParentId(parentId);
	          }
	        } //in case of of fixed level filtering - do not change child-items


	        if (config.level || config.showSubItems) continue;
	      } else {
	        //filtering level, not match
	        child_run = true;
	      } //if "filter by all levels" - filter childs


	      if (allow || !config.level) {
	        if (sub) {
	          var newsub = this.branch[id] = this._filter_branch_rec(filter, value, sub, level + 1, config);

	          item.$count = newsub.length;
	          if (child_run && newsub.length) neworder.push(id);
	        }
	      }
	    }

	    return neworder;
	  },
	  count: function () {
	    if (this.order.length) return this.order.length; //we must return some non-zero value, or logic of selection will think that we have not data at all

	    var count = 0;
	    this.eachOpen(function () {
	      count++;
	    });
	    return count;
	  },
	  _change_branch_id: function (branches, parent, old, newid) {
	    if (branches[old]) {
	      var branch = branches[newid] = branches[old];

	      for (var i = 0; i < branch.length; i++) {
	        this.getItem(branch[i]).$parent = newid;
	      }

	      delete branches[old];
	    }

	    if (branches[parent]) {
	      var index = PowerArray.find.call(branches[parent], old);
	      if (index >= 0) branches[parent][index] = newid;
	    }
	  },
	  changeId: function (old, newid) {
	    if (old == newid) return;
	    var parent = this.getItem(old).$parent;

	    this._change_branch_id(this.branch, parent, old, newid); //in case of filter applied, update id in filtered state as well


	    if (this._filter_branch) this._change_branch_id(this._filter_branch, parent, old, newid);
	    return DataStore.prototype.changeId.call(this, old, newid);
	  },
	  clearAll: function (soft) {
	    this.branch = {
	      0: []
	    };
	    DataStore.prototype.clearAll.call(this, soft);
	  },
	  getPrevSiblingId: function (id) {
	    var order = this.branch[this.getItem(id).$parent];
	    var pos = PowerArray.find.call(order, id) - 1;
	    if (pos >= 0) return order[pos];
	    return null;
	  },
	  getNextSiblingId: function (id) {
	    var order = this.branch[this.getItem(id).$parent];
	    var pos = PowerArray.find.call(order, id) + 1;
	    if (pos < order.length) return order[pos];
	    return null;
	  },
	  getParentId: function (id) {
	    return this.getItem(id).$parent;
	  },
	  getFirstChildId: function (id) {
	    var order = this.branch[id];
	    if (order && order.length) return order[0];
	    return null;
	  },
	  isBranch: function (parent) {
	    return !!this.branch[parent];
	  },
	  getBranchIndex: function (child) {
	    var t = this.branch[this.pull[child].$parent];
	    return PowerArray.find.call(t, child);
	  },
	  _set_child_scheme: function (parse_name) {
	    if (typeof parse_name == "string") this._datadriver_child = function (obj) {
	      var t = obj[parse_name];
	      if (t) delete obj[parse_name];
	      return t;
	    };else this._datadriver_child = parse_name;
	  },
	  _inner_parse: function (info, recs) {
	    var parent = info.parent || 0;

	    for (var i = 0; i < recs.length; i++) {
	      //get hash of details for each record
	      var temp = this.driver.getDetails(recs[i]);
	      var id = this.id(temp); //generate ID for the record

	      var update = !!this.pull[id]; //update mode

	      if (update) {
	        temp = exports.extend(this.pull[id], temp, true);
	        if (this._scheme_update) this._scheme_update(temp);
	      } else {
	        if (this._scheme_init) this._scheme_init(temp);
	        this.pull[id] = temp;
	      }

	      this._extraParser(temp, parent, 0, update, info.from ? info.from * 1 + i : 0);
	    } //fix state of top item after data loading


	    var pItem = this.pull[parent] || {};
	    var pBranch = this.branch[parent] || [];
	    pItem.$count = pBranch.length;
	    delete pItem.webix_kids;
	    if (info.size && info.size != pBranch.length) pBranch[info.size - 1] = undefined;
	  },
	  _extraParser: function (obj, parent, level, update, from) {
	    //processing top item
	    obj.$count = 0; //using soft check, as parent can be a both 0 and "0" ( second one in case of loading from server side ) 

	    obj.$parent = parent != "0" ? parent : 0;
	    obj.$level = level || (parent != "0" ? this.pull[parent].$level + 1 : 1);
	    var parent_branch = this.branch[obj.$parent];
	    if (!parent_branch) parent_branch = this.branch[obj.$parent] = [];
	    if (this._filter_branch) this._filter_branch[obj.$parent] = parent_branch;

	    if (!update) {
	      var pos = from || parent_branch.length;
	      parent_branch[pos] = obj.id;
	    }

	    var child = this._datadriver_child(obj);

	    if (obj.webix_kids) {
	      return obj.$count = -1;
	    }

	    if (!child) //ignore childless
	      return obj.$count = 0; //when loading from xml we can have a single item instead of an array

	    if (!isArray(child)) child = [child];

	    for (var i = 0; i < child.length; i++) {
	      //extra processing to convert strings to objects
	      var item = DataDriver.json.getDetails(child[i]);
	      var itemid = this.id(item);
	      update = !!this.pull[itemid];

	      if (update) {
	        item = exports.extend(this.pull[itemid], item, true);
	        if (this._scheme_update) this._scheme_update(item);
	      } else {
	        if (this._scheme_init) this._scheme_init(item);
	        this.pull[itemid] = item;
	      }

	      this._extraParser(item, obj.id, obj.$level + 1, update);
	    } //processing childrens


	    var branch = this.branch[obj.id];
	    if (branch) obj.$count = branch.length;
	  },
	  _sync_to_order: function (master) {
	    this.order = toArray();

	    this._sync_each_child(0, master);
	  },
	  _sync_each_child: function (start, master) {
	    var branch = this.branch[start];

	    for (var i = 0; i < branch.length; i++) {
	      var id = branch[i];
	      this.order.push(id);
	      var item = this.pull[id];

	      if (item) {
	        if (item.open) {
	          if (item.$count == -1) master.loadBranch(id);else if (item.$count) this._sync_each_child(id, master);
	        }
	      }
	    }
	  },
	  provideApi: function (target, eventable) {
	    var list = ["getPrevSiblingId", "getNextSiblingId", "getParentId", "getFirstChildId", "isBranch", "getBranchIndex", "filterMode_setter"];

	    for (var i = 0; i < list.length; i++) {
	      target[list[i]] = this._methodPush(this, list[i]);
	    }

	    if (!target.getIndexById) DataStore.prototype.provideApi.call(this, target, eventable);
	  },
	  getTopRange: function () {
	    return toArray([].concat(this.branch[0])).map(function (id) {
	      return this.getItem(id);
	    }, this);
	  },
	  eachChild: function (id, functor, master, all) {
	    var branch = this.branch;
	    if (all && this._filter_branch) branch = this._filter_branch;
	    var stack = branch[id];
	    if (stack) for (var i = 0; i < stack.length; i++) {
	      if (stack[i]) functor.call(master || this, this.getItem(stack[i]));
	    }
	  },
	  each: function (method, master, all, id) {
	    this.eachChild(id || 0, function (item) {
	      var branch = this.branch;
	      method.call(master || this, item);
	      if (all && this._filter_branch) branch = this._filter_branch;
	      if (item && branch[item.id]) this.each(method, master, all, item.id);
	    }, this, all);
	  },
	  eachOpen: function (method, master, id) {
	    this.eachChild(id || 0, function (item) {
	      method.call(master || this, item);
	      if (this.branch[item.id] && item.open) this.eachOpen(method, master, item.id);
	    });
	  },
	  eachSubItem: function (id, functor) {
	    var top = this.branch[id || 0];
	    if (top) for (var i = 0; i < top.length; i++) {
	      var key = top[i];

	      if (this.branch[key]) {
	        functor.call(this, this.getItem(key), true);
	        this.eachSubItem(key, functor);
	      } else functor.call(this, this.getItem(key), false);
	    }
	  },
	  eachLeaf: function (id, functor) {
	    var top = this.branch[id || 0];
	    if (top) for (var i = 0; i < top.length; i++) {
	      var key = top[i];

	      if (this.branch[key]) {
	        this.eachLeaf(key, functor);
	      } else functor.call(this, this.getItem(key), false);
	    }
	  },
	  _sort_core: function (sort, order) {
	    var sorter = this.sorting.create(sort);

	    for (var key in this.branch) {
	      var bset = this.branch[key];
	      var data = [];

	      for (var i = 0; i < bset.length; i++) {
	        data.push(this.pull[bset[i]]);
	      }

	      data.sort(sorter);

	      for (var _i = 0; _i < bset.length; _i++) {
	        data[_i] = data[_i].id;
	      }

	      this.branch[key] = data;
	    }

	    return order;
	  },
	  add: function (obj, index, pid) {
	    var refresh_parent = false;
	    var parent = this.getItem(pid || 0);

	    if (parent) {
	      //when adding items to leaf item - it need to be repainted
	      if (!this.branch[parent.id]) refresh_parent = true;
	      parent.$count++; //fix for the adding into dynamic loading branch
	      //dynamic branch has $count as -1

	      if (!parent.$count) parent.$count = 1;
	    }

	    this.branch[pid || 0] = this.order = toArray(this.branch[pid || 0]);
	    obj.$count = obj.webix_kids ? -1 : 0;
	    obj.$level = parent ? parent.$level + 1 : 1;
	    obj.$parent = parent ? parent.id : 0;

	    if (this._filter_branch) {
	      //adding during filtering
	      var origin = this._filter_branch[pid || 0]; //newly created branch

	      if (!origin) origin = this._filter_branch[pid] = this.order; //branch can be shared bettwen collections, ignore such cases

	      if (this.order !== origin) {
	        //we can't know the location of new item in full dataset, making suggestion
	        //put at end by default
	        var original_index = origin.length; //put at start only if adding to the start and some data exists

	        if (!index && this.branch[pid || 0].length) original_index = 0;
	        origin = toArray(origin);
	        obj.id = obj.id || uid();
	        origin.insertAt(obj.id, original_index);
	      }
	    } //call original adding logic


	    var result = DataStore.prototype.add.call(this, obj, index);
	    if (refresh_parent) this.refresh(pid);
	    return result;
	  },
	  _rec_remove: function (id) {
	    var obj = this.pull[id];

	    if (this.branch[obj.id] && this.branch[obj.id].length > 0) {
	      var branch = this.branch[id];

	      for (var i = 0; i < branch.length; i++) {
	        this._rec_remove(branch[i], true);
	      }
	    }

	    delete this.branch[id];
	    if (this._filter_branch) delete this._filter_branch[id];
	    delete this.pull[id];
	    if (this._marks[id]) delete this._marks[id];
	  },
	  _filter_removed: function (pull, parentId, id) {
	    var branch = pull[parentId];

	    if (branch.length == 1 && branch[0] == id && parentId) {
	      delete pull[parentId];
	    } else toArray(branch).remove(id);
	  },
	  remove: function (id) {
	    //id can be an array of IDs - result of getSelect, for example
	    if (isArray(id)) {
	      for (var i = 0; i < id.length; i++) {
	        this.remove(id[i]);
	      }

	      return;
	    }

	    assert(this.exists(id), "Not existing ID in remove command" + id);
	    var obj = this.pull[id];
	    var parentId = obj.$parent || 0;
	    if (this.callEvent("onBeforeDelete", [id]) === false) return false;

	    this._rec_remove(id);

	    this.callEvent("onAfterDelete", [id]);
	    var parent = this.pull[parentId];

	    this._filter_removed(this.branch, parentId, id);

	    if (this._filter_branch) this._filter_removed(this._filter_branch, parentId, id);
	    var refresh_parent = 0;

	    if (parent) {
	      parent.$count--;

	      if (parent.$count <= 0) {
	        parent.$count = 0;
	        parent.open = 0;
	        refresh_parent = 1;
	      }
	    } //repaint signal


	    this.callEvent("onStoreUpdated", [id, obj, "delete"]);
	    if (refresh_parent) this.refresh(parent.id);
	  },

	  /*
	  	serializes data to a json object
	  */
	  getBranch: function (id) {
	    var out = [];
	    var items = (this._filter_branch || this.branch)[id];
	    if (items) for (var i = 0; i < items.length; i++) {
	      out[i] = this.pull[items[i]];
	    }
	    return out;
	  },
	  serialize: function (id, all) {
	    var coll = this.branch; //use original collection of branches

	    if (all && this._filter_branch) coll = this._filter_branch;
	    var ids = coll[id || 0];
	    var result = [];

	    for (var i = 0; i < ids.length; i++) {
	      var obj = this.pull[ids[i]];
	      var rel;

	      if (this._scheme_serialize) {
	        rel = this._scheme_serialize(obj);
	        if (rel === false) continue;
	      } else rel = copy(obj);

	      if (coll[obj.id]) rel.data = this.serialize(obj.id, all);
	      result.push(rel);
	    }

	    return result;
	  }
	};

	var TreeTablePaste = {
	  insert: function (data) {
	    var parent = this.getSelectedId(true, true);

	    for (var i = 0; i < data.length; i++) {
	      var item = {};

	      for (var j = 0; j < this._settings.columns.length; j++) {
	        item[this._settings.columns[j].id] = data[i][j] || "";
	      }

	      if (!isUndefined(item.id) && this.exists(item.id)) item.id = uid();
	      this.add(item, null, parent[0]);
	    }
	  }
	};

	var TreeType = {
	  space: function (obj) {
	    var html = "";

	    for (var i = 1; i < obj.$level; i++) {
	      html += "<div class='webix_tree_none'></div>";
	    }

	    return html;
	  },
	  icon: function (obj) {
	    if (obj.$count) {
	      if (obj.open) return "<div class='webix_tree_open'></div>";else return "<div class='webix_tree_close'></div>";
	    } else return "<div class='webix_tree_none'></div>";
	  },
	  checkbox: function (obj) {
	    if (obj.nocheckbox) return "";
	    return "<input type='checkbox' class='webix_tree_checkbox' " + (obj.checked ? "checked" : "") + (obj.disabled ? " disabled" : "") + ">";
	  },
	  folder: function (obj) {
	    if (obj.icon) return "<div class='webix_tree_file webix_tree_" + obj.icon + "'></div>";

	    if (obj.$count) {
	      if (obj.open) return "<div class='webix_tree_folder_open'></div>";else return "<div class='webix_tree_folder'></div>";
	    }

	    return "<div class='webix_tree_file'></div>";
	  }
	};

	var UploadDriver = {
	  flash: {
	    $render: function () {
	      if (!window.swfobject) require("legacy/swfobject.js", true); // sync loading

	      var config = this._settings;
	      config.swfId = config.swfId || "webix_swf_" + uid();
	      this._getBox().innerHTML += "<div class='webix_upload_flash'><div id='" + config.swfId + "'></div></div>";
	      this._upload_area = this._getBox().lastChild; // add swf object

	      /* global swfobject */

	      swfobject.embedSWF(env.codebase + "/legacy/uploader.swf", config.swfId, "100%", "100%", "9", null, {
	        uploaderId: config.id,
	        ID: config.swfId,
	        enableLogs: config.enableLogs ? "1" : "",
	        paramName: config.inputName,
	        multiple: config.multiple ? "Y" : ""
	      }, {
	        wmode: "transparent"
	      });

	      _event(this._viewobj, "click", bind(function () {
	        var now_date = new Date();

	        if (now_date - (this._upload_timer_click || 0) > 250) {
	          this.fileDialog();
	        }
	      }, this));

	      this.files.attachEvent("onBeforeDelete", bind(this._stop_file, this));
	    },
	    $applyFlash: function (name, params) {
	      return this[name].apply(this, params);
	    },
	    getSwfObject: function () {
	      /* global swfobject */
	      return swfobject.getObjectById(this._settings.swfId);
	    },
	    fileDialog: function () {
	      if (this.getSwfObject()) this.getSwfObject().showDialog();
	    },
	    send: function (id) {
	      if (typeof id == "function") {
	        this._last_assigned_upload_callback = id;
	        id = 0;
	      }

	      if (!id) {
	        var order = this.files.data.order;
	        var complete = true;
	        if (order.length) for (var i = 0; i < order.length; i++) {
	          complete = this.send(order[i]) && complete;
	        }
	        if (complete) this._upload_complete();
	        return;
	      }

	      var item = this.files.getItem(id);
	      if (item.status !== "client") return false;
	      item.status = "transfer";

	      if (this.getSwfObject()) {
	        var url = this._get_active_url(item);

	        var globalData = this._settings.formData || {};
	        if (typeof globalData === "function") globalData = globalData.call(this);
	        var details = exports.extend(item.formData || {}, globalData);
	        this.getSwfObject().upload(id, url, details);
	      }

	      return true;
	    },
	    $beforeAddFileToQueue: function (id, name, size) {
	      var type = name.split(".").pop();

	      var format = this._format_size(size);

	      return this.callEvent("onBeforeFileAdd", [{
	        id: id,
	        name: name,
	        size: size,
	        sizetext: format,
	        type: type
	      }]);
	    },
	    $addFileToQueue: function (id, name, size) {
	      if (this.files.exists(id)) return false;
	      if (!this._settings.multiple) this.files.clearAll();
	      var type = name.split(".").pop();

	      var format = this._format_size(size);

	      var file_struct = {
	        name: name,
	        id: id,
	        size: size,
	        sizetext: format,
	        type: type,
	        status: "client"
	      };
	      this.files.add(file_struct);
	      this.callEvent("onAfterFileAdd", [file_struct]);
	      if (id && this._settings.autosend) this.send(id);
	    },
	    stopUpload: function (id) {
	      this._stop_file(id);
	    },
	    _stop_file: function (id) {
	      var item = this.files.getItem(id);

	      if (item.status == "transfer") {
	        this.getSwfObject().uploadStop(id);
	        item.status = "client";
	      }
	    },
	    _drop: function () {},
	    //drop of files is not supported in IE9-
	    $onUploadComplete: function () {
	      if (this._settings.autosend) {
	        this._upload_complete();
	      }
	    },
	    $onUploadSuccess: function (id, name, response) {
	      var item = this.files.getItem(id);

	      if (item) {
	        item.status = "server";
	        item.progress = 100;

	        if (response.text && typeof response.text == "string") {
	          DataDriver.json.toObject(response.text);
	          exports.extend(item, response, true);
	        }

	        this.callEvent("onFileUpload", [item, response]);
	        this.callEvent("onChange", []);
	        this.files.updateItem(id);
	      }
	    },
	    $onUploadFail: function (id) {
	      var item = this.files.getItem(id);
	      item.status = "error";
	      delete item.percent;
	      this.files.updateItem(id);
	      this.callEvent("onFileUploadError", [item, ""]);
	    }
	  },
	  html5: {
	    $render: function () {
	      if (this._upload_area) {
	        //firstChild is webix_el_box container, which have relative position
	        //as result, file control is placed under the button and not in the top corner
	        this._contentobj.firstChild.appendChild(this._upload_area);

	        return;
	      }

	      this.files.attachEvent("onBeforeDelete", this._stop_file);
	      var input_config = {
	        "type": "file",
	        "class": "webix_hidden_upload",
	        tabindex: -1
	      };
	      if (this._settings.accept) input_config.accept = this._settings.accept;
	      if (this._settings.multiple) input_config.multiple = "true";

	      if (this._settings.directory) {
	        input_config.webkitdirectory = "true";
	        input_config.mozdirectory = "true";
	        input_config.directory = "true";
	      }

	      var f = create("input", input_config);
	      this._upload_area = this._contentobj.firstChild.appendChild(f);

	      _event(this._viewobj, "drop", bind(function (e) {
	        this._drop(e);

	        preventEvent(e);
	      }, this));

	      _event(f, "change", bind(function () {
	        this._add_files(f.files);

	        if (env.isIE) {
	          var t = document.createElement("form");
	          t.appendChild(this._upload_area);
	          t.reset();

	          this._contentobj.firstChild.appendChild(f);
	        } else f.value = "";
	      }, this));

	      _event(this._viewobj, "click", bind(function () {
	        var now_date = new Date();

	        if (now_date - (this._upload_timer_click || 0) > 250) {
	          this.fileDialog();
	        }
	      }, this));

	      _event(this._viewobj, "dragenter", preventEvent);

	      _event(this._viewobj, "dragexit", preventEvent);

	      _event(this._viewobj, "dragover", preventEvent);
	    },
	    _directoryEntry: function (value) {
	      return value.isDirectory;
	    },
	    _directoryDrop: function (item, state, path) {
	      if (item.isFile) {
	        item.file(function (file) {
	          state.addFile(file, null, null, {
	            name: path + "/" + file.name
	          });
	        });
	      } else if (item.isDirectory) {
	        // Get folder contents
	        var dirReader = item.createReader();
	        dirReader.readEntries(function (entries) {
	          for (var i = 0; i < entries.length; i++) {
	            state._directoryDrop(entries[i], state, (path ? path + "/" : "") + item.name);
	          }
	        });
	      }
	    },
	    // adding files by drag-n-drop
	    _drop: function (e) {
	      var files = e.dataTransfer.files;
	      var items = e.dataTransfer.items;

	      if (this.callEvent("onBeforeFileDrop", [files, e])) {
	        items = items || files; //IE10+

	        for (var i = 0; i < items.length; i++) {
	          //https://developer.mozilla.org/en-US/docs/Web/API/DataTransferItem/webkitGetAsEntry
	          var item = items[i];

	          if (item.webkitGetAsEntry) {
	            item = item.webkitGetAsEntry();

	            if (item.isDirectory) {
	              this._directoryDrop(item, this, "");

	              continue;
	            }
	          }

	          this.addFile(files[i]);
	        }
	      }

	      this.callEvent("onAfterFileDrop", [files, e]);
	    },
	    fileDialog: function (context) {
	      this._upload_timer_click = new Date();
	      this._last_file_context = context;

	      var inputs = this._viewobj.getElementsByTagName("INPUT");

	      inputs[inputs.length - 1].click();
	    },
	    send: function (id) {
	      //alternative syntx send(callback)
	      if (typeof id == "function") {
	        this._last_assigned_upload_callback = id;
	        id = 0;
	      }

	      if (!id) {
	        var order = this.files.data.order;
	        var complete = true;
	        if (order.length) for (var i = 0; i < order.length; i++) {
	          complete = !this.send(order[i]) && complete;
	        }
	        if (complete) this._upload_complete();
	        return;
	      }

	      var item = this.files.getItem(id);
	      if (item.status !== "client") return false;
	      assert(this._settings.upload, "You need to define upload url for uploader component");
	      item.status = "transfer";
	      var formData = new FormData();
	      formData.append(this.config.inputName, item.file, item.name);
	      formData.append(this.config.inputName + "_fullpath", item.name);
	      var headers = {};
	      var globalData = this._settings.formData || {};
	      if (typeof globalData === "function") globalData = globalData.call(this);
	      var details = exports.extend(item.formData || {}, globalData);
	      var xhr = new XMLHttpRequest();

	      var url = this._get_active_url(item);

	      if (callEvent("onBeforeAjax", ["POST", url, details, xhr, headers, formData])) {
	        for (var key in details) {
	          formData.append(key, details[key]);
	        }

	        item.xhr = xhr;
	        xhr.upload.addEventListener("progress", bind(function (e) {
	          this.$updateProgress(id, e.loaded / e.total * 100);
	        }, this), false);
	        xhr.onload = bind(function () {
	          if (!xhr.aborted) this._file_complete(id);
	        }, this);
	        xhr.open("POST", url, true);

	        for (var _key in headers) {
	          xhr.setRequestHeader(_key, headers[_key]);
	        }

	        xhr.send(formData);
	      }

	      this.$updateProgress(id, 0);
	      return true;
	    },
	    _file_complete: function (id) {
	      var item = this.files.getItem(id);

	      if (item) {
	        var response = null;

	        if (item.xhr.status < 400) {
	          var driver = DataDriver[this._settings.datatype || "json"];
	          response = driver.toObject(item.xhr.responseText);
	          if (response) response = driver.getDetails(response);
	        }

	        if (!response || response.status == "error") {
	          // file upload error
	          item.status = "error";
	          delete item.percent;
	          this.files.updateItem(id);
	          this.callEvent("onFileUploadError", [item, response]);
	        } else {
	          // file upload complete
	          assert(!response.status || response.status == "server", "Not supported status value, use 'error' or 'server'");

	          this._complete(id, response);
	        }

	        delete item.xhr;
	      }
	    },
	    stopUpload: function (id) {
	      bind(this._stop_file, this.files)(id);
	    },
	    _stop_file: function (id) {
	      var item = this.getItem(id);

	      if (typeof item.xhr !== "undefined") {
	        item.xhr.aborted = true;
	        item.xhr.abort();
	        delete item.xhr;
	        item.status = "client";
	      }
	    }
	  }
	};

	var ValidateCollection = {
	  _validate_init_once: function () {
	    this.data.attachEvent("onStoreUpdated", bind(function (id, data, mode) {
	      if (id && (mode == "add" || mode == "update")) this.validate(id);
	    }, this));
	    this.data.attachEvent("onClearAll", bind(this.clearValidation, this));

	    this._validate_init_once = function () {};
	  },
	  rules_setter: function (value) {
	    if (value) {
	      this._validate_init_once();
	    }

	    return value;
	  },
	  clearValidation: function () {
	    this.data.clearMark("webix_invalid", true);
	  },
	  validate: function (id) {
	    var result = true;
	    if (!id) for (var key in this.data.pull) {
	      result = this.validate(key) && result;
	    } else {
	      this._validate_details = {};
	      var obj = this.getItem(id);
	      result = ValidateData.validate.call(this, null, obj);

	      if (result) {
	        if (this.callEvent("onValidationSuccess", [id, obj])) this._clear_invalid(id);
	      } else {
	        if (this.callEvent("onValidationError", [id, obj, this._validate_details])) this._mark_invalid(id, this._validate_details);
	      }
	    }
	    return result;
	  },
	  _validate: function (rule, data, obj, key) {
	    if (typeof rule == "string") rule = rules[rule];
	    var res = rule.call(this, data, obj, key);

	    if (!res) {
	      this._validate_details[key] = true;
	    }

	    return res;
	  },
	  _clear_invalid: function (id) {
	    this.data.removeMark(id, "webix_invalid", true);
	  },
	  _mark_invalid: function (id) {
	    this.data.addMark(id, "webix_invalid", true);
	  }
	};

	var Values = {
	  $init: function () {
	    this.elements = {};
	  },
	  focus: function (name) {
	    if (name) {
	      assert(this.elements[name], "unknown input name: " + name);

	      this._focus(this.elements[name]);
	    } else {
	      for (var n in this.elements) {
	        if (this._focus(this.elements[n]) !== false) return true;
	      }
	    }

	    return false;
	  },
	  _focus: function (target) {
	    if (target && target.focus) {
	      return target.focus();
	    }

	    return false;
	  },
	  setValues: function (data, update) {
	    if (this._settings.complexData) data = CodeParser.collapseNames(data);

	    this._inner_setValues(data, update);
	  },
	  _inner_setValues: function (data, update) {
	    this._is_form_dirty = update; //prevent onChange calls from separate controls

	    this.blockEvent();
	    if (!update || !this._values) this._values = {};

	    for (var name in data) {
	      if (!this.elements[name]) this._values[name] = data[name];
	    }

	    for (var _name in this.elements) {
	      var input = this.elements[_name];

	      if (input) {
	        if (!isUndefined(data[_name])) input.setValue(data[_name]);else if (!update && input.$allowsClear) input.setValue("");
	        this._values[_name] = input.getValue();
	      }
	    }

	    this.unblockEvent();
	    this.callEvent("onValues", []);
	  },
	  isDirty: function () {
	    if (this._is_form_dirty) return true;
	    if (this.getDirtyValues(1) === 1) return true;
	    return false;
	  },
	  setDirty: function (flag) {
	    this._is_form_dirty = flag;
	    if (!flag) this._values = this._inner_getValues();
	  },
	  getDirtyValues: function () {
	    var result = {};

	    if (this._values) {
	      for (var name in this.elements) {
	        var value = this.elements[name].getValue();

	        if (this._values[name] != value) {
	          result[name] = value; //FIXME - used by isDirty

	          if (arguments[0]) return 1;
	        }
	      }
	    }

	    return result;
	  },
	  getCleanValues: function () {
	    return this._values;
	  },
	  getValues: function (filter) {
	    var data = this._inner_getValues(filter);

	    if (this._settings.complexData) data = CodeParser.expandNames(data);
	    return data;
	  },
	  _inner_getValues: function (filter) {
	    //get original data		
	    var success,
	        elem = null,
	        data = this._values ? copy(this._values) : {}; //update properties from linked controls

	    for (var name in this.elements) {
	      elem = this.elements[name];
	      success = true;

	      if (filter) {
	        if (_typeof(filter) == "object") {
	          if (filter.hidden === false) success = elem.isVisible();
	          if (success && filter.disabled === false) success = elem.isEnabled();
	        } else success = filter.call(this, elem);
	      }

	      if (success) data[name] = elem.getValue();else delete data[name]; //in case of this._values[name]
	    }

	    return data;
	  },
	  clear: function () {
	    this._is_form_dirty = false;
	    var data = {};

	    for (var name in this.elements) {
	      if (this.elements[name].$allowsClear) data[name] = "";
	    }

	    this._inner_setValues(data);
	  },
	  markInvalid: function (name, state) {
	    // remove 'invalid' mark
	    if (state === false) {
	      this._clear_invalid(name);
	    } // add 'invalid' mark
	    else {
	        // set invalidMessage
	        if (typeof state == "string") {
	          var input = this.elements[name];
	          if (input) input._settings.invalidMessage = state;
	        }

	        this._mark_invalid(name);
	      }
	  },
	  _mark_invalid: function (id) {
	    var input = this.elements[id];

	    if (id && input) {
	      this._clear_invalid(id, true);

	      addCss(input._viewobj, "webix_invalid");
	      input._settings.invalid = true;
	      var message = input._settings.invalidMessage;
	      if (typeof message === "string" && input.setBottomText) input.setBottomText();
	    }
	  },
	  _clear_invalid: function (id, silent) {
	    var input = this.elements[id];

	    if (id && input && input.$view && input._settings.invalid) {
	      removeCss(input._viewobj, "webix_invalid");
	      input._settings.invalid = false;
	      var message = input._settings.invalidMessage;
	      if (typeof message === "string" && !silent && input.setBottomText) input.setBottomText();
	    }
	  }
	};

	/*
		Renders collection of items
		Always shows y-scroll
		Can be used with huge datasets
		
		@export
			show
			render
	*/

	var VirtualRenderStack = {
	  $init: function () {
	    assert(this.render, "VirtualRenderStack :: Object must use RenderStack first");
	    this._htmlmap = {}; //init map of rendered elements
	    //we need to repaint area each time when view resized or scrolling state is changed

	    _event(this._viewobj, "scroll", bind(this._render_visible_rows, this));

	    if (env.touch) {
	      this.attachEvent("onAfterScroll", bind(this._render_visible_rows, this));
	    } //here we store IDs of elemenst which doesn't loadede yet, but need to be rendered


	    this._unrendered_area = [];
	  },
	  //return html object by item's ID. Can return null for not-rendering element
	  getItemNode: function (search_id) {
	    //collection was filled in _render_visible_rows
	    return this._htmlmap[search_id];
	  },
	  //adjust scrolls to make item visible
	  showItem: function (id) {
	    var range = this._getVisibleRange();

	    var ind = this.data.getIndexById(id); //we can't use DOM method for not-rendered-yet items, so fallback to pure math

	    var dy = Math.floor(ind / range._dx) * range._y;

	    var state = this.getScrollState();
	    if (dy < state.y || dy + this._settings.height >= state.y + this._content_height) this.scrollTo(0, dy);
	  },
	  //repain self after changes in DOM
	  //for add, delete, move operations - render is delayed, to minify performance impact
	  render: function (id, data, type) {
	    if (!this.isVisible(this._settings.id) || this.$blockRender) return;

	    if (id) {
	      var cont = this.getItemNode(id); //old html element

	      switch (type) {
	        case "update":
	          if (!cont) return; //replace old with new

	          var t = this._htmlmap[id] = this._toHTMLObject(data);

	          insertBefore(t, cont);
	          remove(cont);
	          break;

	        default:
	          // "move", "add", "delete"

	          /*
	          	for all above operations, full repainting is necessary
	          	but from practical point of view, we need only one repainting per thread
	          	code below initiates double-thread-rendering trick
	          */
	          this._render_delayed();

	          break;
	      }
	    } else {
	      //full repainting
	      if (this.callEvent("onBeforeRender", [this.data])) {
	        this._htmlmap = {}; //nulify links to already rendered elements

	        this._render_visible_rows(null, true); // clear delayed-rendering, because we already have repaint view


	        this._wait_for_render = false;
	        this.callEvent("onAfterRender", []);
	      }
	    }
	  },
	  //implement double-thread-rendering pattern
	  _render_delayed: function () {
	    //this flag can be reset from outside, to prevent actual rendering 
	    if (this._wait_for_render) return;
	    this._wait_for_render = true;
	    window.setTimeout(bind(function () {
	      this.render();
	    }, this), 1);
	  },
	  //create empty placeholders, which will take space before rendering
	  _create_placeholder: function (height) {
	    if (env.maxHTMLElementSize) height = Math.min(env.maxHTMLElementSize, height);
	    var node = document.createElement("DIV");
	    node.style.cssText = "height:" + height + "px; width:100%; overflow:hidden;";
	    return node;
	  },

	  /*
	  	Methods get coordinatest of visible area and checks that all related items are rendered
	  	If, during rendering, some not-loaded items was detected - extra data loading is initiated.
	  	reset - flag, which forces clearing of previously rendered elements
	  */
	  _render_visible_rows: function (e, reset) {
	    this._unrendered_area = []; //clear results of previous calls

	    var viewport = this._getVisibleRange(); //details of visible view


	    if (!this._dataobj.firstChild || reset) {
	      //create initial placeholder - for all view space
	      this._dataobj.innerHTML = "";

	      this._dataobj.appendChild(this._create_placeholder(viewport._max)); //register placeholder in collection


	      this._htmlrows = [this._dataobj.firstChild];
	    }
	    /*
	    	virtual rendering breaks all view on rows, because we know widht of item
	    	we can calculate how much items can be placed on single row, and knowledge 
	    	of that, allows to calculate count of such rows
	    	
	    	each time after scrolling, code iterate through visible rows and render items 
	    	in them, if they are not rendered yet
	    	
	    	both rendered rows and placeholders are registered in _htmlrows collection
	    */
	    //position of first visible row


	    var t = viewport._from;

	    while (t <= viewport._height) {
	      //loop for all visible rows
	      //skip already rendered rows
	      while (this._htmlrows[t] && this._htmlrows[t]._filled && t <= viewport._height) {
	        t++;
	      } //go out if all is rendered


	      if (t > viewport._height) break; //locate nearest placeholder

	      var holder = t;

	      while (!this._htmlrows[holder]) {
	        holder--;
	      }

	      var holder_row = this._htmlrows[holder]; //render elements in the row			

	      var base = t * viewport._dx + (this.data.$min || 0); //index of rendered item

	      if (base > (this.data.$max || Infinity)) break; //check that row is in virtual bounds, defined by paging

	      var nextpoint = Math.min(base + viewport._dx - 1, this.data.$max ? this.data.$max - 1 : Infinity);

	      var node = this._create_placeholder(viewport._y); //all items in rendered row


	      var range = this.data.getIndexRange(base, nextpoint);
	      if (!range.length) break;
	      var loading = {
	        $template: "Loading"
	      };

	      for (var i = 0; i < range.length; i++) {
	        if (!range[i]) this._unrendered_area.push(base + i);
	        range[i] = this._toHTML(range[i] || loading);
	      }

	      node.innerHTML = range.join(""); //actual rendering

	      for (var _i = 0; _i < range.length; _i++) {
	        //register all new elements for later usage in getItemNode
	        this._htmlmap[this.data.getIdByIndex(base + _i)] = node.childNodes[_i];
	      } //correct placeholders


	      var h = parseFloat(holder_row.style.height, 10);
	      var delta = (t - holder) * viewport._y;
	      var delta2 = h - delta - viewport._y; //add new row to the DOOM

	      insertBefore(node, delta ? holder_row.nextSibling : holder_row, this._dataobj);
	      this._htmlrows[t] = node;
	      node._filled = true;
	      /*
	      	if new row is at start of placeholder - decrease placeholder's height
	      	else if new row takes whole placeholder - remove placeholder from DOM
	      	else 
	      		we are inserting row in the middle of existing placeholder
	      		decrease height of existing one, and add one more, 
	      		before the newly added row
	      */

	      if (delta <= 0 && delta2 > 0) {
	        holder_row.style.height = delta2 + "px";
	        this._htmlrows[t + 1] = holder_row;
	      } else {
	        if (delta < 0) remove(holder_row);else holder_row.style.height = delta + "px";

	        if (delta2 > 0) {
	          var new_space = this._htmlrows[t + 1] = this._create_placeholder(delta2);

	          insertBefore(new_space, node.nextSibling, this._dataobj);
	        }
	      }

	      t++;
	    } //when all done, check for non-loaded items


	    if (this._unrendered_area.length) {
	      //we have some data to load
	      //detect borders
	      var from = this._unrendered_area[0];
	      var to = this._unrendered_area.pop() + 1;

	      if (to > from) {
	        //initiate data loading
	        var count = to - from;
	        if (this._maybe_loading_already(count, from)) return;
	        count = Math.max(count, this._settings.datafetch || this._settings.loadahead || 0);
	        this.loadNext(count, from);
	      }
	    }
	  },
	  //calculates visible view
	  _getVisibleRange: function () {
	    var state = this.getScrollState();
	    var top = Math.max(0, state.y);
	    var width = this._content_width;
	    var height = this._content_height; //size of single item

	    var t = this.type;
	    var dx = Math.floor(width / t.width) || 1; //at least single item per row

	    var min = Math.floor(top / t.height); //index of first visible row

	    var dy = Math.ceil((height + top) / t.height) - 1; //index of last visible row
	    //total count of items, paging can affect this math

	    var count = this.data.$max ? this.data.$max - this.data.$min : this.data.count();
	    var max = Math.ceil(count / dx) * t.height; //size of view in rows

	    return {
	      _from: min,
	      _height: dy,
	      _top: top,
	      _max: max,
	      _y: t.height,
	      _dx: dx
	    };
	  },
	  _cellPosition: function (id) {
	    var html = this.getItemNode(id);

	    if (!html) {
	      this.showItem(id);

	      this._render_visible_rows();

	      html = this.getItemNode(id);
	    }

	    return {
	      left: html.offsetLeft,
	      top: html.offsetTop,
	      height: html.offsetHeight,
	      width: html.offsetWidth,
	      parent: this._contentobj
	    };
	  }
	};

	/*
		Renders collection of items on demand
	*/

	var VRenderStack = {
	  $init: function () {
	    this._htmlmap = {};

	    if (Touch.$active) {
	      this.attachEvent("onBeforeScroll", function () {
	        this._in_touch_scroll = true;
	      });
	      this.attachEvent("onAfterScroll", function () {
	        this.render(null, null, "paint");
	        this._in_touch_scroll = false;
	      });
	      this.attachEvent("onTouchMove", function () {
	        if (this._in_touch_scroll) {
	          this.blockEvent();
	          this.render(null, null, "paint");
	          this.unblockEvent();
	        }
	      });
	    } else {
	      _event(this._viewobj, "scroll", bind(function () {
	        this.render(null, null, "paint");
	      }, this));
	    }
	  },
	  _sync_scroll: function (x, y, t) {
	    if (this._settings.footer) Touch._set_matrix(this._footer.childNodes[1].firstChild, x, 0, t);
	    this.callEvent("onSyncScroll", [x, y, t]);
	  },
	  //return html container by its ID
	  //can return undefined if container doesn't exists
	  getItemNode: function (search_id) {
	    return this._htmlmap && this._htmlmap[search_id];
	  },

	  /*change scrolling state of top level container, so related item will be in visible part*/
	  showItem: function (id) {
	    var index$$1 = this.data.getIndexById(id);

	    if (index$$1 > -1) {
	      var top = index$$1 * this.type.height;
	      var bottom = top + this.type.height;
	      var scroll = this.getScrollState();
	      var box = offset(this.$view);
	      if (top < scroll.y) this.scrollTo(0, top);else if (bottom > scroll.y + box.height) this.scrollTo(0, bottom - box.height);
	    }
	  },
	  //update view after data update
	  //when called without parameters - all view refreshed
	  render: function (id, data, type) {
	    if (!this.isVisible(this._settings.id) || this.$blockRender) return;
	    var parent = this._renderobj || this._dataobj;

	    if (id) {
	      if (type == "paint" || type == "update") {
	        var cont = this.getItemNode(id); //get html element of updated item

	        if (cont) {
	          var t = this._htmlmap[id] = this._toHTMLObject(data);

	          t.style.top = cont.style.top;
	          t.style.position = "absolute";
	          t.style.left = 0;
	          t.style.width = "100%";
	          insertBefore(t, cont);
	          remove(cont);
	          return;
	        } //updating not rendered yet item


	        return;
	      }
	    }

	    if (type != "paint") {
	      //repaint all
	      this._htmlmap = {};
	      parent.innerHTML = "";
	    } //full reset


	    if (this.callEvent("onBeforeRender", [this.data])) {
	      var count = this.data.count();
	      var scroll = this.getScrollState();
	      var box = offset(this._viewobj);
	      var top = Math.floor(scroll.y / this.type.height) - 2;
	      var bottom = Math.ceil((scroll.y + box.height) / this.type.height) + 2;
	      top = Math.max(0, top);
	      bottom = Math.min(this.data.count() - 1, bottom);
	      var html = [];

	      for (var i = top; i <= bottom; i++) {
	        var sid = this.data.order[i];

	        if (!this._htmlmap[sid]) {
	          var item = this.data.getItem(sid);

	          if (!item) {
	            this._run_load_next({
	              count: bottom - i + (this._settings.loadahead || 0),
	              start: i
	            });

	            break;
	          }

	          html.push(this._toHTML(item));
	        } else {
	          html.push("<div></div>");
	        }
	      }

	      this._html.innerHTML = html.join("");
	      parent.style.position = "relative";
	      parent.style.height = count * this.type.height + "px";
	      var kids = this._html.childNodes;

	      for (var _i = kids.length - 1; _i >= 0; _i--) {
	        var child = kids[_i];
	        var cid = child.getAttribute(this._id);

	        if (cid) {
	          child.style.position = "absolute";
	          child.style.top = (top + _i) * this.type.height + "px";
	          child.style.left = 0;
	          child.style.width = "100%";
	          parent.appendChild(child);
	          this._htmlmap[cid] = child;
	        }
	      }

	      this.callEvent("onAfterRender", []);
	    }
	  },
	  $setSize: function () {
	    if (base.api.$setSize.apply(this, arguments)) {
	      this.render(null, null, "paint");
	    }
	  },
	  _run_load_next: function (conf) {
	    var count = Math.max(conf.count, this._settings.datafetch || this._settings.loadahead || 0);
	    if (this._maybe_loading_already(conf.count, conf.start)) return;
	    this.loadNext(count, conf.start);
	  }
	};

	var version$1 = "6.2.0";
	var name$1 = "core";

	var errorMessage = "non-existing view for export";

	function getDataHelper(key, column, raw) {
	  if (!raw && column.format) return function (obj) {
	    return column.format(obj[key]);
	  };
	  return function (obj) {
	    return obj[key];
	  };
	}

	function getExportScheme(view, options) {
	  var scheme = [];
	  var h_count = 0,
	      f_count = 0;
	  var isTable = view.getColumnConfig;
	  var columns = options.columns;
	  var raw = !!options.rawValues;
	  scheme.heights = {};

	  if (!columns) {
	    if (isTable) columns = [].concat(view._columns);else {
	      columns = [];
	      var obj = view.data.pull[view.data.order[0]];

	      for (var key in obj) {
	        if (key !== "id" && key[0] != "$") columns.push({
	          id: key
	        });
	      }
	    }
	  } else if (!columns.length) {
	    //export options are set as - columns:{ rank:true, title:{ header:"custom"}}
	    var arr = [];

	    for (var _key in columns) {
	      arr.push(exports.extend({
	        id: _key
	      }, exports.extend({}, columns[_key])));
	    }

	    columns = arr;
	  }

	  if (options.ignore) for (var i = columns.length - 1; i >= 0; i--) {
	    if (options.ignore[columns[i].id]) columns.splice(i, 1);
	  }
	  if (options.id) scheme.push({
	    id: "id",
	    width: 50,
	    header: " ",
	    template: function (obj) {
	      return obj.id;
	    }
	  });

	  if (options.flatTree) {
	    var flatKey = options.flatTree.id;
	    var copy$$1 = [].concat(options.flatTree.columns);
	    var fill = [];
	    var fillMode = !!options.flatTree.fill;

	    for (var _i = 1; _i <= copy$$1.length; _i++) {
	      copy$$1[_i - 1].template = function (i) {
	        return function (obj) {
	          return obj.$level == i ? fill[i] = obj[flatKey] : fillMode && i < obj.$level ? fill[i] : "";
	        };
	      }(_i);
	    }

	    var index = 0;

	    for (var _i2 = columns.length - 1; _i2 >= 0; _i2--) {
	      if (columns[_i2].id === flatKey) index = _i2;
	    }

	    columns = [].concat(columns.slice(0, index)).concat(copy$$1).concat(columns.slice(index + 1));
	  }

	  for (var j = 0; j < columns.length; j++) {
	    var column = columns[j];
	    var _key2 = column.id;
	    if (column.noExport) continue; // raw mode has sense only for datatable
	    // in other cases we don't have built-in data templates

	    var rawColumn = raw && isTable;

	    if (isTable) {
	      var sourceColumn = view._columns_pull[_key2]; // when these's no column to take raw data from, or custom template defined - ignore raw mode

	      if (column.template && (!sourceColumn || sourceColumn.template != column.template)) rawColumn = false;
	      if (sourceColumn) column = exports.extend(exports.extend({}, column), sourceColumn);
	    }

	    var record = {
	      id: column.id,
	      template: rawColumn || !column.template ? getDataHelper(_key2, column, raw) : column.template,
	      width: (column.width || 200) * (options.export_mode === "excel" ? 8.43 / 70 : 1),
	      header: column.header !== false ? column.header || _key2 : ""
	    };

	    if (options.export_mode === "excel") {
	      exports.extend(record, {
	        type: column.exportType || "",
	        format: column.exportFormat || ""
	      });
	    }

	    if (typeof record.header === "string") record.header = [{
	      text: record.header
	    }];else record.header = copy(record.header);

	    for (var _i3 = 0; _i3 < record.header.length; _i3++) {
	      var hcell = record.header[_i3] || {};
	      var text = hcell.contentId ? view.getHeaderContent(hcell.contentId).getValue(true) : hcell.text;
	      record.header[_i3] = (text || "").toString().replace(/<[^>]*>/gi, "");
	    }

	    h_count = Math.max(h_count, record.header.length);

	    if (view._settings.footer) {
	      var footer = column.footer || "";
	      if (typeof footer == "string") footer = [{
	        text: footer
	      }];else footer = copy(footer);

	      for (var _i4 = 0; _i4 < footer.length; _i4++) {
	        if (footer[_i4]) footer[_i4] = footer[_i4].contentId ? view.getHeaderContent(footer[_i4].contentId).getValue() : footer[_i4].text;else footer[_i4] = "";
	      }

	      record.footer = footer;
	      f_count = Math.max(f_count, record.footer.length);
	    }

	    scheme.push(record);
	  }

	  for (var _i5 = 0; _i5 < scheme.length; _i5++) {
	    var diff = h_count - scheme[_i5].header.length;

	    for (var d = 0; d < diff; d++) {
	      scheme[_i5].header.push("");
	    }

	    if (view._settings.footer) {
	      diff = f_count - scheme[_i5].footer.length;

	      for (var _d = 0; _d < diff; _d++) {
	        scheme[_i5].footer.push("");
	      }
	    }
	  }

	  return scheme;
	}
	function getExportData(view, options, scheme) {
	  var filterHTML = !!options.filterHTML;
	  var htmlFilter = /<[^>]*>/gi;
	  var data = [];
	  var header, headers;
	  var mode = options.export_mode;

	  if ((mode === "excel" || mode == "csv") && options.docHeader) {
	    data = [[(options.docHeader.text || options.docHeader).toString()], [""]];
	    if (mode === "excel" && options.docHeader.height) scheme.heights[0] = options.docHeader.height;
	  }

	  if (options.header !== false && scheme.length) {
	    for (var h = 0; h < scheme[0].header.length; h++) {
	      headers = [];

	      for (var i = 0; i < scheme.length; i++) {
	        header = "";

	        if (scheme[i].header[h]) {
	          header = scheme[i].header[h];
	          if (filterHTML) header = scheme[i].header[h] = header.replace(htmlFilter, "");
	        }

	        headers.push(header);
	      }

	      if (mode == "excel" && view._columns && options.heights !== false && (view._headers[h] !== $active.barHeight || options.heights == "all")) scheme.heights[data.length] = view._headers[h];
	      if (mode !== "pdf") data[data.length] = headers;
	    }
	  }

	  options.yCorrection = (options.yCorrection || 0) - data.length;
	  var isTree = view.data.name == "TreeStore";
	  var treeline = options.flatTree || options.plainOutput ? "" : " - ";
	  view.data.each(function (item) {
	    if (!options.filter || options.filter(item)) {
	      if (this.data._scheme_export) {
	        item = view.data._scheme_export(item);
	      }

	      var line = [];

	      for (var _i6 = 0; _i6 < scheme.length; _i6++) {
	        var column = scheme[_i6],
	            cell = null; //spreadsheet can output math

	        if (options.math && item["$" + column.id] && item["$" + column.id].charAt(0) == "=" && !item["$" + column.id].match(/^=(image|link|sparkline)\(/i)) cell = item["$" + column.id];

	        if (this._spans_pull) {
	          var span = this.getSpan(item.id, column.id);

	          if (span && span[4] && span[0] == item.id && span[1] == column.id) {
	            cell = span[4];
	            if (filterHTML && typeof cell === "string") cell = cell.replace(htmlFilter, "");
	          }
	        }

	        if (!cell) {
	          cell = column.template(item, view.type, item[column.id], column, _i6);
	          if (!cell && cell !== 0) cell = "";

	          if (filterHTML && typeof cell === "string") {
	            if (isTree) cell = cell.replace(/<div class=.webix_tree_none.><\/div>/, treeline);
	            cell = cell.replace(htmlFilter, "");
	          } //remove end/start spaces(ex.hierarchy data)


	          if (typeof cell === "string" && mode === "csv") cell = cell.trim(); //for multiline data

	          if (typeof cell === "string" && (mode === "excel" || mode === "csv")) {
	            cell = cell.replace(/<br\s*\/?>/mg, "\n");
	          }
	        }

	        line.push(cell);
	      }

	      if (mode == "excel" && view._columns && options.heights !== false && (item.$height && item.$height !== $active.rowHeight || options.heights == "all")) scheme.heights[data.length] = item.$height || this.config.rowHeight;
	      data.push(line);
	    }
	  }, view);

	  if (options.footer !== false) {
	    var f_count = scheme[0].footer ? scheme[0].footer.length : 0;

	    for (var f = 0; f < f_count; f++) {
	      var footers = [];

	      for (var _i7 = 0; _i7 < scheme.length; _i7++) {
	        var footer = scheme[_i7].footer[f];
	        if (filterHTML) footer = scheme[_i7].footer[f] = footer.toString().replace(htmlFilter, "");
	        footers.push(footer);
	      }

	      if (mode == "excel" && view._columns && options.heights !== false && (view._footers[f] !== $active.barHeight || options.heights == "all")) scheme.heights[data.length] = view._footers[f];
	      if (mode !== "pdf") data.push(footers);
	    }
	  }

	  if (mode === "excel" && options.docFooter) {
	    data = data.concat([[], [(options.docFooter.text || options.docFooter).toString()]]);
	    if (options.docFooter.height) scheme.heights[data.length - 1] = options.docFooter.height;
	  }

	  return data;
	}

	var toPNG = function (id, options) {
	  var defer = Deferred.defer();
	  return require(env.cdn + "/extras/html2canvas-1.0.min.js").then(function () {
	    //backward compatibility
	    if (typeof options === "string") options = {
	      filename: options
	    };
	    options = options || {};
	    var view = $$(id);
	    if (view && view.$exportView) view = view.$exportView(options);
	    assert(view, errorMessage);
	    if (!view) return defer.reject(errorMessage);
	    var node = view ? view.$view : toNode(id);
	    var filename = (options.filename || "Data") + ".png";
	    window.html2canvas(node, {
	      background: "#fff",
	      logging: false
	    }).then(function (canvas) {
	      var callback = function (data) {
	        if (options.download !== false) download(data, filename);
	        canvas.remove();
	        defer.resolve(data);
	      };

	      if (canvas.msToBlob) callback(canvas.msToBlob());else canvas.toBlob(callback, "image/png");
	    });
	    return defer;
	  });
	};

	var toCSV = function (id, options) {
	  options = options || {};
	  var view = $$(id);
	  if (view && view.$exportView) view = view.$exportView(options);
	  assert(view, errorMessage);
	  if (!view) return Deferred.reject(errorMessage);
	  options.export_mode = "csv";
	  options.filterHTML = true;
	  var scheme = getExportScheme(view, options);
	  var result = getExportData(view, options, scheme);
	  var data = getCsvData(result, scheme);
	  var filename = (options.filename || "Data") + ".csv";
	  var blob = new Blob(["\uFEFF" + data], {
	    type: "text/csv"
	  });
	  if (options.download !== false) download(blob, filename);
	  return Deferred.resolve(blob);
	};

	function getCsvData(data) {
	  return csv$1.stringify(data);
	}

	var font = {};
	var toPDF = function (id, options) {
	  return require([env.cdn + "/extras/pdfjs.js", env.cdn + "/extras/html2canvas-1.0.min.js"]).then(function () {
	    options = options || {};
	    options.export_mode = "pdf";
	    options._export_font = font;
	    options.fontName = options.fontName || "pt-sans.regular";
	    options.display = options.display || "table";
	    id = isArray(id) ? id : [id];
	    var views = [];

	    for (var i = 0; i < id.length; i++) {
	      if (!id[i].id) id[i] = {
	        id: id[i]
	      };
	      var view = $$(id[i].id);
	      var viewOptions = exports.extend(id[i].options || {}, options);
	      if (view && view.$exportView) view = view.$exportView(viewOptions);

	      if (view) {
	        if (viewOptions.display !== "table") {
	          views.push({
	            node: view.$view,
	            viewOptions: viewOptions
	          });
	          if (options.autowidth) options.width = Math.max(options.width || 0, view.$view.$width);
	        }

	        if (viewOptions.display !== "image" && view.data && view.data.pull) {
	          var scheme = getExportScheme(view, viewOptions);
	          views.push({
	            scheme: scheme,
	            data: getExportData(view, viewOptions, scheme),
	            viewOptions: viewOptions
	          });
	          if (options.autowidth) options.width = Math.max(options.width || 0, getAutowidth(scheme));
	        }
	      }

	      assert(view, errorMessage);
	    }

	    if (views.length == 0) return Deferred.reject(errorMessage);

	    if (font[options.fontName]) {
	      options._export_font = font[options.fontName];
	      return getPdfData(views, options).then(function (pdf) {
	        return getBlob(pdf, options);
	      });
	    } else {
	      var defer = Deferred.defer();
	      /* global pdfjs */

	      pdfjs.load(env.cdn + "/extras/" + options.fontName + ".ttf", function (err, buf) {
	        if (err) throw err;
	        options._export_font = font[options.fontName] = new pdfjs.TTFFont(buf);
	        defer.resolve(getPdfData(views, options).then(function (pdf) {
	          return getBlob(pdf, options);
	        }));
	      });
	      return defer;
	    }
	  });
	};

	function getBlob(pdf, options) {
	  var filename = (options.filename || "Data") + ".pdf";
	  var blob = new Blob([pdf.toString()], {
	    type: "application/pdf"
	  });
	  if (options.download !== false) download(blob, filename);
	  return blob;
	}

	function getPdfData(views, options) {
	  var doc = addPDFDoc(options);
	  var promises = [];

	  for (var i = 0; i < views.length; i++) {
	    if (views[i].node) promises.push(getPDFImage(views[i].node));else promises.push(Deferred.resolve());
	  }

	  return Deferred.all(promises).then(function (images) {
	    for (var _i = 0; _i < promises.length; _i++) {
	      var viewOptions = views[_i].viewOptions;
	      if (viewOptions.textBefore) addText(doc, "before", viewOptions.textBefore);
	      if (images[_i]) doc.image(images[_i], {
	        align: "center"
	      });else addPDFTable(views[_i].scheme, views[_i].data, viewOptions, doc);
	      if (viewOptions.textAfter) addText(doc, "after", viewOptions.textAfter);
	      if (_i != views.length - 1) doc.pageBreak();
	    }

	    return addPDFHeader(doc, options);
	  });
	}

	function addText(doc, type, text) {
	  if (type == "after") doc.text().br();
	  if (typeof text == "string") text = {
	    text: text
	  };
	  doc.text(text.text, text.options || {});
	  if (type == "before") doc.text().br();
	}

	function getPDFImage(node) {
	  return window.html2canvas(node, {
	    background: "#fff",
	    logging: false
	  }).then(function (canvas) {
	    var defer = Deferred.defer();
	    var image = canvas.toDataURL("image/jpeg");
	    pdfjs.load(image, function (err, buffer) {
	      defer.resolve(new pdfjs.Image(buffer));
	    });
	    return defer;
	  });
	}

	function getAutowidth(scheme) {
	  var width = 80; //paddings

	  for (var i = 0; i < scheme.length; i++) {
	    width += scheme[i].width;
	  }

	  return width;
	}

	function addPDFDoc(options) {
	  var width = options.width || 595.296,
	      height = options.height || 841.896; // default A4 size

	  if (options.orientation && options.orientation === "landscape") height = [width, width = height][0];
	  return new pdfjs.Document({
	    padding: 40,
	    font: options._export_font,
	    threshold: 256,
	    width: width,
	    height: height
	  });
	}

	function addPDFTable(scheme, data, options, doc) {
	  options.header = isUndefined(options.header) || options.header === true ? {} : options.header;
	  options.footer = isUndefined(options.footer) || options.footer === true ? {} : options.footer;
	  options.table = options.table || {}; //render table

	  var h_count = options.header === false ? 0 : scheme[0].header.length;
	  var f_count = options.footer === false || !scheme[0].footer ? 0 : scheme[0].footer.length;
	  var colWidths = [];

	  for (var i = 0; i < scheme.length; i++) {
	    colWidths[i] = scheme[i].width;
	  }

	  var tableOps = exports.extend(options.table, {
	    borderWidth: 1,
	    height: 20,
	    lineHeight: 1.1,
	    borderColor: 0xEEEEEE,
	    backgroundColor: 0xFFFFFF,
	    color: 0x666666,
	    textAlign: "left",
	    paddingRight: 10,
	    paddingLeft: 10,
	    headerRows: h_count,
	    widths: colWidths.length ? colWidths : ["100%"]
	  });
	  var table = doc.table(tableOps); //render table header

	  if (h_count) {
	    var headerOps = exports.extend(options.header, {
	      borderRightColor: 0xB0CEE3,
	      borderBottomColor: 0xB0CEE3,
	      color: 0x4A4A4A,
	      backgroundColor: 0xD2E3EF,
	      height: 27,
	      lineHeight: 1.2
	    });

	    for (var _i2 = 0; _i2 < h_count; _i2++) {
	      var header = table.tr(headerOps);

	      for (var s = 0; s < scheme.length; s++) {
	        header.td(scheme[s].header[_i2].toString());
	      }
	    }
	  } //render table data


	  for (var r = 0; r < data.length; r++) {
	    var row = table.tr({});

	    for (var c = 0; c < data[r].length; c++) {
	      row.td(data[r][c]);
	    }
	  } //render table footer


	  if (f_count) {
	    var footerOps = exports.extend(options.footer, {
	      borderRightColor: 0xEEEEEE,
	      borderBottomColor: 0xEEEEEE,
	      backgroundColor: 0xFAFAFA,
	      color: 0x666666,
	      height: 27,
	      lineHeight: 1.2
	    });

	    for (var _i3 = 0; _i3 < f_count; _i3++) {
	      var footer = table.tr(footerOps);

	      for (var _s = 0; _s < scheme.length; _s++) {
	        footer.td(scheme[_s].footer[_i3].toString());
	      }
	    }
	  }
	}

	function addPDFHeader(doc, options) {
	  //doc footer
	  if (options.docFooter !== false) {
	    var ft = doc.footer();
	    ft.text({
	      color: 0x666666,
	      textAlign: "center"
	    }).append(i18n.dataExport.page || "Page").pageNumber().append("  " + (i18n.dataExport.of || "of") + "  ").pageCount();
	  }

	  var horder = {
	    text: 0,
	    image: 1
	  }; //doc header, configurable

	  if (options.docHeader) {
	    if (typeof options.docHeader == "string") options.docHeader = {
	      text: options.docHeader
	    };
	    exports.extend(options.docHeader, {
	      color: 0x666666,
	      textAlign: "right",
	      order: 0
	    });
	    horder.text = options.docHeader.order;
	  }

	  if (options.docHeaderImage) {
	    if (typeof options.docHeaderImage == "string") options.docHeaderImage = {
	      url: options.docHeaderImage
	    };
	    exports.extend(options.docHeaderImage, {
	      align: "right",
	      order: 1
	    });
	    horder.image = options.docHeaderImage.order;
	  }

	  if (options.docHeader && horder.image > horder.text) doc.header({
	    paddingBottom: 10
	  }).text(options.docHeader.text, options.docHeader);

	  if (options.docHeaderImage) {
	    var defer = Deferred.defer();
	    pdfjs.load(options.docHeaderImage.url, function (err, buffer) {
	      if (!err) {
	        var img = new pdfjs.Image(buffer);
	        doc.header({
	          paddingBottom: 10
	        }).image(img, options.docHeaderImage);
	        if (options.docHeader && horder.image < horder.text) doc.header({
	          paddingBottom: 10
	        }).text(options.docHeader.text, options.docHeader);
	      } //render pdf and show in browser


	      defer.resolve(doc.render());
	    });
	    return defer;
	  } else return Deferred.resolve(doc.render());
	}

	var toExcel = function (id, options) {
	  options = options || {};
	  options.export_mode = "excel";
	  id = isArray(id) ? id : [id];
	  var views = [];

	  for (var i = 0; i < id.length; i++) {
	    var view = $$(id[i]);
	    if (view && view.$exportView) view = view.$exportView(options);
	    if (view) views = views.concat(view);
	    assert(view, errorMessage); //spreadsheet and excelviewer require plain data output first

	    if (options.dataOnly) {
	      var scheme = getExportScheme(view, options);
	      views[i] = {
	        scheme: scheme,
	        exportData: getExportData(view, options, scheme),
	        spans: options.spans ? getSpans(view, options) : []
	      };
	    }
	  }

	  if (options.dataOnly) return views;
	  var defer = Deferred.defer();
	  return require(env.cdn + "/extras/xlsx.core.styles.min.js").then(function () {
	    if (!views.length) return defer.reject(errorMessage);
	    var wb = {
	      SheetNames: [],
	      Sheets: {},
	      Workbook: {
	        WBProps: {},
	        Names: []
	      }
	    };
	    var name = isArray(options.sheets) ? options.sheets : [options.name || "Data"];

	    for (var i = 0; i < views.length; i++) {
	      var scheme = views[i].scheme || getExportScheme(views[i], options);
	      var result = views[i].exportData || getExportData(views[i], options, scheme);
	      var spans = views[i].spans ? views[i].spans : options.spans ? getSpans(views[i], options) : [];
	      var ranges = views[i].ranges || [];
	      var styles = views[i].styles || [];
	      var data = getExcelData(result, scheme, spans, styles, options);
	      var sname = (name[i] || "Data" + i).replace(/[*?:[\]\\/]/g, "").replace(/&/g, "&amp;").substring(0, 31);
	      wb.SheetNames.push(sname);
	      wb.Sheets[sname] = data;
	      wb.Workbook.Names = wb.Workbook.Names.concat(ranges);
	    }
	    /* global XLSX */


	    var xls = XLSX.write(wb, {
	      bookType: "xlsx",
	      bookSST: false,
	      type: "binary"
	    });
	    var filename = (options.filename || name.join(",")) + ".xlsx";
	    var blob = new Blob([str2array(xls)], {
	      type: "application/xlsx"
	    });
	    if (options.download !== false) download(blob, filename);
	    defer.resolve(blob);
	    return defer;
	  });
	};

	function str2array(s) {
	  var buf = new ArrayBuffer(s.length);
	  var view = new Uint8Array(buf);

	  for (var i = 0; i != s.length; ++i) {
	    view[i] = s.charCodeAt(i) & 0xFF;
	  }

	  return buf;
	}

	var types = {
	  number: "n",
	  date: "n",
	  string: "s",
	  boolean: "b"
	};
	var table = "_table";

	function getExcelData(data, scheme, spans, styles, options) {
	  var ws = {};
	  var range = {
	    s: {
	      c: 10000000,
	      r: 10000000
	    },
	    e: {
	      c: 0,
	      r: 0
	    }
	  };

	  for (var R = 0; R != data.length; ++R) {
	    for (var C = 0; C != data[R].length; ++C) {
	      if (range.s.r > R) range.s.r = R;
	      if (range.s.c > C) range.s.c = C;
	      if (range.e.r < R) range.e.r = R;
	      if (range.e.c < C) range.e.c = C;
	      var cell = {
	        v: data[R][C]
	      };
	      if (cell.v === null) continue;
	      var cell_ref = XLSX.utils.encode_cell({
	        c: C,
	        r: R
	      });
	      var stringValue = cell.v.toString();
	      var isFormula = stringValue.charAt(0) === "="; // set type based on column's config
	      // skip headers and formula based cells

	      var header = (options.docHeader ? 2 : 0) + scheme[0].header.length;

	      if (R >= header && !isFormula) {
	        var column = scheme[C];
	        if (column.type) cell.t = types[column.type] || "";
	        if (column.format) cell.z = column.format;
	      } // set type based on cell's value


	      if (cell.v instanceof Date) {
	        cell.t = cell.t || "n";
	        cell.z = cell.z || XLSX.SSF[table][14];
	        cell.v = excelDate(cell.v);
	      } else if (!cell.t) {
	        if (typeof cell.v === "boolean") cell.t = "b";else if (typeof cell.v === "number" || parseFloat(cell.v) == cell.v) {
	          cell.v = cell.v * 1;
	          cell.t = "n";
	        } else {
	          // convert any other object to a string
	          cell.v = stringValue;

	          if (isFormula) {
	            cell.t = "n";
	            cell.f = cell.v;
	            delete cell.v;
	          } else cell.t = "s";
	        }
	      }

	      if (styles) {
	        var cellStyle = getStyles(R, C, styles);

	        if (cellStyle.format) {
	          cell.z = cellStyle.format;
	          delete cellStyle.format;
	        }

	        cell.s = cellStyle;
	      }

	      ws[cell_ref] = cell;
	    }
	  }

	  if (range.s.c < 10000000) ws["!ref"] = XLSX.utils.encode_range(range);
	  ws["!rows"] = getRowHeights(scheme.heights);
	  ws["!cols"] = getColumnsWidths(scheme);
	  if (spans.length) ws["!merges"] = spans;
	  return ws;
	}

	function getRowHeights(heights) {
	  for (var i in heights) {
	    heights[i] = {
	      hpx: heights[i],
	      hpt: heights[i] * 0.75
	    };
	  }

	  return heights;
	}

	function getStyles(r, c, styles) {
	  //row index, column index, styles array
	  if (styles[r] && styles[r][c]) return styles[r][c];
	  return "";
	}

	function getSpans(view, options) {
	  var isTable = view.getColumnConfig;
	  var pull = view._spans_pull;
	  var spans = [];

	  if (isTable) {
	    if (options.header !== false) spans = getHeaderSpans(view, options, "header", spans);

	    if (pull) {
	      var xc = options.xCorrection || 0;
	      var yc = options.yCorrection || 0;

	      for (var row in pull) {
	        //{ s:{c:1, r:0}, e:{c:3, r:0} }
	        var cols = pull[row];

	        for (var col in cols) {
	          var sc = view.getColumnIndex(col) - xc;
	          var sr = view.getIndexById(row) - yc;
	          if (sc < 0 || sr < 0) //hidden cols/rows
	            continue;
	          var ec = sc + cols[col][0] - 1;
	          var er = sr + (cols[col][1] - 1);
	          spans.push({
	            s: {
	              c: sc,
	              r: sr
	            },
	            e: {
	              c: ec,
	              r: er
	            }
	          });
	        }
	      }
	    }

	    if (options.footer !== false) spans = getHeaderSpans(view, options, "footer", spans);
	  }

	  return spans;
	}

	function getHeaderSpans(view, options, group, spans) {
	  var columns = view.config.columns;
	  var delta = (options.docHeader ? 2 : 0) + (group == "header" ? 0 : (options.header !== false ? view._headers.length : 0) + view.count());

	  for (var i = 0; i < columns.length; i++) {
	    var header = columns[i][group];

	    for (var h = 0; h < header.length; h++) {
	      if (header[h] && (header[h].colspan || header[h].rowspan)) {
	        spans.push({
	          s: {
	            c: i,
	            r: h + delta
	          },
	          e: {
	            c: i + (header[h].colspan || 1) - 1,
	            r: h + (header[h].rowspan || 1) - 1 + delta
	          }
	        });
	      }
	    }
	  }

	  return spans;
	}

	function excelDate(date) {
	  return Math.round(25569 + date / (24 * 60 * 60 * 1000));
	}

	function getColumnsWidths(scheme) {
	  var wscols = [];

	  for (var i = 0; i < scheme.length; i++) {
	    wscols.push({
	      wch: scheme[i].width
	    });
	  }

	  return wscols;
	}

	function callback(config, result) {
	  config.type.indexOf("confirm") != -1 && result === false ? config._promise.reject() : config._promise.resolve(result);
	  var usercall = config.callback;
	  if (usercall) usercall(result, config.details);
	  modalbox.hide(config.id);
	}

	function modal_key(e) {
	  var count = modalbox.order.length;

	  if (count > 0 && message.keyboard) {
	    e = e || event$1;
	    var code = e.which || event$1.keyCode;
	    var lastModalbox = modalbox.pull[modalbox.order[count - 1]];
	    if (code == 13 || code == 32) callback(lastModalbox, true);
	    if (code == 27) callback(lastModalbox, false);
	    if (e.preventDefault) e.preventDefault();
	    return !(e.cancelBubble = true);
	  }
	}

	event$1(document, "keydown", modal_key, {
	  capture: true
	});

	function modality(mode, container) {
	  var node = container || document.body;
	  var cover;

	  if (isUndefined(node.modality)) {
	    cover = create("DIV", {
	      class: "webix_modal_cover",
	      style: "position:" + (container ? "absolute" : "fixed") + ";"
	    });
	    cover.onkeydown = modal_key;

	    if (container) {
	      var position = window.getComputedStyle(container).position;
	      if (position != "fixed" && position != "absolute" && position != "sticky" && position != "relative") node.style.position = "relative";
	    }

	    node.appendChild(cover);
	    node.modality = 1;
	  } else mode ? node.modality++ : node.modality--; //trigger visibility only if necessary


	  if (mode && node.modality === 1 || node.modality === 0) {
	    if (cover) cover.style.display = "inline-block";else {
	      cover = node.querySelectorAll(".webix_modal_cover");

	      for (var i = 0; i < cover.length; i++) {
	        if (cover[i].parentNode == node) {
	          cover[i].style.display = node.modality == 1 ? "inline-block" : "none";
	          break;
	        }
	      }
	    }
	  }
	}

	function button(text, result, className) {
	  return "<div role='button' tabindex='0' aria-label='" + text + "' class='webix_popup_button" + (className ? " " + className : "") + "' result='" + result + "' ><div>" + text + "</div></div>";
	}

	function info(text) {
	  if (!t.area) {
	    t.area = document.createElement("DIV");
	    t.area.className = "webix_message_area";
	    t.area.style[t.position] = "5px";
	    document.body.appendChild(t.area);
	  }

	  t.area.setAttribute("role", "alert");
	  t.area.setAttribute("aria-atomic", true);
	  t.hide(text.id);
	  var message = document.createElement("DIV");
	  message.innerHTML = "<div>" + text.text + "</div>";
	  message.className = "webix_message webix_" + text.type;

	  message.onclick = function () {
	    t.hide(text.id);
	    text = null;
	  };
	  if (t.position == "bottom" && t.area.firstChild) t.area.insertBefore(message, t.area.firstChild);else t.area.appendChild(message);
	  if (text.expire > 0) t.timers[text.id] = window.setTimeout(function () {
	    t.hide(text.id);
	  }, text.expire); //styling for animation

	  message.style.height = message.offsetHeight - 2 + "px";
	  t.pull[text.id] = message;
	  message = null;
	  return text.id;
	}

	function _boxStructure(config, ok, cancel) {
	  var box = document.createElement("DIV");
	  box.className = " webix_modal_box webix_" + config.type;
	  box.setAttribute("webixbox", 1);
	  box.setAttribute("role", "alertdialog");
	  box.setAttribute("aria-label", config.title || "");
	  box.setAttribute("tabindex", "0");
	  var inner = "";
	  if (config.width) box.style.width = config.width + (rules.isNumber(config.width) ? "px" : "");
	  if (config.height) box.style.height = config.height + (rules.isNumber(config.height) ? "px" : "");
	  if (config.title) inner += "<div class=\"webix_popup_title\">" + config.title + "</div>";
	  inner += "<div class=\"webix_popup_text\"><span>" + (config.content ? "" : config.text) + "</span></div><div  class=\"webix_popup_controls\">";
	  if (cancel) inner += button(config.cancel || i18n.message.cancel, false);
	  if (ok) inner += button(config.ok || i18n.message.ok, true, "confirm");

	  if (config.buttons && !ok && !cancel) {
	    for (var i = 0; i < config.buttons.length; i++) {
	      inner += button(config.buttons[i], i);
	    }
	  }

	  inner += "</div>";
	  box.innerHTML = inner;

	  if (config.content) {
	    var node = config.content;
	    if (typeof node == "string") node = document.getElementById(node);
	    if (node.style.display == "none") node.style.display = "";
	    box.childNodes[config.title ? 1 : 0].appendChild(node);
	  }

	  box.onclick = function (e) {
	    e = e || event$1;
	    var source = e.target || e.srcElement;
	    if (!source.className) source = source.parentNode;

	    if (source.className.indexOf("webix_popup_button") != -1) {
	      var result = source.getAttribute("result");
	      result = result == "true" || (result == "false" ? false : result);
	      callback(config, result);
	    }

	    e.cancelBubble = true;
	  };

	  config._box = box;
	  return box;
	}

	modalbox.pull = {};
	modalbox.order = [];

	function _createBox(config, ok, cancel) {
	  var box = config.tagName ? config : _boxStructure(config, ok, cancel);
	  var containerWidth = config.container ? config.container.offsetWidth : window.innerWidth || document.documentElement.offsetWidth;
	  var containerHeight = config.container ? config.container.offsetHeight : window.innerHeight || document.documentElement.offsetHeight;
	  if (config.container) box.style.position = "absolute";
	  toNode((config.container || document.body).appendChild(box));
	  modality(true, config.container);
	  var x = config.left || Math.abs(Math.floor((containerWidth - box.offsetWidth) / 2));
	  var y = config.top || Math.abs(Math.floor((containerHeight - box.offsetHeight) / 2));
	  if (config.position == "top") box.style.top = "-3px";else box.style.top = y + "px";
	  box.style.left = x + "px"; //necessary for IE only

	  box.onkeydown = modal_key;
	  box.focus();
	  if (!config.id) config.id = _uid("modalbox");else if (modalbox.pull[config.id]) {
	    modalbox.hide(config.id);
	  }
	  modalbox.order.push(config.id);
	  modalbox.pull[config.id] = config;
	  config._promise = Deferred.defer();
	  return config._promise;
	}

	function alertPopup(config) {
	  return _createBox(config, true);
	}

	function confirmPopup(config) {
	  return _createBox(config, true, true);
	}

	function boxPopup(config) {
	  return _createBox(config);
	}

	function box_params(text, type, callback) {
	  if (_typeof(text) != "object") {
	    if (typeof type == "function") {
	      callback = type;
	      type = "";
	    }

	    text = {
	      text: text,
	      type: type,
	      callback: callback
	    };
	  }

	  return text;
	}

	function params(text, type, expire, id) {
	  if (_typeof(text) != "object") text = {
	    text: text,
	    type: type,
	    expire: expire,
	    id: id
	  };
	  text.id = text.id || _uid("message");
	  text.expire = text.expire || t.expire;
	  return text;
	}

	function alert() {
	  var text = box_params.apply(this, arguments);
	  text.type = text.type || "alert";
	  return alertPopup(text);
	}
	function confirm() {
	  var text = box_params.apply(this, arguments);
	  text.type = text.type || "confirm";
	  return confirmPopup(text);
	}
	function modalbox() {
	  var text = box_params.apply(this, arguments);
	  text.type = text.type || "alert";
	  return boxPopup(text);
	}

	modalbox.hide = function (id) {
	  if (id && modalbox.pull[id]) {
	    var node = modalbox.pull[id]._box;

	    if (node) {
	      node.parentNode.removeChild(node);
	      modalbox.order.splice(modalbox.order.indexOf(id), 1);
	      modality(false, modalbox.pull[id].container);
	      delete modalbox.pull[id];
	    }
	  }
	};

	modalbox.hideAll = function () {
	  for (var id in modalbox.pull) {
	    this.hide(id);
	  }
	};

	function message(text, type, expire, id) {
	  //eslint-disable-line
	  text = params.apply(this, arguments);
	  text.type = text.type || "info";
	  var subtype = text.type.split("-")[0];

	  switch (subtype) {
	    case "alert":
	      return alertPopup(text);

	    case "confirm":
	      return confirmPopup(text);

	    case "modalbox":
	      return boxPopup(text);

	    default:
	      return info(text);
	  }
	}
	var t = message;
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function () {
	  for (var key in t.pull) {
	    t.hide(key);
	  }
	};

	t.hide = function (id) {
	  var obj = t.pull[id];

	  if (obj && obj.parentNode) {
	    window.setTimeout(function () {
	      obj.parentNode.removeChild(obj);
	      obj = null;
	    }, 2000); //styling for animation

	    obj.style.height = 0;
	    obj.className += " hidden";
	    t.area.removeAttribute("role");
	    if (t.timers[id]) window.clearTimeout(t.timers[id]);
	    delete t.pull[id];
	  }
	}; //override circualr dependencies


	define("message", message);

	function editStop() {
	  callEvent("onEditEnd", []);
	}

	if (env.isIE8) {
	  // Not really a polyfill, silence the esModule flag
	  Object.defineProperty = function (obj, key, data) {
	    obj[key] = data.value;
	  };
	}

	var en = {
	  groupDelimiter: ",",
	  groupSize: 3,
	  decimalDelimiter: ".",
	  decimalSize: 2,
	  dateFormat: "%m/%d/%Y",
	  timeFormat: "%h:%i %A",
	  longDateFormat: "%d %F %Y",
	  fullDateFormat: "%m/%d/%Y %h:%i %A",
	  am: ["am", "AM"],
	  pm: ["pm", "PM"],
	  price: "${obj}",
	  priceSettings: {
	    groupDelimiter: ",",
	    groupSize: 3,
	    decimalDelimiter: ".",
	    decimalSize: 2
	  },
	  fileSize: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb"],
	  calendar: {
	    monthFull: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    monthShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	    dayFull: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    dayShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    hours: "Hours",
	    minutes: "Minutes",
	    done: "Done",
	    clear: "Clear",
	    today: "Today"
	  },
	  dataExport: {
	    page: "Page",
	    of: "of"
	  },
	  PDFviewer: {
	    of: "of",
	    automaticZoom: "Automatic Zoom",
	    actualSize: "Actual Size",
	    pageFit: "Page Fit",
	    pageWidth: "Page Width",
	    pageHeight: "Page Height",
	    enterPassword: "Enter password",
	    passwordError: "Wrong password"
	  },
	  aria: {
	    calendar: "Calendar",
	    increaseValue: "Increase value",
	    decreaseValue: "Decrease value",
	    navMonth: ["Previous month", "Next month"],
	    navYear: ["Previous year", "Next year"],
	    navDecade: ["Previous decade", "Next decade"],
	    dateFormat: "%d %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Hours: %h %A",
	    minuteFormat: "Minutes: %i",
	    removeItem: "Remove item",
	    pages: ["First page", "Previous page", "Next page", "Last page"],
	    page: "Page",
	    headermenu: "Header menu",
	    openGroup: "Open column group",
	    closeGroup: "Close column group",
	    closeTab: "Close tab",
	    showTabs: "Show more tabs",
	    resetTreeMap: "Reset tree map",
	    navTreeMap: "Level up",
	    nextTab: "Next tab",
	    prevTab: "Previous tab",
	    multitextSection: "Add section",
	    multitextextraSection: "Remove section",
	    showChart: "Show chart",
	    hideChart: "Hide chart",
	    resizeChart: "Resize chart"
	  },
	  richtext: {
	    underline: "Underline",
	    bold: "Bold",
	    italic: "Italic"
	  },
	  combo: {
	    select: "Select",
	    selectAll: "Select all",
	    unselectAll: "Unselect all"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Cancel"
	  },
	  comments: {
	    send: "Send",
	    confirmMessage: "The comment will be removed. Are you sure?",
	    edit: "Edit",
	    remove: "Remove",
	    placeholder: "Type here..",
	    moreComments: "More comments"
	  }
	};

	var wDate = {
	  startOnMonday: false,
	  toFixed: function (num, ms) {
	    if (num < 10) num = "0" + num;
	    if (ms && num < 100) num = "0" + num;
	    return num;
	  },
	  weekStart: function (date) {
	    date = this.copy(date);
	    var shift = date.getDay();

	    if (this.startOnMonday) {
	      if (shift === 0) shift = 6;else shift--;
	    }

	    return this.datePart(this.add(date, -1 * shift, "day"));
	  },
	  monthStart: function (date) {
	    date = this.copy(date);
	    date.setDate(1);
	    return this.datePart(date);
	  },
	  yearStart: function (date) {
	    date = this.copy(date);
	    date.setMonth(0);
	    return this.monthStart(date);
	  },
	  dayStart: function (date) {
	    return this.datePart(date, true);
	  },
	  dateToStr: function (format, utc) {
	    if (typeof format == "function") return format;

	    if (env.strict) {
	      return function (date) {
	        var str = "";
	        var lastPos = 0;
	        format.replace(/%[a-zA-Z]/g, function (s, pos) {
	          str += format.slice(lastPos, pos);

	          var fn = function (date) {
	            if (s == "%d") return wDate.toFixed(date.getDate());
	            if (s == "%m") return wDate.toFixed(date.getMonth() + 1);
	            if (s == "%j") return date.getDate();
	            if (s == "%n") return date.getMonth() + 1;
	            if (s == "%y") return wDate.toFixed(date.getFullYear() % 100);
	            if (s == "%Y") return date.getFullYear();
	            if (s == "%D") return i18n.calendar.dayShort[date.getDay()];
	            if (s == "%l") return i18n.calendar.dayFull[date.getDay()];
	            if (s == "%M") return i18n.calendar.monthShort[date.getMonth()];
	            if (s == "%F") return i18n.calendar.monthFull[date.getMonth()];
	            if (s == "%h") return wDate.toFixed((date.getHours() + 11) % 12 + 1);
	            if (s == "%g") return (date.getHours() + 11) % 12 + 1;
	            if (s == "%G") return date.getHours();
	            if (s == "%H") return wDate.toFixed(date.getHours());
	            if (s == "%i") return wDate.toFixed(date.getMinutes());
	            if (s == "%a") return date.getHours() > 11 ? i18n.pm[0] : i18n.am[0];
	            if (s == "%A") return date.getHours() > 11 ? i18n.pm[1] : i18n.am[1];
	            if (s == "%s") return wDate.toFixed(date.getSeconds());
	            if (s == "%S") return wDate.toFixed(date.getMilliseconds(), true);
	            if (s == "%W") return wDate.toFixed(Date.getISOWeek(date));

	            if (s == "%c") {
	              var str = date.getFullYear();
	              str += "-" + wDate.toFixed(date.getMonth() + 1);
	              str += "-" + wDate.toFixed(date.getDate());
	              str += "T";
	              str += wDate.toFixed(date.getHours());
	              str += ":" + wDate.toFixed(date.getMinutes());
	              str += ":" + wDate.toFixed(date.getSeconds());
	              return str;
	            }

	            return s;
	          };

	          str += fn(date);
	          lastPos = pos + 2;
	        });
	        str += format.slice(lastPos, format.length);
	        return str;
	      };
	    }

	    format = format.replace(/%[a-zA-Z]/g, function (a) {
	      switch (a) {
	        case "%d":
	          return "\"+wDate.toFixed(date.getDate())+\"";

	        case "%m":
	          return "\"+wDate.toFixed((date.getMonth()+1))+\"";

	        case "%j":
	          return "\"+date.getDate()+\"";

	        case "%n":
	          return "\"+(date.getMonth()+1)+\"";

	        case "%y":
	          return "\"+wDate.toFixed(date.getFullYear()%100)+\"";

	        case "%Y":
	          return "\"+date.getFullYear()+\"";

	        case "%D":
	          return "\"+i18n.calendar.dayShort[date.getDay()]+\"";

	        case "%l":
	          return "\"+i18n.calendar.dayFull[date.getDay()]+\"";

	        case "%M":
	          return "\"+i18n.calendar.monthShort[date.getMonth()]+\"";

	        case "%F":
	          return "\"+i18n.calendar.monthFull[date.getMonth()]+\"";

	        case "%h":
	          return "\"+wDate.toFixed((date.getHours()+11)%12+1)+\"";

	        case "%g":
	          return "\"+((date.getHours()+11)%12+1)+\"";

	        case "%G":
	          return "\"+date.getHours()+\"";

	        case "%H":
	          return "\"+wDate.toFixed(date.getHours())+\"";

	        case "%i":
	          return "\"+wDate.toFixed(date.getMinutes())+\"";

	        case "%a":
	          return "\"+(date.getHours()>11?i18n.pm[0]:i18n.am[0])+\"";

	        case "%A":
	          return "\"+(date.getHours()>11?i18n.pm[1]:i18n.am[1])+\"";

	        case "%s":
	          return "\"+wDate.toFixed(date.getSeconds())+\"";

	        case "%S":
	          return "\"+wDate.toFixed(date.getMilliseconds(), true)+\"";

	        case "%W":
	          return "\"+wDate.toFixed(wDate.getISOWeek(date))+\"";

	        case "%c":
	          var str = "\"+date.getFullYear()+\"";
	          str += "-\"+wDate.toFixed((date.getMonth()+1))+\"";
	          str += "-\"+wDate.toFixed(date.getDate())+\"";
	          str += "T";
	          str += "\"+wDate.toFixed(date.getHours())+\"";
	          str += ":\"+wDate.toFixed(date.getMinutes())+\"";
	          str += ":\"+wDate.toFixed(date.getSeconds())+\"";
	          if (utc === true) str += "Z";
	          return str;

	        default:
	          return a;
	      }
	    });
	    if (utc === true) format = format.replace(/date\.get/g, "date.getUTC");
	    var temp = new Function("date", "i18n", "wDate", "if (!date) return ''; if (!date.getMonth) date=i18n.parseFormatDate(date);  return \"" + format + "\";");
	    return function (v) {
	      return temp(v, i18n, wDate);
	    };
	  },
	  strToDate: function (format, utc) {
	    if (typeof format == "function") return format;
	    var mask = format.match(/%[a-zA-Z]/g);
	    var splt = "var temp=date.split(/[^0-9a-zA-Z]+/g);";
	    var i, t, s;

	    if (!i18n.calendar.monthShort_hash) {
	      s = i18n.calendar.monthShort;
	      t = i18n.calendar.monthShort_hash = {};

	      for (i = 0; i < s.length; i++) {
	        t[s[i]] = i;
	      }

	      s = i18n.calendar.monthFull;
	      t = i18n.calendar.monthFull_hash = {};

	      for (i = 0; i < s.length; i++) {
	        t[s[i]] = i;
	      }
	    }

	    if (env.strict) {
	      return function (date) {
	        if (!date) return "";
	        if (_typeof(date) == "object") return date;
	        var temp = date.split(/[^0-9a-zA-Z]+/g);
	        var set = [0, 0, 1, 0, 0, 0, 0];

	        for (i = 0; i < mask.length; i++) {
	          var a = mask[i];
	          if (a == "%y") set[0] = temp[i] * 1 + (temp[i] > 30 ? 1900 : 2000);else if (a == "%Y") {
	            set[0] = (temp[i] || 0) * 1;
	            if (set[0] < 30) set[0] += 2000;
	          } else if (a == "%n" || a == "%m") set[1] = (temp[i] || 1) - 1;else if (a == "%M") set[1] = i18n.calendar.monthShort_hash[temp[i]] || 0;else if (a == "%F") set[1] = i18n.calendar.monthFull_hash[temp[i]] || 0;else if (a == "%j" || a == "%d") set[2] = temp[i] || 1;else if (a == "%g" || a == "%G" || a == "%h" || a == "%H") set[3] = temp[i] || 0;else if (a == "%a") set[3] = set[3] % 12 + ((temp[i] || "") == i18n.am[0] ? 0 : 12);else if (a == "%A") set[3] = set[3] % 12 + ((temp[i] || "") == i18n.am[1] ? 0 : 12);else if (a == "%i") set[4] = temp[i] || 0;else if (a == "%s") set[5] = temp[i] || 0;else if (a == "%S") set[6] = temp[i] || 0;else if (a == "%c") {
	            var reg = /(\d+)-(\d+)-(\d+)T(\d+):(\d+):(\d+)(\+.*|)/g;
	            var res = reg.exec(date);
	            set[0] = (res[1] || 0) * 1;
	            if (set[0] < 30) set[0] += 2000;
	            set[1] = (res[2] || 1) - 1;
	            set[2] = res[3] || 1;
	            set[3] = res[4] || 0;
	            set[4] = res[5] || 0;
	            set[5] = res[6] || 0;
	          }
	        }

	        if (utc) return new Date(Date.UTC(set[0], set[1], set[2], set[3], set[4], set[5], set[6]));
	        return new Date(set[0], set[1], set[2], set[3], set[4], set[5], set[6]);
	      };
	    }

	    for (i = 0; i < mask.length; i++) {
	      switch (mask[i]) {
	        case "%j":
	        case "%d":
	          splt += "set[2]=temp[" + i + "]||1;";
	          break;

	        case "%n":
	        case "%m":
	          splt += "set[1]=(temp[" + i + "]||1)-1;";
	          break;

	        case "%y":
	          splt += "set[0]=temp[" + i + "]*1+(temp[" + i + "]>30?1900:2000);";
	          break;

	        case "%g":
	        case "%G":
	        case "%h":
	        case "%H":
	          splt += "set[3]=temp[" + i + "]||0;";
	          break;

	        case "%i":
	          splt += "set[4]=temp[" + i + "]||0;";
	          break;

	        case "%Y":
	          splt += "set[0]=(temp[" + i + "]||0)*1; if (set[0]<30) set[0]+=2000;";
	          break;

	        case "%a":
	          splt += "set[3]=set[3]%12+(temp[" + i + "]==i18n.am[0]?0:12);";
	          break;

	        case "%A":
	          splt += "set[3]=set[3]%12+(temp[" + i + "]==i18n.am[1]?0:12);";
	          break;

	        case "%s":
	          splt += "set[5]=temp[" + i + "]||0;";
	          break;

	        case "%S":
	          splt += "set[6]=temp[" + i + "]||0;";
	          break;

	        case "%M":
	          splt += "set[1]=i18n.calendar.monthShort_hash[temp[" + i + "]]||0;";
	          break;

	        case "%F":
	          splt += "set[1]=i18n.calendar.monthFull_hash[temp[" + i + "]]||0;";
	          break;

	        case "%c":
	          splt += "var res = date.split('T');";
	          splt += "if(res[0]){ var d = res[0].split('-');";
	          splt += "set[0]= (d[0]||0)*1; if (set[0]<30) set[0]+=2000;";
	          splt += "set[1]= (d[1]||1)-1;";
	          splt += "set[2]= d[2]||1;}";
	          splt += "if(res[1]){ var t = res[1].split(':');";
	          splt += "set[3]= t[0]||0;";
	          splt += "set[4]= t[1]||0;";
	          splt += "set[5]= parseInt(t[2])||0;}";
	          break;

	        default:
	          break;
	      }
	    }

	    var code = "set[0],set[1],set[2],set[3],set[4],set[5], set[6]";
	    if (utc) code = " Date.UTC(" + code + ")";
	    var temp = new Function("date", "i18n", "if (!date) return ''; if (typeof date == 'object') return date; var set=[0,0,1,0,0,0,0]; " + splt + " return new Date(" + code + ");");
	    return function (v) {
	      return temp(v, i18n);
	    };
	  },
	  getISOWeek: function (ndate) {
	    if (!ndate) return false;
	    var nday = ndate.getDay();

	    if (nday === 0) {
	      nday = 7;
	    }

	    var first_thursday = new Date(ndate.valueOf());
	    first_thursday.setDate(ndate.getDate() + (4 - nday));
	    var year_number = first_thursday.getFullYear(); // year of the first Thursday

	    var ordinal_date = Math.floor((first_thursday.getTime() - new Date(year_number, 0, 1).getTime()) / 86400000); //ordinal date of the first Thursday - 1 (so not really ordinal date)

	    var weekNumber = 1 + Math.floor(ordinal_date / 7);
	    return weekNumber;
	  },
	  getUTCISOWeek: function (ndate) {
	    return this.getISOWeek(ndate);
	  },
	  _correctDate: function (d, d0, inc, checkFunc) {
	    if (!inc) return;
	    var incorrect = checkFunc(d, d0);

	    if (incorrect) {
	      var i = inc > 0 ? 1 : -1;

	      while (incorrect) {
	        d.setHours(d.getHours() + i);
	        incorrect = checkFunc(d, d0);
	        i += inc > 0 ? 1 : -1;
	      }
	    }
	  },
	  add: function (date, inc, mode, copy) {
	    if (copy) date = this.copy(date);
	    var d = wDate.copy(date);

	    switch (mode) {
	      case "day":
	        date.setDate(date.getDate() + inc);

	        this._correctDate(date, d, inc, function (d, d0) {
	          return wDate.datePart(d0, true).valueOf() == wDate.datePart(d, true).valueOf();
	        });

	        break;

	      case "week":
	        date.setDate(date.getDate() + 7 * inc);

	        this._correctDate(date, d, 7 * inc, function (d, d0) {
	          return wDate.datePart(d0, true).valueOf() == wDate.datePart(d, true).valueOf();
	        });

	        break;

	      case "month":
	        date.setMonth(date.getMonth() + inc);

	        this._correctDate(date, d, inc, function (d, d0) {
	          return d0.getMonth() == d.getMonth() && d0.getYear() == d.getYear();
	        });

	        break;

	      case "year":
	        date.setYear(date.getFullYear() + inc);

	        this._correctDate(date, d, inc, function (d, d0) {
	          return d0.getFullYear() == d.getFullYear();
	        });

	        break;

	      case "hour":
	        date.setHours(date.getHours() + inc);

	        this._correctDate(date, d, inc, function (d, d0) {
	          return d0.getHours() == d.getHours() && Date.datePart(d0, true) == Date.datePart(d, true);
	        });

	        break;

	      case "minute":
	        date.setMinutes(date.getMinutes() + inc);
	        break;

	      default:
	        wDate.add[mode](date, inc, mode);
	        break;
	    }

	    return date;
	  },
	  datePart: function (date, copy) {
	    if (copy) date = this.copy(date); // workaround for non-existent hours

	    var d = this.copy(date);
	    d.setHours(0);

	    if (d.getDate() != date.getDate()) {
	      date.setHours(1);
	    } else {
	      date.setHours(0);
	    }

	    date.setMinutes(0);
	    date.setSeconds(0);
	    date.setMilliseconds(0);
	    return date;
	  },
	  timePart: function (date, copy) {
	    if (copy) date = this.copy(date);
	    return (date.valueOf() / 1000 - date.getTimezoneOffset() * 60) % 86400;
	  },
	  copy: function (date) {
	    return new Date(date.valueOf());
	  },
	  equal: function (a, b) {
	    if (!a || !b) return false;
	    return a.valueOf() === b.valueOf();
	  },
	  isHoliday: function (day) {
	    day = day.getDay();
	    if (day === 0 || day == 6) return "webix_cal_event";
	  }
	};

	var Number$1 = {
	  getConfig: function (value) {
	    var config = {
	      decimalSize: 0,
	      groupSize: 999,
	      prefix: "",
	      sufix: ""
	    };
	    var parts = value.split(/[0-9].*[0-9]/g);
	    if (parts[0].length) config.prefix = parts[0];
	    if (parts[1].length) config.sufix = parts[1];

	    if (config.prefix || config.sufix) {
	      value = value.substr(config.prefix.length, value.length - config.prefix.length - config.sufix.length);
	    }

	    var num = value.indexOf("1");

	    if (num > 0) {
	      config.prefix = value.substr(0, num);
	      value = value.substr(num);
	    }

	    var dot = value.indexOf("0");

	    if (dot > 0) {
	      config.decimalSize = value.length - dot;
	      config.decimalDelimiter = value[dot - 1];
	      value = value.substr(0, dot - 1);
	    }

	    var sep = value.match(/[^0-9]/);

	    if (sep) {
	      config.groupSize = value.length - sep.index - 1;
	      config.groupDelimiter = value[sep.index];
	    }

	    return config;
	  },
	  parse: function (value, config) {
	    if (!value || typeof value !== "string") return value;
	    if (config.prefix) value = value.toLowerCase().replace(config.prefix.toLowerCase() || "", "");
	    if (config.sufix) value = value.toLowerCase().replace(config.sufix.toLowerCase() || "", "");
	    var decimal = "";

	    if (config.decimalDelimiter) {
	      var ind = value.indexOf(config.decimalDelimiter);

	      if (ind > -1) {
	        decimal = value.substr(ind + 1).replace(/[^0-9]/g, "");
	        decimal = decimal.substr(0, Math.min(decimal.length, config.decimalSize));
	        value = value.substr(0, ind);
	      }
	    }

	    var sign = value[0] === "-" ? -1 : 1;
	    value = value.replace(/[^0-9]/g, "");
	    if (!value) value = "0";
	    if (decimal) value += "." + decimal;
	    return parseFloat(value) * sign;
	  },
	  format: function (value, config) {
	    if (value === "" || typeof value === "undefined") return value;
	    config = config || i18n;
	    value = parseFloat(value);
	    var sign = value < 0 ? "-" : "";
	    value = Math.abs(value);
	    if (!config.decimalOptional) value = value.toFixed(config.decimalSize);
	    var str = value.toString();
	    str = str.split(".");
	    var int_value = "";

	    if (config.groupSize) {
	      var step = config.groupSize;
	      var i = str[0].length;

	      do {
	        i -= step;
	        var chunk = i > 0 ? str[0].substr(i, step) : str[0].substr(0, step + i);
	        int_value = chunk + (int_value ? config.groupDelimiter + int_value : "");
	      } while (i > 0);
	    } else int_value = str[0];

	    if (config.decimalSize) str = sign + int_value + (str[1] ? config.decimalDelimiter + str[1] : "");else str = sign + int_value;

	    if (config.prefix || config.sufix) {
	      return config.prefix + str + config.sufix;
	    } else return str;
	  },
	  numToStr: function (config) {
	    return function (value) {
	      return Number$1.format(value, config);
	    };
	  }
	};

	function extend(base, source) {
	  for (var method in source) {
	    if (_typeof(source[method]) == "object" && !isArray(source[method])) {
	      if (!base[method]) {
	        base[method] = {};
	      }

	      extend(base[method], source[method]);
	    } else base[method] = source[method];
	  }
	}

	var helpers = ["fullDateFormat", "timeFormat", "dateFormat", "longDateFormat", "parseFormat", "parseTimeFormat"];

	i18n.setLocale = function (locale) {
	  if (typeof locale == "string") locale = i18n.locales[locale];

	  if (locale) {
	    locale.priceSettings = copy(locale.priceSettings || locale);
	    extend(i18n, locale);
	  }

	  for (var i = 0; i < helpers.length; i++) {
	    var key = helpers[i];
	    var utc = i18n[key + "UTC"];
	    i18n[key + "Str"] = wDate.dateToStr(i18n[key], utc);
	    i18n[key + "Date"] = wDate.strToDate(i18n[key], utc);
	  }

	  var _price_format = template(i18n.price);

	  var _price_settings = i18n.priceSettings || i18n;

	  i18n.intFormat = Number$1.numToStr({
	    groupSize: i18n.groupSize,
	    groupDelimiter: i18n.groupDelimiter,
	    decimalSize: 0
	  });

	  i18n.priceFormat = function (value) {
	    return _price_format(Number$1.format(value, _price_settings));
	  };

	  i18n.numberFormat = Number$1.format;
	};

	i18n.locales = {
	  "en-US": en
	};
	i18n.setLocale("en-US");

	/*
		Behavior:History - change multiview state on 'back' button

	 */

	var history = {
	  track: function (id, url) {
	    this._init_state(id, url);

	    if (this._aHandler) $$(this._aViewId).detachEvent(this._aHandler);

	    if (id) {
	      this._aViewId = id;
	      var view = $$(id);

	      var handler = function () {
	        if (history._ignored) return;
	        if (view.getValue) history.push(id, view.getValue());
	      };

	      if (view.getActiveId) this._aHandler = view.attachEvent("onViewChange", handler);else this._aHandler = view.attachEvent("onChange", handler);
	    }
	  },
	  _set_state: function (view, state$$1) {
	    history._ignored = 1;
	    view = $$(view);
	    if (view.callEvent("onBeforeHistoryNav", [state$$1])) if (view.setValue) view.setValue(state$$1);
	    history._ignored = 0;
	  },
	  push: function (view, url, value) {
	    view = $$(view);
	    var new_url = "";
	    if (url) new_url = "#!/" + url;

	    if (isUndefined(value)) {
	      if (view.getValue) value = view.getValue();else value = url;
	    }

	    window.history.pushState({
	      webix: true,
	      id: view._settings.id,
	      value: value
	    }, "", new_url);
	  },
	  _init_state: function (view, url) {
	    event$1(window, "popstate", function (ev) {
	      if (ev.state && ev.state.webix) {
	        history._set_state(ev.state.id, ev.state.value);
	      }
	    });
	    var hash = window.location.hash;
	    state.noanimate = true;
	    if (hash && hash.indexOf("#!/") === 0) history._set_state(view, hash.replace("#!/", ""));else if (url) {
	      history.push(view, url);

	      history._set_state(view, url);
	    }
	    state.noanimate = false;

	    this._init_state = function () {};
	  }
	};

	var markup = {
	  namespace: "x",
	  attribute: "data-",
	  dataTag: "li",
	  _dash: /-([a-z])/g,
	  _after_dash: function (match) {
	    return match[1].toUpperCase();
	  },
	  _parse_int: {
	    width: true,
	    height: true,
	    gravity: true,
	    margin: true,
	    padding: true,
	    paddingX: true,
	    paddingY: true,
	    minWidth: true,
	    maxWidth: true,
	    minHeight: true,
	    maxHeight: true,
	    headerRowHeight: true
	  },
	  _parse_bool: {
	    disabled: true,
	    hidden: true
	  },
	  _view_has_method: function (view, name) {
	    return hasMethod(view, name);
	  },
	  init: function (node, target, scope) {
	    node = node || document.body;
	    var els = [];

	    var temp = this._get_core_els(node);

	    var html = temp.html;
	    var ui$$1 = null; //make copy to prevent node removing effects

	    for (var i = temp.length - 1; i >= 0; i--) {
	      els[i] = temp[i];
	    }

	    for (var _i = 0; _i < els.length; _i++) {
	      var config; //collect configuration

	      config = this._sub_markup(els[_i], html);
	      config.$scope = scope;
	      ui$$1 = this._initComponent(config, els[_i], html, target);
	    }

	    return ui$$1;
	  },
	  parse: function (source, mode) {
	    //convert from string to object
	    if (typeof source == "string") source = DataDriver[mode || "xml"].toObject(source, source);

	    var els = this._get_core_els(source, mode);

	    return this._sub_markup(els[0], els.html);
	  },
	  _initComponent: function (config, node, html, target) {
	    if (!target) {
	      config.container = node.parentNode;
	      remove(node);
	    } else config.container = target;

	    if (this._view_has_method(config.view, "setPosition")) delete config.container; //init ui

	    return ui(config);
	  },
	  _get_core_els: function (node) {
	    this._full_prefix = this.namespace ? this.namespace + ":" : "";
	    this._full_prefix_top = this._full_prefix + "ui"; //xhtml mode

	    var els = node.getElementsByTagName(this._full_prefix_top);
	    if (!els.length && node.documentElement && node.documentElement.tagName == this._full_prefix_top) els = [node.documentElement]; //loading from xml file with valid namespace

	    if (!els.length && this.namespace) {
	      els = node.getElementsByTagName("ui");
	      if (!els.length && node.documentElement && node.documentElement.tagName == "ui") els = [node.documentElement];
	    }

	    if (!els.length) {
	      //html mode
	      els = this._get_html_tops(node);
	      els.html = true;
	    }

	    return els;
	  },
	  //html conversion
	  _get_html_tops: function (node) {
	    if (node.getAttribute && node.getAttribute(this.attribute + "view")) return [node];
	    var els = node.querySelectorAll("[" + this.attribute + "view]");
	    var tags = [];

	    for (var i = 0; i < els.length; i++) {
	      if (!els[i].parentNode.getAttribute(this.attribute + "view")) tags.push(els[i]);
	    }

	    return tags;
	  },
	  _sub_markup: function (el, html, json) {
	    var htmltable = false; //ignore top x:ui for xhtml and xml 

	    if (!json) {
	      var name = this._get_name(el, html);

	      if (name == "ui") {
	        var childs = el.childNodes;

	        for (var i = 0; i < childs.length; i++) {
	          if (childs[i].nodeType == 1) {
	            return this._sub_markup(childs[i], html);
	          }
	        }
	      }

	      json = {
	        view: name
	      };

	      if (html && el.tagName.toLowerCase() == "table") {
	        json.data = el;
	        json.datatype = "htmltable";
	        htmltable = true;
	      }
	    }

	    var is_layout = json.view == "cols" || json.view == "rows" || this._view_has_method(json.view, "addView");

	    var subs = [];
	    var has_tags = 0;
	    var allow_sub_tags = !(html || el.style); //only for xml documents

	    var first = el.firstChild;

	    while (first) {
	      //tag node
	      if (first.nodeType == 1) {
	        var _name = this._get_name(first, html);

	        if (_name == "data") {
	          has_tags = 1;
	          var data = first;
	          first = first.nextSibling;
	          json.data = this._handle_data(data, html);
	          continue;
	        } else if (_name == "config") {
	          this._get_config_html(first, json, html);

	          var confignode = first;
	          first = first.nextSibling;
	          remove(confignode);
	          continue;
	        } else if (_name == "column") {
	          has_tags = 1;

	          var column = this._tag_to_json(first, html);

	          column.header = column.header || column.value;
	          column.width = column.width * 1 || "";
	          json.columns = json.columns || [];
	          json.columns.push(column);
	        } else if (_name || is_layout && html) {
	          var obj = this._sub_markup(first, html, {
	            view: _name
	          });

	          if (obj.view == "head") json.head = obj.rows ? obj.rows[0] : obj.template;else if (obj.view == "body") {
	            if (this._view_has_method(json.view, "addView")) {
	              //multiview, accordion
	              //subtag or plain value
	              //in case of multiple sub tags, only first will be used
	              // #dirty
	              subs.push({
	                body: obj.rows ? obj.rows[0] : obj.value,
	                header: obj.header || ""
	              });
	            } else {
	              //window, fieldset
	              //one sub tag - use it
	              //multiple sub tags - create sub layout
	              //or use plain text value
	              json.body = obj.rows ? obj.rows.length == 1 ? obj.rows[0] : {
	                rows: obj.rows
	              } : obj.value;
	            }
	          } else subs.push(obj);
	        } else if (allow_sub_tags) {
	          has_tags = 1;
	          var tagName = first.tagName;
	          if (html) tagName = tagName.toLowerCase().replace(this._dash, this._after_dash);
	          json[tagName] = DataDriver.xml.tagToObject(first);
	        }
	      }

	      first = first.nextSibling;
	    }

	    this._attrs_to_json(el, json, html);

	    if (subs.length) {
	      if (json.stack) {
	        json[json.stack] = subs;
	      } else if (json.subui) {
	        json[json.subui] = subs[0];
	      } else if (this._view_has_method(json.view, "setValues")) {
	        json["elements"] = subs;
	      } else if (json.view == "rows") {
	        json.view = "layout";
	        json.rows = subs;
	      } else if (json.view == "cols") {
	        json.view = "layout";
	        json.cols = subs;
	      } else if (this._view_has_method(json.view, "setValue")) {
	        json["cells"] = subs;
	      } else if (this._view_has_method(json.view, "getBody")) {
	        json.body = subs.length == 1 ? subs[0] : {
	          rows: subs
	        };
	      } else {
	        json["rows"] = subs;
	      }
	    } else if (!htmltable && !has_tags) {
	      if (html && !json.template && (!json.view || json.view == "template")) {
	        json.view = "template";
	        json.content = el;
	      } else {
	        var content = this._content(el, html);

	        if (content) {
	          var target = "template";
	          if (this._view_has_method(json.view, "setValue")) target = "value";
	          json[target] = json[target] || content;
	        }
	      }
	    }

	    return json;
	  },
	  _empty: function (str) {
	    var clean = str.replace(/\s+/gm, "");
	    return clean.length > 0 ? false : true;
	  },
	  _markup_names: {
	    body: 1,
	    head: 1,
	    data: 1,
	    rows: 1,
	    cols: 1,
	    cells: 1,
	    elements: 1,
	    ui: 1,
	    column: 1,
	    config: 1
	  },
	  _get_config_html: function (tag, json, html) {
	    var master = this._attrs_to_json(tag, {});

	    if (master.name) {
	      json[master.name] = master;
	      delete master.name;
	    } else if (master.stack) json[master.stack] = [];else json = master;

	    var childs = tag.childNodes;

	    for (var i = 0; i < childs.length; i++) {
	      var sub = null;
	      if (childs[i].nodeType == 1 && childs[i].tagName.toLowerCase() == "config" && childs[i].attributes.length) sub = this._get_config_html(childs[i], master, html);else if (childs[i].nodeType == 1 && childs[i].tagName.toLowerCase() == "data") {
	        sub = this._handle_data(childs[i], html);
	        if (!master.stack) master.data = sub;
	      } else sub = childs[i].innerHTML;
	      if (master.stack && sub) json[master.stack].push(sub);
	    }

	    return json;
	  },
	  _get_name: function (tag, html) {
	    //value of view attribute or config tag
	    if (html) return tag.getAttribute(this.attribute + "view") || (tag.tagName.toLowerCase() == "config" ? "config" : null);
	    var name = tag.tagName.toLowerCase();

	    if (this.namespace) {
	      if (name.indexOf(this._full_prefix) === 0 || tag.scopeName == this.namespace) return name.replace(this._full_prefix, "");
	    } else {
	      if (ui[name] || this._markup_names[name]) return name;
	    }

	    return 0;
	  },
	  _handle_data: function (el, html) {
	    var data = [];
	    var records = el.getElementsByTagName(markup.dataTag);

	    for (var i = 0; i < records.length; i++) {
	      var rec = records[i];

	      if (rec.parentNode.parentNode.tagName != markup.dataTag) {
	        var json = this._tag_to_json(rec, html); //reuse css class 


	        if (rec.className) json.$css = rec.className;
	        data.push(json);
	      }
	    }

	    remove(el);
	    return data;
	  },
	  _content: function (el) {
	    if (el.style) return el.innerHTML;
	    if (el.firstChild) return el.firstChild.wholeText || el.firstChild.data || "";
	    return "";
	  },
	  _tag_to_json: function (el, html) {
	    if (!html) return DataDriver.xml.tagToObject(el);

	    var json = this._attrs_to_json(el, {}, html);

	    if (!json.value && el.childNodes.length) json.value = this._content(el, html);
	    return json;
	  },
	  _attrs_to_json: function (el, json, html) {
	    var attrs = el.attributes;

	    for (var i = 0; i < attrs.length; i++) {
	      var name = attrs[i].name;

	      if (html) {
	        if (name.indexOf(this.attribute) !== 0) continue;
	        name = name.replace(this.attribute, "").replace(this._dash, this._after_dash);
	      }

	      var value = attrs[i].value;
	      if (value.indexOf("json://") != -1) value = JSON.parse(value.replace("json://", ""));
	      if (this._parse_int[name]) value = parseInt(value, 10);else if (this._parse_bool[name]) value = value && value !== "false" && value != "0";
	      json[name] = value;
	    }

	    return json;
	  }
	};

	env.printPPI = 96;
	env.printMargin = 0.75 * env.printPPI;
	var margin = env.printMargin;
	var papers = {
	  "a4": "A4",
	  "a3": "A3",
	  "letter": "letter"
	};
	var fits = {
	  page: true,
	  data: true
	};
	var modes = {
	  portrait: true,
	  landscape: true
	};
	var sizes = {
	  //inches, real size is value*ppi
	  "A3": {
	    width: 11.7,
	    height: 16.5
	  },
	  "A4": {
	    width: 8.27,
	    height: 11.7
	  },
	  "letter": {
	    width: 8.5,
	    height: 11
	  }
	};

	var print = function (id, options) {
	  var view = $$(id);
	  if (view && view.$printView) view = view.$printView();
	  assert(view, "non-existing view for printing");
	  if (!view) return;
	  if (view.callEvent) view.callEvent("onBeforePrint", [options]);
	  options = _checkOptions(options);

	  _beforePrint(options); //try widget's custom logic first, sometimes it may deny 


	  if (!view.$customPrint || view.$customPrint(options) === true) _print(view, options);

	  _afterPrint(options);
	};
	/*processing print options*/


	function _checkOptions(options) {
	  options = options || {};
	  options.paper = papers[(options.paper || "").toLowerCase()] || "A4";
	  options.mode = modes[options.mode] ? options.mode : "portrait";
	  options.fit = fits[options.fit] ? options.fit : "page";
	  options.scroll = options.scroll || false;
	  options.size = sizes[options.paper];
	  options.margin = options.margin || options.margin === 0 ? options.margin : {};
	  margin = isNaN(options.margin * 1) ? margin : options.margin;
	  options.margin = {
	    top: options.margin.top || options.margin.top === 0 ? options.margin.top : margin,
	    bottom: options.margin.bottom || options.margin.bottom === 0 ? options.margin.bottom : margin,
	    right: options.margin.right || options.margin.right === 0 ? options.margin.right : margin,
	    left: options.margin.left || options.margin.left === 0 ? options.margin.left : margin
	  };
	  return options;
	}
	/*preparing printing environment*/


	function _beforePrint(options) {
	  addCss(document.body, "webix_print");
	  if (options.docHeader) _getHeaderFooter("Header", options);
	  if (options.docFooter) _getHeaderFooter("Footer", options);
	  /* static print styles are located at 'css/print.less'*/

	  var cssString = "@media print { " + "@page{ size:" + options.paper + " " + options.mode + ";" + "margin-top:" + options.margin.top + "px;margin-bottom:" + options.margin.bottom + "px;margin-right:" + options.margin.right + "px;margin-left:" + options.margin.left + "px;}" + "}";
	  addStyle(cssString, "print");
	}
	/*cleaning environment*/


	function _afterPrint(options) {
	  removeCss(document.body, "webix_print");
	  removeStyle("print");
	  if (options.docHeader) remove(options.docHeader);
	  if (options.docFooter) remove(options.docFooter);
	}
	/*common print actions */


	function _print(view, options) {
	  var doc = view.$view.cloneNode(true); //copy data from all canvases

	  var canvases = view.$view.getElementsByTagName("canvas");
	  if (canvases.length) for (var i = canvases.length - 1; i >= 0; i--) {
	    var destCtx = doc.getElementsByTagName("canvas")[i].getContext("2d");
	    destCtx.drawImage(canvases[i], 0, 0);
	  }
	  insertBefore(doc, options.docFooter, document.body);
	  addCss(doc, "webix_ui_print");
	  if (!options.scroll && (view._dataobj && view.data && view.data.pull || view.getBody)) addCss(doc, "webix_print_noscroll");
	  window.print();
	  remove(doc);
	}
	/*custom header nad footer*/


	function _getHeaderFooter(group, options) {
	  var header = create("div", {
	    "class": "webix_view webix_print_" + group.toLowerCase(),
	    "style": "height:0px;visibility:hidden;"
	  }, options["doc" + group]);
	  if (group === "Header") insertBefore(header, document.body.firstChild);else document.body.appendChild(header);
	  options["doc" + group] = header;
	}

	var patterns = {
	  phone: {
	    mask: "+# (###) ###-####",
	    allow: /[0-9]/g
	  },
	  card: {
	    mask: "#### #### #### ####",
	    allow: /[0-9]/g
	  },
	  date: {
	    mask: "####-##-## ##:##",
	    allow: /[0-9]/g
	  }
	};

	/*
		Common helpers
	*/
	var html$1 = {
	  denySelect: denySelect,
	  allowSelect: allowSelect,
	  index: index,
	  createCss: createCss,
	  addStyle: addStyle,
	  removeStyle: removeStyle,
	  create: create,
	  getValue: getValue,
	  remove: remove,
	  insertBefore: insertBefore,
	  locate: locate,
	  offset: offset,
	  posRelative: posRelative,
	  pos: pos,
	  preventEvent: preventEvent,
	  stopEvent: stopEvent,
	  triggerEvent: triggerEvent,
	  addCss: addCss,
	  removeCss: removeCss,
	  getTextSize: getTextSize,
	  download: download,
	  _getClassName: _getClassName,
	  setSelectionRange: setSelectionRange,
	  getSelectionRange: getSelectionRange,
	  addMeta: addMeta
	};

	var timers = {};
	function jsonp(url, params, callback, master) {
	  var defer = Deferred.defer();
	  var id = "webix_jsonp_" + uid();
	  var script = document.createElement("script");
	  script.id = id;
	  script.type = "text/javascript";
	  var head = document.getElementsByTagName("head")[0];

	  if (typeof params == "function") {
	    master = callback;
	    callback = params;
	    params = {};
	  }

	  if (!params) params = {};
	  params.jsonp = id;

	  window[id] = function () {
	    if (callback) callback.apply(master || window, arguments);
	    defer.resolve(arguments[0]);
	    window.clearTimeout(timers[id]);
	    delete timers[id];
	    script.parentNode.removeChild(script);
	    callback = head = master = script = null;
	    delete window[id];
	  }; //timeout timer


	  timers[id] = window.setTimeout(function () {
	    defer.reject();
	    delete window[id];
	  }, jsonp.timer);
	  var vals = [];

	  for (var key in params) {
	    vals.push(key + "=" + encodeURIComponent(params[key]));
	  }

	  url += (url.indexOf("?") == -1 ? "?" : "&") + vals.join("&");
	  script.src = url;
	  head.appendChild(script);
	  return defer;
	}
	jsonp.timer = 3000;

	var error_key = "__webix_remote_error";

	function RemoteContext(url, config) {
	  this._proxy = {};
	  this._queue = [];
	  this._url = url;
	  this._key = "";
	  if (config) this._process(config);else this._ready = ajax(url).then(function (data) {
	    return data.text();
	  }).then(bind(function (text) {
	    text = text.split("/*api*/")[1];

	    this._process(JSON.parse(text));

	    return this._proxy;
	  }, this));
	}

	RemoteContext.prototype = {
	  _process: function (config) {
	    if (config.$key) this._key = config.$key;
	    if (config.$vars) for (var key in config.$vars) {
	      this._proxy[key] = config.$vars[key];
	    }

	    this._parse(config, this._proxy, "");
	  },
	  _parse: function (api, obj, prefix) {
	    for (var key in api) {
	      if (key === "$key" || key === "$vars") continue;
	      var val = api[key];

	      if (_typeof(val) == "object") {
	        var sub = obj[key] = {};

	        this._parse(val, sub, prefix + key + ".");
	      } else obj[key] = this._proxy_call(this, prefix + key);
	    }
	  },
	  _call: function (name, args) {
	    var def = this._deffer(this, name, args);

	    this._queue.push(def);

	    this._start_queue();

	    return def;
	  },
	  _start_queue: function () {
	    if (!this._timer) this._timer = setTimeout(bind(this._run_queue, this), 1);
	  },
	  _run_queue: function () {
	    var data = [],
	        defs = this._queue;

	    for (var i = 0; i < this._queue.length; i++) {
	      var def = this._queue[i];

	      if (def.$sync) {
	        defs.splice(i, 1);
	        i--;
	      } else data.push({
	        name: def.$name,
	        args: def.$args
	      });
	    }

	    if (defs.length) {
	      var request = ajax();

	      var pack = this._pack(data);

	      callEvent("onBeforeRemoteCall", [request, pack, {}]);
	      var promise = request.post(this._url, pack).then(function (response) {
	        var data = response.json();
	        var results = data.data;

	        for (var i = 0; i < results.length; i++) {
	          var res = results[i];
	          var error = results[i] && results[i][error_key];

	          if (error) {
	            callEvent("onRemoteError", [error]);
	            defs[i].reject(error);
	          } else {
	            defs[i].resolve(res);
	          }
	        }
	      }, function (res) {
	        for (var i = 0; i < defs.length; i++) {
	          defs[i].reject(res);
	        }

	        throw res;
	      });
	      callEvent("onAfterRemoteCall", [promise]);
	    }

	    this._queue = [];
	    this._timer = null;
	  },
	  _sync: function () {
	    var value = null;
	    this.$sync = true;
	    var data = [{
	      name: this.$name,
	      args: this.$args
	    }];

	    try {
	      var request = ajax();

	      var pack = this.$context._pack(data);

	      callEvent("onBeforeRemoteCall", [request, pack, {
	        sync: true
	      }]);
	      var xhr = request.sync().post(this.$context._url, pack);
	      callEvent("onAfterRemoteCall", [null]);
	      value = JSON.parse(xhr.responseText).data[0];
	      if (value[error_key]) value = null;
	    } catch (e) {} //eslint-disable-line


	    return value;
	  },
	  _deffer: function (master, name, args) {
	    var pr = Deferred.defer();
	    pr.sync = master._sync;
	    pr.$name = name;
	    pr.$args = args;
	    pr.$context = this;
	    return pr;
	  },
	  _proxy_call: function (master, name) {
	    return function () {
	      return master._call(name, [].slice.call(arguments));
	    };
	  },
	  _getProxy: function () {
	    return this._ready || this._proxy;
	  },
	  _pack: function (obj) {
	    return {
	      key: this._key,
	      payload: obj
	    };
	  }
	};

	function getApi(url, config) {
	  var ctx = new RemoteContext(url, config);

	  var proxy = ctx._getProxy();

	  for (var key in proxy) {
	    remote[key] = proxy[key];
	  }

	  return proxy;
	}

	var remote = function (url, config) {
	  if (_typeof(url) === "object") {
	    var scripts = document.getElementsByTagName("script");
	    config = url;
	    url = scripts[scripts.length - 1].src;
	    return getApi(url, config);
	  } else return getApi(url, config);
	};

	/*submits values*/

	function send(url, values, method, target) {
	  var form = create("FORM", {
	    "target": target || "_self",
	    "action": url,
	    "method": method || "POST"
	  }, "");

	  for (var k in values) {
	    var field = create("INPUT", {
	      "type": "hidden",
	      "name": k,
	      "value": values[k]
	    }, "");
	    form.appendChild(field);
	  }

	  form.style.display = "none";
	  document.body.appendChild(form);
	  form.submit();
	  document.body.removeChild(form);
	}

	function animate$1(obj, parent, config) {
	  var pobj = $$(parent);

	  if (pobj) {
	    var aniset = config || {
	      type: "slide",
	      direction: "left"
	    };

	    var d = pobj._viewobj.cloneNode(true);

	    var view = ui(obj, parent);

	    view._viewobj.parentNode.appendChild(d);

	    var line = animate.formLine(view._viewobj, d, aniset);

	    aniset.callback = function () {
	      animate.breakLine(line);
	    };

	    animate(line, aniset);
	    return view;
	  }
	}
	function animateView(view, stateHandler, config) {
	  view = $$(view);

	  if (view) {
	    config = config || {
	      type: "slide",
	      direction: "left"
	    };

	    var getHTML = function (view) {
	      var el = view._viewobj;
	      var css = el.className;
	      var content = el.innerHTML;
	      return "<div class='" + css + "' style='width:" + el.offsetWidth + "px;height:" + el.offsetHeight + "px;'>" + content + "</div>";
	    }; // get 'display' state of child nodes


	    var display = [];

	    for (var i = 0; i < view._viewobj.childNodes.length; i++) {
	      var node = view._viewobj.childNodes[i];
	      var value = node.currentStyle ? node.currentStyle.display : getComputedStyle(node, null).display;
	      display.push(value || "");
	    } // get current html content


	    var currentState = getHTML(view); // apply new state

	    if (typeof stateHandler == "function") {
	      stateHandler.call(this);
	    } // get new html content


	    var newState = getHTML(view); // insert elements into the view

	    var tempParent = view._viewobj.insertBefore(create("DIV", {
	      "class": "webix_view_animate",
	      "style": "width:" + view._viewobj.offsetWidth + "px;height:" + view._viewobj.offsetHeight + "px;"
	    }, newState + currentState), view._viewobj.firstChild); // hide child nodes


	    for (var _i = 1; _i < view._viewobj.childNodes.length; _i++) {
	      view._viewobj.childNodes[_i].style.display = "none";
	    } // animate inserted elements


	    var line = animate.formLine(tempParent.childNodes[0], tempParent.childNodes[1], config);

	    config.callback = function () {
	      if (tempParent) {
	        view._viewobj.removeChild(tempParent);

	        tempParent = null; // restore 'display' state of child nodes

	        for (var i = 0; i < view._viewobj.childNodes.length; i++) {
	          view._viewobj.childNodes[i].style.display = display[i];
	        }
	      }
	    };

	    animate(line, config);
	    return view;
	  }
	}

	function orientation() {
	  var new_orientation = !!(window.orientation % 180);
	  if (state.orientation === new_orientation) return;
	  state.orientation = new_orientation;
	  callEvent("onRotate", [new_orientation]);
	}

	if (env.touch) {
	  state.orientation = !!((isUndefined(window.orientation) ? 90 : window.orientation) % 180);
	  event$1(window, "onorientationchange" in window ? "orientationchange" : "resize", orientation);
	}

	function fullScreen() {
	  if (!env.touch) return;
	  addMeta("apple-mobile-web-app-capable", "yes");
	  addMeta("viewport", "initial-scale=1, maximum-scale=1, user-scalable=no, shrink-to-fit=no");

	  var fix = function () {
	    var x = window.innerWidth;
	    var y = window.innerHeight;

	    if (y) {
	      document.body.style.height = y + "px";
	      document.body.style.width = x + "px";
	    }

	    state._freeze_resize = false;
	    resize();
	  };

	  var onrotate = function () {
	    state._freeze_resize = true;
	    delay(fix, null, [], 500);
	  };

	  attachEvent("onRotate", onrotate);
	  orientation();
	  delay(onrotate);
	}

	var datafilter = {
	  textWaitDelay: 500,
	  "summColumn": {
	    getValue: function (node) {
	      return node.firstChild.innerHTML;
	    },
	    setValue: function () {},
	    refresh: function (master, node, value) {
	      var result = 0;
	      master.mapCells(null, value.columnId, null, 1, function (value) {
	        value = value * 1;
	        if (!isNaN(value)) result += value;
	      }, true);
	      if (value.format) result = value.format(result);
	      if (value.template) result = value.template({
	        value: result
	      });
	      node.firstChild.innerHTML = result;
	    },
	    trackCells: true,
	    render: function (master, config) {
	      if (config.template) config.template = template(config.template);
	      return "";
	    }
	  },
	  "masterCheckbox": {
	    getValue: function () {},
	    setValue: function () {},
	    getHelper: function (node, config) {
	      return {
	        check: function () {
	          config.checked = false;
	          node.onclick();
	        },
	        uncheck: function () {
	          config.checked = true;
	          node.onclick();
	        },
	        isChecked: function () {
	          return config.checked;
	        }
	      };
	    },
	    refresh: function (master, node, config) {
	      node.onclick = function () {
	        this.getElementsByTagName("input")[0].checked = config.checked = !config.checked;
	        var column = master.getColumnConfig(config.columnId);
	        var checked = config.checked ? column.checkValue : column.uncheckValue;
	        master.data.each(function (obj) {
	          obj[config.columnId] = checked;
	          master.callEvent("onCheck", [obj.id, config.columnId, checked]);
	          this.callEvent("onStoreUpdated", [obj.id, obj, "save"]);
	        });
	        master.refresh();
	      };
	    },
	    render: function (master, config) {
	      return "<input type='checkbox' " + (config.checked ? "checked='1'" : "") + ">";
	    }
	  },
	  "textFilter": {
	    getInputNode: function (node) {
	      return node.firstChild ? node.firstChild.firstChild : {
	        value: null
	      };
	    },
	    getValue: function (node) {
	      return this.getInputNode(node).value;
	    },
	    setValue: function (node, value) {
	      this.getInputNode(node).value = value;
	    },
	    refresh: function (master, node, value) {
	      node.component = master._settings.id;
	      master.registerFilter(node, value, this);
	      node._comp_id = master._settings.id;
	      if (value.value && this.getValue(node) != value.value) this.setValue(node, value.value);
	      node.onclick = preventEvent;

	      _event(node, "keydown", this._on_key_down);
	    },
	    render: function (master, config) {
	      if (this.init) this.init(config);
	      config.css = "webix_ss_filter";
	      return "<input " + (config.placeholder ? "placeholder=\"" + config.placeholder + "\" " : "") + "type='text'>";
	    },
	    _on_key_down: function (e) {
	      var id = this._comp_id; //tabbing through filters must not trigger filtering
	      //we can improve this functionality by preserving initial filter value
	      //and comparing new one with it

	      if ((e.which || e.keyCode) == 9) return;
	      if (this._filter_timer) window.clearTimeout(this._filter_timer);
	      this._filter_timer = window.setTimeout(function () {
	        var ui$$1 = $$(id); //ensure that ui is not destroyed yet

	        if (ui$$1) ui$$1.filterByAll();
	      }, datafilter.textWaitDelay);
	    }
	  },
	  "selectFilter": {
	    getInputNode: function (node) {
	      return node.firstChild ? node.firstChild.firstChild : {
	        value: null
	      };
	    },
	    getValue: function (node) {
	      return this.getInputNode(node).value;
	    },
	    setValue: function (node, value) {
	      this.getInputNode(node).value = value;
	    },
	    refresh: function (master, node, value) {
	      //value - config from header { contet: }
	      value.compare = value.compare || function (a, b) {
	        return a == b;
	      };

	      node.component = master._settings.id;
	      master.registerFilter(node, value, this);
	      var data;
	      var options = value.options;

	      if (options) {
	        if (typeof options == "string") {
	          data = value.options = [];
	          ajax(options).then(bind(function (data) {
	            value.options = data.json();
	            this.refresh(master, node, value);
	          }, this));
	        } else data = options;
	      } else {
	        data = master.collectValues(value.columnId, value.collect);
	        data.unshift({
	          id: "",
	          value: ""
	        });
	      }

	      var optview = $$(options);

	      if (optview && optview.data && optview.data.getRange) {
	        data = optview.data.getRange();
	      } //slow in IE
	      //http://jsperf.com/select-options-vs-innerhtml


	      var select = document.createElement("select");

	      for (var i = 0; i < data.length; i++) {
	        var option = document.createElement("option");
	        option.value = data[i].id;
	        option.text = data[i].value;
	        select.add(option);
	      }

	      node.firstChild.innerHTML = "";
	      node.firstChild.appendChild(select);
	      if (value.value) this.setValue(node, value.value);
	      node.onclick = preventEvent;
	      select._comp_id = master._settings.id;

	      _event(select, "change", this._on_change);
	    },
	    render: function (master, config) {
	      if (this.init) this.init(config);
	      config.css = "webix_ss_filter";
	      return "";
	    },
	    _on_change: function () {
	      $$(this._comp_id).filterByAll();
	    }
	  }
	};
	datafilter.serverFilter = exports.extend({
	  $server: true,
	  _on_key_down: function (e) {
	    var id = this._comp_id,
	        code = e.which || e.keyCode; //ignore tab and navigation keys

	    if (code == 9 || code >= 33 && code <= 40) return;
	    if (this._filter_timer) window.clearTimeout(this._filter_timer);
	    this._filter_timer = window.setTimeout(function () {
	      $$(id).filterByAll();
	    }, datafilter.textWaitDelay);
	  }
	}, datafilter.textFilter);
	datafilter.serverSelectFilter = exports.extend({
	  $server: true,
	  _on_change: function () {
	    var id = this._comp_id;
	    $$(id).filterByAll();
	  }
	}, datafilter.selectFilter);
	datafilter.numberFilter = exports.extend({
	  init: function (config) {
	    config.prepare = function (value) {
	      var _this = this;

	      var equality = value.indexOf("=") != -1;
	      var intvalue = this.format(value);
	      if (intvalue === "") return "";
	      var compare;

	      if (value.indexOf(">") != -1) {
	        compare = this._greater;
	      } else if (value.indexOf("<") != -1) {
	        compare = this._lesser;
	      }

	      if (compare && equality) {
	        config.compare = function (a, b) {
	          return _this._equal(a, b) || compare(a, b);
	        };
	      } else {
	        config.compare = compare || this._equal;
	      }

	      return intvalue;
	    };
	  },
	  format: function (value) {
	    return value.replace(/[^\-.0-9]/g, "");
	  },
	  _greater: function (a, b) {
	    return a * 1 > b;
	  },
	  _lesser: function (a, b) {
	    return a !== "" && a * 1 < b;
	  },
	  _equal: function (a, b) {
	    return a !== "" && a * 1 == b;
	  }
	}, datafilter.textFilter);
	datafilter.dateFilter = exports.extend({
	  format: function (value) {
	    if (value === "") return "";
	    var date = new Date();

	    if (value.indexOf("today") != -1) {
	      date = wDate.dayStart(date);
	    } else if (value.indexOf("now") == -1) {
	      var parts = value.match(/[0-9]+/g);
	      if (!parts || !parts.length) return "";

	      if (parts.length < 3) {
	        parts.reverse();
	        date = new Date(parts[0], (parts[1] || 1) - 1, 1);
	      } else date = i18n.dateFormatDate(value.replace(/^[>< =]+/, ""));
	    }

	    return date.valueOf();
	  }
	}, datafilter.numberFilter);

	env.scrollSize = env.touch || env.$customScroll ? 0 : 17;
	ready(function () {
	  var size = _detectScrollSize();

	  env.scrollSize = env.touch ? 0 : size;
	});

	function _detectScrollSize() {
	  var div = create("div");
	  div.className = "webix_skin_mark";
	  div.style.cssText = "position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;min-height:100px;overflow-y:scroll;";
	  document.body.appendChild(div);
	  var width = div.offsetWidth - div.clientWidth;
	  var name = {
	    200: "flat",
	    210: "compact",
	    230: "contrast",
	    240: "material",
	    250: "mini"
	  }[Math.floor(div.offsetHeight / 10) * 10];
	  document.body.removeChild(div);
	  if (name) set$1(name);
	  if (env.$customScroll) return 0;
	  return width;
	}

	var fixed = false;

	function _fixHeight() {
	  if (fixed) return;
	  addStyle("html, body{ height:100%; }");
	  document.body.className += " webix_full_screen";
	  Touch.limit(false);
	  fixed = true;
	}

	define("_fixHeight", _fixHeight);

	ui.animate = animate$1;
	ui.animateView = animateView;
	ui.freeze = freeze;
	ui.resize = resize;
	ui.each = each;
	ui.hasMethod = hasMethod;
	ui.datafilter = datafilter;
	ui.fullScreen = fullScreen;

	/*German (Germany) locale*/
	var de = {
	  groupDelimiter: ".",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d.%n.%Y",
	  timeFormat: "%H:%i",
	  longDateFormat: "%j. %F %Y",
	  fullDateFormat: "%j. %F %Y %H:%i",
	  am: null,
	  pm: null,
	  price: "{obj} ",
	  priceSettings: {
	    groupDelimiter: ".",
	    groupSize: 3,
	    decimalDelimiter: ",",
	    decimalSize: 2
	  },
	  calendar: {
	    monthFull: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
	    monthShort: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
	    dayFull: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
	    dayShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	    hours: "Stunden",
	    minutes: "Minuten",
	    done: "Fertig",
	    clear: "Entfernen",
	    today: "Heute"
	  },
	  dataExport: {
	    page: "Seite",
	    of: "aus"
	  },
	  PDFviewer: {
	    of: "aus",
	    automaticZoom: "Automatisch Zoom",
	    actualSize: "Aktuelles Ausma",
	    pageFit: "Seite Ausma",
	    pageWidth: "Seite Breite",
	    pageHeight: "Seite Hhe",
	    enterPassword: "Passwort eingeben",
	    passwordError: "Falsches passwort"
	  },
	  aria: {
	    calendar: "Kalender",
	    increaseValue: "Wert erhhen",
	    decreaseValue: "Wert verringern",
	    navMonth: ["Vorheriger Monat", "Nchsten Monat"],
	    navYear: ["Vorheriges Jahr", "Nchstes Jahr"],
	    navDecade: ["Zurck Jahrzehnt", "Als nchstes Jahrzehnt"],
	    dateFormat: "%j. %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Stunden: %H",
	    minuteFormat: "Minuten: %i",
	    removeItem: "Element entfernen",
	    pages: ["Erste Seite", "Vorherige Seite", "Folgeseite", "Letzte Seite"],
	    page: "Seite",
	    headermenu: "Titelmen",
	    openGroup: "ffnen Spaltengruppe ",
	    closeGroup: "Schlieen Spaltengruppe ",
	    closeTab: "Tab schlieen",
	    showTabs: "Weitere Tabs",
	    resetTreeMap: "Zurck zur ursprnglichen Ansicht",
	    navTreeMap: "Aufleveln",
	    nextTab: "Weiter tab",
	    prevTab: "Zurck tab",
	    multitextSection: "Element hinzufgen",
	    multitextextraSection: "Element entfernen",
	    showChart: "Chart anzeigen",
	    hideChart: "Chart verstecken",
	    resizeChart: "Chart Gre ndern"
	  },
	  richtext: {
	    underline: "Unterstreichen",
	    bold: "Fettgedruckt",
	    italic: "Kursiv"
	  },
	  combo: {
	    select: "Auswhlen",
	    selectAll: "Alles auswhlen",
	    unselectAll: "Alles widerrufen"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Abbrechen"
	  },
	  comments: {
	    send: "Absenden",
	    confirmMessage: "Der Kommentar wird entfernt. Sind Sie sicher?",
	    edit: "Redigieren",
	    remove: "Lschen",
	    placeholder: "Geben Sie hier ein..",
	    moreComments: "Mehr Kommentare"
	  }
	};

	/*Spanish (Spain, International Sort) locale*/
	var es = {
	  groupDelimiter: ".",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d/%n/%Y",
	  timeFormat: "%G:%i",
	  longDateFormat: "%d %F %Y",
	  fullDateFormat: "%d %F %Y %G:%i",
	  am: null,
	  pm: null,
	  price: "{obj} ",
	  priceSettings: {
	    groupDelimiter: ".",
	    groupSize: 3,
	    decimalDelimiter: ",",
	    decimalSize: 2
	  },
	  calendar: {
	    monthFull: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
	    monthShort: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
	    dayFull: ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
	    dayShort: ["dom", "lun", "mar", "mi", "jue", "vie", "sb"],
	    hours: "Horas",
	    minutes: "Minutos",
	    done: "Listo",
	    clear: "Reinicio",
	    today: "Hoy"
	  },
	  dataExport: {
	    page: "Pgina",
	    of: "de"
	  },
	  PDFviewer: {
	    of: "de",
	    automaticZoom: "Zoom automtico",
	    actualSize: "Tamao real",
	    pageFit: "Tamao de pgina",
	    pageWidth: "Ancho de pgina",
	    pageHeight: "Altura de la pgina",
	    enterPassword: "Introduzca la contrasea",
	    passwordError: "Contrasea incorrecta"
	  },
	  aria: {
	    calendar: "alendario",
	    increaseValue: "Aumentar el valor",
	    decreaseValue: "Disminuye el valor",
	    navMonth: ["Mes anterior", "Prximo mes"],
	    navYear: ["Ao anterior", "Prximo ao"],
	    navDecade: ["Dcada anterior", "Prxima dcada"],
	    dateFormat: "%d %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Horas: %G",
	    minuteFormat: "Minutos: %i",
	    removeItem: "Retire el elemento",
	    pages: ["Primera pgina", "Pagina anterior", "Siguiente pgina", "ltima pgina"],
	    page: "Pgina",
	    headermenu: "Men de ttulos",
	    openGroup: "Grupo de columnas abiertas",
	    closeGroup: "Primer grupo de columnas",
	    closeTab: "Cerrar tab",
	    showTabs: "Mostrar ms tabs",
	    resetTreeMap: "Volver a la vista original",
	    navTreeMap: "Elevar a mismo nivel",
	    nextTab: "Siguiente tab",
	    prevTab: "Tab anterior",
	    multitextSection: "Aadir elemento",
	    multitextextraSection: "Retire el elemento",
	    showChart: "Espectculo chart",
	    hideChart: "Esconder chart",
	    resizeChart: "Cambiar el tamao el chart"
	  },
	  richtext: {
	    underline: "Subrayar",
	    bold: "Negrita",
	    italic: "Itlico"
	  },
	  combo: {
	    select: "Seleccionar",
	    selectAll: "Seleccionar todo",
	    unselectAll: "Deselecciona todo"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Cancelar"
	  },
	  comments: {
	    send: "Enviar",
	    confirmMessage: "El comentario ser eliminado. Ests seguro?",
	    edit: "Corregir",
	    remove: "Suprimir",
	    placeholder: "Escriba aqu..",
	    moreComments: "Ms comentarios"
	  }
	};

	var fr = {
	  groupDelimiter: " ",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d/%m/%Y",
	  timeFormat: "%H:%i",
	  longDateFormat: "%d %F %Y",
	  fullDateFormat: "%d.%m.%Y %H:%i",
	  price: "{obj} ",
	  priceSettings: null,
	  //use number defaults
	  calendar: {
	    monthFull: ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"],
	    monthShort: ["Jan", "Fv", "Mar", "Avr", "Mai", "Juin", "Juil", "Au", "Sep", "Oct", "Nov", "Dc"],
	    dayFull: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
	    dayShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
	    hours: "Heures",
	    minutes: "Minutes",
	    done: "Fini",
	    clear: "Effacer",
	    today: "Aujourd'hui"
	  },
	  dataExport: {
	    page: "Page",
	    of: "sur"
	  },
	  PDFviewer: {
	    of: "sur",
	    automaticZoom: "Zoom automatique",
	    actualSize: "Taille actuelle",
	    pageFit: "Taille de la page",
	    pageWidth: "Largeur de la page",
	    pageHeight: "Hauteur de page",
	    enterPassword: "Entrez le mot de passe",
	    passwordError: "Mauvais mot de passe"
	  },
	  aria: {
	    calendar: "alendrier",
	    increaseValue: "Augmenter la valeur",
	    decreaseValue: "Diminution de la valeur",
	    navMonth: ["Le mois prcdent", "Le mois prochain"],
	    navYear: ["Anne prcdente", "L'anne prochaine"],
	    navDecade: ["Dcennie prcdente", "Suivant dcennie"],
	    dateFormat: "%d %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Heures: %H",
	    minuteFormat: "Minutes: %i",
	    removeItem: "Retirer l'lment",
	    pages: ["Premire page", "Page prcdente", "Page suivante", "Dernire page"],
	    page: "Page",
	    headermenu: "Menu de titre",
	    openGroup: "Ouvrir groupe de colonnes ",
	    closeGroup: "Fermer groupe de colonnes",
	    closeTab: "Fermer tab",
	    showTabs: "Montrer plus tabs",
	    resetTreeMap: "Revenir  la vue originale",
	    navTreeMap: "Niveau suprieur",
	    nextTab: "Prochain tab",
	    prevTab: "Prcdent tab",
	    multitextSection: "Ajouter l'lment",
	    multitextextraSection: "Retirer l'lment",
	    showChart: "Montrer chart",
	    hideChart: "Cacher chart",
	    resizeChart: "Redimensionner chart"
	  },
	  richtext: {
	    underline: "Souligner",
	    bold: "Gras",
	    italic: "Italique"
	  },
	  combo: {
	    select: "Slectionner",
	    selectAll: "Tout slectionner",
	    unselectAll: "Tout dselectionner"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Annuler"
	  },
	  comments: {
	    send: "Envoyer",
	    confirmMessage: "Le commentaire sera supprim. tes-vous sr?",
	    edit: "Modifier",
	    remove: "Effacer",
	    placeholder: "crivez ici..",
	    moreComments: "Plus de commentaires"
	  }
	};

	/*Italian (Italy) locale*/
	var it = {
	  groupDelimiter: ".",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d/%m/%Y",
	  timeFormat: "%H:%i",
	  longDateFormat: "%j %F %Y",
	  fullDateFormat: "%j %F %Y %H:%i",
	  am: null,
	  pm: null,
	  price: " {obj}",
	  priceSettings: {
	    groupDelimiter: ".",
	    groupSize: 3,
	    decimalDelimiter: ",",
	    decimalSize: 2
	  },
	  calendar: {
	    monthFull: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"],
	    monthShort: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"],
	    dayFull: ["domenica", "luned", "marted", "mercoled", "gioved", "venerd", "sabato"],
	    dayShort: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
	    hours: "Orario",
	    minutes: "Minuti",
	    done: "Pronto",
	    clear: "Pulisci",
	    today: "Oggi"
	  },
	  dataExport: {
	    page: "Pagina",
	    of: "di"
	  },
	  PDFviewer: {
	    of: "di",
	    automaticZoom: "Zoom automatico",
	    actualSize: "Dimensione reale",
	    pageFit: "Dimensioni della pagina",
	    pageWidth: "Larghezza della pagina",
	    pageHeight: "Altezza della pagina",
	    enterPassword: "Inserisci la password",
	    passwordError: "Password errata"
	  },
	  aria: {
	    calendar: "Calendario",
	    increaseValue: "Aumenta il valore",
	    decreaseValue: "Riduci il valore",
	    navMonth: ["Il mese scorso", "Il prossimo mese"],
	    navYear: ["L'anno scorso", "L'anno prossimo"],
	    navDecade: ["Decennio precedente", "Prossimo decennio"],
	    dateFormat: "%j %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Orario: %H",
	    minuteFormat: "Minuti: %i",
	    removeItem: "Rimuovere l'elemento",
	    pages: ["Prima pagina", "Pagina precedente", "Pagina successiva", "Ultima pagina"],
	    page: "Pagina",
	    headermenu: "Menu del titolo",
	    openGroup: "Aperto gruppo di colonne",
	    closeGroup: "Chiudi gruppo di colonne",
	    closeTab: "Chiudi tab",
	    showTabs: "Mostra pi tabs",
	    resetTreeMap: "Tornare alla vista originale",
	    navTreeMap: "Livello superiore",
	    nextTab: "Tab successivo",
	    prevTab: "Tab precedente",
	    multitextSection: "Aggiungi elemento",
	    multitextextraSection: "Rimuovere l'elemento",
	    showChart: "Mostrare grafico",
	    hideChart: "Nascondere grafico",
	    resizeChart: "Ridimensionare grafico"
	  },
	  richtext: {
	    underline: "Sottolineare",
	    bold: "Grassetto",
	    italic: "Corsivo"
	  },
	  combo: {
	    select: "Selezionare",
	    selectAll: "Seleziona tutto",
	    unselectAll: "Deseleziona tutto"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Annullare"
	  },
	  comments: {
	    send: "Inviare",
	    confirmMessage: "Il commento verr rimosso. Sei sicuro?",
	    edit: "Correggere",
	    remove: "Elimina",
	    placeholder: "Digitare qui..",
	    moreComments: "Altri commenti"
	  }
	};

	var ja = {
	  groupDelimiter: ",",
	  groupSize: 3,
	  decimalDelimiter: ".",
	  decimalSize: 2,
	  dateFormat: "%Y.%m.%d",
	  timeFormat: "%H:%i",
	  longDateFormat: "%Y%m%d",
	  fullDateFormat: "%Y.%m.%d %H:%i",
	  price: "{obj}",
	  priceSettings: {
	    groupSize: 3,
	    groupDelimiter: ",",
	    decimalDelimiter: "",
	    decimalSize: 0
	  },
	  calendar: {
	    monthFull: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	    monthShort: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	    dayFull: ["", "", "", "", "", "", ""],
	    dayShort: ["", "", "", "", "", "", ""],
	    hours: "",
	    minutes: "",
	    done: "",
	    clear: "",
	    today: ""
	  },
	  dataExport: {
	    page: "",
	    of: ""
	  },
	  PDFviewer: {
	    of: "",
	    automaticZoom: "",
	    actualSize: "",
	    pageFit: "",
	    pageWidth: "",
	    pageHeight: "",
	    enterPassword: "",
	    passwordError: ""
	  },
	  aria: {
	    calendar: "",
	    increaseValue: "",
	    decreaseValue: "",
	    navMonth: ["", ""],
	    navYear: ["", ""],
	    navDecade: ["", "10"],
	    dateFormat: "%Y%m%d",
	    monthFormat: "%Y%m",
	    yearFormat: "%Y",
	    hourFormat: ": %H",
	    minuteFormat: ": %i",
	    removeItem: "",
	    pages: ["", "", "", ""],
	    page: "",
	    headermenu: "",
	    openGroup: "",
	    closeGroup: "",
	    closeTab: "",
	    showTabs: "",
	    resetTreeMap: "",
	    navTreeMap: "",
	    nextTab: "",
	    prevTab: "",
	    multitextSection: "",
	    multitextextraSection: "",
	    showChart: "",
	    hideChart: "",
	    resizeChart: ""
	  },
	  richtext: {
	    underline: "",
	    bold: "",
	    italic: ""
	  },
	  combo: {
	    select: "",
	    selectAll: "",
	    unselectAll: ""
	  },
	  message: {
	    ok: "OK",
	    cancel: ""
	  },
	  comments: {
	    send: "",
	    confirmMessage: ". ",
	    edit: "",
	    remove: "",
	    placeholder: "..",
	    moreComments: ""
	  }
	};

	var pt = {
	  groupDelimiter: ".",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d/%m/%Y",
	  timeFormat: "%G:%i",
	  longDateFormat: "%d de %F de %Y",
	  fullDateFormat: "%d de %F de %Y %G:%i",
	  am: null,
	  pm: null,
	  price: "R$ {obj}",
	  priceSettings: {
	    groupDelimiter: ".",
	    groupSize: 3,
	    decimalDelimiter: ",",
	    decimalSize: 2
	  },
	  fileSize: ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb"],
	  calendar: {
	    monthFull: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
	    monthShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
	    dayFull: ["Domingo", "Segunda-Feira", "Tera-Feira", "Quarta-Feira", "Quinta-Feira", "Sexta-Feira", "Sbado"],
	    dayShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
	    hours: "Horas",
	    minutes: "Minutos",
	    done: "Feito",
	    clear: "Limpar",
	    today: "Hoje"
	  },
	  dataExport: {
	    page: "Pgina",
	    of: "de"
	  },
	  PDFviewer: {
	    of: "de",
	    automaticZoom: "Zoom automtico",
	    actualSize: "Tamanho atual",
	    pageFit: "Tamanho da pgina",
	    pageWidth: "Largura da pgina",
	    pageHeight: "Altura da pgina",
	    enterPassword: "Digite a senha",
	    passwordError: "Senha incorreta"
	  },
	  aria: {
	    calendar: "Calendrio",
	    increaseValue: "Aumentar o valor",
	    decreaseValue: "Diminuir o valor",
	    navMonth: ["Ms anterior", "Prximo ms"],
	    navYear: ["Ano anterior", "Prximo ano"],
	    navDecade: ["Dcada anterior", "Prxima dcada"],
	    dateFormat: "%d de %F de %Y",
	    monthFormat: "%F de %Y",
	    yearFormat: "%Y",
	    hourFormat: "Horas: %G",
	    minuteFormat: "Minutos: %i",
	    removeItem: "Remover elemento",
	    pages: ["Primeira pgina", "Pgina anterior", "Prxima pgina", "ltima pgina"],
	    page: "Pgina",
	    headermenu: "Menu de ttulos",
	    openGroup: "Grupo coluna aberta",
	    closeGroup: "Fechar grupo de colunas",
	    closeTab: "Fechar tab",
	    showTabs: "Mostre mais tabs",
	    resetTreeMap: "oltar  vista original",
	    navTreeMap: "Upar",
	    nextTab: "Prximo tab",
	    prevTab: "Anterior tab",
	    multitextSection: "Adicionar elemento",
	    multitextextraSection: "Remover elemento",
	    showChart: "Exposio chart",
	    hideChart: "Esconder chart",
	    resizeChart: "Redimensionar chart"
	  },
	  richtext: {
	    underline: "Sublinhado",
	    bold: "Negrito",
	    italic: "itlico"
	  },
	  combo: {
	    select: "Selecionar",
	    selectAll: "Selecionar tudo",
	    unselectAll: "Desmarque todos"
	  },
	  message: {
	    ok: "OK",
	    cancel: "Cancelar"
	  },
	  comments: {
	    send: "Enviar",
	    confirmMessage: "Comentrio ser removido. Voc tem certeza?",
	    edit: "Editar",
	    remove: "Excluir",
	    placeholder: "Digite aqui..",
	    moreComments: "Mais comentrios"
	  }
	};

	/*Chinese (Simplified, PRC) locale*/
	var zh = {
	  groupDelimiter: ",",
	  groupSize: 3,
	  decimalDelimiter: ".",
	  decimalSize: 2,
	  dateFormat: "%Y/%m/%j",
	  timeFormat: "%G:%i",
	  longDateFormat: "%Y''%m''%j''",
	  fullDateFormat: "%Y''%m''%j'' %G:%i",
	  am: ["", ""],
	  pm: ["", ""],
	  price: "{obj}",
	  priceSettings: {
	    groupDelimiter: ",",
	    groupSize: 3,
	    decimalDelimiter: ".",
	    decimalSize: 2
	  },
	  calendar: {
	    monthFull: ["", "", "", "", "", "", "", "", "", "", "", ""],
	    monthShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
	    dayFull: ["", "", "", "", "", "", ""],
	    dayShort: ["", "", "", "", "", "", ""],
	    hours: "",
	    minutes: "",
	    done: "",
	    clear: "",
	    today: ""
	  },
	  dataExport: {
	    page: "",
	    of: ""
	  },
	  PDFviewer: {
	    of: "",
	    automaticZoom: "",
	    actualSize: "",
	    pageFit: "",
	    pageWidth: "",
	    pageHeight: "",
	    enterPassword: "",
	    passwordError: ""
	  },
	  aria: {
	    calendar: "",
	    increaseValue: "",
	    decreaseValue: "",
	    navMonth: ["", ""],
	    navYear: ["", ""],
	    navDecade: ["", ""],
	    dateFormat: "%Y''%m''%j''",
	    monthFormat: "%Y''%m'",
	    yearFormat: "%Y'",
	    hourFormat: ": %G",
	    minuteFormat: ": %i",
	    removeItem: "",
	    pages: ["", "", "", ""],
	    page: "",
	    headermenu: "",
	    openGroup: "",
	    closeGroup: "",
	    closeTab: "",
	    showTabs: "",
	    resetTreeMap: "",
	    navTreeMap: "",
	    nextTab: "",
	    prevTab: "",
	    multitextSection: "",
	    multitextextraSection: "",
	    showChart: "",
	    hideChart: "",
	    resizeChart: ""
	  },
	  richtext: {
	    underline: "",
	    bold: "",
	    italic: ""
	  },
	  combo: {
	    select: "",
	    selectAll: "",
	    unselectAll: ""
	  },
	  message: {
	    ok: "",
	    cancel: ""
	  },
	  comments: {
	    send: "",
	    confirmMessage: ". ?",
	    edit: "",
	    remove: "",
	    placeholder: "..",
	    moreComments: ""
	  }
	};

	var ru = {
	  groupDelimiter: " ",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d.%m.%Y",
	  timeFormat: "%H:%i",
	  longDateFormat: "%d %F %Y",
	  fullDateFormat: "%d.%m.%Y %H:%i",
	  price: "{obj} .",
	  priceSettings: null,
	  //use number defaults
	  calendar: {
	    monthFull: ["", "", "", "", "Ma", "", "", "", "", "O", "", ""],
	    monthShort: ["", "", "Ma", "A", "Ma", "", "", "A", "", "", "", ""],
	    dayFull: ["", "", "", "", "", "", ""],
	    dayShort: ["", "", "", "", "", "", ""],
	    hours: "",
	    minutes: "",
	    done: "oo",
	    clear: "",
	    today: ""
	  },
	  dataExport: {
	    page: "",
	    of: ""
	  },
	  PDFviewer: {
	    of: "",
	    automaticZoom: " ",
	    actualSize: " ",
	    pageFit: " ",
	    pageWidth: " ",
	    pageHeight: " ",
	    enterPassword: " ",
	    passwordError: " "
	  },
	  aria: {
	    calendar: "",
	    increaseValue: " ",
	    decreaseValue: " ",
	    navMonth: [" ", " "],
	    navYear: [" ", " "],
	    navDecade: ["  ", "  "],
	    dateFormat: "%d %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: ": %H",
	    minuteFormat: ": %i",
	    removeItem: " ",
	    pages: [" ", " ", " ", " "],
	    page: "",
	    headermenu: "  ",
	    openGroup: "  ",
	    closeGroup: "  ",
	    closeTab: " ",
	    showTabs: "  ",
	    resetTreeMap: "   ",
	    navTreeMap: "   ",
	    nextTab: " ",
	    prevTab: " ",
	    multitextSection: " ",
	    multitextextraSection: " ",
	    showChart: " ",
	    hideChart: " ",
	    resizeChart: "  "
	  },
	  richtext: {
	    underline: "",
	    bold: "",
	    italic: ""
	  },
	  combo: {
	    select: "",
	    selectAll: " ",
	    unselectAll: " "
	  },
	  message: {
	    ok: "OK",
	    cancel: ""
	  },
	  comments: {
	    send: "",
	    confirmMessage: "  .  ?",
	    edit: "",
	    remove: "",
	    placeholder: " ..",
	    moreComments: " "
	  }
	};

	var be = {
	  groupDelimiter: " ",
	  groupSize: 3,
	  decimalDelimiter: ",",
	  decimalSize: 2,
	  dateFormat: "%d.%m.%Y",
	  timeFormat: "%H:%i",
	  longDateFormat: "%d %F %Y",
	  fullDateFormat: "%d.%m.%Y %H:%i",
	  price: "{obj} .",
	  priceSettings: {
	    groupSize: 3,
	    groupDelimiter: " ",
	    decimalDelimiter: "",
	    decimalSize: 0
	  },
	  calendar: {
	    monthFull: ["", "", "", "", "", "", "", "", "", "", "", ""],
	    monthShort: ["", "", "", "", "", "", "", "", "", "", "", ""],
	    dayFull: ["", "", "", "", "", "", ""],
	    dayShort: ["", "", "", "", "", "", ""],
	    hours: "",
	    minutes: "",
	    done: "",
	    today: "C",
	    clear: ""
	  },
	  dataExport: {
	    page: "",
	    of: ""
	  },
	  PDFviewer: {
	    of: "",
	    automaticZoom: " ",
	    actualSize: " ",
	    pageFit: " ",
	    pageWidth: " ",
	    pageHeight: " ",
	    enterPassword: " ",
	    passwordError: " "
	  },
	  aria: {
	    calendar: "",
	    increaseValue: " ",
	    decreaseValue: " ",
	    navMonth: [" ", " "],
	    navYear: [" ", " "],
	    navDecade: ["  ", "  "],
	    dateFormat: "%d %F %Y",
	    monthFormat: "%F %Y",
	    yearFormat: "%Y",
	    hourFormat: "Hours: %h",
	    minuteFormat: ": %i",
	    removeItem: " ",
	    pages: [" ", " ", " ", " "],
	    page: "",
	    headermenu: " ",
	    openGroup: "  ",
	    closeGroup: "  ",
	    closeTab: " ",
	    showTabs: "  ",
	    resetTreeMap: "   ",
	    navTreeMap: "   ",
	    nextTab: " ",
	    prevTab: " ",
	    multitextSection: " ",
	    multitextextraSection: " ",
	    showChart: " ",
	    hideChart: " ",
	    resizeChart: "  "
	  },
	  richtext: {
	    underline: "",
	    bold: "",
	    italic: ""
	  },
	  combo: {
	    select: "",
	    selectAll: " ",
	    unselectAll: " "
	  },
	  message: {
	    ok: "",
	    cancel: ""
	  },
	  comments: {
	    send: "",
	    confirmMessage: "  .  ?",
	    edit: "",
	    remove: "",
	    placeholder: " ..",
	    moreComments: " "
	  }
	};

	// en-EN locale is bundled by default
	i18n.locales["de-DE"] = de; // spain
	i18n.locales["es-ES"] = es; // france
	i18n.locales["fr-FR"] = fr; // italy
	i18n.locales["it-IT"] = it; // japan
	i18n.locales["ja-JP"] = ja; // portuguese
	i18n.locales["pt-BR"] = pt; // chinese
	i18n.locales["zh-CN"] = zh; // russian
	i18n.locales["ru-RU"] = ru; // belarus
	i18n.locales["be-BY"] = be;

	var api$4 = {
	  name: "baselayout",
	  restore: function (state$$1, factory, configOnly) {
	    var out = this._restore(copy(state$$1), factory);

	    if (configOnly) return out;else ui(out.cols || out.rows, this);
	  },
	  _restore: function (state$$1, factory) {
	    if (state$$1.$layout) {
	      var sub = state$$1.cols || state$$1.rows;

	      for (var i = 0; i < sub.length; i++) {
	        sub[i] = this._restore(sub[i], factory);
	      }
	    } else {
	      return factory.call(this, state$$1);
	    }

	    return state$$1;
	  },
	  serialize: function (serializer) {
	    var out = [];
	    var childs = this.getChildViews();

	    for (var i = 0; i < childs.length; i++) {
	      var sub = childs[i];

	      if (sub.movePortlet) {
	        var child = sub.getChildViews();
	        out.push(serializer.call(this, child[child.length - 1]));
	      } else if (sub.serialize) {
	        // some kind of layout
	        out.push(sub.serialize(serializer, true));
	      } else {
	        // leaf view
	        out.push(serializer.call(this, sub));
	      }
	    }

	    var obj = {
	      $layout: true,
	      type: this.config.type
	    };
	    if (this.config.rows) obj.rows = out;else obj.cols = out;
	    return obj;
	  },
	  $init: function (config) {
	    this.$ready.push(this._parse_cells);
	    this._dataobj = this._contentobj;
	    this._layout_sizes = [];
	    this._responsive = [];
	    this._padding = {
	      top: 0,
	      left: 0,
	      right: 0,
	      bottom: 0
	    };

	    if (config.$topView) {
	      config.borderless = true;
	      config._inner = {
	        top: true,
	        left: true,
	        bottom: true,
	        right: true
	      };
	    }

	    if (config.isolate) exports.extend(this, IdSpace);
	  },
	  rows_setter: function (value) {
	    this._vertical_orientation = 1;
	    this._collection = value;
	    return true;
	  },
	  cols_setter: function (value) {
	    this._vertical_orientation = 0;
	    this.$view.style.whiteSpace = "nowrap";
	    this._collection = value;
	    return true;
	  },
	  _remove: function (view) {
	    PowerArray.removeAt.call(this._cells, PowerArray.find.call(this._cells, view));
	    this.resizeChildren(true);
	  },
	  _replace: function (new_view, target_id) {
	    if (isUndefined(target_id)) {
	      for (var i = 0; i < this._cells.length; i++) {
	        this._cells[i].destructor();
	      }

	      this._collection = new_view;

	      this._parse_cells();
	    } else {
	      var source;

	      if (typeof target_id == "number") {
	        if (target_id < 0 || target_id > this._cells.length) target_id = this._cells.length;
	        var prev_node = (this._cells[target_id] || {})._viewobj;
	        PowerArray.insertAt.call(this._cells, new_view, target_id);
	        if (!new_view._settings.hidden) insertBefore(new_view._viewobj, prev_node, this._dataobj);
	      } else {
	        source = $$(target_id);
	        target_id = PowerArray.find.call(this._cells, source);
	        assert(target_id != -1, "Attempt to replace the non-existing view");
	        var parent = source._viewobj.parentNode;
	        if (parent && !new_view._settings.hidden) parent.insertBefore(new_view._viewobj, source._viewobj);
	        source.destructor();
	        this._cells[target_id] = new_view;
	      }

	      if (!this._vertical_orientation) this._fix_vertical_layout(new_view);
	    }

	    this.resizeChildren(true);
	    var form = this.elements ? this : this.getFormView();
	    if (form) form._recollect_elements();
	    callEvent("onReconstruct", [this]);
	  },
	  _fix_vertical_layout: function (cell) {
	    cell._viewobj.style.display = "inline-block";
	    cell._viewobj.style.verticalAlign = "top";
	  },
	  addView: function (view, index$$1) {
	    if (isUndefined(index$$1)) index$$1 = this._cells.length;
	    var top = this.$$ ? this : this.getTopParentView();
	    state._parent_cell = this;
	    var newui = top && top.ui ? top.ui(view, this, index$$1) : ui(view, this, index$$1);
	    state._parent_cell = null;
	    return newui._settings.id;
	  },
	  removeView: function (id) {
	    var view;
	    if (_typeof(id) != "object") view = $$(id) || (this.$$ ? this.$$(id) : null);else view = id;
	    var target = PowerArray.find.call(this._cells, view);

	    if (target >= 0) {
	      if (this._beforeRemoveView) this._beforeRemoveView(target, view);
	      var form = this.elements ? this : this.getFormView();

	      this._cells.splice(target, 1);

	      if (form) ui.each(view, function (sub) {
	        if (sub.name) delete form.getCleanValues()[sub.config.name];
	      }, form, true);
	      view.destructor();
	      this.resizeChildren(true);
	      if (form) form._recollect_elements();
	    } else assert(false, "Attemp to remove not existing view: " + id);

	    callEvent("onReconstruct", [this]);
	  },
	  reconstruct: function () {
	    this._hiddencells = 0;

	    this._replace(this._collection);
	  },
	  _hide: function (obj, settings, silent) {
	    if (obj._settings.hidden) return;
	    obj._settings.hidden = true;
	    remove(obj._viewobj);
	    this._hiddencells++;
	    if (!silent && !state._ui_creation) this.resizeChildren(true);
	  },
	  _signal_hidden_cells: function (view) {
	    if (view.callEvent) view.callEvent("onViewShow", []);
	  },
	  resizeChildren: function () {
	    if (state._freeze_resize) return;

	    if (this._layout_sizes) {
	      var parent = this.getParentView();

	      if (parent) {
	        if (parent.resizeChildren) return parent.resizeChildren();else return parent.resize();
	      }

	      var sizes = this.$getSize(0, 0);
	      var x, y, nx, ny;
	      nx = x = this._layout_sizes[0] || 0;
	      ny = y = this._layout_sizes[1] || 0; //for auto-fill content, use adjust strategy

	      if ((sizes[1] >= 100000 || sizes[3] >= 100000) && this._viewobj.parentNode) {
	        //in hidden container adjust doesn't work, so fallback to last known size
	        //also, ensure that min-size is not violated
	        nx = x = Math.max(sizes[0], this._settings.width || this._viewobj.parentNode.offsetWidth || x || 0);
	        ny = y = Math.max(sizes[2], this._settings.height || this._viewobj.parentNode.offsetHeight || y || 0);
	      }

	      if (!parent) {
	        //minWidth
	        if (sizes[0] > x) nx = sizes[0]; //minHeight

	        if (sizes[2] > y) ny = sizes[2];
	        var fullscreen = this._viewobj.parentNode == document.body && !this.setPosition; //maxWidth rule

	        if (!fullscreen && x > sizes[1]) nx = sizes[1]; //maxHeight rule

	        if (!fullscreen && y > sizes[3]) ny = sizes[3];
	        this.$setSize(nx, ny);
	      } else this._set_child_size(x, y);

	      if (state._responsive_exception) {
	        state._responsive_exception = false;
	        this.resizeChildren();
	      }

	      callEvent("onResize", []);
	    }
	  },
	  getChildViews: function () {
	    return this._cells;
	  },
	  index: function (obj) {
	    if (obj._settings) obj = obj._settings.id;

	    for (var i = 0; i < this._cells.length; i++) {
	      if (this._cells[i]._settings.id == obj) return i;
	    }

	    return -1;
	  },
	  _show: function (obj, settings, silent) {
	    if (!obj._settings.hidden) return;
	    obj._settings.hidden = false; //index of sibling cell, next to which new item will appear

	    var index$$1 = this.index(obj) + 1; //locate nearest visible cell

	    while (this._cells[index$$1] && this._cells[index$$1]._settings.hidden) {
	      index$$1++;
	    }

	    var view = this._cells[index$$1] ? this._cells[index$$1]._viewobj : null;
	    insertBefore(obj._viewobj, view, this._dataobj || this._viewobj);
	    this._hiddencells--;

	    if (!silent) {
	      this.resizeChildren(true);
	      if (obj.refresh) obj.refresh();
	    }

	    if (obj.callEvent) {
	      obj.callEvent("onViewShow", []);
	      ui.each(obj, this._signal_hidden_cells);
	    }
	  },
	  showBatch: function (name, mode) {
	    var preserve = typeof mode != "undefined";
	    mode = mode !== false;

	    if (!preserve) {
	      if (this._settings.visibleBatch == name) return;
	      this._settings.visibleBatch = name;
	    } else this._settings.visibleBatch = "";

	    var show = [];

	    for (var i = 0; i < this._cells.length; i++) {
	      if (!this._cells[i]._settings.batch && !this._cells[i]._settings.hidden) show.push(this._cells[i]);else if (this._cells[i]._settings.batch == name) {
	        if (mode) show.push(this._cells[i]);else this._hide(this._cells[i], null, true);
	      } else if (!preserve) this._hide(this._cells[i], null, true);
	    }

	    for (var _i = 0; _i < show.length; _i++) {
	      this._show(show[_i], null, true);

	      show[_i]._render_hidden_views();
	    }

	    this.resizeChildren(true);
	  },
	  _parse_cells: function (collection) {
	    this._cells = [];
	    assert(collection, this.name + " was incorrectly defined. <br><br> You have missed rows|cols|cells|elements collection");

	    for (var i = 0; i < collection.length; i++) {
	      state._parent_cell = this;
	      if (!collection[i]._inner) collection[i].borderless = true;
	      this._cells[i] = ui._view(collection[i], this);
	      if (!this._vertical_orientation) this._fix_vertical_layout(this._cells[i]);

	      if (this._settings.visibleBatch && this._settings.visibleBatch != this._cells[i]._settings.batch && this._cells[i]._settings.batch) {
	        this._cells[i]._settings.hidden = true;
	        this._hiddencells++;
	      }

	      if (!this._cells[i]._settings.hidden) {
	        (this._dataobj || this._contentobj).appendChild(this._cells[i]._viewobj);

	        if (this._cells[i].$nospace) this._hiddencells++;
	      }
	    }

	    if (this._parse_cells_ext_end) this._parse_cells_ext_end(collection);
	  },
	  _bubble_size: function (prop, size, vertical) {
	    if (this._vertical_orientation != vertical) for (var i = 0; i < this._cells.length; i++) {
	      this._cells[i]._settings[prop] = size;
	      if (this._cells[i]._bubble_size) this._cells[i]._bubble_size(prop, size, vertical);
	    }
	  },
	  $getSize: function (dx, dy) {
	    debug_size_box_start(this, true);
	    var minWidth = 0;
	    var maxWidth = 100000;
	    var maxHeight = 100000;
	    var minHeight = 0;
	    if (this._vertical_orientation) maxHeight = 0;else maxWidth = 0;
	    var fixed = 0;
	    var fixed_count = 0;
	    var gravity = 0;
	    this._sizes = [];

	    for (var i = 0; i < this._cells.length; i++) {
	      //ignore hidden cells
	      if (this._cells[i]._settings.hidden) continue;

	      var sizes = this._sizes[i] = this._cells[i].$getSize(0, 0);

	      if (this._cells[i].$nospace) {
	        fixed_count++;
	        continue;
	      }

	      if (this._vertical_orientation) {
	        //take max minSize value
	        if (sizes[0] > minWidth) minWidth = sizes[0]; //take min maxSize value

	        if (sizes[1] < maxWidth) maxWidth = sizes[1];
	        minHeight += sizes[2];
	        maxHeight += sizes[3];

	        if (sizes[2] == sizes[3] && sizes[2] != -1) {
	          fixed += sizes[2];
	          fixed_count++;
	        } else gravity += sizes[4];
	      } else {
	        //take max minSize value
	        if (sizes[2] > minHeight) minHeight = sizes[2]; //take min maxSize value

	        if (sizes[3] < maxHeight) maxHeight = sizes[3];
	        minWidth += sizes[0];
	        maxWidth += sizes[1];

	        if (sizes[0] == sizes[1] && sizes[0] != -1) {
	          fixed += sizes[0];
	          fixed_count++;
	        } else gravity += sizes[4];
	      }
	    }

	    if (minHeight > maxHeight) maxHeight = minHeight;
	    if (minWidth > maxWidth) maxWidth = minWidth;
	    this._master_size = [fixed, this._cells.length - fixed_count, gravity];
	    this._desired_size = [minWidth + dx, minHeight + dy]; //get layout sizes

	    var self_size = baseview.api.$getSize.call(this, 0, 0); //use child settings if layout's one was not defined

	    if (self_size[1] >= 100000) self_size[1] = 0;
	    if (self_size[3] >= 100000) self_size[3] = 0;
	    self_size[0] = (self_size[0] || minWidth) + dx;
	    self_size[1] = Math.max(self_size[0], (self_size[1] || maxWidth) + dx);
	    self_size[2] = (self_size[2] || minHeight) + dy;
	    self_size[3] = Math.max(self_size[2], (self_size[3] || maxHeight) + dy);
	    debug_size_box_end(this, self_size);
	    if (!this._vertical_orientation && this._settings.responsive) self_size[0] = 0;
	    return self_size;
	  },
	  $setSize: function (x, y) {
	    this._layout_sizes = [x, y];
	    debug_size_box_start(this);
	    baseview.api.$setSize.call(this, x, y);

	    this._set_child_size(x, y);

	    debug_size_box_end(this, [x, y]);
	  },
	  _set_child_size_a: function (sizes, min, max) {
	    min = sizes[min];
	    max = sizes[max];
	    var height = min;

	    if (min != max) {
	      var ps = this._set_size_delta * sizes[4] / this._set_size_gravity;

	      if (ps < min) {
	        height = min;
	        this._set_size_gravity -= sizes[4];
	        this._set_size_delta -= height;
	      } else if (ps > max) {
	        height = max;
	        this._set_size_gravity -= sizes[4];
	        this._set_size_delta -= height;
	      } else {
	        return -1;
	      }
	    }

	    return height;
	  },
	  _responsive_hide: function (cell, mode) {
	    var target = $$(mode);

	    if (target === "hide" || !target) {
	      cell.hide();
	      cell._responsive_marker = "hide";
	    } else {
	      //for SideBar in Webix 1.9
	      if (!target) target = ui({
	        view: "popup",
	        body: [{}]
	      });
	      cell._responsive_width = cell._settings.width;
	      cell._responsive_height = cell._settings.height;
	      cell._responsive_marker = target._settings.id;
	      cell._settings.width = 0;
	      if (!cell._settings.height) cell._settings.autoheight = true;
	      ui(cell, target, this._responsive.length);
	    }

	    this._responsive.push(cell);
	  },
	  _responsive_show: function (cell) {
	    var target = cell._responsive_marker;
	    cell._responsive_marker = 0;

	    if (target === "hide" || !target) {
	      cell.show();
	    } else {
	      cell._settings.width = cell._responsive_width;
	      cell._settings.height = cell._responsive_height;
	      delete cell._settings.autoheight;
	      var index$$1 = 0;

	      while (this._cells[index$$1] && this._cells[index$$1]._settings.responsiveCell === false) {
	        index$$1++;
	      }

	      ui(cell, this, index$$1);
	    }

	    this._responsive.pop();
	  },
	  _responsive_cells: function (x) {
	    state._responsive_tinkery = true;

	    if (x + this._padding.left + this._padding.right + this._margin * (this._cells.length - 1) < this._desired_size[0]) {
	      var max = this._cells.length - 1;

	      for (var i = 0; i < max; i++) {
	        var cell = this._cells[i];

	        if (!cell._responsive_marker) {
	          if (cell._settings.responsiveCell !== false) {
	            this._responsive_hide(cell, this._settings.responsive);

	            callEvent("onResponsiveHide", [cell._settings.id]);
	            state._responsive_exception = true;
	            break;
	          } else {
	            max = this._cells.length;
	          }
	        }
	      }
	    } else if (this._responsive.length) {
	      var _cell = this._responsive[this._responsive.length - 1];
	      var dx = _cell._responsive_marker == "hide" ? 0 : _cell._responsive_width;

	      var px = _cell.$getSize(dx, 0);

	      if (px[0] + this._desired_size[0] + this._margin + 20 <= x) {
	        this._responsive_show(_cell);

	        callEvent("onResponsiveShow", [_cell._settings.id]);
	        state._responsive_exception = true;
	      }
	    }

	    state._responsive_tinkery = false;
	  },
	  _set_child_size: function (x, y) {
	    state._child_sizing_active = (state._child_sizing_active || 0) + 1;
	    if (!this._vertical_orientation && this._settings.responsive) this._responsive_cells(x, y);
	    this._set_size_delta = (this._vertical_orientation ? y : x) - this._master_size[0];
	    this._set_size_gravity = this._master_size[2];
	    var width = x;
	    var height = y;
	    var auto = [];

	    for (var i = 0; i < this._cells.length; i++) {
	      //ignore hidden cells
	      if (this._cells[i]._settings.hidden || !this._sizes[i]) continue;
	      var sizes = this._sizes[i];

	      if (this._vertical_orientation) {
	        height = this._set_child_size_a(sizes, 2, 3);

	        if (height < 0) {
	          auto.push(i);
	          continue;
	        }
	      } else {
	        width = this._set_child_size_a(sizes, 0, 1);

	        if (width < 0) {
	          auto.push(i);
	          continue;
	        }
	      }

	      this._cells[i].$setSize(width, height);
	    }

	    for (var _i2 = 0; _i2 < auto.length; _i2++) {
	      var index$$1 = auto[_i2];
	      var _sizes = this._sizes[index$$1];
	      var dx = Math.round(this._set_size_delta * _sizes[4] / this._set_size_gravity);
	      this._set_size_delta -= dx;
	      this._set_size_gravity -= _sizes[4];
	      if (this._vertical_orientation) height = dx;else {
	        width = dx;
	      }

	      this._cells[index$$1].$setSize(width, height);
	    }

	    state._child_sizing_active -= 1;
	  },
	  _next: function (obj, mode) {
	    var index$$1 = this.index(obj);
	    if (index$$1 == -1) return null;
	    return this._cells[index$$1 + mode];
	  },
	  _first: function () {
	    return this._cells[0];
	  }
	};
	var view$4 = exports.protoUI(api$4, EventSystem, baseview.view);
	var baselayout = {
	  api: api$4,
	  view: view$4
	};

	var api$5 = {
	  name: "spacer",
	  defaults: {
	    borderless: true
	  },
	  $init: function () {
	    this._viewobj.className += " webix_spacer";
	  }
	};
	var view$5 = exports.protoUI(api$5, base.view);

	var api$6 = {
	  name: "template",
	  $init: function (config) {
	    var subtype = this._template_types[config.type];

	    if (subtype) {
	      exports.extend(config, subtype); //will reset borders for "section"

	      if (config.borderless) {
	        delete config._inner;

	        this._set_inner(config);
	      }
	    }

	    if (this._dataobj == this._viewobj) {
	      this._dataobj = create("DIV");
	      this._dataobj.className = " webix_template";

	      this._viewobj.appendChild(this._dataobj);
	    } else this._dataobj.className += " webix_template";

	    this.attachEvent("onAfterRender", this._correct_width_scroll);
	  },
	  setValues: function (obj, update) {
	    this.data = update ? exports.extend(this.data, obj, true) : obj;
	    this.render();
	  },
	  getValues: function () {
	    return this.data;
	  },
	  $skin: function () {
	    this._template_types.header.height = $active.barHeight - $active.borderWidth * 2;
	    this._template_types.section.height = $active.barHeight;
	  },
	  _template_types: {
	    "header": {
	      css: "webix_header"
	    },
	    "section": {
	      css: "webix_section",
	      borderless: true
	    },
	    "clean": {
	      css: "webix_clean",
	      borderless: true
	    }
	  },
	  onClick_setter: function (value) {
	    this.on_click = exports.extend(this.on_click || {}, value, true);
	    if (!this._onClick) exports.extend(this, MouseEvents);
	    return value;
	  },
	  defaults: {
	    template: template.empty
	  },
	  _render_me: function () {
	    this._not_render_me = false;

	    this._probably_render_me();

	    this.resize();
	  },
	  _probably_render_me: function () {
	    if (!this._not_render_me) {
	      this._not_render_me = true;
	      this.render();
	    }
	  },
	  src_setter: function (value) {
	    this._not_render_me = true;
	    if (!this.callEvent("onBeforeLoad", [])) return "";
	    ajax(value, bind(function (text) {
	      this._settings.template = template(text);

	      this._render_me();

	      this.callEvent("onAfterLoad", []);
	    }, this));
	    return value;
	  },
	  _correct_width_scroll: function () {
	    //we need to force auto height calculation after content change
	    //dropping the last_size flag will ensure that inner logic of $setSize will be processed
	    if (this._settings.autoheight) {
	      this._last_size = null;
	      this.resize();
	    }

	    if (this._settings.scroll && this._settings.scroll.indexOf("x") != -1) this._dataobj.style.width = this._dataobj.scrollWidth + "px";
	  },
	  content_setter: function (config) {
	    if (config) {
	      this._not_render_me = true;

	      this.render = function () {};

	      this._dataobj.appendChild(toNode(config));

	      delay(this._correct_width_scroll, this);
	    }
	  },
	  refresh: function () {
	    this.render();
	  },
	  setHTML: function (html) {
	    this._settings.template = function () {
	      return html;
	    };

	    this.refresh();
	  },
	  setContent: function (content) {
	    this._dataobj.innerHTML = "";
	    this.content_setter(content);
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      this._probably_render_me();

	      if (this._settings.autoheight) {
	        var top = this.getTopParentView();
	        clearTimeout(top._template_resize_timer);
	        top._template_resize_timer = delay(this.resize, this);
	      }

	      return true;
	    }
	  },
	  $getSize: function (x, y) {
	    if (this._settings.autoheight && (!this._settings.type || this._settings.type == "clean")) this._settings.height = this._get_auto_height();
	    return base.api.$getSize.call(this, x, y);
	  },
	  _get_auto_height: function () {
	    var size;
	    var padding = $active.layoutPadding.space;

	    this._probably_render_me();

	    if (!this.isVisible()) {
	      //try getting height of a hidden template
	      size = getTextSize(this._toHTML(this.data) || this._dataobj.innerHTML, //check for config.content 
	      "webix_template", (this.$width || (this.getParentView() ? this.getParentView().$width : 0)) - padding).height;
	    } else {
	      this._dataobj.style.height = "auto";
	      size = this._dataobj.scrollHeight;
	      this._dataobj.style.height = "";
	    }

	    return size;
	  },
	  _one_time_scroll: true //scroll will appear only if set directly in config

	};
	var view$6 = exports.protoUI(api$6, Scrollable, AutoTooltip, AtomDataLoader, AtomRender, EventSystem, base.view);
	var template$1 = {
	  api: api$6,
	  view: view$6
	};

	/*scrollable view with another view insize*/

	var api$7 = {
	  name: "scrollview",
	  defaults: {
	    scroll: "y",
	    scrollSpeed: "0ms"
	  },
	  $init: function () {
	    this._viewobj.className += " webix_scrollview";
	  },
	  body_setter: function (config) {
	    config.borderless = true;
	    state._parent_cell = this;
	    this._body_cell = ui._view(config);

	    this._dataobj.appendChild(this._body_cell._viewobj);
	  },
	  getChildViews: function () {
	    return [this._body_cell];
	  },
	  getBody: function () {
	    return this._body_cell;
	  },
	  resizeChildren: function () {
	    if (!this._body_cell) return;
	    this._desired_size = this._body_cell.$getSize(0, 0);

	    this._resizeChildren();

	    callEvent("onResize", []);
	  },
	  _resizeChildren: function () {
	    var cx = Math.max(this._content_width, this._desired_size[0]);
	    var cy = Math.max(this._content_height, this._desired_size[2]);

	    this._body_cell.$setSize(cx, cy);

	    this._dataobj.style.width = this._body_cell._content_width + "px";
	    this._dataobj.style.height = this._body_cell._content_height + "px";

	    if (env.touch) {
	      var scroll = this.getScrollState();
	      var top = this._body_cell._content_height - this._content_height;
	      if (top < scroll.y) this.scrollTo(null, top);
	    }

	    if (state._responsive_exception) {
	      state._responsive_exception = false;
	      this._desired_size = this._body_cell.$getSize(0, 0);

	      this._resizeChildren();
	    }
	  },
	  $getSize: function (dx, dy) {
	    var desired_size = this._desired_size = this._body_cell.$getSize(0, 0);

	    var self_sizes = base.api.$getSize.call(this, dx, dy);
	    var scroll_size = this._native_scroll || env.scrollSize;

	    if (this._settings.scroll == "x") {
	      self_sizes[2] = Math.max(self_sizes[2], desired_size[2]) + scroll_size;
	      self_sizes[3] = Math.min(self_sizes[3], desired_size[3]) + scroll_size;
	    } else if (this._settings.scroll == "y") {
	      self_sizes[0] = Math.max(self_sizes[0], desired_size[0]) + scroll_size;
	      self_sizes[1] = Math.min(self_sizes[1], desired_size[1]) + scroll_size;
	    }

	    return self_sizes;
	  },
	  $setSize: function (x, y) {
	    var temp = env.scrollSize;
	    env.scrollSize = this._native_scroll || temp;
	    if (base.api.$setSize.call(this, x, y) || state._force_resize) this._resizeChildren();
	    env.scrollSize = temp;
	  },
	  scroll_setter: function (value) {
	    var custom = env.$customScroll;

	    if (typeof value == "string" && value.indexOf("native-") === 0) {
	      this._native_scroll = 17;
	      value = value.replace("native-");
	      env.$customScroll = false;
	    }

	    value = Scrollable.scroll_setter.call(this, value);
	    env.$customScroll = custom;
	    return value;
	  },
	  _replace: function (new_view) {
	    this._body_cell.destructor();

	    this._body_cell = new_view;

	    this._bodyobj.appendChild(this._body_cell._viewobj);

	    this.resize();
	  },
	  showView: function (id) {
	    var topPos = $$(id).$view.offsetTop - $$(id).$view.parentNode.offsetTop;
	    this.scrollTo(0, topPos);
	  }
	};
	var view$7 = exports.protoUI(api$7, Scrollable, EventSystem, base.view);

	var api$8 = {
	  name: "iframe",
	  $init: function () {
	    this._dataobj = this._contentobj;
	    this._contentobj.innerHTML = "<iframe style='width:100%; height:100%' frameborder='0' onload='var t = $$(this.parentNode.getAttribute(\"view_id\")); if (t) t.callEvent(\"onAfterLoad\",[]);' src='about:blank'></iframe>";
	  },
	  load: function (value) {
	    this.src_setter(value);
	  },
	  src_setter: function (value) {
	    if (!this.callEvent("onBeforeLoad", [])) return "";
	    this.getIframe().src = value;
	    return value;
	  },
	  getIframe: function () {
	    return this._contentobj.getElementsByTagName("iframe")[0];
	  },
	  getWindow: function () {
	    return this.getIframe().contentWindow;
	  }
	};
	var view$8 = exports.protoUI(api$8, base.view, EventSystem);

	var api$9 = {
	  name: "layout",
	  $init: function () {
	    this._hiddencells = 0;
	  },
	  defaults: {
	    type: "line"
	  },
	  _parse_cells: function () {
	    if (this._parse_cells_ext) collection = this._parse_cells_ext(collection);

	    if (!this._parse_once) {
	      this._viewobj.className += " webix_layout_" + (this._settings.type || "");
	      this._parse_once = 1;
	    }

	    if (this._settings.margin !== undefined) this._margin = this._settings.margin;
	    if (this._settings.padding !== undefined && _typeof(this._settings.padding) !== "object") this._padding.left = this._padding.right = this._padding.top = this._padding.bottom = this._settings.padding;
	    if (this._settings.paddingX !== undefined) this._padding.left = this._padding.right = this._settings.paddingX;
	    if (this._settings.paddingY !== undefined) this._padding.top = this._padding.bottom = this._settings.paddingY;
	    if (_typeof(this._settings.padding) === "object") exports.extend(this._padding, this._settings.padding, true);
	    if (this._padding.left || this._padding.right || this._padding.top || this._padding.bottom) this._padding.defined = true; //if layout has paddings we need to set the visible border 

	    if (this._hasBorders() && !this._settings.borderless) {
	      this._contentobj.style.borderWidth = "1px"; //if layout has border - normal bordering rules are applied

	      this._render_borders = true;
	    }

	    var collection = this._collection;
	    if (this._settings.borderless) this._settings._inner = {
	      top: true,
	      left: true,
	      right: true,
	      bottom: true
	    };

	    this._beforeResetBorders(collection);

	    baselayout.api._parse_cells.call(this, collection);

	    this._afterResetBorders(collection);
	  },
	  $getSize: function (dx, dy) {
	    dx = dx || 0;
	    dy = dy || 0;
	    var correction = this._margin * (this._cells.length - this._hiddencells - 1);

	    if (this._render_borders || this._hasBorders()) {
	      var _borders = this._settings._inner;

	      if (_borders) {
	        dx += (_borders.left ? 0 : 1) + (_borders.right ? 0 : 1);
	        dy += (_borders.top ? 0 : 1) + (_borders.bottom ? 0 : 1);
	      }
	    }

	    if (!this._settings.height) dy += this._padding.top + this._padding.bottom + (this._vertical_orientation ? correction : 0);
	    if (!this._settings.width) dx += this._padding.left + this._padding.right + (this._vertical_orientation ? 0 : correction);
	    return baselayout.api.$getSize.call(this, dx, dy);
	  },
	  $setSize: function (x, y) {
	    this._layout_sizes = [x, y];
	    debug_size_box_start(this);
	    if (this._hasBorders() || this._render_borders) base.api.$setSize.call(this, x, y);else baseview.api.$setSize.call(this, x, y); //form with scroll

	    y = this._content_height;
	    x = this._content_width;
	    var config = this._settings;

	    if (config.scroll) {
	      y = Math.max(y, this._desired_size[1]);
	      x = Math.max(x, this._desired_size[0]);
	    }

	    this._set_child_size(x, y);

	    debug_size_box_end(this, [x, y]);
	  },
	  _set_child_size: function (x, y) {
	    var correction = this._margin * (this._cells.length - this._hiddencells - 1);
	    y -= this._padding.top + this._padding.bottom;
	    x -= this._padding.left + this._padding.right;
	    if (this._vertical_orientation) y -= correction;else x -= correction;
	    return baselayout.api._set_child_size.call(this, x, y);
	  },
	  resizeChildren: function (structure_changed) {
	    if (structure_changed) {
	      this._last_size = null; //forces children resize

	      var config = [];

	      for (var i = 0; i < this._cells.length; i++) {
	        var cell = this._cells[i];
	        config[i] = cell._settings;
	        var n = cell._layout_sizes && !cell._render_borders || cell._settings.borderless ? "0px" : "1px";
	        cell._viewobj.style.borderTopWidth = cell._viewobj.style.borderBottomWidth = cell._viewobj.style.borderLeftWidth = cell._viewobj.style.borderRightWidth = n;
	      }

	      this._beforeResetBorders(config);

	      for (var _i = 0; _i < config.length; _i++) {
	        if (config[_i].borderless && this._cells[_i]._set_inner) this._cells[_i]._set_inner(config[_i]);
	      }

	      this._afterResetBorders(this._cells);
	    }

	    if (state._responsive_tinkery) return;
	    baselayout.api.resizeChildren.call(this);
	  },
	  _hasBorders: function () {
	    return this._padding.defined && this._margin > 0 && !this._cleanlayout;
	  },
	  _beforeResetBorders: function (collection) {
	    if (this._hasBorders() && (!this._settings.borderless || this._settings.type == "space")) {
	      for (var i = 0; i < collection.length; i++) {
	        if (!collection[i]._inner || !collection[i].borderless) collection[i]._inner = {
	          top: false,
	          left: false,
	          right: false,
	          bottom: false
	        };
	      }
	    } else {
	      for (var _i2 = 0; _i2 < collection.length; _i2++) {
	        collection[_i2]._inner = clone(this._settings._inner);
	      }

	      var mode = false;
	      if (this._cleanlayout) mode = true;
	      var maxlength = collection.length;

	      if (this._vertical_orientation) {
	        for (var _i3 = 1; _i3 < maxlength - 1; _i3++) {
	          collection[_i3]._inner.top = collection[_i3]._inner.bottom = mode;
	        }

	        if (maxlength > 1) {
	          if (this._settings.type != "head") collection[0]._inner.bottom = mode;

	          while (collection[maxlength - 1].hidden && maxlength > 1) {
	            maxlength--;
	          }

	          if (maxlength > 0) collection[maxlength - 1]._inner.top = mode;
	        }
	      } else {
	        for (var _i4 = 1; _i4 < maxlength - 1; _i4++) {
	          collection[_i4]._inner.left = collection[_i4]._inner.right = mode;
	        }

	        if (maxlength > 1) {
	          if (this._settings.type != "head") collection[0]._inner.right = mode;
	          collection[maxlength - 1]._inner.left = mode;

	          while (maxlength > 1 && collection[maxlength - 1].hidden) {
	            maxlength--;
	          }

	          if (maxlength > 0) collection[maxlength - 1]._inner.left = mode;
	        }
	      }
	    }
	  },
	  _fix_container_borders: function (style, inner) {
	    if (inner.top) style.borderTopWidth = "0px";
	    if (inner.left) style.borderLeftWidth = "0px";
	    if (inner.right) style.borderRightWidth = "0px";
	    if (inner.bottom) style.borderBottomWidth = "0px";
	  },
	  _afterResetBorders: function (collection) {
	    var start = 0;

	    for (var i = 0; i < collection.length; i++) {
	      var cell = this._cells[i];
	      var s_inner = cell._settings._inner;

	      if (cell._settings.hidden && this._cells[i + 1]) {
	        var s_next = this._cells[i + 1]._settings._inner;
	        if (!s_inner.top) s_next.top = false;
	        if (!s_inner.left) s_next.left = false;
	        if (i == start) start++;
	      }

	      this._fix_container_borders(cell._viewobj.style, cell._settings._inner);
	    }

	    var style = this._vertical_orientation ? "marginLeft" : "marginTop";
	    var contrstyle = this._vertical_orientation ? "marginTop" : "marginLeft";
	    var padding = this._vertical_orientation ? this._padding.left : this._padding.top;
	    var contrpadding = this._vertical_orientation ? this._padding.top : this._padding.left; //add top offset to all

	    for (var _i5 = 0; _i5 < collection.length; _i5++) {
	      this._cells[_i5]._viewobj.style[style] = padding + "px";
	    } //add left offset to first cell


	    if (this._cells.length) this._cells[start]._viewobj.style[contrstyle] = contrpadding + "px"; //add offset between cells

	    for (var index = start + 1; index < collection.length; index++) {
	      this._cells[index]._viewobj.style[contrstyle] = this._margin + "px";
	    }
	  },
	  type_setter: function (value) {
	    this._margin = typeof this._margin_set[value] !== "undefined" ? this._margin_set[value] : this._margin_set["line"];
	    this._padding.left = this._padding.right = this._padding.top = this._padding.bottom = typeof this._margin_set[value] !== "undefined" ? this._padding_set[value] : this._padding_set["line"];
	    this._cleanlayout = value == "material" || value == "clean";
	    if (value == "material") this._settings.borderless = true;
	    return value;
	  },
	  $skin: function () {
	    this._margin_set = $active.layoutMargin;
	    this._padding_set = $active.layoutPadding;
	  }
	};
	var view$9 = exports.protoUI(api$9, baselayout.view);
	var layout = {
	  api: api$9,
	  view: view$9
	}; //not necessary anymore
	//preserving for backward compatibility

	view$9.call(-1);

	var api$a = {
	  name: "accordion",
	  defaults: {
	    panelClass: "accordionitem",
	    multi: false,
	    collapsed: false
	  },
	  $init: function () {
	    this._viewobj.setAttribute("role", "tablist");

	    this._viewobj.setAttribute("aria-multiselectable", "true");
	  },
	  _replace: function (newview) {
	    layout.api._replace.apply(this, arguments);

	    if (newview.collapsed_setter && newview.refresh) {
	      newview.refresh();
	    }
	  },
	  _parse_cells: function () {
	    var panel = this._settings.panelClass;
	    var cells = this._collection;

	    for (var i = 0; i < cells.length; i++) {
	      if ((cells[i].body || cells[i].header) && !cells[i].view && !cells[i].align) cells[i].view = panel;
	      if (isUndefined(cells[i].collapsed)) cells[i].collapsed = this._settings.collapsed;
	    }

	    this._skin_render_collapse = true;

	    layout.api._parse_cells.call(this);

	    this._skin_render_collapse = false;

	    for (var _i = 0; _i < this._cells.length; _i++) {
	      if (this._cells[_i].name == panel) this._cells[_i].refresh();
	      this._cells[_i]._accLastChild = false;
	    }

	    var found = false;

	    for (var _i2 = this._cells.length - 1; _i2 >= 0 && !found; _i2--) {
	      if (!this._cells[_i2]._settings.hidden) {
	        this._cells[_i2]._accLastChild = true;
	        found = true;
	      }
	    }
	  },
	  _afterOpen: function (view) {
	    if (this._settings.multi === false && this._skin_render_collapse !== true) {
	      for (var i = 0; i < this._cells.length; i++) {
	        if (view != this._cells[i] && !this._cells[i]._settings.collapsed && this._cells[i].collapse) this._cells[i].collapse();
	      }
	    }

	    if (view.callEvent) {
	      view.callEvent("onViewShow", []);
	      each(view, this._signal_hidden_cells);
	    }
	  },
	  _canCollapse: function (view) {
	    if (this._settings.multi === true || this._skin_render_collapse) return true; //can collapse only if you have other item to open

	    for (var i = 0; i < this._cells.length; i++) {
	      if (view != this._cells[i] && !this._cells[i]._settings.collapsed && this._cells[i].isVisible() && !this._cells[i].$nospace) return true;
	    }

	    return false;
	  },
	  $skin: function () {
	    var defaults = this.defaults;
	    if ($active.accordionType) defaults.type = $active.accordionType;
	  }
	};
	var view$a = exports.protoUI(api$a, layout.view);
	var base$1 = {
	  api: api$a,
	  view: view$a
	};

	var api$b = {
	  name: "headerlayout",
	  defaults: {
	    type: "accordion",
	    multi: "mixed",
	    collapsed: false
	  }
	};
	var view$b = exports.protoUI(api$b, base$1.view);

	var api$c = {
	  name: "accordionitem",
	  $init: function (config) {
	    this._viewobj.innerHTML = "<div tabindex='0' webix_ai_id='" + config.id + "'  class='webix_accordionitem_header'><div class='webix_accordionitem_button' ></div><div class='webix_accordionitem_label' ></div></div><div class='webix_accordionitem_body'></div>";
	    this._contentobj = this._viewobj;
	    this._headobj = this._contentobj.childNodes[0];
	    if (!config.header) this._headobj.style.display = "none";
	    this._headlabel = this._contentobj.childNodes[0].childNodes[1];
	    this._headbutton = this._contentobj.childNodes[0].childNodes[0];
	    this._bodyobj = this._contentobj.childNodes[1];
	    this._viewobj.className += " webix_accordionitem";
	    this._head_cell = this._body_cell = null;
	    this._cells = true;

	    this._bodyobj.setAttribute("role", "tabpanel");

	    this._headobj.setAttribute("role", "tab");

	    this.attachEvent("onKeyPress", this._onKeyPress);
	  },
	  _remove: function () {
	    this._body_cell = {
	      destructor: function () {}
	    };
	  },
	  _replace: function (new_view) {
	    this._body_cell.destructor();

	    this._body_cell = new_view;

	    this._bodyobj.appendChild(this._body_cell._viewobj);

	    this.resize();
	  },
	  _id: "webix_ai_id",
	  getChildViews: function () {
	    return [this._body_cell];
	  },
	  body_setter: function (value) {
	    if (_typeof(value) != "object") value = {
	      template: value
	    };
	    value._inner = {
	      top: true,
	      left: true,
	      right: true,
	      bottom: true
	    };
	    state._parent_cell = this;
	    this._body_cell = ui._view(value);

	    this._bodyobj.appendChild(this._body_cell._viewobj);

	    return value;
	  },
	  header_setter: function (value) {
	    if (value) value = template(value);
	    return value;
	  },
	  headerAlt_setter: function (value) {
	    if (value) value = template(value);
	    return value;
	  },
	  $getSize: function (dx, dy) {
	    var size = this._body_cell.$getSize(0, 0); //apply external border to inner content sizes


	    var _borders = this._settings._inner;

	    if (_borders) {
	      dx += (_borders.left ? 0 : 1) + (_borders.right ? 0 : 1);
	      dy += (_borders.top ? 0 : 1) + (_borders.bottom ? 0 : 1);
	    }

	    var header = 0;
	    var self_size = baseview.api.$getSize.call(this, 0, 0); //use child settings if layout's one was not defined

	    self_size[0] = (self_size[0] || size[0]) + dx;
	    if (self_size[1] >= 100000) self_size[1] = size[1];
	    self_size[1] += dx;
	    self_size[2] = (self_size[2] || size[2]) + dy;
	    var fixedHeight = self_size[3] < 100000;
	    if (!fixedHeight) self_size[3] = size[3];
	    self_size[3] += dy;

	    if (this.getParentView()._vertical_orientation) {
	      if (this._settings.collapsed) {
	        self_size[2] = self_size[3] = this._getHeaderSize() + dy;
	      } else if (this._settings.header) header = this._settings.headerHeight;
	    } else {
	      if (this._settings.collapsed) self_size[0] = self_size[1] = this._getHeaderSize() + dx;
	      if (this._settings.header) header = this._settings.headerHeight;
	    } //include header in total height calculation


	    if (!fixedHeight) {
	      self_size[2] += header;
	      self_size[3] += header;
	    }

	    debug_size_box(this, self_size, true);
	    return self_size;
	  },
	  on_click: {
	    webix_accordionitem_header: function (e) {
	      this._toggle(e);

	      return false;
	    },
	    webix_accordionitem_header_v: function (e) {
	      this._toggle(e);

	      return false;
	    }
	  },
	  _toggle: function () {
	    this.define("collapsed", !this._settings.collapsed);
	  },
	  collapsed_setter: function (value) {
	    if (this._settings.header === false) return; //use last layout element if parent is not known yet

	    var parent = this.getParentView();

	    if (parent) {
	      if (!value) this._expand();else {
	        if (parent._canCollapse(this)) this._collapse();else {
	          var success = 0;
	          if (parent._cells.length > 1) for (var i = 0; i < parent._cells.length; i++) {
	            var sibl = parent._cells[i];

	            if (this != sibl && sibl.isVisible() && sibl.expand) {
	              sibl.expand();

	              this._collapse();

	              success = 1;
	              break;
	            }
	          }
	          if (!success) return;
	        }
	      }
	      this._settings.collapsed = value;
	      if (!value) parent._afterOpen(this);
	      this.refresh();
	      if (!state._ui_creation) this.resize();
	      parent.callEvent("onAfter" + (value ? "Collapse" : "Expand"), [this._settings.id]);
	      this._settings.$noresize = value;
	    }

	    return value;
	  },
	  collapse: function () {
	    this.define("collapsed", true);

	    UIManager._moveChildFocus(this);
	  },
	  expand: function () {
	    this.define("collapsed", false);
	  },
	  _show: function () {
	    this.show();
	  },
	  _hide: function () {
	    this.hide();
	  },
	  _expand: function () {
	    this._bodyobj.style.display = "";
	    removeCss(this.$view, "collapsed");
	    removeCss(this._headobj, "collapsed");

	    this._headobj.setAttribute("aria-expanded", "true");
	  },
	  _collapse: function () {
	    if (this._settings.headerAlt) this._headlabel.innerHTML = this._settings.headerAlt();
	    this._bodyobj.style.display = "none";
	    addCss(this.$view, "collapsed");
	    addCss(this._headobj, "collapsed");

	    this._headobj.setAttribute("aria-expanded", "false");
	  },
	  refresh: function () {
	    var template$$1 = this._settings[this._settings.collapsed ? "headerAlt" : "header"] || this._settings.header;

	    if (template$$1) {
	      this._headlabel.innerHTML = template$$1();

	      this._headbutton.setAttribute("aria-label", template$$1());
	    }

	    var css = this.getParentView()._vertical_orientation ? "vertical" : "horizontal";

	    if (this._viewobj.className.indexOf(" " + css) < 0) {
	      addCss(this._viewobj, css);
	    } //fix collapsed columns in IE8


	    if (!env.transform) {
	      addCss(this._viewobj, "webix_ie", true);
	    }
	  },
	  _getHeaderSize: function () {
	    return this._settings.collapsed ? this._settings.headerAltHeight : this._settings.headerHeight;
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y) || this._getHeaderSize() != this._last_set_header_size) {
	      x = this._content_width;
	      y = this._content_height;

	      var headerSize = this._last_set_header_size = this._getHeaderSize(); //-(this._settings._inner.top?0:1);


	      if (this._settings.header) {
	        this._headobj.style.height = headerSize + "px";
	        this._headobj.style.width = "auto";
	        this._headobj.style[env.transform] = "";
	        this._headobj.style.borderBottomWidth = (this._settings.collapsed ? 0 : 1) + "px";

	        if (this.getParentView()._vertical_orientation || !this._settings.collapsed) {
	          y -= this._getHeaderSize();
	        } else if (this._settings.collapsed) {
	          //-2 - borders
	          if (animate.isSupported()) {
	            this._headobj.style.width = y + "px";
	            this._headobj.style.height = x + 3 + "px";
	            var d = Math.floor(y / 2 - x / 2) + (x - this._settings.headerAltHeight) / 2;
	            this._headobj.style[env.transform] = "rotate(90deg) translate(" + d + "px, " + (d + 1) + "px)";
	          } else {
	            //IE8 fix
	            this._headobj.style.width = x + "px";
	            this._headobj.style.height = y + 3 + "px";
	          }
	        }
	      }

	      if (!this._settings.collapsed) {
	        this._body_cell.$setSize(x, y);

	        this._last_size_y = y;
	      }
	    } else if (!this._settings.collapsed) {
	      var body = this._body_cell;
	      if (this._last_size_y) body.$setSize(this._content_width, this._last_size_y);
	    }
	  },
	  $skin: function () {
	    var defaults = this.defaults;
	    defaults.headerAltHeight = defaults.headerHeight = $active.barHeight - $active.borderWidth * 2;
	  },
	  defaults: {
	    header: false,
	    headerAlt: false,
	    body: ""
	  }
	};
	var view$c = exports.protoUI(api$c, MouseEvents, EventSystem, base.view);

	var api$d = {
	  name: "resizearea",
	  defaults: {
	    dir: "x"
	  },
	  $init: function (config) {
	    var dir = config.dir || "x";
	    var node = toNode(config.container);
	    var size = dir == "x" ? "width" : "height";
	    var margin = config.margin ? config.margin + "px" : 0;
	    this._key_property = dir == "x" ? "left" : "top";
	    this._viewobj = create("DIV", {
	      "class": "webix_resize_area webix_dir_" + dir
	    }); //[[COMPAT]] FF12 can produce 2 move events

	    _event(this._viewobj, env.mouse.down, stopEvent);

	    if (margin) {
	      if (dir == "x") margin = margin + " 0 " + margin;else margin = "0 " + margin + " 0 " + margin;
	    }

	    this._dragobj = create("DIV", {
	      "class": "webix_resize_handle_" + dir,
	      "style": margin ? "padding:" + margin : ""
	    }, "<div class='webix_handle_content'></div>");
	    this._originobj = create("DIV", {
	      "class": "webix_resize_origin_" + dir
	    });

	    if (config[size]) {
	      this._originobj.style[size] = config[size] + (config.border ? 1 : 0) + "px";
	      this._dragobj.style[size] = config[size] + "px";
	    }

	    if (config.cursor) this._dragobj.style.cursor = this._originobj.style.cursor = this._viewobj.style.cursor = config.cursor;
	    this._moveev = event$1(node, env.mouse.move, this._onmove, {
	      bind: this
	    });
	    this._upev = event$1(document.body, env.mouse.up, this._onup, {
	      bind: this
	    });
	    this._dragobj.style[this._key_property] = this._originobj.style[this._key_property] = config.start + "px";
	    node.appendChild(this._viewobj);
	    node.appendChild(this._dragobj);
	    node.appendChild(this._originobj);
	  },
	  _onup: function () {
	    this.callEvent("onResizeEnd", [this._last_result]);
	    eventRemove(this._moveev);
	    eventRemove(this._upev);
	    remove(this._viewobj);
	    remove(this._dragobj);
	    remove(this._originobj);
	    this._viewobj = this._dragobj = this._originobj = null;
	  },
	  _onmove: function (e) {
	    var eventPos = pos(e);
	    this._last_result = (this._settings.dir == "x" ? eventPos.x : eventPos.y) + this._settings.start - this._settings.eventPos;
	    this._dragobj.style[this._key_property] = this._last_result + "px";
	    this.callEvent("onResize", [this._last_result]);
	  }
	};
	var view$d = exports.protoUI(api$d, EventSystem, Settings);

	var api$e = {
	  name: "resizer",
	  defaults: {
	    width: 7,
	    height: 7
	  },
	  $init: function (config) {
	    assert(this.getParentView(), "Resizer can't be initialized outside a layout");
	    this._viewobj.className += " webix_resizer";

	    var space = this.getParentView()._margin;

	    _event(this._viewobj, env.mouse.down, this._rsDown, {
	      bind: this
	    });

	    event$1(document.body, env.mouse.up, this._rsUp, {
	      bind: this
	    });

	    var dir = this._getResizeDir();

	    this._rs_started = false;
	    this._resizer_dir = dir;
	    this._resizer_dim = dir == "x" ? "width" : "height";
	    if (dir == "x") config.height = 0;else config.width = 0;

	    if (space > 0) {
	      this._viewobj.className += " webix_resizer_v" + dir;
	      this._viewobj.style.marginRight = "-" + space + "px";
	      if (dir == "x") config.width = space;else config.height = space;
	      this.$nospace = true;
	    } else this._viewobj.className += " webix_resizer_" + dir;

	    this._viewobj.innerHTML = "<div class='webix_resizer_content'></div>";
	    if (dir == "y" && space > 0) this._viewobj.style.marginBottom = "-" + (config.height || this.defaults.height) + "px";

	    this._viewobj.setAttribute("webix_disable_drag", "true");

	    this._viewobj.setAttribute("tabindex", "-1");

	    this._viewobj.setAttribute("aria-grabbed", "false");
	  },
	  _rsDown: function (e) {
	    var cells = this._getResizerCells(); //some sibling can block resize


	    if (cells && !this._settings.disabled) {
	      e = e || event$1;
	      this._rs_started = true;
	      this._rs_process = pos(e);
	      this._rsLimit = [];

	      this._viewobj.setAttribute("aria-grabbed", "true");

	      for (var i = 0; i < 2; i++) {
	        cells[i].$view.setAttribute("aria-dropeffect", "move");
	      }

	      this._viewobj.setAttribute("aria-dropeffect", "move");

	      this._rsStart(e, cells[0]);
	    }
	  },
	  _rsUp: function () {
	    this._rs_started = false;
	    this._rs_process = false;
	  },
	  _rsStart: function (e, cell) {
	    var dir, cellOffset, pos$$1, posParent, start;
	    e = e || event$1;
	    dir = this._resizer_dir;
	    /*layout position:relative to place absolutely positioned elements in it*/

	    this.getParentView()._viewobj.style.position = "relative";
	    pos$$1 = offset(this._viewobj);
	    posParent = offset(this.getParentView()._viewobj);
	    start = pos$$1[dir] - posParent[dir];
	    cellOffset = offset(cell.$view)[dir] - offset(this.getParentView().$view)[dir];
	    this._rs_progress = [dir, cell, start, cellOffset];
	    /*resizer stick (resizerea ext)*/

	    this._resizeStick = new ui.resizearea({
	      container: this.getParentView()._viewobj,
	      dir: dir,
	      eventPos: this._rs_process[dir],
	      start: start - 1,
	      height: this.$height,
	      width: this.$width,
	      border: 1,
	      margin: this.getParentView()._padding[dir === "x" ? "left" : "top"]
	    });
	    /*stops resizing on stick mouseup*/

	    this._resizeStick.attachEvent("onResizeEnd", bind(this._rsEnd, this));
	    /*needed to stop stick moving when the limit for dimension is reached*/


	    this._resizeStick.attachEvent("onResize", bind(this._rsResizeHandler, this));

	    addCss(document.body, "webix_noselect", 1);
	  },
	  _getResizeDir: function () {
	    return this.getParentView()._vertical_orientation ? "y" : "x";
	  },
	  _rsResizeHandler: function () {
	    var cells, config, cDiff, diff, dir, i, limits, limitSizes, sizes, totalSize;

	    if (this._rs_progress) {
	      cells = this._getResizerCells();
	      dir = this._rs_progress[0];
	      /*vector distance between resizer and stick*/

	      diff = this._resizeStick._last_result - this._rs_progress[2];
	      /*new sizes for the resized cells, taking into account the stick position*/

	      sizes = this._rsGetDiffCellSizes(cells, dir, diff);
	      /*sum of cells dimensions*/

	      totalSize = cells[0]["$" + this._resizer_dim] + cells[1]["$" + this._resizer_dim];
	      /*max and min limits if they're set*/

	      limits = dir == "y" ? ["minHeight", "maxHeight"] : ["minWidth", "maxWidth"];

	      for (i = 0; i < 2; i++) {
	        config = cells[i]._settings;
	        cDiff = i ? -diff : diff;
	        /*if cDiff is positive, the size of i cell is increased*/

	        /*if size is bigger than max limit or size is smaller than min limit*/

	        var min = config[limits[0]];
	        var max = config[limits[1]];

	        if (cDiff > 0 && max && max <= sizes[i] || cDiff < 0 && (min || 3) >= sizes[i]) {
	          this._rsLimit[i] = cDiff > 0 ? max : min || 3;
	          /*new sizes, taking into account max and min limits*/

	          limitSizes = this._rsGetLimitCellSizes(cells, dir);
	          /*stick position*/

	          this._resizeStick._dragobj.style[dir == "y" ? "top" : "left"] = this._rs_progress[3] + limitSizes[0] + "px";
	          return;
	        } else if (sizes[i] < 3) {
	          /*cells size can not be less than 1*/
	          this._resizeStick._dragobj.style[dir == "y" ? "top" : "left"] = this._rs_progress[3] + i * totalSize + 1 + "px";
	        } else {
	          this._rsLimit[i] = null;
	        }
	      }
	    }
	  },
	  _getResizerCells: function () {
	    var cells, i, res;
	    cells = this.getParentView()._cells;

	    for (i = 0; i < cells.length; i++) {
	      if (cells[i] == this) {
	        res = [this._getRsCell(cells, i, 1, -1), this._getRsCell(cells, i, 1, 1)];
	        if (!res[0] || !res[1]) res = null;
	        return res;
	      }
	    }
	  },
	  _getRsCell: function (cells, i, step, dir) {
	    var cell = cells[i + dir * step];
	    if (cell && cell._settings.hidden) return this._getRsCell(cells, i, step + 1, dir);else if (cell && cell._settings.$noresize) return null;else return cell;
	  },
	  _rsEnd: function (result) {
	    if (typeof result == "undefined") return;
	    var cells, dir, diff, size;

	    var vertical = this.getParentView()._vertical_orientation;

	    this._resizerStick = null;

	    if (this._rs_progress) {
	      dir = this._rs_progress[0];
	      diff = result - this._rs_progress[2];
	      cells = this._getResizerCells();

	      if (cells[0] && cells[1]) {
	        /*new cell sizes*/
	        size = this._rsGetCellSizes(cells, dir, diff);

	        for (var i = 0; i < 2; i++) {
	          //cell has not fixed size, of fully fixed layout
	          var cell_size = cells[i].$getSize(0, 0);

	          if (vertical ? cell_size[2] == cell_size[3] : Math.abs(cell_size[1] - cell_size[0]) < 3) {
	            /*set fixed sizes for both cells*/
	            cells[i]._settings[this._resizer_dim] = size[i];
	            if (cells[i]._bubble_size) cells[i]._bubble_size(this._resizer_dim, size[i], vertical);
	          } else {
	            var actualSize = cells[i].$view[vertical ? "offsetHeight" : "offsetWidth"]; //cells[i]["$"+this._resizer_dim];

	            cells[i]._settings.gravity = size[i] / actualSize * cells[i]._settings.gravity;
	          }
	        }

	        cells[0].resize();

	        for (var _i = 0; _i < 2; _i++) {
	          if (cells[_i].callEvent) cells[_i].callEvent("onViewResize", []);

	          cells[_i].$view.removeAttribute("aria-dropeffect");
	        }

	        callEvent("onLayoutResize", [cells]);
	      }

	      this._rs_progress = false;
	    }

	    this._rs_progress = false;
	    this._rs_started = false;
	    this._rsLimit = null;
	    removeCss(document.body, "webix_noselect");

	    this._viewobj.setAttribute("aria-grabbed", "false");

	    this._viewobj.removeAttribute("aria-dropeffect");
	  },
	  _rsGetLimitCellSizes: function (cells) {
	    var size1, size2, totalSize;
	    totalSize = cells[0]["$" + this._resizer_dim] + cells[1]["$" + this._resizer_dim];

	    if (this._rsLimit[0]) {
	      size1 = this._rsLimit[0];
	      size2 = totalSize - size1;
	    } else if (this._rsLimit[1]) {
	      size2 = this._rsLimit[1];
	      size1 = totalSize - size2;
	    }

	    return [size1, size2];
	  },
	  _rsGetDiffCellSizes: function (cells, dir, diff) {
	    var sizes = [];
	    var styleDim = this._resizer_dim == "height" ? "offsetHeight" : "offsetWidth";

	    for (var i = 0; i < 2; i++) {
	      sizes[i] = cells[i].$view[styleDim] + (i ? -1 : 1) * diff;
	    }

	    return sizes;
	  },
	  _rsGetCellSizes: function (cells, dir, diff) {
	    var i, sizes, totalSize;
	    /*if max or min dimentsions are set*/

	    if (this._rsLimit[0] || this._rsLimit[1]) {
	      sizes = this._rsGetLimitCellSizes(cells, dir);
	    } else {
	      sizes = this._rsGetDiffCellSizes(cells, dir, diff);

	      for (i = 0; i < 2; i++) {
	        /*if stick moving is stopped outsize cells borders*/
	        if (sizes[i] < 0) {
	          totalSize = sizes[0] + sizes[1];
	          sizes[i] = 1;
	          sizes[1 - i] = totalSize - 1;
	        }
	      }
	    }

	    return sizes;
	  }
	};
	var view$e = exports.protoUI(api$e, MouseEvents, Destruction, base.view);

	var api$f = {
	  name: "align",
	  defaults: {
	    borderless: true,
	    left: 0,
	    top: 0,
	    right: 0,
	    bottom: 0
	  },
	  $init: function () {
	    this._viewobj.className += " webix_view_align";
	  },
	  getChildViews: function () {
	    return [this._body_cell];
	  },
	  body_setter: function (value) {
	    value._inner = {
	      top: false,
	      left: false,
	      right: false,
	      bottom: false
	    };
	    state._parent_cell = this;
	    this._body_cell = ui._view(value);

	    this._viewobj.appendChild(this._body_cell._viewobj);

	    return value;
	  },
	  align_setter: function (value) {
	    if (typeof value === "string") value = value.split(",");
	    this._x_align = this._y_align = this._p_align = "";

	    for (var i = 0; i < value.length; i++) {
	      var c = value[i];
	      if (c === "center" || c === "left" || c === "right") this._x_align = c;
	      if (c === "top" || c === "bottom" || c === "middle") this._y_align = c;
	      if (c === "absolute") this._x_align = this._y_align = this._p_align = "precise";
	    }

	    return value;
	  },
	  getBody: function () {
	    return this._body_cell;
	  },
	  $setSize: function (x, y) {
	    base.api.$setSize.call(this, x, y);
	    var dx, dy;

	    if (this._p_align) {
	      dx = x - this._settings.left - this._settings.right;
	      dy = y - this._settings.top - this._settings.bottom;
	    } else {
	      dx = this._desired_size[0] || x;
	      dy = this._desired_size[2] || y;
	    }

	    this._body_cell.$setSize(dx, dy);

	    var box = this._body_cell._viewobj;
	    if (this._x_align == "center") box.style.marginLeft = Math.ceil((x - dx) / 2) + "px";else if (this._x_align == "right") box.style.marginLeft = x - dx + "px";else box.style.marginLeft = (this._p_align ? this._settings.left : 0) + "px";
	    if (this._y_align == "middle") box.style.marginTop = Math.ceil((y - dy) / 2) + "px";else if (this._y_align == "bottom") box.style.marginTop = y - dy + "px";else box.style.marginTop = (this._p_align ? this._settings.top : 0) + "px";
	  },
	  $getSize: function (dx, dy) {
	    var size = this._desired_size = this._body_cell.$getSize(0, 0);

	    var self_size = baseview.api.$getSize.call(this, 0, 0);

	    if (this._p_align) {
	      dx += this._settings.left + this._settings.right;
	      dy += this._settings.top + this._settings.bottom;
	    }

	    if (!this._x_align || this._p_align) {
	      self_size[0] = size[0] + dx;
	      self_size[1] = size[1] + dx;
	    } else {
	      self_size[0] = (self_size[0] || size[0]) + dy;
	      self_size[1] += dx;
	    }

	    if (!this._y_align || this._p_align) {
	      self_size[2] = size[2] + dy;
	      self_size[3] = size[3] + dy;
	    } else {
	      self_size[2] = (self_size[2] || size[2]) + dy;
	      self_size[3] += dy;
	    }

	    return self_size;
	  }
	};
	var view$f = exports.protoUI(api$f, base.view);

	var api$g = {
	  name: "multiview",
	  defaults: {
	    animate: {}
	  },
	  setValue: function (val) {
	    $$(val).show();
	  },
	  getValue: function () {
	    return this.getActiveId();
	  },
	  $init: function () {
	    this._active_cell = 0;
	    this._vertical_orientation = 1;
	    this._viewobj.style.position = "relative";
	    this._viewobj.className += " webix_multiview";
	    this._back_queue = [];
	  },
	  _ask_render: function (cell_id, view_id) {
	    var cell = $$(cell_id);

	    if (!cell._render_hash) {
	      cell._render_queue = [];
	      cell._render_hash = {};
	    }

	    if (!cell._render_hash[view_id]) {
	      cell._render_hash[view_id] = true;

	      cell._render_queue.push(view_id);
	    }
	  },
	  _render_activation: function (cell_id) {
	    var cell = $$(cell_id);
	    if (this._settings.keepViews) cell._viewobj.style.display = "";
	    /*back array*/

	    if (this._back_queue[this._back_queue.length - 2] != cell_id) {
	      if (this._back_queue.length == 10) this._back_queue.splice(0, 1);

	      this._back_queue.push(cell_id);
	    } else this._back_queue.splice(this._back_queue.length - 1, 1);

	    if (cell._render_hash) {
	      for (var i = 0; i < cell._render_queue.length; i++) {
	        var subcell = $$(cell._render_queue[i]); //cell can be already destroyed

	        if (subcell) subcell.render();
	      }

	      cell._render_queue = [];
	      cell._render_hash = {};
	    }
	  },
	  addView: function () {
	    var id = baselayout.api.addView.apply(this, arguments);
	    if (this._settings.keepViews) $$(id)._viewobj.style.display = "none";else remove($$(id)._viewobj);
	    return id;
	  },
	  _beforeRemoveView: function (index$$1) {
	    //removing current view
	    if (index$$1 == this._active_cell) {
	      var next = Math.max(index$$1 - 1, 0);

	      if (this._cells[next]) {
	        this._in_animation = false;

	        this._show(this._cells[next], false);
	      }
	    }

	    if (index$$1 < this._active_cell) this._active_cell--;
	  },
	  //necessary, as we want to ignore hide calls for elements in multiview
	  _hide: function () {},
	  _parse_cells: function (collection) {
	    collection = collection || this._collection;

	    for (var i = 0; i < collection.length; i++) {
	      collection[i]._inner = this._settings.borderless ? {
	        top: 1,
	        left: 1,
	        right: 1,
	        bottom: 1
	      } : this._settings._inner || {};
	    }

	    baselayout.api._parse_cells.call(this, collection);

	    for (var _i = 1; _i < this._cells.length; _i++) {
	      if (this._settings.keepViews) this._cells[_i]._viewobj.style.display = "none";else remove(this._cells[_i]._viewobj);
	    }

	    for (var _i2 = 0; _i2 < collection.length; _i2++) {
	      var cell = this._cells[_i2];
	      if (cell._cells && !cell._render_borders) continue;
	      var _inner = cell._settings._inner;
	      if (_inner.top) cell._viewobj.style.borderTopWidth = "0px";
	      if (_inner.left) cell._viewobj.style.borderLeftWidth = "0px";
	      if (_inner.right) cell._viewobj.style.borderRightWidth = "0px";
	      if (_inner.bottom) cell._viewobj.style.borderBottomWidth = "0px";

	      cell._viewobj.setAttribute("role", "tabpanel");
	    }

	    this._render_activation(this.getActiveId());
	  },
	  cells_setter: function (value) {
	    assert(value && value.length, "Multiview must have at least one view in 'cells'");
	    this._collection = value;
	  },
	  _getDirection: function (next, active) {
	    var dir = (this._settings.animate || {}).direction;
	    var vx = dir == "top" || dir == "bottom";
	    return next < active ? vx ? "bottom" : "right" : vx ? "top" : "left";
	  },
	  _show: function (obj, animation_options) {
	    var parent = this.getParentView();
	    if (parent && parent.getTabbar) parent.getTabbar().setValue(obj._settings.$id || obj._settings.id);
	    if (this._in_animation) return delay(this._show, this, [obj, animation_options], 100);

	    var _next_cell = -1;

	    for (var i = 0; i < this._cells.length; i++) {
	      if (this._cells[i] == obj) {
	        _next_cell = i;
	        break;
	      }
	    }

	    if (_next_cell < 0 || _next_cell == this._active_cell) return;
	    var prev = this._cells[this._active_cell];
	    var next = this._cells[_next_cell];
	    prev.$getSize(0, 0); //need to be moved in animate

	    if ((animation_options || typeof animation_options == "undefined") && animate.isSupported() && this._settings.animate) {
	      var aniset = exports.extend({}, this._settings.animate);
	      if (this._settings.keepViews) aniset.keepViews = true;
	      aniset.direction = this._getDirection(_next_cell, this._active_cell);
	      aniset = Settings._mergeSettings(animation_options || {}, aniset);
	      var line = animate.formLine(next._viewobj, prev._viewobj, aniset);
	      next.$getSize(0, 0);
	      next.$setSize(this._content_width, this._content_height);
	      var callback_original = aniset.callback;

	      aniset.callback = function () {
	        animate.breakLine(line, this._settings.keepViews);
	        this._in_animation = false;
	        if (callback_original) callback_original.call(this);
	        callback_original = aniset.master = aniset.callback = null;
	        this.resize();
	      };

	      aniset.master = this;
	      this._active_cell = _next_cell;

	      this._render_activation(this.getActiveId());

	      animate(line, aniset);
	      this._in_animation = true;
	    } else {
	      // browsers which don't support transform and transition, or animate:false in config
	      if (this._settings.keepViews) {
	        prev._viewobj.style.display = "none";
	      } else {
	        remove(prev._viewobj);

	        this._viewobj.appendChild(this._cells[i]._viewobj);
	      }

	      this._active_cell = _next_cell;
	      this.resizeChildren();

	      this._render_activation(this.getActiveId());
	    }

	    if (next.callEvent) {
	      next.callEvent("onViewShow", []);
	      each(next, this._signal_hidden_cells);
	    }

	    this.callEvent("onViewChange", [prev._settings.id, next._settings.id]);
	  },
	  $getSize: function (dx, dy) {
	    if (!this._cells.length) return baseview.api.$getSize.call(this, 0, 0);
	    debug_size_box_start(this, true);

	    var size = this._cells[this._active_cell].$getSize(0, 0);

	    if (this._settings.fitBiggest) {
	      for (var i = 0; i < this._cells.length; i++) {
	        if (i != this._active_cell) {
	          var other = this._cells[i].$getSize(0, 0);

	          for (var j = 0; j < 4; j++) {
	            size[j] = Math.max(size[j], other[j]);
	          }
	        }
	      }
	    } //get layout sizes


	    var self_size = baseview.api.$getSize.call(this, 0, 0); //use child settings if layout's one was not defined

	    if (self_size[1] >= 100000) self_size[1] = 0;
	    if (self_size[3] >= 100000) self_size[3] = 0;
	    self_size[0] = (self_size[0] || size[0]) + dx;
	    self_size[1] = (self_size[1] || size[1]) + dx;
	    self_size[2] = (self_size[2] || size[2]) + dy;
	    self_size[3] = (self_size[3] || size[3]) + dy;
	    debug_size_box_end(this, self_size);
	    return self_size;
	  },
	  $setSize: function (x, y) {
	    if (!this._cells.length) return;
	    this._layout_sizes = [x, y];
	    baseview.api.$setSize.call(this, x, y);

	    this._cells[this._active_cell].$setSize(x, y);
	  },
	  isVisible: function (base_id, cell_id) {
	    if (cell_id && cell_id != this.getActiveId()) {
	      if (base_id) this._ask_render(cell_id, base_id);
	      return false;
	    }

	    return base.api.isVisible.call(this, base_id, this._settings.id);
	  },
	  getActiveId: function () {
	    return this._cells.length ? this._cells[this._active_cell]._settings.id : null;
	  },
	  back: function (step) {
	    step = step || 1;

	    if (this.callEvent("onBeforeBack", [this.getActiveId(), step])) {
	      if (this._back_queue.length > step) {
	        var viewId = this._back_queue[this._back_queue.length - step - 1];
	        $$(viewId).show();
	        return viewId;
	      }

	      return null;
	    }

	    return null;
	  }
	};
	var view$g = exports.protoUI(api$g, baselayout.view);

	var api$h = {
	  name: "tabview",
	  setValue: function (val) {
	    this._cells[0].setValue(val);
	  },
	  getValue: function () {
	    return this._cells[0].getValue();
	  },
	  getTabbar: function () {
	    return this._cells[0];
	  },
	  getMultiview: function () {
	    return this._cells[1];
	  },
	  addView: function (obj) {
	    var nid = this.getMultiview().addView(obj.body);
	    obj.id = nid;
	    obj.value = obj.header;
	    delete obj.body;
	    delete obj.header;
	    var t = this.getTabbar();
	    t.addOption(obj);
	    return nid;
	  },
	  removeView: function (id) {
	    var t = this.getTabbar();
	    t.removeOption(id);
	    t.refresh();
	  },
	  $init: function (config) {
	    this.$ready.push(this._init_tabview_handlers);
	    var cells = config.cells;
	    var tabs = [];
	    assert(cells && cells.length, "tabview must have cells collection");

	    for (var i = cells.length - 1; i >= 0; i--) {
	      var view = cells[i].body || cells[i];
	      if (!view.id) view.id = "view" + uid();
	      tabs[i] = {
	        value: cells[i].header,
	        id: view.id,
	        close: cells[i].close,
	        width: cells[i].width,
	        hidden: !!cells[i].hidden
	      };
	      cells[i] = view;
	    }

	    var tabbar = {
	      view: "tabbar",
	      multiview: true
	    };
	    var mview = {
	      view: "multiview",
	      cells: cells,
	      animate: !!config.animate
	    };
	    if (config.value) tabbar.value = config.value;
	    if (config.tabbar) exports.extend(tabbar, config.tabbar, true);
	    if (config.multiview) exports.extend(mview, config.multiview, true);
	    tabbar.options = tabbar.options || tabs;
	    config.rows = [tabbar, mview];
	    delete config.cells;
	    delete config.tabs;
	  },
	  _init_tabview_handlers: function () {
	    this.getTabbar().attachEvent("onOptionRemove", function (id) {
	      var view = $$(id);

	      if (view) {
	        var parent = view.getParentView();
	        if (parent) parent.removeView(view);
	      }
	    });
	  }
	};
	var view$h = exports.protoUI(api$h, layout.view);

	var api$i = {
	  name: "carousel",
	  defaults: {
	    scrollSpeed: "300ms",
	    type: "clean",
	    navigation: {},
	    animate: true
	  },
	  $init: function () {
	    this._viewobj.className += " webix_carousel";
	    this._layout = null;
	    this._dataobj = null;
	    this._active_cell = 0;
	    this.$ready.unshift(this._initLayout);
	    this.$ready.push(this._after_init_call);
	  },
	  addView: function (view, index) {
	    var t = this._layout.addView(view, index);

	    this._fix_after_view_add();

	    return t;
	  },
	  removeView: function (id) {
	    this._layout.removeView(id);

	    this._fix_after_view_add();
	  },
	  _replace: function (new_view, target_id) {
	    this._layout._replace(new_view, target_id);

	    this._fix_after_view_add();
	  },
	  _fix_after_view_add: function () {
	    this._cells = this._layout._cells;

	    this._renderPanel();

	    this.setActiveIndex(Math.min(this._active_cell, this._cells.length - 1));
	  },
	  _initLayout: function () {
	    if (this._layout && this._layout.destructor) this._layout.destructor();
	    var layout = "";

	    if (this.config.cols) {
	      layout = "cols";
	      this._vertical_orientation = 0;
	    } else {
	      layout = "rows";
	      this._vertical_orientation = 1;
	    }

	    var config = {
	      borderless: true,
	      type: "clean"
	    };
	    config[layout] = copy(this._settings[layout]);
	    var layoutProp = ["type", "margin", "marginX", "marginY", "padding", "paddingX", "paddingY"];
	    var layoutConfig = {};

	    for (var i = 0; i < layoutProp.length; i++) {
	      if (this._settings[layoutProp[i]]) {
	        layoutConfig[layoutProp[i]] = this._settings[layoutProp[i]];
	      }
	    }

	    exports.extend(config, layoutConfig, true);
	    state._parent_cell = this;
	    this._layout = ui._view(config);

	    this._viewobj.appendChild(this._layout._viewobj);

	    this._cells = this._layout._cells;
	    this._layout._show = bind(api$i._show, this);
	    this._layout.adjustScroll = bind(api$i.adjustScroll, this);
	    attachEvent("onReconstruct", bind(function (view) {
	      if (view == this._layout) this._setScroll();
	    }, this));
	    this._contentobj = this._viewobj.firstChild;
	  },
	  _onKeyPress: function (code, e) {
	    if (this._settings.navigation.items && e.target.getAttribute("role") === "tab") this._moveActive(code, e);

	    baseview.api._onKeyPress.call(this, code, e);
	  },
	  getChildViews: function () {
	    return [this._layout];
	  },
	  getLayout: function () {
	    return this._layout;
	  },
	  _after_init_call: function () {
	    this._contentobj.setAttribute("touch_scroll", this._vertical_orientation ? "y" : "x");

	    this._layout.attachEvent("onAfterScroll", bind(function () {
	      this.callEvent("onShow", [this.getActiveId()]);
	    }, this));

	    each(this._layout, function (view) {
	      view._viewobj.setAttribute("role", "tabpanel");
	    });
	  },
	  adjustScroll: function (matrix) {
	    var size = this._vertical_orientation ? this._content_height : this._content_width;
	    var correction;

	    if (this._vertical_orientation) {
	      correction = Math.round(matrix.f / size);
	      matrix.f = correction * size;
	    } else {
	      correction = Math.round(matrix.e / size);
	      matrix.e = correction * size;
	    }

	    this._active_cell = -correction;
	    if (this._settings.navigation) this._renderNavItems();
	    return true;
	  },
	  _show: function (obj) {
	    var i, layout, _nextCell, _size, x, y;

	    _nextCell = -1;
	    layout = this._layout;

	    for (i = 0; i < layout._cells.length; i++) {
	      if (layout._cells[i] == obj) {
	        _nextCell = i;
	        break;
	      }
	    }

	    if (_nextCell < 0 || _nextCell == this._active_cell) return;
	    this._active_cell = _nextCell;
	    _size = layout._vertical_orientation ? this._content_height : this._content_width;
	    x = -(layout._vertical_orientation ? 0 : _nextCell * _size);
	    y = -(layout._vertical_orientation ? _nextCell * _size : 0);
	    this.scrollTo(x, y);
	    this.callEvent("onShow", [layout._cells[this._active_cell]._settings.id]);
	    if (this._settings.navigation) this._renderPanel();
	  },
	  scrollTo: function (x, y) {
	    if (Touch && animate.isSupported() && this._settings.animate) Touch._set_matrix(this._contentobj, x, y, this._settings.scrollSpeed || "100ms");else {
	      this._contentobj.style.marginLeft = x + "px";
	      this._contentobj.style.marginTop = y + "px";
	    }
	  },
	  navigation_setter: function (config) {
	    this._mergeSettings(config, {
	      type: "corner",
	      buttons: true,
	      items: true
	    });

	    return config;
	  },
	  showNext: function () {
	    if (this._active_cell < this._layout._cells.length - 1) this.setActiveIndex(this._active_cell + 1);
	  },
	  showPrev: function () {
	    if (this._active_cell > 0) this.setActiveIndex(this._active_cell - 1);
	  },
	  setActiveIndex: function (value) {
	    assert(value < this._layout._cells.length, "Not existing index in collection");
	    var id = this._layout._cells[value]._settings.id;
	    $$(id).show();
	  },
	  getActiveIndex: function () {
	    return this._active_cell;
	  },
	  $getSize: function (dx, dy) {
	    var layoutSizes = this._layout.$getSize(0, 0);

	    var selfSizes = base.api.$getSize.call(this, dx, dy);

	    if (this._layout._vertical_orientation) {
	      selfSizes[0] = Math.max(selfSizes[0], layoutSizes[0]);
	      selfSizes[1] = Math.min(selfSizes[1], layoutSizes[1]);
	    } else {
	      selfSizes[2] = Math.max(selfSizes[2], layoutSizes[2]);
	      selfSizes[3] = Math.min(selfSizes[3], layoutSizes[3]);
	    }

	    return selfSizes;
	  },
	  $setSize: function (x, y) {
	    var layout = this._layout;
	    var c = layout._cells.length;
	    var changed = base.api.$setSize.call(this, x, y);
	    var yc = this._content_height * (layout._vertical_orientation ? c : 1);
	    var xc = this._content_width * (layout._vertical_orientation ? 1 : c);

	    if (changed) {
	      this._contentobj.style.height = yc + "px";
	      this._contentobj.style.width = xc + "px";
	      layout.$setSize(xc, yc);

	      this._setScroll();
	    } else layout.$setSize(xc, yc);
	  },
	  _setScroll: function () {
	    var layout = this._layout;
	    var activeCell = this._active_cell || 0;
	    var size = layout._vertical_orientation ? this._content_height : this._content_width;
	    var x = -(layout._vertical_orientation ? 0 : activeCell * size);
	    var y = -(layout._vertical_orientation ? activeCell * size : 0);
	    this.scrollTo(x, y);
	    if (this._settings.navigation) this._renderPanel();
	  },
	  getActiveId: function () {
	    var cell = this._layout._cells[this._active_cell];
	    return cell ? cell._settings.id : null;
	  },
	  setActive: function (value) {
	    $$(value).show();
	  }
	};
	var view$i = exports.protoUI(api$i, EventSystem, NavigationButtons, base.view);

	var api$j = {
	  name: "proxy",
	  body_setter: function (value) {
	    state._parent_cell = this;
	    this._body_cell = ui._view(value);

	    this._viewobj.appendChild(this._body_cell._viewobj);

	    return value;
	  },
	  getChildViews: function () {
	    return [this._body_cell];
	  },
	  $setSize: function (x, y) {
	    base.api.$setSize.call(this, x, y);

	    this._body_cell.$setSize(this.$width, this.$height);
	  },
	  $getSize: function (dx, dy) {
	    var selfSize = base.api.$getSize.call(this, dx, dy);

	    var size = this._body_cell.$getSize(dx, dy);

	    size[0] = Math.max(selfSize[0], size[0]);
	    size[1] = Math.min(selfSize[1], size[1]);
	    size[2] = Math.max(selfSize[2], size[2]);
	    size[3] = Math.min(selfSize[3], size[3]);
	    size[4] = Math.max(selfSize[4], size[4]);
	    return size;
	  },
	  _replace: function (n) {
	    this._body_cell.destructor();

	    this._body_cell = n;

	    this._viewobj.appendChild(n._viewobj);
	  }
	};
	var view$j = exports.protoUI(api$j, base.view);

	exports.protoUI({
	  name: "portlet",
	  defaults: {
	    template: "GPL version doesn't support portlet <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "dashboard",
	  defaults: {
	    template: "GPL version doesn't support dashboard <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "panel",
	  defaults: {
	    template: "GPL version doesn't support panel <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "abslayout",
	  defaults: {
	    template: "GPL version doesn't support abslayout <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "gridlayout",
	  defaults: {
	    template: "GPL version doesn't support gridlayout <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$k = {
	  $init: function () {
	    exports.extend(this, FlexLayout, true);
	  },
	  name: "flexlayout"
	};
	var view$k = exports.protoUI(api$k, layout.view);

	exports.protoUI({
	  name: "flexdatalayout",
	  defaults: {
	    template: "GPL version doesn't support flexdatalayout <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$l = {
	  name: "popup",
	  $init: function () {
	    this._settings.head = false;
	    this.$view.className += " webix_popup";
	    attachEvent("onClick", bind(this._hide, this));
	    this.attachEvent("onHide", this._hide_point);
	  },
	  $skin: function () {
	    this.defaults.headHeight = $active.barHeight;
	    this.defaults.padding = $active.popupPadding;
	    this.defaults.point = !$active.popupNoPoint;
	    this.defaults.borderless = $active.borderlessPopup;
	  },
	  close: function () {
	    remove(this._point_element);
	    window$1.api.close.call(this);
	  },
	  $getSize: function (x, y) {
	    return window$1.api.$getSize.call(this, x + this._settings.padding * 2, y + this._settings.padding * 2);
	  },
	  $setSize: function (x, y) {
	    base.api.$setSize.call(this, x, y);
	    x = this._content_width - this._settings.padding * 2;
	    y = this._content_height - this._settings.padding * 2;
	    this._contentobj.style.padding = this._settings.padding + "px";
	    this._headobj.style.display = "none";

	    this._body_cell.$setSize(x, y);
	  },
	  //redefine to preserve inner borders
	  //_inner_body_set:function(){}, //same as win?
	  _inner_body_set: function (value) {
	    if (typeof value.borderless == "undefined") value.borderless = false;
	  },
	  head_setter: function () {},
	  _set_point: function (mode, left, top, fixed) {
	    this._hide_point();

	    document.body.appendChild(this._point_element = create("DIV", {
	      "class": "webix_point_" + mode
	    }, ""));
	    this._point_element.style.zIndex = zIndex();
	    this._point_element.style.position = fixed ? "fixed" : "absolute";
	    this._point_element.style.top = top + "px";
	    this._point_element.style.left = left + "px";
	  },
	  _hide_point: function () {
	    this._point_element = remove(this._point_element);
	  }
	};
	var view$l = exports.protoUI(api$l, window$1.view);
	var popup = {
	  api: api$l,
	  view: view$l
	};

	var api$m = {
	  name: "toolbar",
	  defaults: {
	    type: "toolbar"
	  },
	  _render_borders: true,
	  _form_classname: "webix_toolbar",
	  _form_vertical: false,
	  $init: function (config) {
	    if (!config.borderless) {
	      this._contentobj.style.borderWidth = "1px";
	      this._settings._inner = {
	        top: false,
	        left: false,
	        right: false,
	        bottom: false
	      };
	    }

	    this._contentobj.className += " " + this._form_classname;

	    this._viewobj.setAttribute("role", "toolbar");
	  },
	  _recollect_elements: function () {
	    var form = this;
	    form.elements = {};
	    each(this, function (view) {
	      if (view._settings.name && view.getValue && view.setValue) {
	        form.elements[view._settings.name] = view;
	        if (view.mapEvent) view.mapEvent({
	          onbeforetabclick: form,
	          onaftertabclick: form,
	          onitemclick: form,
	          onchange: form
	        });
	      }

	      if (view.setValues) return false;
	    });
	    var old = this._values;
	    this.setDirty(false);

	    if (old) {
	      //restore dirty state after form reconstructing
	      var now = this._values;

	      for (var key in form.elements) {
	        if (old[key] && now[key] != old[key]) {
	          now[key] = old[key];
	          this.setDirty(true);
	        }
	      }
	    }
	  },
	  _parse_cells_ext_end: function () {
	    this._recollect_elements();
	  },
	  _parse_cells_ext: function (collection) {
	    var config = this._settings;

	    if (config.elements && !collection) {
	      this._collection = collection = config.elements;
	      this._vertical_orientation = this._form_vertical;
	      delete config.elements;
	    }

	    if (this._settings.elementsConfig) this._rec_apply_settings(this._collection, config.elementsConfig);
	    return collection;
	  },
	  _rec_apply_settings: function (col, settings) {
	    for (var i = 0; i < col.length; i++) {
	      var element = col[i];
	      exports.extend(element, settings);
	      var nextsettings = settings;
	      if (element.elementsConfig) nextsettings = exports.extend(exports.extend({}, element.elementsConfig), settings);
	      var sub;
	      if (element.body) sub = [element.body];else sub = element.rows || element.cols || element.cells || element.body;
	      if (sub) this._rec_apply_settings(sub, nextsettings);
	    }
	  },
	  $getSize: function (dx, dy) {
	    var sizes = layout.api.$getSize.call(this, dx, dy);
	    var parent = this.getParentView();
	    var index = this._vertical_orientation ? 3 : 1;
	    if (parent && this._vertical_orientation != parent._vertical_orientation) sizes[index] += 100000;
	    debug_size_box(this, sizes, true);
	    return sizes;
	  },
	  render: function () {},
	  refresh: function () {
	    this.render();
	  }
	};
	var view$m = exports.protoUI(api$m, Scrollable, AtomDataLoader, Values, layout.view, ValidateData);
	var toolbar = {
	  api: api$m,
	  view: view$m
	};

	var api$n = {
	  name: "form",
	  defaults: {
	    type: "form",
	    autoheight: true
	  },
	  _default_height: -1,
	  _form_classname: "webix_form",
	  _form_vertical: true,
	  $init: function () {
	    this._viewobj.setAttribute("role", "form");
	  },
	  $getSize: function (dx, dy) {
	    if (this._scroll_y && !this._settings.width) dx += env.scrollSize;
	    var sizes = layout.api.$getSize.call(this, dx, dy);

	    if (this._settings.scroll || !this._settings.autoheight) {
	      sizes[2] = this._settings.height || this._settings.minHeight || 0;
	      sizes[3] += 100000;
	    }

	    return sizes;
	  }
	};
	var view$n = exports.protoUI(api$n, toolbar.view);

	var api$o = {
	  name: "fieldset",
	  defaults: {
	    borderless: true,
	    $cssName: "webix_fieldset",
	    paddingX: 18,
	    paddingY: 30
	  },
	  $init: function (obj) {
	    obj.body = obj.body || {};
	    var css = this.defaults.$cssName;
	    this._viewobj.className += " " + css;
	    this._viewobj.innerHTML = "<fieldset><legend class='" + css + "_label" + (obj.required ? " webix_required" : "") + "'></legend><div class='" + css + "_body'></div></fieldset>";
	  },
	  label_setter: function (value) {
	    this._viewobj.firstChild.childNodes[0].innerHTML = value;
	    return value;
	  },
	  getChildViews: function () {
	    return [this._body_view];
	  },
	  body_setter: function (config) {
	    state._parent_cell = this;
	    this._body_view = ui(config, this._viewobj.firstChild.childNodes[1]);
	    return config;
	  },
	  getBody: function () {
	    return this._body_view;
	  },
	  resizeChildren: function () {
	    if (!this._body_view) return;
	    var x = this.$width - this._settings.paddingX;
	    var y = this.$height - this._settings.paddingY;

	    var sizes = this._body_view.$getSize(0, 0); //minWidth


	    if (sizes[0] > x) x = sizes[0]; //minHeight

	    if (sizes[2] > y) y = sizes[2];

	    this._body_view.$setSize(x, y);

	    this.resize();
	  },
	  $getSize: function (x, y) {
	    debug_size_box_start(this, true);
	    x += this._settings.paddingX;
	    y += this._settings.paddingY;

	    var t = this._body_view.$getSize(x, y);

	    var s = this._last_body_size = base.api.$getSize.call(this, x, y); //inner content minWidth > outer

	    if (s[0] < t[0]) s[0] = t[0];
	    if (s[2] < t[2]) s[2] = t[2]; //inner content maxWidth < outer

	    if (s[1] > t[1]) s[1] = t[1];
	    if (s[3] > t[3]) s[3] = t[3]; //make max size not less than min size

	    if (s[1] < s[0]) s[1] = s[0];
	    if (s[3] < s[2]) s[3] = s[2];
	    debug_size_box_end(this, s);
	    return s;
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      x = Math.min(this._last_body_size[1], x);
	      y = Math.min(this._last_body_size[3], y);

	      this._body_view.$setSize(x - this._settings.paddingX, y - this._settings.paddingY);
	    }
	  }
	};
	var view$o = exports.protoUI(api$o, base.view);
	var fieldset = {
	  api: api$o,
	  view: view$o
	};

	var api$p = {
	  name: "forminput",
	  defaults: {
	    $cssName: "webix_forminput",
	    labelWidth: 80,
	    labelAlign: "left",
	    // remove fieldset sizing
	    paddingY: 0,
	    paddingX: 0
	  },
	  setValue: function (value) {
	    if (this._body_view.setValue) this._body_view.setValue(value);else if (this._body_view.setValues) this._body_view.setValues(value);
	  },
	  focus: function () {
	    if (this._body_view.focus) {
	      return this._body_view.focus();
	    }

	    return false;
	  },
	  getValue: function () {
	    if (this._body_view.getValue) return this._body_view.getValue();else if (this._body_view.getValues) return this._body_view.getValues();
	  },
	  getBody: function () {
	    return this._body_view;
	  },
	  $skin: function () {
	    this._inputPadding = $active.inputPadding;
	    this._inputSpacing = $active.inputSpacing;
	    this._labelTopHeight = $active.labelTopHeight || 15;
	  },
	  $init: function (obj) {
	    this.$ready.push(function () {
	      var label = this._viewobj.firstChild.childNodes[0];

	      if (!this._settings.label || !this._settings.labelWidth) {
	        label.style.display = "none";
	        this._settings.paddingX = this._settings.paddingY = 0;
	        return;
	      }

	      if (this._settings.labelPosition == "top") {
	        label.style.lineHeight = this._labelTopHeight - this._inputPadding + "px";
	        label.className += " " + this.defaults.$cssName + "_label_top";
	      } else label.style.width = this._settings.paddingX + "px";

	      label.style.textAlign = this._settings.labelAlign;
	      if (this._settings.value) this.setValue(this._settings.value);
	    });

	    if (obj.labelPosition != "top") {
	      var lw = isUndefined(obj.labelWidth) ? this.defaults.labelWidth : obj.labelWidth;
	      obj.paddingX = lw - this._inputPadding * 2 + this._inputSpacing * 2;
	    } else obj.paddingY = this._labelTopHeight;
	  },
	  setBottomText: function (text) {
	    var config = this._settings;

	    if (typeof text != "undefined") {
	      if (config.bottomLabel == text) return;
	      config.bottomLabel = text;
	    }

	    var message = (config.invalid ? config.invalidMessage : "") || config.bottomLabel;

	    if (this._invalidMessage) {
	      remove(this._invalidMessage);
	    }

	    if (message) {
	      this.$view.style.position = "relative";
	      this._invalidMessage = create("div", {
	        "class": "webix_inp_bottom_label",
	        role: config.invalid ? "alert" : "",
	        "aria-relevant": "all",
	        style: "position:absolute; bottom:0px; padding:2px; background: white; left:" + this._settings.labelWidth + "px; "
	      }, message);

	      this._viewobj.appendChild(this._invalidMessage);
	    }
	  }
	};
	var view$p = exports.protoUI(api$p, fieldset.view);

	function _tagname(el) {
	  if (!el.tagName) return null;
	  return el.tagName.toLowerCase();
	}

	function _attribute(el, name) {
	  if (!el.getAttribute) return null;
	  var attr = el.getAttribute(name);
	  return attr ? attr.toLowerCase() : null;
	}

	function _get_html_value() {
	  var tagname = _tagname(this);

	  if (_get_value[tagname]) return _get_value[tagname](this);
	  return _get_value.other(this);
	}

	var _get_value = {
	  radio: function (el) {
	    for (var i = 0; i < el.length; i++) {
	      if (el[i].checked) return el[i].value;
	    }

	    return "";
	  },
	  input: function (el) {
	    var type = _attribute(el, "type");

	    if (type === "checkbox") return el.checked;
	    return el.value;
	  },
	  textarea: function (el) {
	    return el.value;
	  },
	  select: function (el) {
	    var index$$1 = el.selectedIndex;
	    return el.options[index$$1].value;
	  },
	  other: function (el) {
	    return el.innerHTML;
	  }
	};

	function _set_html_value(value) {
	  var tagname = _tagname(this);

	  if (_set_value[tagname]) return _set_value[tagname](this, value);
	  return _set_value.other(this, value);
	}

	var _set_value = {
	  radio: function (el, value) {
	    for (var i = 0; i < el.length; i++) {
	      el[i].checked = el[i].value == value;
	    }
	  },
	  input: function (el, value) {
	    var type = _attribute(el, "type");

	    if (type === "checkbox") el.checked = value ? true : false;else el.value = value;
	  },
	  textarea: function (el, value) {
	    el.value = value;
	  },
	  select: function (el, value) {
	    //select first option if no provided and if possible
	    el.value = value ? value : el.firstElementChild.value || value;
	  },
	  other: function (el, value) {
	    el.innerHTML = value;
	  }
	};
	var api$q = {
	  name: "htmlform",
	  $init: function (config) {
	    this.elements = {};
	    this._default_values = false;
	    if (config.content && (config.container == config.content || !config.container && config.content == document.body)) this._copy_inner_content = true;
	  },
	  content_setter: function (content) {
	    content = toNode(content);

	    if (this._copy_inner_content) {
	      while (content.childNodes.length > 1) {
	        this._viewobj.childNodes[0].appendChild(content.childNodes[0]);
	      }
	    } else {
	      this._viewobj.childNodes[0].appendChild(content);
	    }

	    this._parse_inputs();

	    return true;
	  },
	  render: function () {
	    template$1.api.render.apply(this, arguments);

	    this._parse_inputs();
	  },
	  _parse_inputs: function () {
	    var inputs = this._viewobj.querySelectorAll("[name]");

	    this.elements = {};

	    for (var i = 0; i < inputs.length; i++) {
	      var el = inputs[i];

	      var name = _attribute(el, "name");

	      if (name) {
	        var tag = _tagname(el) === "button";

	        var type = _attribute(el, "type");

	        var cant_clear = tag || type === "button" || type === "submit";

	        if (type === "radio") {
	          var stack = this.elements[name] || [];
	          stack.tagName = "radio";
	          stack.push(el);
	          el = stack;
	        }

	        this.elements[name] = el;
	        el.getValue = _get_html_value;
	        el.setValue = _set_html_value;
	        el.$allowsClear = !cant_clear;
	      }
	    }

	    return this.elements;
	  },
	  _mark_invalid: function (id, obj) {
	    this._clear_invalid(id, obj);

	    var el = this._viewobj.querySelector("[name=\"" + id + "\"]");

	    if (el) addCss(el, "invalid");
	  },
	  _clear_invalid: function (id) {
	    var el = this._viewobj.querySelector("[name=\"" + id + "\"]");

	    if (el) removeCss(el, "invalid");
	  }
	};
	var view$q = exports.protoUI(api$q, template$1.view, Values);

	var api$r = {
	  name: "property",
	  $init: function () {
	    this._contentobj.className += " webix_property";

	    this._contentobj.setAttribute("role", "listbox");

	    this._destroy_with_me = [];
	    this.attachEvent("onAfterEditStart", function (id) {
	      var node = this.getItemNode(id);
	      addCss(node, "webix_focused");
	    });
	    this.attachEvent("onAfterEditStop", function (id, editor) {
	      var node = this.getItemNode(editor.config.id);
	      removeCss(node, "webix_focused");
	    });
	  },
	  defaults: {
	    nameWidth: 100,
	    editable: true
	  },
	  on_render: {
	    checkbox: function (value) {
	      return "<input type='checkbox' class='webix_property_check' " + (value ? "checked" : "") + ">";
	    },
	    color: function (value) {
	      return "<div class=\"webix_property_col_val\"><div class='webix_property_col_ind' style=\"background-color:" + (value || "#FFFFFF") + ";\"></div><span>" + value + "</span></div>";
	    }
	  },
	  on_edit: {
	    label: false
	  },
	  _id: "webix_f_id",
	  on_click: {
	    webix_property_check: function (ev) {
	      var id = this.locate(ev);
	      this.getItem(id).value = !this.getItem(id).value;
	      this.callEvent("onCheck", [id, this.getItem(id).value]);
	      return false;
	    }
	  },
	  on_dblclick: {},
	  registerType: function (name, data) {
	    if (data.template) this.on_render[name] = data.template;
	    if (data.editor) this.on_edit[name] = data.editor;
	    if (data.click) for (var key in data.click) {
	      this.on_click[key] = data.click[key];
	    }
	  },
	  elements_setter: function (data) {
	    this._idToLine = {};

	    for (var i = 0; i < data.length; i++) {
	      var line = data[i];
	      if (line.type == "multiselect") line.optionslist = true; //line.type 	= 	line.type||"label";

	      line.id = line.id || uid();
	      line.label = line.label || "";
	      line.value = line.value || "";
	      this._idToLine[line.id] = i;
	      this.template = this._map_options(data[i]);
	    }

	    return data;
	  },
	  showItem: function (id) {
	    RenderStack.showItem.call(this, id);
	  },
	  locate: function () {
	    return locate(arguments[0], this._id);
	  },
	  getItemNode: function (id) {
	    return this._dataobj.childNodes[this._idToLine[id]];
	  },
	  getItem: function (id) {
	    return this._settings.elements[this._idToLine[id]];
	  },
	  _get_editor_type: function (id) {
	    var type = this.getItem(id).type;
	    if (type == "checkbox") return "inline-checkbox";
	    var alter_type = this.on_edit[type];
	    return alter_type === false ? false : alter_type || type;
	  },
	  _get_edit_config: function (id) {
	    return this.getItem(id);
	  },
	  _find_cell_next: function (start, check, direction) {
	    var row = this._idToLine[start.id];
	    var order = this._settings.elements;

	    if (direction) {
	      for (var i = row + 1; i < order.length; i++) {
	        if (check.call(this, order[i].id)) return order[i].id;
	      }
	    } else {
	      for (var _i = row - 1; _i >= 0; _i--) {
	        if (check.call(this, order[_i].id)) return order[_i].id;
	      }
	    }

	    return null;
	  },
	  updateItem: function (key, data) {
	    data = data || {};
	    var line = this.getItem(key);
	    if (line) exports.extend(line, data, true);
	    this.refresh();
	  },
	  _cellPosition: function (id) {
	    var html = this.getItemNode(id);
	    return {
	      left: html.offsetLeft + this._settings.nameWidth,
	      top: html.offsetTop,
	      height: html.firstChild.offsetHeight,
	      width: this._data_width,
	      parent: this._contentobj
	    };
	  },
	  _clear: function () {
	    var lines = this._settings.elements;

	    for (var i = 0; i < lines.length; i++) {
	      lines[i].value = "";
	    }
	  },
	  clear: function () {
	    this._clear();

	    this._props_dataset = {};
	    this.refresh();
	  },
	  setValues: function (data, update) {
	    if (this._settings.complexData) data = CodeParser.collapseNames(data);
	    if (!update) this._clear();

	    for (var key in data) {
	      var line = this.getItem(key);
	      if (line) line.value = data[key];
	    }

	    this._props_dataset = data;
	    this.refresh();
	  },
	  getValues: function () {
	    var data = clone(this._props_dataset || {});

	    for (var i = 0; i < this._settings.elements.length; i++) {
	      var line = this._settings.elements[i];
	      if (line.type != "label") data[line.id] = line.value;
	    }

	    if (this._settings.complexData) data = CodeParser.expandNames(data);
	    return data;
	  },
	  refresh: function () {
	    this.render();
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      this._data_width = this._content_width - this._settings.nameWidth;
	      this.render();
	    }
	  },
	  $getSize: function (dx, dy) {
	    if (this._settings.autoheight) {
	      var count = this._settings.elements.length;
	      this._settings.height = Math.max(this.type.height * count, this._settings.minHeight || 0);
	    }

	    return base.api.$getSize.call(this, dx, dy);
	  },
	  _toHTML: function () {
	    var html = [];
	    var els = this._settings.elements;
	    if (els) for (var i = 0; i < els.length; i++) {
	      var data = els[i];
	      if (data.css && _typeof(data.css) == "object") data.css = createCss(data.css);
	      var pre = "<div webix_f_id=\"" + data.id + "\"" + (data.type !== "label" ? "role=\"option\" tabindex=\"0\"" : "") + " class=\"webix_property_line " + (data.css || "") + "\">";
	      if (data.type == "label") html[i] = pre + "<div class='webix_property_label_line'>" + data.label + "</div></div>";else {
	        var render = this.on_render[data.type],
	            content;
	        var post = "<div class='webix_property_label' style='width:" + this._settings.nameWidth + "px'>" + data.label + "</div><div class='webix_property_value' style='width:" + this._data_width + "px'>";

	        if (data.collection || data.options) {
	          content = data.template(data, data.value);
	        } else if (data.format) content = data.format(data.value);else content = data.value;

	        if (render) content = render.call(this, data.value, data);
	        html[i] = pre + post + content + "</div></div>";
	      }
	    }
	    return html.join("");
	  },
	  type: {
	    height: 24,
	    templateStart: template(""),
	    templateEnd: template("</div>")
	  },
	  $skin: function () {
	    this.type.height = $active.propertyItemHeight;
	  }
	};
	var view$r = exports.protoUI(api$r, AutoTooltip, EditAbility, MapCollection, MouseEvents, Scrollable, SingleRender, AtomDataLoader, EventSystem, base.view);

	var api$s = {
	  name: "calendar",
	  defaults: {
	    date: new Date(),
	    //selected date, not selected by default
	    select: false,
	    navigation: true,
	    monthSelect: true,
	    weekHeader: true,
	    weekNumber: false,
	    skipEmptyWeeks: false,
	    calendarHeader: "%F %Y",
	    calendarWeekHeader: "W#",
	    //calendarTime: "%H:%i",
	    events: wDate.isHoliday,
	    minuteStep: 5,
	    timeIcon: "wxi-clock",
	    icons: false,
	    timepickerHeight: 30,
	    headerHeight: 70,
	    dayTemplate: function (d) {
	      return d.getDate();
	    },
	    width: 260,
	    height: 250
	  },
	  dayTemplate_setter: template,
	  calendarHeader_setter: wDate.dateToStr,
	  calendarWeekHeader_setter: wDate.dateToStr,
	  calendarTime_setter: function (format) {
	    this._calendarTime = format;
	    return wDate.dateToStr(format);
	  },
	  date_setter: function (date) {
	    return this._string_to_date(date);
	  },
	  maxDate_setter: function (date) {
	    return this._string_to_date(date);
	  },
	  minDate_setter: function (date) {
	    return this._string_to_date(date);
	  },
	  minTime_setter: function (time) {
	    if (typeof time == "string") {
	      time = i18n.parseTimeFormatDate(time);
	      time = [time.getHours(), time.getMinutes()];
	    }

	    return time;
	  },
	  maxTime_setter: function (time) {
	    if (typeof time == "string") {
	      time = i18n.parseTimeFormatDate(time);
	      time = [time.getHours(), time.getMinutes()];
	    }

	    return time;
	  },
	  _ariaFocus: function () {
	    var ev = "focus" + (env.isIE ? "in" : "");

	    if (!env.touch) {
	      _event(this.$view, ev, bind(function (e) {
	        var t = e.target.className;
	        var css = t.indexOf("webix_cal_day") !== -1 ? "webix_cal_day" : t.indexOf("webix_cal_block") !== -1 ? "webix_cal_block" : "";

	        if (new Date() - UIManager._tab_time > 300 && new Date() - UIManager._mouse_time > 100 && css) {
	          var prev = e.relatedTarget;

	          if (prev && !isUndefined(prev.className)) {
	            var date = css == "webix_cal_day" ? this._locate_day(e.target) : this._locate_date(e.target);

	            this._moveSelection(date);
	          }
	        }
	      }, this), {
	        capture: !env.isIE
	      });
	    }
	  },
	  $init: function () {
	    this._viewobj.className += " webix_calendar";

	    this._viewobj.setAttribute("role", "region");

	    this._viewobj.setAttribute("aria-label", i18n.aria.calendar); //special dates


	    this._special_dates = {};
	    this._selected_days = {};
	    this._zoom_level = 0; //navigation and aria

	    this._ariaFocus();

	    this.attachEvent("onKeyPress", this._onKeyPress);
	    this.attachEvent("onAfterZoom", function (zoom) {
	      if (zoom >= 0) this.$view.querySelector(".webix_cal_month_name").blur();
	    });
	  },
	  type_setter: function (value) {
	    if (value == "time") {
	      this._zoom_in = true;
	      this._zoom_level = -1;
	    } else if (value == "year") {
	      this._fixed = true;
	    }

	    return value;
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      //repaint calendar when size changed
	      this.render();
	    }
	  },
	  $getSize: function (dx, dy) {
	    if (this._settings.cellHeight) {
	      var state = this._getDateBoundaries(this._settings.date);

	      this._settings.height = this._settings.cellHeight * state._rows + ($active.calendarHeight || 70);
	    }

	    return base.api.$getSize.call(this, dx, dy);
	  },
	  moveSelection: function (mode, details, focus) {
	    if (this.config.master) return; //in daterange

	    var start = this.getSelectedDate();
	    if (this.config.multiselect) start = start[0];
	    var date = wDate.copy(start || this.getVisibleDate());

	    this._moveSelection(date, mode, focus);
	  },
	  _moveSelection: function (date, mode, focus) {
	    var css = this._zoom_logic[this._zoom_level]._keyshift(date, mode, this);

	    if (focus !== false) {
	      var sel = this._viewobj.querySelector("." + css + "[tabindex='0']");

	      if (sel) sel.focus();
	    }
	  },
	  _getDateBoundaries: function (date, reset) {
	    // addition information about rendering event:
	    // how many days from the previous month,
	    // next,
	    // number of weeks to display and so on
	    if (!this._set_date_bounds || reset) {
	      var month = date.getMonth();
	      var year = date.getFullYear();
	      var next = new Date(year, month + 1, 1);
	      var start = wDate.weekStart(new Date(year, month, 1));
	      var days = Math.round((next.valueOf() - start.valueOf()) / (60 * 1000 * 60 * 24));
	      var rows = this._settings.skipEmptyWeeks ? Math.ceil(days / 7) : 6;
	      this._set_date_bounds = {
	        _month: month,
	        _start: start,
	        _next: next,
	        _rows: rows
	      };
	    }

	    return this._set_date_bounds;
	  },
	  $skin: function () {
	    if ($active.calendar) {
	      if ($active.calendar.width) this.defaults.width = $active.calendar.width;
	      if ($active.calendar.height) this.defaults.height = $active.calendar.height;
	      if ($active.calendar.headerHeight) this.defaults.headerHeight = $active.calendar.headerHeight;
	      if ($active.calendar.timepickerHeight) this.defaults.timepickerHeight = $active.calendar.timepickerHeight;
	    }
	  },
	  _getColumnConfigSizes: function (date) {
	    var bounds = this._getDateBoundaries(date);

	    var s = this._settings;
	    var _columnsHeight = [];
	    var _columnsWidth = [];
	    var min = Infinity;
	    var containerWidth = this._content_width - 36;
	    var containerHeight = this._content_height - this._settings.headerHeight - 10 - (this._settings.timepicker || this._icons ? this._settings.timepickerHeight : 0);
	    var columnsNumber = s.weekNumber ? 8 : 7;

	    for (var i = 0; i < columnsNumber; i++) {
	      _columnsWidth[i] = Math.ceil(containerWidth / (columnsNumber - i));
	      containerWidth -= _columnsWidth[i];
	      min = Math.min(min, _columnsWidth[i]);
	    }

	    var rowsNumber = bounds._rows;

	    for (var k = 0; k < rowsNumber; k++) {
	      _columnsHeight[k] = Math.ceil(containerHeight / (rowsNumber - k));
	      containerHeight -= _columnsHeight[k];
	      min = Math.min(min, _columnsHeight[k]);
	    }

	    return [_columnsWidth, _columnsHeight, min];
	  },
	  icons_setter: function (value) {
	    if (!value) this._icons = null;else if (_typeof(value) == "object") this._icons = value;else this._icons = this._icons2;
	  },
	  _icons: [],
	  _icons2: [{
	    template: function () {
	      return "<span role='button' tabindex='0' class='webix_cal_icon_today webix_cal_icon'>" + i18n.calendar.today + "</span>";
	    },
	    on_click: {
	      "webix_cal_icon_today": function () {
	        var date = new Date();
	        if (!this._settings.timepicker) date = wDate.datePart(date);
	        this.setValue(date);
	        this.callEvent("onTodaySet", [this.getSelectedDate()]);
	      }
	    }
	  }, {
	    template: function () {
	      return "<span role='button' tabindex='0' class='webix_cal_icon_clear webix_cal_icon'>" + i18n.calendar.clear + "</span>";
	    },
	    on_click: {
	      "webix_cal_icon_clear": function () {
	        this.setValue("");
	        this.callEvent("onDateClear", [this.getSelectedDate()]);
	      }
	    }
	  }],
	  refresh: function () {
	    this.render();
	  },
	  render: function () {
	    //reset zoom level
	    this._zoom_level = 0;
	    this._zoom_size = false;
	    var s = this._settings;
	    if (!this.isVisible(s.id)) return;
	    this._current_time = wDate.datePart(new Date());
	    this.callEvent("onBeforeRender", []);
	    var date = this._settings.date;

	    var bounds = this._getDateBoundaries(date, true);

	    var sizes = this._getColumnConfigSizes(date);

	    var width = sizes[0];
	    var height = sizes[1];
	    var html = "<div class='webix_cal_month'><span role='button' tabindex='0' aria-live='assertive' aria-atomic='true' class='webix_cal_month_name" + (!this._settings.monthSelect ? " webix_readonly" : "") + "'>" + s.calendarHeader(date) + "</span>";
	    if (s.navigation) html += "<div role='button' tabindex='0' aria-label='" + i18n.aria.navMonth[0] + "' class='webix_cal_prev_button'></div><div role='button' tabindex='0' aria-label='" + i18n.aria.navMonth[1] + "' class='webix_cal_next_button'></div>";
	    html += "</div>";
	    if (s.weekHeader) html += "<div class='webix_cal_header' aria-hidden='true'>" + this._week_template(width) + "</div>";
	    html += "<div class='webix_cal_body'>" + this._body_template(width, height, bounds, sizes[2]) + "</div>";

	    if (this._settings.timepicker || this._icons) {
	      html += "<div class='webix_cal_footer'>";
	      if (this._settings.timepicker) html += this._timepicker_template(date);
	      if (this._icons) html += this._icons_template();
	      html += "</div>";
	    }

	    this._contentobj.innerHTML = html;

	    if (this._settings.type == "time") {
	      var time = this._settings.date;

	      if (time) {
	        if (typeof time == "string") {
	          date = i18n.parseTimeFormatDate(time);
	        } else if (isArray(time)) {
	          date.setHours(time[0]);
	          date.setMinutes(time[1]);
	        }
	      }

	      this._changeZoomLevel(-1, date);
	    } else if (this._settings.type == "month") {
	      this._changeZoomLevel(1, date);
	    } else if (this._settings.type == "year") {
	      this._changeZoomLevel(2, date);
	    }

	    this.callEvent("onAfterRender", []);
	  },
	  _icons_template: function (date) {
	    var html = "<div class='webix_cal_icons'>";
	    var icons = this._icons;

	    for (var i = 0; i < icons.length; i++) {
	      if (icons[i].template) {
	        var template$$1 = typeof icons[i].template == "function" ? icons[i].template : template$$1(icons[i].template);
	        html += template$$1.call(this, date);
	      }

	      if (icons[i].on_click) {
	        exports.extend(this.on_click, icons[i].on_click);
	      }
	    }

	    html += "</div>";
	    return html;
	  },
	  _timepicker_template: function (date) {
	    var timeFormat = this._settings.calendarTime || i18n.timeFormatStr;
	    var clock = this._settings.timeIcon;
	    var tpl = "";
	    if (!this._settings.master) tpl = "<div role='button' tabindex='0' class='webix_cal_time" + (this._icons ? " webix_cal_time_icons" : "") + "'><span class='webix_icon " + clock + "'></span> " + timeFormat(date) + "</div>";else {
	      //daterange needs two clocks
	      var range_date = copy($$(this._settings.master)._settings.value);
	      if (wDate.equal(range_date.end, date)) range_date.start = range_date.end;

	      for (var i in range_date) {
	        tpl += "<div role='button' tabindex='0' class='webix_range_time_" + i + " webix_cal_time'><span class='webix_icon " + clock + "'></span> " + timeFormat(range_date[i]) + "</div>";
	      }
	    }
	    return tpl;
	  },
	  _week_template: function (widths) {
	    var s = this._settings;
	    var week_template = "";
	    var correction = 0;

	    if (s.weekNumber) {
	      correction = 1;
	      week_template += "<div class='webix_cal_week_header' style='width: " + widths[0] + "px;' >" + s.calendarWeekHeader() + "</div>";
	    }

	    var k = wDate.startOnMonday ? 1 : 0;

	    for (var i = 0; i < 7; i++) {
	      // 7 days total
	      var day_index = (k + i) % 7; // 0 - Sun, 6 - Sat as in Locale.date.day_short

	      var day = i18n.calendar.dayShort[day_index]; // 01, 02 .. 31

	      week_template += "<div day='" + day_index + "' style='width: " + widths[i + correction] + "px;' >" + day + "</div>";
	    }

	    return week_template;
	  },
	  blockDates_setter: function (value) {
	    return toFunctor(value, this.$scope);
	  },
	  _day_css: function (day, bounds) {
	    var css = "",
	        isOutside = false;
	    if (wDate.equal(day, this._current_time)) css += " webix_cal_today";
	    if (!this._checkDate(day)) css += " webix_cal_day_disabled";

	    if (day.getMonth() != bounds._month) {
	      isOutside = true;
	      css += " webix_cal_outside";
	    }

	    if (!isOutside && this._selectedDay(day)) css += " webix_cal_select";
	    if (this._settings.events) css += " " + (this._settings.events(day, isOutside) || "");
	    css += " webix_cal_day";
	    return css;
	  },
	  _body_template: function (widths, heights, bounds, sqSize) {
	    var s = this._settings;
	    var html = "";
	    var day = wDate.datePart(wDate.copy(bounds._start));
	    var start = s.weekNumber ? 1 : 0;
	    var weekNumber = wDate.getISOWeek(wDate.add(day, 2, "day", true));

	    for (var y = 0; y < heights.length; y++) {
	      html += "<div class='webix_cal_row' style='height:" + heights[y] + "px;line-height:" + heights[y] + "px'>";

	      if (start) {
	        // recalculate week number for the first week of a year
	        if (!day.getMonth() && day.getDate() < 7) weekNumber = wDate.getISOWeek(wDate.add(day, 2, "day", true));
	        html += "<div class='webix_cal_week_num' aria-hidden='true' style='width:" + widths[0] + "px'>" + weekNumber + "</div>";
	      }

	      for (var x = start; x < widths.length; x++) {
	        var css = this._day_css(day, bounds);

	        var d = this._settings.dayTemplate.call(this, day);

	        var sel = this._selectedDay(day);

	        var alabel = "";

	        var isOutside = day.getMonth() != bounds._month;

	        if (_typeof(d) == "object") {
	          alabel = d.aria || alabel;
	          d = d.text;
	        } else alabel = wDate.dateToStr(i18n.aria.dateFormat)(day);

	        html += "<div day='" + x + "' role='gridcell' " + (isOutside ? "aria-hidden='true'" : "") + " aria-label='" + alabel + "' tabindex='" + (sel && !isOutside ? "0" : "-1") + "' aria-selected='" + (sel && !isOutside ? "true" : "false") + "' class='" + css + "' style='text-align:center; width:" + widths[x] + "px'><span aria-hidden='true' class='webix_cal_day_inner' style='display:inline-block; " + this._getCalSizesString(sqSize, sqSize) + "'>" + d + "</span></div>";
	        day = wDate.add(day, 1, "day");

	        if (day.getHours()) {
	          day = wDate.datePart(day);
	        }
	      }

	      html += "</div>";
	      weekNumber++;
	    }

	    return html;
	  },
	  _changeDate: function (dir, step) {
	    var now = this._settings.date;

	    if (!step) {
	      step = this._zoom_logic[this._zoom_level]._changeStep;
	    }

	    if (!this._zoom_level) {
	      now = wDate.copy(now);
	      now.setDate(1);
	    }

	    var next = wDate.add(now, dir * step, "month", true);

	    this._changeDateInternal(now, next);
	  },
	  _changeDateInternal: function (now, next) {
	    if (this.callEvent("onBeforeMonthChange", [now, next])) {
	      if (this._zoom_level) {
	        this._update_zoom_level(next);
	      } else {
	        this.showCalendar(next);
	      }

	      this.callEvent("onAfterMonthChange", [next, now]);
	    }
	  },
	  _zoom_logic: {
	    "-2": {
	      _isBlocked: function (i) {
	        var config = this._settings,
	            date = config.date,
	            isBlocked = false;
	        var minHour = config.minTime ? config.minTime[0] : 0;
	        var maxHour = config.maxTime ? config.maxTime[0] + (config.maxTime[1] ? 1 : 0) : 24;
	        var minMinute = config.minTime && date.getHours() == minHour ? config.minTime[1] : 0;
	        var maxMinute = config.maxTime && config.maxTime[1] && date.getHours() == maxHour - 1 ? config.maxTime[1] : 60;

	        if (this._settings.blockTime) {
	          var d = wDate.copy(date);
	          d.setMinutes(i);
	          isBlocked = this._settings.blockTime(d);
	        }

	        return i < minMinute || i >= maxMinute || isBlocked;
	      },
	      _setContent: function (next, i) {
	        next.setMinutes(i);
	      },
	      _findActive: function (date, mode, calendar) {
	        if (!this._isBlocked.call(calendar, date.getMinutes())) return date;else {
	          var step = calendar._settings.minuteStep;
	          var newdate = wDate.add(date, mode == "right" ? step : -step, "minute", true);
	          if (date.getHours() === newdate.getHours()) return this._findActive(newdate, mode, calendar);
	        }
	      }
	    },
	    "-1": {
	      _isBlocked: function (i) {
	        var config = this._settings,
	            date = config.date;
	        var minHour = config.minTime ? config.minTime[0] : 0;
	        var maxHour = config.maxTime ? config.maxTime[0] + (config.maxTime[1] ? 1 : 0) : 24;
	        if (i < minHour || i >= maxHour) return true;

	        if (config.blockTime) {
	          var d = wDate.copy(date);
	          d.setHours(i);
	          var minMinute = config.minTime && i == minHour ? config.minTime[1] : 0;
	          var maxMinute = config.maxTime && config.maxTime[1] && i == maxHour - 1 ? config.maxTime[1] : 60;

	          for (var j = minMinute; j < maxMinute; j += config.minuteStep) {
	            d.setMinutes(j);
	            if (!config.blockTime(d)) return false;
	          }

	          return true;
	        }
	      },
	      _setContent: function (next, i) {
	        next.setHours(i);
	      },
	      _keyshift: function (date, mode, calendar) {
	        var newdate,
	            inc,
	            step = calendar._settings.minuteStep;

	        if (mode === "bottom" || mode === "top") {
	          date.setHours(mode === "bottom" ? 23 : 0);
	          date.setMinutes(mode === "bottom" ? 55 : 0);
	          date.setSeconds(0);
	          date.setMilliseconds(0);
	          newdate = date;
	        } else if (mode === "left" || mode === "right") {
	          //minutes
	          inc = mode === "right" ? step : -step;
	          if (mode === "left" && date.getMinutes() < step) inc = 60 - step;
	          if (mode === "right" && date.getMinutes() >= 60 - step) inc = step - 60;
	          inc -= date.getMinutes() % step;
	          newdate = calendar._zoom_logic["-2"]._findActive(wDate.add(date, inc, "minute"), mode, calendar);
	        } else if (mode === "up" || mode === "down") {
	          //hours
	          inc = mode === "down" ? 1 : -1;
	          if (mode === "down" && date.getHours() === 23) inc = -23;
	          if (mode === "up" && date.getHours() === 0) inc = 23;
	          newdate = this._findActive(wDate.add(date, inc, "hour"), mode, calendar);
	        } else if (mode === false) newdate = this._findActive(date, mode, calendar);

	        calendar.selectDate(newdate, false);

	        if (newdate) {
	          calendar._update_zoom_level(newdate);

	          calendar.selectDate(newdate, false);
	        }

	        return "webix_cal_block" + (mode === "left" || mode === "right" ? "_min" : "");
	      },
	      _findActive: function (date, mode, calendar) {
	        if (!this._isBlocked.call(calendar, date.getHours())) return date;else {
	          var newdate = wDate.add(date, mode == "down" ? 1 : -1, "hour", true);
	          if (date.getDate() === newdate.getDate()) return this._findActive(newdate, mode, calendar);
	        }
	      }
	    },
	    "0": {
	      //days
	      _changeStep: 1,
	      _keyshift: function (date, mode, calendar) {
	        var newdate = date;
	        if (mode === "pgup" || mode === "pgdown") newdate = wDate.add(date, mode === "pgdown" ? 1 : -1, "month");else if (mode === "bottom") newdate = new Date(date.getFullYear(), date.getMonth() + 1, 0);else if (mode === "top") newdate = new Date(date.setDate(1));else if (mode === "left" || mode === "right") newdate = wDate.add(date, mode === "right" ? 1 : -1, "day");else if (mode === "up" || mode === "down") newdate = wDate.add(date, mode === "down" ? 1 : -1, "week");
	        if (!calendar._checkDate(newdate)) newdate = calendar._findActive(date, mode);
	        if (newdate) calendar.selectDate(newdate, true);
	        return "webix_cal_day";
	      }
	    },
	    "1": {
	      //months
	      _isBlocked: function (i, calendar) {
	        var blocked = false,
	            minYear,
	            maxYear,
	            min = calendar._settings.minDate || null,
	            max = calendar._settings.maxDate || null,
	            year = calendar._settings.date.getFullYear();

	        if (min && max) {
	          minYear = min.getFullYear();
	          maxYear = max.getFullYear();
	          if (year < minYear || year == minYear && min.getMonth() > i || year > maxYear || year == maxYear && max.getMonth() < i) blocked = true;
	        }

	        return blocked;
	      },
	      _correctDate: function (date, calendar) {
	        if (date < calendar._settings.minDate) {
	          date = wDate.copy(calendar._settings.minDate);
	        } else if (date > calendar._settings.maxDate) {
	          date = wDate.copy(calendar._settings.maxDate);
	        }

	        return date;
	      },
	      _getTitle: function (date) {
	        return date.getFullYear();
	      },
	      _getContent: function (i) {
	        return i18n.calendar.monthShort[i];
	      },
	      _setContent: function (next, i) {
	        if (i != next.getMonth()) next.setDate(1);
	        next.setMonth(i);
	      },
	      _changeStep: 12,
	      _keyshift: function (date, mode, calendar) {
	        var newdate = date;
	        if (mode === "pgup" || mode === "pgdown") newdate = wDate.add(date, mode === "pgdown" ? 1 : -1, "year");else if (mode === "bottom") newdate = new Date(date.setMonth(11));else if (mode === "top") newdate = new Date(date.setMonth(0));else if (mode === "left" || mode === "right") newdate = wDate.add(date, mode === "right" ? 1 : -1, "month");else if (mode === "up" || mode === "down") newdate = wDate.add(date, mode === "down" ? 4 : -4, "month");
	        if (!calendar._checkDate(newdate)) newdate = calendar._findActive(date, mode);

	        if (newdate) {
	          calendar._update_zoom_level(newdate);

	          calendar.selectDate(newdate, false);
	        }

	        return "webix_cal_block";
	      }
	    },
	    "2": {
	      //years
	      _isBlocked: function (i, calendar) {
	        i += calendar._zoom_start_date;
	        var blocked = false;
	        var min = calendar._settings.minDate;
	        var max = calendar._settings.maxDate;

	        if (min && max && (min.getFullYear() > i || max.getFullYear() < i)) {
	          blocked = true;
	        }

	        return blocked;
	      },
	      _correctDate: function (date, calendar) {
	        if (date < calendar._settings.minDate) {
	          date = wDate.copy(calendar._settings.minDate);
	        } else if (date > calendar._settings.maxDate) {
	          date = wDate.copy(calendar._settings.maxDate);
	        }

	        return date;
	      },
	      _getTitle: function (date, calendar) {
	        var start = date.getFullYear();
	        calendar._zoom_start_date = start = start - start % 10 - 1;
	        return start + " - " + (start + 10 + 1);
	      },
	      _getContent: function (i, calendar) {
	        return calendar._zoom_start_date + i;
	      },
	      _setContent: function (next, i, calendar) {
	        next.setFullYear(calendar._zoom_start_date + i);
	      },
	      _changeStep: 12 * 10,
	      _keyshift: function (date, mode, calendar) {
	        var newdate = date;
	        if (mode === "pgup" || mode === "pgdown") newdate = wDate.add(date, mode === "pgdown" ? 10 : -10, "year");else if (mode === "bottom") newdate = new Date(date.setYear(calendar._zoom_start_date + 10));else if (mode === "top") newdate = new Date(date.setYear(calendar._zoom_start_date));else if (mode === "left" || mode === "right") newdate = wDate.add(date, mode === "right" ? 1 : -1, "year");else if (mode === "up" || mode === "down") newdate = wDate.add(date, mode === "down" ? 4 : -4, "year");
	        if (!calendar._checkDate(newdate)) newdate = calendar._findActive(date, mode);

	        if (newdate) {
	          calendar._update_zoom_level(newdate);

	          calendar.selectDate(newdate, false);
	        }

	        return "webix_cal_block";
	      }
	    }
	  },
	  _correctBlockedTime: function () {
	    var i, isDisabledHour, isDisabledMinutes;
	    isDisabledHour = this._zoom_logic[-1]._isBlocked.call(this, this._settings.date.getHours());

	    if (isDisabledHour) {
	      for (i = 0; i < 24; i++) {
	        if (!this._zoom_logic[-1]._isBlocked.call(this, i)) {
	          this._settings.date.setHours(i);

	          break;
	        }
	      }
	    }

	    isDisabledMinutes = this._zoom_logic[-2]._isBlocked.call(this, this._settings.date.getMinutes());

	    if (isDisabledMinutes) {
	      for (i = 0; i < 60; i += this._settings.minuteStep) {
	        if (!this._zoom_logic[-2]._isBlocked.call(this, i)) {
	          this._settings.date.setMinutes(i);

	          break;
	        }
	      }
	    }
	  },
	  _update_zoom_level: function (date) {
	    var config, css, height, i, index$$1, sections, selected, type, width, zlogic, temp, sqSize;
	    var html = "";
	    config = this._settings;
	    index$$1 = config.weekHeader ? 2 : 1;
	    zlogic = this._zoom_logic[this._zoom_level];
	    sections = this._contentobj.childNodes;

	    if (date) {
	      config.date = date;
	    }

	    type = config.type; //store width and height of draw area

	    if (!this._zoom_size) {
	      /*this._reserve_box_height = sections[index].offsetHeight +(index==2?sections[1].offsetHeight:0);*/
	      this._reserve_box_height = this._contentobj.offsetHeight - config.headerHeight;
	      if (type != "year" && type != "month") this._reserve_box_height -= config.timepickerHeight;else if (this._icons) {
	        this._reserve_box_height -= 10;
	      }
	      this._reserve_box_width = sections[index$$1].offsetWidth;
	      this._zoom_size = 1;
	    } //main section


	    if (this._zoom_in) {
	      //hours and minutes
	      height = this._reserve_box_height / 6;
	      var timeColNum = 6;
	      var timeFormat = this._calendarTime || i18n.timeFormat;
	      var enLocale = timeFormat.match(/%([a,A])/);
	      if (enLocale) timeColNum++;
	      width = parseInt((this._reserve_box_width - 3) / timeColNum, 10);
	      sqSize = Math.min(width, height);
	      html += "<div class='webix_time_header'>" + this._timeHeaderTemplate(width, enLocale) + "</div>";
	      html += "<div  class='webix_cal_body' style='height:" + this._reserve_box_height + "px'>"; // check and change blocked selected time

	      this._correctBlockedTime();

	      html += "<div class='webix_hours'>";
	      selected = config.date.getHours();
	      temp = wDate.copy(config.date);

	      for (i = 0; i < 24; i++) {
	        css = "";

	        if (enLocale) {
	          if (i % 4 === 0) {
	            var label = !i ? i18n.am[0] : i == 12 ? i18n.pm[0] : "";
	            html += "<div class='webix_cal_block_empty" + css + "' style='" + this._getCalSizesString(width, height) + "clear:both;" + "'>" + label + "</div>";
	          }
	        }

	        if (this._zoom_logic[-1]._isBlocked.call(this, i)) {
	          css += " webix_cal_day_disabled";
	        } else if (selected == i) css += " webix_selected";

	        temp.setHours(i);
	        html += "<div aria-label='" + wDate.dateToStr(i18n.aria.hourFormat)(temp) + "' role='gridcell'" + " tabindex='" + (selected == i ? "0" : "-1") + "' aria-selected='" + (selected == i ? "true" : "false") + "' class='webix_cal_block" + css + "' data-value='" + i + "' style='" + this._getCalSizesString(width, height) + (i % 4 === 0 && !enLocale ? "clear:both;" : "") + "'><span style='display:inline-block; " + this._getCalSizesString(sqSize, sqSize) + "'>" + wDate.toFixed(enLocale ? !i || i == 12 ? 12 : i % 12 : i) + "</span></div>";
	      }

	      html += "</div>";
	      html += "<div class='webix_minutes'>";
	      selected = config.date.getMinutes();
	      temp = wDate.copy(config.date);

	      for (i = 0; i < 60; i += config.minuteStep) {
	        css = "";

	        if (this._zoom_logic[-2]._isBlocked.call(this, i)) {
	          css = " webix_cal_day_disabled";
	        } else if (selected == i) css = " webix_selected";

	        temp.setMinutes(i);
	        html += "<div aria-label='" + wDate.dateToStr(i18n.aria.minuteFormat)(temp) + "' role='gridcell' tabindex='" + (selected == i ? "0" : "-1") + "' aria-selected='" + (selected == i ? "true" : "false") + "' class='webix_cal_block webix_cal_block_min" + css + "' data-value='" + i + "' style='" + this._getCalSizesString(width, height) + (i % 2 === 0 ? "clear:both;" : "") + "'><span style='display:inline-block; " + this._getCalSizesString(sqSize, sqSize) + "'>" + wDate.toFixed(i) + "</span></div>";
	      }

	      html += "</div>";
	      html += "</div>";
	      html += "<div  class='webix_time_footer'>" + this._timeButtonsTemplate() + "</div>";
	      this._contentobj.innerHTML = html;
	    } else {
	      //years and months
	      //reset header
	      var header = sections[0].childNodes;
	      var labels = i18n.aria["nav" + (this._zoom_level == 1 ? "Year" : "Decade")];
	      header[0].innerHTML = zlogic._getTitle(config.date, this);
	      header[1].setAttribute("aria-label", labels[0]);
	      header[2].setAttribute("aria-label", labels[1]);
	      height = Math.floor(this._reserve_box_height / 3);
	      width = Math.floor(this._reserve_box_width / 4);
	      sqSize = Math.min(height, width);
	      if (this._checkDate(config.date)) selected = this._zoom_level == 1 ? config.date.getMonth() : config.date.getFullYear();

	      for (i = 0; i < 12; i++) {
	        css = selected == (this._zoom_level == 1 ? i : zlogic._getContent(i, this)) ? " webix_selected" : "";

	        if (zlogic._isBlocked(i, this)) {
	          css += " webix_cal_day_disabled";
	        }

	        var format = i18n.aria[(this._zoom_level == 1 ? "month" : "year") + "Format"];
	        html += "<div role='gridcell' aria-label='" + wDate.dateToStr(format)(config.date) + "' tabindex='" + (css.indexOf("selected") !== -1 ? "0" : "-1") + "' aria-selected='" + (css.indexOf("selected") !== -1 ? "true" : "false") + "' class='webix_cal_block" + css + "' data-value='" + i + "' style='" + this._getCalSizesString(width, height) + "'><span style='display:inline-block; " + this._getCalSizesString(sqSize, sqSize) + "'>" + zlogic._getContent(i, this) + "</span></div>";
	      }

	      if (index$$1 - 1) {
	        sections[index$$1 - 1].style.display = "none";
	      }

	      sections[index$$1].innerHTML = html;

	      if (type != "year" && type != "month") {
	        if (!sections[index$$1 + 1]) this._contentobj.innerHTML += "<div  class='webix_time_footer'>" + this._timeButtonsTemplate() + "</div>";else sections[index$$1 + 1].innerHTML = this._timeButtonsTemplate();
	      }

	      sections[index$$1].style.height = this._reserve_box_height + "px";
	    }
	  },
	  _getCalSizesString: function (width, height) {
	    return "width:" + width + "px; height:" + height + "px; line-height:" + height + "px;";
	  },
	  _timeButtonsTemplate: function () {
	    return "<input type='button' style='width:100%' class='webix_cal_done' value='" + i18n.calendar.done + "'>";
	  },
	  _timeHeaderTemplate: function (width, enLocale) {
	    var w1 = width * (enLocale ? 5 : 4);
	    var w2 = width * 2;
	    return "<div class='webix_cal_hours' style='width:" + w1 + "px'>" + i18n.calendar.hours + "</div><div class='webix_cal_minutes' style='width:" + w2 + "px'>" + i18n.calendar.minutes + "</div>";
	  },
	  _changeZoomLevel: function (zoom, date) {
	    var oldzoom = this._zoom_level;

	    if (this.callEvent("onBeforeZoom", [zoom, oldzoom])) {
	      this._zoom_level = zoom;
	      if (zoom) this._update_zoom_level(date);else this.showCalendar(date);
	      this.callEvent("onAfterZoom", [zoom, oldzoom]);
	    }
	  },
	  _correctDate: function (date) {
	    if (!this._checkDate(date) && this._zoom_logic[this._zoom_level]._correctDate) date = this._zoom_logic[this._zoom_level]._correctDate(date, this);
	    return date;
	  },
	  _mode_selected: function (target) {
	    var next = this._locate_date(target);

	    var zoom = this._zoom_level - (this._fixed ? 0 : 1);
	    next = this._correctDate(next);

	    if (this._checkDate(next)) {
	      this._changeZoomLevel(zoom, next);

	      var type = this._settings.type;
	      if (type == "month" || type == "year") this._selectDate(next);
	    }
	  },
	  // selects date and redraw calendar
	  _selectDate: function (date, add) {
	    if (this.callEvent("onBeforeDateSelect", [date])) {
	      this.selectDate(date, true, add);
	      this.callEvent("onDateSelect", [date]); // should be deleted in a future version

	      this.callEvent("onAfterDateSelect", [date]);
	    }
	  },
	  _locate_day: function (target) {
	    var cind = index(target) - (this._settings.weekNumber ? 1 : 0);
	    var rind = index(target.parentNode);
	    var date = wDate.add(this._getDateBoundaries()._start, cind + rind * 7, "day", true);

	    if (this._settings.timepicker) {
	      date.setHours(this._settings.date.getHours());
	      date.setMinutes(this._settings.date.getMinutes());
	    }

	    return date;
	  },
	  _locate_date: function (target) {
	    var value = target.getAttribute("data-value") * 1;
	    var level = target.className.indexOf("webix_cal_block_min") != -1 ? this._zoom_level - 1 : this._zoom_level;
	    var now = this._settings.date;
	    var next = wDate.copy(now);

	    this._zoom_logic[level]._setContent(next, value, this);

	    return next;
	  },
	  on_click: {
	    webix_cal_prev_button: function () {
	      this._changeDate(-1);
	    },
	    webix_cal_next_button: function () {
	      this._changeDate(1);
	    },
	    webix_cal_day_disabled: function () {
	      return false;
	    },
	    webix_cal_outside: function () {
	      if (!this._settings.navigation) return false;
	    },
	    webix_cal_day: function (e, id, target) {
	      var date = this._locate_day(target);

	      var add = this._settings.multiselect === "touch" || e.ctrlKey || e.metaKey;

	      this._selectDate(date, add);
	    },
	    webix_cal_time: function () {
	      if (this._zoom_logic[this._zoom_level - 1]) {
	        this._zoom_in = true;
	        var zoom = this._zoom_level - 1;

	        this._changeZoomLevel(zoom);
	      }
	    },
	    webix_range_time_start: function () {
	      $$(this._settings.master)._time_mode = "start";
	    },
	    webix_range_time_end: function () {
	      $$(this._settings.master)._time_mode = "end";
	    },
	    webix_cal_done: function () {
	      var date = wDate.copy(this._settings.date);
	      date = this._correctDate(date);

	      this._selectDate(date);
	    },
	    webix_cal_month_name: function () {
	      this._zoom_in = false; //maximum zoom reached

	      if (this._zoom_level == 2 || !this._settings.monthSelect) return;
	      var zoom = Math.max(this._zoom_level, 0) + 1;

	      this._changeZoomLevel(zoom);
	    },
	    webix_cal_block: function (e, id, trg) {
	      if (this._zoom_in) {
	        if (trg.className.indexOf("webix_cal_day_disabled") !== -1) return false;

	        var next = this._locate_date(trg);

	        this._update_zoom_level(next);
	      } else {
	        if (trg.className.indexOf("webix_cal_day_disabled") == -1) this._mode_selected(trg);
	      }
	    }
	  },
	  _string_to_date: function (date, format) {
	    if (!date) {
	      return wDate.datePart(new Date());
	    }

	    if (typeof date == "string") {
	      if (format) date = wDate.strToDate(format)(date);else date = i18n.parseFormatDate(date);
	    }

	    return date;
	  },
	  _checkDate: function (date) {
	    var blockedDate = this._settings.blockDates && this._settings.blockDates.call(this, date);

	    var minDate = this._settings.minDate;
	    var maxDate = this._settings.maxDate;
	    var outOfRange = date < minDate || date > maxDate;
	    return !blockedDate && !outOfRange;
	  },
	  _findActive: function (date, mode) {
	    var dir = mode === "top" || mode === "left" || mode === "pgup" || mode === "up" ? -1 : 1;
	    var newdate = wDate.add(date, dir, "day", true);
	    if (this._checkDate(newdate)) return newdate;else {
	      var compare;
	      if (this._zoom_level === 0) compare = date.getMonth() === newdate.getMonth();else if (this._zoom_level === 1) compare = date.getFullYear() === newdate.getFullYear();else if (this._zoom_level === 2) compare = newdate.getFullYear() > this._zoom_start_date && newdate.getFullYear() < this._zoom_start_date + 10;
	      if (compare) return this._findActive(newdate, mode);
	    }
	  },
	  showCalendar: function (date) {
	    date = this._string_to_date(date);
	    this._settings.date = date;
	    this.render();
	    this.resize();
	  },
	  _selectedDay: function (day) {
	    return day && this._selected_days[day.valueOf()];
	  },
	  getSelectedDate: function () {
	    var result = [];

	    for (var key in this._selected_days) {
	      result.push(wDate.copy(this._selected_days[key]));
	    }

	    return this.config.multiselect ? result : result[0] || null;
	  },
	  getVisibleDate: function () {
	    return wDate.copy(this._settings.date);
	  },
	  setValue: function (date) {
	    this.selectDate(date, true);
	  },
	  getValue: function (format) {
	    var date = this.getSelectedDate();
	    if (format) date = wDate.dateToStr(format)(date);
	    return date;
	  },
	  selectDate: function (date, show, add) {
	    if (!date || !add || !this.config.multiselect) this._selected_days = {};

	    if (date) {
	      if (!isArray(date)) date = [date];

	      for (var i = 0; i < date.length; i++) {
	        var days = this._string_to_date(date[i]);

	        var key = wDate.datePart(wDate.copy(days)).valueOf();
	        if (this._selected_days[key] && add) delete this._selected_days[key];else this._selected_days[key] = days;
	        if (!this.config.multiselect) break;
	      }

	      if (date.length && show) this.showCalendar(date[0]);
	    }

	    if (show !== false) this.render();
	    this.callEvent("onChange", [date]);
	  },
	  locate: function () {
	    return null;
	  }
	};
	var view$s = exports.protoUI(api$s, KeysNavigation, MouseEvents, base.view, EventSystem);

	var api$t = {
	  name: "colorboard",
	  defaults: {
	    template: "<div style=\"width:100%;height:100%;background-color:{obj.val}\"></div>",
	    palette: null,
	    height: 220,
	    width: 220,
	    cols: 12,
	    rows: 10,
	    minLightness: 0.15,
	    maxLightness: 1,
	    navigation: true
	  },
	  $init: function () {
	    _event(this._viewobj, "click", bind(function (e) {
	      var value = locate(e, "webix_val");
	      this.setValue(value);
	      this.callEvent("onItemClick", [this._settings.value, e]);
	      this.callEvent("onSelect", [this._settings.value]);
	    }, this));

	    this.$view.setAttribute("role", "grid");

	    this._viewobj.setAttribute("aria-readonly", "true");
	  },
	  _set_item_focus: function () {
	    if (!this.getValue()) this.moveSelection("up");
	  },
	  _findIndex: function (value) {
	    var pal = this._settings.palette;
	    value = (value || "").toUpperCase();

	    for (var r = 0, rows = pal.length; r < rows; r++) {
	      for (var c = 0, cols = pal[r].length; c < cols; c++) {
	        if (pal[r][c].toUpperCase() == value) {
	          return {
	            row: r,
	            col: c
	          };
	        }
	      }
	    }

	    return null;
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      this.render();
	    }
	  },
	  getValue: function () {
	    return this._settings.value;
	  },
	  _getBox: function () {
	    return this._viewobj.firstChild;
	  },
	  setValue: function (value) {
	    if (value && value.toString().charAt(0) != "#") value = "#" + value;
	    var oldvalue = this._settings.value;
	    this._settings.value = value;
	    this.$setValue(value, oldvalue);
	    return value;
	  },
	  _selectBox: null,
	  _getSelectBox: function () {
	    if (this._selectBox && this._selectBox.parentNode) {
	      return this._selectBox;
	    } else {
	      var div = this._selectBox = document.createElement("div");
	      div.className = "webix_color_selector";

	      this._viewobj.lastChild.appendChild(div);

	      return div;
	    }
	  },
	  $setValue: function (value, oldvalue) {
	    if (this.isVisible(this._settings.id)) {
	      var cell,
	          div,
	          ind,
	          parent,
	          style,
	          left = 0,
	          top = 0; //remove tabindex for previous selection

	      if (oldvalue) ind = this._findIndex(oldvalue);
	      if (!ind) ind = {
	        row: 0,
	        col: 0
	      };

	      this._viewobj.lastChild.childNodes[ind.row].childNodes[ind.col].setAttribute("tabindex", "-1");

	      ind = this._findIndex(value);

	      if (ind) {
	        cell = this._viewobj.lastChild.childNodes[ind.row].childNodes[ind.col];
	      }

	      if (cell && cell.parentNode && cell.parentNode.parentNode) {
	        parent = cell.parentNode;
	        left = cell.offsetLeft - parent.offsetLeft;
	        top = -(this.$height - (cell.offsetTop - parent.parentNode.offsetTop));
	        cell.setAttribute("tabindex", "0");
	        cell.setAttribute("aria-selected", "true");
	        cell.setAttribute("tabindex", "0");
	        cell.setAttribute("aria-selected", "true");
	      } else {
	        if (this._selectBox) this._selectBox.style.left = "-100px";

	        this._viewobj.lastChild.childNodes[0].childNodes[0].setAttribute("tabindex", "0");

	        return;
	      }

	      div = this._getSelectBox();
	      style = ["left:" + left + "px", "top:" + top + "px", "width:" + cell.style.width, "height:" + cell.style.height].join(";");

	      if (typeof div.style.cssText !== "undefined") {
	        div.style.cssText = style;
	      } else {
	        div.setAttribute("style", style);
	      }
	    }
	  },
	  _initPalette: function (config) {
	    function numToHex(n) {
	      return color.toHex(n, 2);
	    }

	    function rgbToHex(r, g, b) {
	      return "#" + numToHex(Math.floor(r)) + numToHex(Math.floor(g)) + numToHex(Math.floor(b));
	    }

	    function hslToRgb(h, s, l) {
	      var r, g, b;

	      if (!s) {
	        r = g = b = l; // achromatic
	      } else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1 / 3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1 / 3);
	      }

	      return {
	        r: r * 255,
	        g: g * 255,
	        b: b * 255
	      };
	    }

	    function hue2rgb(p, q, t) {
	      if (t < 0) t += 1;
	      if (t > 1) t -= 1;
	      if (t < 1 / 6) return p + (q - p) * 6 * t;else if (t <= 1 / 2) return q;else if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;else return p;
	    }

	    function renderGrayBar(colCount) {
	      var gray = [],
	          val = 255,
	          step = val / colCount;

	      for (var i = 0; i < colCount; i++) {
	        val = Math.round(val > 0 ? val : 0);
	        gray.push(rgbToHex(val, val, val));
	        val -= step;
	      }

	      gray[gray.length - 1] = "#000000";
	      return gray;
	    }

	    var colors = [];
	    var colorRows = config.rows - 1;
	    var colorStep = 1 / config.cols;
	    var lightStep = (config.maxLightness - config.minLightness) / colorRows;
	    var colorRange = null;
	    colors.push(renderGrayBar(config.cols));

	    for (var step = 0, lt = config.minLightness; step < colorRows; step++) {
	      colorRange = [];

	      for (var c = 0, col = 0; c < config.cols; c++) {
	        var val = hslToRgb(col, 1, lt);
	        colorRange.push(rgbToHex(val.r, val.g, val.b));
	        col += colorStep;
	      }

	      colors.push(colorRange);
	      lt += lightStep;
	    }

	    this._settings.palette = colors;
	  },
	  moveSelection: function (mode, details, focus) {
	    var value = this.getValue(),
	        ind,
	        cell;
	    if (value) ind = this._findIndex(value);
	    if (!ind) ind = {
	      row: 0,
	      col: 0
	    };

	    if (ind) {
	      if (mode == "up" || mode == "down") ind.row = ind.row + (mode == "up" ? -1 : 1);else if (mode == "right" || mode == "left") ind.col = ind.col + (mode == "right" ? 1 : -1);else if (mode == "top") ind.row = ind.col = 0;else if (mode == "bottom") {
	        ind.row = this._viewobj.lastChild.querySelectorAll(".webix_color_row").length - 1;
	        ind.col = this._viewobj.lastChild.childNodes[ind.row].childNodes.length - 1;
	      }
	      ind.row = Math.max(ind.row, 0);
	      if (ind.row >= 0) cell = this._viewobj.lastChild.childNodes[ind.row].childNodes[ind.col];

	      if (cell) {
	        value = cell.getAttribute("webix_val");
	        this.setValue(value);
	        this.callEvent("onSelect", [this._settings.value]);

	        if (focus !== false) {
	          var sel = this._viewobj.querySelector("div[tabindex='0']");

	          if (sel) sel.focus();
	        }
	      }
	    }
	  },
	  render: function () {
	    if (!this.isVisible(this._settings.id)) return;
	    if (!this._settings.palette) this._initPalette(this._settings);
	    var palette = this._settings.palette;
	    this.callEvent("onBeforeRender", []);
	    var config = this._settings,
	        itemTpl = template("<div role='gridcell' tabindex='-1' aria-label=\"{obj.val}\" style=\"width:{obj.width}px;height:{obj.height}px;\" webix_val=\"{obj.val}\">" + (config.template || "") + "</div>"),
	        data = {
	      width: 0,
	      height: 0,
	      val: 0
	    },
	        width = this.$width,
	        height = this.$height,
	        widths = [];
	    var html = "<div class=\"webix_color_palette\"role=\"rowgroup\">";
	    var firstRow = _typeof(palette[0]) == "object" ? palette[0] : palette;

	    for (var i = 0; i < firstRow.length; i++) {
	      widths[i] = Math.floor(width / (firstRow.length - i));
	      width -= widths[i];
	    }

	    if (_typeof(palette[0]) == "object") {
	      for (var r = 0; r < palette.length; r++) {
	        var cellHeight = Math.floor(height / (palette.length - r));
	        height -= cellHeight;
	        var row = palette[r];
	        html += renderRow(row, widths, cellHeight);
	      }
	    } else {
	      html += renderRow(palette, widths, height);
	    }

	    html += "</div>";
	    this._viewobj.innerHTML = html;

	    function renderRow(row, widths, height) {
	      var rowHtml = "<div class=\"webix_color_row\" role=\"row\">";

	      for (var cell = 0; cell < row.length; cell++) {
	        data.width = widths[cell];
	        data.height = height;
	        data.val = row[cell];
	        rowHtml += itemTpl(data);
	      }

	      rowHtml += "</div>";
	      return rowHtml;
	    }

	    this._selectBox = null;
	    if (this._settings.value) this.$setValue(this._settings.value);else this._viewobj.lastChild.childNodes[0].childNodes[0].setAttribute("tabindex", "0");
	    this.callEvent("onAfterRender", []);
	  },
	  refresh: function () {
	    this.render();
	  }
	};
	var view$t = exports.protoUI(api$t, KeysNavigation, base.view, EventSystem);

	var api$u = {
	  name: "button",
	  touchable: true,
	  $skin: function () {
	    this.defaults.height = $active.buttonHeight || $active.inputHeight; //used in "text"

	    this._labelTopHeight = $active.labelTopHeight || 15;
	    this._borderWidth = $active.borderWidth;
	  },
	  defaults: {
	    template: function (obj, common) {
	      var text = common.$renderInput(obj, common);
	      if (obj.badge) text = text.replace("</button>", "<span class='webix_badge'>" + obj.badge + "</span></button>");
	      return "<div class='webix_el_box' style='width:" + obj.awidth + "px; height:" + obj.aheight + "px'>" + text + "</div>";
	    },
	    label: "",
	    borderless: true
	  },
	  $renderInput: function (obj) {
	    var css = "class='webixtype_" + (obj.type || "base") + "' ";
	    return "<button type='button' " + (obj.popup ? "aria-haspopup='true'" : "") + css + ">" + template.escape(obj.label || obj.value) + "</button>";
	  },
	  $init: function () {
	    this._viewobj.className += " webix_control webix_el_" + (this.$cssName || this.name);
	    this.data = this._settings;
	    this._dataobj = this._viewobj;
	    this.$ready.push(function () {
	      this._calc_size(this.config);
	    });
	  },
	  hotkey_setter: function (key) {
	    var control = this;

	    this._addElementHotKey(key, function (view, ev) {
	      if (control.isVisible()) {
	        var elem = control.$view.firstChild;
	        triggerEvent(elem, "MouseEvents", "click");
	        preventEvent(ev);
	      }
	    });
	  },
	  _addElementHotKey: function (key, func, view) {
	    var keyCode = UIManager.addHotKey(key, func, view);
	    this.attachEvent("onDestruct", function () {
	      UIManager.removeHotKey(keyCode, func, view);
	    });
	  },
	  type_setter: function (value) {
	    if (this._types[value]) this.$renderInput = template(this._types[value]);
	    if (value == "prev" || value == "next") this._set_inner_size = this._set_inner_size_next;else this._set_inner_size = false;
	    return value;
	  },
	  _types: {
	    htmlbutton: "<button type='button' class='webix_el_htmlbutton webixtype_base'>#label#</button>",
	    prev: "<input type='button' class='webixtype_prev' value='#label#' /><div class='webix_el_arrow webixtype_prev_arrow'></div>",
	    next: "<input type='button' class='webixtype_next' value='#label#' /><div class='webix_el_arrow webixtype_next_arrow'></div>",
	    imageButton: "<button type='button' class='webix_img_btn_abs webixtype_base' style='width:100%; line-height:#cheight#px'><div class='webix_image' style='width:#dheight#px;height:#dheight#px;background-image:url(#image#);'></div>#label#</button>",
	    imageButtonTop: "<button type='button' class='webix_img_btn_abs webix_img_btn_abs_top webixtype_base'><div class='webix_image' style='width:100%;height:100%;background-image:url(#image#);'></div><div class='webix_img_btn_text'>#label#</div></button>",
	    image: "<button type='button' class='webix_img_btn' style='line-height:#cheight#px;'><div class='webix_image' style='width:#cheight#px;height:#cheight#px;background-image:url(#image#);'></div>#label#</button>",
	    imageTop: "<button type='button' class='webix_img_btn_top'><div class='webix_image' style='width:100%;height:100%;background-image:url(#image#);'></div><div class='webix_img_btn_text'>#label#</div></button>",
	    icon: "<button type='button' class='webix_img_btn' style='line-height:#cheight#px;'><span class='webix_icon_btn #icon#' style='max-width:#cheight#px;'></span>#label#</button>",
	    iconButton: "<button type='button' class='webix_img_btn_abs webixtype_base' style='width:100%;'><span class='webix_icon #icon#'></span>#label#</button>",
	    iconTop: "<button type='button' class='webix_img_btn_top' style='width:100%;top:4px;text-align:center;'><span class='webix_icon #icon#'></span><div class='webix_img_btn_text'>#label#</div></button>",
	    iconButtonTop: "<button type='button' class='webix_img_btn_abs webix_img_btn_abs_top webixtype_base' style='width:100%;top:0px;text-align:center;'><span class='webix_icon #icon#'></span><div class='webix_img_btn_text'>#label#</div></button>"
	  },
	  _findAllInputs: function () {
	    var result = [];
	    var tagNames = ["input", "select", "textarea", "button"];

	    for (var i = 0; i < tagNames.length; i++) {
	      var inputs = this.$view.getElementsByTagName(tagNames[i]);

	      for (var j = 0; j < inputs.length; j++) {
	        result.push(inputs[j]);
	      }
	    }

	    return result;
	  },
	  disable: function () {
	    var i,
	        node,
	        elem = this._getBox();

	    baseview.api.disable.apply(this, arguments);

	    if (elem && elem.className.indexOf(" webix_disabled_box") == -1) {
	      elem.className += " webix_disabled_box";

	      var inputs = this._findAllInputs();

	      for (i = 0; i < inputs.length; i++) {
	        inputs[i].setAttribute("disabled", true);
	      } // richselect and based on it


	      node = this.getInputNode();

	      if (node && node.tagName.toLowerCase() == "div") {
	        this._disabledTabIndex = node.getAttribute("tabIndex");
	        node.removeAttribute("tabIndex");
	      }

	      if (this._settings.labelPosition == "top") {
	        var label = this._dataobj.firstChild;
	        if (label) label.className += " webix_disabled_top_label";
	      }
	    }
	  },
	  enable: function () {
	    baseview.api.enable.apply(this, arguments);

	    var node,
	        elem = this._getBox();

	    if (elem) {
	      elem.className = elem.className.replace(" webix_disabled_box", "");

	      var inputs = this._findAllInputs();

	      for (var i = 0; i < inputs.length; i++) {
	        inputs[i].removeAttribute("disabled");
	      }

	      node = this.getInputNode();
	      if (node && !isUndefined(this._disabledTabIndex)) node.setAttribute("tabIndex", this._disabledTabIndex);

	      if (this._settings.labelPosition == "top") {
	        var label = this._dataobj.firstChild;
	        if (label) label.className = label.className.replace(" webix_disabled_top_label", "");
	      }
	    }
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      this.render();
	    }
	  },
	  setValue: function (value) {
	    value = this.$prepareValue(value);
	    var oldvalue = this._settings.value;
	    if (this.$compareValue(oldvalue, value)) return false;
	    this._settings.value = value;
	    if (this._rendered_input) this.$setValue(value);
	    this.callEvent("onChange", [value, oldvalue]);
	  },
	  $compareValue: function (oldvalue, value) {
	    if (typeof value === "number") value = value.toString();
	    if (typeof oldvalue === "number") oldvalue = oldvalue.toString();
	    return oldvalue == value;
	  },
	  $prepareValue: function (value) {
	    return this._pattern(value, false);
	  },
	  _pattern: function (value) {
	    return value === 0 ? "0" : (value || "").toString();
	  },
	  //visual part of setValue
	  $setValue: function (value) {
	    //		this._settings.label = value;
	    var node = this.getInputNode();

	    if (node) {
	      if (node.tagName == "BUTTON") node.innerHTML = value;else node.value = value;
	    }
	  },
	  getValue: function () {
	    //if button was rendered - returning actual value
	    //otherwise - returning last set value
	    var value = this._rendered_input ? this.$getValue() : this._settings.value;
	    return typeof value == "undefined" ? "" : value;
	  },
	  $getValue: function () {
	    return this._settings.value || "";
	  },
	  focus: function () {
	    if (!UIManager.canFocus(this)) return false;
	    var input = this.getInputNode();
	    if (input && input.focus) input.focus();
	  },
	  blur: function () {
	    var input = this.getInputNode();
	    if (input && input.blur) input.blur();
	  },
	  //get input element
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("input")[0] || this._dataobj.getElementsByTagName("button")[0];
	  },
	  //get top-level sub-container
	  _getBox: function () {
	    for (var i = 0; i < this._dataobj.childNodes.length; i++) {
	      if (this._dataobj.childNodes[i].className.indexOf("webix_el_box") >= 0) return this._dataobj.childNodes[i];
	    }

	    return null;
	  },
	  _get_tooltip_data: function (t, e) {
	    var node = e.target || e.srcElement;

	    var box = this._getBox();

	    if (box && box.contains(node)) return this._settings;
	    return null;
	  },
	  _sqrt_2: Math.sqrt(2),
	  _set_inner_size_next: function () {
	    var cfg = this._settings;

	    var arrow = this._getBox().childNodes[1];

	    var button = arrow.previousSibling;
	    var style = cfg.type == "next" ? "right" : "left";
	    var height = cfg.aheight - $active.inputPadding * 2 - 2 * this._borderWidth; //-2 - borders

	    var arrowEdge = height * this._sqrt_2 / 2;
	    arrow.style.width = arrowEdge + "px";
	    arrow.style.height = arrowEdge + "px";
	    arrow.style.top = (height - arrowEdge) / 2 + $active.inputPadding + "px";
	    arrow.style[style] = (height - arrowEdge) / 2 + this._sqrt_2 / 2 + "px";
	    button.style.width = cfg.awidth - height / 2 - 2 + "px";
	    button.style.height = height + 2 + "px";
	    button.style[style] = height / 2 + 2 + "px";
	    button.style.top = $active.inputPadding + "px";
	  },
	  _calc_size: function (config) {
	    config = config || this._settings;
	    if (config.autowidth) config.width = getTextSize(config.value || config.label || "", "webixbutton").width + (config.badge ? 16 : 0) + (config.type === "iconButton" || config.type === "icon" ? 24 : 0) + (config.type === "imageButton" || config.type === "image" ? config.height - $active.inputPadding : 0);
	  },
	  _calck_input_size: function () {
	    //use width for both width and inputWidth settings in clever way
	    //in form, we can define width for some element smaller than for siblings
	    //it will use inputWidth to render the desired view
	    this._input_width = this._settings.inputWidth || (this._content_width - this._settings.width > 2 ? this._settings.width : 0) || this._content_width;
	    this._input_height = this._settings.inputHeight || this._inputHeight || 0;
	  },
	  resize: function () {
	    this._calc_size();

	    return base.api.resize.apply(this, arguments);
	  },
	  render: function () {
	    this._calck_input_size();

	    this._settings.awidth = this._input_width || this._content_width;
	    this._settings.aheight = this._input_height || this._content_height; //image button - image width

	    this._settings.bheight = this._settings.aheight + 2;
	    this._settings.cheight = this._settings.aheight - 2 * $active.inputPadding;
	    this._settings.dheight = this._settings.cheight - 2; // - borders

	    if (AtomRender.render.call(this)) {
	      this._rendered_input = true;
	      if (this._set_inner_size) this._set_inner_size();

	      if (this._settings.align) {
	        var handle = this._dataobj.firstChild;
	        if (this._settings.labelPosition == "top" && handle.nextSibling) handle = handle.nextSibling;

	        switch (this._settings.align) {
	          case "right":
	            handle.style.cssFloat = "right";
	            break;

	          case "center":
	            handle.style.display = "inline-block";
	            handle.parentNode.style.textAlign = "center";
	            break;

	          case "middle":
	            handle.style.marginTop = Math.round((this._content_height - this._input_height) / 2) + "px";
	            break;

	          case "bottom":
	            handle.style.marginTop = this._content_height - this._input_height + "px";
	            break;

	          case "left":
	            handle.style.cssFloat = "left";
	            break;

	          default:
	            assert(false, "Unknown align mode: " + this._settings.align);
	            break;
	        }
	      }

	      if (this.$render) this.$render(this.data);
	      if (this._settings.disabled) this.disable();

	      if (this._init_once) {
	        this._init_once(this.data);

	        this._init_once = 0;
	      }
	    }
	  },
	  refresh: function () {
	    this.render();
	  },
	  on_click: {
	    _handle_tab_click: function (ev) {
	      var id = locate(ev, "button_id");

	      if (id && this.callEvent("onBeforeTabClick", [id, ev])) {
	        this.setValue(id);
	        this.callEvent("onAfterTabClick", [id, ev]);
	      }
	    },
	    webix_all_segments: function (ev, button) {
	      this.on_click._handle_tab_click.call(this, ev, button);
	    },
	    webix_all_tabs: function (ev, button) {
	      this.on_click._handle_tab_click.call(this, ev, button);
	    },
	    webix_inp_counter_next: function () {
	      if (!this._settings.readonly) this.next();
	    },
	    webix_inp_counter_prev: function () {
	      if (!this._settings.readonly) this.prev();
	    },
	    webix_input_icon: function () {
	      this.getInputNode().focus();
	    },
	    webix_inp_checkbox_border: function (e) {
	      if (!this._settings.disabled && (e.target || e.srcElement).tagName != "DIV" && !this._settings.readonly) this.toggle();
	    },
	    webix_inp_checkbox_label: function () {
	      if (!this._settings.readonly) this.toggle();
	    },
	    webix_inp_radio_border: function (e) {
	      var value = locate(e, "radio_id");
	      this.setValue(value);
	      this.focus();
	    },
	    webix_inp_radio_label: function (e, obj, node) {
	      node = node.parentNode.getElementsByTagName("input")[0];
	      return this.on_click.webix_inp_radio_border.call(this, node, obj, node);
	    },
	    webix_tab_more_icon: function (ev, obj, node) {
	      this.getPopup().resize();
	      this.getPopup().show(node, null, true);
	    },
	    webix_tab_close: function (ev) {
	      var id = locate(ev, "button_id");
	      if (id && this.callEvent("onBeforeTabClose", [id, ev])) this.removeOption(id);
	    }
	  },
	  //method do not used by button, but  used by other child-views
	  _check_options: function (opts) {
	    assert(opts, this.name + ": options not defined");

	    for (var i = 0; i < opts.length; i++) {
	      // asserts need to be removed in final version			
	      assert(!opts[i].text, "Please replace .text with .value in control config");
	      assert(!opts[i].label, "Please replace .label with .value in control config");

	      if (typeof opts[i] == "string") {
	        opts[i] = {
	          id: opts[i],
	          value: opts[i]
	        };
	      } else {
	        if (isUndefined(opts[i].id)) opts[i].id = opts[i].value;
	        if (isUndefined(opts[i].value)) opts[i].value = opts[i].id;
	      }
	    }

	    return opts;
	  },
	  _get_div_placeholder: function (obj) {
	    var placeholder = obj ? obj.placeholder : this._settings.placeholder;
	    return placeholder ? "<span class='webix_placeholder'>" + placeholder + "</span>" : "";
	  }
	};
	var view$u = exports.protoUI(api$u, base.view, AutoTooltip, AtomRender, Settings, EventSystem);
	var button$1 = {
	  api: api$u,
	  view: view$u
	};

	var api$v = {
	  name: "label",
	  defaults: {
	    template: "<div class='webix_el_box' style='width:#awidth#px;height:#aheight#px;line-height:#cheight#px'>#label#</div>"
	  },
	  $skin: function () {
	    this.defaults.height = $active.inputHeight;
	  },
	  focus: function () {
	    return false;
	  },
	  _getBox: function () {
	    return this._dataobj.firstChild;
	  },
	  setHTML: function (html) {
	    this._settings.label = html;
	    this.refresh();
	  },
	  setValue: function (value) {
	    this._settings.label = value;
	    button$1.api.setValue.apply(this, arguments);
	  },
	  $setValue: function (value) {
	    this._dataobj.firstChild.innerHTML = value;
	  },
	  _set_inner_size: function () {},
	  _calc_size: function (config) {
	    config = config || this._settings;
	    if (config.autowidth) config.width = getTextSize(config.value || config.label, "webix_el_label").width;
	  }
	};
	var view$v = exports.protoUI(api$v, button$1.view);

	var controls = {};

	for (var i in UIManager._controls) {
	  controls[UIManager._controls[i]] = i;
	}

	var nav_controls = {
	  9: "tab",
	  38: "up",
	  40: "down",
	  37: "left",
	  39: "right"
	};
	var TextPattern = {
	  $init: function (config) {
	    var pattern = this.defaults.pattern || config.pattern;
	    var format = this.defaults.format || config.format;
	    config.value = isUndefined(config.value) ? "" : config.value;

	    if (pattern || format && !this.format_setter) {
	      this.attachEvent("onKeyPress", function (code, e) {
	        if (e.ctrlKey || e.altKey || this._custom_format) return;
	        if (code > 105 && code < 112) //numpad operators
	          code -= 64;

	        if (controls[code] && code !== 8 && code !== 46) {
	          //del && bsp
	          if (!nav_controls[code]) preventEvent(e);
	          return;
	        }

	        preventEvent(e);

	        this._on_key_pressed(e, code);
	      });
	      this.attachEvent("onAfterRender", this._after_render);

	      this.getText = function () {
	        return this.getInputNode().value;
	      };

	      this._pattern = function (value, mode) {
	        if (mode === false) return this._getRawValue(value);else return this._matchPattern(value);
	      };

	      if (format) {
	        if (_typeof(format) === "object") {
	          this._custom_format = format;
	        } else {
	          format = Number$1.getConfig(format);
	          this._custom_format = {
	            parse: function (value) {
	              return Number$1.parse(value, format);
	            },
	            edit: function (value) {
	              return Number$1.format(value, format);
	            }
	          };
	        }
	      }
	    }
	  },
	  pattern_setter: function (value) {
	    var pattern = patterns[value] || value;
	    if (typeof pattern == "string") pattern = {
	      mask: pattern
	    };
	    pattern.allow = pattern.allow || /[A-Za-z0-9]/g;

	    this._patternScheme(pattern);

	    return pattern;
	  },
	  _init_validation: function () {
	    this.config.validate = this.config.validate || bind(function () {
	      var value = this.getText();
	      var raw = value.replace(this._pattern_chars, "");
	      var matches = (value.toString().match(this._pattern_allows) || []).join("");
	      return matches.length == raw.length && value.length == this._settings.pattern.mask.length;
	    }, this);
	  },
	  _after_render: function () {
	    var ev = env.isIE8 ? "propertychange" : "input";
	    if (!this._custom_format) _event(this.getInputNode(), ev, function () {
	      var stamp = new Date().valueOf(); //dark ie8 magic

	      var width = this.$view.offsetWidth; //eslint-disable-line

	      if (!this._property_stamp || stamp - this._property_stamp > 100) {
	        this._property_stamp = stamp;
	        this.$setValue(this.getText());
	      }
	    }, {
	      bind: this
	    });

	    _event(this.getInputNode(), "blur", function () {
	      this._applyChanges();
	    }, {
	      bind: this
	    });
	  },
	  _patternScheme: function (pattern) {
	    var mask = pattern.mask,
	        scheme = {},
	        chars = "",
	        count = 0;

	    for (var i = 0; i < mask.length; i++) {
	      if (mask[i] === "#") {
	        scheme[i] = count;
	        count++;
	      } else {
	        scheme[i] = false;
	        if (chars.indexOf(mask[i]) === -1) chars += "\\" + mask[i];
	      }
	    }

	    this._pattern_allows = pattern.allow;
	    this._pattern_chars = new RegExp("[" + chars + "]", "g");
	    this._pattern_scheme = scheme;

	    this._init_validation();
	  },
	  _on_key_pressed: function (e, code) {
	    var node = this.getInputNode();
	    var value = node.value;
	    var pos$$1 = getSelectionRange(node);
	    var chr = "";

	    if (code == 8 || code == 46) {
	      if (pos$$1.start == pos$$1.end) {
	        if (code == 8) pos$$1.start--;else pos$$1.end++;
	      }
	    } else {
	      chr = String.fromCharCode(code);
	      if (!e.shiftKey) chr = chr.toLowerCase();
	    }

	    value = value.substr(0, pos$$1.start) + chr + value.substr(pos$$1.end);
	    pos$$1 = this._getCaretPos(chr, value.length, pos$$1.start, code);
	    this._input_code = code;
	    this.$setValue(value);
	    setSelectionRange(node, pos$$1);
	  },
	  _getCaretPos: function (chr, len, pos$$1, code) {
	    if (chr && chr.match(this._pattern_allows) || code == 8 || code == 46) {
	      pos$$1 = chr ? pos$$1 + 1 : pos$$1;
	      pos$$1 = this._fixCaretPos(pos$$1, code);
	    } else if (len - 1 == pos$$1 && code !== 8 && code !== 46) {
	      var rest = this._settings.pattern.mask.indexOf("#", pos$$1);

	      if (rest > 0) pos$$1 += rest;
	    }

	    return pos$$1;
	  },
	  _fixCaretPos: function (pos$$1, code) {
	    var prev = pos$$1 - (code !== 46) * 1;

	    if (this._pattern_scheme[prev] === false) {
	      pos$$1 = pos$$1 + (code == 8 ? -1 : 1);
	      return this._fixCaretPos(pos$$1, code);
	    }

	    if (this._pattern_scheme[pos$$1] === false && code !== 8) return this._fixCaretPos(pos$$1 + 1, code) - 1;
	    return pos$$1;
	  },
	  _getRawValue: function (value) {
	    if (this._custom_format) return this._custom_format.parse(value);
	    value = value || value === 0 ? value : "";
	    var matches = value.toString().match(this._pattern_allows) || [];
	    return matches.join("").replace(this._pattern_chars, "");
	  },
	  _matchPattern: function (value) {
	    if (this._custom_format) return this._custom_format.edit(this._custom_format.parse(value));

	    var raw = this._getRawValue(value),
	        pattern = this._settings.pattern.mask,
	        mask = this._settings.pattern.mask,
	        scheme = this._pattern_scheme,
	        end = false,
	        index$$1 = 0,
	        rawIndex = 0,
	        rawLength = 0;

	    for (var i in scheme) {
	      if (scheme[i] !== false) {
	        if (!end) {
	          index$$1 = i * 1;
	          rawIndex = scheme[i];
	          var rchar = raw[rawIndex] || "";
	          var next = raw[rawIndex + 1];
	          pattern = (rchar ? pattern.substr(0, index$$1) : "") + rchar + (rchar && next ? pattern.substr(index$$1 + 1) : "");
	          if (!next) end = true;
	        }

	        rawLength++;
	      }
	    } //finalize value with subsequent mask chars 


	    var icode = this._input_code;

	    if (icode && icode !== 8 || !icode && rawLength - 1 === rawIndex && pattern.length < mask.length) {
	      if (raw) {
	        var nind = index$$1 + 1;

	        if (mask.charAt(nind) !== "#" && pattern.length < mask.length) {
	          var lind = mask.indexOf("#", nind);
	          if (lind < 0) lind = mask.length;
	          pattern += mask.substr(nind, lind - nind);
	        }
	      } else if (icode !== 46) {
	        pattern += mask.substr(0, mask.indexOf("#"));
	      }
	    }

	    this._input_code = null;
	    return pattern;
	  }
	};

	var api$w = {
	  name: "text",
	  $allowsClear: true,
	  _init_onchange: function () {
	    if (this.$allowsClear) {
	      //attach onChange handler only for controls which do not manage blur on their own
	      //for example - combo
	      if (!this._onBlur) _event(this.getInputNode(), "change", this._applyChanges, {
	        bind: this
	      });
	      if (this._settings.suggest) $$(this._settings.suggest).linkInput(this);
	    }
	  },
	  _applyChanges: function () {
	    var newvalue = this.getValue();
	    var res = this.setValue(newvalue, true); //controls with post formating, we need to repaint value

	    if (this._custom_format && res === false) {
	      this.$setValue(newvalue);
	    }
	  },
	  $skin: function () {
	    this.defaults.height = $active.inputHeight;
	    this.defaults.inputPadding = $active.inputPadding;
	    this._inputSpacing = $active.inputSpacing;
	  },
	  $init: function (config) {
	    if (config.labelPosition == "top") if (isUndefined(config.height) && this.defaults.height) // textarea
	      config.height = this.defaults.height + (config.label ? this._labelTopHeight : 0); //suggest reference for destructor

	    this._destroy_with_me = [];
	    this.attachEvent("onAfterRender", this._init_onchange);
	    this.attachEvent("onBlur", function () {
	      if (this._onBlur) this._onBlur();
	    });
	  },
	  $renderIcon: function () {
	    var config = this._settings;

	    if (config.icon) {
	      var height = config.aheight - 2 * config.inputPadding,
	          padding = (height - 18) / 2 - 1,
	          aria = this.addSection ? "role='button' tabindex='0' aria-label='" + i18n.aria["multitext" + (config.mode || "") + "Section"] + "'" : "";
	      return "<span style='height:" + (height - padding) + "px;padding-top:" + padding + "px;' class='webix_input_icon " + config.icon + "' " + aria + "></span>";
	    }

	    return "";
	  },
	  relatedView_setter: function (value) {
	    this.attachEvent("onChange", function () {
	      var value = this.getValue();
	      var mode = this._settings.relatedAction;
	      var viewid = this._settings.relatedView;
	      var view = $$(viewid);

	      if (!view) {
	        var top = this.getTopParentView();
	        if (top && top.$$) view = top.$$(viewid);
	      }

	      assert(view, "Invalid relatedView: " + viewid);

	      if (mode == "enable") {
	        if (value) view.enable();else view.disable();
	      } else {
	        if (value) view.show();else view.hide();
	      }
	    });
	    return value;
	  },
	  validateEvent_setter: function (value) {
	    if (value == "blur") this.attachEvent("onBlur", this.validate);
	    if (value == "key") this.attachEvent("onTimedKeyPress", this.validate);
	    return value;
	  },
	  validate: function () {
	    var rule = this._settings.validate;
	    if (!rule && this._settings.required) rule = rules.isNotEmpty;
	    var form = this.getFormView();
	    var name = this._settings.name;
	    var value = this.getValue();
	    var data = {};
	    data[name] = value;
	    assert(form, "Validation works only for fields in the form");
	    assert(name, "Validation works only for fields with name");
	    if (rule && !form._validate(rule, value, data, name)) return false;
	    return true;
	  },
	  bottomLabel_setter: function (value) {
	    if (!this._settings.bottomPadding) this._settings.bottomPadding = 18;
	    return value;
	  },
	  _getInvalidText: function () {
	    var text = this._settings.invalidMessage;

	    if (typeof text == "function") {
	      text.call(this);
	    }

	    return text;
	  },
	  setBottomText: function (text, height) {
	    var config = this._settings;

	    if (typeof text != "undefined") {
	      if (config.bottomLabel == text) return;
	      config.bottomLabel = text;
	    }

	    var message = (config.invalid ? config.invalidMessage : "") || config.bottomLabel;
	    if (!message && !config.bottomPadding) config.inputHeight = 0;

	    if (message && !config.bottomPadding) {
	      this._restorePadding = 1;
	      config.bottomPadding = config.bottomPadding || height || 18;
	      this.render();
	      this.resize();
	    } else if (!message && this._restorePadding) {
	      config.bottomPadding = this._restorePadding = 0; //textarea

	      if (!config.height) this.render();
	      this.resize();
	    } else this.render();
	  },
	  $getSize: function () {
	    var sizes = base.api.$getSize.apply(this, arguments);
	    var heightInc = this.config.bottomPadding;

	    if (heightInc) {
	      sizes[2] += heightInc;
	      sizes[3] += heightInc;
	    }

	    return sizes;
	  },
	  $setSize: function (x, y) {
	    var config = this._settings;

	    if (base.api.$setSize.call(this, x, y)) {
	      if (!x || !y) return;

	      if (config.labelPosition == "top") {
	        // textarea
	        if (!config.inputHeight) this._inputHeight = this._content_height - (config.label ? this._labelTopHeight : 0) - (this.config.bottomPadding || 0);
	        config.labelWidth = 0;
	      } else if (config.bottomPadding) {
	        config.inputHeight = this._content_height - this.config.bottomPadding;
	      }

	      this.render();
	    }
	  },
	  _get_input_width: function (config) {
	    var width = (this._input_width || 0) - (config.label ? this._settings.labelWidth : 0) - this._inputSpacing - (config.iconWidth || 0); //prevent js error in IE

	    return width < 0 ? 0 : width;
	  },
	  _render_div_block: function (obj, common) {
	    var id = "x" + uid();

	    var width = common._get_input_width(obj);

	    var inputAlign = obj.inputAlign || "left";
	    var height = this._settings.aheight - 2 * $active.inputPadding - 2 * this._borderWidth;

	    var text = obj.text || obj.value || this._get_div_placeholder(obj);

	    var html = "<div class='webix_inp_static' role='combobox' aria-label='" + template.escape(obj.label) + "' tabindex='0'" + (obj.readonly ? " aria-readonly='true'" : "") + (obj.invalid ? "aria-invalid='true'" : "") + " onclick='' style='line-height:" + height + "px;width: " + width + "px; text-align: " + inputAlign + ";' >" + text + "</div>";
	    return common.$renderInput(obj, html, id);
	  },
	  _baseInputHTML: function (tag) {
	    var html = "<" + tag + (this._settings.placeholder ? " placeholder='" + this._settings.placeholder + "' " : " ");
	    if (this._settings.readonly) html += "readonly='true' aria-readonly=''";
	    if (this._settings.required) html += "aria-required='true'";
	    if (this._settings.invalid) html += "aria-invalid='true'";
	    var attrs = this._settings.attributes;
	    if (attrs) for (var prop in attrs) {
	      html += prop + "='" + attrs[prop] + "' ";
	    }
	    return html;
	  },
	  $renderLabel: function (config, id) {
	    var label = "";

	    if (config.label) {
	      var labelAlign = config.labelAlign || "left";
	      var top = this._settings.labelPosition == "top";
	      var labelTop = top ? "display:block;" : "width: " + this._settings.labelWidth + "px;";

	      var labelHeight = this._getLabelHeight(top);

	      label = "<label style='" + labelTop + "text-align: " + labelAlign + ";line-height:" + labelHeight + "px;' onclick='' for='" + id + "' class='webix_inp_" + (top ? "top_" : "") + "label " + (config.required ? "webix_required" : "") + "'>" + (config.label || "") + "</label>";
	    }

	    return label;
	  },
	  _getLabelHeight: function (top) {
	    return top ? this._labelTopHeight - this._settings.inputPadding : this._settings.aheight - 2 * this._settings.inputPadding;
	  },
	  $renderInput: function (config, div_start, id) {
	    var inputAlign = config.inputAlign || "left";
	    var top = config.labelPosition == "top";

	    var inputWidth = this._get_input_width(config);

	    id = id || uid();
	    var label = this.$renderLabel(config, id);
	    var html = "";

	    if (div_start) {
	      html += div_start;
	    } else {
	      var value = template.escape(config.text || this._pattern(config.value));
	      html += this._baseInputHTML("input") + "id='" + id + "' type='" + (config.type || this.name) + "'" + (config.editable ? " role='combobox'" : "") + " value='" + value + "' style='width: " + inputWidth + "px; text-align: " + inputAlign + ";'";
	      var attrs = config.attributes;
	      if (attrs) for (var prop in attrs) {
	        html += " " + prop + "='" + attrs[prop] + "'";
	      }
	      html += " />";
	    }

	    var icon = this.$renderIcon ? this.$renderIcon(config) : "";
	    html += icon;
	    var result = ""; //label position, top or left

	    if (top) result = label + "<div class='webix_el_box' style='width:" + config.awidth + "px; height:" + config.aheight + "px'>" + html + "</div>";else result = "<div class='webix_el_box' style='width:" + config.awidth + "px; height:" + config.aheight + "px'>" + label + html + "</div>"; //bottom message width

	    var padding = config.awidth - inputWidth - $active.inputPadding * 2; //bottom message text

	    var message = (config.invalid ? config.invalidMessage : "") || config.bottomLabel;
	    if (message) result += "<div class='webix_inp_bottom_label'" + (config.invalid ? "role='alert' aria-relevant='all'" : "") + " style='width:" + (inputWidth || config.awidth) + "px;margin-left:" + Math.max(padding, $active.inputPadding) + "px;'>" + message + "</div>";
	    return result;
	  },
	  defaults: {
	    template: function (obj, common) {
	      return common.$renderInput(obj);
	    },
	    label: "",
	    labelWidth: 80
	  },
	  type_setter: function (value) {
	    return value;
	  },
	  _set_inner_size: false,
	  $setValue: function (value) {
	    this.getInputNode().value = this._pattern(value);
	  },
	  $getValue: function () {
	    return this._pattern(this.getInputNode().value, false);
	  },
	  suggest_setter: function (value) {
	    if (value) {
	      assert(value !== true, "suggest options can't be set as true, data need to be provided instead");

	      if (typeof value == "string") {
	        var attempt = $$(value);
	        if (attempt) return $$(value)._settings.id;
	        value = {
	          body: {
	            url: value,
	            dataFeed: value
	          }
	        };
	      } else if (value.getItem) value = {
	        body: {
	          data: value
	        }
	      };else if (isArray(value)) value = {
	        body: {
	          data: this._check_options(value)
	        }
	      };else if (!value.body) value.body = {};

	      exports.extend(value, {
	        view: "suggest"
	      });
	      var view = ui(value);

	      this._destroy_with_me.push(view);

	      return view._settings.id;
	    }

	    return false;
	  }
	};
	var view$w = exports.protoUI(api$w, TextPattern, button$1.view);
	var text = {
	  api: api$w,
	  view: view$w
	};

	var DataCollection = exports.proto({
	  name: "DataCollection",
	  isVisible: function () {
	    if (!this.data.order.length && !this.data._filter_order && !this._settings.dataFeed) return false;
	    return true;
	  },
	  $init: function (config) {
	    this.data.provideApi(this, true);
	    var id = config && config.id ? config.id : uid();
	    this._settings.id = id;
	    ui.views[id] = this;
	    this.data.attachEvent("onStoreLoad", bind(function () {
	      this.callEvent("onBindRequest", []);
	    }, this));
	  },
	  refresh: function () {
	    this.callEvent("onBindRequest", []);
	  }
	}, DataMove, CollectionBind, BindSource, ValidateCollection, DataLoader, MapCollection, EventSystem, BaseBind, Destruction, Settings);
	define("DataCollection", DataCollection);

	var api$x = {
	  name: "select",
	  defaults: {
	    template: function (obj, common) {
	      var options = common._check_options(obj.options);

	      var id = "x" + uid();
	      var html = common._baseInputHTML("select") + "id='" + id + "' style='width:" + common._get_input_width(obj) + "px;'>";
	      var optview = $$(options);

	      if (optview && optview.data && optview.data.each) {
	        optview.data.each(function (option) {
	          html += "<option" + (option.id == obj.value ? " selected='true'" : "") + " value='" + option.id + "'>" + option.value + "</option>";
	        });
	      } else for (var i = 0; i < options.length; i++) {
	        html += "<option" + (options[i].id == obj.value ? " selected='true'" : "") + " value='" + options[i].id + "'>" + options[i].value + "</option>";
	      }

	      html += "</select>";
	      return common.$renderInput(obj, html, id);
	    }
	  },
	  options_setter: function (value) {
	    if (value) {
	      if (typeof value == "string") {
	        var collection = new DataCollection({
	          url: value
	        });
	        collection.data.attachEvent("onStoreLoad", bind(this.refresh, this));
	        return collection;
	      } else return value;
	    }
	  },
	  //get input element
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("select")[0];
	  }
	};
	var view$x = exports.protoUI(api$x, text.view);

	var api$y = {
	  name: "checkbox",
	  defaults: {
	    checkValue: 1,
	    uncheckValue: 0,
	    template: function (config, common) {
	      var id = "x" + uid();
	      var rightlabel = "";

	      if (config.labelRight) {
	        rightlabel = "<label class='webix_label_right'>" + config.labelRight + "</label>"; //user clearly attempts to hide the label, help him

	        if (config.labelWidth) config.label = config.label || "&nbsp;";
	      }

	      var checked = config.checkValue == config.value;
	      var margin = Math.floor((common._settings.aheight - 16) / 2);
	      var ch = common._baseInputHTML("input") + "style='margin-top:" + margin + "px;" + (config.customCheckbox ? "display:none" : "") + "' id='" + id + "' type='checkbox' " + (checked ? "checked='1'" : "") + (config.labelRight ? " aria-label='" + template.escape(config.labelRight) + "'" : "") + "/>";
	      var className = "webix_inp_checkbox_border webix_el_group webix_checkbox_" + (checked ? "1" : "0");
	      var customCheckbox = config.customCheckbox || "";

	      if (customCheckbox) {
	        customCheckbox = customCheckbox.replace(/(aria-checked=')\w*(?=')/, "$1" + (config.value == config.checkValue ? "true" : "false"));
	        customCheckbox = customCheckbox.replace(/(aria-label=')\w*(?=')/, "$1" + template.escape(config.labelRight || config.label));
	        customCheckbox = customCheckbox.replace(/(aria-invalid=')\w*(?=')/, "$1" + (config.invalid ? "true" : "false"));
	      }

	      var html = "<div style='line-height:" + common._settings.cheight + "px' class='" + className + "'>" + ch + customCheckbox + rightlabel + "</div>";
	      return common.$renderInput(config, html, id);
	    }
	  },
	  customCheckbox_setter: function (value) {
	    if (value === true && $active.customCheckbox) {
	      value = "<a role='presentation' onclick='javascript:void(0)'><button role='checkbox' aria-checked='false' aria-label='' type='button' aria-invalid='' class='webix_custom_checkbox'></button></a>";
	    }

	    return value;
	  },
	  blur: function () {
	    var input = this.getInputNode();
	    if (input) input.blur();
	  },
	  _pattern: function (value) {
	    return value;
	  },
	  _init_onchange: function () {},
	  $setValue: function (value) {
	    var isChecked = value == this._settings.checkValue;
	    var input = this.$view.getElementsByTagName("input")[0];
	    var parentNode = input ? input.parentNode : null;

	    if (parentNode && this._settings.customCheckbox) {
	      var button = parentNode.getElementsByTagName("BUTTON");
	      if (button[0]) button[0].setAttribute("aria-checked", isChecked ? "true" : "false");
	    }

	    if (parentNode) {
	      parentNode.className = parentNode.className.replace(/(webix_checkbox_)\d/, "$1" + (isChecked ? 1 : 0));
	    }

	    input.checked = isChecked;
	  },
	  toggle: function () {
	    var value = this.getValue() != this._settings.checkValue ? this._settings.checkValue : this._settings.uncheckValue;
	    this.setValue(value);
	  },
	  getValue: function () {
	    var value = this._settings.value;
	    return value == this._settings.checkValue ? this._settings.checkValue : this._settings.uncheckValue;
	  },
	  getInputNode: function () {
	    return this.$view.getElementsByTagName(this._settings.customCheckbox ? "button" : "input")[0];
	  },
	  $skin: function () {
	    this.defaults.customCheckbox = !!$active.customCheckbox;
	  }
	};
	var view$y = exports.protoUI(api$y, text.view);
	var checkbox = {
	  api: api$y,
	  view: view$y
	};

	var api$z = {
	  name: "radio",
	  defaults: {
	    template: function (config, common) {
	      var options = common._check_options(config.options);

	      var html = [];
	      var id;

	      for (var i = 0; i < options.length; i++) {
	        var eachid = "x" + uid();
	        id = id || eachid;
	        if (i && (options[i].newline || config.vertical)) html.push("<div class='webix_line_break'></div>");
	        var isChecked = options[i].id == config.value;
	        var label = options[i].value || "";
	        var tooltip = config.tooltip ? " webix_t_id='" + options[i].id + "'" : "";
	        var customRadio = config.customRadio || "";

	        if (customRadio) {
	          var optlabel = (i === 0 ? config.label + " " : "") + label;
	          customRadio = customRadio.replace(/(aria-label=')\w*(?=')/, "$1" + template.escape(optlabel));
	          customRadio = customRadio.replace(/(aria-checked=')\w*(?=')/, "$1" + (isChecked ? "true" : "false"));
	          customRadio = customRadio.replace(/(tabindex=')\w*(?=')/, "$1" + (isChecked || i === 0 && !config.value ? "0" : "-1"));
	          customRadio = customRadio.replace(/(aria-invalid=')\w*(?=')/, "$1" + (config.invalid ? "true" : "false"));
	          customRadio = customRadio.replace(/(button_id=')\w*(?=')/, "$1" + options[i].id);
	        }

	        var rd = common._baseInputHTML("input") + " name='" + (config.name || config.id) + "' type='radio' " + (isChecked ? "checked='1'" : "") + "tabindex=" + (isChecked || i === 0 && !config.value ? "0" : "-1") + " value='" + options[i].id + "' id='" + eachid + "' style='" + (customRadio ? "display:none" : "") + "' />";
	        var input = "<div radio_id='" + options[i].id + "' class='webix_inp_radio_border webix_radio_" + (isChecked ? "1" : "0") + "' role='presentation'>" + rd + customRadio + "</div>";
	        if (label) label = "<label for='" + eachid + "' class='webix_label_right'>" + label + "</label>";
	        html.push("<div class='webix_radio_option' role='presentation'" + tooltip + ">" + input + label + "</div>");
	      }

	      html = "<div class='webix_el_group' role='radiogroup' style='margin-left:" + (config.label ? config.labelWidth : 0) + "px;'>" + html.join("") + "</div>";
	      return common.$renderInput(config, html, id);
	    }
	  },
	  refresh: function () {
	    this.render();
	    if (this._last_size && this.$getSize(0, 0)[2] != this._last_size[1]) this.resize();
	  },
	  $getSize: function (dx, dy) {
	    var size = button$1.api.$getSize.call(this, dx, dy);

	    if (this._settings.options) {
	      var count = this._settings.vertical ? 0 : 1;

	      for (var i = 0; i < this._settings.options.length; i++) {
	        if (this._settings.vertical || this._settings.options[i].newline) count++;
	      }

	      size[3] = size[2] = Math.max(size[2], (this._settings.optionHeight || 25) * count + this._settings.inputPadding * 2 + (this._settings.labelPosition == "top" ? this._labelTopHeight : 0));
	    }

	    var heightInc = this.config.bottomPadding;

	    if (heightInc) {
	      size[2] += heightInc;
	      size[3] += heightInc;
	    }

	    return size;
	  },
	  _getInputNode: function () {
	    return this._dataobj.getElementsByTagName(this._settings.customRadio ? "button" : "input");
	  },
	  $setValue: function (value) {
	    var inp = this._dataobj.getElementsByTagName("input");

	    for (var i = 0; i < inp.length; i++) {
	      if (inp[i].parentNode.getAttribute("radio_id") == value) {
	        inp[i].checked = true;
	        inp[i].setAttribute("tabindex", "0");
	      } else {
	        inp[i].checked = false;
	        inp[i].setAttribute("tabindex", "-1");
	      }

	      var parentNode = inp[i] ? inp[i].parentNode : null;

	      if (parentNode) {
	        parentNode.className = parentNode.className.replace(/(webix_radio_)\d/, "$1" + (inp[i].checked ? 1 : 0));

	        if (this._settings.customRadio) {
	          var button = parentNode.getElementsByTagName("BUTTON");

	          if (button[0]) {
	            button[0].setAttribute("aria-checked", inp[i].checked ? "true" : "false");
	            button[0].setAttribute("tabindex", inp[i].checked ? "0" : "-1");
	          }
	        }
	      }
	    }
	  },
	  getValue: function () {
	    return this._settings.value;
	  },
	  focus: function () {
	    return this._focus();
	  },
	  blur: function () {
	    this._blur();
	  },
	  customRadio_setter: function (value) {
	    if (value === true && $active.customRadio) value = "<a role='presentation' onclick='javascript:void(0)'><button type='button' class='webix_custom_radio' button_id='' role='radio' aria-checked='false' aria-label='' aria-invalid='' tabindex=''></button></a>";
	    return value;
	  },
	  $skin: function () {
	    this.defaults.customRadio = !!$active.customRadio;
	    if ($active.optionHeight) this.defaults.optionHeight = $active.optionHeight;
	  }
	};
	var view$z = exports.protoUI(api$z, text.view, HTMLOptions);

	var api$A = {
	  name: "datepicker",
	  $init: function () {
	    this.$ready.push(this._init_popup);
	  },
	  defaults: {
	    template: function (obj, common) {
	      if (common._settings.type == "time") {
	        common._settings.icon = common._settings.timeIcon;
	      } //temporary remove obj.type [[DIRTY]]


	      var t = obj.type;
	      obj.type = "";
	      var res = obj.editable ? common.$renderInput(obj) : common._render_div_block(obj, common);
	      obj.type = t;
	      return res;
	    },
	    stringResult: false,
	    timepicker: false,
	    icon: "wxi-calendar",
	    icons: true,
	    timeIcon: "wxi-clock",
	    separator: ", "
	  },
	  _onBlur: function () {
	    if (this._settings.text == this.getText() || isUndefined(this._settings.text) && !this.getText()) return;
	    var value = this.getPopup().getValue();
	    if (value) this.setValue(value);
	  },
	  $skin: function () {
	    this.defaults.inputPadding = $active.inputPadding;
	    this.defaults.point = !$active.popupNoPoint;
	  },
	  getPopup: function () {
	    return $$(this._settings.popup);
	  },
	  _init_popup: function () {
	    var obj = this._settings;
	    if (obj.suggest) obj.popup = obj.suggest;else if (!obj.popup) {
	      var timepicker = this._settings.timepicker;
	      obj.popup = obj.suggest = this.suggest_setter({
	        type: "calendar",
	        point: this._settings.point === false ? false : true,
	        padding: 0,
	        body: {
	          height: 240 + (timepicker || this._settings.icons ? 30 : 0),
	          width: 250,
	          multiselect: this._settings.multiselect,
	          timepicker: timepicker,
	          type: this._settings.type,
	          icons: this._settings.icons,
	          timeIcon: this._settings.timeIcon
	        }
	      });
	    }

	    this._init_once = function () {};
	  },
	  $render: function (obj) {
	    if (isUndefined(obj.value)) return;
	    obj.value = this.$prepareValue(obj.value);
	    this.$setValue(obj.value);
	  },
	  $prepareValue: function (value) {
	    if (this._settings.multiselect) {
	      if (typeof value === "string") value = value.split(this._settings.separator);else if (value instanceof Date) {
	        value = [value];
	      } else if (!value) {
	        value = [];
	      }

	      for (var i = 0; i < value.length; i++) {
	        value[i] = this._prepareSingleValue(value[i]);
	      }

	      return value;
	    } else {
	      return this._prepareSingleValue(value);
	    }
	  },
	  _prepareSingleValue: function (value) {
	    var type = this._settings.type;
	    var timeMode = type == "time"; //setValue("1980-12-25")

	    if (!isNaN(parseFloat(value))) value = "" + value;

	    if (typeof value == "string" && value) {
	      var formatDate = null;

	      if ((type == "month" || type == "year") && this._formatDate) {
	        formatDate = this._formatDate;
	      } else formatDate = timeMode ? i18n.parseTimeFormatDate : i18n.parseFormatDate;

	      value = formatDate(value);
	    }

	    if (value) {
	      //time mode
	      if (timeMode) {
	        //setValue([16,24])
	        if (isArray(value)) {
	          var time = new Date();
	          time.setHours(value[0]);
	          time.setMinutes(value[1]);
	          value = time;
	        }
	      } //setValue(invalid date)


	      if (isNaN(value.getTime())) value = "";
	    }

	    return value;
	  },
	  _get_visible_text: function (value) {
	    if (this._settings.multiselect) {
	      return [].concat(value).map(function (a) {
	        return this._get_visible_text_single(a);
	      }.bind(this)).join(this.config.separator);
	    } else return this._get_visible_text_single(value);
	  },
	  _get_visible_text_single: function (value) {
	    var timeMode = this._settings.type == "time";
	    var timepicker = this.config.timepicker;
	    var formatStr = this._formatStr || (timeMode ? i18n.timeFormatStr : timepicker ? i18n.fullDateFormatStr : i18n.dateFormatStr);
	    return formatStr(value);
	  },
	  _set_visible_text: function () {
	    var node = this.getInputNode();

	    if (node.value == undefined) {
	      node.innerHTML = this._settings.text || this._get_div_placeholder();
	    } else {
	      node.value = this._settings.text || "";
	    }
	  },
	  $compareValue: function (oldvalue, value) {
	    if (!oldvalue && !value) return true;
	    return wDate.equal(oldvalue, value);
	  },
	  $setValue: function (value) {
	    this._settings.text = value ? this._get_visible_text(value) : "";

	    this._set_visible_text();
	  },
	  format_setter: function (value) {
	    if (value) {
	      if (typeof value === "function") this._formatStr = value;else {
	        this._formatStr = wDate.dateToStr(value);
	        this._formatDate = wDate.strToDate(value);
	      }
	    } else this._formatStr = this._formatDate = null;

	    return value;
	  },
	  getInputNode: function () {
	    return this._settings.editable ? this._dataobj.getElementsByTagName("input")[0] : this._dataobj.getElementsByTagName("DIV")[1];
	  },
	  getValue: function () {
	    if (this._settings.multiselect) {
	      var value = this._settings.value;
	      if (!value) return [];
	      var result = [].concat(value).map(function (a) {
	        return this._get_value_single(a);
	      }.bind(this));
	      if (this._settings.stringResult) return result.join(this._settings.separator);
	      return result;
	    }

	    return this._get_value_single(this._settings.value);
	  },
	  _get_value_single: function (value) {
	    var type = this._settings.type; //time mode

	    var timeMode = type == "time"; //date and time mode

	    var timepicker = this.config.timepicker; //input was not rendered, we need to parse value from setValue method

	    if (!this._rendered_input) value = this.$prepareValue(value) || null; //rendere and in edit mode
	    else if (this._settings.editable) {
	        var formatDate = this._formatDate || (timeMode ? i18n.timeFormatDate : timepicker ? i18n.fullDateFormatDate : i18n.dateFormatDate);
	        value = formatDate(this.getInputNode().value);
	      } //return string from getValue

	    if (this._settings.stringResult) {
	      var formatStr = i18n.parseFormatStr;
	      if (timeMode) formatStr = i18n.parseTimeFormatStr;

	      if (this._formatStr && (type == "month" || type == "year")) {
	        formatStr = this._formatStr;
	      }

	      if (this._settings.multiselect) return [].concat(value).map(function (a) {
	        return a ? formatStr(a) : "";
	      });
	      return value ? formatStr(value) : "";
	    }

	    return value || null;
	  },
	  getText: function () {
	    var node = this.getInputNode();
	    return node ? typeof node.value == "undefined" ? this.getValue() ? node.innerHTML : "" : node.value : "";
	  }
	};
	var view$A = exports.protoUI(api$A, text.view);
	var datepicker = {
	  api: api$A,
	  view: view$A
	};

	var api$B = {
	  name: "colorpicker",
	  $init: function () {
	    this.$ready.push(this._init_popup);
	  },
	  defaults: {
	    icon: true
	  },
	  _init_popup: function () {
	    var obj = this._settings;
	    if (obj.suggest) obj.popup = obj.suggest;else if (!obj.popup) obj.popup = obj.suggest = this.suggest_setter({
	      type: "colorboard",
	      height: 200
	    });

	    this._init_once = function () {};
	  },
	  $render: function (obj) {
	    if (isUndefined(obj.value)) return;
	    obj.value = this.$prepareValue(obj.value);
	    this.$setValue(obj.value);
	  },
	  getValue: function () {
	    if (this._rendered_input && this._settings.editable) return this.getInputNode().value;else return this._settings.value;
	  },
	  $prepareValue: function (value) {
	    if (value && value.charAt && value.charAt(0) != "#") value = "#" + value;
	    return value || "";
	  },
	  _getColorNode: function () {
	    return this.$view.getElementsByTagName("DIV")[this._settings.editable ? 1 : 2];
	  },
	  _get_visible_text: function (value) {
	    return value;
	  },
	  $setValue: function (value) {
	    this._getColorNode().style.backgroundColor = value;
	    this._settings.text = value;
	    var node = this.getInputNode();
	    if (node.value == undefined) node.innerHTML = value;else node.value = value;
	  },
	  $renderIcon: function () {
	    var config = this.config;
	    return "<div class=\"webix_input_icon\" style=\"background-color:" + config.value + ";\"> </div>";
	  }
	};
	var view$B = exports.protoUI(api$B, datepicker.view);

	var api$C = {
	  name: "richselect",
	  defaults: {
	    template: function (obj, common) {
	      return common._render_div_block(obj, common);
	    },
	    popupWidth: 200,
	    icon: "wxi-menu-down"
	  },
	  _onBlur: function () {
	    if (this._settings.text == this.getText() || isUndefined(this._settings.text) && !this.getText()) return;
	    var suggest = this.getPopup(),
	        nodeValue = this.getInputNode().value,
	        value = suggest.getSuggestion(nodeValue),
	        oldvalue = this.getValue(); //non-empty value that differs from old value and matches filtering rule

	    if (value && value != oldvalue && !(nodeValue === "" && suggest.getItemText(value) !== "")) this.setValue(value);else if (nodeValue === "") this.setValue("");else if (this._revertValue) this._revertValue();
	  },
	  suggest_setter: function (value) {
	    return this.options_setter(value);
	  },
	  options_setter: function (value) {
	    value = this._suggest_config ? this._suggest_config(value) : value;
	    var suggest = this._settings.popup = this._settings.suggest = text.api.suggest_setter.call(this, value);
	    var list = $$(suggest).getList();
	    if (list) list.attachEvent("onAfterLoad", bind(this._reset_value, this));
	    return suggest;
	  },
	  getList: function () {
	    var suggest = $$(this._settings.suggest);
	    assert(suggest, "Input doesn't have a list");
	    return suggest.getList();
	  },
	  _pattern: function (value) {
	    return value;
	  },
	  _reset_value: function () {
	    var value = this._settings.value; //this._dataobj.firstChild - check that input is already rendered, as in IE11 it can be destroy during parent repainting

	    if (!isUndefined(value) && !this.getPopup().isVisible() && !this._settings.text && this._dataobj.firstChild) this.$setValue(value);
	  },
	  $skin: function () {
	    this.defaults.inputPadding = $active.inputPadding;
	  },
	  $render: function (obj) {
	    if (isUndefined(obj.value)) return;
	    this.$setValue(obj.value);
	  },
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("DIV")[1];
	  },
	  getPopup: function () {
	    return $$(this._settings.popup);
	  },
	  getText: function () {
	    var value = this._settings.value,
	        node = this.getInputNode();
	    if (!node) return value ? this.getPopup().getItemText(value) : "";

	    if (typeof node.value == "undefined") {
	      if (node.firstChild && node.firstChild.className === "webix_placeholder") return "";
	      return node.innerHTML;
	    }

	    return node.value;
	  },
	  $setValue: function (value) {
	    if (!this._rendered_input) return;
	    var text$$1 = value;
	    var popup = this.getPopup();
	    if (popup) text$$1 = this.getPopup().getItemText(value);

	    if (!text$$1 && value && value.id) {
	      //add new value
	      var _popup = this.getPopup();

	      var list = _popup.getList(); // add new item only when item with such id doesn't exists yet


	      var exists = list.exists(value.id);
	      if (!exists) list.add(value);
	      text$$1 = _popup.getItemText(value.id); // in case of dynamic list, we can't add extra items
	      // to not interfere with dynamic loading

	      if (list._settings.dynamic && !exists) list.remove(value.id);
	      this._settings.value = value.id;
	    }

	    var node = this.getInputNode();
	    if (isUndefined(node.value)) node.innerHTML = text$$1 || this._get_div_placeholder();else node.value = text$$1 = text$$1.replace(/<[^>]*>/g, "");
	    this._settings.text = text$$1;
	  },
	  getValue: function () {
	    return this._settings.value || "";
	  }
	};
	var view$C = exports.protoUI(api$C, text.view);
	var richselect = {
	  api: api$C,
	  view: view$C
	};

	var api$D = {
	  name: "combo",
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("input")[0];
	  },
	  $render: function (obj) {
	    if (isUndefined(obj.value)) return;
	    this.$setValue(obj.value);
	  },
	  _revertValue: function () {
	    if (!this._settings.editable) {
	      var value = this.getValue();
	      this.$setValue(isUndefined(value) ? "" : value);
	    }
	  },
	  _applyChanges: function () {
	    var input = this.getInputNode(),
	        value = "",
	        suggest = this.getPopup();

	    if (input.value) {
	      value = this._settings.value;
	      if (suggest.getItemText(value) != this.getText()) value = suggest.getSuggestion() || value;
	    }

	    if (value != this._settings.value) this.setValue(value, true);else this.$setValue(value);
	  },
	  defaults: {
	    template: function (config, common) {
	      return common.$renderInput(config).replace(/(<input)\s*(?=\w)/, "$1" + " role='combobox'");
	    },
	    icon: "wxi-menu-down"
	  }
	};
	var view$D = exports.protoUI(api$D, richselect.view);

	var api$E = {
	  name: "counter",
	  defaults: {
	    template: function (config, common) {
	      var value = config.value;
	      var id = "x" + uid();
	      var html = "<div role='spinbutton' aria-label='" + template.escape(config.label) + "' aria-valuemin='" + config.min + "' aria-valuemax='" + config.max + "' aria-valuenow='" + config.value + "' class='webix_el_group' style='width:" + common._get_input_width(config) + "px'>";
	      html += "<button type='button' class='webix_inp_counter_prev' tabindex='-1' aria-label='" + i18n.aria.decreaseValue + "'>-</button>";
	      html += common._baseInputHTML("input") + " id='" + id + "' type='text' class='webix_inp_counter_value' aria-live='assertive'" + " value='" + value + "'></input>";
	      html += "<button type='button' class='webix_inp_counter_next' tabindex='-1' aria-label='" + i18n.aria.increaseValue + "'>+</button></div>";
	      return common.$renderInput(config, html, id);
	    },
	    min: 0,
	    max: Infinity,
	    value: 0,
	    step: 1
	  },
	  $init: function () {
	    _event(this.$view, "keydown", this._keyshift, {
	      bind: this
	    });
	  },
	  _keyshift: function (e) {
	    var code = e.which || e.keyCode,
	        c = this._settings,
	        value = this.getValue();

	    if (code > 32 && code < 41) {
	      if (code === 36) value = c.min;else if (code === 35) value = c.max === Infinity ? 1000000 : c.max;else if (code === 33) this.next();else if (code === 34) this.prev();else value = value + (code === 37 || code === 40 ? -1 : 1);
	      if (code > 34 && value >= c.min && value <= c.max) this.setValue(value);
	    }
	  },
	  $setValue: function (value) {
	    this.getInputNode().value = value;
	  },
	  $prepareValue: function (value) {
	    value = parseFloat(value);
	    return isNaN(value) ? 0 : value;
	  },
	  value_setter: function (value) {
	    return this.$prepareValue(value);
	  },
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("input")[0];
	  },
	  getValue: function () {
	    return button$1.api.getValue.apply(this, arguments) * 1;
	  },
	  next: function (step) {
	    step = 1 * (step || this._settings.step);
	    this.shift(step);
	  },
	  prev: function (step) {
	    step = -1 * (step || this._settings.step);
	    this.shift(step);
	  },
	  shift: function (step) {
	    var min = this._settings.min;
	    var max = this._settings.max;
	    var new_value = this.getValue() + step;
	    if (new_value >= min && new_value <= max) this.setValue(new_value);
	  }
	};
	var view$E = exports.protoUI(api$E, text.view);

	var api$F = {
	  name: "icon",
	  $skin: function () {
	    this.defaults.height = $active.inputHeight;
	    this.defaults.width = $active.inputHeight;
	  },
	  defaults: {
	    template: function (obj, view) {
	      var min = Math.min(obj.awidth, obj.aheight);
	      var top = Math.round((view._content_height - obj.aheight) / 2);
	      var inner = "<button type='button' style='height:" + min + "px;width:" + min + "px;' class='webix_icon_button'>" + "<span class='webix_icon " + obj.icon + "'></span></button>";
	      return "<div class='webix_el_box' style='width:" + obj.awidth + "px;height:" + obj.aheight + "px;line-height:" + obj.aheight + "px;margin-top:" + top + "px'>" + inner + (obj.badge ? "<span class='webix_badge'>" + obj.badge + "</span>" : "") + "</div>";
	    }
	  },
	  _set_inner_size: function () {},
	  $setValue: function () {}
	};
	var view$F = exports.protoUI(api$F, button$1.view);

	var api$G = {
	  name: "search",
	  on_click: {
	    "webix_input_icon": function (e) {
	      this.getInputNode().focus();
	      this.callEvent("onSearchIconClick", [e]);
	    }
	  },
	  $skin: function () {
	    this.defaults.inputPadding = $active.inputPadding;
	  },
	  defaults: {
	    type: "text",
	    icon: "wxi-search"
	  }
	};
	var view$G = exports.protoUI(api$G, text.view);

	var api$H = {
	  name: "segmented",
	  $allowsClear: false,
	  $init: function () {
	    this.attachEvent("onChange", function (value) {
	      if (this._settings.multiview) this._show_view(value);
	    });
	    this.attachEvent("onAfterRender", once(function () {
	      if (this._settings.multiview && this._settings.value) this._show_view(this._settings.value);
	    }));
	  },
	  _show_view: function (value) {
	    var top = this.getTopParentView();
	    var view = null; //get from local isolate

	    if (top && top.$$) view = top.$$(value); //or check globally

	    if (!view) view = $$(value);
	    if (view && view.show) view.show();
	  },
	  defaults: {
	    template: function (obj, common) {
	      if (!obj.options) assert(false, "segmented: options undefined");
	      var options = obj.options;

	      common._check_options(options);

	      options = common._filterOptions(options);

	      var width = common._get_input_width(obj);

	      var id = uid();
	      var html = "<div style='width:" + width + "px' class='webix_all_segments' role='tablist' aria-label='" + template.escape(obj.label) + "'>";
	      var optionWidth = obj.optionWidth || Math.floor(width / options.length);
	      if (!obj.value) obj.value = options[0].id;
	      var tooltip;

	      for (var i = 0; i < options.length; i++) {
	        tooltip = obj.tooltip ? " webix_t_id='" + options[i].id + "'" : "";
	        html += "<button type='button' style='width:" + (options[i].width || optionWidth) + "px' role='tab' aria-selected='" + (obj.value == options[i].id ? "true" : "false") + "' tabindex='" + (obj.value == options[i].id ? "0" : "-1") + "'";
	        html += "class='" + "webix_segment_" + (i == options.length - 1 ? "N" : i > 0 ? 1 : 0) + (obj.value == options[i].id ? " webix_selected " : "") + "' button_id='" + options[i].id + "'" + tooltip + ">";
	        html += options[i].value + "</button>";
	      }

	      return common.$renderInput(obj, html + "</div>", id);
	    }
	  },
	  _getInputNode: function () {
	    return this.$view.getElementsByTagName("BUTTON");
	  },
	  focus: function () {
	    return this._focus();
	  },
	  blur: function () {
	    this._blur();
	  },
	  $setValue: function (value) {
	    var options = this._getInputNode();

	    for (var i = 0; i < options.length; i++) {
	      var id = options[i].getAttribute("button_id");
	      options[i].setAttribute("aria-selected", value == id ? "true" : "false");
	      options[i].setAttribute("tabindex", value == id ? "0" : "-1");
	      if (value == id) addCss(options[i], "webix_selected");else removeCss(options[i], "webix_selected");
	    } //refresh tabbar if the option is in the popup list


	    var popup = this.config.tabbarPopup;
	    if (popup && $$(popup) && $$(popup).getBody().exists(value)) this.refresh();
	  },
	  getValue: function () {
	    return this._settings.value;
	  },
	  getInputNode: function () {
	    return null;
	  },
	  optionIndex: function (id) {
	    var pages = this._settings.options;

	    for (var i = 0; i < pages.length; i++) {
	      if (pages[i].id == id) return i;
	    }

	    return -1;
	  },
	  addOption: function (id, value, show, index$$1) {
	    var obj = id;

	    if (_typeof(id) != "object") {
	      value = value || id;
	      obj = {
	        id: id,
	        value: value
	      };
	    } else {
	      id = obj.id;
	      index$$1 = show;
	      show = value;
	    }

	    if (this.optionIndex(id) < 0) PowerArray.insertAt.call(this._settings.options, obj, index$$1);
	    this.refresh();
	    if (show) this.setValue(id);
	  },
	  removeOption: function (id) {
	    var index$$1 = this.optionIndex(id);
	    var options = this._settings.options;
	    if (index$$1 >= 0) PowerArray.removeAt.call(options, index$$1); // if we remove a selected option

	    if (this._settings.value == id) this._setNextVisible(options, index$$1);
	    this.refresh();
	    this.callEvent("onOptionRemove", [id, this._settings.value]);
	  },
	  _setNextVisible: function (options, index$$1) {
	    var size = options.length;

	    if (size) {
	      index$$1 = Math.min(index$$1, size - 1); //forward search

	      for (var i = index$$1; i < size; i++) {
	        if (!options[i].hidden) return this.setValue(options[i].id);
	      } //backward search


	      for (var _i = index$$1; _i >= 0; _i--) {
	        if (!options[_i].hidden) return this.setValue(options[_i].id);
	      }
	    } //nothing found		


	    this.setValue("");
	  },
	  _filterOptions: function (options) {
	    var copy$$1 = [];

	    for (var i = 0; i < options.length; i++) {
	      if (!options[i].hidden) copy$$1.push(options[i]);
	    }

	    return copy$$1;
	  },
	  _setOptionVisibility: function (id, state) {
	    var options = this._settings.options;
	    var index$$1 = this.optionIndex(id);
	    var option = options[index$$1];

	    if (option && state == !!option.hidden) {
	      //new state differs from previous one
	      option.hidden = !state;

	      if (state || this._settings.value != id) {
	        //show item, no need for extra steps
	        this.refresh();
	      } else {
	        //hide item, switch to next visible one
	        this._setNextVisible(options, index$$1);
	      }
	    }
	  },
	  hideOption: function (id) {
	    this._setOptionVisibility(id, false);
	  },
	  showOption: function (id) {
	    this._setOptionVisibility(id, true);
	  },
	  _set_inner_size: false
	};
	var view$H = exports.protoUI(api$H, text.view, HTMLOptions);
	var segmented = {
	  api: api$H,
	  view: view$H
	};

	var api$I = {
	  name: "textarea",
	  defaults: {
	    template: function (obj, common) {
	      var name = obj.name || obj.id;
	      var id = "x" + uid();
	      var html = common._baseInputHTML("textarea") + "style='width:" + common._get_input_width(obj) + "px;'";
	      html += " id='" + id + "' name='" + name + "' class='webix_inp_textarea'>" + common._pattern(obj.value) + "</textarea>";
	      return common.$renderInput(obj, html, id);
	    },
	    height: 0,
	    minHeight: 60
	  },
	  $skin: function () {
	    this.defaults.inputPadding = $active.inputPadding;
	    this._inputSpacing = $active.inputSpacing;
	  },
	  _skipSubmit: true,
	  _getLabelHeight: function (top) {
	    return top ? this._labelTopHeight - this._settings.inputPadding : "";
	  },
	  //get input element
	  getInputNode: function () {
	    return this._dataobj.getElementsByTagName("textarea")[0];
	  }
	};
	var view$I = exports.protoUI(api$I, text.view);

	var api$J = {
	  name: "toggle",
	  $allowsClear: true,
	  $init: function () {
	    this.attachEvent("onItemClick", function () {
	      this.toggle();
	    });
	  },
	  $setValue: function (value) {
	    var input = this.getInputNode();
	    var obj = this._settings;
	    var isPressed = value && value != "0";
	    var text = (isPressed ? obj.onLabel : obj.offLabel) || obj.label;
	    var textNode = input.lastChild;
	    input.setAttribute("aria-pressed", isPressed ? "true" : false);
	    input.value = text;
	    if (textNode) (textNode.firstChild || textNode).nodeValue = text; //icon or image button

	    if (input.firstChild && input.firstChild.nodeName === "SPAN" && obj.onIcon && obj.offIcon && obj.onIcon !== obj.offIcon) input.firstChild.className = input.firstChild.className.replace(isPressed ? obj.offIcon : obj.onIcon, isPressed ? obj.onIcon : obj.offIcon);
	    var parent = input.parentNode;
	    if (isPressed) addCss(parent, "webix_pressed");else removeCss(parent, "webix_pressed");
	  },
	  toggle: function () {
	    this.setValue(!this.getValue());
	  },
	  getValue: function () {
	    var value = this._settings.value;
	    return !value || value == "0" ? 0 : 1;
	  },
	  defaults: {
	    template: function (obj, common) {
	      var isPressed = obj.value && obj.value != "0";
	      var css = isPressed ? " webix_pressed" : "";
	      obj.label = (isPressed ? obj.onLabel : obj.offLabel) || obj.label;
	      obj.icon = (isPressed ? obj.onIcon : obj.offIcon) || obj.icon;
	      var html = "<div class='webix_el_box" + css + "' style='width:" + obj.awidth + "px; height:" + obj.aheight + "px'>" + common.$renderInput(obj, common) + "</div>";
	      html = html.replace(/(button)\s*(?=\w)/, "$1" + (" aria-pressed='" + (isPressed ? "true" : "false") + "' "));
	      if (obj.badge) html = html.replace(/<\/div>$/, "<span class='webix_badge'>" + obj.badge + "</span></div>");
	      return html;
	    }
	  },
	  _set_inner_size: false
	};
	var view$J = exports.protoUI(api$J, button$1.view);

	var api$K = {
	  name: "multitext",
	  $cssName: "text",
	  defaults: {
	    icon: "wxi-plus-circle",
	    iconWidth: 25,
	    separator: ", "
	  },
	  getValueHere: function () {
	    return text.api.getValue.call(this);
	  },
	  setValueHere: function (value) {
	    return text.api.$setValue.call(this, value);
	  },
	  getValue: function () {
	    if (this.config.mode == "extra") return this.getValueHere();
	    if (this._full_value) return this._full_value;
	    var values = [this.getValueHere(this)];

	    for (var i = 0; i < this._subs.length; i++) {
	      var seg = $$(this._subs[i]).getValueHere();
	      if (seg) values.push(seg);
	    }

	    return values.join(this.config.separator);
	  },
	  $setValue: function (value) {
	    value = value || "";
	    if (this.config.mode == "extra") return this.setValueHere(value);
	    this._full_value = value;
	    var parts = value.split(this.config.separator);

	    if (parts.length == this._subs.length + 1) {
	      this.setValueHere(parts[0]);

	      for (var i = 0; i < this._subs.length; i++) {
	        $$(this._subs[i]).setValueHere(parts[i + 1]);
	      }

	      this._full_value = "";
	      return;
	    }

	    this.removeSection();
	    this.setValueHere.call(this, parts[0]);

	    for (var _i = 1; _i < parts.length; _i++) {
	      this.addSection(parts[_i]);
	    }

	    this._full_value = "";
	  },
	  _subOnChange: function () {
	    var parent = this.config.master ? $$(this.config.master) : this;
	    var newvalue = parent.getValue();
	    var oldvalue = parent._settings.value;

	    if (newvalue !== oldvalue) {
	      parent._settings.value = newvalue;
	      parent.callEvent("onChange", [newvalue, oldvalue]);
	    }
	  },
	  addSection: function (text$$1) {
	    var config = this.config,
	        newConfig = {
	      labelWidth: config.labelWidth,
	      inputWidth: config.inputWidth,
	      width: config.width,
	      label: config.label ? "&nbsp;" : "",
	      view: this.name,
	      mode: "extra",
	      value: text$$1 || "",
	      icon: "wxi-minus-circle",
	      tooltip: config.tooltip,
	      suggest: config.suggest || null,
	      master: config.id
	    };
	    exports.extend(newConfig, config.subConfig || {}, true);
	    var newone = this.getParentView().addView(newConfig);
	    $$(newone).attachEvent("onChange", this._subOnChange);

	    this._subs.push(newone);

	    this.callEvent("onSectionAdd", [newone, this._subs.length]);
	    return newone;
	  },
	  removeSection: function (id) {
	    var parent = this.config.master ? $$(this.config.master) : this;

	    for (var i = parent._subs.length - 1; i >= 0; i--) {
	      var section = parent._subs[i];

	      if (!id || section == id) {
	        parent._subs.removeAt(i);

	        this.getParentView().removeView(section);
	        parent.callEvent("onSectionRemove", [section, i + 1]);
	      }
	    }
	  },
	  on_click: {
	    "webix_input_icon": function () {
	      if (this.config.mode == "extra") {
	        this.removeSection(this.config.id);
	        var childs = this.getParentView().getChildViews();
	        childs[childs.length - 1].focus();

	        this._subOnChange();
	      } else $$(this.addSection()).focus();

	      return false;
	    }
	  },
	  $init: function () {
	    this._subs = toArray([]);
	    this.attachEvent("onKeyPress", this._onKeyPress);
	  },
	  $render: function (obj) {
	    this.$setValue(obj.value);
	  }
	};
	var view$K = exports.protoUI(api$K, text.view);

	exports.protoUI({
	  name: "multiselect",
	  defaults: {
	    template: "GPL version doesn't support multiselect <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "multicombo",
	  defaults: {
	    template: "GPL version doesn't support multicombo <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$L = {
	  name: "slider",
	  $touchCapture: true,
	  defaults: {
	    min: 0,
	    max: 100,
	    value: 50,
	    step: 1,
	    title: false,
	    moveTitle: true,
	    template: function (obj, common) {
	      var id = common._handle_id = "x" + uid();
	      var html = "";
	      var title = "<div class='webix_slider_title" + (obj.moveTitle ? " webix_slider_move" : "") + "'" + (!obj.moveTitle && obj.vertical ? " style='line-height:" + (obj.aheight - obj.inputPadding * 2) + "px;'" : "") + "></div>";
	      var left = "<div class='webix_slider_left'>&nbsp;</div>";
	      var right = "<div class='webix_slider_right'></div>";
	      var handle = "<div class='webix_slider_handle' webix_disable_drag='true' role='slider' aria-label='" + obj.label + (obj.title ? " " + obj.title(obj) : "") + "' aria-valuemax='" + obj.max + "' aria-valuemin='" + obj.min + "' aria-valuenow='" + obj.value + "' tabindex='0' id='" + id + "'>&nbsp;</div>";
	      if (obj.vertical) html = "<div class='webix_slider_box'>" + right + left + handle + "</div>" + title;else html = title + "<div class='webix_slider_box'>" + left + right + handle + "</div>";
	      return common.$renderInput(obj, html, id);
	    }
	  },
	  type_setter: function (type) {
	    this._viewobj.className += " webix_slider_" + type;
	  },
	  title_setter: function (value) {
	    if (typeof value == "string") return template(value);
	    return value;
	  },
	  _get_slider_handle: function () {
	    return this.$view.querySelector(".webix_slider_handle");
	  },
	  _set_inner_size: function () {
	    var handle = this._get_slider_handle();

	    var config = this._settings;

	    if (handle) {
	      //view is rendered for sure
	      var size = config.vertical ? this._content_height : this._get_input_width(config); //width or height

	      var value = config.value % config.step ? Math.round(config.value / config.step) * config.step : config.value;
	      var max = config.max - config.min;
	      value = Math.max(Math.min(value, config.max), config.min);
	      value = config.vertical ? max - (value - config.min) : value - config.min; //top or left

	      var corner1 = Math.ceil((size - 2 * this._sliderPadding) * value / max); //bottom or right

	      var corner2 = size - 2 * this._sliderPadding - corner1;
	      var cornerStr = config.vertical ? "top" : "left";
	      var sizeStr = config.vertical ? "height" : "width";
	      handle.style[cornerStr] = this._sliderPadding + corner1 - this._sliderHandleWidth / 2 + "px";
	      handle.parentNode.style[sizeStr] = size + "px"; //1px border

	      corner2 = Math.min(Math.max(corner2, 2 * this._sliderBorder), size - this._sliderPadding * 2 - 2 * this._sliderBorder);
	      corner1 = Math.min(Math.max(corner1, 2 * this._sliderBorder), size - this._sliderPadding * 2 - 2 * this._sliderBorder); //width for left/top and right/bottom bars

	      var part = handle.previousSibling;
	      part.style[sizeStr] = corner2 + "px";
	      var last = part.previousSibling;
	      last.style[sizeStr] = corner1 + "px";

	      this._set_title(handle, corner1, corner2, cornerStr);
	    }
	  },
	  _set_title: function (handle, corner1, corner2, cornerStr) {
	    var config = this._settings;

	    if (this._settings.title) {
	      var title = handle.parentNode[config.vertical ? "nextSibling" : "previousSibling"];
	      title.innerHTML = this._settings.title(this._settings, this);

	      if (this._settings.moveTitle) {
	        var pos$$1 = 0;
	        if (config.vertical) pos$$1 = corner1 + 2 * this._sliderBorder - this._sliderHandleWidth / 2;else {
	          var half = title.clientWidth / 2;
	          var pos1 = half > corner1 ? half - corner1 - 2 * this._sliderBorder : 0; //left/top text is to large

	          var pos2 = half > corner2 ? half - corner2 - 2 * this._sliderBorder - this._sliderHandleWidth / 2 : 0; //right/bottom text is too large

	          pos$$1 = this._sliderPadding + corner1 - half + pos1 - pos2;
	        }
	        title.style[cornerStr] = pos$$1 + "px";
	      }
	    }
	  },
	  _set_value_now: function () {
	    this._get_slider_handle().setAttribute("aria-valuenow", this._settings.value);
	  },
	  refresh: function () {
	    var handle = this._get_slider_handle();

	    if (handle) {
	      this._set_value_now();

	      if (this._settings.title) handle.setAttribute("aria-label", this._settings.label + " " + this._settings.title(this._settings, this));

	      this._set_inner_size();
	    }
	  },
	  value_setter: function (value) {
	    return this.$prepareValue(value);
	  },
	  $setValue: function () {
	    this.refresh();
	  },
	  $getValue: function () {
	    return this._settings.value;
	  },
	  $prepareValue: function (value) {
	    value = parseFloat(value);
	    return isNaN(value) ? 0 : value;
	  },
	  $init: function (config) {
	    if (env.touch) this.attachEvent("onTouchStart", bind(this._on_mouse_down_start, this));else _event(this._viewobj, "mousedown", bind(this._on_mouse_down_start, this));

	    _event(this.$view, "keydown", bind(this._handle_move_keyboard, this));

	    if (config.vertical) {
	      config.height = config.height || $active.vSliderHeight;
	      this._viewobj.className += " webix_slider_vertical";
	      this._sliderPadding = $active.vSliderPadding;
	    }
	  },
	  $skin: function () {
	    this._sliderHandleWidth = $active.sliderHandleWidth; //8 - width of handle / 2

	    this._sliderPadding = $active.sliderPadding; //10 - padding of webix_slider_box ( 20 = 10*2 )

	    this._sliderBorder = $active.sliderBorder; //1px border
	  },
	  _handle_move_keyboard: function (e) {
	    var code = e.keyCode,
	        c = this._settings,
	        value = c.value;

	    if (code > 32 && code < 41) {
	      preventEvent(e);
	      var trg = e.target || e.srcElement;
	      var match = /webix_slider_handle_(\d)/.exec(trg.className);
	      this._activeIndex = match ? parseInt(match[1], 10) : -1;
	      if (match) value = c.value[this._activeIndex];
	      value = value < c.min ? c.min : value > c.max ? c.max : value;
	      if (code === 36) value = c.min;else if (code === 35) value = c.max;else {
	        var inc = code === 37 || code === 40 || code === 34 ? -1 : 1;
	        if (code === 33 || code === 34 || c.step > 1) inc = inc * c.step;
	        value = value * 1 + inc;
	      }

	      if (match) {
	        var other = c.value[this._activeIndex ? 0 : 1];
	        value = this._activeIndex && value <= other || !this._activeIndex && value >= other ? other : value;
	      }

	      if (value >= c.min && value <= c.max) {
	        if (match) {
	          var temp = [];

	          for (var i = 0; i < c.value.length; i++) {
	            temp[i] = i === this._activeIndex ? value : c.value[i];
	          }

	          value = temp;
	        }

	        this.setValue(value);
	        this._activeIndex = -1;
	      }
	    }
	  },
	  _on_mouse_down_start: function (e) {
	    var trg = e.target || e.srcElement;

	    if (this._mouse_down_process) {
	      this._mouse_down_process(e);
	    }

	    var value = this._settings.value;
	    if (isArray(value)) value = copy(value);

	    if (trg.className.indexOf("webix_slider_handle") != -1) {
	      this._start_value = value;
	      return this._start_handle_dnd.apply(this, arguments);
	    } else if (trg.className.indexOf("webix_slider") != -1) {
	      this._start_value = value;
	      this._settings.value = this._get_value_from_event.apply(this, arguments);

	      this._start_handle_dnd(e);
	    }
	  },
	  _start_handle_dnd: function () {
	    if (env.touch) {
	      this._handle_drag_events = [this.attachEvent("onTouchMove", bind(this._handle_move_process, this)), this.attachEvent("onTouchEnd", bind(this._handle_move_stop, this))];
	    } else this._handle_drag_events = [event$1(document.body, "mousemove", bind(this._handle_move_process, this)), event$1(window, "mouseup", bind(this._handle_move_stop, this))];

	    addCss(document.body, "webix_noselect");
	  },
	  _handle_move_stop: function () {
	    //detach event handlers
	    if (this._handle_drag_events) {
	      if (env.touch) {
	        this.detachEvent(this._handle_drag_events[0]);
	        this.detachEvent(this._handle_drag_events[1]);
	      } else {
	        eventRemove(this._handle_drag_events[0]);
	        eventRemove(this._handle_drag_events[1]);
	      }

	      this._handle_drag_events = [];
	    }

	    removeCss(document.body, "webix_noselect");
	    var value = this._settings.value;
	    if (isArray(value)) value = copy(value);
	    this._settings.value = this._start_value;
	    this.setValue(value);

	    this._get_slider_handle(this._activeIndex).focus();

	    this._activeIndex = -1;
	  },
	  _handle_move_process: function () {
	    this._settings.value = this._get_value_from_event.apply(this, arguments);
	    this.refresh();
	    this.callEvent("onSliderDrag", []);
	  },
	  _get_value_from_event: function (event, touchContext) {
	    // this method takes 2 arguments in case of touch env
	    var pos$$1 = 0;
	    var ax = this._settings.vertical ? "y" : "x";
	    if (env.touch) pos$$1 = touchContext ? touchContext[ax] : event[ax];else pos$$1 = pos(event)[ax];
	    return this._get_value_from_pos(pos$$1);
	  },
	  _get_value_from_pos: function (pos$$1) {
	    var config = this._settings;
	    var max = config.max - config.min;
	    var ax = config.vertical ? "y" : "x"; //top or left depending on slider type

	    var corner = offset(this._get_slider_handle().parentNode)[ax] + this._sliderPadding; //height or width depending on slider type


	    var size = (config.vertical ? this._content_height : this._get_input_width(config)) - 2 * this._sliderPadding;
	    var newvalue = size ? (pos$$1 - corner) * max / size : 0;
	    if (config.vertical) newvalue = max - newvalue;
	    newvalue = Math.round((newvalue + 1 * config.min) / config.step) * config.step;
	    return Math.max(Math.min(newvalue, config.max), config.min);
	  },
	  _init_onchange: function () {} //need not ui.text logic

	};
	var view$L = exports.protoUI(api$L, text.view);

	exports.protoUI({
	  name: "rangeslider",
	  defaults: {
	    template: "GPL version doesn't support rangeslider <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$M = {
	  name: "switch",
	  defaults: {
	    template: function (config, common) {
	      common._calck_switch_size();

	      var id = config.name || "x" + uid();
	      var rightlabel = "";

	      if (config.labelRight) {
	        rightlabel = "<label class='webix_label_right'>" + config.labelRight + "</label>";
	        if (config.labelWidth) config.label = config.label || "&nbsp;";
	      }

	      var checked = config.checkValue == config.value;
	      var aria = "aria-label=\"" + (config.label || config.labelRight || "") + "\" role=\"checkbox\" tabindex=\"0\" aria-checked=\"" + (checked ? "true" : "false") + "\" " + (config.readonly ? "aria-readonly='true'" : "") + "\"";
	      var html = "<div class=\"webix_switch_box " + (checked ? " webix_switch_on" : "") + "\" style=\"width:" + common._switchWidth + "px\">" + "<span class=\"webix_switch_text\">" + ((checked ? config.onLabel : config.offLabel) || "") + "</span>" + "<button class=\"webix_switch_handle\" " + aria + " style=\"left:" + (checked ? common._switchWidth - common._switchHeight : 0) + "px;\">" + "<input  id=\"" + id + "\" class=\"webix_switch_toggle\" type=\"checkbox\" " + (checked ? "checked" : "") + "></button>" + "</div>" + rightlabel;
	      return common.$renderInput(config, html, id);
	    }
	  },
	  $skin: function () {
	    this._switchHeight = $active.switchHeight;
	    this._switchWidth = $active.switchWidth;
	  },
	  $setValue: function (value) {
	    var config = this._settings;
	    var checked = value == config.checkValue;
	    var box = this.$view.querySelector(".webix_switch_box");

	    if (box) {
	      var handle = box.childNodes[1];
	      var text = (checked ? config.onLabel : config.offLabel) || "";
	      if (checked) addCss(box, "webix_switch_on");else removeCss(box, "webix_switch_on");
	      handle.style.left = (checked ? this._switchWidth - this._switchHeight : 0) + "px";
	      handle.firstChild.checked = checked;
	      handle.setAttribute("aria-checked", checked ? "true" : "false");

	      if (text) {
	        box.childNodes[0].innerHTML = text;
	      }
	    }
	  },
	  _calck_switch_size: function () {
	    var config = this._settings;

	    if (config.onLabel || config.offLabel) {
	      var onWidth = config.onLabel ? getTextSize(config.onLabel, "webix_switch_text").width : 0;
	      var offWidth = config.onLabel ? getTextSize(config.offLabel, "webix_switch_text").width : 0;
	      this._switchWidth = Math.max(onWidth, offWidth) + this._switchHeight;
	    }
	  },
	  on_click: {
	    "webix_switch_box": function () {
	      if (!this._settings.readonly) this.toggle();
	    },
	    "webix_label_right": function () {
	      if (!this._settings.readonly) this.toggle();
	    }
	  }
	};
	var view$M = exports.protoUI(api$M, checkbox.view);

	var api$N = {
	  name: "tabbar",
	  $init: function () {
	    this.attachEvent("onKeyPress", this._onKeyPress);
	  },
	  $skin: function () {
	    var skin = $active;
	    var defaults = this.defaults;
	    defaults.topOffset = skin.tabTopOffset || 0;
	    defaults.tabOffset = typeof skin.tabOffset != "undefined" ? skin.tabOffset : 10;
	    defaults.bottomOffset = skin.tabBottomOffset || 0;
	    defaults.height = skin.tabbarHeight;
	    defaults.tabMargin = skin.tabMargin;
	    defaults.inputPadding = skin.inputPadding;
	    defaults.tabMinWidth = skin.tabMinWidth || 100;
	    defaults.tabMoreWidth = skin.tabMoreWidth || 40;
	    defaults.borderless = !skin.tabBorder;
	  },
	  _getTabbarSizes: function () {
	    var config = this._settings,
	        i,
	        len,
	        tabs = this._tabs || config.options,
	        totalWidth = this._input_width - config.tabOffset * 2,
	        limitWidth = config.optionWidth || config.tabMinWidth;
	    len = tabs.length;

	    if (config.tabMinWidth && totalWidth / len < limitWidth) {
	      return {
	        max: parseInt(totalWidth / limitWidth, 10) || 1
	      };
	    }

	    if (!config.optionWidth) {
	      for (i = 0; i < len; i++) {
	        if (tabs[i].width) {
	          totalWidth -= tabs[i].width + (!i && !config.type ? config.tabMargin : 0);
	          len--;
	        }
	      }
	    }

	    return {
	      width: len ? totalWidth / len : config.tabMinWidth
	    };
	  },
	  _init_popup: function () {
	    var obj = this._settings;

	    if (!obj.tabbarPopup) {
	      var popupConfig = {
	        view: "popup",
	        width: obj.popupWidth || 200,
	        body: {
	          view: "list",
	          borderless: true,
	          select: true,
	          css: "webix_tab_list",
	          autoheight: true,
	          yCount: obj.yCount,
	          type: {
	            template: obj.popupTemplate
	          }
	        }
	      };
	      var view = ui(popupConfig);
	      view.getBody().attachEvent("onBeforeSelect", bind(function (id) {
	        if (id && this.callEvent("onBeforeTabClick", [id])) {
	          this.setValue(id);
	          $$(this._settings.tabbarPopup).hide();
	          this.callEvent("onAfterTabClick", [id]);
	          return true;
	        }
	      }, this));
	      view.getBody().attachEvent("onAfterSelect", bind(function () {
	        this.refresh();
	      }, this));
	      obj.tabbarPopup = view._settings.id;

	      this._destroy_with_me.push(view);
	    }

	    this._init_popup = function () {};
	  },
	  getPopup: function () {
	    this._init_popup();

	    return $$(this._settings.tabbarPopup);
	  },
	  moreTemplate_setter: template,
	  popupTemplate_setter: template,
	  defaults: {
	    popupWidth: 200,
	    popupTemplate: "#value#",
	    yCount: 7,
	    moreTemplate: "<span class=\"webix_icon wxi-dots\"></span>",
	    template: function (obj, common) {
	      var contentWidth, html, i, leafWidth, resultHTML, style, sum, tabs, verticalOffset, width;
	      common._tabs = tabs = common._filterOptions(obj.options);

	      if (!tabs.length) {
	        html = "<div class='webix_tab_filler' style='width:" + common._input_width + "px; border-right:0px;'></div>";
	      } else {
	        common._check_options(tabs);

	        if (!obj.value && tabs.length) obj.value = tabs[0].id;
	        html = "";
	        if (obj.tabOffset) html += "<div class='webix_tab_filler' style='width:" + obj.tabOffset + "px;'>&nbsp;</div>";
	        contentWidth = common._input_width - obj.tabOffset * 2 - (!obj.type ? obj.tabMargin * (tabs.length - 1) : 0);
	        verticalOffset = obj.topOffset + obj.bottomOffset;

	        var sizes = common._getTabbarSizes();

	        if (sizes.max && sizes.max < tabs.length) {
	          //we need popup
	          var popup = common.getPopup();
	          popup.hide();
	          var list = popup.getBody() || null;

	          if (list) {
	            if (sizes.max) {
	              var found = false;

	              for (i = 0; i < tabs.length && !found; i++) {
	                if (tabs[i].id == obj.value) {
	                  found = true;

	                  if (i + 1 > sizes.max) {
	                    var selectedTab = tabs.splice(i, 1);
	                    var displayTabs = tabs.splice(0, sizes.max - 1).concat(selectedTab);
	                    tabs = displayTabs.concat(tabs);
	                  }
	                }
	              }

	              list.clearAll();
	              list.parse(tabs.slice(sizes.max));
	            } else {
	              list.clearAll();
	            }
	          }
	        } else if (common._settings.tabbarPopup) $$(common._settings.tabbarPopup).hide();

	        sum = obj.tabOffset;
	        var lastTab = false;

	        for (i = 0; i < tabs.length && !lastTab; i++) {
	          // tab width
	          if (sizes && sizes.max) {
	            if (sizes.max == i + 1) {
	              lastTab = true;
	            }

	            contentWidth = common._input_width - obj.tabOffset * 2 - (!obj.type && sizes.max > 1 ? obj.tabMargin * (sizes.max - 1) : 0);
	            width = (contentWidth - obj.tabMoreWidth) / sizes.max;
	          } else width = sizes.width;

	          width = tabs[i].width || obj.optionWidth || width;
	          sum += width + (i && !obj.type ? obj.tabMargin : 0);
	          if (obj.tabMargin > 0 && i && !obj.type) html += "<div class='webix_tab_filler' style='width:" + obj.tabMargin + "px;'></div>"; // tab innerHTML

	          html += common._getTabHTML(tabs[i], width);

	          if (lastTab) {
	            html += "<div role=\"button\" tabindex=\"0\" aria-label=\"" + i18n.aria.showTabs + "\" class=\"webix_tab_more_icon\" style=\"width:" + obj.tabMoreWidth + "px;\">" + obj.moreTemplate(obj, common) + "</div>";
	            sum += obj.tabMoreWidth;
	          }
	        }

	        leafWidth = common._content_width - sum;
	        if (leafWidth > 0 && !obj.type) html += "<div class='webix_tab_filler' style='width:" + leafWidth + "px;'>&nbsp;</div>";
	      }

	      resultHTML = ""; // consider top and bottom offset in tabs height (top tabbar)

	      style = verticalOffset && !obj.type ? "height:" + (common._content_height - verticalOffset) + "px" : ""; //space above tabs (top tabbar)

	      if (obj.topOffset && !obj.type) resultHTML += "<div class='webix_before_all_tabs' style='width:100%;height:" + obj.topOffset + "px'></div>"; // tabs html

	      resultHTML += "<div style='" + style + "' role='tablist' class='webix_all_tabs " + (obj.type ? "webixtype_" + obj.type : "") + "'>" + html + "</div>"; //space below to tabs (top tabbar)

	      if (obj.bottomOffset && !obj.type) resultHTML += "<div class='webix_after_all_tabs' style='width:100%;height:" + obj.bottomOffset + "px'></div>";
	      return resultHTML;
	    }
	  },
	  _getInputNode: function () {
	    return this.$view.querySelectorAll(".webix_item_tab");
	  },
	  _getTabHTML: function (tab, width) {
	    var html,
	        className = "",
	        tooltip = "",
	        config = this.config;
	    if (tab.id == config.value) className = " webix_selected";
	    if (tab.css) className += " " + tab.css;
	    if (config.tooltip) tooltip = " webix_t_id='" + tab.id + "'";
	    width = tab.width || width;
	    html = "<div class=\"webix_item_tab" + className + "\" button_id=\"" + tab.id + "\" role=\"tab\" aria-selected=\"" + (tab.id == config.value ? "true" : "false") + "\" tabindex=\"" + (tab.id == config.value ? "0" : "-1") + "\" style=\"width:" + width + "px;\"" + tooltip + ">"; // a tab title

	    if (this._tabTemplate) {
	      var calcHeight = this._content_height - config.inputPadding * 2 - 2;
	      var height = this._content_height - 2;
	      var temp = exports.extend({
	        cheight: calcHeight,
	        aheight: height
	      }, tab);
	      html += this._tabTemplate(temp);
	    } else {
	      var icon = tab.icon ? "<span class='webix_icon " + tab.icon + "'></span> " : "";
	      html += icon + tab.value;
	    }

	    if (tab.close || config.close) html += "<span role='button' tabindex='0' aria-label='" + i18n.aria.closeTab + "' class='webix_tab_close webix_icon wxi-close'></span>";
	    html += "</div>";
	    return html;
	  },
	  _getBox: function () {
	    return this._dataobj.firstChild;
	  },
	  _types: {
	    image: "<div class='webix_img_btn_top' style='height:#cheight#px;background-image:url(#image#);'><div class='webix_img_btn_text'>#value#</div></div>",
	    icon: "<div class='webix_img_btn' style='line-height:#cheight#px;height:#cheight#px;'><span class='webix_icon_btn #icon#' style='max-width:#cheight#px;max-height:#cheight#px;'></span>#value#</div>",
	    iconTop: "<div class='webix_img_btn_top' style='height:#cheight#px;width:100%;top:0px;text-align:center;'><span class='webix_icon #icon#'></span><div class='webix_img_btn_text'>#value#</div></div>"
	  },
	  type_setter: function (value) {
	    this._settings.tabOffset = 0;
	    if (this._types[value]) this._tabTemplate = template(this._types[value]);
	    return value;
	  }
	};
	var view$N = exports.protoUI(api$N, segmented.view);

	var api$O = {
	  name: "richtext",
	  defaults: {
	    label: "",
	    labelWidth: 80,
	    labelPosition: "left"
	  },
	  $init: function () {
	    this._viewobj.className += " webix_richtext";
	    this.$ready.unshift(this._setLayout);
	  },
	  getInputNode: function () {
	    return this.$view.querySelector(".webix_richtext_editor");
	  },
	  _button: function (name) {
	    return {
	      view: "toggle",
	      type: "iconButton",
	      icon: "wxi-" + name,
	      name: name,
	      id: name,
	      label: i18n.richtext[name],
	      autowidth: true,
	      action: name,
	      click: this._add_data
	    };
	  },
	  _setLayout: function () {
	    var top = this;
	    var editField = {
	      view: "template",
	      css: "webix_richtext_container",
	      borderless: true,
	      template: "<div class='webix_richtext_editor' contenteditable='true'>" + this.getValue() + "</div>",
	      on: {
	        onAfterRender: function () {
	          top._rendered_input = true;

	          _event(top.getInputNode(), "blur", function () {
	            top._updateValue(this.innerHTML);
	          });

	          _event(top.getInputNode(), "keyup", function () {
	            top._getselection();
	          });
	        }
	      },
	      onClick: {
	        webix_richtext_editor: function () {
	          top._getselection();
	        }
	      }
	    };
	    var editorToolbar = {
	      view: "toolbar",
	      id: "toolbar",
	      elements: [this._button("underline"), this._button("bold"), this._button("italic"), {}]
	    };
	    var rows = [editorToolbar, editField];

	    if (this.config.labelPosition === "top" || !this.config.labelWidth) {
	      editorToolbar.elements.concat([{
	        view: "label",
	        label: this.config.label,
	        align: "right"
	      }, {
	        width: 4
	      }]);
	      this.rows_setter(rows);
	    } else {
	      this.config.borderless = true;
	      this.cols_setter([{
	        template: this.config.label || " ",
	        css: "webix_richtext_inp_label" + (this.config.required ? " webix_required" : ""),
	        borderless: true,
	        width: this.config.labelWidth
	      }, {
	        rows: rows
	      }]);
	    }
	  },
	  _getselection: function () {
	    var top = this;
	    var bar = top.$$("toolbar");
	    var sel;
	    bar.setValues({
	      italic: false,
	      underline: false,
	      bold: false
	    });

	    if (window.getSelection) {
	      sel = window.getSelection();
	    } else {
	      sel = document.selection.createRange();
	    }

	    for (var i = 0; i < sel.rangeCount; ++i) {
	      if (top.$view.contains(this.getInputNode())) {
	        if (document.queryCommandState("bold")) {
	          top.$$("bold").setValue(true);
	        }

	        if (document.queryCommandState("underline")) {
	          top.$$("underline").setValue(true);
	        }

	        if (document.queryCommandState("italic")) {
	          top.$$("italic").setValue(true);
	        }
	      }
	    }
	  },
	  refresh: function () {
	    if (this._rendered_input) this.getInputNode().innerHTML = this.config.value;
	  },
	  _execCommandOnElement: function (el, commandName) {
	    var sel, selText;

	    if (window.getSelection()) {
	      sel = window.getSelection();
	      selText = sel.toString().length;
	    } else {
	      sel = document.selection.createRange();
	      selText = sel.text.length;
	    }

	    if (selText > 0) {
	      for (var i = 0; i < sel.rangeCount; ++i) {
	        var range = sel.getRangeAt(i);

	        if (!sel.isCollapsed) {
	          document.execCommand(commandName, false, "");
	        } else {
	          var textValue = sel.focusNode.textContent;
	          var focusEl = sel.focusNode;
	          var focustext = sel.anchorOffset;
	          var wordBegining = textValue.substring(0, focustext).match(/[A-Za-z]*$/)[0];
	          var wordEnd = textValue.substring(focustext).match(/^[A-Za-z]*/)[0];
	          var startWord = focustext - wordBegining.length;
	          var endWord = focustext + wordEnd.length;
	          range.setStart(focusEl, startWord);
	          range.setEnd(focusEl, endWord);
	          sel.removeAllRanges();
	          window.getSelection().addRange(range);
	          document.execCommand(commandName, false, "");
	        }
	      }
	    }
	  },
	  _add_data: function () {
	    var top = this.getTopParentView();
	    var editableElement = top.getInputNode();

	    if (this.$view.contains(this.getInputNode())) {
	      top._execCommandOnElement(editableElement, this.config.action);
	    }
	  },
	  focus: function () {
	    if (!UIManager.canFocus(this)) return false;
	    var editableElement = this.$view.querySelector(".webix_richtext_editor");
	    editableElement.focus();
	  },
	  _updateValue: function (value) {
	    var old = this.config.value;
	    this.config.value = value || "";
	    if (old !== value) this.callEvent("onChange", [value, old]);
	  },
	  setValue: function (value) {
	    this._updateValue(value);

	    this.refresh();
	  },
	  getValue: function () {
	    var input = this.getInputNode();
	    if (input) this.config.value = this.getInputNode().innerHTML;
	    var value = this.config.value;
	    return value || (value === 0 ? "0" : "");
	  }
	};
	var view$O = exports.protoUI(api$O, IdSpace, layout.view);

	var api$P = {
	  name: "proto",
	  $init: function () {
	    this.data.provideApi(this, true);
	    this._dataobj = this._dataobj || this._contentobj; //render self , each time when data is updated

	    this.data.attachEvent("onStoreUpdated", bind(function () {
	      this.render.apply(this, arguments);
	    }, this));
	  },
	  $setSize: function () {
	    if (base.api.$setSize.apply(this, arguments)) this.render();
	  },
	  _id: "webix_item",
	  on_mouse_move: {},
	  type: {}
	};
	var view$P = exports.protoUI(api$P, PagingAbility, DataMarks, AutoTooltip, ValidateCollection, RenderStack, DataLoader, base.view, EventSystem, Settings);
	var proto = {
	  api: api$P,
	  view: view$P
	};

	var api$Q = {
	  name: "list",
	  _listClassName: "webix_list",
	  _itemClassName: "webix_list_item",
	  $init: function (config) {
	    addCss(this._viewobj, this._listClassName + ((config.layout || this.defaults.layout) == "x" ? "-x" : ""));
	    this.data.provideApi(this, true);
	    this._auto_resize = bind(this._auto_resize, this);
	    this.data.attachEvent("onStoreUpdated", this._auto_resize);
	    this.data.attachEvent("onSyncApply", this._auto_resize);
	    this.attachEvent("onAfterRender", this._correct_width_scroll);

	    this._viewobj.setAttribute("role", "listbox");
	  },
	  dynamic_setter: function (value) {
	    if (value) exports.extend(this, VRenderStack, true);
	    return value;
	  },
	  $dragHTML: function (obj, e, context) {
	    var html;

	    if (this._settings.layout == "y" && this.type.width == "auto") {
	      this.type.width = this._content_width;
	      html = this._toHTML(obj);
	      this.type.width = "auto";
	    } else html = this._toHTML(obj);

	    if (isArray(context.source) && context.source.length > 1) html = this._toMultipleHTML(html, context.source.length);
	    return html;
	  },
	  defaults: {
	    select: false,
	    scroll: true,
	    layout: "y",
	    navigation: true,
	    datafetch: 50
	  },
	  _id: "webix_l_id",
	  on_click: {
	    webix_list_item: function (e, id) {
	      if (this._settings.select) {
	        this._no_animation = true;
	        if (this._settings.select == "multiselect" || this._settings.multiselect) this.select(id, false, e.ctrlKey || e.metaKey || this._settings.multiselect == "touch", e.shiftKey); //multiselection
	        else this.select(id);
	        this._no_animation = false;
	      }
	    }
	  },
	  on_dblclick: {},
	  getVisibleCount: function () {
	    return Math.floor(this._content_height / this._one_height());
	  },
	  _auto_resize: function () {
	    if (this._settings.autoheight || this._settings.autowidth) this.resize();
	  },
	  _auto_height_calc: function (count) {
	    var value = this.data.$pagesize || this.count();

	    this._onoff_scroll(count && count < value, "y");

	    if (this._settings.autoheight && value < (count || Infinity)) count = value;
	    var height = this._one_height() * count + (this.type.margin || 0); //unitlist

	    if (this.getUnits) height += this.getUnits().length * this.type.headerHeight;
	    return Math.max(height, this._settings.minHeight || 0);
	  },
	  _one_height: function () {
	    return this.type.height + (this.type.margin || 0);
	  },
	  _auto_width_calc: function (count) {
	    var value = this.data.$pagesize || this.count();

	    this._onoff_scroll(count && count < value, "x");

	    if (this._settings.autowidth && value < (count || Infinity)) count = value;
	    return this.type.width * count;
	  },
	  _correct_width_scroll: function () {
	    if (this._settings.layout == "x") this._dataobj.style.width = this.type.width != "auto" ? this.type.width * this.count() + "px" : "auto";
	  },
	  $getSize: function (dx, dy) {
	    if (this._settings.layout == "y") {
	      if (this.type.width != "auto") this._settings.width = this.type.width + (this._scroll_y ? env.scrollSize : 0);
	      if (this._settings.yCount || this._settings.autoheight) this._settings.height = this._auto_height_calc(this._settings.yCount) || 1;
	    } else {
	      if (this.type.height != "auto") this._settings.height = this._one_height() + (this._scroll_x ? env.scrollSize : 0);
	      if (this._settings.xCount || this._settings.autowidth) this._settings.width = this._auto_width_calc(this._settings.xCount) || 1;
	    }

	    return base.api.$getSize.call(this, dx, dy);
	  },
	  $setSize: function () {
	    base.api.$setSize.apply(this, arguments);
	  },
	  type: {
	    css: "",
	    widthSize: function (obj, common) {
	      return common.width + (common.width > -1 ? "px" : "");
	    },
	    heightSize: function (obj, common) {
	      return common.height + (common.height > -1 ? "px" : "");
	    },
	    classname: function (obj, common, marks) {
	      var css = "webix_list_item";
	      if (common.css) css += " " + common.css;

	      if (obj.$css) {
	        if (_typeof(obj.$css) == "object") obj.$css = createCss(obj.$css);
	        css += " " + obj.$css;
	      }

	      if (marks && marks.$css) css += " " + marks.$css;
	      return css;
	    },
	    aria: function (obj, common, marks) {
	      return "role=\"option\"" + (marks && marks.webix_selected ? " aria-selected=\"true\" tabindex=\"0\"" : " tabindex=\"-1\"") + (obj.$count && obj.$template ? "aria-expanded=\"true\"" : "");
	    },
	    template: function (obj) {
	      return (obj.icon ? "<span class='webix_list_icon webix_icon " + obj.icon + "'></span>" : "") + obj.value + (obj.badge ? "<div class='webix_badge'>" + obj.badge + "</div>" : "");
	    },
	    width: "auto",
	    templateStart: template("<div webix_l_id=\"#id#\" class=\"{common.classname()}\" style=\"width:{common.widthSize()}; height:{common.heightSize()}; overflow:hidden;\" {common.aria()}>"),
	    templateEnd: template("</div>")
	  },
	  $skin: function () {
	    this.type.height = $active.listItemHeight;
	  }
	};
	var view$Q = exports.protoUI(api$Q, CustomPrint, KeysNavigation, DataMove, DragItem, MouseEvents, SelectionModel, Scrollable, proto.view, CopyPaste);
	var list = {
	  api: api$Q,
	  view: view$Q
	};

	/*
		UI:Uploader
	*/
	// #include ui/view.js
	// #include ui/list.js

	type(list.view, {
	  name: "uploader",
	  template: "{common.removeIcon()}{common.percent()}<div style='float:right'>#sizetext#</div>{common.fileName()}",
	  percent: function (obj) {
	    if (obj.status == "transfer") return "<div style='width:60px; text-align:center; float:right'>" + obj.percent + "%</div>";
	    return "<div class='webix_upload_" + obj.status + "'><span class='" + (obj.status == "error" ? "error_icon" : "webix_icon wxi-check") + "'></span></div>";
	  },
	  removeIcon: function () {
	    return "<div class='webix_remove_upload'><span class='cancel_icon'></span></div>";
	  },
	  fileName: function (obj) {
	    return "<div style='text-overflow:ellipsis; white-space:nowrap; overflow:hidden; padding-right:8px;'>" + obj.name + "</div>";
	  },
	  on_click: {
	    "webix_remove_upload": function (ev, id) {
	      $$(this.config.uploader).files.remove(id);
	    }
	  }
	});
	var api$R = {
	  name: "uploader",
	  defaults: {
	    autosend: true,
	    multiple: true,
	    inputName: "upload"
	  },
	  $cssName: "button webix_uploader",
	  $allowsClear: true,
	  on_click: {
	    //don't fire extra onItemClick events, visible button will do it
	    "webix_hidden_upload": function () {
	      return false;
	    }
	  },
	  //will be redefined by upload driver
	  send: function () {},
	  fileDialog: function () {},
	  stopUpload: function () {},
	  $init: function () {
	    var driver = UploadDriver.html5;
	    this.files = new DataCollection();
	    this._destroy_with_me = [this.files]; // browser doesn't support XMLHttpRequest2

	    if (isUndefined(XMLHttpRequest) || isUndefined(new XMLHttpRequest().upload)) driver = UploadDriver.flash;
	    assert(driver, "incorrect driver");
	    exports.extend(this, driver, true);
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      this.render();
	    }
	  },
	  apiOnly_setter: function (value) {
	    delay(this.render, this);
	    return this.$apiOnly = value;
	  },
	  _add_files: function (files) {
	    for (var i = 0; i < files.length; i++) {
	      this.addFile(files[i]);
	    }
	  },
	  link_setter: function (value) {
	    if (value) delay(function () {
	      var view = $$(this._settings.link);

	      if (!view) {
	        var top = this.getTopParentView();
	        if (top.$$) view = top.$$(this._settings.link);
	      }

	      if (view.sync && view.filter) view.sync(this.files);else if (view.setValues) this.files.data.attachEvent("onStoreUpdated", function () {
	        view.setValues(this);
	      });
	      view._settings.uploader = this._settings.id;
	    }, this);
	    return value;
	  },
	  addFile: function (name, size, type$$1, extra) {
	    var file = null;

	    if (_typeof(name) == "object") {
	      file = name;
	      name = file.name;
	      size = file.size;
	    }

	    var format = this._format_size(size);

	    type$$1 = type$$1 || name.split(".").pop();
	    var file_struct = {
	      file: file,
	      name: name,
	      id: uid(),
	      size: size,
	      sizetext: format,
	      type: type$$1,
	      context: this._last_file_context,
	      status: "client"
	    };
	    if (file && file.webkitRelativePath) file_struct.name = file.webkitRelativePath;
	    if (extra) exports.extend(file_struct, extra, true);

	    if (this.callEvent("onBeforeFileAdd", [file_struct])) {
	      if (!this._settings.multiple) this.files.clearAll();
	      var id = this.files.add(file_struct);
	      this.callEvent("onAfterFileAdd", [file_struct]);
	      if (id && this._settings.autosend) this.send(id);
	    }

	    return file_struct;
	  },
	  _get_active_url: function (item) {
	    var url = this._settings.upload;
	    var urldata = exports.extend(item.urlData || {}, this._settings.urlData || {});

	    if (url && urldata) {
	      var subline = [];

	      for (var key in urldata) {
	        subline.push(encodeURIComponent(key) + "=" + encodeURIComponent(urldata[key]));
	      }

	      if (subline.length) url += (url.indexOf("?") == -1 ? "?" : "&") + subline.join("&");
	    }

	    return url;
	  },
	  addDropZone: function (id, hover_text) {
	    var node = toNode(id);
	    var extra_css = "";
	    if (hover_text) extra_css = " " + createCss({
	      content: "\"" + hover_text + "\""
	    }, ":before");
	    var fullcss = "webix_drop_file" + extra_css;
	    var timer = null; //web

	    _event(node, "dragover", preventEvent);

	    _event(node, "dragover", function () {
	      addCss(node, fullcss, true);

	      if (timer) {
	        clearTimeout(timer);
	        timer = null;
	      }
	    });

	    _event(node, "dragleave", function () {
	      //when moving over html child elements
	      //browser will issue dragleave and dragover events
	      //ignore first one
	      timer = setTimeout(function () {
	        removeCss(node, fullcss);
	      }, 150);
	    });

	    _event(node, "drop", bind(function (e) {
	      removeCss(node, fullcss);

	      this._drop(e);

	      return preventEvent(e);
	    }, this));
	  },
	  _format_size: function (size) {
	    var index$$1 = 0;

	    while (size > 1024) {
	      index$$1++;
	      size = size / 1024;
	    }

	    return Math.round(size * 100) / 100 + " " + i18n.fileSize[index$$1];
	  },
	  _complete: function (id, response) {
	    var item = this.files.getItem(id);
	    exports.extend(item, response, true);
	    item.status = "server";
	    item.progress = 100;
	    this.callEvent("onFileUpload", [item, response]);
	    this.callEvent("onChange", []);
	    this.files.updateItem(id);
	    if (this.isUploaded()) this._upload_complete(response);
	  },
	  _upload_complete: function (response) {
	    this.callEvent("onUploadComplete", [response]);

	    if (this._last_assigned_upload_callback) {
	      this._last_assigned_upload_callback.call(this, response);

	      this._last_assigned_upload_callback = 0;
	    }
	  },
	  isUploaded: function () {
	    var order = this.files.data.order;

	    for (var i = 0; i < order.length; i++) {
	      if (this.files.getItem(order[i]).status != "server") return false;
	    }

	    return true;
	  },
	  $onUploadComplete: function () {},
	  $updateProgress: function (id, percent) {
	    var item = this.files.getItem(id);
	    item.percent = Math.round(percent);
	    this.files.updateItem(id);
	  },
	  setValue: function (value) {
	    if (typeof value == "string" && value) value = {
	      value: value,
	      status: "server"
	    };
	    this.files.clearAll();
	    if (value) this.files.parse(value);
	    this.callEvent("onChange", []);
	  },
	  getValue: function () {
	    var data = [];
	    this.files.data.each(function (obj) {
	      if (obj.status == "server") data.push(obj.value || obj.name);
	    });
	    return data.join(",");
	  }
	};
	var view$R = exports.protoUI(api$R, button$1.view);

	var api$S = {
	  name: "suggest",
	  defaults: {
	    autofocus: false,
	    type: "list",
	    keyPressTimeout: 1,
	    body: {
	      yCount: 10,
	      autoheight: true,
	      body: true,
	      select: true,
	      borderless: true,
	      navigation: true
	    },
	    filter: function (item, value) {
	      if (item.value.toString().toLowerCase().indexOf(value.toLowerCase()) === 0) return true;
	      return false;
	    }
	  },
	  template_setter: template,
	  filter_setter: function (value) {
	    return toFunctor(value, this.$scope);
	  },
	  $init: function (obj) {
	    var temp = {};
	    exports.extend(temp, copy(this.defaults.body));
	    temp.view = obj.type || this.defaults.type;

	    var etemp = this._get_extendable_cell(temp);

	    if (obj.body) exports.extend(etemp, obj.body, true);
	    if (obj.data) etemp.data = obj.data;
	    if (obj.url) etemp.url = obj.url;
	    if (obj.datatype) etemp.datatype = obj.datatype;
	    if (obj.id) temp.id = temp.id || obj.id + "_" + temp.view;
	    obj.body = temp;
	    this.$ready.push(this._set_on_popup_click);
	    this.attachEvent("onShow", function () {
	      if (this._settings.master) {
	        var master = $$(this._settings.master);

	        if (master) {
	          var node = master._getInputDiv ? master._getInputDiv() : master.getInputNode();
	          node.setAttribute("aria-expanded", "true");
	        }
	      }

	      this._show_selection();
	    });
	    this.attachEvent("onHide", function () {
	      if (this._settings.master) {
	        var master = $$(this._settings.master);

	        if (master) {
	          var node = master._getInputDiv ? master._getInputDiv() : master.getInputNode();
	          node.setAttribute("aria-expanded", "false");
	        }
	      }
	    });
	    this._old_text = {};
	  },
	  _get_extendable_cell: function (obj) {
	    return obj;
	  },
	  _preselectMasterOption: function (data) {
	    var master,
	        node,
	        text = "";

	    if (data) {
	      if (this._settings.master) {
	        master = $$(this._settings.master);
	        node = master.getInputNode();

	        if (node && master.$setValueHere) {
	          master.$setValueHere(data.value);
	        } else if (node) {
	          if (master.options_setter) text = this.getItemText(data.id);else if (data.value) text = master._get_visible_text ? master._get_visible_text(data.value) : data.value.toString();
	          if (isUndefined(node.value)) node.innerHTML = text;else node.value = text.replace(/<[^>]*>/g, "");
	        }
	      }
	    }

	    node = node || this._last_input_target;
	    if (node) node.focus();
	  },
	  setMasterValue: function (data, refresh) {
	    var text = data.id ? this.getItemText(data.id) : data.text || data.value;

	    if (this._settings.master) {
	      var master = $$(this._settings.master);
	      if (refresh && data.id) master.refresh();else if (master.options_setter) master.setValue(data.$empty ? "" : data.id);else if (master.setValueHere) master.setValueHere(text);else master.setValue(text);
	    } else if (this._last_input_target) {
	      this._last_input_target.value = text;
	    }

	    if (!refresh) {
	      this.hide(true);
	      if (this._last_input_target) this._last_input_target.focus();
	    }

	    this.callEvent("onValueSuggest", [data, text]);
	    delay(function () {
	      callEvent("onEditEnd", []);
	    });
	  },
	  getMasterValue: function () {
	    if (this._settings.master) return $$(this._settings.master).getValue();
	    return null;
	  },
	  getItemId: function (text) {
	    var list = this.getList();

	    for (var key in list.data.pull) {
	      var obj = list.getItem(key);
	      if (this._settings.filter.call(this, obj, text)) return obj.id;
	    }
	  },
	  getItemText: function (id) {
	    var item = this.getList().getItem(id);
	    if (!item) return this._old_text[id] || "";
	    if (this._settings.template) return this._settings.template.call(this, item, this.type);
	    if (this._settings.textValue) return "" + item[this._settings.textValue] + "";
	    var type = this.getList().type;
	    var text = type.template.call(type, item, type);
	    return this._old_text[id] = text;
	  },
	  getSuggestion: function (text) {
	    var id,
	        list = this.getList(),
	        order = list.data.order;
	    if (list.getSelectedId) id = list.getSelectedId();

	    if (text && order.length && (!id || order.find(id) < 0)) {
	      id = order[0]; //ensure that option really does match client-side filtering rules

	      if (!list.config.dataFeed && !this.config.filter.call(this, list.data.pull[id], text)) return null;
	    } //complex id in datatable


	    if (id && _typeof(id) == "object") id = id + "";
	    return id;
	  },
	  getList: function () {
	    return this._body_cell;
	  },
	  _set_on_popup_click: function () {
	    var list = this.getList();
	    var type = this._settings.type;

	    if (list.count) {
	      list.attachEvent("onItemClick", bind(function (item) {
	        this.setMasterValue(list.getItem(item));
	      }, this));
	      list.data.attachEvent("onstoreupdated", bind(function (id, obj, mode) {
	        if (mode == "delete" && id == this.getMasterValue()) this.setMasterValue({
	          id: "",
	          text: ""
	        }, 1);else if (mode == "update" && id == this.getMasterValue()) {
	          this.setMasterValue(obj, 1);
	        }
	      }, this));
	      list.data.attachEvent("onAfterFilter", bind(this._suggest_after_filter, this));
	      list.data.attachEvent("onStoreLoad", bind(this._suggest_after_filter, this));
	      if (isUndefined(this._settings.fitMaster)) this._settings.fitMaster = true;
	    } else if (type == "calendar") {
	      list.attachEvent("onDateSelect", function () {
	        this.getParentView().setMasterValue({
	          value: list.getSelectedDate()
	        }, list.config.multiselect);
	      });
	      list.attachEvent("onTodaySet", function (date) {
	        this.getParentView().setMasterValue({
	          value: date
	        });
	      });
	      list.attachEvent("onDateClear", function (date) {
	        this.getParentView().setMasterValue({
	          value: date
	        });
	      });
	    } else if (type == "colorboard") {
	      list.attachEvent("onItemClick", function (value) {
	        this.getParentView().setMasterValue({
	          value: value
	        });
	      });
	    }
	  },
	  input_setter: function (value) {
	    this.linkInput(value);
	    return 0;
	  },
	  linkInput: function (input) {
	    var node;

	    if (input.getInputNode) {
	      node = input.getInputNode();
	      node.webix_master_id = input._settings.id;
	    } else node = toNode(input);

	    _event(node, "keydown", function (e) {
	      if ((node != document.body || this.isVisible()) && (input.config ? !input.config.readonly : !node.getAttribute("readonly"))) this._suggestions(e);
	    }, {
	      bind: this
	    });

	    if (input._getInputDiv) node = input._getInputDiv();
	    node.setAttribute("aria-autocomplete", "list");
	    node.setAttribute("aria-expanded", "false");

	    if (node.tagName === "DIV") {
	      node.setAttribute("aria-live", "assertive");
	      node.setAttribute("aria-atomic", "true");
	    }

	    this._non_ui_mode = true;
	  },
	  _suggestions: function (e) {
	    e = e || event;
	    var list = this.getList();
	    var trg = e.target || e.srcElement;
	    if (trg == document.body && !this.isVisible() || trg.className == "webix_clipbuffer") return;
	    this._last_input_target = trg;
	    this._settings.master = trg.webix_master_id;
	    window.clearTimeout(this._key_timer);
	    var code = e.keyCode; //shift and ctrl

	    if (code == 16 || code == 17) return; // tab - hide popup and do nothing

	    if (code == 9) return this._tab_key(this, list); // escape - hide popup

	    if (code == 27) return this._escape_key(this, list); // enter

	    if (code == 13) return this.$enterKey(this, list); // up/down/right/left are used for navigation

	    if (this._navigate(e)) {
	      preventEvent(e);
	      return false;
	    }

	    if (isUndefined(trg.value)) return;
	    clearTimeout(this._last_delay);
	    this._last_delay = delay(function () {
	      //focus moved to the different control, suggest is not necessary
	      if (!this._non_ui_mode && UIManager.getFocus() != $$(this._settings.master)) return;
	      this._resolve_popup = true; //for multicombo

	      var val = trg.value; // used to prevent showing popup when it was initialized

	      if (list.config.dataFeed) list.filter("value", val);else if (list.filter) {
	        list.filter(bind(function (item) {
	          return this._settings.filter.call(this, item, val);
	        }, this));
	      }
	    }, this, [], this._settings.keyPressTimeout);
	  },
	  _suggest_after_filter: function () {
	    if (!this._resolve_popup) return true;
	    this._resolve_popup = false;
	    var list = this.getList(); // filtering is complete
	    // if there are as min 1 variant it must be shown, hidden otherwise

	    if (list.count() > 0) {
	      this.adjust();
	      if (!this.isVisible()) this._dont_unfilter = true;
	      this.show(this._last_input_target, null, true);
	      this._dont_unfilter = false;
	    } else {
	      this.hide(true);
	      this._last_input_target = null;
	    }
	  },
	  show: function (node) {
	    if (!this.isVisible()) {
	      var list = this.getList();

	      if (list.filter && !this._dont_unfilter) {
	        list.filter("");
	      }

	      if (this.$customWidth) {
	        this.$customWidth(node);
	      } else if (node.tagName && this._settings.fitMaster) {
	        this._settings.width = node.offsetWidth - 2; //2 - borders
	      }

	      if (list._zoom_level) list.render();
	      this.adjust(); // needed to return focus

	      if (node.tagName == "INPUT") this._last_input_target = node;
	    }

	    popup.api.show.apply(this, arguments);
	  },
	  _show_selection: function (list) {
	    list = list || this.getList();
	    var value = this.getMasterValue();

	    if (list.select && list.showItem) {
	      if (value && list.exists && list.exists(value)) {
	        list.select(value);
	        list.showItem(value);
	      } else {
	        list.unselect();
	        list.showItem(list.getFirstId());
	      }
	    } else if (list.setValue) {
	      if (this._settings.master) value = $$(this._settings.master).$prepareValue(value);
	      list.setValue(value);
	    }
	  },
	  $enterKey: function (popup$$1, list) {
	    var value;

	    if (popup$$1.isVisible()) {
	      if (list.count && list.count()) {
	        value = list.getSelectedId(false, true);
	        if (list.count() == 1 && list.getFirstId() != value) value = list.getFirstId();
	        if (value) value = list.getItem(value);
	      } else if (list.getSelectedDate && list.getSelectedDate()) value = {
	        value: list.getSelectedDate()
	      };else if (list.getValue && list.getValue()) value = {
	        value: list.getValue()
	      };

	      if (value) this.setMasterValue(value);
	      popup$$1.hide(true);
	    } else popup$$1.show(this._last_input_target);
	  },
	  _escape_key: function (popup$$1) {
	    return popup$$1.hide(true);
	  },
	  _tab_key: function (popup$$1) {
	    return popup$$1.hide(true);
	  },

	  /*! suggestions navigation: up/down buttons move selection
	   *	@param e
	   *		event object
	   **/
	  _navigate: function (e) {
	    var list = this.getList();
	    var code = e.keyCode;
	    var data;

	    if (list.moveSelection && code < 41 && code > 32 && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {
	      // down arrow
	      if (code === 40) {
	        var visible = this.isVisible();
	        if (!visible) this.show(this._last_input_target);
	        list.moveSelection("down", false, false);
	      } // other arrows
	      else {
	          if (list.count && code !== 38 || !list.count && !list.isVisible()) return false;
	          var dir;
	          if (code == 33) dir = "pgup";
	          if (code == 34) dir = "pgdown";
	          if (code == 35) dir = "bottom";
	          if (code == 36) dir = "top";
	          if (code == 37) dir = "left";
	          if (code == 38) dir = "up";
	          if (code == 39) dir = "right";
	          list.moveSelection(dir, false, false);
	        }

	      if (list.count) data = list.getSelectedItem();else if (list.getSelectedDate) data = {
	        value: list.getVisibleDate()
	      };else if (list.getValue) data = {
	        value: list.getValue()
	      };

	      this._preselectMasterOption(data);

	      return true;
	    }

	    return false;
	  },
	  getValue: function () {
	    var list = this.getList();
	    var value = (list.getValue ? list.getValue() : list.getSelectedId()) || "";
	    value = value.id || value; // check empty

	    if (list.getItem) {
	      var item = list.getItem(value);
	      if (item && item.$empty) return "";
	    }

	    return value;
	  },
	  setValue: function (value) {
	    var list = this.getList();

	    if (value) {
	      if (list.exists(value)) {
	        list.select(value);
	        list.showItem(value);
	      }
	    } else {
	      list.unselect();
	      list.showItem(list.getFirstId());
	    }
	  }
	};
	var view$S = exports.protoUI(api$S, popup.view);
	var suggest = {
	  api: api$S,
	  view: view$S
	};

	exports.protoUI({
	  name: "multisuggest",
	  defaults: {
	    template: "GPL version doesn't support multisuggest <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "checksuggest",
	  defaults: {
	    template: "GPL version doesn't support checksuggest <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "datasuggest",
	  defaults: {
	    template: "GPL version doesn't support datasuggest <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "gridsuggest",
	  defaults: {
	    template: "GPL version doesn't support gridsuggest <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "daterange",
	  defaults: {
	    template: "GPL version doesn't support daterange <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$T = {
	  name: "daterangesuggest",
	  defaults: {
	    type: "daterange",
	    body: {
	      view: "daterange",
	      icons: true,
	      button: true,
	      borderless: true
	    }
	  },
	  getValue: function () {
	    return this.getRange().getValue();
	  },
	  setValue: function (value) {
	    this.getRange().setValue(copy(value));
	  },
	  getRange: function () {
	    return this.getBody();
	  },
	  getButton: function () {
	    return this.getBody().getChildViews()[1].getChildViews()[1];
	  },
	  _setValue: function (value, hide) {
	    var master = $$(this._settings.master);

	    if (master) {
	      master.setValue(value);
	      if (hide) this.hide();
	    } else this.setValue(value);
	  },
	  _set_on_popup_click: function () {
	    var range = this.getRange();
	    range.attachEvent("onAfterDateSelect", bind(function (value) {
	      this._setValue(value);
	    }, this));
	    range.attachEvent("onDateClear", bind(function (value) {
	      this._setValue(value);
	    }, this));
	    range.attachEvent("onTodaySet", bind(function (value) {
	      this._setValue(value);
	    }, this));
	  }
	};
	var view$T = exports.protoUI(api$T, suggest.view);

	var api$U = {
	  $cssName: "datepicker",
	  name: "daterangepicker",
	  $init: function (config) {
	    //set non-empty initial value
	    this._settings.value = {}; // other types are not implemented

	    delete config.type;
	  },
	  _init_popup: function () {
	    var obj = this._settings;
	    if (obj.suggest) obj.popup = obj.suggest;else if (!obj.popup) {
	      obj.popup = obj.suggest = this.suggest_setter({
	        view: "daterangesuggest",
	        body: {
	          timepicker: obj.timepicker,
	          calendarCount: obj.calendarCount,
	          height: 250 + (obj.button || obj.icons ? 30 : 0)
	        }
	      });
	    }

	    this._init_once = function () {};
	  },
	  $prepareValue: function (value) {
	    value = value || {};
	    value.start = datepicker.api.$prepareValue.call(this, value.start ? value.start : null);
	    value.end = datepicker.api.$prepareValue.call(this, value.end ? value.end : null);
	    var daterange = $$(this._settings.popup).getRange();
	    return copy(daterange._correct_value(value));
	  },
	  $compareValue: function (oldvalue, value) {
	    var compare = datepicker.api.$compareValue;
	    var start = compare.call(this, oldvalue.start, value.start);
	    var end = compare.call(this, oldvalue.end, value.end);
	    return start && end;
	  },
	  $setValue: function (value) {
	    value = value || {};
	    this._settings.text = (value.start ? this._get_visible_text(value.start) : "") + (value.end ? " - " + this._get_visible_text(value.end) : "");

	    this._set_visible_text();
	  },
	  $render: function (obj) {
	    obj.value = this.$prepareValue(obj.value);
	    this.$setValue(obj.value);
	  },
	  getValue: function () {
	    var value = this._settings.value;

	    if (this._settings.stringResult) {
	      var formatStr = i18n.parseFormatStr;
	      return this._formatValue(formatStr, value);
	    }

	    return value || null;
	  },
	  _formatValue: function (format, value) {
	    if (value.start) value.start = format(value.start);
	    if (value.end) value.end = format(value.end);
	    return value;
	  }
	};
	var view$U = exports.protoUI(api$U, datepicker.view);

	exports.protoUI({
	  name: "excelbar",
	  defaults: {
	    template: "GPL version doesn't support excelbar <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "excelviewer",
	  defaults: {
	    template: "GPL version doesn't support excelviewer <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "pdfbar",
	  defaults: {
	    template: "GPL version doesn't support pdfbar <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "pdfviewer",
	  defaults: {
	    template: "GPL version doesn't support pdfviewer <br> You need Webix PRO"
	  }
	}, template$1.view);

	/*
		UI:Video
	*/
	// #include ui/view.js

	var api$V = {
	  name: "video",
	  $init: function (config) {
	    if (!config.id) config.id = uid();
	    this.$ready.push(this._init_video);
	  },
	  _init_video: function () {
	    var c = this._settings;
	    this._contentobj = create("video", {
	      "class": "webix_view_video",
	      "style": "width:100%;height:100%;",
	      "autobuffer": "autobuffer"
	    }, "");
	    if (c.poster) this._contentobj.poster = c.poster;

	    if (c.src) {
	      if (_typeof(c.src) != "object") c.src = [c.src];

	      for (var i = 0; i < c.src.length; i++) {
	        this._contentobj.innerHTML += " <source src=\"" + c.src[i] + "\">";
	      }
	    }

	    if (c.controls) this._contentobj.controls = true;
	    if (c.autoplay) this._contentobj.autoplay = true;

	    this._viewobj.appendChild(this._contentobj);
	  },
	  getVideo: function () {
	    return this._contentobj;
	  },
	  defaults: {
	    src: "",
	    controls: true
	  }
	};
	var view$V = exports.protoUI(api$V, base.view);

	exports.protoUI({
	  name: "gage",
	  defaults: {
	    template: "GPL version doesn't support gage <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "barcode",
	  defaults: {
	    template: "GPL version doesn't support barcode <br> You need Webix PRO"
	  }
	}, template$1.view);

	exports.protoUI({
	  name: "bulletgraph",
	  defaults: {
	    template: "GPL version doesn't support bulletgraph <br> You need Webix PRO"
	  }
	}, template$1.view);

	var google, script;
	var api$W = {
	  name: "geochart",
	  defaults: {
	    chart: {
	      displayMode: "auto",
	      region: "world",
	      resolution: "countries"
	    }
	  },
	  $init: function (config) {
	    this.$view.innerHTML = "<div class='webix_map_content' style='width:100%;height:100%'></div>";
	    this._contentobj = this.$view.firstChild;
	    this._waitMap = Deferred.defer();
	    config.chart = exports.extend(config.chart || {}, this.defaults.chart);
	    this.data.provideApi(this, true);
	    this.$ready.push(this.render);
	    this.data.attachEvent("onClearAll", bind(this._refreshColumns, this));
	    this.data.attachEvent("onStoreUpdated", bind(this._drawData, this));
	  },
	  getMap: function (waitMap) {
	    return waitMap ? this._waitMap : this._map;
	  },
	  _getCallBack: function (prev) {
	    return bind(function () {
	      if (typeof prev === "function") prev();
	      google = google || window.google;

	      this._initMap();
	    }, this);
	  },
	  render: function () {
	    if (typeof window.google == "undefined" || typeof window.google.charts == "undefined") {
	      if (!script) {
	        script = document.createElement("script");
	        script.type = "text/javascript";
	        script.src = "//www.gstatic.com/charts/loader.js";
	        document.getElementsByTagName("head")[0].appendChild(script);
	      }

	      script.onload = this._getCallBack(script.onload);
	    } else //there's a custom link to google api in document head
	      this._getCallBack()();
	  },
	  _initMap: function () {
	    if (!google.visualization || !google.visualization.GeoChart) {
	      google.charts.load("current", {
	        "packages": ["geochart"],
	        "mapsApiKey": this._settings.key
	      });
	      google.charts.setOnLoadCallback(bind(function () {
	        this._initMap();
	      }, this));
	    } else {
	      this._map = new google.visualization.GeoChart(this._contentobj);

	      this._mapEvents();

	      this._waitMap.resolve(this._map);
	    }
	  },
	  $onLoad: function (obj) {
	    if (!this._map) {
	      this._waitMap.then(bind(function () {
	        this.parse(obj, this._settings.datatype);
	      }, this));

	      return true;
	    }

	    return false;
	  },
	  _drawData: function () {
	    if (!this._map) {
	      if (!this._map) this._waitMap.then(bind(this._drawData, this));
	      return;
	    }

	    var columns = this._columns && this._columns.length ? this._columns : this._defineColumns();
	    var data = [];
	    this.data.each(function (obj) {
	      var line = [];

	      for (var c = 0; c < columns.length; c++) {
	        var value = obj[columns[c].label];
	        if (columns[c].type == "number") value = value * 1;else if (columns[c].role == "tooltip") value = this._settings.tooltip(obj);
	        line.push(value);
	      }

	      data.push(line);
	    }, this);

	    if (columns.length) {
	      var table = new google.visualization.DataTable();

	      for (var i = 0; i < columns.length; i++) {
	        table.addColumn(columns[i]);
	      }

	      table.addRows(data);
	      var view = new google.visualization.DataView(table);

	      this._map.draw(view, this._settings.chart);
	    } else //draw clean chart
	      this._map.draw(google.visualization.arrayToDataTable([["", ""]]), {});
	  },
	  setDisplayMode: function (value) {
	    this._settings.chart.displayMode = value;
	    this.refresh();
	  },
	  setRegion: function (value) {
	    this._settings.chart.region = value;
	    this.refresh();
	  },
	  refresh: function () {
	    this._map.clearChart();

	    this._drawData();
	  },
	  tooltip_setter: function (value) {
	    var tooltip = this._settings.chart.tooltip;
	    this._settings.chart.tooltip = exports.extend(tooltip || {}, {
	      isHtml: true
	    });
	    return template(value);
	  },
	  $setSize: function (w, h) {
	    if (base.api.$setSize.apply(this, arguments) && this._map) {
	      exports.extend(this._settings, {
	        width: w,
	        height: h
	      });
	      this.refresh();
	    }
	  },
	  _refreshColumns: function () {
	    this._columns = null;

	    this._drawData();
	  },
	  _getColumnType: function (item, key) {
	    if (!item || isUndefined(item[key])) return "string";

	    var type = _typeof(item[key]);

	    if (type == "string" && !isNaN(item[key] * 1)) type = "number";
	    return type;
	  },
	  _defineColumns: function () {
	    var columns = this._settings.columns || [];
	    var item = this.data.pull[this.data.order[0]]; //auto columns

	    if (!columns.length && item) {
	      for (var key in item) {
	        if (key !== "id") columns.push(key);
	      }
	    } //["title", "area"]


	    for (var i = 0; i < columns.length; i++) {
	      if (_typeof(columns[i]) !== "object") {
	        columns[i] = {
	          type: this._getColumnType(item, columns[i]),
	          label: columns[i]
	        };
	      }
	    }

	    if (this._settings.tooltip) columns.push({
	      type: "string",
	      role: "tooltip",
	      p: {
	        "html": true
	      }
	    });
	    this._columns = columns;
	    return columns;
	  },
	  _mapEvents: function () {
	    google.visualization.events.addListener(this._map, "error", bind(function () {
	      this.callEvent("onMapError", arguments);
	    }, this));
	    google.visualization.events.addListener(this._map, "ready", bind(function () {
	      this.callEvent("onMapReady", arguments);
	    }, this));
	    google.visualization.events.addListener(this._map, "regionClick", bind(function () {
	      this.callEvent("onRegionClick", arguments);
	    }, this));
	    google.visualization.events.addListener(this._map, "select", bind(function () {
	      var selnow = this._map.getSelection()[0];

	      var sel = selnow || this._selprev;

	      if (sel) {
	        var id = this.data.order[sel.row];
	        this._selprev = sel;
	        this.callEvent("onItemClick", [id, !!selnow]);
	      }
	    }, this));
	  }
	};
	var view$W = exports.protoUI(api$W, DataLoader, EventSystem, base.view);

	var google$1, script$1;
	var api$X = {
	  name: "google-map",
	  $init: function () {
	    this.$view.innerHTML = "<div class='webix_map_content' style='width:100%;height:100%'></div>";
	    this._contentobj = this.$view.firstChild;
	    this._waitMap = Deferred.defer();
	    this.data.provideApi(this, true);
	    this.$ready.push(this.render);
	  },
	  getMap: function (waitMap) {
	    return waitMap ? this._waitMap : this._map;
	  },
	  _getCallBack: function (prev) {
	    return bind(function () {
	      if (typeof prev === "function") prev();
	      google$1 = google$1 || window.google;

	      this._initMap.call(this);
	    }, this);
	  },
	  render: function () {
	    if (typeof window.google == "undefined" || typeof window.google.maps == "undefined") {
	      if (!script$1) {
	        script$1 = document.createElement("script");
	        script$1.type = "text/javascript";
	        var config = this._settings;
	        var src = config.src || "//maps.google.com/maps/api/js";
	        src += src.indexOf("?") === -1 ? "?" : "&";
	        if (config.key) src += "&key=" + config.key;
	        if (config.libraries) src += "&libraries=" + config.libraries;
	        script$1.src = src;
	        document.getElementsByTagName("head")[0].appendChild(script$1);
	      }

	      script$1.onload = this._getCallBack(script$1.onload);
	    } else //there's a custom link to google api in document head
	      this._getCallBack()();
	  },
	  _initMap: function () {
	    var c = this.config;

	    if (this.isVisible(c.id)) {
	      this._map = new google$1.maps.Map(this._contentobj, {
	        zoom: c.zoom,
	        center: new google$1.maps.LatLng(c.center[0], c.center[1]),
	        mapTypeId: google$1.maps.MapTypeId[c.mapType]
	      });

	      this._waitMap.resolve(this._map);

	      this._contentobj.firstChild.setAttribute("webix_disable_drag", "true");
	    }
	  },
	  center_setter: function (config) {
	    if (this._map) this._map.setCenter(new google$1.maps.LatLng(config[0], config[1]));
	    return config;
	  },
	  mapType_setter: function (config) {
	    /*ROADMAP,SATELLITE,HYBRID,TERRAIN*/
	    if (this._map) this._map.setMapTypeId(google$1.maps.MapTypeId[config]);
	    return config;
	  },
	  zoom_setter: function (config) {
	    if (this._map) this._map.setZoom(config);
	    return config;
	  },
	  layerType_setter: function (config) {
	    if (config == "heatmap") this.config.libraries = "visualization";

	    if (this._layerApi[config]) {
	      exports.extend(this, this._layerApi[config], true);
	      this.data.attachEvent("onStoreUpdated", bind(function () {
	        this._waitMap.then(bind(function () {
	          this.drawData.call(this, arguments);
	        }, this));
	      }, this));
	    }

	    return config;
	  },
	  defaults: {
	    zoom: 5,
	    center: [39.5, -98.5],
	    mapType: "ROADMAP",
	    layerType: "marker"
	  },
	  $setSize: function () {
	    base.api.$setSize.apply(this, arguments);
	    if (this._map) google$1.maps.event.trigger(this._map, "resize");
	  },
	  $onLoad: function (data) {
	    if (!this._map) {
	      this._waitMap.then(bind(function () {
	        this.parse(data);
	      }, this));

	      return true;
	    }

	    return false;
	  },
	  _layerApi: {
	    marker: {
	      drawData: function (id, item, operation) {
	        switch (operation) {
	          case "add":
	            item.$marker = this._getItemConfig(item);
	            break;

	          case "update":
	            item.$marker = this._getItemConfig(item);
	            break;

	          case "delete":
	            item.$marker.setMap(null);
	            break;

	          default:
	            this.data.each(function (item) {
	              item.$marker = this._getItemConfig(item);
	            }, this);
	            break;
	        }
	      },
	      clearAll: function (soft) {
	        this.data.each(function (obj) {
	          obj.$marker.setMap(null);
	        });
	        this.data.clearAll(soft);
	      },
	      showItem: function (id) {
	        var item = this.getItem(id);

	        this._map.setCenter(new google$1.maps.LatLng(item.lat, item.lng));
	      },
	      _getItemConfig: function (item) {
	        var obj = {};

	        for (var i in item) {
	          obj[i] = item[i];
	        }

	        obj.position = new google$1.maps.LatLng(item.lat, item.lng);
	        obj.map = item.hidden ? null : this._map;
	        var marker = item.$marker;

	        if (!marker) {
	          marker = new google$1.maps.Marker(obj);

	          this._events(marker);
	        } else {
	          item.$marker.setMap(obj.map);
	        }

	        this.callEvent("onItemRender", [item]);
	        return marker;
	      },
	      _events: function (marker) {
	        var map = this;
	        marker.addListener("click", function () {
	          map.callEvent("onItemClick", [this.id, this]);
	        });

	        if (marker.getDraggable()) {
	          marker.addListener("dragend", function () {
	            map._onDrag(this, true);
	          });
	          marker.addListener("drag", function () {
	            map._onDrag(this);
	          });
	        }
	      },
	      _onDrag: function (marker, end) {
	        var item = this.getItem(marker.id);
	        var pos = marker.getPosition();
	        var ev = end ? "onAfterDrop" : "onDrag";
	        item.lat = pos.lat();
	        item.lng = pos.lng();
	        this.callEvent(ev, [item.id, item]);
	      }
	    },
	    heatmap: {
	      heatmapConfig_setter: function (value) {
	        value = value || {};
	        return value;
	      },
	      drawData: function () {
	        if (this._heatmap) {
	          this._heatmap.setMap(null);

	          this._heatmap = null;
	        }

	        var hdata = [];
	        this.data.each(function (item) {
	          hdata.push(this._getConfig(item));
	        }, this);

	        if (hdata.length) {
	          var data = exports.extend(this.config.heatmapConfig, {
	            data: hdata,
	            map: this._map
	          }, true);
	          this._heatmap = new google$1.maps.visualization.HeatmapLayer(data);
	          this.callEvent("onHeatMapRender", [this._heatmap]);
	        }
	      },
	      getHeatmap: function () {
	        return this._heatmap;
	      },
	      _getConfig: function (item) {
	        var obj = {};

	        for (var i in item) {
	          obj[i] = item[i];
	        }

	        obj.location = new google$1.maps.LatLng(item.lat, item.lng);
	        return obj;
	      }
	    }
	  }
	};
	var view$X = exports.protoUI(api$X, DataLoader, EventSystem, base.view);

	exports.protoUI({
	  name: "organogram",
	  defaults: {
	    template: "GPL version doesn't support organogram <br> You need Webix PRO"
	  }
	}, template$1.view);

	var Pie$1 = {
	  $render_pie: function (ctx, data, x, y, sIndex, map) {
	    this._renderPie(ctx, data, x, y, 1, map, sIndex);
	  },

	  /**
	   *   renders a pie chart
	   *   @param: ctx - canvas object
	   *   @param: data - object those need to be displayed
	   *   @param: x - the width of the container
	   *   @param: y - the height of the container
	   *   @param: ky - value from 0 to 1 that defines an angle of inclination (0<ky<1 - 3D chart)
	   */
	  _renderPie: function (ctx, data, point0, point1, ky, map, sIndex) {
	    if (!data.length) return;

	    var coord = this._getPieParameters(point0, point1);
	    /*pie radius*/


	    var radius = this._settings.radius ? this._settings.radius : coord.radius;
	    if (radius < 0) return;
	    /*real values*/

	    var values = this._getValues(data);

	    var totalValue = this._getTotalValue(values);
	    /*weighed values (the ratio of object value to total value)*/


	    var ratios = this._getRatios(values, totalValue);
	    /*pie center*/


	    var x0 = this._settings.x ? this._settings.x : coord.x;
	    var y0 = this._settings.y ? this._settings.y : coord.y;
	    /*adds shadow to the 2D pie*/

	    if (ky == 1 && this._settings.shadow) this._addShadow(ctx, x0, y0, radius);
	    /*changes vertical position of the center according to 3Dpie cant*/

	    y0 = y0 / ky;
	    /*the angle defines the 1st edge of the sector*/

	    var alpha0 = -Math.PI / 2;
	    var angles = [];
	    /*changes Canvas vertical scale*/

	    ctx.scale(1, ky);
	    /*adds radial gradient to a pie*/

	    if (this._settings.gradient) {
	      var x1 = ky != 1 ? x0 + radius / 3 : x0;
	      var y1 = ky != 1 ? y0 + radius / 3 : y0;

	      this._showRadialGradient(ctx, x0, y0, radius, x1, y1);
	    }

	    for (var i = 0; i < data.length; i++) {
	      if (!values[i]) continue;
	      /*drawing sector*/
	      //ctx.lineWidth = 2;

	      ctx.strokeStyle = this._settings.lineColor.call(this, data[i]);
	      ctx.beginPath();
	      ctx.moveTo(x0, y0);
	      angles.push(alpha0);
	      /*the angle defines the 2nd edge of the sector*/

	      var alpha1 = -Math.PI / 2 + ratios[i] - 0.0001;
	      ctx.arc(x0, y0, radius, alpha0, alpha1, false);
	      ctx.lineTo(x0, y0);

	      var color = this._settings.color.call(this, data[i]);

	      ctx.fillStyle = color;
	      ctx.fill();
	      /*text that needs being displayed inside the sector*/

	      if (this._settings.pieInnerText) this._drawSectorLabel(x0, y0, 5 * radius / 6, alpha0, alpha1, ky, this._settings.pieInnerText(data[i], totalValue), true);
	      /*label outside the sector*/

	      if (this._settings.label) this._drawSectorLabel(x0, y0, radius + this._settings.labelOffset, alpha0, alpha1, ky, this._settings.label(data[i]));
	      /*drawing lower part for 3D pie*/

	      if (ky != 1) {
	        this._createLowerSector(ctx, x0, y0, alpha0, alpha1, radius, true);

	        ctx.fillStyle = "#000000";
	        ctx.globalAlpha = 0.2;

	        this._createLowerSector(ctx, x0, y0, alpha0, alpha1, radius, false);

	        ctx.globalAlpha = 1;
	        ctx.fillStyle = color;
	      }
	      /*creats map area (needed for events)*/


	      map.addSector(data[i].id, alpha0, alpha1, x0 - point0.x, y0 - point0.y / ky, radius, ky, sIndex);
	      alpha0 = alpha1;
	    }
	    /*renders radius lines and labels*/


	    ctx.globalAlpha = 0.8;
	    var p;

	    for (i = 0; i < angles.length; i++) {
	      p = this._getPositionByAngle(angles[i], x0, y0, radius);

	      this._drawLine(ctx, x0, y0, p.x, p.y, this._settings.lineColor.call(this, data[i]), 2);
	    }

	    ctx.globalAlpha = 1;

	    if (ky == 1 && this._settings.border) {
	      ctx.lineWidth = this._settings.borderWidth || 2;
	      ctx.strokeStyle = this._settings.borderColor ? this._settings.borderColor.call(this) : "#ffffff";
	      ctx.beginPath();
	      ctx.arc(x0, y0, radius + 1, 0, 2 * Math.PI, false);
	      ctx.stroke();
	    }

	    ctx.scale(1, 1 / ky);
	  },

	  /**
	   *   returns list of values
	   *   @param: data array
	   */
	  _getValues: function (data) {
	    var v = [];

	    for (var i = 0; i < data.length; i++) {
	      v.push(Math.abs(parseFloat(this._settings.value(data[i]) || 0)));
	    }

	    return v;
	  },

	  /**
	   *   returns total value
	   *   @param: the array of values
	   */
	  _getTotalValue: function (values) {
	    var t = 0;

	    for (var i = 0; i < values.length; i++) {
	      t += values[i];
	    }

	    return t;
	  },

	  /**
	   *   gets angles for all values
	   *   @param: the array of values
	   *   @param: total value (optional)
	   */
	  _getRatios: function (values, totalValue) {
	    var value;
	    var ratios = [];
	    var prevSum = 0;
	    totalValue = totalValue || this._getTotalValue(values);

	    for (var i = 0; i < values.length; i++) {
	      value = values[i];
	      ratios[i] = Math.PI * 2 * (totalValue ? (value + prevSum) / totalValue : 1 / values.length);
	      prevSum += value;
	    }

	    return ratios;
	  },

	  /**
	   *   returns calculated pie parameters: center position and radius
	   *   @param: x - the width of a container
	   *   @param: y - the height of a container
	   */
	  _getPieParameters: function (point0, point1) {
	    /*var offsetX = 0;
	     var offsetY = 0;
	     if(this._settings.legend &&this._settings.legend.layout!="x")
	     offsetX = this._settings.legend.width*(this._settings.legend.align=="right"?-1:1);
	     var x0 = (x + offsetX)/2;
	     if(this._settings.legend &&this._settings.legend.layout=="x")
	     offsetY = this._settings.legend.height*(this._settings.legend.valign=="bottom"?-1:1);
	     var y0 = (y+offsetY)/2;*/
	    var width = point1.x - point0.x;
	    var height = point1.y - point0.y;
	    var x0 = point0.x + width / 2;
	    var y0 = point0.y + height / 2;
	    var radius = Math.min(width / 2, height / 2);
	    return {
	      "x": x0,
	      "y": y0,
	      "radius": radius
	    };
	  },

	  /**
	   *   creates lower part of sector in 3Dpie
	   *   @param: ctx - canvas object
	   *   @param: x0 - the horizontal position of the pie center
	   *   @param: y0 - the vertical position of the pie center
	   *   @param: a0 - the angle that defines the first edge of a sector
	   *   @param: a1 - the angle that defines the second edge of a sector
	   *   @param: R - pie radius
	   *   @param: line (boolean) - if the sector needs a border
	   */
	  _createLowerSector: function (ctx, x0, y0, a1, a2, R, line) {
	    ctx.lineWidth = 1;
	    /*checks if the lower sector needs being displayed*/

	    if (!(a1 <= 0 && a2 >= 0 || a1 >= 0 && a2 <= Math.PI || Math.abs(a1 - Math.PI) > 0.003 && a1 <= Math.PI && a2 >= Math.PI)) return;

	    if (a1 <= 0 && a2 >= 0) {
	      a1 = 0;
	      line = false;

	      this._drawSectorLine(ctx, x0, y0, R, a1, a2);
	    }

	    if (a1 <= Math.PI && a2 >= Math.PI) {
	      a2 = Math.PI;
	      line = false;

	      this._drawSectorLine(ctx, x0, y0, R, a1, a2);
	    }
	    /*the height of 3D pie*/


	    var offset = (this._settings.pieHeight || Math.floor(R / 4)) / this._settings.cant;

	    ctx.beginPath();
	    ctx.arc(x0, y0, R, a1, a2, false);
	    ctx.lineTo(x0 + R * Math.cos(a2), y0 + R * Math.sin(a2) + offset);
	    ctx.arc(x0, y0 + offset, R, a2, a1, true);
	    ctx.lineTo(x0 + R * Math.cos(a1), y0 + R * Math.sin(a1));
	    ctx.fill();
	    if (line) ctx.stroke();
	  },

	  /**
	   *   draws a serctor arc
	   */
	  _drawSectorLine: function (ctx, x0, y0, R, a1, a2) {
	    ctx.beginPath();
	    ctx.arc(x0, y0, R, a1, a2, false);
	    ctx.stroke();
	  },

	  /**
	   *   adds a shadow to pie
	   *   @param: ctx - canvas object
	   *   @param: x - the horizontal position of the pie center
	   *   @param: y - the vertical position of the pie center
	   *   @param: R - pie radius
	   */
	  _addShadow: function (ctx, x, y, R) {
	    ctx.globalAlpha = 0.5;
	    var shadows = ["#c4c4c4", "#c6c6c6", "#cacaca", "#dcdcdc", "#dddddd", "#e0e0e0", "#eeeeee", "#f5f5f5", "#f8f8f8"];

	    for (var i = shadows.length - 1; i > -1; i--) {
	      ctx.beginPath();
	      ctx.fillStyle = shadows[i];
	      ctx.arc(x + 1, y + 1, R + i, 0, Math.PI * 2, true);
	      ctx.fill();
	    }

	    ctx.globalAlpha = 1;
	  },

	  /**
	   *   returns a gray gradient
	   *   @param: gradient - gradient object
	   */
	  _getGrayGradient: function (gradient) {
	    gradient.addColorStop(0.0, "#ffffff");
	    gradient.addColorStop(0.7, "#7a7a7a");
	    gradient.addColorStop(1.0, "#000000");
	    return gradient;
	  },

	  /**
	   *   adds gray radial gradient
	   *   @param: ctx - canvas object
	   *   @param: x - the horizontal position of the pie center
	   *   @param: y - the vertical position of the pie center
	   *   @param: radius - pie radius
	   *   @param: x0 - the horizontal position of a gradient center
	   *   @param: y0 - the vertical position of a gradient center
	   */
	  _showRadialGradient: function (ctx, x, y, radius, x0, y0) {
	    //ctx.globalAlpha = 0.3;
	    ctx.beginPath();
	    var gradient;

	    if (typeof this._settings.gradient != "function") {
	      gradient = ctx.createRadialGradient(x0, y0, radius / 4, x, y, radius);
	      gradient = this._getGrayGradient(gradient);
	    } else gradient = this._settings.gradient(gradient);

	    ctx.fillStyle = gradient;
	    ctx.arc(x, y, radius, 0, Math.PI * 2, true);
	    ctx.fill(); //ctx.globalAlpha = 1;

	    ctx.globalAlpha = 0.7;
	  },

	  /**
	   *   returns the calculates pie parameters: center position and radius
	   *   @param: ctx - canvas object
	   *   @param: x0 - the horizontal position of the pie center
	   *   @param: y0 - the vertical position of the pie center
	   *   @param: R - pie radius
	   *   @param: alpha1 - the angle that defines the 1st edge of a sector
	   *   @param: alpha2 - the angle that defines the 2nd edge of a sector
	   *   @param: ky - the value that defines an angle of inclination
	   *   @param: text - label text
	   *   @param: in_width (boolean) - if label needs being displayed inside a pie
	   */
	  _drawSectorLabel: function (x0, y0, R, alpha1, alpha2, ky, text, in_width) {
	    var t = this.canvases[0].renderText(0, 0, text, 0, 1);
	    if (!t) return; //get existing width of text

	    var labelWidth = t.scrollWidth;
	    t.style.width = labelWidth + "px"; //adjust text label to fit all text

	    if (labelWidth > x0) labelWidth = x0; //the text can't be greater than half of view
	    //calculate expected correction based on default font metrics

	    var width = alpha2 - alpha1 < 0.2 ? 4 : 8;
	    if (in_width) width = labelWidth / 1.8;
	    var alpha = alpha1 + (alpha2 - alpha1) / 2; //position and its correction

	    R = R - (width - 8) / 2;
	    var corr_x = -width;
	    var corr_y = -8;
	    var align = "right"; //for items in left upper and lower sector

	    if (alpha >= Math.PI / 2 && alpha < Math.PI || alpha <= 3 * Math.PI / 2 && alpha >= Math.PI) {
	      corr_x = -labelWidth - corr_x + 1;
	      /*correction for label width*/

	      align = "left";
	    }
	    /*
	       calculate position of text
	       basically get point at center of pie sector
	    */


	    var offset = 0;
	    if (!in_width && ky < 1 && alpha > 0 && alpha < Math.PI) offset = (this._settings.height || Math.floor(R / 4)) / ky;
	    var y = (y0 + Math.floor((R + offset) * Math.sin(alpha))) * ky + corr_y;
	    var x = x0 + Math.floor((R + width / 2) * Math.cos(alpha)) + corr_x;
	    /*
	       if pie sector starts in left of right part pie,
	       related text	must be placed to the left of to the right of pie as well
	    */

	    var left_end = alpha2 < Math.PI / 2 + 0.01;
	    var left_start = alpha1 < Math.PI / 2;

	    if (left_start && left_end) {
	      x = Math.max(x, x0 + 3); //right part of pie

	      /*if(alpha2-alpha1<0.2)
	      	x = x0;*/
	    } else if (!left_start && !left_end) x = Math.min(x, x0 - labelWidth); //left part of pie
	    else if (!in_width && (alpha >= Math.PI / 2 && alpha < Math.PI || alpha <= 3 * Math.PI / 2 && alpha >= Math.PI)) {
	        x += labelWidth / 3;
	      } //we need to set position of text manually, based on above calculations


	    t.style.top = y + "px";
	    t.style.left = x + "px";
	    t.style.width = labelWidth + "px";
	    t.style.textAlign = align;
	    t.style.whiteSpace = "nowrap";
	  },
	  $render_pie3D: function (ctx, data, x, y, sIndex, map) {
	    this._renderPie(ctx, data, x, y, this._settings.cant, map);
	  },
	  $render_donut: function (ctx, data, point0, point1, sIndex, map) {
	    if (!data.length) return;

	    this._renderPie(ctx, data, point0, point1, 1, map, sIndex);

	    var config = this._settings;

	    var coord = this._getPieParameters(point0, point1);

	    var pieRadius = config.radius ? config.radius : coord.radius;
	    var innerRadius = config.innerRadius && config.innerRadius < pieRadius ? config.innerRadius : pieRadius / 3;
	    var x0 = config.x ? config.x : coord.x;
	    var y0 = config.y ? config.y : coord.y;
	    ctx.fillStyle = "#ffffff";
	    ctx.beginPath();
	    ctx.arc(x0, y0, innerRadius, 0, Math.PI * 2, true);
	    ctx.fill();
	  }
	};

	var BarChart = {
	  /**
	  *   renders a bar chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: x - the width of the container
	  *   @param: y - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_bar: function (ctx, data, point0, point1, sIndex, map) {
	    var barWidth,
	        cellWidth,
	        i,
	        limits,
	        maxValue,
	        minValue,
	        relValue,
	        valueFactor,
	        relativeValues,
	        startValue,
	        unit,
	        xax,
	        yax,
	        totalHeight = point1.y - point0.y;
	    yax = !!this._settings.yAxis;
	    xax = !!this._settings.xAxis;
	    limits = this._getLimits();
	    maxValue = limits.max;
	    minValue = limits.min;
	    /*an available width for one bar*/

	    cellWidth = (point1.x - point0.x) / data.length;
	    /*draws x and y scales*/

	    if (!sIndex && !(this._settings.origin != "auto" && !yax)) {
	      this._drawScales(data, point0, point1, minValue, maxValue, cellWidth);
	    }
	    /*necessary for automatic scale*/


	    if (yax) {
	      maxValue = parseFloat(this._settings.yAxis.end);
	      minValue = parseFloat(this._settings.yAxis.start);
	    }
	    /*unit calculation (bar_height = value*unit)*/


	    relativeValues = this._getRelativeValue(minValue, maxValue);
	    relValue = relativeValues[0];
	    valueFactor = relativeValues[1];
	    unit = relValue ? totalHeight / relValue : relValue;

	    if (!yax && !(this._settings.origin != "auto" && xax)) {
	      /*defines start value for better representation of small values*/
	      startValue = 10;
	      unit = relValue ? (totalHeight - startValue) / relValue : startValue;
	    }
	    /*if yAxis isn't set, but with custom origin */


	    if (!sIndex && this._settings.origin != "auto" && !yax && this._settings.origin > minValue) {
	      this._drawXAxis(ctx, data, point0, point1, cellWidth, point1.y - unit * (this._settings.origin - minValue));
	    }
	    /*a real bar width */


	    barWidth = parseInt(this._settings.barWidth, 10);
	    var seriesNumber = 0;
	    var seriesIndex = 0;

	    for (i = 0; i < this._series.length; i++) {
	      if (i == sIndex) {
	        seriesIndex = seriesNumber;
	      }

	      if (this._series[i].type == "bar") seriesNumber++;
	    }

	    if (this._series && barWidth * seriesNumber + 4 > cellWidth) barWidth = parseInt(cellWidth / seriesNumber - 4, 10);
	    /*the half of distance between bars*/

	    var barOffset = (cellWidth - barWidth * seriesNumber) / 2;
	    /*the radius of rounding in the top part of each bar*/

	    var radius = typeof this._settings.radius != "undefined" ? parseInt(this._settings.radius, 10) : Math.round(barWidth / 5);
	    var inner_gradient = false;
	    var gradient = this._settings.gradient;

	    if (gradient && typeof gradient != "function") {
	      inner_gradient = gradient;
	      gradient = false;
	    } else if (gradient) {
	      gradient = ctx.createLinearGradient(0, point1.y, 0, point0.y);

	      this._settings.gradient(gradient);
	    }
	    /*draws a black line if the horizontal scale isn't defined*/


	    if (!xax) {
	      this._drawLine(ctx, point0.x, point1.y + 0.5, point1.x, point1.y + 0.5, "#edeff0", 1); //hardcoded color!

	    }

	    for (i = 0; i < data.length; i++) {
	      var value = parseFloat(this._settings.value(data[i]) || 0);
	      if (this._logScaleCalc) value = this._log10(value);
	      if (value > maxValue) value = maxValue;
	      value -= minValue;
	      value *= valueFactor;
	      /*start point (bottom left)*/

	      var x0 = point0.x + barOffset + i * cellWidth + (barWidth + 1) * seriesIndex;
	      var y0 = point1.y;

	      var color$$1 = gradient || this._settings.color.call(this, data[i]);

	      var border = this._settings.border ? 1 : 0;

	      var label = this._settings.label(data[i]);
	      /* don't draw borders and labels for not painted values (on y-Axis or lower) */


	      if (value == this._settings.origin || this._settings.origin == "auto" && this._settings.value(data[i]) == minValue) {
	        border = 0;
	        label = "";
	      } else if (value < 0 || this._settings.yAxis && value === 0 && !(this._settings.origin != "auto" && this._settings.origin > minValue)) {
	        value = border = 0;
	        label = "";
	      }
	      /*takes start value into consideration */
	      else if (!yax && !(this._settings.origin != "auto" && xax)) value += startValue / unit;
	      /*drawing bar body*/


	      ctx.globalAlpha = this._settings.alpha.call(this, data[i]);

	      var points = this._drawBar(ctx, point0, x0, y0, barWidth, minValue, radius, unit, value, color$$1, gradient, inner_gradient, border);

	      if (inner_gradient) {
	        this._drawBarGradient(ctx, x0, y0, barWidth, minValue, radius, unit, value, color$$1, inner_gradient, border);
	      }
	      /*drawing the gradient border of a bar*/


	      if (border) this._drawBarBorder(ctx, x0, y0, barWidth, minValue, radius, unit, value, color$$1);
	      ctx.globalAlpha = 1;
	      /*sets a bar label*/

	      if (points[0] != x0) this.canvases[sIndex].renderTextAt(false, true, x0 + Math.floor(barWidth / 2), points[1], label);else this.canvases[sIndex].renderTextAt(true, true, x0 + Math.floor(barWidth / 2), points[3], label);
	      /*defines a map area for a bar*/

	      map.addRect(data[i].id, [x0 - point0.x, points[3] - point0.y, points[2] - point0.x, points[1] - point0.y], sIndex); //this._addMapRect(map,data[i].id,[{x:x0,y:points[3]},{x:points[2],y:points[1]}],point0,sIndex);
	    }
	  },
	  _correctBarParams: function (ctx, x, y, value, unit, barWidth, minValue) {
	    var xax = this._settings.xAxis;
	    var axisStart = y;

	    if (!!xax && this._settings.origin != "auto" && this._settings.origin > minValue) {
	      y -= (this._settings.origin - minValue) * unit;
	      axisStart = y;
	      value = value - (this._settings.origin - minValue);

	      if (value < 0) {
	        value *= -1;
	        ctx.translate(x + barWidth, y);
	        ctx.rotate(Math.PI);
	        x = 0;
	        y = 0;
	      }

	      y -= 0.5;
	    }

	    return {
	      value: value,
	      x0: x,
	      y0: y,
	      start: axisStart
	    };
	  },
	  _drawBar: function (ctx, point0, x0, y0, barWidth, minValue, radius, unit, value, color$$1, gradient, inner_gradient, border) {
	    ctx.save();
	    ctx.fillStyle = color$$1;

	    var p = this._correctBarParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    var points = this._setBarPoints(ctx, p.x0, p.y0, barWidth, radius, unit, p.value, border);

	    if (gradient && !inner_gradient) ctx.lineTo(p.x0 + border, point0.y); //fix gradient sphreading

	    ctx.fill();
	    ctx.restore();
	    var x1 = p.x0;
	    var x2 = p.x0 != x0 ? x0 + points[0] : points[0];
	    var y1 = p.x0 != x0 ? p.start - points[1] - p.y0 : p.y0;
	    var y2 = p.x0 != x0 ? p.start - p.y0 : points[1];
	    return [x1, y1, x2, y2];
	  },
	  _setBorderStyles: function (ctx, rawColor) {
	    var hsv, rgb;
	    rgb = color.toRgb(rawColor);
	    hsv = color.rgbToHsv(rgb[0], rgb[1], rgb[2]);
	    hsv[2] /= 1.4;
	    var rgbColor = "rgb(" + color.hsvToRgb(hsv[0], hsv[1], hsv[2]) + ")";
	    ctx.strokeStyle = rgbColor;
	    if (ctx.globalAlpha == 1) ctx.globalAlpha = 0.9;
	  },
	  _drawBarBorder: function (ctx, x0, y0, barWidth, minValue, radius, unit, value, color$$1) {
	    var p;
	    ctx.save();
	    p = this._correctBarParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    this._setBorderStyles(ctx, color$$1);

	    this._setBarPoints(ctx, p.x0, p.y0, barWidth, radius, unit, p.value, ctx.lineWidth / 2, 1);

	    ctx.stroke();
	    /*ctx.fillStyle = color;
	     this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,0);
	     ctx.lineTo(p.x0,0);
	     ctx.fill()
	    		 ctx.fillStyle = "#000000";
	     ctx.globalAlpha = 0.37;
	    	 this._setBarPoints(ctx,p.x0,p.y0,barWidth,radius,unit,p.value,0);
	     ctx.fill()
	     */

	    ctx.restore();
	  },
	  _drawBarGradient: function (ctx, x0, y0, barWidth, minValue, radius, unit, value, color$$1, inner_gradient, border) {
	    ctx.save();

	    var p = this._correctBarParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    var gradParam = this._setBarGradient(ctx, p.x0, p.y0, p.x0 + barWidth, p.y0 - unit * p.value + 2, inner_gradient, color$$1, "y");

	    ctx.fillStyle = gradParam.gradient;

	    this._setBarPoints(ctx, p.x0 + gradParam.offset, p.y0, barWidth - gradParam.offset * 2, radius, unit, p.value, gradParam.offset + border);

	    ctx.fill();
	    ctx.restore();
	  },

	  /**
	   *   sets points for bar and returns the position of the bottom right point
	   *   @param: ctx - canvas object
	   *   @param: x0 - the x position of start point
	   *   @param: y0 - the y position of start point
	   *   @param: barWidth - bar width
	   *   @param: radius - the rounding radius of the top
	   *   @param: unit - the value defines the correspondence between item value and bar height
	   *   @param: value - item value
	   *   @param: offset - the offset from expected bar edge (necessary for drawing border)
	   */
	  _setBarPoints: function (ctx, x0, y0, barWidth, radius, unit, value, offset, skipBottom) {
	    /*correction for displaing small values (when rounding radius is bigger than bar height)*/
	    ctx.beginPath(); //y0 = 0.5;

	    var angle_corr = 0;

	    if (radius > unit * value) {
	      var cosA = (radius - unit * value) / radius;
	      if (cosA <= 1 && cosA >= -1) angle_corr = -Math.acos(cosA) + Math.PI / 2;
	    }
	    /*start*/


	    ctx.moveTo(x0 + offset, y0);
	    /*start of left rounding*/

	    var y1 = y0 - Math.floor(unit * value) + radius + (radius ? 0 : offset);
	    if (radius < unit * value) ctx.lineTo(x0 + offset, y1);
	    /*left rounding*/

	    var x2 = x0 + radius;
	    if (radius && radius > 0) ctx.arc(x2, y1, Math.max(radius - offset, 0), -Math.PI + angle_corr, -Math.PI / 2, false);
	    /*start of right rounding*/

	    var x3 = x0 + barWidth - radius - offset;
	    var y3 = y1 - radius + (radius ? offset : 0);
	    ctx.lineTo(x3, y3);
	    /*right rounding*/

	    if (radius && radius > 0) ctx.arc(x3 + offset, y1, Math.max(radius - offset, 0), -Math.PI / 2, 0 - angle_corr, false);
	    /*bottom right point*/

	    var x5 = x0 + barWidth - offset;
	    ctx.lineTo(x5, y0);
	    /*line to the start point*/

	    if (!skipBottom) {
	      ctx.lineTo(x0 + offset, y0);
	    } //	ctx.lineTo(x0,0); //IE fix!


	    return [x5, y3];
	  }
	};

	var LineChart = {
	  /**
	  *   renders a graphic
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: width - the width of the container
	  *   @param: height - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_line: function (ctx, data, point0, point1, sIndex, map) {
	    var config, i, items, params, x0, x1, x2, y1, y2, y0, res1, res2;
	    params = this._calculateLineParams(ctx, data, point0, point1, sIndex);
	    config = this._settings;

	    if (data.length) {
	      x0 = config.offset ? point0.x + params.cellWidth * 0.5 : point0.x; //finds items with data (excludes scale units)

	      items = [];

	      for (i = 0; i < data.length; i++) {
	        res2 = this._getPointY(data[i], point0, point1, params);

	        if (res2 || res2 == "0") {
	          x2 = !i ? x0 : params.cellWidth * i - 0.5 + x0;
	          y2 = _typeof(res2) == "object" ? res2.y0 : res2;

	          if (i && this._settings.fixOverflow) {
	            res1 = this._getPointY(data[i - 1], point0, point1, params);

	            if (res1.out && res1.out == res2.out) {
	              continue;
	            }

	            x1 = params.cellWidth * (i - 1) - 0.5 + x0;
	            y1 = _typeof(res1) == "object" ? res1.y0 : res1;

	            if (res1.out) {
	              y0 = res1.out == "min" ? point1.y : point0.y;
	              items.push({
	                x: this._calcOverflowX(x1, x2, y1, y2, y0),
	                y: y0
	              });
	            }

	            if (res2.out) {
	              y0 = res2.out == "min" ? point1.y : point0.y;
	              items.push({
	                x: this._calcOverflowX(x1, x2, y1, y2, y0),
	                y: y0
	              });
	            }
	          }

	          if (!res2.out) items.push({
	            x: x2,
	            y: res2,
	            index: i
	          });
	        }
	      }

	      this._mapStart = point0;

	      for (i = 1; i <= items.length; i++) {
	        //line start position
	        x1 = items[i - 1].x;
	        y1 = items[i - 1].y;

	        if (i < items.length) {
	          //line end position
	          x2 = items[i].x;
	          y2 = items[i].y; //line

	          this._drawLine(ctx, x1, y1, x2, y2, config.line.color.call(this, data[i - 1]), config.line.width); //line shadow


	          if (config.line && config.line.shadow) {
	            ctx.globalAlpha = 0.3;

	            this._drawLine(ctx, x1 + 2, y1 + config.line.width + 8, x2 + 2, y2 + config.line.width + 8, "#eeeeee", config.line.width + 3);

	            ctx.globalAlpha = 1;
	          }
	        } //item


	        if (typeof items[i - 1].index != "undefined") {
	          this._drawItem(ctx, x1, y1, data[items[i - 1].index], config.label(data[items[i - 1].index]), sIndex, map, point0);
	        }
	      }
	    }
	  },
	  _calcOverflowX: function (x1, x2, y1, y2, y) {
	    return x1 + (y - y1) * (x2 - x1) / (y2 - y1);
	  },

	  /**
	  *   draws an item and its label
	  *   @param: ctx - canvas object
	  *   @param: x0 - the x position of a circle
	  *   @param: y0 - the y position of a circle
	  *   @param: obj - data object
	  *   @param: label - (boolean) defines wherether label needs being drawn
	  */
	  _drawItem: function (ctx, x0, y0, obj, label, sIndex, map) {
	    var config = this._settings.item;
	    var R = parseInt(config.radius.call(this, obj), 10) || 0;
	    var mapStart = this._mapStart;
	    var item = config.type.call(this, obj);

	    if (R) {
	      ctx.save();

	      if (config.shadow) {
	        ctx.lineWidth = 1;
	        ctx.strokeStyle = "#bdbdbd";
	        ctx.fillStyle = "#bdbdbd";
	        var alphas = [0.1, 0.2, 0.3];

	        for (var i = alphas.length - 1; i >= 0; i--) {
	          ctx.globalAlpha = alphas[i];
	          ctx.strokeStyle = "#d0d0d0";
	          ctx.beginPath();

	          this._strokeChartItem(ctx, x0, y0 + 2 * R / 3, R + i + 1, item);

	          ctx.stroke();
	        }

	        ctx.beginPath();
	        ctx.globalAlpha = 0.3;
	        ctx.fillStyle = "#bdbdbd";

	        this._strokeChartItem(ctx, x0, y0 + 2 * R / 3, R + 1, item);

	        ctx.fill();
	      }

	      ctx.restore();
	      ctx.lineWidth = config.borderWidth;
	      ctx.fillStyle = config.color.call(this, obj);
	      ctx.strokeStyle = config.borderColor.call(this, obj);
	      ctx.globalAlpha = config.alpha.call(this, obj);
	      ctx.beginPath();

	      this._strokeChartItem(ctx, x0, y0, R + 1, item);

	      ctx.fill();
	      ctx.stroke();
	      ctx.globalAlpha = 1;
	    }
	    /*item label*/


	    if (label) {
	      this.canvases[sIndex].renderTextAt(false, true, x0, y0 - R - this._settings.labelOffset, this._settings.label.call(this, obj));
	    }

	    if (map) {
	      var areaPos = this._settings.eventRadius || R + 1; //this._addMapRect(map,obj.id,[{x:x0-areaPos,y:y0-areaPos},{x0+areaPos,y:y0+areaPos}],point0,sIndex);

	      map.addRect(obj.id, [x0 - areaPos - mapStart.x, y0 - areaPos - mapStart.y, x0 + areaPos - mapStart.x, y0 + areaPos - mapStart.y], sIndex);
	    }
	  },
	  _strokeChartItem: function (ctx, x0, y0, R, type) {
	    var p = [];

	    if (type && (type == "square" || type == "s")) {
	      R *= Math.sqrt(2) / 2;
	      p = [[x0 - R - ctx.lineWidth / 2, y0 - R], [x0 + R, y0 - R], [x0 + R, y0 + R], [x0 - R, y0 + R], [x0 - R, y0 - R]];
	    } else if (type && (type == "diamond" || type == "d")) {
	      var corr = ctx.lineWidth > 1 ? ctx.lineWidth * Math.sqrt(2) / 4 : 0;
	      p = [[x0, y0 - R], [x0 + R, y0], [x0, y0 + R], [x0 - R, y0], [x0 + corr, y0 - R - corr]];
	    } else if (type && (type == "triangle" || type == "t")) {
	      p = [[x0, y0 - R], [x0 + Math.sqrt(3) * R / 2, y0 + R / 2], [x0 - Math.sqrt(3) * R / 2, y0 + R / 2], [x0, y0 - R]];
	    } else p = [[x0, y0, R, 0, Math.PI * 2, true]];

	    this._path(ctx, p);
	  },

	  /**
	  *   gets the vertical position of the item
	  *   @param: data - data object
	  *   @param: y0 - the y position of chart start
	  *   @param: y1 - the y position of chart end
	  *   @param: params - the object with elements: minValue, maxValue, unit, valueFactor (the value multiple of 10)
	  */
	  _getPointY: function (data, point0, point1, params) {
	    var minValue = params.minValue;
	    var maxValue = params.maxValue;
	    var unit = params.unit;
	    var valueFactor = params.valueFactor;
	    /*the real value of an object*/

	    var value = this._settings.value(data);

	    if (this._logScaleCalc) {
	      value = this._log10(value);
	    }
	    /*a relative value*/


	    var v = (parseFloat(value || 0) - minValue) * valueFactor;
	    if (!this._settings.yAxis) v += params.startValue / unit;
	    /*a vertical coordinate*/

	    var y = point1.y - unit * v;
	    /*the limit of the max and min values*/

	    if (this._settings.fixOverflow && (this._settings.type == "line" || this._settings.type == "area")) {
	      if (value > maxValue) y = {
	        y: point0.y,
	        y0: y,
	        out: "max"
	      };else if (v < 0 || value < minValue) y = {
	        y: point1.y,
	        y0: y,
	        out: "min"
	      };
	    } else {
	      if (value > maxValue) y = point0.y;
	      if (v < 0 || value < minValue) y = point1.y;
	    }

	    return y;
	  },
	  _calculateLineParams: function (ctx, data, point0, point1, sIndex) {
	    var params = {};
	    /*maxValue - minValue*/

	    var relValue;
	    /*available height*/

	    params.totalHeight = point1.y - point0.y;
	    /*a space available for a single item*/
	    //params.cellWidth = Math.round((point1.x-point0.x)/((!this._settings.offset&&this._settings.yAxis)?(data.length-1):data.length));

	    if (this._settings.cellWidth) params.cellWidth = Math.min(point1.x - point0.x, this._settings.cellWidth);else params.cellWidth = (point1.x - point0.x) / (!this._settings.offset ? data.length - 1 : data.length);
	    /*scales*/

	    var yax = !!this._settings.yAxis;
	    var limits = this._settings.type.indexOf("stacked") != -1 ? this._getStackedLimits(data) : this._getLimits();
	    params.maxValue = limits.max;
	    params.minValue = limits.min;
	    /*draws x and y scales*/

	    if (!sIndex) this._drawScales(data, point0, point1, params.minValue, params.maxValue, params.cellWidth);
	    /*necessary for automatic scale*/

	    if (yax) {
	      params.maxValue = parseFloat(this._settings.yAxis.end);
	      params.minValue = parseFloat(this._settings.yAxis.start);
	    }
	    /*unit calculation (y_position = value*unit)*/


	    var relativeValues = this._getRelativeValue(params.minValue, params.maxValue);

	    relValue = relativeValues[0];
	    params.valueFactor = relativeValues[1];
	    params.unit = relValue ? params.totalHeight / relValue : 10;
	    params.startValue = 0;

	    if (!yax) {
	      /*defines start value for better representation of small values*/
	      params.startValue = 10;
	      if (params.unit != params.totalHeight) params.unit = relValue ? (params.totalHeight - params.startValue) / relValue : 10;
	    }

	    return params;
	  }
	};

	var BarHChart = {
	  /**
	  *   renders a bar chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: x - the width of the container
	  *   @param: y - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_barH: function (ctx, data, point0, point1, sIndex, map) {
	    var barOffset, barWidth, cellWidth, color, gradient, i, limits, maxValue, minValue, innerGradient, valueFactor, relValue, radius, relativeValues, startValue, totalWidth, value, unit, x0, y0, xax;
	    /*an available width for one bar*/

	    cellWidth = (point1.y - point0.y) / data.length;
	    limits = this._getLimits("h");
	    maxValue = limits.max;
	    minValue = limits.min;
	    totalWidth = point1.x - point0.x;
	    xax = !!this._settings.xAxis;
	    /*draws x and y scales*/

	    if (!sIndex) this._drawHScales(ctx, data, point0, point1, minValue, maxValue, cellWidth);
	    /*necessary for automatic scale*/

	    if (xax) {
	      maxValue = parseFloat(this._settings.xAxis.end);
	      minValue = parseFloat(this._settings.xAxis.start);
	    }
	    /*unit calculation (bar_height = value*unit)*/


	    relativeValues = this._getRelativeValue(minValue, maxValue);
	    relValue = relativeValues[0];
	    valueFactor = relativeValues[1];
	    unit = relValue ? totalWidth / relValue : 10;

	    if (!xax) {
	      /*defines start value for better representation of small values*/
	      startValue = 10;
	      unit = relValue ? (totalWidth - startValue) / relValue : 10;
	    }
	    /*a real bar width */


	    barWidth = parseInt(this._settings.barWidth, 10);
	    if (barWidth * this._series.length + 4 > cellWidth) barWidth = cellWidth / this._series.length - 4;
	    /*the half of distance between bars*/

	    barOffset = Math.floor((cellWidth - barWidth * this._series.length) / 2);
	    /*the radius of rounding in the top part of each bar*/

	    radius = typeof this._settings.radius != "undefined" ? parseInt(this._settings.radius, 10) : Math.round(barWidth / 5);
	    innerGradient = false;
	    gradient = this._settings.gradient;

	    if (gradient && typeof gradient != "function") {
	      innerGradient = gradient;
	      gradient = false;
	    } else if (gradient) {
	      gradient = ctx.createLinearGradient(point0.x, point0.y, point1.x, point0.y);

	      this._settings.gradient(gradient);
	    }
	    /*draws a black line if the horizontal scale isn't defined*/


	    if (!xax) {
	      this._drawLine(ctx, point0.x - 0.5, point0.y, point0.x - 0.5, point1.y, "#edeff0", 1); //hardcoded color!

	    }

	    for (i = 0; i < data.length; i++) {
	      value = parseFloat(this._settings.value(data[i] || 0));
	      if (this._logScaleCalc) value = this._log10(value);
	      if (!value || isNaN(value)) continue;
	      if (value > maxValue) value = maxValue;
	      value -= minValue;
	      value *= valueFactor;
	      /*start point (bottom left)*/

	      x0 = point0.x;
	      y0 = point0.y + barOffset + i * cellWidth + (barWidth + 1) * sIndex;

	      if (value < 0 && this._settings.origin == "auto" || this._settings.xAxis && value === 0 && !(this._settings.origin != "auto" && this._settings.origin > minValue)) {
	        this.canvases[sIndex].renderTextAt("middle", "right", x0 + 10, y0 + barWidth / 2 + barOffset, this._settings.label(data[i]));
	        continue;
	      }

	      if (value < 0 && this._settings.origin != "auto" && this._settings.origin > minValue) {
	        value = 0;
	      }
	      /*takes start value into consideration*/


	      if (!xax) value += startValue / unit;
	      color = gradient || this._settings.color.call(this, data[i]);
	      /*drawing the gradient border of a bar*/

	      if (this._settings.border) {
	        this._drawBarHBorder(ctx, x0, y0, barWidth, minValue, radius, unit, value, color);
	      }
	      /*drawing bar body*/


	      ctx.globalAlpha = this._settings.alpha.call(this, data[i]);

	      var points = this._drawBarH(ctx, point1, x0, y0, barWidth, minValue, radius, unit, value, color, gradient, innerGradient);

	      if (innerGradient) {
	        this._drawBarHGradient(ctx, x0, y0, barWidth, minValue, radius, unit, value, color, innerGradient);
	      }

	      ctx.globalAlpha = 1;
	      /*sets a bar label and map area*/

	      if (points[3] == y0) {
	        this.canvases[sIndex].renderTextAt("middle", "left", points[0] - 5, points[3] + Math.floor(barWidth / 2), this._settings.label(data[i]));
	        map.addRect(data[i].id, [points[0] - point0.x, points[3] - point0.y, points[2] - point0.x, points[3] + barWidth - point0.y], sIndex);
	      } else {
	        this.canvases[sIndex].renderTextAt("middle", false, points[2] + 5, points[1] + Math.floor(barWidth / 2), this._settings.label(data[i]));
	        map.addRect(data[i].id, [points[0] - point0.x, y0 - point0.y, points[2] - point0.x, points[3] - point0.y], sIndex);
	      }
	    }
	  },

	  /**
	   *   sets points for bar and returns the position of the bottom right point
	   *   @param: ctx - canvas object
	   *   @param: x0 - the x position of start point
	   *   @param: y0 - the y position of start point
	   *   @param: barWidth - bar width
	   *   @param: radius - the rounding radius of the top
	   *   @param: unit - the value defines the correspondence between item value and bar height
	   *   @param: value - item value
	   *   @param: offset - the offset from expected bar edge (necessary for drawing border)
	   */
	  _setBarHPoints: function (ctx, x0, y0, barWidth, radius, unit, value, offset, skipLeft) {
	    /*correction for displaing small values (when rounding radius is bigger than bar height)*/
	    var angle_corr = 0;

	    if (radius > unit * value) {
	      var sinA = (radius - unit * value) / radius;
	      angle_corr = -Math.asin(sinA) + Math.PI / 2;
	    }
	    /*start*/


	    ctx.moveTo(x0, y0 + offset);
	    /*start of left rounding*/

	    var x1 = x0 + unit * value - radius - (radius ? 0 : offset);
	    x1 = Math.max(x0, x1);
	    if (radius < unit * value) ctx.lineTo(x1, y0 + offset);
	    /*left rounding*/

	    var y2 = y0 + radius;
	    if (radius && radius > 0) ctx.arc(x1, y2, radius - offset, -Math.PI / 2 + angle_corr, 0, false);
	    /*start of right rounding*/

	    var y3 = y0 + barWidth - radius - (radius ? 0 : offset);
	    var x3 = x1 + radius - (radius ? offset : 0);
	    ctx.lineTo(x3, y3);
	    /*right rounding*/

	    if (radius && radius > 0) ctx.arc(x1, y3, radius - offset, 0, Math.PI / 2 - angle_corr, false);
	    /*bottom right point*/

	    var y5 = y0 + barWidth - offset;
	    ctx.lineTo(x0, y5);
	    /*line to the start point*/

	    if (!skipLeft) {
	      ctx.lineTo(x0, y0 + offset);
	    } //	ctx.lineTo(x0,0); //IE fix!


	    return [x3, y5];
	  },
	  _drawHScales: function (ctx, data, point0, point1, start, end, cellWidth) {
	    var x = 0;

	    if (this._settings.xAxis) {
	      if (!this.canvases["x"]) this.canvases["x"] = this._createCanvas("axis_x");
	      x = this._drawHXAxis(this.canvases["x"].getCanvas(), data, point0, point1, start, end);
	    }

	    if (this._settings.yAxis) {
	      if (!this.canvases["y"]) this.canvases["y"] = this._createCanvas("axis_y");

	      this._drawHYAxis(this.canvases["y"].getCanvas(), data, point0, point1, cellWidth, x);
	    }
	  },
	  _drawHYAxis: function (ctx, data, point0, point1, cellWidth, yAxisX) {
	    if (!this._settings.yAxis) return;
	    var unitPos;
	    var x0 = parseInt(yAxisX ? yAxisX : point0.x, 10) - 0.5;
	    var y0 = point1.y + 0.5;
	    var y1 = point0.y;

	    this._drawLine(ctx, x0, y0, x0, y1, this._settings.yAxis.color, 1);

	    for (var i = 0; i < data.length; i++) {
	      /*scale labels*/
	      var right = this._settings.origin != "auto" && this._settings.type == "barH" && parseFloat(this._settings.value(data[i])) < this._settings.origin;

	      unitPos = y1 + cellWidth / 2 + i * cellWidth;
	      this.canvases["y"].renderTextAt("middle", right ? false : "left", right ? x0 + 5 : x0 - 5, unitPos, this._settings.yAxis.template(data[i]), "webix_axis_item_y", right ? 0 : x0 - 10);
	      if (this._settings.yAxis.lines.call(this, data[i])) this._drawLine(ctx, point0.x, unitPos, point1.x, unitPos, this._settings.yAxis.lineColor.call(this, data[i]), 1);
	    }

	    if (this._settings.yAxis.lines.call(this, {})) this._drawLine(ctx, point0.x + 0.5, y1 + 0.5, point1.x, y1 + 0.5, this._settings.yAxis.lineColor.call(this, {}), 1);

	    this._setYAxisTitle(point0, point1);
	  },
	  _drawHXAxis: function (ctx, data, point0, point1, start, end) {
	    var step;
	    var scaleParam = {};
	    var axis = this._settings.xAxis;
	    if (!axis) return;
	    var y0 = point1.y + 0.5;
	    var x0 = point0.x - 0.5;
	    var x1 = point1.x - 0.5;
	    var yAxisStart = point0.x;

	    this._drawLine(ctx, x0, y0, x1, y0, axis.color, 1);

	    if (axis.step) step = parseFloat(axis.step);

	    if (typeof this._configXAxis.step == "undefined" || typeof this._configXAxis.start == "undefined" || typeof this._configXAxis.end == "undefined") {
	      scaleParam = this._calculateScale(start, end);
	      start = scaleParam.start;
	      end = scaleParam.end;
	      step = scaleParam.step;
	      this._settings.xAxis.end = end;
	      this._settings.xAxis.start = start;
	      this._settings.xAxis.step = step;
	    }

	    if (step === 0) return;
	    var stepHeight = (x1 - x0) * step / (end - start);
	    var c = 0;

	    for (var i = start; i <= end; i += step) {
	      var value = this._logScaleCalc ? Math.pow(10, i) : i;
	      if (scaleParam.fixNum) value = parseFloat(value).toFixed(scaleParam.fixNum);
	      var xi = Math.floor(x0 + c * stepHeight) + 0.5;
	      /*canvas line fix*/

	      if (!(i == start && this._settings.origin == "auto") && axis.lines.call(this, i)) this._drawLine(ctx, xi, y0, xi, point0.y, this._settings.xAxis.lineColor.call(this, i), 1);
	      if (i == this._settings.origin) yAxisStart = xi + 1;
	      /*correction for JS float calculation*/

	      if (step < 1 && !this._logScaleCalc) {
	        var power = Math.min(Math.floor(this._log10(step)), start <= 0 ? 0 : Math.floor(this._log10(start)));
	        var corr = Math.pow(10, -power);
	        value = Math.round(value * corr) / corr;
	        i = value;
	      }

	      this.canvases["x"].renderTextAt(false, true, xi, y0 + 2, axis.template(value.toString()), "webix_axis_item_x");
	      c++;
	    }

	    this.canvases["x"].renderTextAt(true, false, x0, point1.y + this._settings.padding.bottom - 3, this._settings.xAxis.title, "webix_axis_title_x", point1.x - point0.x);
	    return yAxisStart;
	  },
	  _correctBarHParams: function (ctx, x, y, value, unit, barWidth, minValue) {
	    var yax = this._settings.yAxis;
	    var axisStart = x;

	    if (!!yax && this._settings.origin != "auto" && this._settings.origin > minValue) {
	      x += (this._settings.origin - minValue) * unit;
	      axisStart = x;
	      value = value - (this._settings.origin - minValue);

	      if (value < 0) {
	        value *= -1;
	        ctx.translate(x, y + barWidth);
	        ctx.rotate(Math.PI);
	        x = 0.5;
	        y = 0;
	      }

	      x += 0.5;
	    }

	    return {
	      value: value,
	      x0: x,
	      y0: y,
	      start: axisStart
	    };
	  },
	  _drawBarH: function (ctx, point1, x0, y0, barWidth, minValue, radius, unit, value, color, gradient, inner_gradient) {
	    ctx.save();

	    var p = this._correctBarHParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    ctx.fillStyle = color;
	    ctx.beginPath();

	    var points = this._setBarHPoints(ctx, p.x0, p.y0, barWidth, radius, unit, p.value, this._settings.border ? 1 : 0);

	    if (gradient && !inner_gradient) ctx.lineTo(point1.x, p.y0 + (this._settings.border ? 1 : 0)); //fix gradient sphreading

	    ctx.fill();
	    ctx.restore();
	    var y1 = p.y0;
	    var y2 = p.y0 != y0 ? y0 : points[1];
	    var x1 = p.y0 != y0 ? p.start - points[0] : p.start;
	    var x2 = p.y0 != y0 ? p.start : points[0];
	    return [x1, y1, x2, y2];
	  },
	  _drawBarHBorder: function (ctx, x0, y0, barWidth, minValue, radius, unit, value, color) {
	    ctx.save();

	    var p = this._correctBarHParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    ctx.beginPath();

	    this._setBorderStyles(ctx, color);

	    ctx.globalAlpha = 0.9;

	    this._setBarHPoints(ctx, p.x0, p.y0, barWidth, radius, unit, p.value, ctx.lineWidth / 2, 1);

	    ctx.stroke();
	    ctx.restore();
	  },
	  _drawBarHGradient: function (ctx, x0, y0, barWidth, minValue, radius, unit, value, color, inner_gradient) {
	    ctx.save();

	    var p = this._correctBarHParams(ctx, x0, y0, value, unit, barWidth, minValue);

	    var gradParam = this._setBarGradient(ctx, p.x0, p.y0 + barWidth, p.x0 + unit * p.value, p.y0, inner_gradient, color, "x");

	    ctx.fillStyle = gradParam.gradient;
	    ctx.beginPath();

	    this._setBarHPoints(ctx, p.x0, p.y0 + gradParam.offset, barWidth - gradParam.offset * 2, radius, unit, p.value, gradParam.offset);

	    ctx.fill();
	    ctx.globalAlpha = 1;
	    ctx.restore();
	  }
	};

	var StackedBarChart = {
	  /**
	  *   renders a bar chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: x - the width of the container
	  *   @param: y - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_stackedBar: function (ctx, data, point0, point1, sIndex, map) {
	    var maxValue, minValue, xAxisY, x0, y0;
	    /*necessary if maxValue - minValue < 0*/

	    var valueFactor;
	    /*maxValue - minValue*/

	    var relValue;
	    var config = this._settings;
	    var total_height = point1.y - point0.y;
	    var yax = !!config.yAxis;
	    var xax = !!config.xAxis;

	    var limits = this._getStackedLimits(data);

	    var origin = config.origin === 0;
	    maxValue = limits.max;
	    minValue = limits.min;
	    /*an available width for one bar*/

	    var cellWidth = Math.floor((point1.x - point0.x) / data.length);
	    /*draws x and y scales*/

	    if (!sIndex) {
	      xAxisY = this._drawScales(data, point0, point1, minValue, maxValue, cellWidth);
	    }
	    /*necessary for automatic scale*/


	    if (yax) {
	      maxValue = parseFloat(config.yAxis.end);
	      minValue = parseFloat(config.yAxis.start);
	    }
	    /*unit calculation (bar_height = value*unit)*/


	    var relativeValues = this._getRelativeValue(minValue, maxValue);

	    relValue = relativeValues[0];
	    valueFactor = relativeValues[1];
	    var unit = relValue ? total_height / relValue : 10;
	    /*a real bar width */

	    var barWidth = parseInt(config.barWidth, 10);
	    if (barWidth + 4 > cellWidth) barWidth = cellWidth - 4;
	    /*the half of distance between bars*/

	    var barOffset = Math.floor((cellWidth - barWidth) / 2);
	    var inner_gradient = config.gradient ? config.gradient : false;
	    /*draws a black line if the horizontal scale isn't defined*/

	    if (!xax) {
	      //scaleY = y-bottomPadding;
	      this._drawLine(ctx, point0.x, point1.y + 0.5, point1.x, point1.y + 0.5, "#edeff0", 1); //hardcoded color!

	    }

	    for (var i = 0; i < data.length; i++) {
	      var value = Math.abs(parseFloat(config.value(data[i] || 0)));
	      if (this._logScaleCalc) value = this._log10(value);
	      /*start point (bottom left)*/

	      x0 = point0.x + barOffset + i * cellWidth;
	      var negValue = origin && value < 0;

	      if (!sIndex) {
	        y0 = xAxisY - 1;
	        data[i].$startY = y0;

	        if (origin) {
	          if (negValue) y0 = xAxisY + 1;
	          data[i].$startYN = xAxisY + 1;
	        }
	      } else {
	        y0 = negValue ? data[i].$startYN : data[i].$startY;
	      }

	      if (!value || isNaN(value)) continue;
	      /*adjusts the first tab to the scale*/

	      if (!sIndex && !origin) value -= minValue;
	      value *= valueFactor;
	      /*the max height limit*/

	      if (y0 < point0.y + 1) continue;

	      var color = this._settings.color.call(this, data[i]);

	      var firstSector = Math.abs(y0 - (origin ? point1.y + minValue * unit : point1.y)) < 3;
	      /*drawing bar body*/

	      ctx.globalAlpha = config.alpha.call(this, data[i]);
	      ctx.fillStyle = ctx.strokeStyle = config.color.call(this, data[i]);
	      ctx.beginPath();
	      var y1 = y0 - unit * value + (firstSector ? negValue ? -1 : 1 : 0);

	      var points = this._setStakedBarPoints(ctx, x0 - (config.border ? 0.5 : 0), y0, barWidth + (config.border ? 0.5 : 0), y1, 0, point0.y);

	      ctx.fill();
	      ctx.stroke();
	      /*gradient*/

	      if (inner_gradient) {
	        ctx.save();

	        var gradParam = this._setBarGradient(ctx, x0, y0, x0 + barWidth, points[1], inner_gradient, color, "y");

	        ctx.fillStyle = gradParam.gradient;
	        ctx.beginPath();
	        points = this._setStakedBarPoints(ctx, x0 + gradParam.offset, y0, barWidth - gradParam.offset * 2, y1, config.border ? 1 : 0, point0.y);
	        ctx.fill();
	        ctx.restore();
	      }
	      /*drawing the gradient border of a bar*/


	      if (config.border) {
	        ctx.save();
	        if (typeof config.border == "string") ctx.strokeStyle = config.border;else this._setBorderStyles(ctx, color);
	        ctx.beginPath();

	        this._setStakedBarPoints(ctx, x0 - 0.5, parseInt(y0, 10) + 0.5, barWidth + 1, parseInt(y1, 10) + 0.5, 0, point0.y, firstSector);

	        ctx.stroke();
	        ctx.restore();
	      }

	      ctx.globalAlpha = 1;
	      /*sets a bar label*/

	      this.canvases[sIndex].renderTextAt(false, true, x0 + Math.floor(barWidth / 2), points[1] + (y0 - points[1]) / 2 - 7, this._settings.label(data[i]));
	      /*defines a map area for a bar*/

	      map.addRect(data[i].id, [x0 - point0.x, points[1] - point0.y, points[0] - point0.x, data[i][negValue ? "$startYN" : "$startY"] - point0.y], sIndex);
	      /*the start position for the next series*/

	      data[i][negValue ? "$startYN" : "$startY"] = points[1];
	    }
	  },

	  /**
	   *   sets points for bar and returns the position of the bottom right point
	   *   @param: ctx - canvas object
	   *   @param: x0 - the x position of start point
	   *   @param: y0 - the y position of start point
	   *   @param: barWidth - bar width
	   *   @param: radius - the rounding radius of the top
	   *   @param: unit - the value defines the correspondence between item value and bar height
	   *   @param: value - item value
	   *   @param: offset - the offset from expected bar edge (necessary for drawing border)
	   *   @param: minY - the minimum y position for the bars ()
	   */
	  _setStakedBarPoints: function (ctx, x0, y0, barWidth, y1, offset, minY, skipBottom) {
	    /*start*/
	    ctx.moveTo(x0, y0);
	    /*maximum height limit*/

	    if (y1 < minY) y1 = minY;
	    ctx.lineTo(x0, y1);
	    var x3 = x0 + barWidth;
	    var y3 = y1;
	    ctx.lineTo(x3, y3);
	    /*right rounding*/

	    /*bottom right point*/

	    var x5 = x0 + barWidth;
	    ctx.lineTo(x5, y0);
	    /*line to the start point*/

	    if (!skipBottom) {
	      ctx.lineTo(x0, y0);
	    } //	ctx.lineTo(x0,0); //IE fix!


	    return [x5, y3];
	  }
	};

	var StackedBarHChart = {
	  /**
	  	*   renders a bar chart
	  	*   @param: ctx - canvas object
	  	*   @param: data - object those need to be displayed
	  	*   @param: x - the width of the container
	  	*   @param: y - the height of the container
	  	*   @param: sIndex - index of drawing chart
	  	*   @param: map - map object
	  	*/
	  $render_stackedBarH: function (ctx, data, point0, point1, sIndex, map) {
	    var maxValue, minValue;
	    /*necessary if maxValue - minValue < 0*/

	    var valueFactor;
	    /*maxValue - minValue*/

	    var relValue;
	    var total_width = point1.x - point0.x;
	    var yax = !!this._settings.yAxis;

	    var limits = this._getStackedLimits(data);

	    maxValue = limits.max;
	    minValue = limits.min;
	    /*an available width for one bar*/

	    var cellWidth = Math.floor((point1.y - point0.y) / data.length);
	    /*draws x and y scales*/

	    if (!sIndex) this._drawHScales(ctx, data, point0, point1, minValue, maxValue, cellWidth);
	    /*necessary for automatic scale*/

	    if (yax) {
	      maxValue = parseFloat(this._settings.xAxis.end);
	      minValue = parseFloat(this._settings.xAxis.start);
	    }
	    /*unit calculation (bar_height = value*unit)*/


	    var relativeValues = this._getRelativeValue(minValue, maxValue);

	    relValue = relativeValues[0];
	    valueFactor = relativeValues[1];
	    var unit = relValue ? total_width / relValue : 10;
	    var startValue = 0;

	    if (!yax) {
	      /*defines start value for better representation of small values*/
	      startValue = 10;
	      unit = relValue ? (total_width - startValue) / relValue : 10;
	    }
	    /*a real bar width */


	    var barWidth = parseInt(this._settings.barWidth, 10);
	    if (barWidth + 4 > cellWidth) barWidth = cellWidth - 4;
	    /*the half of distance between bars*/

	    var barOffset = (cellWidth - barWidth) / 2;
	    /*the radius of rounding in the top part of each bar*/

	    var radius = 0;
	    var inner_gradient = false;
	    var gradient = this._settings.gradient;

	    if (gradient) {
	      inner_gradient = true;
	    }
	    /*draws a black line if the horizontal scale isn't defined*/


	    if (!yax) {
	      this._drawLine(ctx, point0.x - 0.5, point0.y, point0.x - 0.5, point1.y, "#edeff0", 1); //hardcoded color!

	    }

	    var seriesNumber = 0;
	    var seriesIndex = 0;

	    for (i = 0; i < this._series.length; i++) {
	      if (i == sIndex) {
	        seriesIndex = seriesNumber;
	      }

	      if (this._series[i].type == "stackedBarH") seriesNumber++;
	    }

	    for (var i = 0; i < data.length; i++) {
	      if (!seriesIndex) data[i].$startX = point0.x;
	      var value = Math.abs(parseFloat(this._settings.value(data[i] || 0)));
	      if (value > maxValue) value = maxValue;
	      value -= minValue;
	      value *= valueFactor;
	      /*start point (bottom left)*/

	      var x0 = point0.x;
	      var y0 = point0.y + barOffset + i * cellWidth;
	      if (!seriesIndex) data[i].$startX = x0;else x0 = data[i].$startX;
	      if (!value || isNaN(value)) continue;
	      /*takes start value into consideration*/

	      if (!yax) value += startValue / unit;

	      var color = this._settings.color.call(this, data[i]);
	      /*drawing bar body*/


	      ctx.globalAlpha = this._settings.alpha.call(this, data[i]);
	      ctx.fillStyle = this._settings.color.call(this, data[i]);
	      ctx.beginPath();

	      var points = this._setBarHPoints(ctx, x0, y0, barWidth, radius, unit, value, 0);

	      if (gradient && !inner_gradient) ctx.lineTo(point0.x + total_width, y0 + (this._settings.border ? 1 : 0)); //fix gradient sphreading

	      ctx.fill();

	      if (inner_gradient) {
	        var gradParam = this._setBarGradient(ctx, x0, y0 + barWidth, x0, y0, inner_gradient, color, "x");

	        ctx.fillStyle = gradParam.gradient;
	        ctx.beginPath();
	        points = this._setBarHPoints(ctx, x0, y0, barWidth, radius, unit, value, 0);
	        ctx.fill();
	      }
	      /*drawing the gradient border of a bar*/


	      if (this._settings.border) {
	        this._drawBarHBorder(ctx, x0, y0, barWidth, minValue, radius, unit, value, color);
	      }

	      ctx.globalAlpha = 1;
	      /*sets a bar label*/

	      this.canvases[sIndex].renderTextAt("middle", true, data[i].$startX + (points[0] - data[i].$startX) / 2 - 1, y0 + (points[1] - y0) / 2, this._settings.label(data[i]));
	      /*defines a map area for a bar*/

	      map.addRect(data[i].id, [data[i].$startX - point0.x, y0 - point0.y, points[0] - point0.x, points[1] - point0.y], sIndex);
	      /*the start position for the next series*/

	      data[i].$startX = points[0];
	    }
	  }
	};

	var Spline$1 = {
	  /**
	  *   renders a spline chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: width - the width of the container
	  *   @param: height - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_spline: function (ctx, data, point0, point1, sIndex, map) {
	    var config, i, items, j, params, sparam, x, x0, x1, x2, y, y1, y2;
	    params = this._calculateLineParams(ctx, data, point0, point1, sIndex);
	    config = this._settings;
	    this._mapStart = point0;
	    /*array of all points*/

	    items = [];
	    /*drawing all items*/

	    if (data.length) {
	      /*getting all points*/
	      x0 = config.offset ? point0.x + params.cellWidth * 0.5 : point0.x;

	      for (i = 0; i < data.length; i++) {
	        y = this._getPointY(data[i], point0, point1, params);

	        if (y || y == "0") {
	          x = !i ? x0 : params.cellWidth * i - 0.5 + x0;
	          items.push({
	            x: x,
	            y: y,
	            v: this._settings.value(data[i]),
	            index: i
	          });
	        }
	      }

	      sparam = this._getSplineParameters(items);

	      for (i = 0; i < items.length; i++) {
	        x1 = items[i].x;
	        y1 = items[i].y;

	        if (i < items.length - 1) {
	          x2 = items[i + 1].x;
	          y2 = items[i + 1].y;

	          for (j = x1; j < x2; j++) {
	            var sY1 = this._getSplineYPoint(j, x1, i, sparam.a, sparam.b, sparam.c, sparam.d);

	            if (sY1 < point0.y) sY1 = point0.y;
	            if (sY1 > point1.y) sY1 = point1.y;

	            var sY2 = this._getSplineYPoint(j + 1, x1, i, sparam.a, sparam.b, sparam.c, sparam.d);

	            if (sY2 < point0.y) sY2 = point0.y;
	            if (sY2 > point1.y) sY2 = point1.y;

	            this._drawLine(ctx, j, sY1, j + 1, sY2, config.line.color(data[i]), config.line.width);
	          }

	          this._drawLine(ctx, x2 - 1, this._getSplineYPoint(j, x1, i, sparam.a, sparam.b, sparam.c, sparam.d), x2, y2, config.line.color(data[i]), config.line.width);
	        }

	        this._drawItem(ctx, x1, y1, data[items[i].index], config.label(data[items[i].index]), sIndex, map);
	      }
	    }
	  },

	  /*gets spline parameter*/
	  _getSplineParameters: function (points) {
	    var a,
	        b,
	        c,
	        d,
	        i,
	        s,
	        u,
	        v,
	        h = [],
	        m = [],
	        n = points.length;

	    for (i = 0; i < n - 1; i++) {
	      h[i] = points[i + 1].x - points[i].x;
	      m[i] = (points[i + 1].y - points[i].y) / h[i];
	    }

	    u = [];
	    v = [];
	    u[0] = 0;
	    u[1] = 2 * (h[0] + h[1]);
	    v[0] = 0;
	    v[1] = 6 * (m[1] - m[0]);

	    for (i = 2; i < n - 1; i++) {
	      u[i] = 2 * (h[i - 1] + h[i]) - h[i - 1] * h[i - 1] / u[i - 1];
	      v[i] = 6 * (m[i] - m[i - 1]) - h[i - 1] * v[i - 1] / u[i - 1];
	    }

	    s = [];
	    s[n - 1] = s[0] = 0;

	    for (i = n - 2; i >= 1; i--) {
	      s[i] = (v[i] - h[i] * s[i + 1]) / u[i];
	    }

	    a = [];
	    b = [];
	    c = [];
	    d = [];

	    for (i = 0; i < n - 1; i++) {
	      a[i] = points[i].y;
	      b[i] = -h[i] * s[i + 1] / 6 - h[i] * s[i] / 3 + (points[i + 1].y - points[i].y) / h[i];
	      c[i] = s[i] / 2;
	      d[i] = (s[i + 1] - s[i]) / (6 * h[i]);
	    }

	    for (i = 0; i < points.length - 1; i++) {
	      if (points[i].v === 0 && points[i + 1].v === 0) {
	        a[i] = points[i].y;
	        d[i] = c[i] = b[i] = 0;
	      }
	    }

	    return {
	      a: a,
	      b: b,
	      c: c,
	      d: d
	    };
	  },

	  /*returns the y position of the spline point */
	  _getSplineYPoint: function (x, xi, i, a, b, c, d) {
	    return a[i] + (x - xi) * (b[i] + (x - xi) * (c[i] + (x - xi) * d[i]));
	  }
	};

	var AreaChart = {
	  /**
	  *   renders an area chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: width - the width of the container
	  *   @param: height - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_area: function (ctx, data, point0, point1, sIndex, map) {
	    var align, config, i, mapRect, obj, params, path, res1, res2, x0, x1, y1, x2, y2, y0;
	    params = this._calculateLineParams(ctx, data, point0, point1, sIndex);
	    config = this._settings; //the size of map area

	    mapRect = config.eventRadius || Math.floor(params.cellWidth / 2);

	    if (data.length) {
	      // area points
	      path = []; //the x position of the first item

	      x0 = !config.offset ? point0.x : point0.x + params.cellWidth * 0.5;
	      /*
	       iterates over all data items:
	       calculates [x,y] for area path, adds rect to chart map and renders labels
	       */

	      for (i = 0; i < data.length; i++) {
	        obj = data[i];
	        res2 = this._getPointY(obj, point0, point1, params);
	        x2 = x0 + params.cellWidth * i;

	        if (res2) {
	          y2 = _typeof(res2) == "object" ? res2.y0 : res2;

	          if (i && this._settings.fixOverflow) {
	            res1 = this._getPointY(data[i - 1], point0, point1, params);

	            if (res1.out && res1.out == res2.out) {
	              continue;
	            }

	            x1 = params.cellWidth * (i - 1) - 0.5 + x0;
	            y1 = _typeof(res1) == "object" ? res1.y0 : res1;

	            if (res1.out) {
	              y0 = res1.out == "min" ? point1.y : point0.y;
	              path.push([this._calcOverflowX(x1, x2, y1, y2, y0), y0]);
	            }

	            if (res2.out) {
	              y0 = res2.out == "min" ? point1.y : point0.y;
	              path.push([this._calcOverflowX(x1, x2, y1, y2, y0), y0]);
	              if (i == data.length - 1 && y0 == point0.y) path.push([x2, point0.y]);
	            }
	          }

	          if (!res2.out) {
	            path.push([x2, y2]); //map

	            map.addRect(obj.id, [x2 - mapRect - point0.x, y2 - mapRect - point0.y, x2 + mapRect - point0.x, y2 + mapRect - point0.y], sIndex);
	          } //labels


	          if (!config.yAxis) {
	            align = !config.offset && i == data.length - 1 ? "left" : "center";
	            this.canvases[sIndex].renderTextAt(false, align, x2, y2 - config.labelOffset, config.label(obj));
	          }
	        }
	      }

	      if (path.length) {
	        path.push([x2, point1.y]);
	        path.push([path[0][0], point1.y]);
	      } //filling area


	      ctx.globalAlpha = this._settings.alpha.call(this, data[0]);
	      ctx.fillStyle = this._settings.color.call(this, data[0]);
	      ctx.beginPath();

	      this._path(ctx, path);

	      ctx.fill();
	      ctx.lineWidth = 1;
	      ctx.globalAlpha = 1; //border

	      if (config.border) {
	        ctx.lineWidth = config.borderWidth || 1;
	        if (config.borderColor) ctx.strokeStyle = config.borderColor.call(this, data[0]);else this._setBorderStyles(ctx, ctx.fillStyle);
	        ctx.beginPath();

	        this._path(ctx, path);

	        ctx.stroke();
	      }
	    }
	  },

	  /**
	  *   renders an area chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: width - the width of the container
	  *   @param: height - the height of the container
	  *   @param: sIndex - index of drawing chart
	  */
	  $render_stackedArea: function (ctx, data, point0, point1, sIndex, map) {
	    var a0, a1, align, config, i, j, lastItem, mapRect, obj, params, path, x, y, yPos;
	    params = this._calculateLineParams(ctx, data, point0, point1, sIndex);
	    config = this._settings;
	    /*the value that defines the map area position*/

	    mapRect = config.eventRadius || Math.floor(params.cellWidth / 2);
	    /*drawing all items*/

	    if (data.length) {
	      // area points
	      path = []; // y item positions

	      yPos = []; //the x position of the first item

	      x = !config.offset ? point0.x : point0.x + params.cellWidth * 0.5;

	      var setOffset = function (i, y) {
	        return sIndex ? data[i].$startY ? y - point1.y + data[i].$startY : 0 : y;
	      };

	      var solveEquation = function (x, p0, p1) {
	        var k = (p1.y - p0.y) / (p1.x - p0.x);
	        return k * x + p0.y - k * p0.x;
	      };
	      /*
	       iterates over all data items:
	       calculates [x,y] for area path, adds rect to chart map and renders labels
	       */


	      for (i = 0; i < data.length; i++) {
	        obj = data[i];

	        if (!i) {
	          y = setOffset(i, point1.y);
	          path.push([x, y]);
	        } else {
	          x += params.cellWidth;
	        }

	        y = setOffset(i, this._getPointY(obj, point0, point1, params));
	        yPos.push(isNaN(y) && !i ? data[i].$startY || point1.y : y);

	        if (y) {
	          path.push([x, y]); //map

	          map.addRect(obj.id, [x - mapRect - point0.x, y - mapRect - point0.y, x + mapRect - point0.x, y + mapRect - point0.y], sIndex); //labels

	          if (!config.yAxis) {
	            align = !config.offset && lastItem ? "left" : "center";
	            this.canvases[sIndex].renderTextAt(false, align, x, y - config.labelOffset, config.label(obj));
	          }
	        }
	      } // bottom right point


	      path.push([x, setOffset(i - 1, point1.y)]); // lower border from the end to start

	      if (sIndex) {
	        for (i = data.length - 2; i > 0; i--) {
	          x -= params.cellWidth;
	          y = data[i].$startY;
	          if (y) path.push([x, y]);
	        }
	      } // go to start point


	      path.push([path[0][0], path[0][1]]); // filling path

	      ctx.globalAlpha = this._settings.alpha.call(this, data[0]);
	      ctx.fillStyle = this._settings.color.call(this, data[0]);
	      ctx.beginPath();

	      this._path(ctx, path);

	      ctx.fill(); // set y positions of the next series

	      for (i = 0; i < data.length; i++) {
	        y = yPos[i];

	        if (!y) {
	          if (i == data.length - 1) {
	            y = data[i].$startY;
	          }

	          for (j = i + 1; j < data.length; j++) {
	            if (yPos[j]) {
	              a0 = {
	                x: point0.x,
	                y: yPos[0]
	              };
	              a1 = {
	                x: point0.x + params.cellWidth * j,
	                y: yPos[j]
	              };
	              y = solveEquation(point0.x + params.cellWidth * i, a0, a1);
	              break;
	            }
	          }
	        }

	        data[i].$startY = y;
	      }
	    }
	  }
	};

	var Radar = {
	  $render_radar: function (ctx, data, x, y, sIndex, map) {
	    this._renderRadarChart(ctx, data, x, y, sIndex, map);
	  },

	  /**
	  *   renders a pie chart
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: x - the width of the container
	  *   @param: y - the height of the container
	  *   @param: ky - value from 0 to 1 that defines an angle of inclination (0<ky<1 - 3D chart)
	  */
	  _renderRadarChart: function (ctx, data, point0, point1, sIndex, map) {
	    if (!data.length) return;

	    var coord = this._getPieParameters(point0, point1);
	    /*scale radius*/


	    var radius = this._settings.radius ? this._settings.radius : coord.radius;
	    /*scale center*/

	    var x0 = this._settings.x ? this._settings.x : coord.x;
	    var y0 = this._settings.y ? this._settings.y : coord.y;
	    /*angles for each unit*/

	    var ratioUnits = [];

	    for (var i = 0; i < data.length; i++) {
	      ratioUnits.push(1);
	    }

	    var ratios = this._getRatios(ratioUnits, data.length);

	    this._mapStart = point0;
	    if (!sIndex) this._drawRadarAxises(ratios, x0, y0, radius, data);

	    this._drawRadarData(ctx, ratios, x0, y0, radius, data, sIndex, map);
	  },
	  _drawRadarData: function (ctx, ratios, x, y, radius, data, sIndex, map) {
	    var alpha0, alpha1, config, i, min, max, pos0, pos1, posArr, r0, r1, relValue, startAlpha, value, value0, value1, valueFactor, unit, unitArr;
	    config = this._settings;
	    /*unit calculation (item_radius_pos = value*unit)*/

	    min = config.yAxis.start;
	    max = config.yAxis.end;
	    unitArr = this._getRelativeValue(min, max);
	    relValue = unitArr[0];
	    unit = relValue ? radius / relValue : radius / 2;
	    valueFactor = unitArr[1];
	    startAlpha = -Math.PI / 2;
	    alpha0 = alpha1 = startAlpha;
	    posArr = [];
	    pos1 = 0;

	    for (i = 0; i < data.length; i++) {
	      if (!value1) {
	        value = config.value(data[i]);
	        if (this._logScaleCalc) value = this._log10(value);
	        /*a relative value*/

	        value0 = (parseFloat(value || 0) - min) * valueFactor;
	      } else value0 = value1;

	      r0 = Math.floor(unit * value0);
	      value = config.value(i != data.length - 1 ? data[i + 1] : data[0]);
	      if (this._logScaleCalc) value = this._log10(value);
	      value1 = (parseFloat(value || 0) - min) * valueFactor;
	      r1 = Math.floor(unit * value1);
	      alpha0 = alpha1;
	      alpha1 = i != data.length - 1 ? startAlpha + ratios[i] - 0.0001 : startAlpha;
	      pos0 = pos1 || this._getPositionByAngle(alpha0, x, y, r0);
	      pos1 = this._getPositionByAngle(alpha1, x, y, r1);
	      /*creates map area*/

	      /*areaWidth  = (config.eventRadius||(parseInt(config.item.radius.call(this,data[i]),10)+config.item.borderWidth));
	       map.addRect(data[i].id,[pos0.x-areaWidth,pos0.y-areaWidth,pos0.x+areaWidth,pos0.y+areaWidth],sIndex);*/
	      //this._drawLine(ctx,pos0.x,pos0.y,pos1.x,pos1.y,config.line.color.call(this,data[i]),config.line.width)

	      posArr.push(pos0);
	    }

	    if (config.fill) this._fillRadarChart(ctx, posArr, data);
	    if (!config.disableLines && data.length > 2) this._strokeRadarChart(ctx, posArr, data);
	    if (!config.disableItems || data.length < 3) this._drawRadarItemMarkers(ctx, posArr, data, sIndex, map);
	    posArr = null;
	  },
	  _drawRadarItemMarkers: function (ctx, points, data, sIndex, map) {
	    for (var i = 0; i < points.length; i++) {
	      this._drawItem(ctx, points[i].x, points[i].y, data[i], this._settings.label.call(this, data), sIndex, map);
	    }
	  },
	  _fillRadarChart: function (ctx, points, data) {
	    var pos0, pos1;
	    ctx.globalAlpha = this._settings.alpha.call(this, {});
	    ctx.beginPath();

	    for (var i = 0; i < points.length; i++) {
	      ctx.fillStyle = this._settings.fill.call(this, data[i]);
	      pos0 = points[i];
	      pos1 = points[i + 1] || points[0];

	      if (!i) {
	        ctx.moveTo(pos0.x, pos0.y);
	      }

	      ctx.lineTo(pos1.x, pos1.y);
	    }

	    ctx.fill();
	    ctx.globalAlpha = 1;
	  },
	  _strokeRadarChart: function (ctx, points, data) {
	    var pos0, pos1;

	    for (var i = 0; i < points.length; i++) {
	      pos0 = points[i];
	      pos1 = points[i + 1] || points[0];

	      this._drawLine(ctx, pos0.x, pos0.y, pos1.x, pos1.y, this._settings.line.color.call(this, data[i]), this._settings.line.width);
	    }
	  },
	  _drawRadarAxises: function (ratios, x, y, radius, data) {
	    var configY = this._settings.yAxis;
	    var configX = this._settings.xAxis;
	    var start = configY.start;
	    var end = configY.end;
	    var step = configY.step;
	    var scaleParam = {};
	    var config = this._configYAxis;

	    if (typeof config.step == "undefined" || typeof config.start == "undefined" || typeof config.end == "undefined") {
	      var limits = this._getLimits();

	      scaleParam = this._calculateScale(limits.min, limits.max);
	      start = scaleParam.start;
	      end = scaleParam.end;
	      step = scaleParam.step;
	      configY.end = end;
	      configY.start = start;
	    }

	    var units = [];
	    var i, j, p;
	    var c = 0;
	    var stepHeight = radius * step / (end - start);
	    /*correction for small step*/

	    var power, corr;

	    if (step < 1) {
	      power = Math.min(this._log10(step), start <= 0 ? 0 : this._log10(start));
	      corr = Math.pow(10, -power);
	    }

	    var angles = [];
	    if (!this.canvases["scale"]) this.canvases["scale"] = this._createCanvas("radar_scale");
	    var ctx = this.canvases["scale"].getCanvas();

	    for (i = end; i >= start; i -= step) {
	      var value = this._logScaleCalc ? Math.pow(10, i) : i;
	      if (scaleParam.fixNum) value = parseFloat(i).toFixed(scaleParam.fixNum);
	      units.push(Math.floor(c * stepHeight) + 0.5);

	      if (corr && !this._logScaleCalc) {
	        value = Math.round(value * corr) / corr;
	        i = value;
	      }

	      var unitY = y - radius + units[units.length - 1];
	      this.canvases["scale"].renderTextAt("middle", "left", x, unitY, configY.template(value.toString()), "webix_axis_item_y webix_radar");

	      if (ratios.length < 2) {
	        this._drawScaleSector(ctx, "arc", x, y, radius - units[units.length - 1], -Math.PI / 2, 3 * Math.PI / 2, i);

	        return;
	      }

	      var startAlpha = -Math.PI / 2;
	      /*possibly need  to moved in config*/

	      var alpha0 = startAlpha;
	      var alpha1;

	      for (j = 0; j < ratios.length; j++) {
	        if (!c) angles.push(alpha0);
	        alpha1 = startAlpha + ratios[j] - 0.0001;

	        this._drawScaleSector(ctx, ratios.length > 2 ? config.lineShape || "line" : "arc", x, y, radius - units[units.length - 1], alpha0, alpha1, i, j, data[i]);

	        alpha0 = alpha1;
	      }

	      c++;
	    }
	    /*renders radius lines and labels*/


	    for (i = 0; i < angles.length; i++) {
	      p = this._getPositionByAngle(angles[i], x, y, radius);
	      if (configX.lines.call(this, data[i], i)) this._drawLine(ctx, x, y, p.x, p.y, configX ? configX.lineColor.call(this, data[i]) : "#cfcfcf", 1);

	      this._drawRadarScaleLabel(ctx, x, y, radius, angles[i], configX ? configX.template.call(this, data[i]) : "&nbsp;");
	    }
	  },
	  _drawScaleSector: function (ctx, shape, x, y, radius, a1, a2, i, j) {
	    var pos1, pos2;
	    if (radius < 0) return false;
	    pos1 = this._getPositionByAngle(a1, x, y, radius);
	    pos2 = this._getPositionByAngle(a2, x, y, radius);
	    var configY = this._settings.yAxis;

	    if (configY.bg) {
	      ctx.beginPath();
	      ctx.moveTo(x, y);
	      if (shape == "arc") ctx.arc(x, y, radius, a1, a2, false);else {
	        ctx.lineTo(pos1.x, pos1.y);
	        ctx.lineTo(pos2.x, pos2.y);
	      }
	      ctx.fillStyle = configY.bg(i, j);
	      ctx.moveTo(x, y);
	      ctx.fill();
	      ctx.closePath();
	    }

	    if (configY.lines.call(this, i)) {
	      ctx.lineWidth = 1;
	      ctx.beginPath();
	      if (shape == "arc") ctx.arc(x, y, radius, a1, a2, false);else {
	        ctx.moveTo(pos1.x, pos1.y);
	        ctx.lineTo(pos2.x, pos2.y);
	      }
	      ctx.strokeStyle = configY.lineColor.call(this, i);
	      ctx.stroke();
	    }
	  },
	  _drawRadarScaleLabel: function (ctx, x, y, r, a, text) {
	    if (!text) return false;
	    var t = this.canvases["scale"].renderText(0, 0, text, "webix_axis_radar_title", 1);
	    var width = t.scrollWidth;
	    var height = t.offsetHeight;
	    var delta = 0.001;

	    var pos = this._getPositionByAngle(a, x, y, r + 5);

	    var corr_x = 0,
	        corr_y = 0;

	    if (a < 0 || a > Math.PI) {
	      corr_y = -height;
	    }

	    if (a > Math.PI / 2) {
	      corr_x = -width;
	    }

	    if (Math.abs(a + Math.PI / 2) < delta || Math.abs(a - Math.PI / 2) < delta) {
	      corr_x = -width / 2;
	    } else if (Math.abs(a) < delta || Math.abs(a - Math.PI) < delta) {
	      corr_y = -height / 2;
	    }

	    t.style.top = pos.y + corr_y + "px";
	    t.style.left = pos.x + corr_x + "px";
	    t.style.width = width + "px";
	    t.style.whiteSpace = "nowrap";
	  }
	};

	var Scatter = {
	  /**
	  *   renders a graphic
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: point0  - top left point of a chart
	  *   @param: point1  - right bottom point of a chart
	  *   @param: sIndex - index of drawing chart
	     *   @param: map - map object
	  */
	  $render_scatter: function (ctx, data, point0, point1, sIndex, map) {
	    if (!this._settings.xValue) return;
	    var config = this._settings;
	    var lines = !(config.disableLines || typeof config.disableLines == "undefined");
	    /*max in min values*/

	    var limitsY = this._getLimits();

	    var limitsX = this._getLimits("h", "xValue");
	    /*render scale*/


	    if (!sIndex) {
	      if (!this.canvases["x"]) this.canvases["x"] = this._createCanvas("axis_x");
	      if (!this.canvases["y"]) this.canvases["y"] = this._createCanvas("axis_y");

	      this._drawYAxis(this.canvases["y"].getCanvas(), data, point0, point1, limitsY.min, limitsY.max);

	      this._drawHXAxis(this.canvases["x"].getCanvas(), data, point0, point1, limitsX.min, limitsX.max);
	    }

	    limitsY = {
	      min: config.yAxis.start,
	      max: config.yAxis.end
	    };
	    limitsX = {
	      min: config.xAxis.start,
	      max: config.xAxis.end
	    };

	    var params = this._getScatterParams(ctx, data, point0, point1, limitsX, limitsY);

	    this._mapStart = point0;
	    var items = [];

	    for (var i = 0; i < data.length; i++) {
	      var x = this._calculateScatterItemPosition(params, point1, point0, limitsX, data[i], "X");

	      var y = this._calculateScatterItemPosition(params, point0, point1, limitsY, data[i], "Y");

	      if (isNaN(x) || isNaN(y)) continue;
	      items.push({
	        x: x,
	        y: y,
	        index: i
	      });
	    }

	    var x1, y1, x2, y2, di;

	    for (var _i = 0; _i < items.length; _i++) {
	      di = items[_i].index;

	      if (lines) {
	        var color = config.line.color.call(this, data[di]); //line start position

	        x1 = items[_i].x;
	        y1 = items[_i].y;

	        if (_i == items.length - 1) {
	          //connecting last and first items
	          if (config.shape && items.length > 2) {
	            this._drawLine(ctx, x2, y2, items[0].x, items[0].y, color, config.line.width); //render shape on top of the line


	            if (!config.disableItems) this._drawScatterItem(ctx, map, items[0], data[0], sIndex);
	            if (config.fill) this._fillScatterChart(ctx, items, data);
	          }
	        } else {
	          // line between two points
	          x2 = items[_i + 1].x;
	          y2 = items[_i + 1].y;

	          this._drawLine(ctx, x1, y1, x2, y2, color, config.line.width);
	        }
	      } //item


	      if (!config.disableItems && items[_i]) {
	        this._drawScatterItem(ctx, map, items[_i], data[di], sIndex);
	      }
	    }
	  },
	  _fillScatterChart: function (ctx, points, data) {
	    var pos0, pos1;
	    ctx.globalAlpha = this._settings.alpha.call(this, {});
	    ctx.beginPath();

	    for (var i = 0; i < points.length; i++) {
	      ctx.fillStyle = this._settings.fill.call(this, data[i]);
	      pos0 = points[i];
	      pos1 = points[i + 1] || points[0];

	      if (!i) {
	        ctx.moveTo(pos0.x, pos0.y);
	      }

	      ctx.lineTo(pos1.x, pos1.y);
	    }

	    ctx.fill();
	    ctx.globalAlpha = 1;
	  },
	  _getScatterParams: function (ctx, data, point0, point1, limitsX, limitsY) {
	    var params = {};
	    /*available space*/

	    params.totalHeight = point1.y - point0.y;
	    /*available width*/

	    params.totalWidth = point1.x - point0.x;
	    /*unit calculation (y_position = value*unit)*/

	    this._calcScatterUnit(params, limitsX.min, limitsX.max, params.totalWidth, "X");

	    this._calcScatterUnit(params, limitsY.min, limitsY.max, params.totalHeight, "Y");

	    return params;
	  },
	  _drawScatterItem: function (ctx, map, item, obj, sIndex) {
	    this._drawItem(ctx, item.x, item.y, obj, this._settings.label.call(this, obj), sIndex, map);
	  },
	  _calculateScatterItemPosition: function (params, point0, point1, limits, obj, axis) {
	    /*the real value of an object*/
	    var value = this._settings[axis == "X" ? "xValue" : "value"].call(this, obj);
	    /*a relative value*/


	    var valueFactor = params["valueFactor" + axis];
	    var v = (parseFloat(value || 0) - limits.min) * valueFactor;
	    /*a vertical coordinate*/

	    var unit = params["unit" + axis];
	    var pos = point1[axis.toLowerCase()] - (axis == "X" ? -1 : 1) * Math.floor(unit * v);
	    /*the limit of the minimum value is  the minimum visible value*/

	    if (v < 0) pos = point1[axis.toLowerCase()];
	    /*the limit of the maximum value*/

	    if (value > limits.max) pos = point0[axis.toLowerCase()];
	    /*the limit of the minimum value*/

	    if (value < limits.min) pos = point1[axis.toLowerCase()];
	    return pos;
	  },
	  _calcScatterUnit: function (p, min, max, size, axis) {
	    var relativeValues = this._getRelativeValue(min, max);

	    axis = axis || "";
	    p["relValue" + axis] = relativeValues[0];
	    p["valueFactor" + axis] = relativeValues[1];
	    p["unit" + axis] = p["relValue" + axis] ? size / p["relValue" + axis] : 10;
	  }
	};

	var Presets = {
	  presets: {
	    "simple": {
	      item: {
	        borderColor: "#ffffff",
	        color: "#2b7100",
	        shadow: false,
	        borderWidth: 2
	      },
	      line: {
	        color: "#8ecf03",
	        width: 2
	      }
	    },
	    "plot": {
	      color: "#8664C6",
	      item: {
	        borderColor: "#8664C6",
	        borderWidth: 1,
	        color: "#ffffff",
	        type: "r",
	        shadow: false
	      },
	      line: {
	        color: "#8664C6",
	        width: 2
	      }
	    },
	    "diamond": {
	      color: "#FF5C4C",
	      item: {
	        borderColor: "#FF5C4C",
	        color: "#FF5C4C",
	        type: "d",
	        radius: 3,
	        shadow: true
	      },
	      line: {
	        color: "#FF5C4C",
	        width: 2
	      }
	    },
	    "point": {
	      color: "#1ca1c1",
	      disableLines: true,
	      fill: false,
	      disableItems: false,
	      item: {
	        color: "#1ca1c1",
	        borderColor: "#1ca1c1",
	        radius: 2,
	        borderWidth: 2,
	        type: "r"
	      },
	      alpha: 1
	    },
	    "line": {
	      line: {
	        color: "#1ca1c1",
	        width: 2
	      },
	      item: {
	        color: "#ffffff",
	        borderColor: "#1ca1c1",
	        radius: 2,
	        borderWidth: 2,
	        type: "d"
	      },
	      fill: false,
	      disableItems: false,
	      disableLines: false,
	      alpha: 1
	    },
	    "area": {
	      fill: "#1ca1c1",
	      line: {
	        color: "#1ca1c1",
	        width: 1
	      },
	      disableItems: true,
	      alpha: 0.2,
	      disableLines: false
	    },
	    "round": {
	      item: {
	        radius: 3,
	        borderColor: "#1ca1c1",
	        borderWidth: 1,
	        color: "#1ca1c1",
	        type: "r",
	        shadow: false,
	        alpha: 0.6
	      }
	    },
	    "square": {
	      item: {
	        radius: 3,
	        borderColor: "#00a497",
	        borderWidth: 2,
	        color: "#ffffff",
	        type: "s",
	        shadow: false,
	        alpha: 1
	      },
	      line: {
	        color: "#00a497"
	      }
	    },

	    /*bar*/
	    "column": {
	      color: "RAINBOW",
	      gradient: false,
	      barWidth: 45,
	      radius: 0,
	      alpha: 1,
	      border: true
	    },
	    "stick": {
	      barWidth: 5,
	      gradient: false,
	      color: "#1ca1c1",
	      radius: 2,
	      alpha: 1,
	      border: false
	    },
	    "alpha": {
	      color: "#b9a8f9",
	      barWidth: 70,
	      gradient: "falling",
	      radius: 0,
	      alpha: 0.5,
	      border: true
	    }
	  }
	};

	var SplineArea$1 = {
	  /**
	   *   renders an splineArea chart
	   *   @param: ctx - canvas object
	   *   @param: data - object those need to be displayed
	   *   @param: width - the width of the container
	   *   @param: height - the height of the container
	   *   @param: sIndex - index of drawing chart
	   */
	  $render_splineArea: function (ctx, data, point0, point1, sIndex, map) {
	    var color,
	        i,
	        items,
	        j,
	        mapRect,
	        params,
	        sParams,
	        x,
	        x0,
	        x1,
	        x2,
	        y,
	        y2,
	        config = this._settings,
	        path = [];
	    params = this._calculateLineParams(ctx, data, point0, point1, sIndex);
	    mapRect = config.eventRadius || Math.floor(params.cellWidth / 2);
	    /*array of all points*/

	    items = [];

	    if (data.length) {
	      /*getting all points*/
	      x0 = point0.x;

	      for (i = 0; i < data.length; i++) {
	        y = this._getPointY(data[i], point0, point1, params);

	        if (y || y == "0") {
	          x = !i ? x0 : params.cellWidth * i - 0.5 + x0;
	          items.push({
	            x: x,
	            y: y,
	            index: i
	          });
	          map.addRect(data[i].id, [x - mapRect - point0.x, y - mapRect - point0.y, x + mapRect - point0.x, y + mapRect - point0.y], sIndex);
	        }
	      }

	      sParams = this._getSplineParameters(items);

	      for (i = 0; i < items.length; i++) {
	        x1 = items[i].x;

	        if (i < items.length - 1) {
	          x2 = items[i + 1].x;
	          y2 = items[i + 1].y;

	          for (j = x1; j < x2; j++) {
	            var sY1 = this._getSplineYPoint(j, x1, i, sParams.a, sParams.b, sParams.c, sParams.d);

	            if (sY1 < point0.y) sY1 = point0.y;
	            if (sY1 > point1.y) sY1 = point1.y;

	            var sY2 = this._getSplineYPoint(j + 1, x1, i, sParams.a, sParams.b, sParams.c, sParams.d);

	            if (sY2 < point0.y) sY2 = point0.y;
	            if (sY2 > point1.y) sY2 = point1.y;
	            path.push([j, sY1]);
	            path.push([j + 1, sY2]);
	          }

	          path.push([x2, y2]);
	        }
	      }

	      color = this._settings.color.call(this, data[0]);

	      if (path.length) {
	        path.push([x2, point1.y]);
	        path.push([path[0][0], point1.y]);
	      } //filling area


	      ctx.globalAlpha = this._settings.alpha.call(this, data[0]);
	      ctx.fillStyle = color;
	      ctx.beginPath();

	      this._path(ctx, path);

	      ctx.fill();
	      ctx.lineWidth = 1;
	      ctx.globalAlpha = 1; // draw line

	      if (config.border) {
	        ctx.lineWidth = config.borderWidth || 1;
	        if (config.borderColor) ctx.strokeStyle = config.borderColor.call(this, data[0]);else this._setBorderStyles(ctx, color);
	        ctx.beginPath();
	        path.splice(path.length - 3);

	        this._path(ctx, path);

	        ctx.stroke();
	      }
	    }
	  }
	};

	var animateDuration = 400,
	    cellWidth = 30;
	var DynamicChart = {
	  dynamic_setter: function (value) {
	    if (value) init(this);
	    return value;
	  }
	};
	/**
	 * Sets event handlers and properties for a stock chart
	 * @param {object} chart - chart view
	 */

	function init(chart) {
	  if (chart._stockRenderHandler) return;
	  var config = chart._settings;
	  if (!config.cellWidth) config.cellWidth = cellWidth;
	  if (!config.animateDuration) config.animateDuration = animateDuration;
	  config.offset = false;
	  chart._stockRenderHandler = chart.attachEvent("onBeforeRender", function (data, type) {
	    var bounds = chart._getChartBounds(chart._content_width, chart._content_height);

	    resizeStockCanvases(chart);
	    filterStockData(data, bounds.start, bounds.end, config.cellWidth);
	    if (type == "add") startAnimation(chart);
	  });
	  chart._stockXAxisHandler = chart.attachEvent("onBeforeXAxis", function (ctx, data, point0, point1, cellWidth, y) {
	    drawXAxis(chart, ctx, data, point0, point1, cellWidth, y);
	    return false;
	  });
	}
	/**
	 * Starts stock animation
	 * @param {object} chart - chart view
	 */


	function startAnimation(chart) {
	  var cellWidth = chart._settings.cellWidth;

	  if (chart._stockAnimationOffset != cellWidth) {
	    chart._stockAnimationOffset = cellWidth;
	    chart.render();
	  }

	  chart._stockAnimationOffset = 0;
	  chart._stockAnimationStart = null;
	  if (window.requestAnimationFrame && !document.hidden) window.requestAnimationFrame(function (t) {
	    animate$2(chart, t);
	  });
	  if (!chart._stockAnimateHandler) chart._stockAnimateHandler = chart.attachEvent("onAfterRender", function (data) {
	    applyStockOffset(chart, data);
	  });
	}
	/**
	 * Animates a chart
	 * @param {object} chart - chart view
	 * @param {number} timestamp - timestamp
	 */


	function animate$2(chart, timestamp) {
	  var progress,
	      duration = chart._settings.animateDuration,
	      cellWidth = chart._settings.cellWidth;

	  if (cellWidth && chart.count() > 1) {
	    if (!chart._stockAnimationStart) chart._stockAnimationStart = timestamp;
	    progress = timestamp - chart._stockAnimationStart;
	    chart._stockAnimationOffset = Math.min(Math.max(progress / duration * cellWidth, 1), cellWidth);
	    chart.render();
	    if (progress < duration) window.requestAnimationFrame(function (t) {
	      animate$2(chart, t);
	    });
	  }
	}
	/**
	 * Applies animation offset to "series" and "x-axis" canvases
	 * @param {object} chart - chart view
	 * @param {object} data - data array
	 */


	function applyStockOffset(chart, data) {
	  var count = chart.count(),
	      bounds = chart._getChartBounds(chart._content_width, chart._content_height),
	      cellWidth = chart._settings.cellWidth,
	      offset$$1 = chart._stockAnimationOffset || 0,
	      isScroll = data.length < count || (data.length - 1) * cellWidth > bounds.end.x - bounds.start.x;

	  function setCanvasOffset(canvas, x0, x1, skipRight) {
	    var ctx = canvas.getCanvas(),
	        elem = canvas._canvas,
	        labels = canvas._canvas_labels,
	        series = canvas._canvas_series; // if we need to display less values than they are

	    if (offset$$1 && (data.length < count || (data.length - 1) * cellWidth > x1 - x0)) {
	      // move canvas to the left
	      elem.style.left = -offset$$1 + "px";

	      if (data.length > 1) {
	        setLabelsOffset(labels, offset$$1, series); // clear out of the scale parts

	        ctx.clearRect(0, 0, x0 + offset$$1, elem.offsetHeight);
	        ctx.clearRect(x1 + offset$$1, 0, elem.offsetWidth, elem.offsetHeight);
	      }
	    } // animation for the right part (added item)
	    else {
	        elem.style.left = "0px";
	        if (!skipRight && offset$$1 != cellWidth) ctx.clearRect(x0 + (data.length - 1) * cellWidth - cellWidth + offset$$1, 0, elem.offsetWidth, elem.offsetHeight);
	      } // show label for the last label after finishing animation


	    if (labels.length > 1 && offset$$1 && offset$$1 != cellWidth) {
	      var last = labels.length - 1;
	      if (isAxisTitle(series, labels[last])) last -= 1;
	      labels[last].style.display = "none";
	    }
	  }

	  eachStockCanvas(chart, function (name, canvas) {
	    setCanvasOffset(canvas, bounds.start.x, bounds.end.x, name == "x");
	  });
	  setHtmlMapSizes(chart, bounds, isScroll ? offset$$1 : 0);
	}

	function isAxisTitle(series, label) {
	  return series === "axis_x" && label.className.indexOf("webix_axis_title_x") !== -1;
	}

	function setLabelsOffset(labels, offset$$1, series) {
	  if (labels.length) {
	    remove(labels[0]);

	    for (var i = 1; i < labels.length; i++) {
	      //don't move axis title
	      if (isAxisTitle(series, labels[i])) continue;
	      labels[i].style.left = labels[i].offsetLeft - offset$$1 + "px";
	    }
	  }
	}
	/**
	 * Gets visible chart data
	 * @param {object} data - an array with all chart data
	 * @param {object} point0 - a top left point of a plot
	 * @param {object} point1 - a bottom right point of a plot
	 * @param {number} cellWidth - a unit width
	 */


	function filterStockData(data, point0, point1, cellWidth) {
	  if (cellWidth && data.length) {
	    var limit = Math.ceil((point1.x - point0.x) / cellWidth);
	    if (data.length > limit + 1) data.splice(0, data.length - limit - 1);
	  }
	}
	/**
	 * Calls a function for "series" and "x-axis" canvases
	 * @param {object} chart - chart view
	 * @param {function} func - function to call
	 */


	function eachStockCanvas(chart, func) {
	  if (chart.canvases) {
	    for (var i = 0; i < chart._series.length; i++) {
	      if (chart.canvases[i]) func(i, chart.canvases[i]);
	    }

	    if (chart.canvases["x"]) func("x", chart.canvases["x"]);
	  }
	}
	/**
	 * Set sizes for animated canvases
	 * @param {object} chart - chart view
	 */


	function resizeStockCanvases(chart) {
	  eachStockCanvas(chart, function (name, canvas) {
	    canvas._resizeCanvas(chart._content_width + 2 * chart._settings.cellWidth, chart._content_height);
	  });
	}
	/**
	 * Set sizes for an html map of a chart
	 * @param {object} chart - a chart view
	 * @param {object} bounds - start and end points of a plot
	 * @param {number} offset - an offset to apply
	 */


	function setHtmlMapSizes(chart, bounds, offset$$1) {
	  chart._contentobj._htmlmap.style.left = bounds.start.x - offset$$1 + "px";
	  chart._contentobj._htmlmap.style.width = bounds.end.x - bounds.start.x + offset$$1 + "px";
	}
	/**
	 * Renders lines and labels of an x-axis
	 * @param {object} chart - a chart view
	 * @param {object} ctx - a canvas Context
	 * @param {object} data - a data array
	 * @param {object} point0 - a top left point of a plot
	 * @param {object} point1 - a bottom right point of a plot
	 * @param {number} cellWidth - a width of a unit
	 * @param {number} y - the vertical position of an "x-axis" line
	 */


	function drawXAxis(chart, ctx, data, point0, point1, cellWidth, y) {
	  var center,
	      i,
	      isScroll,
	      unitPos,
	      config = chart._settings,
	      x0 = point0.x - 0.5,
	      y0 = parseInt(y ? y : point1.y, 10) + 0.5,
	      x1 = point1.x;
	  if (!config.dynamic) return false;
	  isScroll = (data.length - 1) * cellWidth > x1 - x0 || data.length < chart.count();

	  for (i = 0; i < data.length; i++) {
	    unitPos = x0 + i * cellWidth;
	    center = isScroll ? i > 1 : !!i;
	    unitPos = Math.ceil(unitPos) - 0.5; //scale labels

	    chart._drawXAxisLabel(unitPos, y0, data[i], center); //draws a vertical line for the horizontal scale


	    if (i && config.xAxis.lines.call(chart, data[i])) chart._drawXAxisLine(ctx, unitPos, point1.y, point0.y, data[i]);
	  }

	  chart.canvases["x"].renderTextAt(true, false, x0, point1.y + config.padding.bottom - 3, config.xAxis.title, "webix_axis_title_x", point1.x - point0.x);

	  chart._drawLine(ctx, x0, y0, x1 + (isScroll ? chart._stockAnimationOffset : 0), y0, config.xAxis.color, 1);
	}

	var api$Y = {
	  name: "chart",
	  $init: function (config) {
	    this._series = [this._settings];
	    this._legend_labels = [];
	    this._contentobj.className += " webix_chart";
	    this.$ready.push(this._after_init_call);
	    /*preset*/

	    if (config.preset) {
	      this._definePreset(config);
	    } // move series to end of configuration properties hash
	    // so it will be parsed after other settings


	    if (config.series) {
	      var series = config.series;
	      delete config.series;
	      config.series = series;
	    }

	    this.data.provideApi(this, true);
	  },
	  _after_init_call: function () {
	    this.data.attachEvent("onStoreUpdated", bind(function () {
	      this.render.apply(this, arguments);
	    }, this));
	  },
	  defaults: {
	    ariaLabel: "chart",
	    color: "default",
	    alpha: "1",
	    radius: 0,
	    label: false,
	    value: "{obj.value}",
	    padding: {},
	    type: "pie",
	    lineColor: "#ffffff",
	    cant: 0.5,
	    barWidth: 30,
	    line: {
	      width: 2,
	      color: "#1ca1c1"
	    },
	    item: {
	      radius: 3,
	      borderColor: "#1ca1c1",
	      borderWidth: 2,
	      color: "#ffffff",
	      alpha: 1,
	      type: "r",
	      shadow: false
	    },
	    shadow: false,
	    gradient: false,
	    border: false,
	    labelOffset: 20,
	    origin: "auto",
	    scale: "linear"
	  },
	  _id: "webix_area_id",
	  on_click: {
	    webix_chart_legend_item: function (e, id, obj) {
	      var series = obj.getAttribute("series_id");

	      if (this.callEvent("onLegendClick", [e, series, obj])) {
	        if (typeof series != "undefined" && this._series.length > 1) {
	          var config = this._settings;
	          var values = config.legend.values;
	          var toggle = values && values[series].toggle || config.legend.toggle; // hide action

	          if (toggle) {
	            if (obj.className.indexOf("hidden") != -1) {
	              this.showSeries(series);
	            } else {
	              this.hideSeries(series);
	            }
	          }
	        }
	      }
	    }
	  },
	  on_dblclick: {},
	  on_mouse_move: {},
	  locate: function (e) {
	    return locate(e, this._id);
	  },
	  $setSize: function (x, y) {
	    var res = base.api.$setSize.call(this, x, y);

	    if (res) {
	      for (var c in this.canvases) {
	        this.canvases[c]._resizeCanvas(this._content_width, this._content_height);
	      }

	      this.render();
	    }

	    return res;
	  },
	  type_setter: function (val) {
	    assert(this["$render_" + val], "Chart type is not supported, or extension is not loaded: " + val);

	    if (typeof this._settings.offset == "undefined") {
	      this._settings.offset = !(val.toLowerCase().indexOf("area") != -1);
	    }

	    if (val == "radar" && !this._settings.yAxis) this.define("yAxis", {});

	    if (val == "scatter") {
	      if (!this._settings.yAxis) this.define("yAxis", {});
	      if (!this._settings.xAxis) this.define("xAxis", {});
	    }

	    return val;
	  },
	  destructor: function () {
	    this.removeAllSeries();
	    Destruction.destructor.apply(this, arguments);
	  },
	  removeAllSeries: function () {
	    this.clearCanvas();

	    if (this._legendObj) {
	      this._legendObj.innerHTML = "";

	      this._legendObj.parentNode.removeChild(this._legendObj);

	      this._legendObj = null;
	    }

	    if (this.canvases) {
	      this.canvases = {};
	    }

	    this._contentobj.innerHTML = "";
	    this._series = [];
	  },
	  clearCanvas: function () {
	    if (this.canvases && _typeof(this.canvases) == "object") for (var c in this.canvases) {
	      this.canvases[c].clearCanvas();
	    }
	  },
	  render: function (id, changes, type) {
	    var bounds, data, map, temp;
	    if (!this.isVisible(this._settings.id)) return;
	    data = this._getChartData();
	    if (!this.callEvent("onBeforeRender", [data, type])) return;

	    if (this.canvases && _typeof(this.canvases) == "object") {
	      for (var i in this.canvases) {
	        this.canvases[i].clearCanvas();
	      }
	    } else this.canvases = {};

	    if (this._settings.legend) {
	      if (!this.canvases["legend"]) this.canvases["legend"] = this._createCanvas("legend");

	      this._drawLegend(this.data.getRange(), this._content_width, this._content_height);
	    }

	    this._map = map = new HtmlMap(this._id);
	    temp = this._settings;
	    bounds = this._getChartBounds(this._content_width, this._content_height);

	    if (this._series) {
	      for (var _i = 0; _i < this._series.length; _i++) {
	        this._settings = this._series[_i];
	        if (!this.canvases[_i]) this.canvases[_i] = this._createCanvas(this.name + " " + _i, "z-index:" + (2 + _i), null, _i, this._settings.ariaLabel);

	        this["$render_" + this._settings.type](this.canvases[_i].getCanvas(), data, bounds.start, bounds.end, _i, map);
	      }
	    }

	    map.render(this._contentobj);
	    this._contentobj.lastChild.style.zIndex = 100;

	    this._applyBounds(this._contentobj.lastChild, bounds);

	    this.callEvent("onAfterRender", [data]);
	    this._settings = temp; // hide hidden series

	    if (this._settings.legend && this._settings.legend.values) {
	      var series = this._settings.legend.values;

	      for (var _i2 = 0; _i2 < series.length; _i2++) {
	        if (series[_i2].$hidden) this.hideSeries(_i2);
	      }
	    }
	  },
	  _applyBounds: function (elem, bounds) {
	    var style = {};
	    style.left = bounds.start.x;
	    style.top = bounds.start.y;
	    style.width = bounds.end.x - bounds.start.x;
	    style.height = bounds.end.y - bounds.start.y;

	    for (var prop in style) {
	      elem.style[prop] = style[prop] + "px";
	    }
	  },
	  _getChartData: function () {
	    var axis, axisConfig, config, data, i, newData, start, units, value, valuesHash;
	    data = this.data.getRange();
	    axis = this._settings.type.toLowerCase().indexOf("barh") != -1 ? "yAxis" : "xAxis";
	    axisConfig = this._settings[axis];

	    if (axisConfig && axisConfig.units && _typeof(axisConfig.units) == "object") {
	      config = axisConfig.units;
	      units = [];

	      if (typeof config.start != "undefined" && typeof config.end != "undefined" && typeof config.next != "undefined") {
	        start = config.start;

	        while (start <= config.end) {
	          units.push(start);
	          start = config.next.call(this, start);
	        }
	      } else if (Object.prototype.toString.call(config) === "[object Array]") {
	        units = config;
	      }

	      newData = [];

	      if (units.length) {
	        value = axisConfig.value;
	        valuesHash = {};

	        for (i = 0; i < data.length; i++) {
	          valuesHash[value(data[i])] = i;
	        }

	        for (i = 0; i < units.length; i++) {
	          if (typeof valuesHash[units[i]] != "undefined") {
	            data[valuesHash[units[i]]].$unit = units[i];
	            newData.push(data[valuesHash[units[i]]]);
	          } else {
	            newData.push({
	              $unit: units[i]
	            });
	          }
	        }
	      }

	      return newData;
	    }

	    return data;
	  },
	  series_setter: function (config) {
	    if (_typeof(config) != "object") {
	      assert(config, "Chart :: Series must be an array or object");
	    } else {
	      this._parseSettings(!config.length ? config : config[0]);

	      this._series = [this._settings];

	      for (var i = 1; i < config.length; i++) {
	        this.addSeries(config[i]);
	      }
	    }

	    return config;
	  },
	  value_setter: template,
	  xValue_setter: template,
	  yValue_setter: function (config) {
	    this.define("value", config);
	  },
	  alpha_setter: template,
	  label_setter: template,
	  lineColor_setter: template,
	  borderColor_setter: template,
	  pieInnerText_setter: template,
	  gradient_setter: function (config) {
	    if (typeof config != "function" && config && config === true) config = "light";
	    return config;
	  },
	  colormap: {
	    "RAINBOW": function (obj) {
	      var pos$$1 = Math.floor(this.getIndexById(obj.id) / this.count() * 1536);
	      if (pos$$1 == 1536) pos$$1 -= 1;
	      return this._rainbow[Math.floor(pos$$1 / 256)](pos$$1 % 256);
	    },
	    "default": function (obj) {
	      var count = this.count();
	      var colorsCount = this._defColors.length;
	      var i = this.getIndexById(obj.id);

	      if (colorsCount > count) {
	        if (i) {
	          if (i < colorsCount - count) i = this._defColorsCursor + 2;else i = this._defColorsCursor + 1;
	        }

	        this._defColorsCursor = i;
	      } else i = i % colorsCount;

	      return this._defColors[i];
	    }
	  },
	  color_setter: function (value) {
	    return this.colormap[value] || template(value);
	  },
	  fill_setter: function (value) {
	    return !value || value == "0" ? false : template(value);
	  },
	  _definePreset: function (obj) {
	    this.define("preset", obj.preset);
	    delete obj.preset;
	  },
	  preset_setter: function (value) {
	    var a, b, preset;
	    this.defaults = exports.extend({}, this.defaults);
	    preset = this.presets[value];

	    if (_typeof(preset) == "object") {
	      for (a in preset) {
	        if (_typeof(preset[a]) == "object") {
	          if (!this.defaults[a] || _typeof(this.defaults[a]) != "object") {
	            this.defaults[a] = exports.extend({}, preset[a]);
	          } else {
	            this.defaults[a] = exports.extend({}, this.defaults[a]);

	            for (b in preset[a]) {
	              this.defaults[a][b] = preset[a][b];
	            }
	          }
	        } else {
	          this.defaults[a] = preset[a];
	        }
	      }

	      return value;
	    }

	    return false;
	  },
	  legend_setter: function (config) {
	    if (!config) {
	      if (this._legendObj) {
	        this._legendObj.innerHTML = "";
	        this._legendObj = null;
	      }

	      return false;
	    }

	    if (_typeof(config) != "object") //allow to use template string instead of object
	      config = {
	        template: config
	      };

	    this._mergeSettings(config, {
	      width: 150,
	      height: 18,
	      layout: "y",
	      align: "left",
	      valign: "bottom",
	      template: "",
	      toggle: this._settings.type.toLowerCase().indexOf("stacked") != -1 ? "" : "hide",
	      marker: {
	        type: "square",
	        width: 15,
	        height: 15,
	        radius: 3
	      },
	      margin: 4,
	      padding: 3
	    });

	    config.template = template(config.template);
	    return config;
	  },
	  item_setter: function (config) {
	    if (_typeof(config) != "object") config = {
	      color: config,
	      borderColor: config
	    };

	    this._mergeSettings(config, exports.extend({}, this.defaults.item));

	    var settings = ["alpha", "borderColor", "color", "radius", "type"];

	    this._converToTemplate(settings, config);

	    return config;
	  },
	  line_setter: function (config) {
	    if (_typeof(config) != "object") config = {
	      color: config
	    };
	    config = exports.extend(config, this.defaults.line);
	    config.color = template(config.color);
	    return config;
	  },
	  padding_setter: function (config) {
	    if (_typeof(config) != "object") config = {
	      left: config,
	      right: config,
	      top: config,
	      bottom: config
	    };

	    this._mergeSettings(config, {
	      left: 50,
	      right: 20,
	      top: 35,
	      bottom: 40
	    });

	    return config;
	  },
	  xAxis_setter: function (config) {
	    if (!config) return false;
	    if (_typeof(config) != "object") config = {
	      template: config
	    };

	    this._mergeSettings(config, {
	      title: "",
	      color: "#edeff0",
	      lineColor: "#edeff0",
	      template: "{obj}",
	      lines: true
	    });

	    var templates = ["lineColor", "template", "lines"];

	    this._converToTemplate(templates, config);

	    this._configXAxis = exports.extend({}, config);
	    return config;
	  },
	  yAxis_setter: function (config) {
	    this._mergeSettings(config, {
	      title: "",
	      color: "#edeff0",
	      lineColor: "#edeff0",
	      template: "{obj}",
	      lines: true,
	      bg: "#ffffff"
	    });

	    var templates = ["lineColor", "template", "lines", "bg"];

	    this._converToTemplate(templates, config);

	    this._configYAxis = exports.extend({}, config);
	    return config;
	  },
	  _converToTemplate: function (arr, config) {
	    for (var i = 0; i < arr.length; i++) {
	      config[arr[i]] = template(config[arr[i]]);
	    }
	  },
	  _createCanvas: function (name, style, container, index$$1, title) {
	    var params = {
	      container: container || this._contentobj,
	      name: name,
	      title: isUndefined(title) ? name : title || "",
	      series: index$$1,
	      style: style || "",
	      width: this._content_width,
	      height: this._content_height
	    };
	    return new Canvas(params);
	  },
	  _drawScales: function (data, point0, point1, start, end, cellWidth) {
	    var ctx,
	        y = 0;

	    if (this._settings.yAxis) {
	      if (!this.canvases["y"]) this.canvases["y"] = this._createCanvas("axis_y");
	      y = this._drawYAxis(this.canvases["y"].getCanvas(), data, point0, point1, start, end);
	    }

	    if (this._settings.xAxis) {
	      if (!this.canvases["x"]) this.canvases["x"] = this._createCanvas("axis_x");
	      ctx = this.canvases["x"].getCanvas();
	      if (this.callEvent("onBeforeXAxis", [ctx, data, point0, point1, cellWidth, y])) this._drawXAxis(ctx, data, point0, point1, cellWidth, y);
	    }

	    return y;
	  },
	  _drawXAxis: function (ctx, data, point0, point1, cellWidth, y) {
	    var i,
	        unitPos,
	        config = this._settings,
	        x0 = point0.x - 0.5,
	        y0 = parseInt(y ? y : point1.y, 10) + 0.5,
	        x1 = point1.x,
	        center = true,
	        labelY = config.type == "stackedBar" ? point1.y + 0.5 : y0;

	    for (i = 0; i < data.length; i++) {
	      if (config.offset === true) unitPos = x0 + cellWidth / 2 + i * cellWidth;else {
	        unitPos = i == data.length - 1 && !config.cellWidth ? point1.x : x0 + i * cellWidth;
	        center = !!i;
	      }
	      unitPos = Math.ceil(unitPos) - 0.5;
	      /*scale labels*/

	      var top = config.origin != "auto" && config.type == "bar" && parseFloat(config.value(data[i])) < config.origin;

	      this._drawXAxisLabel(unitPos, labelY, data[i], center, top);
	      /*draws a vertical line for the horizontal scale*/


	      if ((config.offset || i || config.cellWidth) && config.xAxis.lines.call(this, data[i])) this._drawXAxisLine(ctx, unitPos, point1.y, point0.y, data[i]);
	    }

	    this.canvases["x"].renderTextAt(true, false, x0, point1.y + config.padding.bottom - 3, config.xAxis.title, "webix_axis_title_x", point1.x - point0.x);

	    this._drawLine(ctx, x0, y0, x1, y0, config.xAxis.color, 1);
	    /*the right border in lines in scale are enabled*/


	    if (!config.xAxis.lines.call(this, {}) || !config.offset) return;

	    this._drawLine(ctx, x1 + 0.5, point1.y, x1 + 0.5, point0.y + 0.5, config.xAxis.lineColor.call(this, {}), 1);
	  },
	  _drawYAxis: function (ctx, data, point0, point1, start, end) {
	    var step;
	    var scaleParam = {};
	    if (!this._settings.yAxis) return;
	    var x0 = point0.x - 0.5;
	    var y0 = point1.y;
	    var y1 = point0.y;
	    var lineX = point1.y + 0.5; //this._drawLine(ctx,x0,y0,x0,y1,this._settings.yAxis.color,1);

	    if (this._settings.yAxis.step) step = parseFloat(this._settings.yAxis.step);

	    if (typeof this._configYAxis.step == "undefined" || typeof this._configYAxis.start == "undefined" || typeof this._configYAxis.end == "undefined") {
	      scaleParam = this._calculateScale(start, end);
	      start = scaleParam.start;
	      end = scaleParam.end;
	      step = scaleParam.step;
	      this._settings.yAxis.end = end;
	      this._settings.yAxis.start = start;
	    } else if (this.config.scale == "logarithmic") this._logScaleCalc = true;

	    this._setYAxisTitle(point0, point1);

	    if (step === 0) return;

	    if (end == start) {
	      return y0;
	    }

	    var stepHeight = (y0 - y1) * step / (end - start);
	    var c = 0;

	    for (var i = start; i <= end; i += step) {
	      var value = this._logScaleCalc ? Math.pow(10, i) : i;
	      if (scaleParam.fixNum) value = parseFloat(value).toFixed(scaleParam.fixNum);
	      var yi = Math.floor(y0 - c * stepHeight) + 0.5;
	      /*canvas line fix*/

	      if (!(i == start && this._settings.origin == "auto") && this._settings.yAxis.lines.call(this, i)) this._drawLine(ctx, x0, yi, point1.x, yi, this._settings.yAxis.lineColor.call(this, i), 1);
	      if (i == this._settings.origin) lineX = yi;
	      /*correction for JS float calculation*/

	      if (step < 1 && !this._logScaleCalc) {
	        var power = Math.min(Math.floor(this._log10(step)), start <= 0 ? 0 : Math.floor(this._log10(start)));
	        var corr = Math.pow(10, -power);
	        value = Math.round(value * corr) / corr;
	        i = value;
	      }

	      this.canvases["y"].renderText(0, yi - 5, this._settings.yAxis.template(value.toString()), "webix_axis_item_y", point0.x - 5);
	      c++;
	    }

	    this._drawLine(ctx, x0, y0 + 1, x0, y1, this._settings.yAxis.color, 1);

	    return lineX;
	  },
	  _setYAxisTitle: function (point0, point1) {
	    var className = "webix_axis_title_y";
	    var text = this.canvases["y"].renderTextAt("middle", false, 0, parseInt((point1.y - point0.y) / 2 + point0.y, 10), this._settings.yAxis.title, className);
	    if (text) text.style.left = (env.transform ? (text.offsetHeight - text.offsetWidth) / 2 : 0) + "px";
	  },
	  _calculateLogScale: function (nmin, nmax) {
	    var startPower = Math.floor(this._log10(nmin));
	    var endPower = Math.ceil(this._log10(nmax));
	    return {
	      start: startPower,
	      step: 1,
	      end: endPower
	    };
	  },
	  _normStep: function (step) {
	    var power = Math.floor(this._log10(step));
	    var calculStep = Math.pow(10, power);
	    var stepVal = step / calculStep;
	    stepVal = stepVal > 5 ? 10 : 5;
	    return parseInt(stepVal, 10) * calculStep;
	  },
	  _calculateScale: function (nmin, nmax) {
	    this._logScaleCalc = false;

	    if (this._settings.scale == "logarithmic") {
	      var logMin = Math.floor(this._log10(nmin));
	      var logMax = Math.ceil(this._log10(nmax));

	      if (nmin > 0 && nmax > 0 && logMax - logMin > 1) {
	        this._logScaleCalc = true;
	        return this._calculateLogScale(nmin, nmax);
	      }
	    }

	    if (this._settings.origin != "auto" && this._settings.origin < nmin) nmin = this._settings.origin;
	    var step, start, end;
	    step = this._normStep((nmax - nmin) / 8 || 1);
	    if (step > Math.abs(nmin)) start = nmin < 0 ? -step : 0;else {
	      var absNmin = Math.abs(nmin);
	      var powerStart = Math.floor(this._log10(absNmin));
	      var nminVal = absNmin / Math.pow(10, powerStart);
	      start = Math.ceil(nminVal * 10) / 10 * Math.pow(10, powerStart) - step;

	      if (absNmin > 1 && step > 0.1) {
	        start = Math.ceil(start);
	      }

	      while (nmin < 0 ? start <= nmin : start >= nmin) {
	        start -= step;
	      }

	      if (nmin < 0) start = -start - 2 * step;
	    }
	    if (nmax - start > 10) step = this._normStep((nmax - start) / 8 || 1);
	    end = start;
	    var power = Math.floor(this._log10(step));

	    while (end < nmax) {
	      end += step;
	      end = parseFloat((end * 1.0).toFixed(Math.abs(power)));
	    }

	    return {
	      start: start,
	      end: end,
	      step: step,
	      fixNum: power < 0 ? Math.abs(power) : 0
	    };
	  },
	  _getLimits: function (orientation, value) {
	    var data = this.data._obj_array();

	    var maxValue, minValue;
	    var axis = arguments.length && orientation == "h" ? this._configXAxis : this._configYAxis;
	    value = value || "value";

	    if (axis && typeof axis.end != "undefined" && typeof axis.start != "undefined" && axis.step) {
	      maxValue = parseFloat(axis.end);
	      minValue = parseFloat(axis.start);
	    } else {
	      maxValue = GroupMethods.max(this._series[0][value], data);
	      minValue = axis && typeof axis.start != "undefined" ? parseFloat(axis.start) : GroupMethods.min(this._series[0][value], data);
	      if (this._series.length > 1) for (var i = 1; i < this._series.length; i++) {
	        var maxI = GroupMethods.max(this._series[i][value], data);
	        var minI = GroupMethods.min(this._series[i][value], data);
	        if (maxI > maxValue) maxValue = maxI;
	        if (minI < minValue) minValue = minI;
	      }
	    }

	    return {
	      max: maxValue,
	      min: minValue
	    };
	  },
	  _log10: function (n) {
	    var method_name = "log";
	    return Math[method_name](n) / Math.LN10;
	  },
	  _drawXAxisLabel: function (x, y, obj, center, top) {
	    if (!this._settings.xAxis) return;
	    var elem = this.canvases["x"].renderTextAt(top, center, x, y - (top ? 2 : 0), this._settings.xAxis.template(obj));
	    if (elem) elem.className += " webix_axis_item_x";
	  },
	  _drawXAxisLine: function (ctx, x, y1, y2, obj) {
	    if (!this._settings.xAxis || !this._settings.xAxis.lines) return;

	    this._drawLine(ctx, x, y1, x, y2, this._settings.xAxis.lineColor.call(this, obj), 1);
	  },
	  _drawLine: function (ctx, x1, y1, x2, y2, color$$1, width) {
	    ctx.strokeStyle = color$$1;
	    ctx.lineWidth = width;
	    ctx.beginPath();
	    ctx.moveTo(x1, y1);
	    ctx.lineTo(x2, y2);
	    ctx.stroke();
	    ctx.lineWidth = 1;
	  },
	  _getRelativeValue: function (minValue, maxValue) {
	    var relValue;
	    var valueFactor = 1;

	    if (maxValue != minValue) {
	      relValue = maxValue - minValue;
	    } else relValue = minValue;

	    return [relValue, valueFactor];
	  },
	  _rainbow: [function (pos$$1) {
	    return "#FF" + color.toHex(pos$$1 / 2, 2) + "00";
	  }, function (pos$$1) {
	    return "#FF" + color.toHex(pos$$1 / 2 + 128, 2) + "00";
	  }, function (pos$$1) {
	    return "#" + color.toHex(255 - pos$$1, 2) + "FF00";
	  }, function (pos$$1) {
	    return "#00FF" + color.toHex(pos$$1, 2);
	  }, function (pos$$1) {
	    return "#00" + color.toHex(255 - pos$$1, 2) + "FF";
	  }, function (pos$$1) {
	    return "#" + color.toHex(pos$$1, 2) + "00FF";
	  }],
	  _defColors: ["#f55b50", "#ff6d3f", "#ffa521", "#ffc927", "#ffee54", "#d3e153", "#9acb61", "#63b967", "#21a497", "#21c5da", "#3ea4f5", "#5868bf", "#7b53c0", "#a943ba", "#ec3b77", "#9eb0b8"],
	  _defColorsCursor: 0,

	  /**
	  *   adds series to the chart (value and color properties)
	  *   @param: obj - obj with configuration properties
	  */
	  addSeries: function (obj) {
	    var temp = exports.extend({}, this._settings);
	    this._settings = exports.extend({}, temp);

	    this._parseSettings(obj, {});

	    this._series.push(this._settings);

	    this._settings = temp;
	  },
	  _getActiveSeries: function (e) {
	    var a, areas, i, offset$$1, pos$$1, selection, x, y;
	    areas = this._map._areas;
	    offset$$1 = offset(this._contentobj._htmlmap);
	    pos$$1 = pos(e);
	    x = pos$$1.x - offset$$1.x;
	    y = pos$$1.y - offset$$1.y;

	    for (i = 0; i < areas.length; i++) {
	      a = areas[i].points;

	      if (x <= a[2] && x >= a[0] && y <= a[3] && y >= a[1]) {
	        if (selection) {
	          if (areas[i].index > selection.index) selection = areas[i];
	        } else selection = areas[i];
	      }
	    }

	    return selection ? selection.index : 0;
	  },
	  hideSeries: function (series) {
	    this.canvases[series].hideCanvas();
	    var legend = this._settings.legend;

	    if (legend && legend.values && legend.values[series]) {
	      legend.values[series].$hidden = true;

	      this._drawLegend();
	    }

	    this._map.hide(this._contentobj, series, true);
	  },
	  showSeries: function (series) {
	    this.canvases[series].showCanvas();
	    var legend = this._settings.legend;

	    if (legend && legend.values && legend.values[series]) {
	      delete legend.values[series].$hidden;

	      this._drawLegend();
	    }

	    this._map.hide(this._contentobj, series, false);
	  },

	  /**
	  *   renders legend block
	  *   @param: ctx - canvas object
	  *   @param: data - object those need to be displayed
	  *   @param: width - the width of the container
	  *   @param: height - the height of the container
	  */
	  _drawLegend: function (data, width) {
	    /*position of the legend block*/
	    var i,
	        legend,
	        legendContainer,
	        legendHeight,
	        legendItems,
	        legendWidth,
	        style,
	        x = 0,
	        y = 0,
	        ctx,
	        itemColor,
	        disabled,
	        item;
	    data = data || [];
	    width = width || this._content_width;
	    ctx = this.canvases["legend"].getCanvas();
	    /*legend config*/

	    legend = this._settings.legend;
	    /*the legend sizes*/

	    style = this._settings.legend.layout != "x" ? "width:" + legend.width + "px" : "";
	    /*creation of legend container*/

	    if (this._legendObj) {
	      this._legendObj.innerHTML = "";

	      this._legendObj.parentNode.removeChild(this._legendObj);
	    }

	    this.canvases["legend"].clearCanvas(true);
	    legendContainer = create("DIV", {
	      "class": "webix_chart_legend",
	      "style": "left:" + x + "px; top:" + y + "px;" + style
	    }, "");

	    if (legend.padding) {
	      legendContainer.style.padding = legend.padding + "px";
	    }

	    this._legendObj = legendContainer;

	    this._contentobj.appendChild(legendContainer);
	    /*rendering legend text items*/


	    legendItems = [];
	    if (!legend.values) for (i = 0; i < data.length; i++) {
	      legendItems.push(this._drawLegendText(legendContainer, legend.template(data[i]), data[i].id));
	    } else for (i = 0; i < legend.values.length; i++) {
	      legendItems.push(this._drawLegendText(legendContainer, legend.values[i].text, typeof legend.values[i].id != "undefined" ? _typeof(legend.values[i].id) : i, legend.values[i].$hidden));
	    }
	    if (legendContainer.offsetWidth === 0) legendContainer.style.width = "auto";
	    legendWidth = legendContainer.offsetWidth;
	    legendHeight = legendContainer.offsetHeight;
	    /*this._settings.legend.width = legendWidth;
	    this._settings.legend.height = legendHeight;*/

	    /*setting legend position*/

	    if (legendWidth < width) {
	      if (legend.layout == "x" && legend.align == "center") {
	        x = (width - legendWidth) / 2;
	      }

	      if (legend.align == "right") {
	        x = width - legendWidth;
	      }

	      if (legend.margin && legend.align != "center") {
	        x += (legend.align == "left" ? 1 : -1) * legend.margin;
	      }
	    }

	    if (legendHeight < this._content_height) {
	      if (legend.valign == "middle" && legend.align != "center" && legend.layout != "x") y = (this._content_height - legendHeight) / 2;else if (legend.valign == "bottom") y = this._content_height - legendHeight;

	      if (legend.margin && legend.valign != "middle") {
	        y += (legend.valign == "top" ? 1 : -1) * legend.margin;
	      }
	    }

	    legendContainer.style.left = x + "px";
	    legendContainer.style.top = y + "px";
	    /*drawing colorful markers*/

	    ctx.save();

	    for (i = 0; i < legendItems.length; i++) {
	      item = legendItems[i];

	      if (legend.values && legend.values[i].$hidden) {
	        disabled = true;
	        itemColor = legend.values[i].disableColor ? legend.values[i].disableColor : "#edeff0";
	      } else {
	        disabled = false;
	        itemColor = legend.values ? legend.values[i].color : this._settings.color.call(this, data[i]);
	      }

	      this._drawLegendMarker(ctx, item.offsetLeft + x, item.offsetTop + y, itemColor, item.offsetHeight, disabled, i);
	    }

	    ctx.restore();
	    legendItems = null;
	  },

	  /**
	  *   appends legend item to legend block
	  *   @param: ctx - canvas object
	  *   @param: obj - data object that needs being represented
	  */
	  _drawLegendText: function (cont, value, series, disabled) {
	    var style = "";
	    if (this._settings.legend.layout == "x") style = "float:left;";
	    /*the text of the legend item*/

	    var text = create("DIV", {
	      "style": style + "padding-left:" + (10 + this._settings.legend.marker.width) + "px",
	      "class": "webix_chart_legend_item" + (disabled ? " hidden" : ""),
	      "role": "button",
	      "tabindex": "0",
	      "aria-label": i18n.aria[(disabled ? "show" : "hide") + "Chart"] + " " + value
	    }, value);
	    if (arguments.length > 2) text.setAttribute("series_id", series);
	    cont.appendChild(text);
	    return text;
	  },

	  /**
	  *   draw legend colorful marder
	  *   @param: ctx - canvas object
	  *   @param: x - the horizontal position of the marker
	  *   @param: y - the vertical position of the marker
	  *   @param: obj - data object which color needs being used
	  */
	  _drawLegendMarker: function (ctx, x, y, color$$1, height, disabled, i) {
	    var p = [];
	    var marker = this._settings.legend.marker;
	    var values = this._settings.legend.values;
	    var type = values && values[i].markerType ? values[i].markerType : marker.type;

	    if (color$$1) {
	      ctx.strokeStyle = ctx.fillStyle = color$$1;
	    }

	    if (type == "round" || !marker.radius) {
	      ctx.beginPath();
	      ctx.lineWidth = marker.height;
	      ctx.lineCap = marker.type;
	      /*start of marker*/

	      x += ctx.lineWidth / 2 + 5;
	      y += height / 2;
	      ctx.moveTo(x, y);
	      var x1 = x + marker.width - marker.height + 1;
	      ctx.lineTo(x1, y);
	      ctx.stroke();
	      ctx.fill();
	    } else if (type == "item") {
	      /*copy of line*/
	      if (this._settings.line && this._settings.type != "scatter" && !this._settings.disableLines) {
	        ctx.beginPath();
	        ctx.lineWidth = this._series[i].line.width;
	        ctx.strokeStyle = disabled ? color$$1 : this._series[i].line.color.call(this, {});
	        var x0 = x + 5;
	        var y0 = y + height / 2;
	        ctx.moveTo(x0, y0);

	        var _x = x0 + marker.width;

	        ctx.lineTo(_x, y0);
	        ctx.stroke();
	      }
	      /*item copy*/


	      var config = this._series[i].item;
	      var radius = parseInt(config.radius.call(this, {}), 10) || 0;
	      var markerType = config.type.call(this, {});

	      if (radius) {
	        ctx.beginPath();

	        if (disabled) {
	          ctx.lineWidth = config.borderWidth;
	          ctx.strokeStyle = color$$1;
	          ctx.fillStyle = color$$1;
	        } else {
	          ctx.lineWidth = config.borderWidth;
	          ctx.fillStyle = config.color.call(this, {});
	          ctx.strokeStyle = config.borderColor.call(this, {});
	          ctx.globalAlpha = config.alpha.call(this, {});
	        }

	        ctx.beginPath();
	        x += marker.width / 2 + 5;
	        y += height / 2;

	        this._strokeChartItem(ctx, x, y, radius + 1, markerType);

	        ctx.fill();
	        ctx.stroke();
	      }

	      ctx.globalAlpha = 1;
	    } else {
	      ctx.beginPath();
	      ctx.lineWidth = 1;
	      x += 5;
	      y += height / 2 - marker.height / 2;
	      p = [[x + marker.radius, y + marker.radius, marker.radius, Math.PI, 3 * Math.PI / 2, false], [x + marker.width - marker.radius, y], [x + marker.width - marker.radius, y + marker.radius, marker.radius, -Math.PI / 2, 0, false], [x + marker.width, y + marker.height - marker.radius], [x + marker.width - marker.radius, y + marker.height - marker.radius, marker.radius, 0, Math.PI / 2, false], [x + marker.radius, y + marker.height], [x + marker.radius, y + marker.height - marker.radius, marker.radius, Math.PI / 2, Math.PI, false], [x, y + marker.radius]];

	      this._path(ctx, p);

	      ctx.stroke();
	      ctx.fill();
	    }
	  },

	  /**
	  *   gets the points those represent chart left top and right bottom bounds
	  *   @param: width - the width of the chart container
	  *   @param: height - the height of the chart container
	  */
	  _getChartBounds: function (width, height) {
	    var chartX0, chartY0, chartX1, chartY1;
	    chartX0 = this._settings.padding.left;
	    chartY0 = this._settings.padding.top;
	    chartX1 = width - this._settings.padding.right;
	    chartY1 = height - this._settings.padding.bottom;

	    if (this._settings.legend) {
	      var legend = this._settings.legend;
	      /*legend size*/

	      var legendWidth = this._settings.legend.width;
	      var legendHeight = this._settings.legend.height;
	      /*if legend is horizontal*/

	      if (legend.layout == "x") {
	        if (legend.valign == "center") {
	          if (legend.align == "right") chartX1 -= legendWidth;else if (legend.align == "left") chartX0 += legendWidth;
	        } else if (legend.valign == "bottom") {
	          chartY1 -= legendHeight;
	        } else {
	          chartY0 += legendHeight;
	        }
	      }
	      /*vertical scale*/
	      else {
	          if (legend.align == "right") chartX1 -= legendWidth;else if (legend.align == "left") chartX0 += legendWidth;
	        }
	    }

	    return {
	      start: {
	        x: chartX0,
	        y: chartY0
	      },
	      end: {
	        x: chartX1,
	        y: chartY1
	      }
	    };
	  },

	  /**
	  *   gets the maximum and minimum values for the stacked chart
	  *   @param: data - data set
	  */
	  _getStackedLimits: function (data) {
	    var i, j, maxValue, minValue, value;

	    if (this._settings.yAxis && typeof this._settings.yAxis.end != "undefined" && typeof this._settings.yAxis.start != "undefined" && this._settings.yAxis.step) {
	      maxValue = parseFloat(this._settings.yAxis.end);
	      minValue = parseFloat(this._settings.yAxis.start);
	    } else {
	      for (i = 0; i < data.length; i++) {
	        data[i].$sum = 0;
	        data[i].$min = Infinity;

	        for (j = 0; j < this._series.length; j++) {
	          value = Math.abs(parseFloat(this._series[j].value(data[i]) || 0));
	          if (isNaN(value)) continue;
	          if (this._series[j].type.toLowerCase().indexOf("stacked") != -1) data[i].$sum += value;
	          if (value < data[i].$min) data[i].$min = value;
	        }
	      }

	      maxValue = -Infinity;
	      minValue = Infinity;

	      for (i = 0; i < data.length; i++) {
	        if (data[i].$sum > maxValue) maxValue = data[i].$sum;
	        if (data[i].$min < minValue) minValue = data[i].$min;
	      }

	      if (minValue > 0) minValue = 0;
	    }

	    return {
	      max: maxValue,
	      min: minValue
	    };
	  },

	  /*adds colors to the gradient object*/
	  _setBarGradient: function (ctx, x1, y1, x2, y2, type, rawColor, axis) {
	    var gradient, offset$$1, rgb, hsv, rawColor0, stops;

	    if (type == "light") {
	      if (axis == "x") gradient = ctx.createLinearGradient(x1, y1, x2, y1);else gradient = ctx.createLinearGradient(x1, y1, x1, y2);
	      stops = [[0, "#FFFFFF"], [0.9, rawColor], [1, rawColor]];
	      offset$$1 = 2;
	    } else if (type == "falling" || type == "rising") {
	      if (axis == "x") gradient = ctx.createLinearGradient(x1, y1, x2, y1);else gradient = ctx.createLinearGradient(x1, y1, x1, y2);
	      rgb = color.toRgb(rawColor);
	      hsv = color.rgbToHsv(rgb[0], rgb[1], rgb[2]);
	      hsv[1] *= 1 / 2;
	      rawColor0 = "rgb(" + color.hsvToRgb(hsv[0], hsv[1], hsv[2]) + ")";

	      if (type == "falling") {
	        stops = [[0, rawColor0], [0.7, rawColor], [1, rawColor]];
	      } else if (type == "rising") {
	        stops = [[0, rawColor], [0.3, rawColor], [1, rawColor0]];
	      }

	      offset$$1 = 0;
	    } else {
	      ctx.globalAlpha = 0.37;
	      offset$$1 = 0;
	      if (axis == "x") gradient = ctx.createLinearGradient(x1, y2, x1, y1);else gradient = ctx.createLinearGradient(x1, y1, x2, y1);
	      stops = [[0, "#9d9d9d"], [0.3, "#e8e8e8"], [0.45, "#ffffff"], [0.55, "#ffffff"], [0.7, "#e8e8e8"], [1, "#9d9d9d"]];
	    }

	    this._gradient(gradient, stops);

	    return {
	      gradient: gradient,
	      offset: offset$$1
	    };
	  },

	  /**
	  *   returns the x and y position
	  *   @param: a - angle
	  *   @param: x - start x position
	  *   @param: y - start y position
	  *   @param: r - destination to the point
	  */
	  _getPositionByAngle: function (a, x, y, r) {
	    a *= -1;
	    x = x + Math.cos(a) * r;
	    y = y - Math.sin(a) * r;
	    return {
	      x: x,
	      y: y
	    };
	  },
	  _gradient: function (gradient, stops) {
	    for (var i = 0; i < stops.length; i++) {
	      gradient.addColorStop(stops[i][0], stops[i][1]);
	    }
	  },
	  _path: function (ctx, points) {
	    var i, method;

	    for (i = 0; i < points.length; i++) {
	      method = i ? "lineTo" : "moveTo";
	      if (points[i].length > 2) method = "arc";
	      ctx[method].apply(ctx, points[i]);
	    }
	  },
	  _addMapRect: function (map, id, points, bounds, sIndex) {
	    map.addRect(id, [points[0].x - bounds.x, points[0].y - bounds.y, points[1].x - bounds.x, points[1].y - bounds.y], sIndex);
	  }
	};
	var view$Y = exports.protoUI(api$Y, Pie$1, BarChart, LineChart, BarHChart, StackedBarChart, StackedBarHChart, Spline$1, AreaChart, Radar, Scatter, Presets, SplineArea$1, DynamicChart, Group, AutoTooltip, DataLoader, MouseEvents, EventSystem, base.view);

	exports.protoUI({
	  name: "rangechart",
	  defaults: {
	    template: "GPL version doesn't support rangechart <br> You need Webix PRO"
	  }
	}, template$1.view);

	var api$Z = {
	  name: "grouplist",
	  defaults: {
	    animate: {}
	  },
	  _listClassName: "webix_grouplist",
	  $init: function () {
	    exports.extend(this.data, TreeStore, true); //needed for getRange

	    this.data.count = function () {
	      return this.order.length;
	    };

	    this.data.provideApi(this, true);
	    this.data.attachEvent("onClearAll", bind(this._onClear, this));

	    this._onClear();
	  },
	  _onClear: function () {
	    this._nested_cursor = [];
	    this._nested_chain = [];
	  },
	  $setSize: function () {
	    if (base.api.$setSize.apply(this, arguments)) {
	      //critical for animations in group list
	      this._dataobj.style.width = this._content_width;
	    }
	  },
	  on_click: {
	    webix_list_item: function (e, id) {
	      if (this._in_animation) {
	        return false;
	      }

	      for (var i = 0; i < this._nested_chain.length; i++) {
	        if (this._nested_chain[i] == id) {
	          //one level up
	          for (var j = i; j < this._nested_chain.length; j++) {
	            this.data.getItem(this._nested_chain[j]).$template = "";
	          }

	          if (!i) {
	            //top level
	            this._nested_cursor = this.data.branch[0];
	            this._nested_chain = [];
	          } else {
	            this._nested_cursor = this.data.branch[this._nested_chain[i - 1]];

	            this._nested_chain.splice(i);
	          }

	          this._is_level_down = false;
	          return this.render();
	        }
	      }

	      var obj = this.getItem(id);

	      if (obj.$count) {
	        //one level down
	        this._is_level_down = true;

	        this._nested_chain.push(id);

	        obj.$template = "Back";
	        this._nested_cursor = this.data.branch[obj.id];
	        return this.render();
	      } else {
	        if (this._settings.select) {
	          this._no_animation = true;
	          if (this._settings.select == "multiselect" || this._settings.multiselect) this.select(id, false, this._settings.multiselect == "touch" || e.ctrlKey || e.metaKey, e.shiftKey); //multiselection
	          else this.select(id);
	          this._no_animation = false;
	        }
	      }
	    }
	  },
	  getOpenState: function () {
	    return {
	      parents: this._nested_chain,
	      branch: this._nested_cursor
	    };
	  },
	  render: function () {
	    var i, lastChain; //start filtering processing=>

	    this._nested_chain = copy(this._nested_chain);
	    this._nested_cursor = copy(this._nested_cursor);

	    if (this._nested_chain.length) {
	      for (i = 0; i < this._nested_chain.length; i++) {
	        if (!this.data.branch[this._nested_chain[i]]) {
	          this._nested_chain.splice(i, 1);

	          i--;
	        }
	      }
	    }

	    lastChain = this._nested_chain.length ? this._nested_chain[this._nested_chain.length - 1] : 0;
	    this._nested_cursor = copy(this.data.branch[lastChain]);

	    if (!this._nested_cursor.length && this._nested_chain.length) {
	      this._nested_cursor = [lastChain];

	      this._nested_chain.pop();
	    } //<= end filtering processing


	    if (this._in_animation) {
	      return delay(this.render, this, arguments, 100);
	    }

	    for (i = 0; i < this._nested_cursor.length; i++) {
	      this.data.getItem(this._nested_cursor[i]).$template = "";
	    }

	    if (!this._nested_cursor.length) this._nested_cursor = this.data.branch[0];
	    this.data.order = toArray([].concat(this._nested_chain).concat(this._nested_cursor));

	    if (this.callEvent("onBeforeRender", [this.data])) {
	      if (this._no_animation || !this._dataobj.innerHTML || !(animate.isSupported() && this._settings.animate) || this._prev_nested_chain_length == this._nested_chain.length) {
	        // if dataobj is empty or animation is not supported
	        RenderStack.render.apply(this, arguments);
	      } else {
	        //getRange - returns all elements
	        if (this.callEvent("onBeforeRender", [this.data])) {
	          if (!this._back_scroll_states) this._back_scroll_states = [];

	          var next_div = this._dataobj.cloneNode(false);

	          next_div.innerHTML = this.data.getRange().map(this._toHTML, this).join("");
	          var aniset = exports.extend({}, this._settings.animate);
	          aniset.direction = this._is_level_down ? "left" : "right";
	          /*scroll position restore*/

	          var animArr = [clone(aniset), clone(aniset)];

	          if (this._is_level_down) {
	            this._back_scroll_states.push(this.getScrollState());

	            if (Touch && Touch.$active) {
	              animArr[0].y = 0;
	              animArr[1].y = -this.getScrollState().y;
	            }
	          } else {
	            var getScrollState = this._back_scroll_states.pop();

	            if (Touch && Touch.$active) {
	              animArr[0].y = -getScrollState.y;
	              animArr[1].y = -this.getScrollState().y;
	            }
	          }

	          var line = animate.formLine(next_div, this._dataobj, aniset);
	          /*keeping scroll position*/

	          if (Touch && Touch.$active) Touch._set_matrix(next_div, 0, this._is_level_down ? 0 : animArr[0].y, "0ms");
	          aniset.master = this;

	          aniset.callback = function () {
	            this._dataobj = next_div;
	            /*scroll position restore*/

	            if (!this._is_level_down) {
	              if (Touch && Touch.$active) {
	                delay(function () {
	                  Touch._set_matrix(next_div, 0, animArr[0].y, "0ms");
	                }, this);
	              } else if (getScrollState) this.scrollTo(0, getScrollState.y);
	            } else if (!(Touch && Touch.$active)) {
	              this.scrollTo(0, 0);
	            }

	            animate.breakLine(line);
	            aniset.master = aniset.callback = null;
	            this._htmlmap = null; //clear map, it will be filled at first getItemNode

	            this._in_animation = false;
	            this.callEvent("onAfterRender", []);
	          };

	          this._in_animation = true;
	          animate(line, animArr);
	        }
	      }

	      this._prev_nested_chain_length = this._nested_chain.length;
	    }
	  },
	  templateBack_setter: function (config) {
	    this.type.templateBack = template(config);
	  },
	  templateItem_setter: function (config) {
	    this.type.templateItem = template(config);
	  },
	  templateGroup_setter: function (config) {
	    this.type.templateGroup = template(config);
	  },
	  type: {
	    template: function (obj, common) {
	      if (obj.$count) return common.templateGroup(obj, common);
	      return common.templateItem(obj, common);
	    },
	    css: "group",
	    classname: function (obj, common, marks) {
	      return "webix_list_item" + " webix_" + (obj.$count ? "group" : "item") + (obj.$template ? "_back" : "") + (marks && marks.webix_selected ? " webix_selected" : "") + (common.css ? " " + common.css : "") + (obj.$css ? " " + obj.$css : "");
	    },
	    templateStart: template("<div webix_l_id=\"#id#\" class=\"{common.classname()}\" style=\"width:{common.widthSize()}; height:{common.heightSize()};  overflow:hidden;\" {common.aria()}>"),
	    templateBack: template("#value#"),
	    templateItem: template("#value#"),
	    templateGroup: template("#value#"),
	    templateEnd: function (obj) {
	      var html = "";
	      if (obj.$count) html += "<div class='webix_arrow_icon'></div>";
	      html += "</div>";
	      return html;
	    }
	  },
	  showItem: function (id) {
	    var obj, parent;

	    if (id) {
	      obj = this.getItem(id);
	      parent = obj.$parent;
	      if (obj.$count) parent = obj.id;
	    }

	    this._nested_cursor = this.data.branch[parent || 0];
	    this._nested_chain = []; //build _nested_chain

	    while (parent) {
	      this.getItem(parent).$template = "Back";

	      this._nested_chain.unshift(parent);

	      parent = this.getItem(parent).$parent;
	    } //render


	    this._no_animation = true;
	    this.render();
	    this._no_animation = false; //scroll if necessary

	    RenderStack.showItem.call(this, id);
	  }
	};
	var view$Z = exports.protoUI(api$Z, Group, list.view);

	type(view$Z, {});

	var api$_ = {
	  name: "unitlist",
	  _id: "webix_item_id",
	  uniteBy_setter: template,
	  render: function (id, data, type) {
	    var config = this._settings;
	    if (!this.isVisible(config.id)) return;
	    if (!config.uniteBy) return;

	    if (id) {
	      var cont = this.getItemNode(id); //get html element of updated item

	      if (cont && type == "update" && this._settings.uniteBy.call(this, data) == this.getItem(id).$unitValue) {
	        var t = this._htmlmap[id] = this._toHTMLObject(data);

	        insertBefore(t, cont);
	        remove(cont);
	        return;
	      }
	    } //full reset


	    if (this.callEvent("onBeforeRender", [this.data])) {
	      this.units = null;

	      this._setUnits();

	      if (this.units) {
	        this._dataobj.innerHTML = this._getUnitRange().map(this._toHTML, this).join("");
	        this._htmlmap = null;
	      }

	      this.callEvent("onAfterRender", []);
	    }
	  },
	  getUnits: function () {
	    var result = [];

	    if (this.units) {
	      for (var b in this.units) {
	        result.push(b);
	      }
	    }

	    return result;
	  },
	  getUnitList: function (id) {
	    return this.units ? this.units[id] : null;
	  },
	  _toHTML: function (obj) {
	    //check if related template exist
	    var mark = this.data._marks[obj.id];
	    assert(!obj.$template || this.type["template" + obj.$template], "RenderStack :: Unknown template: " + obj.$template);
	    this.callEvent("onItemRender", [obj]);

	    if (obj.$unit) {
	      return this.type.templateStartHeader(obj, this.type) + this.type.templateHeader.call(this, obj.$unit) + this.type.templateEnd(obj, this.type);
	    }

	    return this.type.templateStart(obj, this.type, mark) + (obj.$template ? this.type["template" + obj.$template] : this.type.template)(obj, this.type) + this.type.templateEnd(obj, this.type);
	  },
	  _getUnitRange: function () {
	    var data, i, u, unit;
	    data = [];
	    var min = this.data.$min || 0;
	    var max = this.data.$max || Infinity;
	    var count = 0;

	    for (u in this.units) {
	      data.push({
	        $unit: u
	      });
	      unit = this.units[u];

	      for (i = 0; i < unit.length; i++) {
	        if (count == min) data = [{
	          $unit: u
	        }];
	        data.push(this.getItem(unit[i]));
	        if (count == max) return toArray(data);
	        count++;
	      }
	    }

	    return toArray(data);
	  },
	  _setUnits: function () {
	    var list$$1 = this;
	    this.units = {};
	    this.data.each(function (obj) {
	      var result = list$$1._settings.uniteBy.call(this, obj);

	      obj.$unitValue = result;
	      if (!list$$1.units[result]) list$$1.units[result] = [];
	      list$$1.units[result].push(obj.id);
	    });
	  },
	  type: {
	    headerHeight: 20,
	    templateHeader: function (value) {
	      return "<span class='webix_unit_header_inner'>" + value + "</span>";
	    },
	    templateStart: function (obj, type, marks) {
	      if (obj.$unit) return type.templateStartHeader.apply(this, arguments);
	      var className = "webix_list_item webix_list_" + type.css + "_item" + (marks && marks.webix_selected ? " webix_selected" : "") + (obj.$css ? obj.$css : "");
	      var style = "width:" + type.widthSize(obj, type, marks) + "; height:" + type.heightSize(obj, type, marks) + "; overflow:hidden;" + (type.layout && type.layout == "x" ? "float:left;" : "");
	      return "<div webix_item_id=\"" + obj.id + "\" class=\"" + className + "\" style=\"" + style + "\" " + type.aria(obj, type, marks) + ">";
	    },
	    templateStartHeader: function (obj, type, marks) {
	      var className = "webix_unit_header webix_unit_" + type.css + "_header" + (obj.$selected ? "_selected" : "");
	      var style = "width:" + type.widthSize(obj, type, marks) + "; height:" + type.headerHeight + "px; overflow:hidden;";
	      return "<div webix_unit_id=\"" + obj.$unit + "\" class=\"" + className + "\" style=\"" + style + "\">";
	    }
	  },
	  $skin: function () {
	    this.type.headerHeight = $active.unitHeaderHeight;
	  }
	};
	var view$_ = exports.protoUI(api$_, list.view);

	i18n.dbllist = {
	  selectAll: "<span class='webix_icon wxi-angle-double-right'></span>",
	  selectOne: "<span class='webix_icon wxi-angle-right'></span>",
	  deselectAll: "<span class='webix_icon wxi-angle-double-left'></span>",
	  deselectOne: "<span class='webix_icon wxi-angle-left'></span>"
	};
	var api$10 = {
	  name: "dbllist",
	  defaults: {
	    borderless: true
	  },
	  $init: function () {
	    this._moved = {};
	    this._inRight = bind(function (obj) {
	      return this._moved[obj.id];
	    }, this);
	    this._inLeft = bind(function (obj) {
	      return !this._moved[obj.id];
	    }, this);
	    this.$view.className += " webix_dbllist";
	    this.$ready.unshift(this._setLayout);
	  },
	  $onLoad: function (data, driver) {
	    this._updateAndResize(function () {
	      this.$$("left").data.driver = driver;
	      this.$$("left").parse(data);
	      this.$$("right").data.driver = driver;
	      this.$$("right").parse(data);
	    });

	    this._refresh();

	    return true;
	  },
	  _getButtons: function () {
	    if (this._settings.buttons === false) return {
	      width: 10
	    };
	    var locale = i18n.dbllist;
	    var buttons = [this._getButton("deselect_all", locale.deselectAll), this._getButton("select_all", locale.selectAll), this._getButton("deselect_one", locale.deselectOne), this._getButton("select_one", locale.selectOne)];
	    buttons = {
	      width: 120,
	      template: buttons.join(""),
	      onClick: {
	        dbllist_button: function (e, id, trg) {
	          this.getTopParentView()._update_list(trg.getAttribute("action"));
	        }
	      }
	    };
	    if (this._settings.buttons) buttons.template = this._settings.buttons;
	    return buttons;
	  },
	  _getButton: function (action, label) {
	    return "<button class='dbllist_button' action='" + action + "'>" + label + "</button>";
	  },
	  _getList: function (id, action, label, bottom) {
	    var list = {
	      view: "list",
	      select: "multiselect",
	      multiselect: "touch",
	      id: id,
	      action: action,
	      drag: true,
	      type: {
	        margin: 3,
	        id: id
	      },
	      on: {
	        onBeforeDrop: function (context) {
	          var source = context.from;
	          var target = context.to;
	          var top = source.getTopParentView();

	          if (top === this.getTopParentView()) {
	            var mode = target._settings.action != "select_one";
	            top.select(context.source, mode);
	          }

	          return false;
	        },
	        onItemDblClick: function () {
	          return this.getTopParentView()._update_list(this.config.action);
	        }
	      }
	    };
	    if (this._settings.list) exports.extend(list, this._settings.list, true);
	    if (label) list = {
	      rows: [{
	        view: "label",
	        label: label,
	        css: "webix_inp_top_label"
	      }, list]
	    };
	    if (bottom) return {
	      rows: [list, {
	        view: "label",
	        height: 20,
	        label: bottom,
	        css: "bottom_label"
	      }]
	    };
	    return list;
	  },
	  _setLayout: function () {
	    var cols = [{
	      margin: 10,
	      type: "clean",
	      cols: [this._getList("left", "select_one", this._settings.labelLeft, this._settings.labelBottomLeft), this._getButtons(), this._getList("right", "deselect_one", this._settings.labelRight, this._settings.labelBottomRight)]
	    }];
	    this.cols_setter(cols);
	  },
	  _update_list: function (action) {
	    var top = this;
	    var id = null;
	    var mode = false;

	    if (action === "select_all") {
	      id = top.$$("left").data.order;
	      mode = true;
	    } else if (action === "select_one") {
	      id = top.$$("left").getSelectedId(true);
	      mode = true;
	    } else if (action === "deselect_all") {
	      id = top.$$("right").data.order;
	      mode = false;
	    } else if (action === "deselect_one") {
	      id = top.$$("right").getSelectedId(true);
	      mode = false;
	    }

	    top.select(id, mode);
	  },
	  select: function (id, mode) {
	    var i;
	    if (_typeof(id) !== "object") id = [id];

	    if (mode) {
	      for (i = 0; i < id.length; i++) {
	        this._moved[id[i]] = true;
	      }
	    } else {
	      for (i = 0; i < id.length; i++) {
	        delete this._moved[id[i]];
	      }
	    }

	    this._refresh();

	    this.callEvent("onChange", []);
	  },
	  _updateAndResize: function (handler, size) {
	    freeze(bind(handler, this), false);
	    if (size && (this.$$("left")._settings.autoheight || this.$$("right")._settings.autoheight)) this.resize();
	  },
	  _refresh: function () {
	    var left = this.$$("left");
	    var right = this.$$("right");
	    if (left) this._updateAndResize(function () {
	      left.filter(this._inLeft);
	      right.filter(this._inRight);
	    }, true);
	  },
	  focus: function () {
	    if (!UIManager.canFocus(this)) return false;
	    UIManager.setFocus(this);
	  },
	  value_setter: function (val) {
	    this.setValue(val);
	  },
	  setValue: function (value) {
	    this._moved = {};
	    if (_typeof(value) !== "object") value = value.toString().split(",");

	    for (var i = 0; i < value.length; i++) {
	      this._moved[value[i]] = true;
	    }

	    this._refresh();
	  },
	  getValue: function () {
	    var value = [];

	    for (var key in this._moved) {
	      value.push(key);
	    }

	    return value.join(",");
	  }
	};
	var view$10 = exports.protoUI(api$10, AtomDataLoader, IdSpace, layout.view);

	var api$11 = {
	  name: "tree",
	  defaults: {
	    scroll: "auto",
	    navigation: true
	  },
	  $init: function () {
	    this._viewobj.className += " webix_tree"; //map API of DataStore on self

	    exports.extend(this.data, TreeStore, true);
	    exports.extend(this.on_click, TreeClick);
	    this.attachEvent("onAfterRender", this._refresh_scroll);
	    this.attachEvent("onPartialRender", this._refresh_scroll);
	    this.data.provideApi(this, true);

	    this._viewobj.setAttribute("role", "tree");
	  },
	  //attribute , which will be used for ID storing
	  _id: "webix_tm_id",
	  //supports custom context menu
	  on_context: {},
	  on_dblclick: {
	    webix_tree_checkbox: function () {
	      if (this.on_click.webix_tree_checkbox) return this.on_click.webix_tree_checkbox.apply(this, arguments);
	    }
	  },
	  $fixEditor: function (editor) {
	    var item = this.getItemNode(editor.id).querySelector("span");

	    if (item) {
	      if (item.innerHTML === "") item.innerHTML = "&nbsp;";
	      var padding = 10;
	      var pos$$1 = item.offsetLeft;
	      editor.node.style.width = this.$view.scrollWidth - pos$$1 - padding + "px";
	      editor.node.style.marginLeft = pos$$1 + "px";
	      editor.node.style.left = "0px";
	    }
	  },
	  //css class to action map, for onclick event
	  on_click: {
	    webix_tree_item: function (e, id) {
	      if (this._settings.activeTitle) {
	        var item = this.getItem(id);
	        if (item.open) this.close(id);else this.open(id);
	      }

	      if (this._settings.select) {
	        if (this._settings.select == "multiselect" || this._settings.multiselect) {
	          var multimode = e.ctrlKey || e.metaKey || this._settings.multiselect == "touch";

	          if (this._settings.multiselect == "level" && (multimode || e.shiftKey)) {
	            //allow only selection on the same level
	            var select = this.getSelectedId(true)[0];
	            if (select && this.getParentId(id) != this.getParentId(select)) return;
	          }

	          this.select(id, false, multimode, e.shiftKey); //multiselection
	        } else this.select(id);
	      }
	    }
	  },
	  _paste: {
	    // insert new item with pasted value
	    insert: function (text) {
	      var parent = this.getSelectedId() || "0";
	      this.add({
	        value: text
	      }, null, parent);
	    },
	    // change value of each selected item
	    modify: function (text) {
	      var sel = this.getSelectedId(true);

	      for (var i = 0; i < sel.length; i++) {
	        this.getItem(sel[i]).value = text;
	        this.refresh(sel[i]);
	      }
	    },
	    // do nothing
	    custom: function () {}
	  },
	  _drag_order_complex: true,
	  $dragHTML: function (obj, e, context) {
	    var html = "<div class='webix_tree_item'>" + this.type.template(obj, this.type) + "</div>";
	    if (isArray(context.source) && context.source.length > 1) html = this._toMultipleHTML(html, context.source.length);
	    return html;
	  },
	  _close_branches: function (context) {
	    var source = context.source;

	    for (var i = 0; i < source.length; i++) {
	      this.close(source[i]);
	    }
	  },
	  _set_drop_area: function (target, t) {
	    var node = this.getItemNode(target);

	    if (node) {
	      node.parentNode.insertBefore(DragControl._dropHTML[0], node);
	    } else t.children[0].children[0].appendChild(DragControl._dropHTML[0]);
	  },
	  //css class to action map, for dblclick event
	  type: exports.extend({
	    //normal state of item
	    template: function (obj, common) {
	      var template$$1 = common["template" + obj.level] || common.templateCommon;
	      return template$$1.apply(this, arguments);
	    },
	    classname: function (obj, common, marks) {
	      var css = "webix_tree_item";

	      if (obj.$css) {
	        if (_typeof(obj.$css) == "object") obj.$css = createCss(obj.$css);
	        css += " " + obj.$css;
	      }

	      if (marks && marks.$css) css += " " + marks.$css;
	      if (common.css) css += " " + common.css;
	      return css;
	    },
	    aria: function (obj, common, marks) {
	      return "role=\"treeitem\"" + (marks && marks.webix_selected ? " aria-selected=\"true\" tabindex=\"0\"" : " tabindex=\"-1\"") + (obj.$count ? "aria-expanded=\"" + (obj.open ? "true" : "false") + "\"" : "") + "aria-level=\"" + obj.$level + "\"";
	    },
	    templateCommon: template("{common.icon()} {common.folder()} <span>#value#</span>"),
	    templateStart: template("<div webix_tm_id=\"#id#\" class=\"{common.classname()}\" {common.aria()}>"),
	    templateEnd: template("</div>"),
	    templateCopy: template("#value#")
	  }, TreeType)
	};
	var view$11 = exports.protoUI(api$11, TreeStateCheckbox, Group, TreeAPI, DragItem, TreeDataMove, SelectionModel, KeysNavigation, MouseEvents, Scrollable, TreeDataLoader, proto.view, TreeRenderStack, CopyPaste, EventSystem);
	var tree = {
	  api: api$11,
	  view: view$11
	};
	type(view$11, {
	  name: "lineTree",
	  css: "webixLineTree",
	  icon: function (obj, common) {
	    var html = "";
	    var open = "";

	    for (var i = 1; i <= obj.$level; i++) {
	      if (i == obj.$level) open = obj.$count ? obj.open ? "webix_tree_open " : "webix_tree_close " : "webix_tree_none ";

	      var icon = common._icon_src(obj, common, i);

	      if (icon) html += "<div class='" + open + "webix_tree_img webix_tree_" + icon + "'></div>";
	    }

	    return html;
	  },
	  _icon_src: function (obj, common, level) {
	    var lines = common._tree_branch_render_state;
	    var tree = TreeRenderStack._obj;

	    if (lines === 0 && tree) {
	      //we are in standalone rendering 
	      //need to reconstruct rendering state
	      var lines_level = obj.$level;
	      var branch_id = obj.id;
	      lines = [];

	      while (lines_level) {
	        var parent_id = tree.getParentId(branch_id);
	        var pbranch = tree.data.branch[parent_id];
	        if (pbranch[pbranch.length - 1] == branch_id) lines[lines_level] = true;
	        branch_id = parent_id;
	        lines_level--;
	      } //store for next round


	      common._tree_branch_render_state = lines;
	    }

	    if (!lines) return 0; //need to be replaced with image urls

	    if (level == obj.$level) {
	      var mode = 3; //3-way line

	      if (!obj.$parent) {
	        //top level
	        if (obj.$index === 0) mode = 4; //firts top item
	      }

	      if (lines[obj.$level]) mode = 2;

	      if (obj.$count) {
	        if (obj.open) return "minus" + mode;else return "plus" + mode;
	      } else return "line" + mode;
	    } else {
	      if (!lines[level]) return "line1";
	      return "blank";
	    }
	  }
	});

	var api$12 = {
	  name: "treemap",
	  defaults: {
	    activeItem: false,
	    subRender: true,
	    header: true,
	    headerHeight: 35,
	    value: template("#value#"),
	    headerTemplate: "",
	    navigation: true
	  },
	  value_setter: template,
	  headerTemplate_setter: template,
	  header_setter: function (value) {
	    if (value && value !== true) {
	      this.type.header = value;
	    }

	    return value;
	  },
	  $init: function () {
	    this.$view.className += " webix_treemap";

	    this._viewobj.setAttribute("role", "tree");

	    this._htmlElement = document.createElement("DIV");
	    exports.extend(this.data, TreeStore, true);
	    this.data.provideApi(this, true);
	    this.data.attachEvent("onClearAll", bind(function () {
	      this._html = "";
	      this.$values = {};
	      this.$xy = {};
	    }, this));
	    this.attachEvent("onKeyPress", this._onKeyPress);
	  },
	  _toHTMLItem: function (obj) {
	    var mark = this.data._marks[obj.id];
	    this.callEvent("onItemRender", [obj]);
	    var template$$1 = obj.$template ? this.type["template" + obj.$template].call(this, obj, this.type, mark) : this.type.template.call(this, obj, this.type, mark);
	    return this.type.templateStart.call(this, obj, this.type, mark) + template$$1 + this.type.templateEnd.call(this);
	  },
	  _renderHeader: function (id) {
	    var item = this.getItem(id);
	    var height = this._settings.headerHeight;
	    var html = "<div class='webix_treemap_header' style='height:" + height + "px;line-height:" + height + "px;'>";
	    html += this.type.header.call(this, item, this.type);
	    html += "</div>";
	    return html;
	  },
	  _renderBranch: function (pId) {
	    var sizes,
	        row,
	        value,
	        sum,
	        leaves = [];

	    if (!this.$width || !this.count()) {
	      this._html = "";
	      return false;
	    }

	    if (!pId) {
	      pId = this.config.branch || 0;
	      this._html = "";
	      this.$values = {};
	      this.$xy = {};
	      this.$xy[pId] = {
	        width: this.$width,
	        height: this.$height,
	        top: 0,
	        left: 0
	      }; // header

	      if (pId && this._settings.header) {
	        this.$xy[pId].height -= this._settings.headerHeight;
	        this.$xy[pId].top = this._settings.headerHeight;
	        this._html += this._renderHeader(pId);
	      } // values calculation


	      sum = 0;
	      this.data.each(function (item) {
	        var parentId = this.getParentId(item.id);

	        if (!this.data.branch[item.id]) {
	          value = this.config.value.call(this, item) * 1;

	          if (!isNaN(value) && value) {
	            this.$values[item.id] = value;
	            sum += value;

	            while (parentId) {
	              if (!this.$values[parentId]) this.$values[parentId] = 0;
	              this.$values[parentId] += value;
	              parentId = this.getParentId(parentId);
	            }
	          }
	        }
	      }, this, false, pId);
	    }

	    this.data.eachChild(pId, function (item) {
	      if (this.$values[item.id]) leaves.push(copy(item));
	    }, this);
	    sum = sum || this.$values[pId];

	    if (leaves.length && sum) {
	      sizes = this.$xy[pId];
	      row = {
	        top: sizes.top,
	        left: sizes.left,
	        dx: sizes.width,
	        dy: sizes.height,
	        set: [],
	        sum: 0
	      };
	      row.dim = Math.min(row.dx, row.dy);
	      var delta = row.dx * row.dy / sum; //total area

	      for (var _i = 0; _i < leaves.length; _i++) {
	        leaves[_i].$value = this.$values[leaves[_i].id] * delta;
	      } //normalized value


	      leaves.sort(function (a, b) {
	        return a.$value > b.$value ? -1 : 1;
	      });
	      var bad = Infinity;
	      var i = 0;

	      while (leaves[i]) {
	        var check = this._worst(row, leaves[i]);

	        if (check < bad) {
	          row.sum += leaves[i].$value;
	          row.set.push(leaves[i]);
	          bad = check;
	          i++;
	        } else {
	          this._renderRow(row);

	          var r = {
	            top: row.top,
	            left: row.left,
	            dx: row.dx,
	            dy: row.dy,
	            set: [],
	            sum: 0
	          };

	          var _delta = row.sum / row.dim;

	          if (row.dx > row.dy) {
	            r.left += _delta;
	            r.dx -= _delta;
	          } else {
	            r.top += _delta;
	            r.dy -= _delta;
	          }

	          row = r;
	          row.dim = Math.min(row.dx, row.dy);
	          bad = Infinity;
	        }
	      }
	    }

	    if (row) this._renderRow(row);
	  },
	  _renderRow: function (row) {
	    var i,
	        id,
	        x,
	        y,
	        top = row.top,
	        left = row.left;
	    row.mode = row.dy < row.dx;
	    row.contra = row.sum / row.dim;

	    for (i = 0; i < row.set.length; i++) {
	      id = row.set[i].id;

	      if (row.mode) {
	        x = row.contra;
	        y = row.set[i].$value / row.contra;
	      } else {
	        x = row.set[i].$value / row.contra;
	        y = row.contra;
	      }

	      this.$xy[id] = {};
	      this.$xy[id].top = top;
	      this.$xy[id].left = left;
	      if (row.mode) top += y;else left += x;
	      this.$xy[id].width = x;
	      this.$xy[id].height = y;
	      this._html += this._toHTMLItem(this.getItem(id));
	      if (this._settings.subRender && this.data.branch[id]) this._renderBranch(id);
	    }
	  },
	  _worst: function (row, add) {
	    var s = row.sum + add.$value;
	    var a = s * s / (row.dim * row.dim * add.$value);

	    if (row.set.length) {
	      a = Math.max(row.dim * row.dim * row.set[0].$value / (s * s), a);
	    }

	    return a > 1 ? a : 1 / a;
	  },
	  _toHTMLObject: function (obj) {
	    this._htmlElement.innerHTML = this._toHTMLItem(obj);
	    return this._htmlElement.firstChild;
	  },
	  showBranch: function (id) {
	    this._settings.branch = id;
	    this.refresh();
	  },
	  render: function (id, data, type) {
	    if (!this.isVisible(this._settings.id) || this.$blockRender) return;

	    if (type == "update") {
	      var cont = this.getItemNode(id); //get html element of updated item

	      if (cont) {
	        var t = this._htmlmap[id] = this._toHTMLObject(data);

	        insertBefore(t, cont);
	        remove(cont);
	      }
	    } else if (this.data.branch && (!this._settings.branch || this.data.branch[this._settings.branch])) {
	      this._htmlmap = null;
	      this.callEvent("onBeforeRender", []);

	      this._renderBranch();

	      this._dataobj.innerHTML = this._html;
	      this.callEvent("onAfterRender", []);
	    }

	    return true;
	  },
	  _id: "webix_dm_id",
	  on_click: {
	    webix_treemap_item: function (e, id) {
	      if (this._settings.select) {
	        if (this._settings.select == "multiselect" || this._settings.multiselect) this.select(id, false, e.ctrlKey || e.metaKey || this._settings.multiselect == "touch", e.shiftKey);else this.select(id);
	      }

	      if (this._settings.activeItem && this.isBranch(id)) {
	        this.showBranch(id);
	      }
	    },
	    webix_treemap_header_item: function (e) {
	      var id = locate(e, "webix_dm_header_id");
	      this.define("branch", id);
	      this.refresh();
	    },
	    webix_treemap_reset: function () {
	      this.define("branch", 0);
	      this.refresh();
	    }
	  },
	  on_dblclick: {},
	  on_mouse_move: {},
	  _getCssText: function (style) {
	    var css = "";

	    for (var property in style) {
	      css += property + ":" + style[property] + ";";
	    }

	    return css;
	  },
	  type: {
	    //normal state of item
	    template: template("#value#"),
	    header: function (obj, common) {
	      var id = obj.id;
	      var resetIcon = "<div role='button' tabindex='0' aria-label='" + i18n.aria.resetTreeMap + "' class='webix_treemap_reset'></div>";
	      var arr = [];

	      while (id) {
	        obj = this.getItem(id);
	        arr.push(common.headerItem.call(this, obj, common));
	        id = this.getParentId(id);
	      }

	      arr.reverse();
	      return resetIcon + arr.join("<span class='webix_icon wxi-angle-right webix_treemap_path_icon'></span>");
	    },
	    headerItem: function (obj) {
	      var template$$1 = this.config.headerTemplate(obj);
	      var html = "<a role=\"button\" tabindex=\"0\" aria-label=\"" + template$$1 + "\" webix_dm_header_id=\"" + obj.id + "\" class=\"webix_treemap_header_item\">";
	      html += template$$1;
	      html += "</a>";
	      return html;
	    },
	    classname: function (obj, common, marks) {
	      var css = "webix_treemap_item";
	      if (common.css) css += " " + common.css;

	      if (obj.$css) {
	        if (_typeof(obj.$css) == "object") obj.$css = createCss(obj.$css);
	        css += " " + obj.$css;
	      }

	      var xy = this.$xy[obj.id];
	      if (marks && marks.$css) css += " " + marks.$css;
	      css += " webix_treemap_level_" + this.getItem(obj.id).$level;
	      var parentId = this.getParentId(obj.id);
	      if (!parentId || parentId == this._settings.branch) css += " webix_treemap_level_top";
	      if (this.$height - xy.top - xy.height < 1) css += " webix_treemap_item_bottom";
	      if (this.$width - xy.left - xy.width < 1) css += " webix_treemap_item_right";

	      if (common.cssClass) {
	        var cssClass = common.cssClass.call(this, obj, common, marks);

	        if (cssClass) {
	          if (_typeof(cssClass) == "object") {
	            css += " " + createCss(cssClass);
	          } else css += " " + cssClass;
	        }
	      }

	      return css;
	    },
	    templateStart: function (obj, type, marks) {
	      var style = "";

	      if (this.$xy) {
	        var xy = this.$xy[obj.id];
	        style += "width: " + xy.width + "px; height: " + xy.height + "px;";
	        style += "top: " + xy.top + "px; left: " + xy.left + "px;";
	      }

	      return "<div role=\"treeitem\" aria-level=\"" + obj.$level + "\" " + (marks && marks.webix_selected ? "aria-selected=\"true\" tabindex=\"0\"" : "") + " webix_dm_id=\"" + obj.id + "\" class=\"" + type.classname.call(this, obj, type, marks) + "\" style=\"" + style + "\">";
	    },
	    templateEnd: template("</div>")
	  }
	};
	var view$12 = exports.protoUI(api$12, Group, TreeAPI, SelectionModel, KeysNavigation, MouseEvents, Scrollable, TreeDataLoader, proto.view, TreeRenderStack, CopyPaste, EventSystem);

	/*
		UI:DataView
	*/
	// #include ui/component.js
	// #include core/mouse.js 	
	// #include core/edit.js 
	// #include core/selection.js 
	// #include core/drag.js
	// #include core/move.js
	// #include core/virtual_render.js
	// #include core/keynav.js
	// #include core/print.js

	var api$13 = {
	  name: "dataview",
	  $init: function (config) {
	    if (config.sizeToContent) //method need to be called before data-loaders
	      //so we are using unshift to place it at start
	      this.$ready.unshift(this._after_init_call);
	    var type = config.type || config.item;
	    var prerender = config.prerender || this.defaults.prerender || type && type.width == "auto" || config.drag == "move" || config.drag == "order";
	    if (!prerender && !config.autoheight) exports.extend(this, VirtualRenderStack, true);
	    if (config.autoheight) config.scroll = false;

	    if (type && type.type == "tiles") {
	      this._viewobj.firstChild.style.padding = "8px";
	      this._tilesPadding = 8;
	    }

	    this._contentobj.className += " webix_dataview";

	    this._viewobj.setAttribute("role", "listbox");
	  },
	  _after_init_call: function () {
	    var test = create("DIV", 0, this.type.template({}));
	    test.style.position = "absolute";
	    document.body.appendChild(test);
	    this.type.width = test.offsetWidth;
	    this.type.height = test.offsetHeight;
	    remove(test);
	  },
	  defaults: {
	    scroll: true,
	    datafetch: 50,
	    navigation: true
	  },
	  _id: "webix_l_id",
	  _itemClassName: "webix_dataview_item",
	  _tilesPadding: 0,
	  _drag_direction: "x",
	  on_click: {
	    webix_dataview_item: function (e, id) {
	      if (this._settings.select) {
	        if (this._settings.select == "multiselect" || this._settings.multiselect) this.select(id, false, this._settings.multiselect == "touch" || e.ctrlKey || e.metaKey, e.shiftKey); //multiselection
	        else this.select(id);
	      }
	    }
	  },
	  on_dblclick: {},
	  on_mouse_move: {},
	  type: {
	    //normal state of item
	    template: template("#value#"),
	    //in case of dyn. loading - temporary spacer
	    templateLoading: template("Loading..."),
	    width: 160,
	    height: 50,
	    classname: function (obj, common, marks) {
	      var css = "webix_dataview_item";
	      if (common.css) css += " " + common.css;
	      if (common.type && common.type.toString() == "tiles") css += "tiles ";

	      if (obj.$css) {
	        if (_typeof(obj.$css) == "object") obj.$css = createCss(obj.$css);
	        css += " " + obj.$css;
	      }

	      if (marks && marks.$css) css += " " + marks.$css;
	      return css;
	    },
	    tilesStart: function (obj, common) {
	      if (common.type == "tiles") return "<div class=\"webix_dataview_inner_item\" style=\"box-sizing:border-box; overflow:hidden;\">";
	      return "";
	    },
	    tilesEnd: function (obj, common) {
	      if (common.type == "tiles") return "</div>";
	      return "";
	    },
	    aria: function (obj, common, marks) {
	      return "role=\"option\"" + (marks && marks.webix_selected ? " aria-selected=\"true\" tabindex=\"0\"" : " tabindex=\"-1\"");
	    },
	    templateStart: template("<div webix_l_id=\"#id#\" class=\"{common.classname()}\" {common.aria()} style=\"width:{common.width}px; height:{common.height}px; float:left; overflow:hidden;\">{common.tilesStart()}"),
	    templateEnd: template("{common.tilesEnd()}</div>")
	  },
	  _calck_autoheight: function (width) {
	    return this._settings.height = this.type.height * Math.ceil(this.data.count() / Math.floor(width / this.type.width));
	  },
	  autoheight_setter: function (mode) {
	    if (mode) {
	      this.data.attachEvent("onStoreLoad", bind(this.resize, this));
	      this._contentobj.style.overflowY = "hidden";
	    }

	    return mode;
	  },
	  $getSize: function (dx, dy) {
	    if (this._settings.xCount > 0 && this.type.width != "auto" && !this._autowidth) this._settings.width = this.type.width * this._settings.xCount + (this._scroll_y ? env.scrollSize : 0);
	    if (this._settings.yCount && this.type.height != "auto") this._settings.height = this.type.height * this._settings.yCount;
	    var width = this._settings.width || this._content_width;

	    if (this._settings.autoheight && width) {
	      this._calck_autoheight(width);

	      this.scroll_setter(false);
	    }

	    return base.api.$getSize.call(this, dx, dy);
	  },
	  _recalk_counts: function () {
	    var render = false;

	    if (this._settings.yCount && this.type.height == "auto") {
	      this.type.height = Math.floor((this._content_height - this._tilesPadding) / this._settings.yCount);
	      render = true;
	    }

	    if (this._settings.xCount && (this.type.width == "auto" || this._autowidth)) {
	      this._autowidth = true; //flag marks that width was set to "auto" initially

	      this.type.width = Math.floor((this._content_width - this._tilesPadding * 2) / this._settings.xCount);
	      render = true;
	    } else this._autowidth = false;

	    return render;
	  },
	  $setSize: function (x, y) {
	    if (base.api.$setSize.call(this, x, y)) {
	      if (this._settings.autoheight && this._calck_autoheight() != this._content_height) return delay(this.resize, this);
	      if (this._recalk_counts() || this._render_visible_rows) this.render();
	    }
	  }
	};
	var view$13 = exports.protoUI(api$13, DataMove, DragItem, MouseEvents, KeysNavigation, SelectionModel, Scrollable, CustomPrint, proto.view);

	i18n.pager = {
	  first: "<span class='webix_icon wxi-angle-double-left'></span>",
	  last: "<span class='webix_icon wxi-angle-double-right'></span>",
	  next: "<span class='webix_icon wxi-angle-right'></span>",
	  prev: "<span class='webix_icon wxi-angle-left'></span>"
	};
	var api$14 = {
	  defaults: {
	    size: 10,
	    //items on page
	    page: 0,
	    //current page
	    group: 5,
	    template: "{common.pages()}",
	    maxWidth: 100000,
	    height: 30,
	    borderless: true
	  },
	  name: "pager",
	  on_click: {
	    //on paging button click
	    "webix_pager_item": function (e, id) {
	      this.select(id);
	    }
	  },
	  $init: function (config) {
	    this.data = this._settings;
	    this._dataobj = this._viewobj;
	    this._viewobj.className += " webix_pager" + (config.autowidth ? " webix_pager_auto" : "");
	    if (config.master === false || config.master === 0) this.$ready.push(this._remove_master);
	  },
	  _remove_master: function () {
	    this.refresh();
	    this.$master = {
	      refresh: function () {},
	      select: function () {}
	    };
	  },
	  select: function (id) {
	    if (this.$master && this.$master.name == "pager") return this.$master.select(id); //id - id of button, number for page buttons

	    switch (id) {
	      case "next":
	        id = this._settings.page + 1;
	        break;

	      case "prev":
	        id = this._settings.page - 1;
	        break;

	      case "first":
	        id = 0;
	        break;

	      case "last":
	        id = this._settings.limit - 1;
	        break;

	      default:
	        //use incoming id
	        break;
	    }

	    if (id < 0) id = 0;
	    if (id >= this.data.limit) id = this.data.limit - 1;
	    var old = this.data.page;

	    if (this.callEvent("onBeforePageChange", [id, old])) {
	      this.data.page = id * 1; //must be int

	      if (this.refresh()) {
	        if (!this._settings.animate || !this._animate(old, id * 1, this._settings.animate)) this.$master.refresh();
	      }

	      this.callEvent("onAfterPageChange", [id]);
	    }
	  },
	  _id: "webix_p_id",
	  template_setter: template,
	  type: {
	    template: function (a, b) {
	      return a.template.call(this, a, b);
	    },
	    //list of page numbers
	    pages: function (obj) {
	      var html = ""; //skip rendering if paging is not fully initialized

	      if (obj.page == -1) return ""; //current page taken as center of view, calculate bounds of group

	      obj.$min = obj.page - Math.round((obj.group - 1) / 2);
	      obj.$max = obj.$min + obj.group * 1 - 1;

	      if (obj.$min < 0) {
	        obj.$max += obj.$min * -1;
	        obj.$min = 0;
	      }

	      if (obj.$max >= obj.limit) {
	        obj.$min -= Math.min(obj.$min, obj.$max - obj.limit + 1);
	        obj.$max = obj.limit - 1;
	      } //generate HTML code of buttons


	      for (var i = obj.$min || 0; i <= obj.$max; i++) {
	        html += this.button({
	          id: i,
	          index: i + 1,
	          selected: i == obj.page ? "_selected" : "",
	          label: i18n.aria.page + " " + (i + 1)
	        });
	      }

	      return html;
	    },
	    page: function (obj) {
	      return obj.page + 1;
	    },
	    //go-to-first page button
	    first: function () {
	      return this.button({
	        id: "first",
	        index: i18n.pager.first,
	        selected: "",
	        label: i18n.aria.pages[0]
	      });
	    },
	    //go-to-last page button
	    last: function () {
	      return this.button({
	        id: "last",
	        index: i18n.pager.last,
	        selected: "",
	        label: i18n.aria.pages[3]
	      });
	    },
	    //go-to-prev page button
	    prev: function () {
	      return this.button({
	        id: "prev",
	        index: i18n.pager.prev,
	        selected: "",
	        label: i18n.aria.pages[1]
	      });
	    },
	    //go-to-next page button
	    next: function () {
	      return this.button({
	        id: "next",
	        index: i18n.pager.next,
	        selected: "",
	        label: i18n.aria.pages[2]
	      });
	    },
	    button: template("<button type='button' webix_p_id='{obj.id}' class='webix_pager_item{obj.selected}' aria-label='{obj.label}'>{obj.index}</button>")
	  },
	  clone: function (pager) {
	    if (!pager.$view) {
	      pager.view = "pager";
	      pager = ui(pager);
	    }

	    this._clone = pager;
	    pager.$master = this;

	    this._refresh_clone();
	  },
	  refresh: function () {
	    var s = this._settings;
	    if (!s.count) return; //max page number

	    s.limit = Math.ceil(s.count / s.size);
	    var newPage = Math.min(s.limit - 1, s.page);
	    if (newPage != s.page) return this.$master.setPage(newPage);
	    s.page = newPage;

	    if (newPage >= 0 && newPage != s.old_page || s.limit != s.old_limit || s.old_count != s.count) {
	      //refresh self only if current page or total limit was changed
	      this.render();

	      this._refresh_clone();

	      s.old_limit = s.limit; //save for onchange check in next iteration

	      s.old_page = s.page;
	      s.old_count = s.count;
	      return true;
	    }
	  },
	  apiOnly_setter: function (value) {
	    return this.$apiOnly = value;
	  },
	  _refresh_clone: function () {
	    if (this._clone) {
	      this._clone._settings.count = this._settings.count;
	      this._clone._settings.page = this._settings.page;

	      this._clone.refresh();
	    }
	  },
	  _animate: function (old, id, config) {
	    if (old == id) return false;

	    if (this._pgInAnimation) {
	      if (this._pgAnimateTimeout) {
	        window.clearTimeout(this._pgAnimateTimeout);
	      }

	      return this._pgAnimateTimeout = delay(this._animate, this, [old, id, config], 100);
	    }

	    var direction = id > old ? "left" : "right";
	    if (config.direction == "top" || config.direction == "bottom") direction = id > old ? "top" : "bottom";
	    if (config.flip) direction = ""; //make copy of existing view

	    var top = 0;
	    var snode = this.$master._dataobj;
	    var isDataTable = !!this.$master._body;

	    if (isDataTable) {
	      snode = this.$master._body;
	      top = snode.offsetTop;
	      addCss(this.$master.$view, "webix_animation");
	    }

	    var onode = snode.cloneNode(true);
	    onode.style.width = snode.style.width = "100%"; //redraw page

	    this.$master.refresh(); //append copy next to original

	    insertBefore(onode, snode.nextSibling, snode.parentNode);
	    if (isDataTable) onode.childNodes[1].scrollLeft = snode.childNodes[1].scrollLeft; //animation config

	    var line;
	    var base$$1 = config !== true ? config : {};
	    var aniset = exports.extend({
	      direction: direction,
	      callback: bind(function () {
	        aniset.callback = null;
	        animate.breakLine(line);
	        this._pgInAnimation = false;
	        if (this.$master._body) removeCss(this.$master.$view, "webix_animation");
	      }, this),
	      top: top,
	      keepViews: isDataTable
	    }, base$$1); //run animation

	    line = animate.formLine(snode, onode, aniset);
	    animate([snode, onode], aniset);
	    this._pgInAnimation = true;
	  }
	};
	var view$14 = exports.protoUI(api$14, MouseEvents, SingleRender, base.view, EventSystem);

	var api$15 = {
	  name: "comments",
	  defaults: {
	    sendAction: "click",
	    mode: "comments",
	    moreButton: template(i18n.comments.moreComments)
	  },
	  $init: function (config) {
	    this.$view.className += " webix_comments";
	    config.rows = [this._configList(config)];
	    if (!config.readonly) config.rows.push(this._configForm());
	    this._destroy_with_me = [];

	    this._initUsers(config.users);

	    this._initMenu();

	    this.$ready.push(this._afterInit);
	  },
	  $exportView: function () {
	    return this._list;
	  },
	  _afterInit: function () {
	    var _this = this;

	    // store UI blocks
	    this._list = this.queryView({
	      view: "list"
	    });
	    this._form = this.queryView({
	      view: "form"
	    });
	    this._sendButton = this.queryView({
	      view: "button"
	    });
	    this._input = this.queryView({
	      view: "textarea"
	    }); //provide data-like API

	    this._list.data.provideApi(this, true);

	    this.serialize = function () {
	      var data = _this._list.serialize();

	      var index$$1 = _this.getIndexById("$more");

	      if (index$$1 >= 0) data.splice(index$$1, 1);
	      return data;
	    }; //tune input zone


	    this._clickHandler = attachEvent("onClick", function (e) {
	      var view = $$(e);

	      if (view == _this._input) {
	        _this._changeTextarea(true);

	        delay(function () {
	          _this._input.focus();
	        });
	      } else if (view !== _this._sendButton && view !== _this._listMenu && (!e || (e.target.className || "").toString().indexOf("webix_comments_menu") === -1)) {
	        _this._changeTextarea();
	      }
	    });
	    this.attachEvent("onDestruct", function () {
	      detachEvent(this._clickHandler);
	    });
	  },
	  $onLoad: function (data, driver) {
	    this._fillList(data, driver);
	  },
	  _fillList: function (data, driver) {
	    var _this2 = this;

	    var list$$1 = this._list || this.queryView({
	      view: "list"
	    });
	    list$$1.data.driver = driver;
	    var more = data.more;
	    data = driver.getRecords(data); //parse more comments

	    if (this._moreCall) {
	      this._moreCall = false;

	      if (data.length) {
	        //add spaces after 'more' button to accommodate new data
	        var order = list$$1.data.order,
	            pos$$1 = 1;
	        if (this._settings.mode == "chat") list$$1.data.order = toArray([order[0]].concat(new Array(data.length), order.slice(1)));else {
	          var start = list$$1.getIndexById("$more");
	          list$$1.data.order = toArray(order.slice(0, start).concat(new Array(data.length), order.slice(start)));
	          pos$$1 = start;
	        } //parse into defined position

	        list$$1.parse({
	          data: data,
	          pos: pos$$1
	        });
	        if (more) dp(this._list).ignore(function () {
	          _this2._list.updateItem("$more", {
	            value: more
	          });
	        });
	        if (this._settings.mode == "chat") list$$1.showItem(list$$1.getIdByIndex(data.length));
	      }

	      if (!data.length || !more) dp(this._list).ignore(function () {
	        _this2._list.remove("$more");
	      });
	    } //normal parse
	    else {
	        if (more && !list$$1.exists("$more")) {
	          more = {
	            id: "$more",
	            value: more
	          };
	          if (this._settings.mode == "chat") data.unshift(more);else data.push(more);
	        }

	        list$$1.parse(data);
	        if (this._settings.mode == "chat") list$$1.showItem(list$$1.getLastId());
	      }
	  },
	  $skin: function () {
	    this._inputHeight = $active.inputHeight + 6;
	  },
	  getUsers: function () {
	    return this._users;
	  },
	  getMenu: function () {
	    return this._listMenu;
	  },
	  setCurrentUser: function (id) {
	    this.config.currentUser = id;

	    this._form.clear();

	    this._list.refresh();
	  },
	  edit: function (id) {
	    if (this.callEvent("onBeforeEditStart", [id])) {
	      this._changeTextarea(true);

	      var values = this._list.getItem(id);

	      this._form.setValues(values);

	      this._form.focus(); //set cursor to the last character and scroll to bottom


	      var node = this._form.elements.text.getInputNode();

	      node.scrollTop = node.scrollHeight;
	      setSelectionRange(node, values.text.length);
	      this.callEvent("onAfterEditStart", [id]);
	    }
	  },
	  _saveComment: function (clear) {
	    var values = this._form.getValues();

	    if (values.text) {
	      if (values.id) this.updateItem(values.id, values);else {
	        if (this.config.currentUser) values.user_id = this.config.currentUser;
	        values.date = new Date();
	        this.add(values);

	        this._list.scrollTo(0, this._list.getLastId());
	      }

	      this._form.clear();

	      if (clear) this._input.getInputNode().value = "";
	    }
	  },
	  _removeComment: function (id) {
	    if (this._form.getValues().id == id) {
	      this._form.clear();
	    }

	    this.remove(id);
	  },
	  _changeTextarea: function (increase) {
	    //this behaviour is only for desktop, otherwise we will never see the button on mobile
	    if (env.touch) return;
	    var text = this._input;

	    if (increase) {
	      this._sendButton.getParentView().show();

	      text.define({
	        height: 84
	      });
	    } else {
	      if (UIManager.hasFocus(this._sendButton)) UIManager.setFocus(this._list);

	      this._sendButton.getParentView().hide();

	      text.define({
	        height: this._inputHeight
	      });
	    }

	    text.resize();
	  },
	  _toggleButton: function (value) {
	    if (!value) value = this._input.getValue();
	    if (value && !this._sendButton.isEnabled()) this._sendButton.enable();else if (!value && this._sendButton.isEnabled()) this._sendButton.disable();
	  },
	  _initMenu: function () {
	    var _this3 = this;

	    this._listMenu = ui({
	      view: "contextmenu",
	      autowidth: true,
	      point: false,
	      data: [{
	        id: "edit",
	        icon: "wxi-pencil",
	        value: i18n.comments["edit"]
	      }, {
	        id: "remove",
	        icon: "wxi-trash",
	        value: i18n.comments["remove"]
	      }],
	      on: {
	        onShow: function () {
	          var ctx = _this3._listMenu.getContext();

	          _this3._list.addCss(ctx.id, "active_menu");
	        },
	        onHide: function () {
	          var ctx = _this3._listMenu.getContext();

	          _this3._list.removeCss(ctx.id, "active_menu");
	        },
	        onItemClick: function (id) {
	          var ctx = _this3._listMenu.getContext();

	          if (_this3.callEvent("onBeforeMenuAction", [id, ctx.id])) {
	            if (id == "edit") _this3.edit(ctx.id);else if (id == "remove") {
	              if (i18n.comments.confirmMessage) confirm({
	                text: i18n.comments.confirmMessage,
	                callback: function (res) {
	                  if (res) _this3._removeComment(ctx.id);
	                }
	              });else _this3._removeComment(ctx.id);
	            }
	          }
	        }
	      }
	    });

	    this._destroy_with_me.push(this._listMenu);
	  },
	  _configForm: function () {
	    var _this4 = this;

	    var locale = i18n.comments;
	    return {
	      view: "form",
	      minHeight: 50,
	      paddingX: 10,
	      elements: [{
	        view: "textarea",
	        css: "webix_comments_textarea",
	        height: this._inputHeight,
	        name: "text",
	        placeholder: locale["placeholder"],
	        keyPressTimeout: 100,
	        on: {
	          onTimedKeyPress: function () {
	            _this4._toggleButton();
	          },
	          onChange: function (newv) {
	            _this4._toggleButton(newv);
	          },
	          onKeyPress: function (code, ev) {
	            if (code == 13) {
	              var action = _this4._settings.sendAction,
	                  shift = ev.shiftKey;

	              if (action == "enter" && !shift || action !== "enter" && shift) {
	                preventEvent(ev);

	                _this4._saveComment(true);
	              }
	            }
	          }
	        }
	      }, {
	        hidden: !env.touch,
	        cols: [{}, {
	          view: "button",
	          disabled: true,
	          css: "webix_comments_send",
	          type: "form",
	          value: locale["send"],
	          autowidth: true,
	          click: function () {
	            _this4._saveComment();
	          }
	        }]
	      }]
	    };
	  },
	  _configList: function (config) {
	    var _this5 = this;

	    var css = "webix_comments_";
	    var type = {
	      height: "auto",
	      templateStatus: function (obj) {
	        return "<span class = '" + css + "status " + obj.status + "'></span>";
	      },
	      templateUser: function (obj) {
	        var users = _this5.getUsers();

	        var user = users && users.exists(obj.user_id) ? users.getItem(obj.user_id) : {};
	        var name = "<span class = '" + css + "name'>" + (user.value || "") + "</span>";
	        return name;
	      },
	      templateMenu: function () {
	        return "<span class='webix_icon wxi-dots " + css + "menu'></span>";
	      },
	      templateDate: function (obj) {
	        var format = wDate.dateToStr("%d %M, %H:%i");
	        return obj.date ? "<span class='" + css + "date'>" + format(obj.date) + "</span>" : "";
	      },
	      templateLinks: function (obj) {
	        var text = obj.text.replace(/(https?:\/\/[^\s]+)/g, function (match) {
	          match = template.escape(match);
	          var html = "<a target='_blank' href='" + match + "'>";
	          if (match.match(/.(jpg|jpeg|png|gif)$/)) html += "<img class='webix_comments_image' src='" + match + "'/>";else html += match;
	          return html + "</a>";
	        });
	        return text;
	      },
	      templateText: function (obj, common) {
	        return "<div class = '" + css + "message'>" + common.templateLinks(obj) + "</div>";
	      },
	      templateAvatar: function (obj, common) {
	        var avatar = "<div class='" + css + "avatar'>";

	        var users = _this5.getUsers();

	        var user = users && users.exists(obj.user_id) ? users.getItem(obj.user_id) : {};
	        if (user.status) avatar += common.templateStatus(user);
	        avatar += "<div class='" + css + "avatar_image ";
	        if (user.image) avatar += "'><img src = '" + user.image + "' class='" + css + "photo'>";else {
	          var icon = user.value ? user.value[0].toUpperCase() : "<span class='webix_icon wxi-user'></span>";
	          avatar += css + "avatar_text'>" + icon;
	        }
	        avatar += "</div></div>";
	        return avatar;
	      },
	      template: function (obj, common) {
	        var message$$1;

	        if (obj.id == "$more") {
	          message$$1 = "<div class='webix_comments_more'>" + _this5._settings.moreButton(obj) + "</div>";
	        } else {
	          var avatar = common.templateAvatar(obj, common);
	          var user = common.templateUser(obj, common);
	          var date = common.templateDate(obj, common);
	          var menu = common.templateMenu(obj, common);
	          var text = common.templateText(obj, common);
	          message$$1 = avatar + user + menu + date + text;
	        }

	        return message$$1;
	      },
	      classname: function (obj, common, marks) {
	        var css = list.api.type.classname(obj, common, marks);
	        if (obj.user_id && obj.user_id == _this5._settings.currentUser || !_this5._users.count()) css += " webix_comments_current";
	        return css;
	      }
	    };
	    type = exports.extend(type, config.listItem || {}, true);
	    var scheme = {
	      $init: function (obj) {
	        if (obj.date) obj.date = i18n.parseFormatDate(obj.date);
	      }
	    };
	    scheme = exports.extend(scheme, config.scheme || {}, true);
	    var listConfig = {
	      view: "list",
	      navigation: false,
	      type: type,
	      scheme: scheme,
	      onClick: {
	        "webix_comments_menu": function (ev, id) {
	          if (_this5._listMenu.isVisible()) _this5._listMenu.hide();else {
	            _this5._listMenu.setContext({
	              obj: _this5,
	              id: id
	            });

	            _this5._listMenu.show(ev.target, type.menuPosition || {
	              pos: "left",
	              y: 30,
	              x: 10
	            });
	          }
	        },
	        "webix_comments_more": function () {
	          if (_this5.config.url && _this5.callEvent("onDataRequest", [])) {
	            _this5._moreCall = true;

	            var more = _this5._list.getItem("$more").value;

	            var pos$$1 = _this5._settings.mode == "chat" ? more : _this5._list.getIndexById("$more");
	            var url = proxy$a.$parse(_this5.config.url);
	            var callback = {
	              error: function () {
	                _this5._moreCall = false;
	              }
	            };
	            if (typeof url == "string") url = url + (url.indexOf("?") < 0 ? "?" : "&") + "pos=" + pos$$1 + "&more=" + more;

	            _this5.load(url, callback, {
	              pos: pos$$1,
	              more: more
	            });
	          }
	        }
	      },
	      on: {
	        onAfterScroll: bind(function () {
	          //menu moves with scroll
	          this._listMenu.hide();
	        }, this)
	      }
	    };
	    if (config.save) listConfig.save = config.save;
	    return listConfig;
	  },
	  _initUsers: function (value) {
	    var _this6 = this;

	    if (value && value.getItem) {
	      this._users = value;
	    } else {
	      this._users = new DataCollection();

	      this._destroy_with_me.push(this._users);

	      if (value && typeof value === "string") this._users.load(value);else this._users.parse(value || []);
	    }

	    this._users.data.attachEvent("onStoreUpdated", function () {
	      _this6._list.refresh();
	    });
	  }
	};
	var view$15 = exports.protoUI(api$15, AtomDataLoader, layout.view);

	// #include ui/list.js

	var api$16 = {
	  name: "menu",
	  _listClassName: "webix_menu",
	  $init: function (config) {
	    this.data._scheme_init = bind(function (obj) {
	      if (obj.disabled) this.data.addMark(obj.id, "webix_disabled", true, 1, true);
	    }, this);

	    if (config.autowidth) {
	      this._autowidth_submenu = true;
	      delete config.autowidth;
	    }

	    this.data.attachEvent("onStoreUpdated", bind(function () {
	      this._hide_sub_menu();
	    }, this));
	    this.attachEvent("onMouseMove", this._mouse_move_menu);
	    this.attachEvent("onMouseOut", function (e) {
	      if (this._menu_was_activated() && this._settings.openAction == "click") return;
	      if (!this._child_menu_active && e.relatedTarget) this._hide_sub_menu();
	    });
	    this.attachEvent("onItemClick", function (id, e, trg) {
	      var item = this.getItem(id);

	      if (item) {
	        if (item.$template) return;
	        var parent = this.getTopMenu(); //ignore disabled items

	        if (!this.data.getMark(id, "webix_disabled")) {
	          if (!parent.callEvent("onMenuItemClick", [id, e, trg])) {
	            e.showpopup = true;
	            return;
	          }

	          if (this != parent) parent._call_onclick(id, e, trg); //click on group - do not close submenus

	          if (!item.submenu && !parent._show_child_on_click) {
	            parent._hide_sub_menu(true);

	            if (parent._hide_on_item_click) parent.hide();
	          } else {
	            if ((this === parent || env.touch) && parent._settings.openAction == "click") {
	              this._mouse_move_activation(id, trg);
	            } //do not close popups when clicking on menu folder


	            e.showpopup = true;
	          }
	        }
	      }
	    });
	    this.attachEvent("onKeyPress", function (code) {
	      if (code === 9) this.getTopMenu()._hide_sub_menu();else if (code === 13 || code === 32) {
	        var sel = this.getSelectedId(),
	            node;
	        if (sel) node = this.getItemNode(sel);
	        if (node) triggerEvent(node, "MouseEvents", "click");
	      }
	    });
	    this.data.attachEvent("onClearAll", function () {
	      this._hidden_items = [];
	    });
	    this.data._hidden_items = [];

	    this._viewobj.setAttribute("role", "menubar"); //component can create new view


	    this._destroy_with_me = [];
	  },
	  sizeToContent: function () {
	    if (this._settings.layout == "y") {
	      var texts = [];
	      var isSubmenu = false;
	      this.data.each(function (obj) {
	        texts.push(this._toHTML(obj));
	        if (obj.submenu) isSubmenu = true;
	      }, this); // text width + padding + borders+ arrow

	      this.config.width = getTextSize(texts, this.$view.className).width + 8 * 2 + 2 + (isSubmenu ? 15 : 0);
	      this.resize();
	    } else assert(false, "sizeToContent will work for vertical menu only");
	  },
	  getTopMenu: function () {
	    var parent = this;

	    while (parent._parent_menu) {
	      parent = $$(parent._parent_menu);
	    }

	    return parent;
	  },
	  _auto_height_calc: function (count) {
	    if (this._settings.autoheight) count = this.count();
	    var value = this.count(),
	        height = 0;

	    for (var i = 0; i < count; i++) {
	      var item = this.data.pull[this.data.order[i]];

	      if (item && item.$template == "Separator") {
	        height += 4;
	        if (!this._settings.autoheight) count++;
	      } else height += this.type.height;
	    }

	    this._onoff_scroll(count && count < value, "y");

	    return height;
	  },
	  on_mouse_move: {},
	  type: {
	    _submenu: function (obj) {
	      return obj.submenu || obj.data || obj.item;
	    },
	    css: "menu",
	    width: "auto",
	    aria: function (obj, common, marks) {
	      return "role=\"menuitem\"" + (marks && marks.webix_selected ? " aria-selected=\"true\" tabindex=\"0\"" : "tabindex=\"-1\"") + (common._submenu(obj) ? "aria-haspopup=\"true\"" : "") + (marks && marks.webix_disabled ? " aria-disabled=\"true\"" : "");
	    },
	    templateStart: function (obj, common, mark) {
	      if (obj.$template === "Separator" || obj.$template === "Spacer") {
	        return "<div webix_l_id=\"#id#\" role=\"separator\" tabindex=\"-1\" class=\"webix_context_" + obj.$template.toLowerCase() + "\">";
	      }

	      var link = (obj.href ? " href='" + obj.href + "' " : "") + (obj.target ? " target='" + obj.target + "' " : "");
	      return list.api.type.templateStart(obj, common, mark).replace(/^<div/, "<a " + link) + (common._submenu(obj) && common.subsign ? "<div class='webix_submenu_icon'></div>" : "");
	    },
	    templateEnd: function (obj) {
	      return obj.$template === "Separator" || obj.$template === "Spacer" ? "</div>" : "</a>";
	    },
	    templateSeparator: template("<div class='sep_line'></div>"),
	    templateSpacer: template("<div></div>")
	  },
	  getMenu: function (id) {
	    if (!this.data.pull[id]) {
	      for (var subid in this.data.pull) {
	        var obj = this.getItem(subid);

	        if (obj.submenu) {
	          var search = this._get_submenu(obj).getMenu(id);

	          if (search) return search;
	        }
	      }
	    } else return this;
	  },
	  getSubMenu: function (id) {
	    var menu = this.getMenu(id);
	    var obj = menu.getItem(id);
	    return obj.submenu ? menu._get_submenu(obj) : null;
	  },
	  getMenuItem: function (id) {
	    return this.getMenu(id).getItem(id);
	  },
	  _get_submenu: function (data) {
	    var sub = $$(data.submenu);

	    if (!sub) {
	      data.submenu = this._create_sub_menu(data);
	      sub = $$(data.submenu);
	    }

	    return sub;
	  },
	  _mouse_move_menu: function (id, e, target) {
	    if (!this._menu_was_activated()) return;

	    this._mouse_move_activation(id, target);
	  },
	  _menu_was_activated: function () {
	    var top = this.getTopMenu();

	    if (top._settings.openAction == "click") {
	      if (env.touch) return false;
	      var sub = top._open_sub_menu;
	      if (sub && $$(sub).isVisible()) return true;
	      return false;
	    }

	    return true;
	  },
	  _mouse_move_activation: function (id, target) {
	    var data = this.getItem(id);
	    if (!data) return; //clear flag of submenu usage

	    this._child_menu_active = null; //hide previously opened sub-menu

	    if (this._open_sub_menu && data.submenu != this._open_sub_menu) this._hide_sub_menu(true); //show submenu

	    if (this.type._submenu(data) && !this.config.hidden) {
	      var sub = this._get_submenu(data);

	      if (this.data.getMark(id, "webix_disabled")) return;
	      sub.show(target, {
	        pos: this._settings.subMenuPos
	      });
	      sub._parent_menu = this._settings.id;
	      this._open_sub_menu = data.submenu;
	    }
	  },
	  disableItem: function (id) {
	    this.getMenu(id).addCss(id, "webix_disabled");
	  },
	  enableItem: function (id) {
	    this.getMenu(id).removeCss(id, "webix_disabled");
	  },
	  _set_item_hidden: function (id, state) {
	    var menu = this.data;

	    if (menu._hidden_items[id] != state) {
	      menu._hidden_items[id] = state;
	      menu.filter(function (obj) {
	        return !menu._hidden_items[obj.id];
	      });
	      this.resize();
	    }
	  },
	  hideItem: function (id) {
	    var menu = this.getMenu(id);
	    if (menu) menu._set_item_hidden(id, true);
	  },
	  showItem: function (id) {
	    var menu = this.getMenu(id);

	    if (menu) {
	      menu._set_item_hidden(id, false);

	      return list.api.showItem.call(menu, id);
	    }
	  },
	  _hide_sub_menu: function (mode) {
	    if (this._open_sub_menu) {
	      //recursive sub-closing
	      var sub = $$(this._open_sub_menu);
	      if (sub._hide_sub_menu) //custom context may not have submenu
	        sub._hide_sub_menu(mode);

	      if (mode || !sub._show_on_mouse_out) {
	        sub.hide();
	        this._open_sub_menu = null;
	      }
	    }
	  },
	  _create_sub_menu: function (data) {
	    var listConfig = {
	      view: "submenu",
	      data: this.type._submenu(data)
	    };

	    var settings = this.getTopMenu()._settings.submenuConfig;

	    if (settings) exports.extend(listConfig, settings, true);
	    var parentData = this.getMenuItem(data.id);
	    if (parentData && parentData.config) exports.extend(listConfig, parentData.config, true);
	    var menu = ui(listConfig);

	    this._destroy_with_me.push(menu);

	    menu._parent_menu = this;
	    return menu._settings.id;
	  },
	  _skip_item: function (id, prev, mode) {
	    var item = this.getItem(id);

	    if (item.$template == "Separator" || item.$template == "Spacer" || this.data.getMark(id, "webix_disabled")) {
	      var index$$1 = this.getIndexById(id) + (mode == "up" ? -1 : 1);
	      id = index$$1 >= 0 ? this.getIdByIndex(index$$1) : null;
	      return id ? this._skip_item(id, prev, mode) : prev;
	    } else return id;
	  },
	  $skin: function () {
	    list.api.$skin.call(this);
	    this.type.height = $active.menuHeight;
	  },
	  defaults: {
	    scroll: "",
	    layout: "x",
	    mouseEventDelay: 100,
	    subMenuPos: "bottom"
	  }
	};
	var view$16 = exports.protoUI(api$16, list.view);
	var menu = {
	  api: api$16,
	  view: view$16
	};

	var api$17 = {
	  name: "submenu",
	  $init: function () {
	    this._body_cell = clone(this._dummy_cell_interface);
	    this._body_cell._view = this;
	    this.attachEvent("onMouseOut", function (e) {
	      if (this.getTopMenu()._settings.openAction == "click") return;
	      if (!this._child_menu_active && !this._show_on_mouse_out && e.relatedTarget) this.hide();
	    }); //inform parent that focus is still in menu

	    this.attachEvent("onMouseMoving", function () {
	      if (this._parent_menu) $$(this._parent_menu)._child_menu_active = true;
	    });
	    this.attachEvent("onBeforeShow", function () {
	      if (this.getTopMenu()._autowidth_submenu && this.sizeToContent && !this.isVisible()) this.sizeToContent();
	    });

	    this._dataobj.setAttribute("role", "menu");
	  },
	  $skin: function () {
	    menu.api.$skin.call(this);
	    popup.api.$skin.call(this);
	    this.type.height = $active.menuHeight;
	  },
	  _dummy_cell_interface: {
	    $getSize: function (dx, dy) {
	      //we saving height and width, as list can hardcode new values
	      var h = this._view._settings.height * 1;
	      var w = this._view._settings.width * 1;
	      var size = menu.api.$getSize.call(this._view, dx, dy); //restoring

	      this._view._settings.height = h;
	      this._view._settings.width = w;
	      return size;
	    },
	    $setSize: function (x, y) {
	      if (this._view._settings.scroll) this._view._bodyobj.style.height = y + "px";
	    },
	    destructor: function () {
	      this._view = null;
	    }
	  },
	  //ignore body element
	  body_setter: function () {},
	  getChildViews: function () {
	    return [];
	  },
	  defaults: {
	    width: 150,
	    subMenuPos: "right",
	    layout: "y",
	    autoheight: true
	  },
	  type: {
	    height: $active.menuHeight,
	    subsign: true
	  }
	};
	var view$17 = exports.protoUI(api$17, menu.view, popup.view);
	var submenu = {
	  api: api$17,
	  view: view$17
	};

	var api$18 = {
	  name: "sidemenu",
	  defaults: {
	    animate: true,
	    position: "left",
	    width: 200,
	    borderless: true
	  },
	  $init: function () {
	    this.$view.className += " webix_sidemenu";
	  },
	  $skin: function () {
	    this.defaults.padding = 0;
	  },
	  position_setter: function (value) {
	    var prevPosition = this._settings.position;
	    if (prevPosition) removeCss(this.$view, " webix_sidemenu_" + prevPosition);
	    addCss(this.$view, " webix_sidemenu_" + value);
	    return value;
	  },
	  $getSize: function () {
	    var sizes = window$1.api.$getSize.apply(this, arguments);
	    this._desired_sizes = sizes;
	    return sizes;
	  },
	  $setSize: function (x, y) {
	    base.api.$setSize.call(this, x, y);
	    x = this._content_width - this._settings.padding * 2;
	    y = this._content_height - this._settings.padding * 2;
	    this._contentobj.style.padding = this._settings.padding + "px";
	    this._headobj.style.display = "none";
	    this._bodyobj.style.height = y + "px";

	    this._body_cell.$setSize(x, y);
	  },
	  show: function () {
	    if (!this.callEvent("onBeforeShow", arguments)) return false;
	    this._settings.hidden = false;
	    this._viewobj.style.zIndex = this._settings.zIndex || zIndex();

	    if (this._settings.modal || this._modal) {
	      this._modal_set(true);

	      this._modal = null; // hidden_setter handling
	    }

	    this._viewobj.style.display = "block";

	    this._render_hidden_views();

	    if (this._settings.position) this._setPosition();
	    this._hide_timer = 1;
	    delay(function () {
	      this._hide_timer = 0;
	    }, this, [], env.touch ? 400 : 100);

	    if (this.config.autofocus) {
	      this._prev_focus = UIManager.getFocus();
	      UIManager.setFocus(this);
	    }

	    if (-1 == state._popups.find(this)) state._popups.push(this);
	    this.callEvent("onShow", []);
	  },
	  _setPosition: function (x) {
	    var width,
	        height,
	        maxWidth,
	        maxHeight,
	        position,
	        left = 0,
	        top = 0,
	        state$$1 = {};
	    this.$view.style.position = "fixed";
	    maxWidth = document.documentElement.offsetWidth;
	    maxHeight = document.documentElement.offsetHeight;
	    width = this._desired_sizes[0] || maxWidth;
	    height = this._desired_sizes[2] || maxHeight;
	    assert(width && height, "Attempt to show not rendered window");
	    position = this._settings.position;

	    if (position == "top") {
	      width = maxWidth;
	    } else if (position == "right") {
	      height = maxHeight;
	      left = maxWidth - width;
	    } else if (position == "bottom") {
	      width = maxWidth;
	      top = maxHeight - height;
	    } else {
	      height = maxHeight;
	    }

	    state$$1 = {
	      left: left,
	      top: top,
	      width: width,
	      height: height,
	      maxWidth: maxWidth,
	      maxHeight: maxHeight
	    };
	    if (typeof this._settings.state == "function") this._settings.state.call(this, state$$1);
	    this._state = state$$1;
	    this.$setSize(state$$1.width, state$$1.height);

	    if (typeof x == "undefined" && this._isAnimationSupported()) {
	      removeCss(this.$view, "webix_animate", true); // set initial state

	      this._animate[this._settings.position].beforeShow.call(this, state$$1); // set apply animation css


	      delay(function () {
	        addCss(this.$view, "webix_animate", true);
	      }, this, null, 1); // animate popup

	      delay(function () {
	        this._animate[this._settings.position].show.call(this, state$$1);
	      }, this, null, 10);
	    } else {
	      if (this._settings.position === "right") state$$1.left = state$$1.right ? maxWidth - state$$1.width - state$$1.right : maxWidth - state$$1.width;
	      this.setPosition(state$$1.left, state$$1.top);
	    }
	  },
	  _isAnimationSupported: function () {
	    return animate.isSupported() && this._settings.animate && !(env.isIE && navigator.appVersion.indexOf("MSIE 9") != -1);
	  },
	  hidden_setter: function (value) {
	    if (value) this.hide(true);else this.show();
	    return !!value;
	  },
	  _animate: {
	    left: {
	      beforeShow: function (state$$1) {
	        this.$view.style.left = -state$$1.width + "px";
	        this.$view.style.top = state$$1.top + "px";
	      },
	      show: function (state$$1) {
	        this.$view.style.left = state$$1.left ? state$$1.left + "px" : "0px";
	      },
	      hide: function (state$$1) {
	        this.$view.style.left = -state$$1.width + "px";
	      }
	    },
	    right: {
	      beforeShow: function (state$$1) {
	        this.$view.style.left = "auto";
	        this.$view.style.right = -state$$1.width + "px";
	        this.$view.style.top = state$$1.top + "px";
	      },
	      show: function (state$$1) {
	        this.$view.style.right = state$$1.right ? state$$1.right + "px" : "0px";
	      },
	      hide: function (state$$1) {
	        this.$view.style.right = -state$$1.width + "px";
	      }
	    },
	    top: {
	      beforeShow: function (state$$1) {
	        this.setPosition(state$$1.left, state$$1.top);
	        this.$view.style.height = "0px";
	        this._bodyobj.style.height = "0px";
	      },
	      show: function (state$$1) {
	        this.$view.style.height = state$$1.height + "px";
	        this._bodyobj.style.height = state$$1.height + "px";
	      },
	      hide: function () {
	        this.$view.style.height = "0px";
	        this._bodyobj.style.height = "0px";
	      }
	    },
	    bottom: {
	      beforeShow: function (state$$1) {
	        this.$view.style.left = state$$1.left + "px";
	        this.$view.style.top = "auto";
	        var bottom = state$$1.bottom != undefined ? state$$1.bottom : state$$1.maxHeight - state$$1.top - state$$1.height;
	        this.$view.style.bottom = bottom + "px";
	        this.$view.style.height = "0px";
	      },
	      show: function (state$$1) {
	        this.$view.style.height = state$$1.height + "px";
	      },
	      hide: function () {
	        this.$view.style.height = "0px";
	      }
	    }
	  },
	  hide: function (force) {
	    if (this.$destructed) return;
	    if (this._settings.modal) this._modal_set(false);
	    var maxWidth = document.documentElement.offsetWidth;
	    var maxHeight = document.documentElement.offsetHeight;

	    if (!force && this._isAnimationSupported() && maxWidth == this._state.maxWidth && maxHeight == this._state.maxHeight) {
	      // call 'hide' animation handler
	      this._animate[this._settings.position].hide.call(this, this._state); // hide popup


	      var tid = event$1(this.$view, env.transitionEnd, bind(function () {
	        this._hide_callback();

	        eventRemove(tid);
	      }, this));
	    } else {
	      this._hide_callback();
	    }

	    if (this._settings.autofocus) {
	      var el = document.activeElement;

	      if (el && this._viewobj && this._viewobj.contains(el)) {
	        UIManager.setFocus(this._prev_focus);
	        this._prev_focus = null;
	      }
	    }

	    this._hide_sub_popups();
	  }
	};
	var view$18 = exports.protoUI(api$18, popup.view);

	var api$19 = {
	  name: "sidebar",
	  defaults: {
	    type: "sideBar",
	    activeTitle: true,
	    select: true,
	    scroll: false,
	    collapsed: false,
	    collapsedWidth: 44,
	    position: "left",
	    width: 250,
	    mouseEventDelay: 10
	  },
	  $skin: function () {
	    this.defaults.titleHeight = $active.sidebarTitleHeight;
	  },
	  $init: function () {
	    this.$ready.push(this._initSidebar);
	    this.$ready.push(this._initContextMenu);

	    this.data._scheme_init = function (obj) {
	      if (obj.data) obj.menu = copy(obj.data);else if (obj.item) //xml child records, can be {} or []
	        obj.menu = copy(obj.item.length ? obj.item : [obj.item]);
	    };
	  },
	  on_context: {},
	  on_mouse_move: {},
	  _initSidebar: function () {
	    this._fullWidth = this.config.width;
	    this.attachEvent("onBeforeOpen", function (id) {
	      if (!this.config.multipleOpen) {
	        var open = this.getOpenItems();

	        for (var i = 0; i < open.length; i++) {
	          if (this.getParentId(id) == this.getParentId(open[i])) this.close(open[i]);
	        }
	      }

	      return !this.config.collapsed;
	    });
	    this.attachEvent("onItemClick", function (id, ev, node) {
	      if (this.getPopup() && !this.getPopup().config.hidden) ev.showpopup = true;
	      if (env.touch) this._showPopup(id, node);
	    });
	    this.attachEvent("onBeforeSelect", function (id) {
	      if (!this.getItem(id).$count) {
	        this.clearCss("webix_sidebar_selected");
	        return true;
	      }

	      return false;
	    });
	    this.attachEvent("onAfterSelect", function (id) {
	      this._markMenu(this, id, !$active.sidebarMarkAll);

	      this.getPopup()._onMasterSelect(id);
	    });
	    this.attachEvent("onMouseMove", function (id, ev, node) {
	      this._showPopup(id, node);
	    });
	    if (this.config.collapsed) this.collapse();
	  },
	  _showPopup: function (id, node) {
	    if (this.config.collapsed) {
	      var popup = this.getPopup();

	      if (popup) {
	        this._updateTitle(id);

	        this._updateList(id);

	        popup.show(node, {
	          x: this.config.position == "left" ? this.config.collapsedWidth : -popup.config.width,
	          y: -1
	        });
	      }
	    }
	  },
	  _updateTitle: function (id) {
	    var popup = this.getPopup();
	    var title = popup.getBody().getChildViews()[0];
	    if (!title || title.masterId == id) return;
	    var selectedId = this.getSelectedId();
	    title.masterId = id;
	    title.parse(this.getItem(id));

	    if (selectedId && this.getParentId(selectedId) == id) {
	      addCss(title.$view, "webix_sidebar_selected", true);
	    } else {
	      removeCss(title.$view, "webix_sidebar_selected");
	    }

	    if (selectedId == id) {
	      addCss(title.$view, "webix_selected", true);
	    } else {
	      removeCss(title.$view, "webix_selected");
	    }
	  },
	  _updateList: function (id) {
	    var popup = this.getPopup();
	    var list = popup.getBody().getChildViews()[1];
	    if (!list || list.masterId == id) return;
	    if (this.exists(list.masterId) && this.getItem(list.masterId).menu) this.updateItem(list.masterId, {
	      menu: list.data.serialize()
	    });
	    list.clearCss("webix_sidebar_selected");
	    list.masterId = id;
	    var selectedId = this.getSelectedId();
	    var data = copy(this.getItem(id).menu || []);
	    list.unselect();

	    if (data.length) {
	      list.show();
	      list.data.importData(data);
	      if (list.exists(selectedId)) list.select(selectedId);else if (selectedId) this._markMenu(list, selectedId);
	    } else {
	      list.hide();
	      list.data.clearAll();
	    }
	  },
	  _initContextMenu: function () {
	    var master = this,
	        config = master.config,
	        popup;

	    if (config.popup) {
	      popup = $$(config.popup);
	    }

	    if (!popup) {
	      var dirClassName = config.position == "left" ? "webix_sidebar_popup_left" : "webix_sidebar_popup_right";
	      var subMenuPos = config.position == "left" ? "right" : "left";

	      var menuTemplate = function (obj) {
	        var icon = "wxi-angle-" + (config.position == "left" ? "right" : "left");
	        var arrow = obj.submenu || obj.data || obj.item ? "<div class=\"webix_icon " + icon + "\"></div>" : "";
	        return arrow + obj.value;
	      };

	      var popupConfig = {
	        view: "popup",
	        css: "webix_sidebar_popup " + dirClassName + " " + config.css,
	        autofit: false,
	        width: this._fullWidth - this.config.collapsedWidth,
	        borderless: true,
	        padding: 0,
	        body: {
	          rows: [{
	            view: "template",
	            borderless: true,
	            css: "webix_sidebar_popup_title",
	            template: "#value#",
	            height: this.config.titleHeight + 2,
	            onClick: {
	              webix_template: function () {
	                var id = this.masterId;
	                if (!master.getItem(id).$count) master.select(id);
	              }
	            }
	          }, {
	            view: "menu",
	            submenu: "data",
	            layout: "y",
	            subMenuPos: subMenuPos,
	            select: true,
	            borderless: true,
	            autoheight: true,
	            css: "webix_sidebar_popup_list " + dirClassName + " " + config.css,
	            template: menuTemplate,
	            type: {
	              subsign: false
	            },
	            submenuConfig: {
	              padding: 0,
	              subMenuPos: subMenuPos,
	              template: menuTemplate,
	              select: true,
	              type: {
	                subsign: false
	              },
	              css: "webix_sidebar_popup_list " + dirClassName + " " + config.css,
	              on: {
	                onShow: function () {
	                  this.clearCss("webix_sidebar_selected");
	                  this.unselectAll();
	                  var sel = master.getSelectedId();
	                  if (sel && this.exists(sel)) this.select(sel);else if (sel) master._markMenu(this, sel);
	                },
	                onBeforeSelect: function (id) {
	                  if (this.getSubMenu(id)) return false;
	                },
	                onAfterSelect: function (id) {
	                  var menu = master.getPopup().queryView({
	                    view: "menu"
	                  });
	                  var parent = master.getParentId(id);

	                  while (parent) {
	                    var sub = menu.getMenu(parent);

	                    if (sub) {
	                      sub.unselectAll();

	                      master._markMenu(sub, id);
	                    }

	                    parent = master.getParentId(parent);
	                  }

	                  master._markMenu(this, id);
	                }
	              }
	            },
	            on: {
	              onBeforeSelect: function (id) {
	                if (this.getSubMenu(id)) return false;
	              },
	              onMenuItemClick: function (id) {
	                if (!this.getSubMenu(id)) master.select(id);
	              }
	            }
	          }]
	        }
	      };
	      exports.extend(popupConfig, config.popup || {}, true);
	      popup = ui(popupConfig);

	      popup._onMasterSelect = function (id) {
	        if (master && master.getParentId(id) == this.masterId) {
	          addCss(this.$view, "webix_sidebar_selected", true);
	        }

	        if (master.config.collapsed && master.getItem(id).$level == 1) {
	          var title = popup.getBody().getChildViews()[0];
	          if (title) addCss(title.$view, "webix_selected", true);
	        }
	      };

	      popup.queryView({
	        view: "menu"
	      })._show_child_on_click = true;
	    }

	    popup.attachEvent("onBeforeShow", function () {
	      return config.collapsed;
	    });
	    this._destroy_with_me = [popup];
	    config.popupId = popup.config.id;

	    _event(document.body, "mousemove", function (e) {
	      var trg = e.target || e.srcElement;

	      if (!popup.config.hidden && !popup.$view.contains(trg) && !this.$view.firstChild.contains(trg) && !popup.queryView({
	        view: "menu"
	      })._open_sub_menu) {
	        popup.hide();
	      }
	    }, {
	      bind: this
	    });
	  },
	  _markMenu: function (view, sel, topOnly) {
	    var css = "webix_sidebar_selected";
	    view.data.each(function (obj) {
	      if (this._isChild(sel, obj.id) && (!topOnly || this.getParentId(obj.id) == "0")) view.addCss(obj.id, css);else if (view.hasCss(obj.id, css)) view.removeCss(obj.id, css);
	    }, this);
	  },
	  _isChild: function (cid, pid) {
	    var parent = this.getParentId(cid);
	    if (pid == parent) return true;
	    if (parent) return this._isChild(parent, pid);
	    return false;
	  },
	  getPopup: function () {
	    return $$(this.config.popupId);
	  },
	  position_setter: function (value) {
	    var newPos = value;
	    var oldPos = value == "left" ? "right" : "left";
	    removeCss(this.$view, "webix_sidebar_" + oldPos);
	    addCss(this.$view, "webix_sidebar_" + newPos, true);
	    var popup = this.getPopup();

	    if (popup) {
	      var popupEl = popup.$view;
	      removeCss(popupEl, "webix_sidebar_popup_" + oldPos);
	      addCss(popupEl, "webix_sidebar_popup_" + newPos, true);
	    }

	    return value;
	  },
	  collapse: function () {
	    this.define("collapsed", true);
	  },
	  expand: function () {
	    this.define("collapsed", false);
	  },
	  toggle: function () {
	    var collapsed = !this.config.collapsed;
	    this.define("collapsed", collapsed);
	  },
	  collapsed_setter: function (value) {
	    var width;

	    if (!value) {
	      width = this._fullWidth;
	      this.type.collapsed = false;
	      addCss(this.$view, "webix_sidebar_expanded", true);
	    } else {
	      width = this.config.collapsedWidth;
	      this.closeAll();
	      this.type.collapsed = true;
	      removeCss(this.$view, "webix_sidebar_expanded");
	    }

	    this.define("width", width);
	    this.resize();
	    return value;
	  },
	  getState: function () {
	    var state = {
	      collapsed: this.config.collapsed
	    };
	    exports.extend(state, TreeAPI.getState.call(this));
	    return state;
	  },
	  setState: function (state) {
	    TreeAPI.setState.call(this, state);
	    this.define("collapsed", state.collapsed);
	  }
	};
	type(tree.view, {
	  name: "sideBar",
	  height: "auto",
	  css: "webix_sidebar",
	  template: function (obj, common) {
	    if (common.collapsed) return common.icon(obj, common);
	    return common.arrow(obj, common) + common.icon(obj, common) + "<span>" + obj.value + "</span>";
	  },
	  arrow: function (obj) {
	    var html = "";

	    for (var i = 1; i <= obj.$level; i++) {
	      if (i == obj.$level && obj.$count) {
	        var icon = "wxi-angle-" + (obj.open ? "down" : "left");
	        var className = "webix_sidebar_dir_icon webix_icon " + icon;
	        html += "<span class='" + className + "'></span>";
	      }
	    }

	    return html;
	  },
	  icon: function (obj) {
	    var style = "";

	    if (obj.$level > 2) {
	      style = "style=\"padding-left:" + 40 * (obj.$level - 2) + "px\"";
	    }

	    if (obj.icon) return "<span class='webix_icon webix_sidebar_icon " + obj.icon + "' " + style + "></span>";
	    return "<span " + style + "></span>";
	  }
	});
	var view$19 = exports.protoUI(api$19, tree.view);

	var api$1a = {
	  name: "context"
	};
	var view$1a = exports.protoUI(api$1a, ContextHelper, popup.view);

	var api$1b = {
	  name: "contextmenu",
	  _hide_on_item_click: true,
	  $init: function (config) {
	    if (config.submenuConfig) exports.extend(config, config.submenuConfig);
	  }
	};
	var view$1b = exports.protoUI(api$1b, ContextHelper, submenu.view);

	var api$1c = {
	  name: "vscroll",
	  $apiOnly: true,
	  defaults: {
	    scroll: "x",
	    scrollStep: 40,
	    scrollPos: 0,
	    scrollSize: 18,
	    scrollVisible: 1,
	    zoom: 1
	  },
	  $init: function (config) {
	    var dir = config.scroll || "x";
	    var node = this._viewobj = toNode(config.container);
	    node.className += " webix_vscroll_" + dir;
	    node.innerHTML = "<div class='webix_vscroll_body'></div>";

	    _event(node, "scroll", this._onscroll, {
	      bind: this
	    });

	    this._last_set_size = 0;
	  },
	  reset: function () {
	    this.config.scrollPos = 0;
	    this._viewobj[this.config.scroll == "x" ? "scrollLeft" : "scrollTop"] = 0;
	  },
	  _check_quantum: function (value) {
	    if (value > 1500000) {
	      this._settings.zoom = value / 1000000;
	      value = 1000000;
	    } else {
	      this._settings.zoom = 1;
	    }

	    return value;
	  },
	  scrollWidth_setter: function (value) {
	    value = this._check_quantum(value);
	    this._viewobj.firstChild.style.width = value + "px";
	    return value;
	  },
	  scrollHeight_setter: function (value) {
	    value = this._check_quantum(value);
	    this._viewobj.firstChild.style.height = value + "px";
	    return value;
	  },
	  sizeTo: function (value, top, bottom) {
	    value = value - (top || 0) - (bottom || 0);
	    var width = this._settings.scrollSize; //IEFix
	    //IE doesn't react on scroll-click if it has not at least 1 px of visible content

	    if (env.isIE && width) width += 1;

	    if (!width && this._settings.scrollVisible && !env.$customScroll) {
	      this._viewobj.style.pointerEvents = "none";
	      width = 14;
	    }

	    if (!width) {
	      this._viewobj.style.display = "none";
	    } else {
	      this._viewobj.style.display = "block";
	      if (top) this._viewobj.style.marginTop = top + "px";
	      this._viewobj.style[this._settings.scroll == "x" ? "width" : "height"] = Math.max(0, value) + "px";
	      this._viewobj.style[this._settings.scroll == "x" ? "height" : "width"] = width + "px";
	    }

	    this._last_set_size = value;
	  },
	  getScroll: function () {
	    return Math.round(this._settings.scrollPos * this._settings.zoom);
	  },
	  getSize: function () {
	    return Math.round((this._settings.scrollWidth || this._settings.scrollHeight) * this._settings.zoom);
	  },
	  scrollTo: function (value) {
	    if (value < 0) value = 0;
	    var config = this._settings;
	    value = value / config.zoom; //safety check for negative values

	    if (value < 0) value = 0; //apply new position

	    if (value != this._settings.scrollPos) {
	      this._viewobj[config.scroll == "x" ? "scrollLeft" : "scrollTop"] = value;

	      this._onscroll_inner(value, true);

	      return true;
	    }
	  },
	  _onscroll: function () {
	    var x = this._viewobj[this._settings.scroll == "x" ? "scrollLeft" : "scrollTop"];
	    if (Math.floor(x) != Math.floor(this._settings.scrollPos)) this._onscroll_inner(x, false);
	  },
	  _onscroll_inner: function (value, api) {
	    //size of scroll area
	    var height = this._settings.scrollWidth || this._settings.scrollHeight; //if we scrolled to the end of the area

	    if (value >= height - this._last_set_size / (api ? this._settings.zoom : 1)) {
	      //set value so the last row is visible
	      value = Math.max(0, height - this._last_set_size / this._settings.zoom);
	    }

	    this._settings.scrollPos = value || 0;
	    this.callEvent("onScroll", [this.getScroll()]);
	  },
	  activeArea: function (area, x_mode) {
	    this._x_scroll_mode = x_mode;

	    _event(area, env.isIE8 ? "mousewheel" : "wheel", this._on_wheel, {
	      bind: this,
	      passive: false
	    });

	    this._add_touch_events(area);
	  },
	  _add_touch_events: function (area) {
	    if (!env.touch && window.navigator.pointerEnabled) {
	      addCss(area, "webix_scroll_touch_ie", true);

	      _event(area, "pointerdown", function (e) {
	        if (e.pointerType == "touch" || e.pointerType == "pen") {
	          this._start_context = Touch._get_context_m(e);
	          this._start_scroll_pos = this.getScroll();
	        }
	      }, {
	        bind: this
	      });

	      event$1(document.body, "pointermove", function (e) {
	        var scroll;

	        if (this._start_context) {
	          this._current_context = Touch._get_context_m(e);

	          if (this._settings.scroll == "x") {
	            scroll = this._current_context.x - this._start_context.x;
	          } else if (this._settings.scroll == "y") {
	            scroll = this._current_context.y - this._start_context.y;
	          }

	          if (scroll && Math.abs(scroll) > 5) {
	            this.scrollTo(this._start_scroll_pos - scroll);
	          }
	        }
	      }, {
	        bind: this
	      });
	      event$1(window, "pointerup", function () {
	        if (this._start_context) {
	          this._start_context = this._current_context = null;
	        }
	      }, {
	        bind: this
	      });
	    }
	  },
	  _on_wheel: function (e) {
	    var dir = 0;
	    var step = e.deltaMode === 0 ? 30 : 1;
	    if (env.isIE8) dir = e.detail = -e.wheelDelta / 30;

	    if (e.deltaX && Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
	      //x-scroll
	      if (this._x_scroll_mode && this._settings.scrollVisible) dir = e.deltaX / step;
	    } else {
	      //y-scroll
	      if (!this._x_scroll_mode && this._settings.scrollVisible) {
	        if (isUndefined(e.deltaY)) dir = e.detail;else dir = e.deltaY / step;
	      }
	    } // Safari requires target preserving
	    // (used in _check_rendered_cols of DataTable)


	    if (env.isSafari) this._scroll_trg = e.target || e.srcElement;
	    if (dir) if (this.scrollTo(this.getScroll() + dir * this._settings.scrollStep)) return preventEvent(e);
	  }
	};
	var view$1c = exports.protoUI(api$1c, EventSystem, Settings);

	var temp$3 = {};

	var Mixin = {
	  filterByAll: function () {
	    //we need to use dynamic function creating
	    var server = false;
	    this.data.silent(function () {
	      this.filter();
	      var first = false;

	      for (var key in this._filter_elements) {
	        assert(key, "empty column id for column with filtering");
	        if (!this.isColumnVisible(key)) continue;
	        var record = this._filter_elements[key];
	        var originvalue = record[2].getValue(record[0]); //saving last filter value, for usage in getState

	        var inputvalue = originvalue;
	        if (record[1].prepare) inputvalue = record[1].prepare.call(record[2], inputvalue, record[1], this); //preserve original value

	        record[1].value = originvalue;
	        var compare = record[1].compare;
	        if (!this.callEvent("onBeforeFilter", [key, inputvalue, record[1]])) continue;

	        if (record[2].$server || server) {
	          //if one of filters is server side, do not run any client side filters
	          server = true;
	        } else {
	          if (inputvalue === "") continue;

	          if (compare) {
	            compare = this._multi_compare(key, compare);
	            this.filter(bind(function (obj, value) {
	              if (!obj) return false;
	              return compare(obj[key], value, obj);
	            }, this), inputvalue, first);
	          } else this.filter(key, inputvalue, first);

	          first = true;
	        }
	      }

	      if (server) this._runServerFilter();
	    }, this);

	    if (!server) {
	      this.refresh();
	      this.callEvent("onAfterFilter", []);
	    }
	  },
	  _multi_compare: function (key, compare) {
	    var column = this.getColumnConfig(key);
	    var separator = column ? column.optionslist : null; //default mode

	    if (!separator) return compare;
	    if (typeof separator != "string") separator = ",";
	    return function (itemValue, inputValue, obj) {
	      if (!itemValue) return true;
	      var ids = itemValue.split(separator);

	      for (var i = 0; i < ids.length; i++) {
	        if (compare(ids[i], inputValue, obj)) return true;
	      }
	    };
	  },
	  filterMode_setter: function (mode) {
	    return exports.extend(this.data._filterMode, mode, true);
	  },
	  getFilter: function (columnId) {
	    var filter = this._filter_elements[columnId];
	    if (filter && filter[2].getInputNode) return filter[2].getInputNode(filter[0]);
	    return null;
	  },
	  registerFilter: function (node, config, obj) {
	    this._filter_elements[config.columnId] = [node, config, obj];
	  },
	  collectValues: function (id, mode) {
	    var values = [];
	    var checks = {
	      "": true
	    };
	    var obj = this.getColumnConfig(id);
	    var options = mode && mode.visible ? null : obj.options || obj.collection;

	    if (options) {
	      if (_typeof(options) == "object" && !options.loadNext) {
	        //raw object
	        if (isArray(options)) for (var i = 0; i < options.length; i++) {
	          values.push({
	            id: options[i],
	            value: options[i]
	          });
	        } else for (var key in options) {
	          values.push({
	            id: key,
	            value: options[key]
	          });
	        }
	        return values;
	      } else {
	        //view
	        if (typeof options === "string") options = $$(options);
	        if (options.getBody) options = options.getBody();

	        this._collectValues.call(options, "id", "value", values, checks);
	      }
	    } else this._collectValues(obj.id, obj.id, values, checks);

	    var result = {
	      values: values
	    };
	    this.callEvent("onCollectValues", [id, result]);
	    return result.values;
	  },
	  _collectValues: function (id, value, values, checks) {
	    this.data.each(function (obj) {
	      var test = obj ? obj[id] : "";

	      if (test !== undefined && !checks[test]) {
	        checks[test] = true;
	        var lineid = obj[id]; //special handling for 0 values
	        //convert to string to create a valid ID

	        if (lineid === 0) lineid = "0";
	        values.push({
	          id: lineid,
	          value: obj[value]
	        });
	      }
	    }, this, true);

	    if (values.length) {
	      var type = typeof values[0].value === "string" ? "string" : "raw";
	      values.sort(this.data.sorting.create({
	        as: type,
	        by: "value",
	        dir: "asc"
	      }));
	    }
	  },
	  _runServerFilter: function () {
	    var _this = this;

	    this.loadNext(0, 0, 0, 0, 1).then(function (data) {
	      if (_this.editStop) _this.editStop();

	      _this.clearAll(true);

	      _this.parse(data);

	      _this.callEvent("onAfterFilter", []);
	    });
	  }
	};

	var Mixin$1 = {
	  hover_setter: function (value) {
	    if (value && !this._hover_initialized) {
	      this._enable_mouse_move();

	      this.config.experimental = true;
	      this.attachEvent("onMouseMoving", function () {
	        var row = this.locate(arguments[0]);
	        row = row ? row.row : null;

	        if (this._last_hover != row) {
	          if (this._last_hover) this.removeRowCss(this._last_hover, this._settings.hover);
	          this._last_hover = row;
	          if (this._last_hover) this.addRowCss(this._last_hover, this._settings.hover);
	        }
	      });
	      event$1(this.$view, "mouseout", bind(function (e) {
	        if (this._last_hover && document.body.contains(e.target)) {
	          this.removeRowCss(this._last_hover, this._settings.hover);
	          this._last_hover = null;
	        }
	      }, this));
	      this._hover_initialized = 1;
	    }

	    return value;
	  },
	  select_setter: function (value) {
	    if (!this.select && value) {
	      exports.extend(this, this._selections._commonselect, true);
	      if (value === true) value = "row";else if (value == "multiselect") {
	        value = "row";
	        this._settings.multiselect = true;
	      }
	      assert(this._selections[value], "Unknown selection mode: " + value);
	      exports.extend(this, this._selections[value], true);
	    }

	    return value;
	  },
	  getSelectedId: function (mode) {
	    return mode ? [] : ""; //dummy placeholder
	  },
	  getSelectedItem: function (mode) {
	    return SelectionModel.getSelectedItem.call(this, mode);
	  },
	  _selections: {
	    //shared methods for all selection models
	    _commonselect: {
	      _select_css: " webix_cell_select",
	      $init: function () {
	        this._reinit_selection();

	        this.on_click.webix_cell = bind(this._click_before_select, this); //temporary stab, actual handlers need to be created

	        this._data_cleared = this._data_filtered = function () {
	          this.unselect();
	        };

	        this.data.attachEvent("onStoreUpdated", bind(this._data_updated, this));
	        this.data.attachEvent("onSyncApply", bind(this._data_synced, this));
	        this.data.attachEvent("onClearAll", bind(this._data_cleared, this));
	        this.data.attachEvent("onAfterFilter", bind(this._data_filtered, this));
	        this.data.attachEvent("onIdChange", bind(this._id_changed, this));
	        this.$ready.push(SelectionModel._set_noselect);
	      },
	      _id_changed: function (oldid, newid) {
	        for (var i = 0; i < this._selected_rows.length; i++) {
	          if (this._selected_rows[i] == oldid) this._selected_rows[i] = newid;
	        }

	        for (var _i = 0; _i < this._selected_areas.length; _i++) {
	          var item = this._selected_areas[_i];

	          if (item.row == oldid) {
	            oldid = this._select_key(item);
	            item.row = newid;
	            newid = this._select_key(item);
	            item.id = newid;
	            delete this._selected_pull[oldid];
	            this._selected_pull[newid] = true;
	          }
	        }
	      },
	      _data_updated: function (id, obj, type) {
	        if (type == "delete") this.unselect(id);
	      },
	      _data_synced: function () {
	        for (var i = this._selected_areas.length - 1; i >= 0; i--) {
	          var row = this._selected_areas[i].row;

	          if (!this.exists(row)) {
	            this._selected_areas.splice(i, 1);

	            delete this._selected_pull[row];
	          }
	        }
	      },
	      _reinit_selection: function () {
	        //list of selected areas
	        this._selected_areas = []; //key-value hash of selected areas, for fast search

	        this._selected_pull = {}; //used to track selected cell objects

	        this._selected_rows = [];
	      },
	      isSelected: function (id, column) {
	        var key;
	        if (!isUndefined(column)) key = this._select_key({
	          row: id,
	          column: column
	        });else key = _typeof(id) === "object" ? this._select_key(id) : id;
	        return this._selected_pull[key];
	      },
	      getSelectedId: function (asArray, plain) {
	        var result; //if multiple selections was created - return array
	        //in case of single selection, return value or array, when asArray parameter provided

	        if (this._selected_areas.length > 1 || asArray) {
	          result = [].concat(this._selected_areas);
	          if (plain) for (var i = 0; i < result.length; i++) {
	            result[i] = result[i].id;
	          }
	        } else {
	          result = this._selected_areas[0];
	          if (plain && result) return result.id;
	        }

	        return result;
	      },
	      _id_to_string: function () {
	        return this.row;
	      },
	      _select: function (data, preserve) {
	        var key = this._select_key(data); //don't allow selection on unnamed columns


	        if (key === null) return;
	        if (preserve === -1) return this._unselect(data);
	        data.id = key;
	        data.toString = this._id_to_string;
	        if (!this.callEvent("onBeforeSelect", [data, preserve])) return false; //ignore area, if it was already selected and
	        // - we are preserving existing selection
	        // - this is the only selected area
	        // otherwise we need to clear other selected areas

	        if (this._selected_pull[key] && (preserve || this._selected_areas.length == 1)) return;
	        if (!preserve) this._clear_selection();

	        this._selected_areas.push(data);

	        this._selected_pull[key] = true;
	        this.callEvent("onAfterSelect", [data, preserve]);

	        this._finalize_select(this._post_select(data));

	        return true;
	      },
	      _clear_selection: function () {
	        if (!this._selected_areas.length) return false;

	        for (var i = 0; i < this._selected_areas.length; i++) {
	          if (!this.callEvent("onBeforeUnSelect", [this._selected_areas[i]])) return false;
	        }

	        for (var _i2 = 0; _i2 < this._selected_rows.length; _i2++) {
	          this.data.removeMark(this._selected_rows[_i2], "webix_selected");
	        }

	        var cols = this._settings.columns;
	        if (cols) for (var _i3 = 0; _i3 < cols.length; _i3++) {
	          cols[_i3].$selected = null;
	        }
	        var data = this._selected_areas;

	        this._reinit_selection();

	        for (var _i4 = 0; _i4 < data.length; _i4++) {
	          this.callEvent("onAfterUnSelect", [data[_i4]]);
	        }

	        return true;
	      },
	      unselectAll: function () {
	        this.clearSelection();
	      },
	      selectAll: function () {
	        this.selectRange();
	      },
	      clearSelection: function () {
	        if (this._clear_selection()) {
	          this.callEvent("onSelectChange", []);
	          this.render();
	        }
	      },
	      _unselect: function (data) {
	        var key = this._select_key(data);

	        if (!key && this._selected_areas.length) {
	          this.clearSelection();
	          this.callEvent("onSelectChange", []);
	        } //ignore area, if it was already selected


	        if (!this._selected_pull[key]) return;
	        if (!this.callEvent("onBeforeUnSelect", [data])) return false;

	        for (var i = 0; i < this._selected_areas.length; i++) {
	          if (this._selected_areas[i].id == key) {
	            this._selected_areas.splice(i, 1);

	            break;
	          }
	        }

	        delete this._selected_pull[key];
	        this.callEvent("onAfterUnSelect", [data]);

	        this._finalize_select(0, this._post_unselect(data));
	      },
	      _add_item_select: function (id) {
	        var item = this.getItem(id);
	        return this.data.addMark(item.id, "webix_selected", 0, {
	          $count: 0
	        }, true);
	      },
	      _finalize_select: function (id) {
	        if (id) this._selected_rows.push(id);

	        if (!this._silent_selection) {
	          this.render();
	          this.callEvent("onSelectChange", []);
	        }
	      },
	      _click_before_select: function (e, id) {
	        var preserve = e.ctrlKey || e.metaKey || this._settings.multiselect == "touch";
	        var range = e.shiftKey;
	        if (!this._settings.multiselect && this._settings.select != "multiselect" && this._settings.select != "area") preserve = range = false;

	        if (range && this._selected_areas.length) {
	          var last = this._selected_areas[this._selected_areas.length - 1];

	          this._selectRange(id, last);
	        } else {
	          if (preserve && this._selected_pull[this._select_key(id)]) this._unselect(id);else this._select({
	            row: id.row,
	            column: id.column
	          }, preserve);
	        }
	      },
	      _mapSelection: function (callback, column, row) {
	        var cols = this._settings.columns; //selected columns only

	        if (column) {
	          var temp = [];

	          for (var i = 0; i < cols.length; i++) {
	            if (cols[i].$selected) temp.push(cols[i]);
	          }

	          cols = temp;
	        }

	        var rows = this.data.order;
	        var row_ind = 0;

	        for (var _i5 = 0; _i5 < rows.length; _i5++) {
	          var item = this.getItem(rows[_i5]);
	          if (!item) continue; //dyn loading, row is not available

	          var selection = this.data.getMark(item.id, "webix_selected");

	          if (selection || column) {
	            var col_ind = 0;

	            for (var j = 0; j < cols.length; j++) {
	              var id = cols[j].id;

	              if (row || column || selection[id]) {
	                if (callback) item[id] = callback(item[id], rows[_i5], id, row_ind, col_ind);else return {
	                  row: rows[_i5],
	                  column: id
	                };
	                col_ind++;
	              }
	            } //use separate row counter, to count only selected rows


	            row_ind++;
	          }
	        }
	      }
	    },
	    row: {
	      _select_css: " webix_row_select",
	      _select_key: function (data) {
	        return data.row;
	      },
	      select: function (row_id, preserve) {
	        //when we are using id from mouse events
	        if (row_id) row_id = row_id.toString();
	        assert(this.data.exists(row_id), "Incorrect id in select command: " + row_id);

	        this._select({
	          row: row_id
	        }, preserve);
	      },
	      _post_select: function (data) {
	        this._add_item_select(data.row).$row = true;
	        return data.row;
	      },
	      unselect: function (row_id) {
	        this._unselect({
	          row: row_id
	        });
	      },
	      _post_unselect: function (data) {
	        this.data.removeMark(data.row, "webix_selected", 0, 1);
	        return data.row;
	      },
	      mapSelection: function (callback) {
	        return this._mapSelection(callback, false, true);
	      },
	      _selectRange: function (a, b) {
	        return this.selectRange(a.row, b.row);
	      },
	      selectRange: function (row_id, end_row_id, preserve) {
	        if (isUndefined(preserve)) preserve = true;
	        var row_start_ind = row_id ? this.getIndexById(row_id) : 0;
	        var row_end_ind = end_row_id ? this.getIndexById(end_row_id) : this.data.order.length - 1;

	        if (row_start_ind > row_end_ind) {
	          var temp = row_start_ind;
	          row_start_ind = row_end_ind;
	          row_end_ind = temp;
	        }

	        this._silent_selection = true;

	        for (var i = row_start_ind; i <= row_end_ind; i++) {
	          var id = this.getIdByIndex(i);

	          if (!id) {
	            if (row_id) this.select(row_id);
	            break;
	          }

	          this.select(id, preserve);
	        }

	        this._silent_selection = false;

	        this._finalize_select();
	      }
	    },
	    cell: {
	      _select_key: function (data) {
	        if (!data.column) return null;
	        return data.row + "_" + data.column;
	      },
	      select: function (row_id, column_id, preserve) {
	        assert(this.data.exists(row_id), "Incorrect id in select command: " + row_id);

	        this._select({
	          row: row_id,
	          column: column_id
	        }, preserve);
	      },
	      _post_select: function (data) {
	        var sel = this._add_item_select(data.row);

	        sel.$count++;
	        sel[data.column] = true;
	        return data.row;
	      },
	      unselect: function (row_id, column_id) {
	        this._unselect({
	          row: row_id,
	          column: column_id
	        });
	      },
	      _post_unselect: function (data) {
	        var sel = this._add_item_select(data.row);

	        sel.$count--;
	        sel[data.column] = false;
	        if (sel.$count <= 0) this.data.removeMark(data.row, "webix_selected");
	        return data.row;
	      },
	      mapSelection: function (callback) {
	        return this._mapSelection(callback, false, false);
	      },
	      _selectRange: function (a, b) {
	        return this.selectRange(a.row, a.column, b.row, b.column);
	      },
	      selectRange: function (row_id, column_id, end_row_id, end_column_id, preserve) {
	        if (isUndefined(preserve)) preserve = true;
	        var row_start_ind = row_id ? this.getIndexById(row_id) : 0;
	        var row_end_ind = end_row_id ? this.getIndexById(end_row_id) : this.data.order.length - 1;
	        var col_start_ind = column_id ? this.getColumnIndex(column_id) : 0;
	        var col_end_ind = end_column_id ? this.getColumnIndex(end_column_id) : this._columns.length - 1;

	        if (row_start_ind > row_end_ind) {
	          var temp = row_start_ind;
	          row_start_ind = row_end_ind;
	          row_end_ind = temp;
	        }

	        if (col_start_ind > col_end_ind) {
	          var _temp = col_start_ind;
	          col_start_ind = col_end_ind;
	          col_end_ind = _temp;
	        }

	        this._silent_selection = true;

	        for (var i = row_start_ind; i <= row_end_ind; i++) {
	          for (var j = col_start_ind; j <= col_end_ind; j++) {
	            this.select(this.getIdByIndex(i), this.columnId(j), preserve);
	          }
	        }

	        this._silent_selection = false;

	        this._finalize_select();
	      }
	    },
	    column: {
	      _select_css: " webix_column_select",
	      _select_key: function (data) {
	        return data.column;
	      },
	      _id_to_string: function () {
	        return this.column;
	      },
	      //returns box-like area, with ordered selection cells
	      select: function (column_id, preserve) {
	        this._select({
	          column: column_id
	        }, preserve);
	      },
	      _post_select: function (data) {
	        this._settings.columns[this.getColumnIndex(data.column)].$selected = true;
	        if (!this._silent_selection) this._render_header_and_footer();
	      },
	      unselect: function (column_id) {
	        this._unselect({
	          column: column_id
	        });
	      },
	      _post_unselect: function (data) {
	        this._settings.columns[this.getColumnIndex(data.column)].$selected = null;

	        this._render_header_and_footer();
	      },
	      mapSelection: function (callback) {
	        return this._mapSelection(callback, true, false);
	      },
	      _selectRange: function (a, b) {
	        return this.selectRange(a.column, b.column);
	      },
	      selectRange: function (column_id, end_column_id, preserve) {
	        if (isUndefined(preserve)) preserve = true;
	        var column_start_ind = column_id ? this.getColumnIndex(column_id) : 0;
	        var column_end_ind = end_column_id ? this.getColumnIndex(end_column_id) : this._columns.length - 1;

	        if (column_start_ind > column_end_ind) {
	          var temp = column_start_ind;
	          column_start_ind = column_end_ind;
	          column_end_ind = temp;
	        }

	        this._silent_selection = true;

	        for (var i = column_start_ind; i <= column_end_ind; i++) {
	          this.select(this.columnId(i), preserve);
	        }

	        this._silent_selection = false;

	        this._render_header_and_footer();

	        this._finalize_select();
	      },
	      _data_synced: function () {//do nothing, as columns are not changed
	      }
	    },
	    area: {
	      _select_key: function (data) {
	        return data.row + "_" + data.column;
	      },
	      getSelectedId: function (asArray) {
	        var area = this.getSelectArea();
	        var result = [];

	        if (area) {
	          if (asArray && (area.start.row != area.end.row || area.start.column != area.end.column)) {
	            var row_start_ind = this.getIndexById(area.start.row);
	            var row_end_ind = this.getIndexById(area.end.row); //filtering in process

	            if (row_start_ind == -1 || row_end_ind == -1) return result;
	            var col_start_ind = this.getColumnIndex(area.start.column);
	            var col_end_ind = this.getColumnIndex(area.end.column);

	            for (var i = row_start_ind; i <= row_end_ind; i++) {
	              for (var j = col_start_ind; j <= col_end_ind; j++) {
	                result.push({
	                  row: this.getIdByIndex(i),
	                  column: this.columnId(j)
	                });
	              }
	            }
	          } else {
	            result.push(area.end);
	          }
	        }

	        return asArray ? result : result[0];
	      },
	      unselect: function () {
	        this._unselect();
	      },
	      _unselect: function () {
	        this.removeSelectArea();
	        this.callEvent("onSelectChange", []);
	      },
	      mapSelection: function (callback) {
	        var select = this.getSelectArea();

	        if (select) {
	          var sind = this.getColumnIndex(select.start.column);
	          var eind = this.getColumnIndex(select.end.column);
	          var srow = this.getIndexById(select.start.row);
	          var erow = this.getIndexById(select.end.row);

	          for (var i = srow; i <= erow; i++) {
	            var rid = this.data.order[i];
	            var item = this.getItem(rid);

	            for (var j = sind; j <= eind; j++) {
	              var cid = this._columns[j].id;
	              if (callback) item[cid] = callback(item[cid], rid, cid, i - srow, j - sind);else return {
	                row: rid,
	                column: cid
	              };
	            }
	          }
	        }
	      },
	      select: function (row_id, column_id, preserve) {
	        assert(this.data.exists(row_id), "Incorrect id in select command: " + row_id);

	        this._select({
	          row: row_id,
	          column: column_id
	        }, preserve);
	      },
	      _selectRange: function (id, last) {
	        this._extendAreaRange(id, last);
	      },
	      _select: function (cell) {
	        //ctrl-selection is not supported yet, so ignoring the preserve flag
	        this.addSelectArea(cell, cell, false);
	        return true;
	      },
	      _data_synced: function () {
	        if (this._selected_areas.length) this.refreshSelectArea();
	      }
	    }
	  }
	};

	var Mixin$2 = {
	  blockselect_setter: function (value) {
	    if (value && this._block_sel_flag) {
	      _event(this._viewobj, env.mouse.move, this._bs_move, {
	        bind: this
	      });

	      _event(this._viewobj, env.mouse.down, this._bs_down, {
	        bind: this
	      });

	      event$1(document.body, env.mouse.up, this._bs_up, {
	        bind: this
	      });
	      this._block_sel_flag = this._bs_ready = this._bs_progress = false;
	      this.attachEvent("onAfterScroll", function () {
	        this._update_block_selection();
	      }); // auto scroll

	      exports.extend(this, AutoScroll, true);
	      this.attachEvent("onBeforeAutoScroll", function () {
	        return this._bs_progress;
	      });
	    }

	    return value;
	  },
	  _block_sel_flag: true,
	  _childOf: function (e, tag) {
	    var src = e.target || e.srcElement;

	    while (src) {
	      if (src.getAttribute && src.getAttribute("webixignore")) return false;
	      if (src == tag) return true;
	      src = src.parentNode;
	    }

	    return false;
	  },
	  _bs_down: function (e) {
	    // do not listen to mousedown of subview on master
	    if (this._settings.subview && this != $$(e.target || e.srcElement)) return;

	    if (this._childOf(e, this._body)) {
	      //disable block selection when we have an active editor
	      if (e.target && e.target.tagName == "INPUT" || this._rs_process) return;
	      this._bs_position = offset(this._body);
	      var pos$$1 = pos(e);
	      this._bs_ready = [pos$$1.x - this._bs_position.x, pos$$1.y - this._bs_position.y];
	      preventEvent(e);
	    }
	  },
	  _bs_up: function (e) {
	    if (this._block_panel) {
	      this._bs_select("select", true, e);

	      this._block_panel = remove(this._block_panel);
	    }

	    removeCss(document.body, "webix_noselect");
	    this._bs_ready = this._bs_progress = false;
	    if (this._auto_scroll_delay) this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	  },
	  _update_block_selection: function () {
	    if (this._bs_progress) this._bs_select(false, false);
	  },
	  _bs_select: function (mode, theend, e) {
	    var start = null;
	    if (!this._bs_ready[2]) this._bs_ready[2] = this._locate_cell_xy.apply(this, this._bs_ready);
	    start = this._bs_ready[2];

	    var end = this._locate_cell_xy.apply(this, this._bs_progress);

	    if (!this.callEvent("onBeforeBlockSelect", [start, end, theend, e])) return;

	    if ((!this._bs_do_select || this._bs_do_select(start, end, theend, e) !== false) && start.row && end.row) {
	      if (mode === "select") {
	        this._clear_selection();

	        this._selectRange(start, end);
	      } else {
	        var startx, starty, endx, endy;

	        if (mode === "box") {
	          startx = Math.min(this._bs_ready[0], this._bs_progress[0]);
	          endx = Math.max(this._bs_ready[0], this._bs_progress[0]);
	          starty = Math.min(this._bs_ready[1], this._bs_progress[1]);
	          endy = Math.max(this._bs_ready[1], this._bs_progress[1]);
	        } else {
	          var startn = this._cellPosition(start.row, start.column);

	          var endn = this._cellPosition(end.row, end.column);

	          var scroll = this.getScrollState();
	          var startWidth = startn.width;
	          var endWidth = endn.width;

	          if (this._right_width && this._bs_ready[0] > this._left_width + this._center_width) {
	            startn.left += this._left_width + this._center_width;
	          } else if (this._left_width) {
	            if (this._bs_ready[0] > this._left_width) {
	              if (startn.left < scroll.x) {
	                startWidth -= scroll.x - startn.left;
	                startn.left = this._left_width;
	              } else startn.left += this._left_width - scroll.x;
	            }
	          } else startn.left -= scroll.x;

	          if (this._right_width && this._bs_progress[0] > this._left_width + this._center_width) {
	            endn.left += this._left_width + this._center_width;
	          } else if (this._left_width) {
	            if (this._bs_progress[0] > this._left_width) {
	              if (endn.left < scroll.x) {
	                endWidth -= scroll.x - endn.left;
	                endn.left = this._left_width;
	              } else endn.left += this._left_width - scroll.x;
	            }
	          } else endn.left -= scroll.x;

	          if (this._settings.prerender) {
	            startn.top -= this._scrollTop;
	            endn.top -= this._scrollTop;
	          }

	          startx = Math.min(startn.left, endn.left);
	          endx = Math.max(startn.left + startWidth, endn.left + endWidth);
	          starty = Math.min(startn.top, endn.top);
	          endy = Math.max(startn.top + startn.height, endn.top + endn.height);
	          if (this._settings.topSplit) starty += this._getTopSplitOffset(start);
	          if (this._auto_scroll_delay) this._auto_scroll_delay = window.clearTimeout(this._auto_scroll_delay);
	          if (e) this._auto_scroll_delay = delay(this._auto_scroll, this, [pos(e)], 250);
	        }

	        var style = this._block_panel.style;
	        style.left = startx + "px";
	        style.top = starty + "px";
	        style.width = endx - startx + "px";
	        style.height = endy - starty + "px";
	      }
	    }

	    if (theend) this.callEvent("onAfterBlockSelect", [start, end]);
	  },
	  _bs_start: function () {
	    this._block_panel = create("div", {
	      "class": "webix_block_selection"
	    }, "");

	    this._body.appendChild(this._block_panel);
	  },
	  _bs_move: function (e) {
	    if (this._bs_ready !== false) {
	      if (!this._bs_progress) addCss(document.body, "webix_noselect");
	      var pos$$1 = pos(e);
	      var progress = [pos$$1.x - this._bs_position.x, pos$$1.y - this._bs_position.y]; //prevent unnecessary block selection while dbl-clicking

	      if (Math.abs(this._bs_ready[0] - progress[0]) < 5 && Math.abs(this._bs_ready[1] - progress[1]) < 5) return;
	      if (this._bs_progress === false) this._bs_start(e);
	      this._bs_progress = progress;

	      this._bs_select(this.config.blockselect, false, e);
	    }
	  },
	  _locate_cell_xy: function (x, y) {
	    var inTopSplit = false,
	        row = null,
	        column = null;
	    if (this._right_width && x > this._left_width + this._center_width) x += this._x_scroll.getSize() - this._center_width - this._left_width - this._right_width;else if (!this._left_width || x > this._left_width) x += this._x_scroll.getScroll();

	    if (this._settings.topSplit && this._render_scroll_top > this._settings.topSplit) {
	      var splitPos = this._cellPosition(this.getIdByIndex(this._settings.topSplit - 1), this.columnId(0));

	      if (splitPos.top + splitPos.height > y) {
	        inTopSplit = true;
	      }
	    }

	    if (!inTopSplit) y += this.getScrollState().y;
	    if (x < 0) x = 0;
	    if (y < 0) y = 0;
	    var cols = this._settings.columns;
	    var rows = this.data.order;
	    var summ = 0;

	    for (var i = 0; i < cols.length; i++) {
	      summ += cols[i].width;

	      if (summ >= x) {
	        column = cols[i].id;
	        break;
	      }
	    }

	    if (!column) column = cols[cols.length - 1].id;
	    summ = 0;
	    var start = this.data.$min || 0;

	    if (this._settings.fixedRowHeight) {
	      row = rows[start + Math.floor(y / this._settings.rowHeight)];
	    } else for (var _i = start; _i < rows.length; _i++) {
	      summ += this._getHeightByIndex(_i);

	      if (summ >= y) {
	        row = rows[_i];
	        break;
	      }
	    }

	    if (!row) row = rows[rows.length - 1];
	    return {
	      row: row,
	      column: column
	    };
	  },
	  _getTopSplitOffset: function (cell, area) {
	    var y = 0,
	        startIndex = this.getIndexById(cell.row);

	    if (startIndex >= this._settings.topSplit) {
	      var startPos = this._cellPosition(this.getIdByIndex(startIndex), cell.column);

	      var splitPos = this._cellPosition(this.getIdByIndex(this._settings.topSplit - 1), cell.column);

	      if (splitPos.top + splitPos.height - startPos.top > 0) {
	        y = splitPos.top + splitPos.height - (startPos.top > 0 || !area ? startPos.top : 0);
	      }
	    }

	    return y;
	  }
	};

	var Mixin$3 = {
	  resizeRow_setter: function (value) {
	    this._settings.scrollAlignY = false;
	    this._settings.fixedRowHeight = false;
	    return this.resizeColumn_setter(value);
	  },
	  resizeColumn_setter: function (value) {
	    if (value && this._rs_init_flag) {
	      _event(this._viewobj, "mousemove", this._rs_move, {
	        bind: this
	      });

	      _event(this._viewobj, "mousedown", this._rs_down, {
	        bind: this
	      });

	      _event(this._viewobj, "mouseup", this._rs_up, {
	        bind: this
	      });

	      this._rs_init_flag = false;
	    }

	    return value;
	  },
	  _rs_init_flag: true,
	  _rs_down: function (e) {
	    // do not listen to mousedown of subview on master
	    if (this._settings.subview && this != $$(e.target || e.srcElement)) return; //if mouse was near border

	    if (!this._rs_ready) return;
	    this._rs_process = [pos(e), this._rs_ready[2]];
	    addCss(document.body, "webix_noselect");
	    denySelect();
	  },
	  _rs_up: function () {
	    this._rs_process = false;
	    removeCss(document.body, "webix_noselect");
	    allowSelect();
	  },
	  _rs_start: function () {
	    if (this._rs_progress) return;
	    var dir = this._rs_ready[0];
	    var node = this._rs_process[1];

	    var obj = this._locate(node);

	    if (!obj) return;
	    var eventPos = this._rs_process[0];
	    var start;

	    if (dir == "x") {
	      start = offset(node).x + this._rs_ready[1] - offset(this._body).x;
	      eventPos = eventPos.x;
	      if (!this._rs_ready[1]) obj.cind -= node.parentNode.colSpan || 1;
	    } else {
	      start = offset(node).y + this._rs_ready[1] - offset(this._body).y + this._header_height;
	      eventPos = eventPos.y;
	      if (!this._rs_ready[1]) obj.rind--;
	    }

	    if (obj.cind >= 0 && obj.rind >= 0) {
	      this._rs_progress = [dir, obj, start];
	      var resize = new ui.resizearea({
	        container: this._viewobj,
	        dir: dir,
	        eventPos: eventPos,
	        start: start,
	        cursor: (dir == "x" ? "col" : "row") + "-resize"
	      });
	      resize.attachEvent("onResizeEnd", bind(this._rs_end, this));
	    }

	    this._rs_down = this._rs_ready = false;
	  },
	  _rs_end: function (result) {
	    if (this._rs_progress) {
	      var dir = this._rs_progress[0];
	      var obj = this._rs_progress[1];
	      var newsize = result - this._rs_progress[2];

	      if (dir == "x") {
	        //in case of right split - different sizing logic applied
	        if (this._settings.rightSplit && obj.cind + 1 >= this._rightSplit && obj.cind !== this._columns.length - 1) {
	          obj.cind++;
	          newsize *= -1;
	        }

	        var column = this._columns[obj.cind];
	        var oldwidth = column.width;
	        delete column.fillspace;
	        delete column.adjust;

	        this._setColumnWidth(obj.cind, oldwidth + newsize, true, true);

	        this._updateColsSizeSettings();
	      } else {
	        var rid = this.getIdByIndex(obj.rind);

	        var oldheight = this._getRowHeight(this.getItem(rid));

	        this.setRowHeight(rid, oldheight + newsize);
	      }

	      this._rs_up();
	    }

	    this._rs_progress = null;
	  },
	  _rs_move: function (e) {
	    var cell = null,
	        config = this._settings;
	    if (this._rs_ready && this._rs_process) return this._rs_start(e);
	    e = e || event;
	    var node = e.target || e.srcElement;
	    var mode = false; //resize ready flag

	    if (node.tagName == "TD" || node.tagName == "TABLE") return;
	    var element_class = node.className || "";
	    var in_body = typeof element_class === "string" && element_class.indexOf("webix_cell") != -1; //ignore resize in case of drag-n-drop enabled

	    if (in_body && config.drag) return;
	    var in_header = typeof element_class === "string" && element_class.indexOf("webix_hcell") != -1;
	    this._rs_ready = false;

	    if (in_body || in_header) {
	      var dx = node.offsetWidth;
	      var dy = node.offsetHeight;
	      var pos$$1 = posRelative(e);
	      var resizeRow = config.resizeRow; // if resize is only within the first column

	      if (_typeof(resizeRow) == "object" && resizeRow.headerOnly) {
	        cell = this._locate(node);
	        if (cell.cind > 0) resizeRow = false;
	      }

	      if (in_body && resizeRow) {
	        resizeRow = _typeof(resizeRow) == "object" && resizeRow.size ? resizeRow.size : 3;

	        if (pos$$1.y < resizeRow) {
	          if (!cell) cell = this._locate(node); // avoid resize header border

	          if (cell.rind) {
	            this._rs_ready = ["y", 0, node];
	            mode = "row-resize";
	          }
	        } else if (dy - pos$$1.y < resizeRow + 1) {
	          this._rs_ready = ["y", dy, node];
	          mode = "row-resize";
	        }
	      }

	      var resizeColumn = config.resizeColumn; // if resize is only within the header

	      if (_typeof(resizeColumn) == "object" && resizeColumn.headerOnly && in_body) resizeColumn = false;

	      if (resizeColumn) {
	        resizeColumn = _typeof(resizeColumn) == "object" && resizeColumn.size ? resizeColumn.size : 3;

	        if (pos$$1.x < resizeColumn) {
	          this._rs_ready = ["x", 0, node];
	          mode = "col-resize";
	        } else if (dx - pos$$1.x < resizeColumn + 1) {
	          this._rs_ready = ["x", dx, node];
	          mode = "col-resize";
	        }
	      }
	    } //mark or unmark resizing ready state


	    if (this._cursor_timer) window.clearTimeout(this._cursor_timer);
	    this._cursor_timer = delay(this._mark_resize_ready, this, [mode], mode ? 100 : 0);
	  },
	  _mark_resize_ready: function (mode) {
	    if (this._last_cursor_mode != mode) {
	      this._last_cursor_mode = mode;
	      this._viewobj.style.cursor = mode || "default";
	    }
	  }
	};

	attachEvent("onDataTable", function (table, config) {
	  if (env.touch) {
	    Touch.$init();
	    config.scrollSize = 0; // needed to show datatable scroll

	    if (Touch._disabled) Touch.limit();
	    table.$ready.push(table.$touch);
	  }
	});
	var Mixin$4 = {
	  $touch: function () {
	    var config = this._settings;
	    config.scrollAlignY = false;
	    exports.extend(this, config.prerender === true ? this._touchNative : this._touch);
	    var scrollMode = "";
	    if (!config.autowidth && config.scrollX !== false) scrollMode += "x";
	    if (!config.autoheight && config.scrollY !== false) scrollMode += "y";

	    this._body.setAttribute("touch_scroll", scrollMode);

	    Touch._init_scroll_node(this._body.childNodes[1].firstChild);

	    Touch._set_matrix(this._body.childNodes[1].firstChild, 0, 0, "0ms");

	    this._sync_scroll(0, 0, "0ms");
	  },
	  _touchNative: {
	    _scrollTo_touch: function (x, y) {
	      Touch._set_matrix(this._body.childNodes[1].firstChild, -x, -y, "0ms");

	      this._sync_scroll(-x, -y, "0ms");
	    },
	    _getScrollState_touch: function () {
	      var temp = Touch._get_matrix(this._body.childNodes[1].firstChild);

	      return {
	        x: -temp.e,
	        y: -temp.f
	      };
	    },
	    $init: function () {
	      this.attachEvent("onBeforeScroll", function () {
	        Touch._scroll_node = this._body.childNodes[1].firstChild;

	        Touch._get_sizes(Touch._scroll_node);

	        Touch._scroll_master = this;
	      });
	      this.attachEvent("onTouchEnd", function () {
	        Touch._scroll_master = null;
	      });
	    },
	    _sync_scroll: function (x, y, t) {
	      if (this._settings.leftSplit) Touch._set_matrix(this._body.childNodes[0].firstChild, 0, y, t);
	      if (this._settings.rightSplit) Touch._set_matrix(this._body.childNodes[2].firstChild, 0, y, t);
	      if (this._settings.header) Touch._set_matrix(this._header.childNodes[1].firstChild, x, 0, t);
	      if (this._settings.footer) Touch._set_matrix(this._footer.childNodes[1].firstChild, x, 0, t);
	      this.callEvent("onSyncScroll", [x, y, t]);
	    },
	    _sync_pos: function () {}
	  },
	  _touch: {
	    _scrollTo_touch: function (x, y) {
	      delay(function () {
	        this.callEvent("onAfterScroll", [{
	          e: -x,
	          f: -y
	        }]);
	      }, this);
	    },
	    $scroll: {
	      gravity: 0,
	      elastic: false
	    },
	    $init: function () {
	      //if the result column's width < container's width,
	      this.attachEvent("onAfterColumnHide", function () {
	        this._scrollTo_touch(0, 0);
	      });
	      this.attachEvent("onBeforeScroll", function () {
	        var t = Touch;
	        t._scroll_node = this._body.childNodes[1].firstChild;

	        t._get_sizes(t._scroll_node);

	        t._scroll_stat.left = this._scrollLeft;
	        t._scroll_stat.hidden = this._x_scroll._settings.scrollVisible || this._y_scroll._settings.scrollVisible;
	        t._scroll_stat.dy = this._dtable_height;
	        t._scroll_master = this;
	      });
	      this.attachEvent("onAfterScroll", function (result) {
	        //onAfterScroll may be triggered by some non-touch related logic
	        if (!result) return;
	        var isScrollX = this._scrollLeft != -result.e;
	        var isScrollY = this._scrollTop != -result.f;
	        Touch._scroll_master = null;
	        Touch._fix_f = null;
	        this._scrollTop = 0;
	        this._scrollLeft = 0; //ipad can delay content rendering if 3d transformation applied
	        //switch back to 2d

	        var temp = Touch.config.translate;
	        Touch.config.translate = "translate";

	        this._sync_scroll(this._x_scroll ? 0 : result.e, 0, "0ms");

	        Touch.config.translate = temp;
	        this._scrollLeft = -result.e;
	        this._scrollTop = -result.f;

	        this._correctScrollSize();

	        this.render();

	        if (isScrollX) {
	          if (this._x_scroll) this._x_scroll.scrollTo(this._scrollLeft);
	          this.callEvent("onScrollX", []);
	        }

	        if (isScrollY) {
	          if (this._y_scroll) this._y_scroll.scrollTo(this._scrollTop);
	          this.callEvent("onScrollY", []);
	        }

	        return false;
	      });
	    },
	    _sync_scroll: function (x, y, t) {
	      y += this._scrollTop;
	      x += this._scrollLeft;

	      Touch._set_matrix(this._body.childNodes[1].firstChild, x, y, t);

	      if (this._settings.leftSplit) Touch._set_matrix(this._body.childNodes[0].firstChild, 0, y, t);
	      if (this._settings.rightSplit) Touch._set_matrix(this._body.childNodes[2].firstChild, 0, y, t);
	      if (this._settings.header) Touch._set_matrix(this._header.childNodes[1].firstChild, x, 0, t);
	      if (this._settings.footer) Touch._set_matrix(this._footer.childNodes[1].firstChild, x, 0, t);
	      this.callEvent("onSyncScroll", [x, y, t]);
	    },
	    _sync_pos: function (matrix) {
	      matrix.f -= this._scrollTop;
	      matrix.e -= this._scrollLeft;
	    }
	  }
	};

	var Mixin$5 = {
	  $init: function () {
	    this.data.attachEvent("onStoreUpdated", bind(function (id) {
	      if (!id) this._adjustColumns();
	    }, this));
	    this.attachEvent("onStructureLoad", this._adjustColumns);
	    this.attachEvent("onStructureUpdate", this._resizeColumns);
	    this.attachEvent("onColumnResize", function (a, b, c, user) {
	      if (user) this._resizeColumns();
	    });
	    this.attachEvent("onResize", this._resizeColumns);
	  },
	  _adjustColumns: function () {
	    var resize = false;
	    var cols = this._columns;

	    for (var i = 0; i < cols.length; i++) {
	      if (cols[i].adjust && (cols[i].adjust == "header" || this.count())) resize = this._adjustColumn(i, cols[i].adjust, true) || resize;
	    }

	    if (resize) {
	      this._updateColsSizeSettings(true);

	      this._resizeColumns();
	    }
	  },
	  _resizeColumns: function () {
	    var cols = this._settings.columns;
	    var fill = [];
	    var summ = 0;
	    if (cols && !this._settings.autowidth) for (var i = 0; i < cols.length; i++) {
	      var colfil = cols[i].fillspace;

	      if (colfil) {
	        fill[i] = colfil;
	        summ += colfil * 1 || 1;
	      }
	    }
	    if (summ) this._fillColumnSize(fill, summ);
	  },
	  _fillColumnSize: function (fill, summ) {
	    var cols = this._settings.columns;
	    if (!cols) return;
	    var width = this._content_width - this._scrollSizeY;
	    var resize = false;

	    if (width > 0) {
	      for (var i = 0; i < cols.length; i++) {
	        if (!fill[i]) width -= cols[i].width || this.config.columnWidth;
	      }

	      for (var _i = 0; _i < fill.length; _i++) {
	        if (fill[_i]) {
	          var request = Math.min(width, Math.round(width * fill[_i] / summ));
	          resize = this._setColumnWidth(_i, request, true) || resize;
	          width = width - cols[_i].width;
	          summ = summ - fill[_i];
	        }
	      }

	      if (resize) this._updateColsSizeSettings(true);
	    }
	  },
	  _getColumnConfigSize: function (ind, headers) {
	    var config = this._settings.columns[ind];
	    var max = config.minColumnWidth || 10; //get max data width

	    if (headers != "header") {
	      var count = this.data.order.length;
	      if (config.adjustBatch && config.adjustBatch < count) count = config.adjustBatch;
	      var order = this.data.order.slice(0, count);

	      for (var i = 0; i < count; i++) {
	        order[i] = order[i] ? this._getValue(this.getItem(order[i]), config, 0) : "";
	      }

	      max = Math.max(max, getTextSize(order, "webix_table_cell webix_cell").width);
	    } //get max header width


	    if (headers != "data") {
	      for (var _i2 = 0; _i2 < config.header.length; _i2++) {
	        var header = config.header[_i2];

	        if (header) {
	          var width = 0;
	          if (header.rotate) for (var h = 0; h < (header.rowspan || 1); h++) {
	            width += this._headers[h];
	          }
	          var css = "webix_table_cell webix_cell " + (header.css || "") + (header.rotate ? "webix_measure_rotate" : "");
	          var size = getTextSize([header.text], css, width);
	          max = Math.max(max, header.rotate ? size.height : size.width);
	        }
	      }

	      if (config.sort) max += 10; // add 10px for sort marker
	    } //1px to compensate offsetWidth rounding


	    return max + 1 + (env.isIE ? $active.layoutPadding.space : 0);
	  },
	  _adjustColumn: function (ind, headers, ignore) {
	    if (ind >= 0) {
	      var width = this._getColumnConfigSize(ind, headers);

	      return this._setColumnWidth(ind, width, ignore);
	    }
	  },
	  adjustColumn: function (id, headers) {
	    this._adjustColumn(this.getColumnIndex(id), headers);
	  },
	  adjustRowHeight: function (id, silent) {
	    var _this = this;

	    if (id) {
	      var config = this.getColumnConfig(id);
	      var container;
	      var d = create("DIV", {
	        "class": "webix_table_cell webix_measure_size webix_cell"
	      }, "");
	      d.style.cssText = "width:" + config.width + "px; height:1px; visibility:hidden; position:absolute; top:0px; left:0px; overflow:hidden;";
	      this.$view.appendChild(d);

	      if (d.offsetHeight < 1) {
	        //hidden container, height detection is broken
	        //reattach to the body
	        container = this.$view.cloneNode(true);
	        document.body.appendChild(container);
	        container.appendChild(d);
	      }

	      this.data.each(function (obj) {
	        d.innerHTML = this._getValue(obj, config, 0);
	        obj.$height = Math.max(d.scrollHeight, this._settings.rowHeight);
	      }, this);
	      d = remove(d);
	      if (container) remove(container);
	    } else {
	      //set size of array based on data size
	      //can be not-reliable for tree-like components anyway
	      var heightsArr = new Array(this.data.order.length);
	      var cols = this.config.columns; //set 0 as initial height

	      var j = 0; //iterate through all possible items
	      //we need to be sure that heightsArr is not lesser than real data count

	      for (var key in this.data.pull) {
	        //eslint-disable-line
	        heightsArr[j] = 0;
	        j++;
	      }

	      var _loop = function (i) {
	        //adjust size for single columns
	        _this.adjustRowHeight(cols[i].id, true); //for each row, set height as maximum between all columns


	        var j = 0;

	        _this.data.each(function (obj) {
	          //index is not reliable for tree-components, using a custom counter
	          if (obj.$height > heightsArr[j]) {
	            heightsArr[j] = obj.$height;
	          }

	          obj.$height = heightsArr[j];
	          j++;
	        });
	      };

	      for (var i = 0; i < cols.length; i++) {
	        _loop(i);
	      }
	    }

	    if (!silent) this.refresh();
	  }
	};

	var Mixin$6 = {
	  math_setter: function (value) {
	    if (value) this._math_init();
	    return value;
	  },
	  _math_pref: "$",
	  _math_init: function () {
	    if (env.strict) return;
	    this.data.attachEvent("onStoreUpdated", bind(this._parse_row_math, this));
	    this.data.attachEvent("onStoreLoad", bind(this._parse_math, this));
	    this.attachEvent("onStructureLoad", this._parse_math);
	  },
	  _parse_row_math: function (id, obj, action) {
	    if (!id || action == "paint") return;

	    if (action == "delete") {
	      for (var i = 0; i < this._columns.length; i++) {
	        this._remove_old_triggers(obj, this._columns[i].id);
	      }
	    } else {
	      if (action == "add") this._exprs_by_columns(obj);

	      for (var _i = 0; _i < this._columns.length; _i++) {
	        this._parse_cell_math(id, this._columns[_i].id, action !== "add");
	      }

	      this._math_recalc = {};
	    }
	  },
	  _parse_cell_math: function (row, col, _inner_call) {
	    var item = this.getItem(row);
	    var value; // if it's outer call we should use inputted value otherwise to take formula, not calculated value

	    if (_inner_call === true) value = item[this._math_pref + col] || item[col];else {
	      value = item[col];
	      this._math_recalc = {};
	    }

	    if (value && value.length > 0 && value.toString().substr(0, 1) === "=") {
	      // calculate math value
	      if (!item[this._math_pref + col] || _inner_call !== true) item[this._math_pref + col] = item[col];
	      item[col] = this._calculate(value, row, col); //this.updateItem(item);
	    } else {
	      // just a string
	      if (typeof item[this._math_pref + col] !== "undefined") delete item[this._math_pref + col]; // remove triggers if they were setted earlier

	      this._remove_old_triggers(item, col);
	    } // recalculate depending cells


	    if (typeof item.depends !== "undefined" && typeof item.depends[col] !== "undefined") {
	      for (var i in item.depends[col]) {
	        var name = item.depends[col][i][0] + "__" + item.depends[col][i][1];

	        if (typeof this._math_recalc[name] === "undefined") {
	          this._math_recalc[name] = true;

	          this._parse_cell_math(item.depends[col][i][0], item.depends[col][i][1], true);
	        }
	      }
	    }
	  },
	  _set_original_value: function (row, col) {
	    var item = this.getItem(row);
	    if (typeof item[this._math_pref + col] !== "undefined") item[col] = item[this._math_pref + col];
	  },
	  _parse_math: function () {
	    if (!this._columns || !this.count()) return;

	    this._exprs_by_columns();

	    for (var j = 0; j < this._columns.length; j++) {
	      var col = this.columnId(j);
	      this.data.each(function (obj) {
	        this._parse_cell_math(obj.id, col);
	      }, this);
	    }

	    this._math_recalc = {};
	  },
	  _exprs_by_columns: function (row) {
	    for (var i = 0; i < this._columns.length; i++) {
	      if (this._columns[i].math) {
	        var col = this.columnId(i);
	        var math = "=" + this._columns[i].math;
	        math = math.replace(/\$c/g, "#$c#");

	        if (row) {
	          row[col] = this._parse_relative_expr(math, row.id, col);
	          delete row[this._math_pref + col];

	          this._remove_old_triggers(row, col);
	        } else this.data.each(function (obj) {
	          obj[col] = this._parse_relative_expr(math, obj.id, col);
	          delete obj[this._math_pref + col];

	          this._remove_old_triggers(obj, col);
	        }, this);
	      }
	    }
	  },
	  _parse_relative_expr: function (expr, row, col) {
	    return template(expr)({
	      "$r": row,
	      "$c": col
	    });
	  },
	  _get_calc_value: function (row, col) {
	    var item;
	    if (this.exists(row)) item = this.getItem(row);else return "#out_of_range";
	    var value = item[this._math_pref + col] || item[col] || 0;
	    value = value.toString();
	    if (value.substring(0, 1) !== "=") // it's a string
	      return value;else {
	      // TODO: check if value shouldn't be recalculated
	      // and return value calculated earlier
	      // calculate math expr value right now
	      if (typeof item[this._math_pref + col] === "undefined") item[this._math_pref + col] = item[col];
	      item[col] = this._calculate(value, row, col, true);
	      return item[col];
	    }
	  },
	  _calculate: function (value, row, col, _inner_call) {
	    // add coord in math trace to detect self-references
	    if (_inner_call === true) {
	      if (this._in_math_trace(row, col)) return "#selfreference";
	    } else this._start_math_trace();

	    this._to_math_trace(row, col);

	    var item = this.getItem(row);
	    value = value.substring(1); // get operations list

	    var operations = this._get_operations(value);

	    var triggers = this._get_refs(value, row);

	    if (operations) {
	      value = this._replace_refs(value, triggers);
	      value = this._parse_args(value, operations);
	    } else {
	      value = this._replace_refs(value, triggers, true);
	    }

	    var exc = this._math_exception(value);

	    if (exc !== false) return exc; // remove from coord from trace when calculations were finished - it's important!

	    this._from_math_trace(row, col); // process triggers to know which cells should be recalculated when one was changed


	    this._remove_old_triggers(item, col);

	    for (var i = 0; i < triggers.length; i++) {
	      this._add_trigger([row, col], triggers[i]);
	    }

	    exc = this._math_exception(value);
	    if (exc !== false) return exc; // there aren't any operations here. returns number or value of another cell

	    if (!value) return value; // process mathematical expression and getting final result

	    value = this._compute(value.replace(/\$r/g, item.id));
	    exc = this._math_exception(value);
	    if (exc !== false) return exc;
	    return value;
	  },
	  _get_operations: function (value) {
	    // gettings operations list (+-*/)
	    var splitter = /(\+|-|\*|\/)/g;
	    var operations = value.replace(/\[[^)]*?\]/g, "").match(splitter);
	    return operations;
	  },

	  /*! gets list of referencies in formula
	   **/
	  _get_refs: function (value, id) {
	    var reg = /\[([^\]]+),([^\]]+)\]/g;
	    var cells = value.match(reg);
	    if (cells === null) cells = [];

	    for (var i = 0; i < cells.length; i++) {
	      var cell = cells[i];
	      var tmp = cell;
	      cell = cell.substr(1, cell.length - 2);
	      cell = cell.split(",");
	      cell[0] = this._trim(cell[0]);
	      cell[1] = this._trim(cell[1]);
	      if (cell[0].substr(0, 1) === ":") cell[0] = this.getIdByIndex(cell[0].substr(1));
	      if (cell[0] === "$r") cell[0] = id;
	      if (cell[1].substr(0, 1) === ":") cell[1] = this.columnId(cell[1].substr(1));
	      cell[2] = tmp;
	      cells[i] = cell;
	    }

	    return cells;
	  },
	  // replace given list of references by their values
	  _replace_refs: function (value, cells, clean) {
	    var dell = "(",
	        delr = ")";
	    if (clean) dell = delr = "";

	    for (var i = 0; i < cells.length; i++) {
	      var cell = cells[i];

	      var cell_value = this._get_calc_value(cell[0], cell[1]);

	      if (isNaN(cell_value)) cell_value = "\"" + cell_value + "\"";
	      value = value.replace(cell[2], dell + cell_value + delr);
	    }

	    return value;
	  },
	  _parse_args: function (value, operations) {
	    var args = [];

	    for (var i = 0; i < operations.length; i++) {
	      var op = operations[i];

	      var temp = this._split_by(value, op);

	      args.push(temp[0]);
	      value = temp[1];
	    }

	    args.push(value); //var reg = /^(-?\d|\.|\(|\))+$/;

	    for (var _i2 = 0; _i2 < args.length; _i2++) {
	      var arg = this._trim(args[_i2]); //	if (reg.test(arg) === false)
	      //		return ''; //error


	      args[_i2] = arg;
	    }

	    var expr = "";

	    for (var _i3 = 0; _i3 < args.length - 1; _i3++) {
	      expr += args[_i3] + operations[_i3];
	    }

	    expr += args[args.length - 1];
	    return expr;
	  },
	  _compute: function (expr) {
	    var result;

	    try {
	      result = window.eval(expr);
	    } catch (ex) {
	      assert(false, "Math error in datatable<br>" + expr);
	      result = "";
	    }

	    return result.toString();
	  },
	  _split_by: function (value, splitter) {
	    var pos = value.indexOf(splitter);
	    var before = value.substr(0, pos);
	    var after = value.substr(pos + 1);
	    return [before, after];
	  },
	  _trim: function (value) {
	    value = value.replace(/^ */g, "");
	    value = value.replace(/ *$/g, "");
	    return value;
	  },
	  _start_math_trace: function () {
	    this._math_trace = [];
	  },
	  _to_math_trace: function (row, col) {
	    this._math_trace[row + "__" + col] = true;
	  },
	  _from_math_trace: function (row, col) {
	    if (typeof this._math_trace[row + "__" + col] !== "undefined") delete this._math_trace[row + "__" + col];
	  },
	  _in_math_trace: function (row, col) {
	    if (typeof this._math_trace[row + "__" + col] !== "undefined") return true;else return false;
	  },
	  _add_trigger: function (depends, from) {
	    var item = this.getItem(from[0]);
	    if (typeof item.depends === "undefined") item.depends = {};
	    if (typeof item.depends[from[1]] === "undefined") item.depends[from[1]] = {};
	    item.depends[from[1]][depends[0] + "__" + depends[1]] = depends;
	    item = this.getItem(depends[0]);
	    if (typeof item.triggers === "undefined") item.triggers = {};
	    if (typeof item.triggers[depends[1]] === "undefined") item.triggers[depends[1]] = {};
	    item.triggers[depends[1]][from[0] + "__" + from[1]] = from;
	  },
	  _remove_old_triggers: function (item, col) {
	    if (!item) return;
	    if (typeof item.triggers === "undefined") return;

	    for (var i in item.triggers[col]) {
	      var depend = item.triggers[col][i];
	      var row = this.getItem(depend[0]);
	      if (row) delete row.depends[depend[1]][item.id + "__" + col];
	    }
	  },
	  // check if exception syntax exists and returns exception text or false
	  _math_exception: function (value) {
	    var reg = /#\w+/;
	    var match = value.match(reg);
	    if (match !== null && match.length > 0) return match[0];
	    return false;
	  }
	};

	var temp$4 = {};

	// #include core/edit.js
	// #include ui/inputs.js

	var Mixin$7 = {
	  /////////////////////////
	  //    edit start       //
	  /////////////////////////
	  _get_editor_type: function (id) {
	    return this.getColumnConfig(id.column).editor;
	  },
	  getEditor: function (row, column) {
	    if (!row) return this._last_editor;

	    if (arguments.length == 1) {
	      column = row.column;
	      row = row.row;
	    }

	    return (this._editors[row] || {})[column];
	  },
	  _for_each_editor: function (handler) {
	    for (var row in this._editors) {
	      var row_editors = this._editors[row];

	      for (var column in row_editors) {
	        if (column != "$count") handler.call(this, row_editors[column]);
	      }
	    }
	  },
	  _init_editor: function (id, type, show) {
	    var row = id.row;
	    var column = id.column;
	    var col_settings = type.config = this.getColumnConfig(column); //show it over cell

	    if (show !== false) this.showCell(row, column);
	    var node = type.render();
	    if (type.$inline) node = this._locateInput(id);
	    type.node = node;
	    var item = this.getItem(row);
	    var format = col_settings.editFormat;
	    var value;
	    if (this._settings.editMath) value = item["$" + column];
	    value = value || item[column];
	    if (isUndefined(value)) value = "";
	    type.setValue(format ? format(value) : value, item);
	    type.value = item[column];

	    this._addEditor(id, type);

	    if (!type.$inline) this._sizeToCell(id, node, true);
	    if (type.afterRender) type.afterRender();

	    if (this._settings.liveValidation) {
	      _event(type.node, "keyup", this._bind_live_validation(id, this));

	      this.validateEditor(id);
	    }

	    return node;
	  },
	  _bind_live_validation: function (id, that) {
	    return function () {
	      that.validateEditor(id);
	    };
	  },
	  _get_new_value: function (editor) {
	    var parser = this.getColumnConfig(editor.column).editParse;
	    var new_value = editor.getValue();
	    return parser ? parser(new_value) : new_value;
	  },
	  _set_new_value: function (editor, new_value, copy$$1) {
	    var item = copy$$1 ? {} : this.getItem(editor.row);
	    item[editor.column] = new_value;
	    if (this._settings.editMath) item["$" + editor.column] = null;
	    return item;
	  },
	  //register editor in collection
	  _addEditor: function (id, type) {
	    var row_editors = this._editors[id.row] = this._editors[id.row] || {};
	    row_editors.$count = (row_editors.$count || 0) + 1;
	    type.row = id.row;
	    type.column = id.column;
	    this._last_editor = row_editors[id.column] = type;
	    this._in_edit_mode++;
	    this._last_editor_scroll = this.getScrollState();
	  },
	  _removeEditor: function (editor) {
	    if (this._last_editor == editor) this._last_editor = 0;
	    if (editor.destroy) editor.destroy();
	    var row = this._editors[editor.row];
	    delete row[editor.column];
	    row.$count--;
	    if (!row.$count) delete this._editors[editor.row];
	    this._in_edit_mode--;
	  },
	  _changeEditorId: function (oldid, newid) {
	    var editor = this._editors[oldid];

	    if (editor) {
	      this._editors[newid] = editor;
	      delete this._editors[oldid];

	      for (var key in editor) {
	        if (key != "$count") editor[key].row = newid;
	      }
	    }
	  },
	  //get html cell by combined id
	  _locate_cell: function (id) {
	    var area,
	        i,
	        index,
	        j,
	        node,
	        span,
	        config = this.getColumnConfig(id.column),
	        cell = 0;

	    if (config && config.node && config.attached) {
	      index = this.getIndexById(id.row);

	      if (this._spans_pull) {
	        span = this.getSpan(id.row, id.column);

	        if (span) {
	          for (i = 0; i < 3; i++) {
	            area = this._spans_areas[i];

	            for (j = 0; !cell && j < area.childNodes.length; j++) {
	              node = area.childNodes[j];
	              if (node.getAttribute("row") == index && node.getAttribute("column") == this.getColumnIndex(id.column)) cell = node;
	            }
	          }
	        }
	      }

	      if (!cell && index >= config._yr0 - this._settings.topSplit && index < config._yr1) cell = config.node.childNodes[index - config._yr0 + this._settings.topSplit];
	    }

	    return cell;
	  },
	  /////////////////////////
	  //    public methods   //
	  /////////////////////////
	  editCell: function (row, column, preserve, show) {
	    column = column || this._settings.columns[0].id;
	    return EditAbility.edit.call(this, {
	      row: row,
	      column: column
	    }, preserve, show);
	  },
	  editRow: function (id) {
	    if (id && id.row) id = id.row;
	    var next = false;
	    this.eachColumn(function (column) {
	      this.edit({
	        row: id,
	        column: column
	      }, next, !next);
	      next = true;
	    });
	  },
	  editColumn: function (id) {
	    if (id && id.column) id = id.column;
	    var next = false;
	    this.eachRow(function (row) {
	      this.edit({
	        row: row,
	        column: id
	      }, next, !next);
	      next = true;
	    });
	  },
	  eachRow: function (handler, all) {
	    var order = this.data.order;
	    if (all) order = this.data._filter_order || order;

	    for (var i = 0; i < order.length; i++) {
	      handler.call(this, order[i]);
	    }
	  },
	  eachColumn: function (handler, all) {
	    for (var i in this._columns_pull) {
	      var column = this._columns_pull[i];
	      handler.call(this, column.id, column);
	    }

	    if (all) {
	      for (var _i in this._hidden_column_hash) {
	        var _column = this._hidden_column_hash[_i];
	        handler.call(this, _column.id, _column);
	      }
	    }
	  },
	  ////////////////////
	  //    edit next   //
	  ////////////////////
	  _after_edit_next: function (editor_next) {
	    if (this.getSelectedId) {
	      //select related cell when possible
	      var sel = this.getSelectedId(true);

	      if (sel.length == 1) {
	        this._select(editor_next);

	        return false;
	      }
	    }
	  },
	  _custom_tab_handler: function (tab, e) {
	    if (this._settings.editable && !this._in_edit_mode) {
	      //if we have focus in some custom input inside of datatable
	      if (e.target && e.target.tagName == "INPUT") return true; //init editor related to a single selected row/column/cell

	      var selection = this.getSelectedId(true);

	      if (selection.length == 1) {
	        var sel = selection[0];
	        if (this._settings.select == "row") sel.column = this._settings.columns[e.shiftKey ? 0 : this._settings.columns.length - 1].id;
	        this.editNext(tab, sel);
	        return false;
	      }
	    }

	    return true;
	  },
	  _find_cell_next: function (start, check, direction) {
	    var row = this.getIndexById(start.row);
	    var column = this.getColumnIndex(start.column);
	    var order = this.data.order;
	    var cols = this._columns;

	    if (direction) {
	      for (var i = row; i < order.length; i++) {
	        for (var j = column + 1; j < cols.length; j++) {
	          var id = {
	            row: order[i],
	            column: cols[j].id
	          };

	          if (check.call(this, id) && (!this._checkCellMerge || !this._checkCellMerge(start, id))) {
	            return id;
	          }
	        }

	        column = -1;
	      }
	    } else {
	      for (var _i2 = row; _i2 >= 0; _i2--) {
	        for (var _j = column - 1; _j >= 0; _j--) {
	          var _id = {
	            row: order[_i2],
	            column: cols[_j].id
	          };
	          if (check.call(this, _id)) return _id;
	        }

	        column = cols.length;
	      }
	    }

	    return null;
	  },
	  /////////////////////////////
	  //    scroll correction    //
	  /////////////////////////////
	  _correct_after_focus_y: function () {
	    if (this._in_edit_mode) {
	      if (this._ignore_after_focus_scroll) this._ignore_after_focus_scroll = false;else {
	        this._y_scroll.scrollTo(this.getScrollState().y + this._body.childNodes[1].firstChild.scrollTop);

	        this._body.childNodes[1].firstChild.scrollTop = 0;
	        this._ignore_after_focus_scroll = true;
	      }
	    }
	  },
	  _correct_after_focus_x: function () {
	    if (this._in_edit_mode) {
	      this._x_scroll.scrollTo(this._body.childNodes[1].scrollLeft);
	    }
	  },
	  _component_specific_edit_init: function () {
	    this.attachEvent("onScrollY", this._update_editor_y_pos);
	    this.attachEvent("onScrollX", this._update_editor_y_pos);
	    this.attachEvent("onScrollY", this._refocus_inline_editor);
	    this.attachEvent("onColumnResize", function () {
	      this.editStop();
	    });
	    this.attachEvent("onAfterFilter", function () {
	      this.editStop();
	    });
	    this.attachEvent("onRowResize", function () {
	      this.editStop();
	    });
	    this.attachEvent("onAfterScroll", function () {
	      if (this._settings.topSplit) this.editStop();
	    });
	    this._body.childNodes[1].firstChild.onscroll = bind(this._correct_after_focus_y, this);
	    this._body.childNodes[1].onscroll = bind(this._correct_after_focus_x, this);
	  },
	  _update_editor_y_pos: function () {
	    if (this._in_edit_mode) {
	      var old = this._last_editor_scroll;
	      this._last_editor_scroll = this.getScrollState();
	      var diff = this._last_editor_scroll.y - old.y;

	      this._for_each_editor(function (editor) {
	        if (editor.getPopup) {
	          var node = this.getItemNode(editor);
	          if (node) editor.getPopup().show(node);else editor.getPopup().show({
	            x: -10000,
	            y: -10000
	          });
	        }

	        if (!editor.linkInput && !editor.$inline) {
	          editor.node.top -= diff;
	          editor.node.style.top = editor.node.top + "px";
	        }
	      });
	    }
	  }
	};

	var Mixin$8 = {
	  $init: function () {
	    this._clear_hidden_state();

	    this.attachEvent("onStructureLoad", this._hideInitialColumns);
	  },
	  _clear_hidden_state: function () {
	    this._hidden_column_hash = {};
	    this._hidden_column_order = toArray();
	    this._hidden_split = [0, 0];
	  },
	  _hideInitialColumns: function () {
	    var cols = this._columns;

	    for (var i = 0; i < cols.length; i++) {
	      if (cols[i].header) this._getInitialSpans(cols, cols[i].header);
	      if (cols[i].footer) this._getInitialSpans(cols, cols[i].footer);
	    }

	    for (var _i = cols.length - 1; _i >= 0; _i--) {
	      if (cols[_i].hidden) this.hideColumn(cols[_i].id, {}, true, true);else if (cols[_i].batch && this.config.visibleBatch && cols[_i].batch != this.config.visibleBatch) {
	        this.hideColumn(cols[_i].id, {}, true, true);
	      }
	    }
	  },
	  _getInitialSpans: function (cols, elements) {
	    for (var h = 0; h < elements.length; h++) {
	      var line = elements[h];
	      if (line && line.colspan && !line.$colspan) line.$colspan = line.colspan;
	    }
	  },
	  moveColumn: function (id, index) {
	    var start_index = this.getColumnIndex(id);
	    if (start_index == index) return; //already in place

	    var columns = this._settings.columns;
	    var start = columns.splice(start_index, 1);
	    var pos = index - (index > start_index ? 1 : 0);
	    PowerArray.insertAt.call(columns, start[0], pos);
	    var order = this._hidden_column_order; // order exists even if columns are not reordered, so checking for length

	    if (order.length) {
	      order = toArray(order);
	      var hidden_index = order.find(id);
	      order.removeAt(hidden_index);
	      if (pos === 0) order.unshift(id);else {
	        order.insertAt(id, order.find(columns[pos - 1].id) + 1);
	      }
	    } //TODO: split handling
	    //we can move split line when column dropped after it


	    this._refresh_columns();
	  },
	  _init_horder: function () {
	    var horder = this._hidden_column_order;
	    var cols = this._settings.columns;

	    if (!horder.length) {
	      for (var i = 0; i < cols.length; i++) {
	        horder[i] = cols[i].id;
	      }

	      this._hidden_split = [this._settings.leftSplit, this._rightSplit];
	    }
	  },
	  isColumnVisible: function (id) {
	    return !this._hidden_column_hash[id];
	  },
	  hideColumn: function (id, opts, silent, mode) {
	    var cols = this._settings.columns;
	    var horder = this._hidden_column_order;
	    var hhash = this._hidden_column_hash;
	    var column;
	    var span = 1;
	    opts = opts || {};

	    if (mode !== false) {
	      var index = this.getColumnIndex(id);
	      assert(index != -1, "hideColumn: invalid ID or already hidden");
	      if (index === -1 || !this.callEvent("onBeforeColumnHide", [id])) return; //in case of second call to hide the same column, command will be ignored

	      if (index == -1) return;

	      this._init_horder();

	      if (opts.spans) {
	        var header = cols[index].header;

	        for (var i = 0; i < header.length; i++) {
	          if (header[i]) {
	            header[i].$groupSpan = header[i].colspan || 1;
	            span = Math.max(span, header[i].$groupSpan);
	          }
	        }
	      }

	      if (index < this._settings.leftSplit) this._settings.leftSplit -= span;
	      if (index >= this._rightSplit) this._settings.rightSplit -= span;else this._rightSplit -= span;

	      for (var _i2 = index + span - 1; _i2 >= index; _i2--) {
	        this._hideColumn(index);

	        column = cols.splice(index, 1)[0];
	        hhash[column.id] = column;
	        column._yr0 = -1;
	        delete this._columns_pull[column.id];
	      }

	      this.callEvent("onAfterColumnHide", [id]);
	    } else {
	      column = hhash[id];
	      assert(column, "showColumn: invalid ID or already visible"); //in case of second show command for already visible column - ignoring

	      if (!column || !this.callEvent("onBeforeColumnShow", [id])) return;
	      var prev = null;
	      var _i3 = 0;
	      var hindex = 0;

	      for (; _i3 < horder.length; _i3++) {
	        if (horder[_i3] == id) {
	          hindex = _i3;
	          break;
	        }

	        if (!hhash[horder[_i3]]) prev = horder[_i3];
	      }

	      var _index = prev ? this.getColumnIndex(prev) + 1 : 0;

	      if (opts.spans) {
	        var _header = column.header;

	        for (var _i4 = 0; _i4 < _header.length; _i4++) {
	          if (_header[_i4]) {
	            _header[_i4].colspan = _header[_i4].$groupSpan || _header[_i4].colspan;
	            delete _header[_i4].$groupSpan;
	            span = Math.max(span, _header[_i4].colspan || 1);
	          }
	        }
	      }

	      for (var _i5 = hindex + span - 1; _i5 >= hindex; _i5--) {
	        var _column = hhash[horder[_i5]];

	        if (_column) {
	          //can be already shown by another action
	          PowerArray.insertAt.call(cols, _column, _index);
	          delete _column.hidden;
	          delete hhash[_column.id];
	          this._columns_pull[_column.id] = _column;
	        } else span--;
	      }

	      if (hindex < this._hidden_split[0]) this._settings.leftSplit += span;
	      if (hindex >= this._hidden_split[1]) this._settings.rightSplit += span;else this._rightSplit += span;
	      this.callEvent("onAfterColumnShow", [id]);
	    }

	    if (column.header) this._fixColspansHidden(column, mode !== false ? 0 : 1, "header");
	    if (column.footer) this._fixColspansHidden(column, mode !== false ? 0 : 1, "footer");
	    if (!silent) this._refresh_columns();
	  },
	  _fixColspansHidden: function (config, mod, elName) {
	    for (var i = config[elName].length - 1; i >= 0; i--) {
	      var ind = this._hidden_column_order;
	      var spanSource,
	          isHidden = false,
	          spanSize = 0;

	      for (var j = 0; j < ind.length; j++) {
	        var colConfig = this.getColumnConfig(ind[j]);
	        var el = colConfig[elName][i];

	        if (!this.isColumnVisible(ind[j])) {
	          //hidden column
	          if (el && el.$colspan && spanSize <= 0) {
	            //start of colspan in hidden
	            spanSize = el.colspan = el.$colspan;
	            isHidden = spanSource = el;
	          }

	          if (spanSource && spanSize > 0) {
	            //hidden column in colspan, decrease colspan size
	            spanSource.colspan--;
	          }
	        } else {
	          //visible column
	          if (isHidden && spanSize > 0 && spanSource && spanSource.colspan > 0) {
	            //bit start of colspan is hidden
	            el = colConfig[elName][i] = spanSource;
	            spanSource = el;
	          } else if (el && el.$colspan && spanSize <= 0) {
	            //visible start of colspan
	            spanSize = el.colspan = el.$colspan;
	            spanSource = el;
	          }

	          isHidden = null;
	        }

	        spanSize--;
	      }
	    }
	  },
	  refreshColumns: function (columns, reset) {
	    this._dtable_column_refresh = true;

	    if (columns && columns != this.config.columns || reset) {
	      this._clear_hidden_state();

	      this._filter_elements = {};
	      if (columns) this._rightSplit = columns.length - (this.config.rightSplit || 0);
	    }

	    this._columns_pull = {}; //clear rendered data

	    for (var i = 0; i < this._columns.length; i++) {
	      var col = this._columns[i];
	      this._columns_pull[col.id] = col;
	      col.attached = col.node = null;
	    }

	    for (var _i6 = 0; _i6 < 3; _i6++) {
	      this._header.childNodes[_i6].innerHTML = "";
	      this._body.childNodes[_i6].firstChild.innerHTML = "";
	    } //render new structure


	    this._columns = this.config.columns = columns || this.config.columns;
	    this._rightSplit = this._columns.length - this._settings.rightSplit;
	    this._dtable_fully_ready = 0;

	    this._define_structure();

	    this.callEvent("onStructureUpdate");

	    this._update_scroll();

	    this.render();
	    this._dtable_column_refresh = 0;
	  },
	  _refresh_columns: function () {
	    this._dtable_fully_ready = 0;
	    this.callEvent("onStructureUpdate");

	    this._apply_headers();

	    this.render();
	  },
	  showColumn: function (id, opts, silent) {
	    return this.hideColumn(id, opts, silent, false);
	  },
	  showColumnBatch: function (batch, mode) {
	    var preserve = typeof mode != "undefined";
	    mode = mode !== false;
	    this.eachColumn(function (id, col) {
	      if (col.batch) {
	        var hidden = this._hidden_column_hash[col.id];
	        if (!mode) hidden = !hidden;
	        if (col.batch == batch && hidden) this.hideColumn(col.id, {
	          spans: true
	        }, true, !mode);else if (!preserve && col.batch != batch && !hidden) this.hideColumn(col.id, {
	          spans: true
	        }, true, mode);
	      }
	    }, true);

	    this._refresh_columns();
	  }
	};

	var Mixin$9 = {
	  $init: function () {
	    this.attachEvent("onAfterScroll", this._set_focusable_item);
	    this.attachEvent("onFocus", function () {
	      addCss(this.$view, "webix_dtable_focused");
	    });
	    this.attachEvent("onBlur", function () {
	      removeCss(this.$view, "webix_dtable_focused");
	    });
	  },
	  _set_focusable_item: function () {
	    var sel = this._getVisibleSelection();

	    if (!sel) {
	      var node = this._dataobj.querySelector(".webix_cell");

	      if (node) node.setAttribute("tabindex", "0");
	    }
	  },
	  _getVisibleSelection: function () {
	    var sel = this.getSelectedId(true);

	    for (var i = 0; i < sel.length; i++) {
	      if (this.isColumnVisible(sel[i].column)) return this.getItemNode(sel[i]);
	    }

	    return null;
	  },
	  moveSelection: function (mode, details, focus) {
	    if (this._settings.disabled) return;
	    details = details || {}; //get existing selection as array

	    var t = this.getSelectedId(true);
	    var index$$1 = t.length - 1;
	    var preserve = this._settings.multiselect || this._settings.areaselect ? details.shift : false; //change defaults in case of multiselection

	    if (t.length > 1 && this._settings.select !== "cell") {
	      t = t.sort(bind(function (a, b) {
	        if (this.getIndexById(a.row) > this.getIndexById(b.row) || this.getColumnIndex(a.column) > this.getColumnIndex(b.column)) return 1;else return -1;
	      }, this));
	      if (mode == "up" || mode == "left" || mode == "top" || mode == "pgup") index$$1 = 0;
	    }

	    if (index$$1 < 0 && this.count()) {
	      //no selection
	      if (mode == "down" || mode == "right") mode = "top";else if (mode == "up" || mode == "left") mode = "bottom";else return;
	      index$$1 = 0;
	      t = [{
	        row: 1,
	        column: 1
	      }];
	    }

	    if (index$$1 >= 0) {
	      var row = t[index$$1].row;
	      var column = t[index$$1].column;

	      if (mode == "top" || mode == "bottom") {
	        if (row) {
	          // first/last row setting
	          if (mode == "top") row = this.data.getFirstId();else if (mode == "bottom") row = this.data.getLastId();
	        }

	        if (column) {
	          // first/last column setting
	          index$$1 = 0;
	          if (mode == "bottom") index$$1 = this.config.columns.length - 1;
	          column = this.columnId(index$$1);
	        }
	      } else if (mode == "up" || mode == "down" || mode == "pgup" || mode == "pgdown") {
	        if (row) {
	          //it seems row's can be seleted
	          var _index = this.getIndexById(row);

	          var step = 1;
	          if (mode == "pgup" || mode == "pgdown") step = this._pager ? this._pager.config.size : Math.round(this._dtable_offset_height / this._settings.rowHeight); //get new selection row

	          if (mode == "up" || mode == "pgup") _index -= step;else if (mode == "down" || mode == "pgdown") _index += step; //check that we in valid row range

	          if (_index < 0) _index = 0;
	          if (_index >= this.data.order.length) _index = this.data.order.length - 1;
	          row = this.getIdByIndex(_index);
	          if (!row && this._settings.pager) this.showItemByIndex(_index);
	        }
	      } else if (mode == "right" || mode == "left") {
	        if (column && this.config.select != "row") {
	          //it seems column's can be selected
	          var _index2 = this.getColumnIndex(column); //get new selected column


	          if (mode == "right") _index2++;else if (mode == "left") _index2--; //check that result column index is in valid range

	          if (_index2 < 0) _index2 = 0;
	          if (_index2 >= this.config.columns.length) _index2 = this.config.columns.length - 1;
	          column = this.columnId(_index2);
	        } else if ((this.open || this._subViewStorage) && mode == "right") {
	          return this.open ? this.open(row) : this.openSub(row);
	        } else if ((this.close || this._subViewStorage) && mode == "left") {
	          return this.close ? this.close(row) : this.closeSub(row);
	        }
	      } else {
	        assert(false, "Not supported selection moving mode");
	        return;
	      }

	      if (row) {
	        this.showCell(row, column);

	        if (!this.select) {
	          //switch on cell or row selection by default
	          exports.extend(this, this._selections._commonselect, true);
	          this._settings.select = this.open || this._subViewStorage ? "row" : "cell";
	          exports.extend(this, this._selections[this._settings.select], true);
	        }

	        var cell = {
	          row: row,
	          column: column
	        };

	        if (preserve && this._settings.select == "area") {
	          var last = this._selected_areas[this._selected_areas.length - 1];

	          this._extendAreaRange(cell, last, mode, details);
	        } else this._select(cell, preserve);

	        if (!this._settings.clipboard && focus !== false) {
	          var node = this.getItemNode(cell);
	          if (node) node.focus();
	        }
	      }
	    }

	    return false;
	  }
	};

	var DragOrder$1 = {
	  _add_css: function (source) {
	    var context = DragControl._drag_context;
	    if (!this._settings.prerender) source = [context.start];

	    for (var i = 0; i < source.length; i++) {
	      for (var j = 0; j < this._columns.length; j++) {
	        var node = this.getItemNode({
	          row: source[i],
	          cind: j
	        });
	        if (node) addCss(node, "webix_invisible");
	      }

	      this.data.addMark(source[i], "webix_invisible", 1, 1, true);
	    }
	  },
	  _remove_css: function (source) {
	    var context = DragControl._drag_context;
	    if (!this._settings.prerender) source = [context.start];

	    for (var i = 0; i < source.length; i++) {
	      for (var j = 0; j < this._columns.length; j++) {
	        var node = this.getItemNode({
	          row: source[i],
	          cind: j
	        });
	        if (node) removeCss(node, "webix_invisible");
	      }

	      this.data.removeMark(source[i], "webix_invisible", 1);
	    }
	  },
	  _set_drop_area: function (target) {
	    for (var i = 0; i < this._columns.length; i++) {
	      var column = this._columns[i];
	      var node = this.getItemNode({
	        row: target,
	        cind: i
	      });

	      if (node) {
	        node.parentNode.insertBefore(DragControl._dropHTML[i], node);
	      } else column.node.appendChild(DragControl._dropHTML[i]);
	    }
	  },
	  _init_drop_area: function () {
	    var dropArea = [];
	    var count = this._columns.length;
	    var node = document.createElement("div");
	    node.className = "webix_drop_area";
	    node.style.height = this._settings.rowHeight + "px";
	    node.innerHTML = this.$dropHTML();

	    for (var i = 0; i < count; i++) {
	      dropArea.push(node.cloneNode(true));
	    }

	    return dropArea;
	  }
	};
	var Mixin$a = {
	  drag_setter: function (value) {
	    // disable drag-n-drop for frozen rows
	    this.attachEvent("onBeforeDrag", function (context) {
	      return this._checkDragTopSplit(context.source);
	    });
	    this.attachEvent("onBeforeDragIn", function (context) {
	      var result = this._checkDragTopSplit(context.target);

	      if (!result && DragControl._dropHTML) {
	        remove(DragControl._dropHTML);
	        this._marked_item_id = DragControl._dropHTML = null;
	      }

	      return result;
	    });
	    DragItem.drag_setter.call(this, value);
	    if (value == "order" || value == "move") exports.extend(this, DragOrder$1, true);
	    return value;
	  },
	  _checkDragTopSplit: function (ids) {
	    var i,
	        index$$1,
	        frozen = false;

	    if (this._settings.topSplit && ids) {
	      if (!isArray(ids)) ids = [ids];

	      for (i = 0; !frozen && i < ids.length; i++) {
	        index$$1 = this.getIndexById(ids[i]);
	        frozen = index$$1 >= 0 && index$$1 < this._settings.topSplit;
	      }
	    }

	    return !frozen;
	  },
	  _toHTML: function (obj) {
	    var width = this._content_width - this._scrollSizeY;
	    var html = "<div class='webix_dd_drag' style='width:" + width + "px;'>";
	    var cols = this._settings.columns;

	    for (var i = 0; i < cols.length; i++) {
	      var value = this._getValue(obj, cols[i]);

	      html += "<div style='width:" + cols[i].width + "px;'>" + value + "</div>";
	    }

	    return html + "</div>";
	  },
	  getHeaderNode: function (column_id, row_index) {
	    return this._getHeaderNode(column_id, row_index, this._header);
	  },
	  getFooterNode: function (column_id, row_index) {
	    return this._getHeaderNode(column_id, row_index, this._footer);
	  },
	  _getHeaderNode: function (column_id, row_index, group) {
	    if (this.isColumnVisible(column_id)) {
	      var ind = this.getColumnIndex(column_id);
	      var hind = this._settings.leftSplit > ind ? 0 : this._rightSplit <= ind ? 2 : 1;
	      row_index = row_index || 0;
	      var rows = group.childNodes[hind].getElementsByTagName("TR");

	      if (rows.length) {
	        var nodes = rows[row_index + 1].childNodes;

	        for (var i = 0; i < nodes.length; i++) {
	          if (nodes[i].getAttribute("column") == ind) return nodes[i].firstChild;
	        }
	      }
	    }

	    return null;
	  },
	  getItemNode: function (id) {
	    if (id && !id.header) {
	      var row = id.row || id;
	      var rowindex = typeof id.rind === "number" ? id.rind : this.getIndexById(row);

	      var state = this._get_y_range();

	      var minRow = state[0] - this._settings.topSplit; //row not visible

	      if (rowindex < minRow && rowindex > state[1]) return; //get visible column

	      var x_range = this._get_x_range();

	      var colindex = this._settings.leftSplit ? 0 : x_range[0];
	      var specific = typeof id.cind === "number";

	      if (id.column || specific) {
	        colindex = specific ? id.cind : this.getColumnIndex(id.column); //column not visible

	        if (colindex < this._rightSplit && colindex >= this._settings.leftSplit && (colindex < x_range[0] || colindex > x_range[1])) return;
	      }

	      var column = this._settings.columns[colindex];

	      if (column.attached && column.node) {
	        if (row === "$webix-drop") return DragControl._dropHTML[colindex];
	        var nodeIndex = rowindex < this._settings.topSplit || this._settings.prerender ? rowindex : rowindex - minRow;
	        var nodes = column.node.childNodes;
	        var length = Math.min(nodes.length, nodeIndex + 1);

	        for (var i = 0; i < length; i++) {
	          if (nodes[i].className === "webix_drop_area") nodeIndex++;
	        }

	        return nodes[nodeIndex];
	      }
	    }
	  },
	  _isDraggable: function (e) {
	    var nodeName = (e.target || e.srcElement).nodeName;
	    return nodeName != "INPUT" && nodeName != "TEXTAREA";
	  },
	  dragColumn_setter: function (value) {
	    var control; //will be defined below

	    if (value == "order") {
	      control = {
	        $drag: bind(function (s, e) {
	          if (!this._isDraggable(e) || this._rs_process) return false;
	          var id = this.locate(e);
	          if (!id || !this.callEvent("onBeforeColumnDrag", [id.column, e])) return false;
	          DragControl._drag_context = {
	            from: control,
	            start: id,
	            custom: "column_dnd"
	          };
	          var column = this.getColumnConfig(id.column);
	          this._relative_column_drag = posRelative(e);
	          this._limit_column_drag = column.width;
	          return "<div class='webix_dd_drag_column' style='width:" + column.width + "px'>" + (column.header[0].text || "&nbsp;") + "</div>";
	        }, this),
	        $dragPos: bind(function (pos$$1, e, node) {
	          var context = DragControl.getContext();
	          var box = offset(this.$view);
	          node.style.display = "none";
	          var html = document.elementFromPoint(pos$$1.x, box.y + 1);
	          var id = html ? this.locate(html) : null;
	          var start = DragControl.getContext().start.column;

	          if (id && id.column != start && (!this._column_dnd_temp_block || id.column != this._last_sort_dnd_node)) {
	            //ignore normal dnd , and dnd from other components
	            if (context.custom == "column_dnd" && $$(html) == this) {
	              if (!this.callEvent("onBeforeColumnDropOrder", [start, id.column, e])) return;
	              var start_index = this.getColumnIndex(start);
	              var end_index = this.getColumnIndex(id.column); //on touch devices we need to preserve drag-start element till the end of dnd

	              if (e.touches) {
	                this._dragTarget = e.target;
	                this._dragTarget.style.display = "none";
	                this.$view.parentNode.appendChild(this._dragTarget);
	              }

	              this.moveColumn(start, end_index + (start_index < end_index ? 1 : 0));
	              this._last_sort_dnd_node = id.column;
	              this._column_dnd_temp_block = true;
	            }
	          }

	          if (id && id.column == start) {
	            //flag prevent flickering just after column move
	            this._column_dnd_temp_block = false;
	          }

	          node.style.display = "block";
	          pos$$1.x = pos$$1.x - this._relative_column_drag.x;
	          pos$$1.y = box.y;
	          if (pos$$1.x < box.x) pos$$1.x = box.x;else {
	            var max = box.x + this.$view.offsetWidth - this._scrollSizeY - this._limit_column_drag;
	            if (pos$$1.x > max) pos$$1.x = max;
	          }
	          DragControl._skip = true;
	        }, this),
	        $dragDestroy: bind(function (a, node) {
	          remove(node); //clean dnd source element

	          if (this._dragTarget) remove(this._dragTarget);
	          var id = DragControl.getContext().start;
	          this.callEvent("onAfterColumnDropOrder", [id.column, this._last_sort_dnd_node, a]);
	        }, this),
	        $drop: function () {}
	      };
	    } else if (value) {
	      control = {
	        _inner_drag_only: true,
	        $drag: bind(function (s, e) {
	          if (!this._isDraggable(e) || this._rs_process) return false;
	          var id = this.locate(e);
	          if (!id || !this.callEvent("onBeforeColumnDrag", [id.column, e])) return false;
	          DragControl._drag_context = {
	            from: control,
	            start: id,
	            custom: "column_dnd"
	          };
	          var header = this.getColumnConfig(id.column).header;
	          var text = "&nbsp;";

	          for (var i = 0; i < header.length; i++) {
	            if (header[i]) {
	              text = header[i].text;
	              break;
	            }
	          }

	          return "<div class='webix_dd_drag_column'>" + text + "</div>";
	        }, this),
	        $drop: bind(function (s, t, e) {
	          var target = e; //on touch devices event doesn't point to the actual drop target

	          if (e.touches && this._drag_column_last) target = this._drag_column_last;
	          var id = this.locate(target);
	          if (!id) return false;
	          var start = DragControl.getContext().start.column;

	          if (start != id.column) {
	            if (!this.callEvent("onBeforeColumnDrop", [start, id.column, e])) return;
	            var start_index = this.getColumnIndex(start);
	            var end_index = this.getColumnIndex(id.column);
	            this.moveColumn(start, end_index + (start_index < end_index ? 1 : 0));
	            this.callEvent("onAfterColumnDrop", [start, id.column, e]);
	          }
	        }, this),
	        $dragIn: bind(function (s, t, e) {
	          var context = DragControl.getContext(); //ignore normal dnd , and dnd from other components

	          if (context.custom != "column_dnd" || context.from != control) return false;
	          var target = e.target || e.srcElement;

	          while ((target.className || "").indexOf("webix_hcell") == -1) {
	            target = target.parentNode;
	            if (!target) return;
	          }

	          if (target != this._drag_column_last) {
	            //new target
	            if (this._drag_column_last) removeCss(this._drag_column_last, "webix_dd_over_column");
	            addCss(target, "webix_dd_over_column");
	          }

	          return this._drag_column_last = target;
	        }, this),
	        $dragDestroy: bind(function (a, h) {
	          if (this._drag_column_last) removeCss(this._drag_column_last, "webix_dd_over_column");
	          remove(h);
	        }, this)
	      };
	    }

	    if (value) {
	      DragControl.addDrag(this._header, control);
	      DragControl.addDrop(this._header, control, true);
	    }
	  }
	};

	var Mixin$b = {
	  clearValidation: function () {
	    for (var i in this.data._marks) {
	      this._clear_invalid_css(i);
	    }

	    this.data.clearMark("webix_invalid", true);
	  },
	  _mark_invalid: function (id, details) {
	    this._clear_invalid_css(id);

	    for (var key in details) {
	      this.addCellCss(id, key, "webix_invalid_cell");
	    }

	    this.addCss(id, "webix_invalid");
	  },
	  _clear_invalid: function (id) {
	    this._clear_invalid_css(id);

	    this.removeCss(id, "webix_invalid");
	  },
	  _clear_invalid_css: function (id) {
	    var mark = this.data.getMark(id, "$cellCss");

	    if (mark) {
	      for (var key in mark) {
	        mark[key] = mark[key].replace("webix_invalid_cell", "").replace("  ", " ");
	      }
	    }
	  },
	  addRowCss: function (id, css, silent) {
	    this.addCss(id, css, silent);
	  },
	  removeRowCss: function (id, css, silent) {
	    this.removeCss(id, css, silent);
	  },
	  addCellCss: function (id, name, css, silent) {
	    var mark = this.data.getMark(id, "$cellCss");
	    var newmark = mark || {};
	    var style = newmark[name] || "";
	    newmark[name] = style.replace(css, "").replace("  ", " ") + " " + css;
	    if (!mark) this.data.addMark(id, "$cellCss", false, newmark, true);
	    if (!silent) this.refresh(id);
	  },
	  removeCellCss: function (id, name, css, silent) {
	    var mark = this.data.getMark(id, "$cellCss");

	    if (mark) {
	      var style = mark[name] || "";
	      if (style) mark[name] = style.replace(css, "").replace("  ", " ");
	      if (!silent) this.refresh(id);
	    }
	  }
	};

	var Mixin$c = {
	  _prePrint: function (options, htmlOnly) {
	    if (options.scroll && !htmlOnly) return true;
	    options.header = isUndefined(options.header) ? this.config.header ? true : false : options.header;
	    options.footer = isUndefined(options.footer) ? this.config.footer ? true : false : options.footer;
	    options.xCorrection = options.xCorrection || 0; //spreadsheet
	  },
	  _findIndex: function (arr, func) {
	    var result = -1;

	    for (var i = 0; result < 0 && i < arr.length; i++) {
	      if (func(arr[i])) result = i;
	    }

	    return result;
	  },
	  _getTableHeader: function (base, columns, group) {
	    var spans = {},
	        start = 0;
	    base.forEach(bind(function (tableArray, tid) {
	      var row = tableArray[0],
	          headerArray = [],
	          length = row.length;
	      row.forEach(bind(function (cell, cid) {
	        var column = columns[cid + start];

	        for (var h = 0; h < column[group].length; h++) {
	          var header = column[group][h];
	          if (!header && !(spans[tid] && spans[tid][h])) continue;
	          header = copy(header || {
	            text: ""
	          });

	          if (spans[tid] && spans[tid][h] && cid === 0) {
	            header.colspan = spans[tid][h];
	            spans[tid][h] = 0;
	          }

	          if (header.colspan) {
	            var colspan = Math.min(header.colspan, length - cid);
	            spans[tid + 1] = spans[tid + 1] || {};
	            spans[tid + 1][h] = header.colspan - colspan;
	            header.colspan = colspan;
	          }

	          if (header.rowspan && length === 1) {
	            header.height = (header.height || this.config.headerRowHeight) * header.rowspan;
	            header.rowspan = null;
	          }

	          var hcell = {
	            txt: header.rotate ? this.getHeaderNode(column.id, h).innerHTML : header.text || (header.contentId ? this.getHeaderContent(header.contentId).getValue() : ""),
	            className: "webix_hcell " + "webix_" + group + "_cell " + (header.css || ""),
	            style: {
	              height: (header.height || this.config.headerRowHeight) + "px",
	              width: header.colspan ? "auto" : column.width + "px"
	            },
	            span: header.colspan || header.rowspan ? {
	              colspan: header.colspan || 1,
	              rowspan: header.rowspan || 1
	            } : null
	          };
	          headerArray[h] = headerArray[h] || [];
	          headerArray[h][cid] = hcell;
	        }
	      }, this));
	      if (group == "header") base[tid] = headerArray.concat(tableArray);else base[tid] = tableArray.concat(headerArray);
	      start += length;
	    }, this));
	    return base;
	  },
	  _getTableArray: function (options, base, start) {
	    var columns = this.config.columns;
	    var sel = this.getSelectedId(true);

	    var maxWidth = this._getPageWidth(options);

	    var rightRestriction = 0;
	    var bottomRestriction = 0;
	    var tableArray = [];
	    var newTableStart = 0;
	    start = start || 0 + options.xCorrection;
	    base = base || [];
	    this.eachRow(bind(function (row) {
	      var width = 0;
	      var rowItem = this.getItem(row);
	      var rowIndex = this.getIndexById(row);
	      var colrow = [];
	      var datarow = false;

	      for (var c = start; c < columns.length; c++) {
	        var column = columns[c].id;
	        var colIndex = this.getColumnIndex(column) - start;

	        if (columns[c]) {
	          width += columns[c].width;

	          if (width > maxWidth && c > start) {
	            // 'c>start' ensures that a single long column will have to fit the page
	            newTableStart = c;
	            break;
	          }

	          if (options.data !== "selection" || options.data == "selection" && this._findIndex(sel, function (obj) {
	            return obj.column == column && obj.row == row;
	          }) !== -1) {
	            var span;
	            if (this.getSpan) span = this.getSpan(row, column); //check span from previous table

	            if (span && this.getColumnIndex(column) === start) {
	              var spanStart = this.getColumnIndex(span[1]);

	              if (spanStart < start) {
	                span[2] = span[2] - (start - spanStart);
	                span[4] = span[4] ? span[4] : rowItem[span[1]] ? this.getText(row, span[1]) : null;
	                span[1] = column;
	              }
	            }

	            if (!span || span && span[0] == row && span[1] == column) {
	              var cellValue = span && span[4] ? span[4] : this._columns_pull[column] ? this.getText(row, column) : "";
	              var className = this.getCss(row, column) + " " + (columns[c].css || "") + (span ? " webix_dtable_span " + (span[5] || "") : "");
	              var style = {
	                height: span && span[3] > 1 ? "auto" : (rowItem.$height || this.config.rowHeight) + "px",
	                width: span && span[2] > 1 ? "auto" : columns[c].width + "px"
	              };
	              colrow.push({
	                txt: cellValue,
	                className: className,
	                style: style,
	                span: span ? {
	                  colspan: span[2],
	                  spanStart: this.getColumnIndex(span[1]),
	                  rowspan: span[3]
	                } : null
	              });

	              if (cellValue) {
	                rightRestriction = Math.max(colIndex + 1, rightRestriction);
	                bottomRestriction = Math.max(rowIndex + 1, bottomRestriction);
	              }

	              datarow = datarow || !!cellValue;
	            } else if (span) {
	              colrow.push({
	                $inspan: true
	              });
	              rightRestriction = Math.max(colIndex + 1, rightRestriction);
	              bottomRestriction = Math.max(rowIndex + 1, bottomRestriction);
	            }
	          }
	        }
	      }

	      if (!options.skiprows || datarow) tableArray.push(colrow);
	    }, this));

	    if (bottomRestriction && rightRestriction) {
	      if (options.trim) {
	        tableArray.length = bottomRestriction;
	        tableArray = tableArray.map(function (item) {
	          for (var i = item.length - 1; i >= 0; i--) {
	            if (item[i].span && item[i].span.colspan) {
	              item[i].span.colspan = Math.min(item[i].span.colspan, item.length - i);
	              break;
	            }
	          }

	          item.length = rightRestriction;
	          return item;
	        });
	      }

	      base.push(tableArray);
	    }

	    if (newTableStart) this._getTableArray(options, base, newTableStart);else {
	      //keep this order as logic relies on the first data row
	      if (options.footer) base = this._getTableHeader(base, columns, "footer");
	      if (options.header) base = this._getTableHeader(base, columns, "header");
	    }
	    return base;
	  },
	  _getTableHTML: function (tableData, options) {
	    var container = create("div");
	    tableData.forEach(bind(function (table, i) {
	      var tableHTML = create("table", {
	        "class": "webix_table_print " + this.$view.className + (options.borderless ? " borderless" : ""),
	        "style": "border-collapse:collapse",
	        "id": this.$view.getAttribute("id")
	      });
	      table.forEach(function (row) {
	        var tr = create("tr");
	        row.forEach(function (cell) {
	          if (!cell.$inspan) {
	            var td = create("td");
	            td.innerHTML = cell.txt;
	            td.className = cell.className;

	            for (var key in cell.style) {
	              td.style[key] = cell.style[key];
	            }

	            if (cell.span) {
	              td.colSpan = cell.span.colspan;
	              td.rowSpan = cell.span.rowspan;
	            }

	            tr.appendChild(td);
	          }
	        });
	        tableHTML.appendChild(tr);
	      });
	      container.appendChild(tableHTML);

	      if (i + 1 < tableData.length) {
	        var br = create("DIV", {
	          "class": "webix_print_pagebreak"
	        });
	        container.appendChild(br);
	      }
	    }, this));
	    return container;
	  }
	};

	var Mixin$d = {
	  $exportView: function (options) {
	    if (this.isBranchOpen) //treetable
	      exports.extend(options, {
	        filterHTML: true
	      });
	    if (options.export_mode !== "excel" || options.dataOnly || !options.styles) return this;else {
	      //excel export with styles
	      options.dataOnly = true;
	      options.heights = isUndefined(options.heights) ? "all" : options.heights;
	      var data = toExcel(this, options);
	      data[0].styles = this._getExportStyles(options);
	      delete options.dataOnly;
	      return data;
	    }
	  },
	  _getExportStyles: function (options) {
	    var columns = this.config.columns,
	        styles = [];
	    this._style_hash = this._style_hash || {};
	    if (options.docHeader) styles = [{
	      0: this._getExportDocStyle(options.docHeader.css)
	    }, {
	      0: {}
	    }];
	    if (options.header !== false) styles = this._getExportHStyles(options, "header", styles);
	    this.data.each(function (obj) {
	      var row = {};

	      for (var i = 0; i < columns.length; i++) {
	        var cellCss = this.getCss(obj.id, columns[i].id);
	        var columnCss = columns[i].node.className;
	        var spanCss = "";
	        var evenCss = this.getIndexById(obj.id) % 2 ? "even" : "odd"; //for skins like metro, web, air

	        var span = null;
	        var node = null;

	        if (this._spans_pull && (span = this.getSpan(obj.id, columns[i].id))) {
	          node = this.getSpanNode({
	            row: span[0],
	            column: span[1]
	          });
	          spanCss = "webix_dtable_span " + (span[5] || "");
	        } else node = this.getItemNode({
	          row: obj.id,
	          column: columns[i].id
	        });

	        if (!node) {
	          node = create("div", {
	            "class": cellCss,
	            style: "visibility:hidden"
	          });
	          var cnode = columns[i].node;

	          if (!columns[i].attached) {
	            cnode = create("div", {
	              "class": columnCss,
	              style: "visibility:hidden"
	            });

	            this._body.appendChild(cnode);
	          }

	          cnode.appendChild(node);
	        }

	        row[i] = this._getExportCellStyle(node, [cellCss, columnCss, spanCss, evenCss].join(":"));
	      }

	      styles[styles.length] = row;
	    }, this);
	    if (options.footer !== false && this.config.footer) styles = this._getExportHStyles(options, "footer", styles);
	    if (options.docFooter) styles = styles.concat([{
	      0: {}
	    }, {
	      0: this._getExportDocStyle(options.docFooter.css)
	    }]);
	    return styles;
	  },
	  _getExportHStyles: function (options, group, styles) {
	    var columns = this.config.columns,
	        hs = []; //spans

	    for (var h = 0; h < columns[0][group].length; h++) {
	      var hrow = {};

	      for (var i = 0; i < columns.length; i++) {
	        var header = columns[i][group][h]; //ToDo:make sure it is rendered and attached

	        if (header) {
	          //can be null
	          var cid = header.colspan ? columns[i + header.colspan - 1].id : columns[i].id;
	          var node = group == "header" ? this.getHeaderNode(cid, h) : this.getFooterNode(cid, h);

	          if (node) {
	            var name = [node.parentNode.className, header.css || "", "webix_hcell", group];
	            hrow[i] = this._getExportCellStyle(node, name.join(":"));
	            if (header.colspan || header.rowspan) hs.push([h, i, {
	              colspan: header.colspan - 1 || 0,
	              rowspan: header.rowspan - 1 || 0
	            }, hrow[i]]);
	          }
	        } else {
	          for (var s = 0; s < hs.length; s++) {
	            var st = hs[s][2],
	                hsc = hs[s][1],
	                hsr = hs[s][0];
	            if (hsc + st.colspan >= i && hsr + st.rowspan >= h) hrow[i] = hs[s][3];
	          }
	        }
	      }

	      styles[styles.length] = hrow;
	    }

	    return styles;
	  },
	  _getExportCellStyle: function (node, name) {
	    if (this._style_hash[name]) return this._style_hash[name];else {
	      var base = this._getRules(node);

	      var rules = {
	        font: {},
	        alignment: {},
	        border: {}
	      }; //font

	      rules.font.name = base["font-family"].replace(/,.*$/, ""); // cut off fallback font;

	      rules.font.sz = base["font-size"].replace("px", "") * 0.75; //px to pt conversion

	      rules.font.color = {
	        rgb: color.rgbToHex(base["color"])
	      };
	      if (base["font-weight"] !== "normal") rules.font.bold = true;
	      if (base["text-decoration-line"] === "underline") rules.font.underline = true;
	      if (base["font-style"] === "italic") rules.font.italic = true;
	      if (base["text-decoration-line"] === "line-through") rules.font.strike = true; //alignment

	      rules.alignment.horizontal = base["text-align"];
	      rules.alignment.vertical = base["height"] == base["line-height"] ? "center" : "top";
	      if (base["white-space"] == "normal") rules.alignment.wrapText = true; //rotated header

	      if (node.firstChild && node.firstChild.className && node.firstChild.className.indexOf("webix_rotate") !== -1) rules.alignment.textRotation = 90; //background

	      var bg = color.rgbToHex(base["background-color"]) || "FFFFFF";
	      rules.fill = {
	        fgColor: {
	          rgb: bg
	        }
	      };
	      if (base["background-image"].indexOf("gradient") !== -1) //air skins use gradient for header
	        rules.fill = {
	          fgColor: {
	            rgb: color.rgbToHex(base["background-image"].substring(base["background-image"].lastIndexOf("(")))
	          }
	        }; //borders

	      if (node.parentNode && node.parentNode.nodeName == "TD") //borders for header are set for parent td, so we change base rules here
	        base = this._getRules(node.parentNode);
	      if (base["border-right-width"] !== "0px") rules.border.right = {
	        style: "thin",
	        color: {
	          rgb: color.rgbToHex(base["border-right-color"]) || bg
	        }
	      };
	      if (base["border-bottom-width"] !== "0px") rules.border.bottom = {
	        style: "thin",
	        color: {
	          rgb: color.rgbToHex(base["border-bottom-color"]) || bg
	        }
	      };
	      if (base["border-left-width"] !== "0px") rules.border.left = {
	        style: "thin",
	        color: {
	          rgb: color.rgbToHex(base["border-left-color"]) || bg
	        }
	      };
	      if (base["border-top-width"] !== "0px") rules.border.top = {
	        style: "thin",
	        color: {
	          rgb: color.rgbToHex(base["border-top-color"]) || bg
	        }
	      };
	      this._style_hash[name] = rules;
	      return rules;
	    }
	  },
	  _getExportDocStyle: function (css) {
	    css = exports.extend(css || {}, {
	      visibility: "hidden",
	      "white-space": "nowrap",
	      "text-align": "left"
	    });
	    var cssStr = "";

	    for (var i in css) {
	      cssStr += i + ":" + css[i] + ";";
	    }

	    var node = create("div", {
	      style: cssStr
	    });

	    this._body.appendChild(node);

	    var style = this._getExportCellStyle(node, cssStr);

	    remove(node);
	    return style;
	  },
	  _getRules: function (node) {
	    var style = {};
	    if (window.getComputedStyle) style = window.getComputedStyle(node);else style = node.currentStyle;
	    return style;
	  }
	};

	var temp$5 = {};

	var temp$6 = {};

	var temp$7 = {};

	var api$1d = {
	  name: "datatable",
	  defaults: {
	    leftSplit: 0,
	    rightSplit: 0,
	    topSplit: 0,
	    columnWidth: 100,
	    minColumnWidth: 20,
	    minColumnHeight: 26,
	    prerender: false,
	    autoheight: false,
	    autowidth: false,
	    header: true,
	    fixedRowHeight: true,
	    scrollAlignY: true,
	    scrollX: true,
	    scrollY: true,
	    datafetch: 50,
	    navigation: true
	  },
	  $skin: function () {
	    this.defaults.rowHeight = $active.rowHeight;
	    this.defaults.headerRowHeight = $active.barHeight - $active.borderWidth * 2;
	  },
	  on_click: {
	    webix_richfilter: function () {
	      return false;
	    },
	    webix_table_checkbox: function (e, id) {
	      id = this.locate(e);
	      var item = this.getItem(id.row);
	      var col = this.getColumnConfig(id.column);
	      var trg = e.target || e.srcElement; //read actual value from HTML tag when possible
	      //as it can be affected by dbl-clicks

	      var check = trg.type == "checkbox" ? trg.checked : item[id.column] != col.checkValue;
	      var value = check ? col.checkValue : col.uncheckValue;
	      var update = {};
	      update[id.column] = value;
	      this.updateItem(id.row, update, this._settings.checkboxRefresh ? "update" : "save");
	      this.callEvent("onCheck", [id.row, id.column, value]);
	      return false;
	    },
	    webix_table_radio: function (e) {
	      var id = this.locate(e);
	      var item = this.getItem(id.row);
	      var col = this.getColumnConfig(id.column);
	      this.eachRow(function (rowid) {
	        var item = this.data.pull[rowid];
	        if (item && item[id.column] == col.checkValue) item[id.column] = col.uncheckValue;
	      });
	      item[id.column] = col.checkValue;
	      this.callEvent("onCheck", [id.row, id.column, true]);
	      this.refresh();
	      return false;
	    }
	  },
	  on_dblclick: {
	    webix_table_checkbox: function () {
	      return this.on_click.webix_table_checkbox.apply(this, arguments);
	    }
	  },
	  on_context: {},
	  $init: function (config) {
	    this.on_click = exports.extend({}, this.on_click);
	    var html = "<div class='webix_ss_header'><div class='webix_hs_left'></div><div class='webix_hs_center'></div><div class='webix_hs_right'></div></div><div class='webix_ss_body'><div class='webix_ss_left'><div class='webix_ss_center_scroll'></div></div>";
	    html += "<div class='webix_ss_center'><div class='webix_ss_center_scroll' role='rowgroup'></div></div>";
	    html += "<div class='webix_ss_right'><div class='webix_ss_center_scroll'></div></div></div>";
	    html += "<div class='webix_ss_hscroll' role='scrollbar' aria-orientation='horizontal'></div><div class='webix_ss_footer'><div class='webix_hs_left'></div><div class='webix_hs_center'></div><div class='webix_hs_right'></div></div><div class='webix_ss_vscroll_header'></div><div class='webix_ss_vscroll' role='scrollbar' aria-orientation='vertical'></div><div class='webix_ss_vscroll_footer'></div>";
	    this._contentobj.innerHTML = html;
	    this._top_id = this._contentobj.id = this.name + uid();
	    this._contentobj.className += " webix_dtable";
	    this._dataobj = this._contentobj;
	    this._header = this._contentobj.firstChild;
	    this._body = this._header.nextSibling;
	    this._footer = this._body.nextSibling.nextSibling;

	    this._viewobj.setAttribute("role", "grid");

	    if (!config.editable) this._viewobj.setAttribute("aria-readonly", "true");
	    this.data.provideApi(this, true);
	    this.data.attachEvent("onParse", bind(this._call_onparse, this));
	    this.$ready.push(this._first_render);
	    this._columns = [];
	    this._hidden_column_order = [];
	    this._headers = [];
	    this._footers = [];
	    this._rows_cache = [];
	    this._active_headers = {};
	    this._filter_elements = {};
	    this._header_height = this._footer_height = 0; //component can create new view

	    this._destroy_with_me = [];
	    this.data.attachEvent("onServerConfig", bind(this._config_table_from_file, this));
	    this.data.attachEvent("onServerOptions", bind(this._config_options_from_file, this));
	    this.attachEvent("onViewShow", function () {
	      this._restore_scroll_state();

	      this._refresh_any_header_content();
	    });
	    this.data.attachEvent("onClearAll", bind(function (soft) {
	      if (!soft) {
	        this._scrollLeft = this._scrollTop = 0;
	        if (this._x_scroll) this._x_scroll.reset();
	        if (this._y_scroll) this._y_scroll.reset();

	        this._setLeftScroll(0);
	      }
	    }, this));
	    this.attachEvent("onDestruct", this._clean_config_struct);
	    this.attachEvent("onKeyPress", this._onKeyPress);
	    this.attachEvent("onScrollY", this._adjust_rows);
	    callEvent("onDataTable", [this, config]);
	  },
	  _render_initial: function () {
	    this._scrollSizeX = this._scrollSizeY = env.scrollSize;
	    addStyle("#" + this._top_id + " .webix_cell { height:" + this._settings.rowHeight + "px; line-height:" + (this._settings.rowLineHeight || this._settings.rowHeight) + "px;" + (this._settings.fixedRowHeight ? "" : "white-space:normal;") + " }");
	    addStyle("#" + this._top_id + " .webix_hcell { height:" + this._settings.headerRowHeight + "px; line-height:" + this._settings.headerRowHeight + "px;}");

	    this._render_initial = function () {};
	  },
	  _first_render: function () {
	    this.data.attachEvent("onStoreLoad", bind(this._refresh_any_header_content, this));
	    this.data.attachEvent("onSyncApply", bind(this._refresh_any_header_content, this));
	    this.data.attachEvent("onStoreUpdated", bind(function () {
	      return this.render.apply(this, arguments);
	    }, this));
	    this.data.attachEvent("onStoreUpdated", bind(this._refresh_tracking_header_content, this));
	    this.render();
	  },
	  refresh: function () {
	    this.render();
	  },
	  render: function (id, data, mode) {
	    //pure data saving call
	    if (mode == "save") return; //during dnd we must not repaint anything in mobile webkit

	    if (mode == "move") {
	      var context = DragControl.getContext();
	      if (context && context.fragile) return;
	    }

	    if (!this._columns.length) {
	      var cols = this._settings.columns;

	      if (!cols || !cols.length) {
	        if (this._settings.autoConfig && this.data.order.length && !this._hidden_column_order.length) {
	          this._dtable_fully_ready = 0;

	          this._autoDetectConfig();
	        } else return;
	      }

	      this._define_structure();
	    }

	    if (!this.isVisible(this._settings.id) || this.$blockRender) return this._render_initial(); //Chrome 34, Custom Font loading bug

	    var fast_mode = this.config.experimental && !this._settings.subview; //replace multiple atomic updates by single big repaint

	    if (id && data != -1 && (mode == "paint" || mode == "update") && !fast_mode) {
	      if (this._render_timer) clearTimeout(this._render_timer);

	      if (!this._render_timer || this._render_timer_id == id) {
	        this._render_timer_id = id;
	        this._render_timer = delay(function () {
	          //if only one call - repaint single item
	          this.render(id, -1, mode);
	        }, this);
	      } else {
	        this._render_timer_id = null;
	        this._render_timer = delay(function () {
	          //if ther was a serie of calls - replace them with single full repaint
	          this.render();
	        }, this);
	      }

	      return;
	    } else if (this._render_timer) {
	      clearTimeout(this._render_timer);
	      this._render_timer = 0;
	    }

	    if (this.callEvent("onBeforeRender", [this.data])) {
	      this._render_initial();

	      if (!this._dtable_fully_ready) this._apply_headers();

	      if (this._content_width) {
	        if (fast_mode && (mode == "paint" || mode == "update") && id) this._repaint_single_row(id);else this._check_rendered_cols(true, true);
	      }

	      if (!id || mode != "update") {
	        this._dtable_height = this._get_total_height();

	        this._set_split_sizes_y();
	      } //don't depend on hidden rows/rolumns


	      this._viewobj.setAttribute("aria-colcount", Math.max(this._hidden_column_order.length, this._columns.length));

	      this._viewobj.setAttribute("aria-rowcount", this.data.count());

	      this.callEvent("onAfterRender", [this.data]);
	      return true;
	    }
	  },
	  getColumnConfig: function (id) {
	    return this._columns_pull[id] || this._hidden_column_hash[id];
	  },
	  _config_options_from_file: function (colls) {
	    for (var key in colls) {
	      var column = this.getColumnConfig(key);
	      assert(column, "Orphan collection: " + key);
	      var temp = new DataCollection({
	        data: colls[key]
	      });

	      this._destroy_with_me.push(temp);

	      this._bind_collection(temp, column);
	    }
	  },
	  //xml has different configuration structure, fixing
	  _config_table_from_file: function (config) {
	    if (config.columns && this._dtable_fully_ready) this.refreshColumns(null, true);
	  },
	  _define_structure: function () {
	    if (this._settings.columns) {
	      this._columns = this._settings.columns;
	      this._columns_pull = {};

	      for (var i = 0; i < this._columns.length; i++) {
	        var col = this._columns[i];
	        this._columns_pull[col.id] = col;
	        var format = col.cssFormat;
	        if (format) col.cssFormat = toFunctor(format, this.$scope);
	        col.width = col.width || this._settings.columnWidth;
	        if (typeof col.format == "string") col.format = i18n[col.format] || window[col.format];

	        if (col.numberFormat) {
	          var nformat = col.numberFormat;
	          if (typeof nformat === "string") col.numberFormat = nformat = Number$1.getConfig(nformat);
	          col.format = Number$1.numToStr(nformat);

	          col.editFormat = col.editFormat || function (val) {
	            return Number$1.format(val, nformat);
	          };

	          col.editParse = col.editParse || function (val) {
	            return Number$1.parse(val, nformat);
	          };
	        } //default settings for checkboxes and radios


	        if (isUndefined(col.checkValue)) col.checkValue = 1;
	        if (isUndefined(col.uncheckValue)) col.uncheckValue = 0;
	        if (col.css && _typeof(col.css) == "object") col.css = createCss(col.css);
	        var rawTemplate = col.template;

	        if (rawTemplate) {
	          if (typeof rawTemplate == "string") rawTemplate = rawTemplate.replace(/#\$value#/g, "#" + col.id + "#");
	          col.template = template(rawTemplate);
	        }
	      }

	      this._normalize_headers("header", this._headers);

	      this._normalize_headers("footer", this._footers);

	      this.callEvent("onStructureLoad", []);
	    }
	  },
	  _define_structure_and_render: function () {
	    this._apply_headers();
	  },
	  _clean_config_struct: function () {
	    //remove column technical info from the column
	    //it allows to reuse the same config object for new grid
	    for (var i = 0; i < this._columns.length; i++) {
	      delete this._columns[i].attached;
	      delete this._columns[i].node;
	    }
	  },
	  _apply_headers: function () {
	    this._rightSplit = this._columns.length - this._settings.rightSplit;
	    this._dtable_width = 0;

	    for (var i = 0; i < this._columns.length; i++) {
	      if (!this._columns[i].node) {
	        var temp = create("DIV");
	        temp.style.width = this._columns[i].width + "px";
	        this._columns[i].node = temp;
	      }

	      if (i >= this._settings.leftSplit && i < this._rightSplit) this._dtable_width += this._columns[i].width;
	    }

	    var marks = [];

	    if (this._settings.rightSplit) {
	      var nr = this._columns.length - this._settings.rightSplit;
	      marks[nr] = " webix_first";
	      marks[nr - 1] = " webix_last";
	    }

	    if (this._settings.leftSplit) {
	      var nl = this._settings.leftSplit;
	      marks[nl] = " webix_first";
	      marks[nl - 1] = " webix_last";
	    }

	    marks[0] = (marks[0] || "") + " webix_first webix_select_mark";
	    var last_index = this._columns.length - 1;
	    marks[last_index] = (marks[last_index] || "") + " webix_last";

	    for (var _i = 0; _i < this._columns.length; _i++) {
	      var node = this._columns[_i].node;
	      node.setAttribute("column", _i);
	      node.className = "webix_column " + (this._columns[_i].css || "") + (marks[_i] || "");
	    }

	    this._create_scrolls();

	    this._set_columns_positions();

	    this._set_split_sizes_x();

	    this._render_header_and_footer();

	    this._dtable_fully_ready = true;
	  },
	  _set_columns_positions: function () {
	    var left = 0;

	    for (var i = 0; i < this._columns.length; i++) {
	      var column = this._columns[i];
	      if (i == this._settings.leftSplit || i == this._rightSplit) left = 0;

	      if (column.node) {
	        column.node.style.left = left + "px";

	        if (this._settings.leftSplit || this._settings.rightSplit) {
	          remove(column.node);
	          column.attached = false;
	        }
	      }

	      left += column.width;
	    }
	  },
	  _render_header_and_footer: function () {
	    if (!this._header_fix_width) this._header_fix_width = 0;
	    this._header_height = this._footer_height = 0;

	    if (this._settings.header) {
	      this._refreshHeaderContent(this._header, 0, 1);

	      this._normalize_headers("header", this._headers);

	      this._header_height = this._headers._summ;

	      this._render_header_section(this._header, "header", this._headers);
	    }

	    if (this._settings.footer) {
	      this._refreshHeaderContent(this._footer, 0, 1);

	      this._normalize_headers("footer", this._footers);

	      this._footer_height = this._footers._summ;

	      this._render_header_section(this._footer, "footer", this._footers);
	    }

	    this.refreshHeaderContent(false, false);

	    this._size_header_footer_fix();

	    if (this._last_sorted) this.markSorting(this._last_sorted, this._last_order);
	  },
	  _getHeaderHeight: function (header, column, ind) {
	    var width = 0;
	    var colspan = header.colspan || 1;
	    var css = "webix_hcell " + (header.css || "");
	    if (header.rotate) css += " webix_measure_rotate";else for (var i = 0; i < colspan; i++) {
	      width += this._columns[ind + i] ? this._columns[ind + i].width : this.config.columnWidth;
	    }
	    var size = getTextSize([header.text], css, width); //+1 to compensate for scrollHeight rounding

	    return (header.rotate ? size.width : size.height) + 1;
	  },
	  _normalize_headers: function (collection, heights) {
	    var rows = 0;

	    for (var i = 0; i < this._columns.length; i++) {
	      var data = this._columns[i][collection];

	      if (!data || _typeof(data) != "object" || !data.length) {
	        if (isUndefined(data)) {
	          if (collection == "header") data = this._columns[i].id;else data = "";
	        }

	        data = [data];
	      }

	      for (var j = 0; j < data.length; j++) {
	        if (_typeof(data[j]) != "object") data[j] = {
	          text: data[j]
	        };
	        if (data[j] && data[j].height) heights[j] = data[j].height;
	        if (data[j] && data[j].autoheight) heights[j] = this._getHeaderHeight(data[j], this._columns[i], i);
	      }

	      rows = Math.max(rows, data.length);
	      this._columns[i][collection] = data;
	    }

	    heights._summ = rows;

	    for (var _i2 = rows - 1; _i2 >= 0; _i2--) {
	      heights[_i2] = heights[_i2] || this._settings.headerRowHeight;
	      heights._summ += heights[_i2] * 1;
	    } //set null to cells included in col|row spans


	    for (var _i3 = 0; _i3 < this._columns.length; _i3++) {
	      var col = this._columns[_i3][collection];

	      for (var _j = 0; _j < col.length; _j++) {
	        if (col[_j] && col[_j].rowspan) for (var z = 1; z < col[_j].rowspan; z++) {
	          col[_j + z] = null;
	        }
	        if (col[_j] && col[_j].colspan) for (var _z = 1; _z < col[_j].colspan; _z++) {
	          this._columns[_i3 + _z][collection][_j] = null;
	        }
	      }
	    } //auto-rowspan cells, which has not enough header lines


	    for (var _i4 = 0; _i4 < this._columns.length; _i4++) {
	      var _data = this._columns[_i4][collection];

	      if (_data.length < rows) {
	        var end = _data.length - 1;
	        _data[end].rowspan = rows - _data.length + 1;

	        for (var _j2 = end + 1; _j2 < rows; _j2++) {
	          _data[_j2] = null;
	        }
	      }
	    }

	    return rows;
	  },
	  _find_header_content: function (sec, id) {
	    var alltd = sec.getElementsByTagName("TD");

	    for (var i = 0; i < alltd.length; i++) {
	      if (alltd[i].getAttribute("active_id") == id) return alltd[i];
	    }
	  },
	  getHeaderContent: function (id) {
	    var obj = this._find_header_content(this._header, id);

	    if (!obj) obj = this._find_header_content(this._footer, id);

	    if (obj) {
	      var config = this._active_headers[id];
	      var type$$1 = datafilter[config.content];
	      var _base = {
	        type: type$$1,
	        getValue: function (text) {
	          return type$$1.getValue(obj, text);
	        },
	        setValue: function (value) {
	          return type$$1.setValue(obj, value);
	        }
	      };
	      if (type$$1.getHelper) exports.extend(_base, type$$1.getHelper(obj, config));
	      return _base;
	    }
	  },
	  _summ_next: function (heights, start, i) {
	    var summ = i ? -1 : 0;
	    i += start;

	    for (start; start < i; start++) {
	      summ += heights[start] + 1;
	    }

	    return summ;
	  },
	  _render_subheader: function (start, end, width, name, heights) {
	    if (start == end) return "";
	    var html = "<table role='presentation' style='width:" + width + "px' cellspacing='0' cellpadding='0'>";
	    html += "<tr class='webix_size_row'>";

	    for (var i = start; i < end; i++) {
	      html += "<td style='width:" + this._columns[i].width + "px;'></td>";
	    }

	    html += "</tr>";
	    var count = this._columns[0][name].length;

	    for (var j = 0; j < count; j++) {
	      html += "<tr section='" + name + "' role='row'>";

	      for (var _i5 = start; _i5 < end; _i5++) {
	        var header = this._columns[_i5][name][j];
	        if (header === null) continue;

	        if (header.content) {
	          header.contentId = header.contentId || uid();
	          header.columnId = this._columns[_i5].id;
	          header.format = this._columns[_i5].format;
	          assert(datafilter, "Filtering extension was not included");
	          assert(datafilter[header.content], "Unknown content type: " + header.content);
	          header.text = datafilter[header.content].render(this, header);
	          this._active_headers[header.contentId] = header;
	          this._has_active_headers = true;
	        }

	        html += "<td  role='presentation' column='" + (header.colspan ? header.colspan - 1 + _i5 : _i5) + "'";
	        var hcss = "";
	        if (_i5 == start) hcss += "webix_first";
	        var column_pos = _i5 + (header.colspan ? header.colspan - 1 : 0);
	        if (column_pos >= end - 1) hcss += " webix_last";
	        if (header.rowspan && j + header.rowspan === count || j === count - 1) hcss += " webix_last_row";
	        if (hcss) html += " class=\"" + hcss + "\"";
	        var cell_height = heights[j];
	        var sheight = "";
	        if (header.contentId) html += " active_id='" + header.contentId + "'";
	        if (header.colspan) html += " colspan='" + header.colspan + "'";

	        if (header.rowspan) {
	          html += " rowspan='" + header.rowspan + "'";
	          cell_height = this._summ_next(this._headers, j, header.rowspan);
	        }

	        if (cell_height != this._settings.headerRowHeight) sheight = " style='line-height:" + cell_height + "px; height:" + cell_height + "px;'";
	        var css = "webix_hcell";
	        var header_css = header.css;

	        if (header_css) {
	          if (_typeof(header_css) == "object") header.css = header_css = createCss(header_css);
	          css += " " + header_css;
	        }

	        if (this._columns[_i5].$selected) css += " webix_sel_hcell";
	        html += "><div role='columnheader' class='" + css + "'" + sheight + ">";
	        var text = header.text === "" ? "&nbsp;" : header.text;
	        if (header.rotate) text = "<div class='webix_rotate' style='width:" + (cell_height - 10) + "px; transform-origin:center " + (cell_height - 15) / 2 + "px;-webkit-transform-origin:center " + (cell_height - 15) / 2 + "px;'>" + text + "</div>";
	        html += text + "</div></td>";
	      }

	      html += "</tr>";
	    }

	    html += "</tr></table>";
	    return html;
	  },
	  showItemByIndex: function (row_ind, column_ind) {
	    var pager = this._settings.pager;

	    if (pager) {
	      var target = Math.floor(row_ind / pager.size);
	      if (target != pager.page) $$(pager.id).select(target);
	    } //parameter will be set to -1, to mark that scroll need not to be adjusted


	    var scroll = this.getScrollState();

	    if (row_ind != -1) {
	      var state = this._get_y_range();

	      if (row_ind < state[0] + 1 || row_ind >= state[1] - 1) {
	        //not visible currently
	        var summ = this._getHeightByIndexSumm(pager ? this.data.$min : 0, row_ind);

	        if (row_ind < state[0] + 1) {
	          //scroll top - show row at top of screen
	          summ = Math.max(0, summ - 1) - this._top_split_height;
	        } else {
	          //scroll bottom - show row at bottom of screen
	          summ += this._getHeightByIndex(row_ind) - this._dtable_offset_height; //because of row rounding we neet to scroll some extra
	          //TODO: create a better heuristic

	          if (row_ind > 0) summ += this._getHeightByIndex(row_ind - 1) - 1;
	        }

	        scroll.y = summ;
	      }
	    }

	    if (column_ind != -1) {
	      //ignore split columns - they are always visible
	      if (column_ind < this._settings.leftSplit) return;
	      if (column_ind >= this._rightSplit) return; //very similar to y-logic above

	      var _state = this._get_x_range();

	      if (column_ind < _state[0] + 1 || column_ind >= _state[1] - 1) {
	        //not visible currently
	        var _summ = 0;

	        for (var i = this._settings.leftSplit; i < column_ind; i++) {
	          _summ += this._columns[i].width;
	        }
	        /*jsl:ignore*/


	        if (column_ind < _state[0] + 1) ; else {
	          //scroll to right border
	          _summ += this._columns[column_ind].width - this._center_width;
	        }
	        /*jsl:end*/


	        scroll.x = _summ;
	      }
	    }

	    this.scrollTo(scroll.x, scroll.y);
	  },
	  showCell: function (row, column) {
	    if (!column || !row) {
	      //if column or row not provided - take from current selection
	      var t = this.getSelectedId(true);

	      if (t.length == 1) {
	        column = column || t[0].column;
	        row = row || t[0].row;
	      }
	    } //convert id to index


	    column = column ? this.getColumnIndex(column) : -1;
	    row = row ? this.getIndexById(row) : -1;
	    this.showItemByIndex(row, column);
	  },
	  scrollTo: function (x, y) {
	    if (!this._x_scroll) return;
	    if (this._scrollTo_touch) return this._scrollTo_touch(x, y);
	    if (x !== null) this._x_scroll.scrollTo(x);
	    if (y !== null) this._y_scroll.scrollTo(y);
	  },
	  getScrollState: function () {
	    if (this._getScrollState_touch) return this._getScrollState_touch();
	    var diff = this._render_scroll_shift ? 0 : this._render_scroll_diff || 0;
	    return {
	      x: this._scrollLeft || 0,
	      y: this._scrollTop + diff
	    };
	  },
	  showItem: function (id) {
	    this.showItemByIndex(this.getIndexById(id), -1);
	  },
	  _render_header_section: function (sec, name, heights) {
	    var header = sec.childNodes;
	    header[0].innerHTML = this._render_subheader(0, this._settings.leftSplit, this._left_width, name, heights);
	    header[1].innerHTML = this._render_subheader(this._settings.leftSplit, this._rightSplit, this._dtable_width, name, heights);
	    header[2].innerHTML = this._render_subheader(this._rightSplit, this._columns.length, this._right_width, name, heights);
	    if (this._dtable_column_refresh) header[1].scrollLeft = this.getScrollState().x;
	    header[1].onscroll = bind(this._scroll_with_header, this);
	  },
	  _scroll_with_header: function () {
	    var active = this.getScrollState().x;
	    var header = this._header.childNodes[1].scrollLeft;
	    if (header != active) this.scrollTo(header, null);
	  },
	  _refresh_tracking_header_content: function () {
	    this.refreshHeaderContent(true, true);
	  },
	  _refresh_any_header_content: function () {
	    this.refreshHeaderContent(false, true);
	  },
	  //[DEPRECATE] - v3.0, move to private
	  refreshHeaderContent: function (trackedOnly, preserve, id) {
	    if (this._settings.header) {
	      if (preserve) this._refreshHeaderContent(this._header, trackedOnly, 1, id);

	      this._refreshHeaderContent(this._header, trackedOnly, 0, id);
	    }

	    if (this._settings.footer) {
	      if (preserve) this._refreshHeaderContent(this._footer, trackedOnly, 1, id);

	      this._refreshHeaderContent(this._footer, trackedOnly, 0, id);
	    }
	  },
	  refreshFilter: function (id) {
	    this.refreshHeaderContent(false, true, id);
	  },
	  _refreshHeaderContent: function (sec, cellTrackOnly, getOnly, byId) {
	    if (this._has_active_headers && sec) {
	      var alltd = sec.getElementsByTagName("TD");

	      for (var i = 0; i < alltd.length; i++) {
	        if (alltd[i].getAttribute("active_id")) {
	          var obj = this._active_headers[alltd[i].getAttribute("active_id")];

	          if (byId && byId != obj.columnId) continue;
	          var content = datafilter[obj.content];

	          if (getOnly) {
	            if (content.getValue) {
	              obj.value = content.getValue(alltd[i]);
	            }
	          } else if (!cellTrackOnly || content.trackCells) {
	            content.refresh(this, alltd[i], obj);
	          }
	        }
	      }
	    }
	  },
	  headerContent: [],
	  _set_size_scroll_area: function (obj, height, hdx) {
	    if (this._scrollSizeY) {
	      obj.style.height = Math.max(height, 1) - 1 + "px";
	      obj.style.width = (this._rightSplit ? 0 : hdx) + this._scrollSizeY - 1 + "px"; // temp. fix: Chrome [DIRTY]

	      if (env.isWebKit) var w = obj.offsetWidth; //eslint-disable-line
	    } else obj.style.display = "none";
	  },
	  _size_header_footer_fix: function () {
	    if (this._settings.header) this._set_size_scroll_area(this._header_scroll, this._header_height, this._header_fix_width);
	    if (this._settings.footer) this._set_size_scroll_area(this._footer_scroll, this._footer_height, this._header_fix_width);
	  },
	  _update_scroll: function () {
	    var hasX = !(this._settings.autowidth || this._settings.scrollX === false);
	    this._scrollSizeX = hasX ? env.scrollSize : 0;
	    var hasY = !(this._settings.autoheight || this._settings.scrollY === false);
	    this._scrollSizeY = hasY ? env.scrollSize : 0;
	    if (env.touch) hasX = hasY = false;

	    if (this._x_scroll) {
	      this._x_scroll._settings.scrollSize = this._scrollSizeX;
	      this._x_scroll._settings.scrollVisible = hasX;
	    }

	    if (this._y_scroll) {
	      this._y_scroll._settings.scrollSize = this._scrollSizeY;
	      this._y_scroll._settings.scrollVisible = hasY;
	    }
	  },
	  _create_scrolls: function () {
	    this._scrollTop = 0;
	    this._scrollLeft = 0;
	    var scrx, scry;
	    scrx = scry = 1;
	    if (this._settings.autoheight || this._settings.scrollY === false) scry = this._scrollSizeY = 0;
	    if (this._settings.autowidth || this._settings.scrollX === false) scrx = this._scrollSizeX = 0;
	    if (env.touch) scrx = scry = 0;

	    if (!this._x_scroll) {
	      this._x_scroll = ui({
	        view: "vscroll",
	        container: this._footer.previousSibling,
	        scrollWidth: this._dtable_width,
	        scrollSize: this._scrollSizeX,
	        scrollVisible: scrx
	      }); //fix for scroll space on Mac

	      if (scrx && !this._scrollSizeX && !env.$customScroll) this._x_scroll._viewobj.style.position = "absolute";

	      this._x_scroll.attachEvent("onScroll", bind(this._onscroll_x, this));
	    }

	    if (!this._y_scroll) {
	      this._header_scroll = this._footer.nextSibling;
	      var vscroll_view = this._header_scroll.nextSibling;
	      this._footer_scroll = vscroll_view.nextSibling;
	      this._y_scroll = ui({
	        view: "vscroll",
	        container: vscroll_view,
	        scrollHeight: 100,
	        scroll: "y",
	        scrollSize: this._scrollSizeY,
	        scrollVisible: scry
	      });

	      this._y_scroll.activeArea(this._body);

	      this._x_scroll.activeArea(this._body, true);

	      this._y_scroll.attachEvent("onScroll", bind(this._onscroll_y, this));
	    }

	    if (this._content_width) this.callEvent("onResize", [this._content_width, this._content_height]);
	    if (env.$customScroll) temp$1.enable(this);

	    this._create_scrolls = function () {};
	  },
	  columnId: function (index$$1) {
	    return this._columns[index$$1].id;
	  },
	  getColumnIndex: function (id) {
	    for (var i = 0; i < this._columns.length; i++) {
	      if (this._columns[i].id == id) return i;
	    }

	    return -1;
	  },
	  _getNodeBox: function (rid, cid) {
	    var xs = 0,
	        xe = 0,
	        ye = 0,
	        ys = 0;
	    var i;
	    var zone = 0;

	    for (i = 0; i < this._columns.length; i++) {
	      if (this._rightSplit == i || this._settings.leftSplit == i) {
	        xs = 0;
	        zone++;
	      }

	      if (this._columns[i].id == cid) break;
	      xs += this._columns[i].width;
	    }

	    xe += this._columns[i].width;

	    for (i = 0; i < this.data.order.length; i++) {
	      if (this.data.order[i] == rid) break;
	      ys += this._getHeightByIndex(i);
	    }

	    ye += this._getHeightByIndex(i);
	    return [xs, xe, ys - this._scrollTop, ye, this._body.childNodes[zone]];
	  },
	  _id_to_string: function () {
	    return this.row;
	  },
	  locate: function (node, idOnly) {
	    if (this._settings.subview && this != $$(node)) return null;
	    node = node.target || node.srcElement || node;

	    while (node && node.getAttribute) {
	      if (node === this.$view) break;

	      var cs = _getClassName(node).toString();

	      var pos$$1 = null;

	      if (cs.indexOf("webix_cell") != -1) {
	        pos$$1 = this._locate(node);
	        if (pos$$1) pos$$1.row = this.data.order[pos$$1.rind];
	      }

	      if (cs.indexOf("webix_hcell") != -1) {
	        pos$$1 = this._locate(node);
	        if (pos$$1) pos$$1.header = true;
	      }

	      if (cs.indexOf("webix_drop_area") != -1) {
	        pos$$1 = this._locate(node);
	        if (pos$$1) pos$$1.row = pos$$1.rind = "$webix-drop";
	      }

	      if (pos$$1) {
	        if (idOnly) return pos$$1.header ? null : pos$$1.row;
	        pos$$1.column = this._columns[pos$$1.cind].id;
	        pos$$1.toString = this._id_to_string;
	        return pos$$1;
	      }

	      node = node.parentNode;
	    }

	    return null;
	  },
	  _locate: function (node) {
	    var cdiv = node.parentNode;
	    if (!cdiv) return null;
	    var column = (node.getAttribute("column") || cdiv.getAttribute("column")) * 1;
	    var rind = node.getAttribute("aria-rowindex");
	    var row = node.getAttribute("row") || (rind ? rind - 1 : 0);
	    var span = (node.getAttribute("colspan") || cdiv.getAttribute("colspan")) * 1;
	    return {
	      rind: row,
	      cind: column,
	      span: span
	    };
	  },
	  _correctScrollSize: function () {
	    var center = -this._center_width;

	    for (var i = 0; i < this._columns.length; i++) {
	      center += this._columns[i].width;
	    }

	    this._scrollLeft = Math.min(this._scrollLeft, Math.max(0, center));
	  },
	  _updateColsSizeSettings: function (silent) {
	    if (!this._dtable_fully_ready) return;

	    this._correctScrollSize();

	    this._set_columns_positions();

	    this._set_split_sizes_x();

	    this._render_header_and_footer();

	    if (!silent) this._check_rendered_cols(false, false);
	  },
	  setColumnWidth: function (col, width, skip_update) {
	    return this._setColumnWidth(this.getColumnIndex(col), width, skip_update);
	  },
	  _setColumnWidth: function (col, width, skip_update, by_user) {
	    if (isNaN(width) || col < 0) return;
	    var column = this._columns[col];
	    if (column.minWidth && width < column.minWidth) width = column.minWidth;else if (width < this._settings.minColumnWidth) width = this._settings.minColumnWidth;
	    var old = column.width;

	    if (old != width) {
	      if (col >= this._settings.leftSplit && col < this._rightSplit) this._dtable_width += width - old;
	      column.width = width;
	      if (column.node) //method can be called from onStructLoad
	        column.node.style.width = width + "px";else return false;
	      if (!skip_update) this._updateColsSizeSettings();
	      this.callEvent("onColumnResize", [column.id, width, old, !!by_user]);
	      return true;
	    }

	    return false;
	  },
	  _getRowHeight: function (row) {
	    return (row.$height || this._settings.rowHeight) + (row.$subopen ? row.$subHeight : 0);
	  },
	  _getHeightByIndex: function (index$$1) {
	    var id = this.data.order[index$$1];
	    if (!id) return this._settings.rowHeight;
	    return this._getRowHeight(this.data.pull[id]);
	  },
	  _getHeightByIndexSumm: function (index1, index2) {
	    if (this._settings.fixedRowHeight) return (index2 - index1) * this._settings.rowHeight;else {
	      var summ = 0;

	      for (; index1 < index2; index1++) {
	        summ += this._getHeightByIndex(index1);
	      }

	      return summ;
	    }
	  },
	  _cellPosition: function (row, column) {
	    var top;

	    if (arguments.length == 1) {
	      column = row.column;
	      row = row.row;
	    }

	    var item = this.getItem(row);
	    var config = this.getColumnConfig(column);
	    var left = 0;
	    var parent = 0;

	    for (var index$$1 = 0; index$$1 < this._columns.length; index$$1++) {
	      if (index$$1 == this._settings.leftSplit || index$$1 == this._rightSplit) left = 0;
	      var leftcolumn = this._columns[index$$1];

	      if (leftcolumn.id == column) {
	        var split_column = index$$1 < this._settings.leftSplit ? 0 : index$$1 >= this._rightSplit ? 2 : 1;
	        parent = this._body.childNodes[split_column].firstChild;
	        break;
	      }

	      left += leftcolumn.width;
	    }

	    if (this.getIndexById(row) < this._settings.topSplit) top = this._getHeightByIndexSumm(0, this.getIndexById(row));else top = this._getHeightByIndexSumm((this._render_scroll_top || 0) - this._settings.topSplit, this.getIndexById(row)) + (this._render_scroll_shift || 0);
	    return {
	      parent: parent,
	      top: top,
	      left: left,
	      width: config.width,
	      height: item.$height || this._settings.rowHeight
	    };
	  },
	  _get_total_height: function () {
	    var pager = this._settings.pager;
	    var start = 0;
	    var max = this.data.order.length;

	    if (pager) {
	      start = pager.size * pager.page;
	      max = Math.min(max, start + pager.size);

	      if (pager.level) {
	        start = this.data.$min;
	        max = this.data.$max;
	      }
	    }

	    return this._getHeightByIndexSumm(start, max);
	  },
	  setRowHeight: function (rowId, height) {
	    if (isNaN(height)) return;
	    if (height < this._settings.minColumnHeight) height = this._settings.minColumnHeight;
	    var item = this.getItem(rowId);
	    var old_height = item.$height || this._settings.rowHeight;

	    if (old_height != height) {
	      item.$height = height;
	      this.config.fixedRowHeight = false;
	      this.render();
	      this.callEvent("onRowResize", [rowId, height, old_height]);
	    }
	  },
	  _onscroll_y: function (value) {
	    var scrollChange = this._scrollTop !== value;
	    this._scrollTop = value;

	    if (!this._settings.prerender) {
	      this._check_rendered_cols();
	    } else {
	      var conts = this._body.childNodes;

	      for (var i = 0; i < conts.length; i++) {
	        conts[i].scrollTop = value;
	      }
	    }

	    if (env.$customScroll) temp$1._update_scroll(this._body);

	    if (scrollChange) {
	      this.callEvent("onScrollY", []);
	      this.callEvent("onAfterScroll", []);
	    }
	  },
	  _setLeftScroll: function (value) {
	    this._body.childNodes[1].scrollLeft = this._scrollLeft = value;
	    if (this._settings.header) this._header.childNodes[1].scrollLeft = value;
	    if (this._settings.footer) this._footer.childNodes[1].scrollLeft = value;
	  },
	  _onscroll_x: function (value) {
	    var scrollChange = this._scrollLeft !== value;

	    this._setLeftScroll(value);

	    if (this._settings.prerender === false) this._check_rendered_cols(this._minimize_dom_changes ? false : true);
	    if (env.$customScroll) temp$1._update_scroll(this._body);

	    if (scrollChange) {
	      this.callEvent("onScrollX", []);
	      this.callEvent("onAfterScroll", []);
	    }
	  },
	  _get_x_range: function (full) {
	    if (full) return [0, this._columns.length];
	    var t = this._scrollLeft;
	    var xind = this._settings.leftSplit;

	    while (t > 0 && this._columns.length - 1 > xind) {
	      t -= this._columns[xind].width;
	      xind++;
	    }

	    var xend = xind;
	    if (t && xind > 0) xind--;
	    t += this._center_width;

	    while (t > 0 && xend < this._rightSplit) {
	      t -= this._columns[xend].width;
	      xend++;
	    }

	    return [xind, xend];
	  },
	  getVisibleCount: function () {
	    return Math.floor(this._dtable_offset_height / this.config.rowHeight);
	  },
	  //returns info about y-scroll position
	  _get_y_range: function (full) {
	    var t = this._scrollTop;
	    var start = 0;
	    var end = this.count(); //apply pager, if defined

	    var pager = this._settings.pager;

	    if (pager) {
	      start = pager.page * pager.size;
	      end = Math.min(end, start + pager.size);

	      if (pager.level) {
	        start = this.data.$min;
	        end = this.data.$max;
	      }
	    } //in case of autoheight - request full rendering


	    if (this._settings.autoheight) return [start, end, 0];
	    if (full) return [start, end, 0];
	    var xind = start;
	    var topSplit = this._settings.topSplit || 0;
	    if (topSplit) xind += topSplit;
	    var rowHeight = this._settings.fixedRowHeight ? this._settings.rowHeight : 0;

	    if (rowHeight) {
	      var dep = Math.ceil(t / rowHeight);
	      t -= dep * rowHeight;
	      xind += dep;
	    } else while (t > 0) {
	      t -= this._getHeightByIndex(xind);
	      xind++;
	    } //how much of the first cell is scrolled out


	    var xdef = xind > 0 && t ? -(this._getHeightByIndex(xind - 1) + t) : 0;
	    var xend = xind;
	    if (t) xind--;
	    t += (this._dtable_offset_height || this._content_height) - (this._top_split_height || 0);

	    if (rowHeight) {
	      var _dep = Math.ceil(t / rowHeight);

	      t -= _dep * rowHeight;
	      xend += _dep;
	    } else {
	      while (t > 0 && xend < end) {
	        t -= this._getHeightByIndex(xend);
	        xend++;
	      }
	    }

	    if (xend > end) xend = end;
	    return [xind, xend, xdef];
	  },
	  _repaint_single_row: function (id) {
	    var item = this.getItem(id);
	    var rowindex = this.getIndexById(id);

	    var state = this._get_y_range();

	    var freeze = this.config.topSplit;
	    var freezeCss = "";

	    if (rowindex >= freeze) {
	      //row not visible
	      if (rowindex < state[0] || rowindex >= state[1]) return;
	      rowindex -= state[0] - freeze;
	    } else {
	      freezeCss = rowindex == freeze - 1 ? " webix_topcell webix_last_topcell" : " webix_topcell";
	    } //get visible column


	    var x_range = this._get_x_range();

	    for (var i = 0; i < this._columns.length; i++) {
	      var column = this._columns[i]; //column not visible

	      if (i < this._rightSplit && i >= this._settings.leftSplit && (i < x_range[0] || i > x_range[1])) column._yr0 = -999; //ensure that column will not be reused

	      if (column.attached && column.node) {
	        var node = column.node.childNodes[rowindex];
	        if (!node) continue;

	        var value = this._getValue(item, this._columns[i], 0);

	        node.innerHTML = value;
	        node.className = this._getCss(this._columns[i], value, item, id) + freezeCss;
	      }
	    }
	  },
	  _check_rendered_cols: function (x_scroll, force) {
	    if (!this._columns.length) return;
	    if (force) this._clearColumnCache();

	    var xr = this._get_x_range(this._settings.prerender);

	    var yr = this._get_y_range(this._settings.prerender === true);

	    if (x_scroll) {
	      for (var i = this._settings.leftSplit; i < xr[0]; i++) {
	        this._hideColumn(i, force);
	      }

	      for (var _i6 = xr[1]; _i6 < this._rightSplit; _i6++) {
	        this._hideColumn(_i6, force);
	      }
	    }

	    this._render_full_rows = [];

	    for (var _i7 = 0; _i7 < this._settings.leftSplit; _i7++) {
	      this._renderColumn(_i7, yr, force);
	    }

	    for (var _i8 = xr[0]; _i8 < xr[1]; _i8++) {
	      this._renderColumn(_i8, yr, force, _i8 == xr[0]);
	    }

	    for (var _i9 = this._rightSplit; _i9 < this._columns.length; _i9++) {
	      this._renderColumn(_i9, yr, force);
	    }

	    this._check_and_render_full_rows(yr[0], yr[1], force);

	    this._check_load_next(yr);
	  },
	  _delete_full_rows: function (start, end) {
	    this._rows_cache_start = start;
	    this._rows_cache_end = end;
	    remove(this._rows_cache);
	    this._rows_cache = [];
	  },
	  _adjust_rows: function () {
	    if (this._settings.prerender && this._rows_body) {
	      var state = this.getScrollState();
	      this._rows_body.style.top = "-" + (state.y || 0) + "px";
	    }
	  },
	  _check_and_render_full_rows: function (start, end, force) {
	    if (this._rows_body) this._rows_body.style.top = this._render_scroll_shift + "px";

	    if (!force && start == this._rows_cache_start && end == this._rows_cache_end) {
	      if (this.config.topSplit) {
	        //don't move split rows
	        for (var i = 0; i < this._render_full_rows.length; i++) {
	          var row = this._rows_cache[i];

	          if (this._render_full_rows[i].index < this.config.topSplit) {
	            row.style.top = this._render_full_rows[i].top - this._render_scroll_shift + "px";
	          }
	        }
	      }

	      return;
	    }

	    this._delete_full_rows(start, end);

	    if (this._render_full_row_some) this._render_full_row_some = false;else return;

	    for (var _i10 = 0; _i10 < this._render_full_rows.length; _i10++) {
	      var info = this._render_full_rows[_i10];
	      var item = this.getItem(info.id);
	      var value;

	      if (typeof item.$row == "function") {
	        value = item.$row.call(this, item, this.type);
	      } else {
	        value = this._getValue(item, this.getColumnConfig(item.$row), _i10);
	      }

	      var _row = this._rows_cache[_i10] = create("DIV", null, value);

	      _row.className = "webix_cell " + (item.$sub ? "webix_dtable_sub" + (this._settings.subview ? "view" : "row") : "webix_dtable_colrow" + (item.$row ? " webix_topcell" + (this.data.getMark(item.id, "webix_selected") ? " webix_selected" : "") : ""));

	      _row.setAttribute("column", 0);

	      _row.setAttribute("row", info.index);

	      var height = item.$height || this._settings.rowHeight;
	      if (item.$subopen) _row.style.height = item.$subHeight + "px";else _row.style.height = height + "px";
	      _row.style.paddingRight = env.scrollSize + "px";
	      var topDelta = this._render_full_rows[_i10].index < this.config.topSplit ? -this._render_scroll_shift : 0;
	      _row.style.top = topDelta + info.top + (item.$subopen ? height - 1 : 0) + "px";

	      if (!this._rows_body) {
	        this._rows_body = create("DIV");
	        this._rows_body.style.position = "relative";
	        this._rows_body.style.top = this._render_scroll_shift + "px";

	        this._body.appendChild(this._rows_body);
	      }

	      this._rows_body.appendChild(_row);

	      this.attachEvent("onSyncScroll", function (x, y, t) {
	        Touch._set_matrix(this._rows_body, 0, y, t);
	      });
	      if (this._settings.subview) this.callEvent("onSubViewRender", [item, _row]);
	    }
	  },
	  _check_load_next: function (yr) {
	    var paging = this._settings.pager;
	    var fetch = this._settings.datafetch;
	    var direction = !this._last_valid_render_pos || yr[0] >= this._last_valid_render_pos;
	    this._last_valid_render_pos = yr[0];

	    if (this._data_request_flag) {
	      if (paging && (!fetch || fetch >= paging.size)) if (this._check_rows([0, paging.size * paging.page], Math.max(fetch, paging.size), true)) return this._data_request_flag = null;

	      this._run_load_next(this._data_request_flag, direction);

	      this._data_request_flag = null;
	    } else {
	      if (this._settings.loadahead) this._check_rows(yr, this._settings.loadahead, direction);
	    }
	  },
	  _check_rows: function (view, count, dir) {
	    var start = view[1];
	    var end = start + count;

	    if (!dir) {
	      start = view[0] - count;
	      end = view[0];
	    }

	    if (start < 0) start = 0;
	    end = Math.min(end, this.data.order.length - 1);
	    var result = false;

	    for (var i = start; i < end; i++) {
	      if (!this.data.order[i]) {
	        if (!result) result = {
	          start: i,
	          count: end - start
	        };else {
	          result.last = i;
	          result.count = i - start;
	        }
	      }
	    }

	    if (result) {
	      this._run_load_next(result, dir);

	      return true;
	    }
	  },
	  _run_load_next: function (conf, direction) {
	    var count = Math.max(conf.count, this._settings.datafetch || this._settings.loadahead || 0);
	    var start = direction ? conf.start : conf.last - count + 1;
	    if (this._maybe_loading_already(conf.count, conf.start)) return;
	    this.loadNext(count, start);
	  },
	  // necessary for safari only
	  _preserveScrollTarget: function (columnNode) {
	    if (env.isSafari) {
	      var i,
	          node,
	          newNode,
	          scroll,
	          dir = [this._x_scroll, this._y_scroll];

	      for (i = 0; i < 2; i++) {
	        scroll = dir[i];

	        if (scroll && scroll._scroll_trg && scroll._scroll_trg.parentNode == columnNode) {
	          node = scroll._scroll_trg;
	        }
	      }

	      if (node) {
	        if (this._scrollWheelTrg) remove(this._scrollWheelTrg);
	        this._scrollWheelTrg = node;
	        newNode = node.cloneNode(true); // required for _hideColumn

	        node.parentNode.insertBefore(newNode, node);
	        this._scrollWheelTrg.style.display = "none";

	        this._body.appendChild(this._scrollWheelTrg);
	      }
	    }
	  },
	  _hideColumn: function (index$$1) {
	    var col = this._columns[index$$1]; // preserve target node for Safari wheel event

	    this._preserveScrollTarget(col.node);

	    remove(col.node);
	    col.attached = false;
	  },
	  _clearColumnCache: function () {
	    for (var i = 0; i < this._columns.length; i++) {
	      this._columns[i]._yr0 = -1;
	    }

	    if (this._rows_cache.length) {
	      remove(this._rows_cache);
	      this._rows_cache = [];
	    }
	  },
	  getText: function (row_id, column_id) {
	    return this._getValue(this.getItem(row_id), this.getColumnConfig(column_id), 0);
	  },
	  getCss: function (row_id, column_id) {
	    var item = this.getItem(row_id);
	    return this._getCss(this.getColumnConfig(column_id), item[column_id], item, row_id);
	  },
	  _getCss: function (config, value, item, id) {
	    var css = "webix_cell";

	    if (config.cssFormat) {
	      var per_css = config.cssFormat(value, item, id, config.id);

	      if (per_css) {
	        if (_typeof(per_css) == "object") css += " " + createCss(per_css);else css += " " + per_css;
	      }
	    }

	    var row_css = item.$css;

	    if (row_css) {
	      if (_typeof(row_css) == "object") item.$css = row_css = createCss(row_css);
	      css += " " + row_css;
	    }

	    var mark = this.data._marks[id];

	    if (mark) {
	      if (mark.$css) css += " " + mark.$css;

	      if (mark.$cellCss) {
	        var mark_marker = mark.$cellCss[config.id];
	        if (mark_marker) css += " " + mark_marker;
	      }
	    }

	    if (item.$cellCss) {
	      var css_marker = item.$cellCss[config.id];

	      if (css_marker) {
	        if (_typeof(css_marker) == "object") css_marker = createCss(css_marker);
	        css += " " + css_marker;
	      }
	    } //cell-selection


	    var selected = this.data.getMark(item.id, "webix_selected");
	    if (selected && (selected.$row || selected[config.id]) || config.$selected) css += this._select_css;
	    return css;
	  },
	  _getValue: function (item, config, i) {
	    if (!item) return "";
	    var value;
	    value = item[config.id];
	    if (value === undefined || value === null) value = "";
	    if (config.format) value = config.format(value);
	    if (config.template) value = config.template(item, this.type, value, config, i);
	    return value;
	  },
	  //we don't use render-stack, but still need a place for common helpers
	  //so creating a simple "type" holder
	  type: {
	    checkbox: function (obj, common, value, config) {
	      var checked = value == config.checkValue ? "checked=\"true\"" : "";
	      return "<input class='webix_table_checkbox' type='checkbox' " + checked + ">";
	    },
	    radio: function (obj, common, value, config) {
	      var checked = value == config.checkValue ? "checked=\"true\"" : "";
	      return "<input class='webix_table_radio' type='radio' " + checked + ">";
	    },
	    editIcon: function () {
	      return "<span class='webix_icon wxi-pencil'></span>";
	    },
	    trashIcon: function () {
	      return "<span class='webix_icon wxi-trash'></span>";
	    }
	  },
	  type_setter: function (value) {
	    if (!this.types || !this.types[value]) type(this, value);else {
	      this.type = clone(this.types[value]);
	      if (this.type.css) this._contentobj.className += " " + this.type.css;
	    }
	    if (this.type.on_click) exports.extend(this.on_click, this.type.on_click);
	    return value;
	  },
	  _renderColumn: function (index$$1, yr, force, single$$1) {
	    var col = this._columns[index$$1];

	    if (!col.attached) {
	      var split_column = index$$1 < this._settings.leftSplit ? 0 : index$$1 >= this._rightSplit ? 2 : 1;

	      this._body.childNodes[split_column].firstChild.appendChild(col.node);

	      col.attached = true;
	      col.split = split_column;
	    }

	    this._render_scroll_top = yr[0];
	    this._render_scroll_shift = 0;
	    this._render_scroll_diff = yr[2]; //if columns not aligned during scroll - set correct scroll top value for each column

	    if (this._settings.scrollAlignY) {
	      if (yr[1] == this.data.order.length || this.data.$pagesize && yr[1] % this.data.$pagesize === 0) {
	        col.node.style.top = (this._render_scroll_shift = yr[2]) + "px";
	      } else if (col._yr2) col.node.style.top = "0px";
	    } else {
	      this._render_scroll_shift = yr[2];
	      col.node.style.top = yr[2] + "px";
	    }

	    if (!force && col._yr0 == yr[0] && col._yr1 == yr[1] && (!this._settings.topSplit || col._render_scroll_shift == this._render_scroll_shift)) return 0;
	    var html = "";
	    var config = this._settings.columns[index$$1];
	    var state = {
	      row: this._settings.rowHeight,
	      total: 0,
	      single: single$$1
	    };

	    for (var i = 0; i < this._settings.topSplit; i++) {
	      html += this._render_single_cell(i, config, yr, state, -this._render_scroll_shift, index$$1);
	    } // ignore not available rows in top-split area


	    this._data_request_flag = null;

	    for (var _i11 = Math.max(yr[0], this._settings.topSplit); _i11 < yr[1]; _i11++) {
	      html += this._render_single_cell(_i11, config, yr, state, -1, index$$1);
	    } // preserve target node for Safari wheel event


	    this._preserveScrollTarget(col.node);

	    col.node.innerHTML = html;
	    col._yr0 = yr[0];
	    col._yr1 = yr[1];
	    col._yr2 = yr[2];
	    col._render_scroll_shift = this._render_scroll_shift;
	    return 1;
	  },
	  _render_single_cell: function (i, config, yr, state, top, index$$1) {
	    var id = this.data.order[i];
	    var item = this.data.getItem(id);
	    var html = "";

	    if (item) {
	      var aria = " role='gridcell' aria-rowindex='" + (i + 1) + "' aria-colindex='" + (this.getColumnIndex(config.id) + 1) + "'" + (item.$count || item.$sub ? " aria-expanded='" + (item.open || item.$subopen ? "true" : "false") + "'" : "") + (item.$level ? " aria-level='" + item.$level + "'" : "");

	      if (state.single && item.$row) {
	        this._render_full_row_some = true;

	        this._render_full_rows.push({
	          top: state.total,
	          id: item.id,
	          index: i
	        });

	        if (!item.$sub) {
	          var rowHeight = item.$height || state.row;
	          state.total += rowHeight;
	          return "<div" + aria + " class='webix_cell' style='height:" + rowHeight + "px;'></div>";
	        }
	      }

	      var value = this._getValue(item, config, i);

	      var css = this._getCss(config, value, item, id);

	      var ariaSelect = " aria-selected='true' tabindex='0'";

	      if (css.indexOf("select") !== -1) {
	        //in case of row/column selection - make only first cell focusable
	        if (css.indexOf("row") !== -1) {
	          var xr = this._get_x_range();

	          if (xr[0] === index$$1) aria += ariaSelect;
	        } else if (css.indexOf("col") !== -1) {
	          if (i === yr[0]) aria += ariaSelect;
	        } else aria += ariaSelect;
	      }

	      var isOpen = !!item.$subopen;
	      var margin = isOpen ? "margin-bottom:" + item.$subHeight + "px;" : "";

	      if (top >= 0) {
	        if (top > 0) margin += "top:" + top + "px;'";
	        css = "webix_topcell " + css;
	        if (i == this._settings.topSplit - 1) css = "webix_last_topcell " + css;
	      }

	      if (item.$height) {
	        html = "<div" + aria + " class='" + css + "' style='height:" + item.$height + "px;" + margin + "'>" + value + "</div>";
	        state.total += item.$height - state.row;
	      } else {
	        html = "<div" + aria + " class='" + css + "'" + (margin ? " style='" + margin + "'" : "") + ">" + value + "</div>";
	      }

	      if (isOpen) state.total += item.$subHeight;
	    } else {
	      html = "<div role='gridcell' class='webix_cell'></div>";
	      if (!this._data_request_flag) this._data_request_flag = {
	        start: i,
	        count: yr[1] - i
	      };else this._data_request_flag.last = i;
	    }

	    state.total += state.row;
	    return html;
	  },
	  _set_split_sizes_y: function () {
	    if (!this._columns.length || isNaN(this._content_height * 1)) return;
	    debug_size_box(this, ["y-sizing"], true);
	    var wanted_height = this._dtable_height + (this._scrollSizeX ? this._scrollSizeX : 0);
	    if ((this._settings.autoheight || this._settings.yCount) && this.resize()) return;

	    this._y_scroll.sizeTo(this._content_height, this._header_height, this._footer_height);

	    this._y_scroll.define("scrollHeight", wanted_height);

	    this._top_split_height = this._settings.topSplit ? this._getHeightByIndexSumm(0, this._settings.topSplit) : 0;
	    this._dtable_offset_height = Math.max(0, this._content_height - this._scrollSizeX - this._header_height - this._footer_height);

	    for (var i = 0; i < 3; i++) {
	      this._body.childNodes[i].style.height = this._dtable_offset_height + "px";
	      if (this._settings.prerender) this._body.childNodes[i].firstChild.style.height = this._dtable_height + "px";else this._body.childNodes[i].firstChild.style.height = this._dtable_offset_height + "px";
	    } //prevent float overflow, when we have split and very small


	    this._header.style.height = this._header_height + "px";
	  },
	  _set_split_sizes_x: function () {
	    if (!this._columns.length) return;
	    var index$$1 = 0;
	    this._left_width = 0;
	    this._right_width = 0;
	    this._center_width = 0;

	    while (index$$1 < this._settings.leftSplit) {
	      this._left_width += this._columns[index$$1].width;
	      index$$1++;
	    }

	    index$$1 = this._columns.length - 1;

	    while (index$$1 >= this._rightSplit) {
	      this._right_width += this._columns[index$$1].width;
	      index$$1--;
	    }

	    if (!this._content_width) return;
	    if (this._settings.autowidth && this.resize()) return;
	    this._center_width = this._content_width - this._right_width - this._left_width - this._scrollSizeY;
	    this._body.childNodes[1].firstChild.style.width = this._dtable_width + "px";
	    this._body.childNodes[0].style.width = this._left_width + "px";
	    this._body.childNodes[1].style.width = this._center_width + "px";
	    this._body.childNodes[2].style.width = this._right_width + "px";
	    this._header.childNodes[0].style.width = this._left_width + "px";
	    this._header.childNodes[1].style.width = this._center_width + "px";
	    this._header.childNodes[2].style.width = this._right_width + "px";
	    this._footer.childNodes[0].style.width = this._left_width + "px";
	    this._footer.childNodes[1].style.width = this._center_width + "px";
	    this._footer.childNodes[2].style.width = this._right_width + "px";
	    var delta = this._center_width - this._dtable_width;
	    if (delta < 0) delta = 0; //negative header space has not sense

	    if (delta != this._header_fix_width) {
	      this._header_fix_width = delta;

	      this._size_header_footer_fix();
	    } // temp. fix: Chrome [DIRTY]


	    if (env.isWebKit) {
	      var w = this._body.childNodes[0].offsetWidth; //eslint-disable-line

	      w = this._body.childNodes[1].offsetWidth;
	      w = this._body.childNodes[1].firstChild.offsetWidth;
	      w = this._body.childNodes[2].offsetWidth;
	    }

	    this._x_scroll.sizeTo(this._content_width - this._scrollSizeY);

	    this._x_scroll.define("scrollWidth", this._dtable_width + this._left_width + this._right_width);
	  },
	  $getSize: function (dx, dy) {
	    if ((this._settings.autoheight || this._settings.yCount) && this._settings.columns) {
	      //if limit set - use it
	      var desired = (this._settings.yCount || 0) * this._settings.rowHeight; //else try to use actual rendered size
	      //if component invisible - this is not valid, so fallback to all rows

	      if (!desired) desired = this.isVisible() ? this._dtable_height : this.count() * this._settings.rowHeight; //add scroll and check minHeight limit

	      this._settings.height = Math.max(desired + (this._scrollSizeX ? this._scrollSizeX : 0) - 1, this._settings.minHeight || 0) + this._header_height + this._footer_height;
	    }

	    if (this._settings.autowidth && this._settings.columns) this._settings.width = Math.max(this._dtable_width + this._left_width + this._right_width + this._scrollSizeY, this._settings.minWidth || 0);
	    var minwidth = this._left_width + this._right_width + this._scrollSizeY;
	    var sizes = base.api.$getSize.call(this, dx, dy);
	    sizes[0] = Math.max(sizes[0] || minwidth);
	    return sizes;
	  },
	  _restore_scroll_state: function () {
	    if (this._x_scroll && !env.touch) {
	      var state = this.getScrollState();
	      this._x_scroll._last_scroll_pos = this._y_scroll._last_scroll_pos = -1;
	      this.scrollTo(state.x, state.y);
	    }
	  },
	  $setSize: function () {
	    var oldw = this._content_width;
	    var oldh = this._content_height;

	    if (base.api.$setSize.apply(this, arguments)) {
	      if (this._dtable_fully_ready) {
	        this.callEvent("onResize", [this._content_width, this._content_height, oldw, oldh]);

	        this._set_split_sizes_x();

	        this._set_split_sizes_y();
	      }

	      this.render();
	    }
	  },
	  _on_header_click: function (column) {
	    var col = this.getColumnConfig(column);
	    if (!col.sort) return;
	    var order = "asc";
	    if (col.id == this._last_sorted) order = this._last_order == "asc" ? "desc" : "asc";

	    this._sort(col.id, order, col.sort);
	  },
	  markSorting: function (column, order) {
	    if (!this._sort_sign) this._sort_sign = create("DIV");
	    var parent = this._sort_sign.parentNode;

	    if (parent) {
	      parent.removeAttribute("aria-sort");
	      parent.removeAttribute("tabindex");
	    }

	    remove(this._sort_sign);

	    if (order) {
	      var cell = this._get_header_cell(this.getColumnIndex(column));

	      if (cell) {
	        this._sort_sign.className = "webix_ss_sort_" + order;
	        cell.style.position = "relative";
	        cell.appendChild(this._sort_sign);
	        cell.setAttribute("aria-sort", order + "ending");
	        cell.setAttribute("tabindex", "0");
	      }

	      this._last_sorted = column;
	      this._last_order = order;
	    } else {
	      this._last_sorted = this._last_order = null;
	    }
	  },
	  scroll_setter: function (mode) {
	    if (typeof mode == "string") {
	      this._settings.scrollX = mode.indexOf("x") != -1;
	      this._settings.scrollY = mode.indexOf("y") != -1;
	      return mode;
	    } else return this._settings.scrollX = this._settings.scrollY = mode;
	  },
	  _get_header_cell: function (column) {
	    var cells = this._header.getElementsByTagName("TD");

	    var maybe = null;

	    for (var i = 0; i < cells.length; i++) {
	      if (cells[i].getAttribute("column") == column && !cells[i].getAttribute("active_id")) {
	        maybe = cells[i].firstChild;
	        if ((cells[i].colSpan || 0) < 2) return maybe;
	      }
	    }

	    return maybe;
	  },
	  _sort: function (col_id, direction, type$$1) {
	    var _this = this;

	    direction = direction || "asc";
	    this.markSorting(col_id, direction);

	    if (type$$1 == "server") {
	      this.callEvent("onBeforeSort", [col_id, direction, type$$1]);
	      this.loadNext(0, 0, 0, 0, 1).then(function (data) {
	        _this.clearAll(true);

	        _this.parse(data);

	        _this.callEvent("onAfterSort", [col_id, direction, type$$1]);
	      });
	    } else {
	      if (type$$1 == "text") {
	        this.data.each(function (obj) {
	          obj.$text = this.getText(obj.id, col_id);
	        }, this);
	        type$$1 = "string";
	        col_id = "$text";
	      }

	      if (typeof type$$1 == "function") this.data.sort(type$$1, direction);else this.data.sort(col_id, direction, type$$1 || "string");
	    }
	  },
	  _mouseEventCall: function (css_call, e, id, trg) {
	    var functor, i, res;

	    if (css_call.length) {
	      for (i = 0; i < css_call.length; i++) {
	        functor = toFunctor(css_call[i], this.$scope);
	        res = functor.call(this, e, id, trg);
	        if (res === false) return false;
	      }
	    }
	  },
	  //because we using non-standard rendering model, custom logic for mouse detection need to be used
	  _mouseEvent: function (e, hash, name, pair) {
	    e = e || event;
	    var trg = e.target || e.srcElement;
	    if (this._settings.subview && this != $$(trg)) return; //define some vars, which will be used below

	    var css = "",
	        css_call = [],
	        found = false,
	        id = null,
	        res; //loop through all parents

	    while (trg && trg.parentNode && trg != this._viewobj.parentNode) {
	      var trgCss = _getClassName(trg);

	      if (css = trgCss) {
	        css = css.toString().split(" ");

	        for (var i = css.length - 1; i >= 0; i--) {
	          if (hash[css[i]]) css_call.push(hash[css[i]]);
	        }
	      }

	      if (trg.parentNode.getAttribute && !id) {
	        var column = trg.parentNode.getAttribute("column") || trg.getAttribute("column");

	        if (column) {
	          //we need to ignore TD - which is header|footer
	          var isBody = trg.parentNode.tagName == "DIV"; //column already hidden or removed

	          if (!this._columns[column]) return;
	          found = true;

	          if (isBody) {
	            var index$$1 = trg.parentNode.getAttribute("row") || trg.getAttribute("row");

	            if (!index$$1) {
	              //click event occurs on column holder, we can't detect cell
	              if (trg.getAttribute("column")) return;
	              index$$1 = index(trg);
	              if (index$$1 >= this._settings.topSplit && !this._settings.prerender) index$$1 += this._columns[column]._yr0 - this._settings.topSplit;
	            }

	            this._item_clicked = id = {
	              row: this.data.order[index$$1],
	              column: this._columns[column].id
	            };
	            id.toString = this._id_to_string;
	          } else this._item_clicked = id = {
	            column: this._columns[column].id
	          }; //some custom css handlers was found


	          res = this._mouseEventCall(css_call, e, id, trg);
	          if (res === false) return; //call inner handler

	          if (isBody) {
	            if (this.callEvent("on" + name, [id, e, trg]) && pair) {
	              this.callEvent("on" + pair, [id, e, trg]);
	            }
	          } else if (name == "ItemClick") {
	            var isHeader = trg.parentNode.parentNode.getAttribute("section") == "header";
	            if (isHeader && this.callEvent("onHeaderClick", [id, e, trg])) this._on_header_click(id.column);
	          }

	          css_call = [];
	        }
	      }

	      trg = trg.parentNode;
	    }

	    this._mouseEventCall(css_call, e, id, this.$view);

	    return found; //returns true if item was located and event was triggered
	  },
	  _get_tooltip_data: function (t, e) {
	    var id = this.locate(e);
	    if (!id) return null;
	    var tooltip = TooltipControl._tooltip;
	    var data;

	    if (id.header) {
	      var node = e.target || e.srcElement;
	      var pos$$1;
	      var cind = id.cind - (id.span ? id.span - 1 : 0);
	      var rind = -1;

	      while (node && !pos$$1) {
	        node = node.parentNode;
	        pos$$1 = node.getAttribute("section");
	      }

	      while ((node = node.previousSibling) !== null) {
	        rind++;
	      }

	      var config = this._columns[cind][pos$$1][rind];
	      if (config.tooltip) tooltip.type.template = template(config.tooltip === true ? "#text#" : config.tooltip);else return null;
	      data = config;
	    } else {
	      var _config = tooltip.type.column = this.getColumnConfig(id.column);

	      var def = !_config.tooltip || _config.tooltip === true; //empty tooltip - ignoring

	      if (!_config.tooltip && _config.tooltip !== undefined) return null;

	      if (def && !this._settings.tooltip.template) {
	        data = this.getText(id.row, id.column).toString();
	      } else if (!def) {
	        var area = (e.target || e.srcElement).getAttribute("webix_area");

	        if (area) {
	          tooltip.type.template = function (obj, common) {
	            var values = obj[_config.id];
	            return template(_config.tooltip).call(this, obj, common, values[area], area);
	          };
	        } else tooltip.type.template = template(_config.tooltip);
	      } else tooltip.type.template = template(this._settings.tooltip.template);
	    }

	    return data || this.getItem(id.row);
	  },
	  showOverlay: function (message) {
	    if (!this._datatable_overlay) {
	      var t = create("DIV", {
	        "class": "webix_overlay"
	      }, "");

	      this._body.appendChild(t);

	      this._datatable_overlay = t;
	    }

	    this._datatable_overlay.innerHTML = message;
	  },
	  hideOverlay: function () {
	    if (this._datatable_overlay) {
	      remove(this._datatable_overlay);
	      this._datatable_overlay = null;
	    }
	  },
	  mapCells: function (startrow, startcol, numrows, numcols, callback, getOnly) {
	    if (startrow === null && this.data.order.length > 0) startrow = this.data.order[0];
	    if (startcol === null) startcol = this.columnId(0);
	    if (numrows === null) numrows = this.data.order.length;
	    if (numcols === null) numcols = this._settings.columns.length;
	    if (!this.exists(startrow)) return;
	    startrow = this.getIndexById(startrow);
	    startcol = this.getColumnIndex(startcol);
	    if (startcol === null) return;

	    for (var i = 0; i < numrows && startrow + i < this.data.order.length; i++) {
	      var row_ind = startrow + i;
	      var row_id = this.data.order[row_ind];

	      if (row_id) {
	        //dyn loading
	        var item = this.getItem(row_id);

	        for (var j = 0; j < numcols && startcol + j < this._settings.columns.length; j++) {
	          var col_ind = startcol + j;
	          var col_id = this.columnId(col_ind);
	          var result = callback(item[col_id], row_id, col_id, i, j);
	          if (!getOnly) item[col_id] = result;
	        }
	      }
	    }
	  },
	  _call_onparse: function (driver, data) {
	    if (!this._settings.columns && driver.getConfig) this.define("columns", driver.getConfig(data));
	  },
	  _autoDetectConfig: function () {
	    var test = this.getItem(this.getFirstId());
	    var res = this._settings.columns = [];

	    for (var key in test) {
	      if (key != "id" && key[0] != "$") res.push({
	        id: key,
	        header: key[0].toUpperCase() + key.substr(1),
	        sort: "string",
	        editor: "text"
	      });
	    }

	    if (res.length) res[0].fillspace = true;
	    if (typeof this._settings.select == "undefined") this.define("select", "row");
	  }
	}; // #include ui/datatable/datatable_filter.js
	// #include ui/datatable/datatable_selection.js
	// #include ui/datatable/datatable_blockselect.js
	// #include ui/datatable/datatable_resize.js
	// #include ui/datatable/datatable_paging.js
	// #include ui/datatable/datatable_clipboard.js
	// #include ui/datatable/datatable_state.js
	// #include ui/datatable/datatable_touch.js
	// #include ui/datatable/datatable_size.js
	// #include ui/datatable/datatable_math.js
	// #include ui/datatable/datatable_edit.js
	// #include ui/datatable/datatable_columns.js
	// #include ui/datatable/datatable_keynav.js
	// #include ui/datatable/datatable_dnd.js
	// #include ui/datatable/datatable_validation.js
	// #include ui/datatable/datatable_sparklines.js
	// #include ui/datatable/datatable_print.js
	// #include ui/datatable/datatable_export.js

	var view$1d = exports.protoUI(api$1d, temp$3, DataState, TablePaste, DataMove, EditAbility, KeysNavigation, PagingAbility, CustomPrint, Mixin$c, ValidateCollection, Mixin$b, Mixin$d, DragItem, Mixin$a, Mixin$9, Mixin$8, Mixin$7, Mixin$6, temp$4, Mixin$5, Mixin$4, Mixin$3, temp$5, Mixin$2, Mixin$1, Mixin, temp$6, temp$7, AutoTooltip, Group, DataMarks, DataLoader, MouseEvents, MapCollection, base.view, EventSystem, Settings);
	var datatable = {
	  api: api$1d,
	  view: view$1d
	};

	var api$1e = {
	  name: "treetable",
	  $init: function () {
	    exports.extend(this.data, TreeStore, true);
	    exports.extend(this.type, TreeType);
	    exports.extend(this, TreeDataMove, true);

	    for (var key in TreeClick) {
	      if (!this.on_click[key]) this.on_click[key] = this._unwrap_id(TreeClick[key]);
	    }

	    this.type.treetable = template("{common.space()}{common.icon()} {common.folder()}");

	    this.type.treecheckbox = function (obj) {
	      if (obj.indeterminate && !obj.nocheckbox) return "<div class='webix_tree_checkbox webix_indeterminate'></div>";else return TreeType.checkbox.apply(this, arguments);
	    };

	    this.data.provideApi(this, true);

	    this._viewobj.setAttribute("role", "treegrid");
	  },
	  _drag_order_complex: false,
	  _unwrap_id: function (original) {
	    return function (e, id) {
	      id = id.row;
	      return original.call(this, e, id);
	    };
	  },
	  _close_branches: function (context) {
	    var source = !this._settings.prerender ? [context.start] : context.source;

	    for (var i = 0; i < source.length; i++) {
	      this.close(source[i]);
	    }
	  },
	  getState: function () {
	    var state = DataState.getState.call(this);
	    exports.extend(state, TreeAPI.getState.call(this));
	    return state;
	  },
	  setState: function (state) {
	    if (TreeAPI.setState.call(this, state)) {
	      //run grid-state only when tree component was fully loaded 
	      DataState.setState.call(this, state);
	    }
	  },
	  clipboard_setter: function (value) {
	    exports.extend(this._paste, TreeTablePaste);
	    return TablePaste.clipboard_setter.call(this, value);
	  },
	  _run_load_next: function (conf, direction) {
	    for (var i = 0; i < conf.start; i++) {
	      var id = this.data.order[i];
	      if (id && this.getItem(id).$level != 1) conf.start--;
	    }

	    return datatable.api._run_load_next.call(this, conf, direction);
	  }
	};
	var view$1e = exports.protoUI(api$1e, TreeAPI, TreeStateCheckbox, TreeDataLoader, datatable.view);

	/* eslint no-constant-condition: 0 */

	/* eslint no-inner-declarations: 0 */

	{
	  var get_inspector_config = function (view) {
	    var values = {};
	    var options = [];
	    view = $$(view);

	    for (var key in view.config) {
	      if (ignore[key]) continue;
	      if (_typeof(view.config[key]) == "object") continue;
	      if (typeof view.config[key] == "undefined") continue;
	      if (typeof view.config[key] == "function") continue;
	      if (key == "view" || key == "id") options.push({
	        label: key,
	        id: key
	      });else options.push({
	        label: key,
	        type: "text",
	        id: key
	      });
	      if (view.defaults[key] == view.config[key]) options[options.length - 1].css = {
	        "color": "#888"
	      };
	      values[key] = view.config[key];
	    }

	    options.sort(function (a, b) {
	      if (!a.css && b.css) return -1;
	      if (a.css && !b.css) return 1;
	      return a.id > b.id ? 1 : a.id == b.id ? 0 : -1;
	    });
	    return {
	      elements: options,
	      data: values,
	      head: " [" + view.name + "] <strong>" + view._settings.id + "</strong>"
	    };
	  };

	  var create_inspector = function () {
	    if (!$$("webix_debug_inspector_win")) ui({
	      id: "webix_debug_inspector_win",
	      view: "window",
	      top: 2,
	      left: 0,
	      width: 350,
	      height: 350,
	      head: false,
	      autofit: false,
	      body: {
	        cols: [{
	          width: 10
	        }, {
	          type: "clean",
	          rows: [{
	            view: "toolbar",
	            elements: [{
	              view: "label",
	              value: "",
	              id: "webix_debug_inspector_head"
	            }, {
	              view: "button",
	              width: 100,
	              value: "Hide",
	              type: "custom",
	              click: function () {
	                show_inspector();
	              }
	            }]
	          }, {
	            id: "webix_debug_inspector",
	            nameWidth: 150,
	            view: "property",
	            scroll: "y",
	            elements: [],
	            on: {
	              onaftereditstop: function (state, editor) {
	                if (state.old == state.value) return;
	                var value = state.value;

	                if (value === "true" || value === "false") {
	                  value = value === "true";
	                } else {
	                  var intvalue = parseInt(value, 10);
	                  if (intvalue == value) value = intvalue;
	                }

	                var view = $$(this.config.view);
	                view.define(editor.id, value);
	                if (view.refreshColumns) view.refreshColumns();else if (view.refresh) view.refresh();
	                view.resize();
	              }
	            }
	          }]
	        }]
	      }
	    });
	  };

	  var show_inspector = function (view, ev) {
	    create_inspector();
	    var win = $$("webix_debug_inspector_win");

	    if (view) {
	      var config = get_inspector_config(view);
	      var winx = document.body.offsetWidth;
	      var winy = document.body.offsetHeight;
	      var pos$$1 = ev ? pos(ev) : {
	        x: 0,
	        y: 0
	      };
	      win.define("height", Math.max(350, winy - 4));
	      win.resize();
	      var props = $$("webix_debug_inspector");
	      props.define("elements", config.elements);
	      props.define("view", view);
	      win.show({
	        x: pos$$1.x > winx / 2 ? 0 : winx - 370,
	        y: 0
	      });
	      $$("webix_debug_inspector").setValues(config.data);
	      $$("webix_debug_inspector_head").setValue(config.head);
	    } else win.hide();
	  };

	  var infi = function (value) {
	    if (value >= 100000) return "Any";
	    return value;
	  };

	  var log_level = function (data, prefix, now) {
	    window.console.log((data == now ? ">>" : "  ") + prefix + data.name + " / " + data.config.id);
	    prefix += "  ";
	    if (data._cells) for (var i = 0; i < data._cells.length; i++) {
	      log_level(data._cells[i], prefix, now);
	    }
	    if (data._head_cell) log_level(data._head_cell, prefix, now);
	    if (data._body_cell) log_level(data._body_cell, prefix, now);
	  };

	  attachEvent("onLoadError", function (xhttp, owner) {
	    var text; //xhttp can be of blob or arraybuffer type, or just empty in case of no data

	    try {
	      text = xhttp.responseText;
	    } catch (e) {
	      text = "";
	    }

	    text = text || "[EMPTY DATA]";
	    var error_text = "Data loading error, check console for details";
	    if (text.indexOf("<?php") === 0) error_text = "PHP support missed";else if (text.indexOf("WEBIX_ERROR:") === 0) error_text = text.replace("WEBIX_ERROR:", "");
	    message({
	      type: "debug",
	      text: error_text,
	      expire: -1
	    });

	    if (window.console) {
	      var logger = window.console;
	      logger.log("Data loading error");
	      logger.log("Object:", owner);
	      logger.log("Response:", text);
	      if (xhttp) logger.log("XHTTP:", xhttp);
	    }
	  });
	  ready(function () {
	    var path = document.location.href;

	    if (path.indexOf("file:") === 0) {
	      message({
	        type: "error",
	        text: "Please open sample by http,<br>not as file://",
	        expire: -1
	      });
	    }
	  });
	  var ignore = {
	    "_inner": true,
	    "awidth": true,
	    "cheight": true,
	    "bheight": true,
	    "aheight": true
	  };
	  var uiConfig = {
	    view: "contextmenu",
	    id: "webix:debugmenu",
	    on: {
	      onBeforeShow: function (e) {
	        if (!e.ctrlKey) return false;
	        var view = locate(e, "view_id");
	        if (!view) return false;
	        this.config.lastTarget = view;
	        blockEvent();
	        delay(function () {
	          unblockEvent();
	        });
	      },
	      onShow: function () {
	        var view = $$(this.config.lastTarget);
	        var info = "<span style='color:#888'>" + view._settings.id + "<sup style='float:right'>[" + view.name + "]</sup></span>";
	        document.getElementById("webix_debug_cmx").innerHTML = info;
	      }
	    },
	    data: ["<div id='webix_debug_cmx'></div>", {
	      id: "inspect",
	      value: "Inspect"
	    }, {
	      id: "docs",
	      value: "Documentation"
	    }, {
	      value: "Log to Console",
	      submenu: [{
	        id: "size",
	        value: "Sizes"
	      }, {
	        id: "tree",
	        value: "Tree"
	      }, {
	        id: "dump",
	        value: "Dump"
	      }]
	    }],
	    click: function (id, ev) {
	      //mixing two object result in confusion
	      var obj = $$(this.config.lastTarget);

	      if (id == "dump") {
	        window.console.info("\n" + obj.name + " / " + obj.config.id);
	        window.console.log("\nView: ", obj, ", Config: ", obj.config, ", Data: ", obj.data);
	        window.console.log(obj.$view);
	      }

	      if (id == "tree") {
	        var now = obj;

	        while (obj.getParentView()) {
	          obj = obj.getParentView();
	        }

	        window.console.log("");
	        log_level(obj, "", now);
	      }

	      if (id == "size") {
	        window.console.info("");
	        window.console.info("\n" + obj.name + " / " + obj.config.id);
	        window.console.info("\n[min]   ", obj.config.width, " x ", obj.config.height);
	        var sizes = obj.$getSize(0, 0);
	        window.console.info("[max]    ", infi(sizes[1]), " x ", infi(sizes[3]) + (obj.config.autoheight ? ", auto height" : ""));
	        window.console.info("[gravity]   ", obj.config.gravity);
	        window.console.info("\n[content]    ", obj._content_width, " x ", obj._content_height);
	        window.console.info("[last set]   ", obj._last_size[0], " x ", obj._last_size[1]);
	        if (obj._settings._inner) window.console.info("\n[borders]   ", "left:", !obj._settings._inner.left, "\ttop:", !obj._settings._inner.top, "\tright:", !obj._settings._inner.right, "\tbottom:", !obj._settings._inner.bottom);else window.console.info("\n[borders]   none");
	      }

	      if (id == "docs") window.open("http://docs.webix.com/api__refs__ui." + obj.name + ".html", "__blank");

	      if (id == "inspect") {
	        show_inspector(this.config.lastTarget, ev);
	      }
	    }
	  };
	  ready(function () {
	    uiConfig.master = document.body;
	    ui(uiConfig);
	  });
	}

	var DataRecord = exports.proto({
	  name: "DataRecord",
	  isVisible: function () {
	    return true;
	  },
	  $init: function (config) {
	    this.data = config || {};
	    var id = config && config.id ? config.id : uid();
	    this._settings = {
	      id: id
	    };
	    ui.views[id] = this;
	  },
	  getValues: function () {
	    return this.data;
	  },
	  setValues: function (data, update) {
	    this.data = update ? exports.extend(this.data, data, true) : data;
	    this.callEvent("onChange", [data]);
	  },
	  refresh: function () {
	    this.callEvent("onBindRequest");
	  }
	}, EventSystem, BaseBind, AtomDataLoader, Settings);

	var DataValue = exports.proto({
	  name: "DataValue",
	  isVisible: function () {
	    return true;
	  },
	  $init: function (config) {
	    if (!config || isUndefined(config.value)) this.data = config || "";
	    var id = config && config.id ? config.id : uid();
	    this._settings = {
	      id: id
	    };
	    ui.views[id] = this;
	  },
	  setValue: function (value) {
	    this.data = value;
	    this.callEvent("onChange", [value]);
	  },
	  getValue: function () {
	    return this.data;
	  },
	  refresh: function () {
	    this.callEvent("onBindRequest");
	  }
	}, EventSystem, BaseBind);

	var TreeCollection = exports.proto({
	  name: "TreeCollection",
	  $init: function () {
	    exports.extend(this.data, TreeStore, true);
	    this.data.provideApi(this, true);
	    exports.extend(this, TreeDataMove, true);
	  }
	}, TreeDataLoader, DataCollection);

	//----------------

	exports.Date = wDate;
	exports.Number = Number$1;
	exports.promise = Deferred;
	exports.DataCollection = DataCollection;
	exports.DataRecord = DataRecord;
	exports.DataValue = DataValue;
	exports.TreeCollection = TreeCollection;
	exports.ActiveContent = ActiveContent;
	exports.AtomDataLoader = AtomDataLoader;
	exports.AtomRender = AtomRender;
	exports.AutoScroll = AutoScroll;
	exports.AutoTooltip = AutoTooltip;
	exports.BaseBind = BaseBind;
	exports.BindSource = BindSource;
	exports.Canvas = Canvas;
	exports.CodeParser = CodeParser;
	exports.CollectionBind = CollectionBind;
	exports.ContextHelper = ContextHelper;
	exports.CopyPaste = CopyPaste;
	exports.CustomPrint = CustomPrint;
	exports.CustomScroll = temp$1;
	exports.DataMarks = DataMarks;
	exports.DataMove = DataMove;
	exports.DataLoader = DataLoader;
	exports.DataState = DataState;
	exports.DataStore = DataStore;
	exports.Destruction = Destruction;
	exports.DragControl = DragControl;
	exports.DragItem = DragItem;
	exports.DragOrder = DragOrder;
	exports.EditAbility = EditAbility;
	exports.EventSystem = EventSystem;
	exports.FlexLayout = FlexLayout;
	exports.Group = Group;
	exports.GroupMethods = GroupMethods;
	exports.GroupStore = GroupStore;
	exports.HTMLOptions = HTMLOptions;
	exports.HtmlMap = HtmlMap;
	exports.IdSpace = IdSpace;
	exports.KeysNavigation = KeysNavigation;
	exports.MapCollection = MapCollection;
	exports.Modality = Modality;
	exports.MouseEvents = MouseEvents;
	exports.Movable = Movable;
	exports.NavigationButtons = NavigationButtons;
	exports.OverlayBox = OverlayBox;
	exports.PagingAbility = PagingAbility;
	exports.ProgressBar = ProgressBar;
	exports.RecordBind = RecordBind;
	exports.RenderStack = RenderStack;
	exports.ResizeArea = ResizeArea;
	exports.SingleRender = SingleRender;
	exports.Scrollable = Scrollable;
	exports.SelectionModel = SelectionModel;
	exports.Settings = Settings;
	exports.Sparklines = Sparklines;
	exports.TablePaste = TablePaste;
	exports.TooltipControl = TooltipControl;
	exports.Touch = Touch;
	exports.TreeAPI = TreeAPI;
	exports.TreeClick = TreeClick;
	exports.TreeDataLoader = TreeDataLoader;
	exports.TreeDataMove = TreeDataMove;
	exports.TreeRenderStack = TreeRenderStack;
	exports.TreeStateCheckbox = TreeStateCheckbox;
	exports.TreeStore = TreeStore;
	exports.TreeTablePaste = TreeTablePaste;
	exports.TreeType = TreeType;
	exports.UIManager = UIManager;
	exports.Undo = Undo;
	exports.UploadDriver = UploadDriver;
	exports.ValidateCollection = ValidateCollection;
	exports.ValidateData = ValidateData;
	exports.ValueBind = ValueBind;
	exports.Values = Values;
	exports.VirtualRenderStack = VirtualRenderStack;
	exports.VRenderStack = VRenderStack;
	exports.html = html$1;
	exports.skin = skin$5;
	exports.debug = debug;
	exports.i18n = i18n;
	exports.ready = ready;
	exports.env = env;
	exports.color = color;
	exports.csv = csv$1;
	exports.clipbuffer = clipbuffer;
	exports.history = history;
	exports.storage = storage;
	exports.template = template;
	exports.type = type;
	exports.markup = markup;
	exports.editors = editors;
	exports.animate = animate;
	exports.print = print;
	exports.rules = rules;
	exports.patterns = patterns;
	exports.version = version$1;
	exports.name = name$1;
	exports.level_in = level_in;
	exports.level_out = level_out;
	exports.clone = clone;
	exports.copy = copy;
	exports.single = single;
	exports.bind = bind;
	exports.exec = exec;
	exports.wrap = wrap;
	exports.isUndefined = isUndefined;
	exports.delay = delay;
	exports.once = once;
	exports.uid = uid;
	exports.toNode = toNode;
	exports.toArray = toArray;
	exports.toFunctor = toFunctor;
	exports.isArray = isArray;
	exports.isDate = isDate;
	exports.PowerArray = PowerArray;
	exports._events_final_destructor = _events_final_destructor;
	exports._event = _event;
	exports.event = event$1;
	exports.eventRemove = eventRemove;
	exports.callEvent = callEvent;
	exports.attachEvent = attachEvent;
	exports.detachEvent = detachEvent;
	exports.blockEvent = blockEvent;
	exports.unblockEvent = unblockEvent;
	exports.mapEvent = mapEvent;
	exports.hasEvent = hasEvent;
	exports.stringify = stringify;
	exports.toPNG = toPNG;
	exports.toCSV = toCSV;
	exports.toPDF = toPDF;
	exports.toExcel = toExcel;
	exports.alert = alert;
	exports.confirm = confirm;
	exports.modalbox = modalbox;
	exports.message = message;
	exports.editStop = editStop;
	exports.ajax = ajax;
	exports.jsonp = jsonp;
	exports.DataDriver = DataDriver;
	exports.dp = dp;
	exports.DataProcessor = DataProcessor;
	exports.remote = remote;
	exports.require = require;
	exports.proxy = proxy$a;
	exports.send = send;
	exports.ui = ui;
	exports.$$ = $$;

	Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2pzL2luZGV4LnRzIiwid2VicGFjazovLy9DOi9Vc2Vycy9yZXNvdy9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy93ZWJpeC93ZWJpeC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFjO0FBRWQsSUFBSSxNQUFNLEdBQUc7SUFDVCxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ0wsU0FBUyxFQUFFLFlBQVk7UUFDdkIsSUFBSSxFQUFFLE1BQU07UUFDWixFQUFFLEVBQUUsWUFBWTtRQUNoQixLQUFLLEVBQUUsR0FBRztRQUNWLFFBQVEsRUFBRTtZQUNOLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFB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RUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Rzs7QUFFNUc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCLG9EQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsOERBQThEOzs7QUFHOUQ7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwR0FBMEc7O0FBRTFHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLG1FQUFtRTs7QUFFbkUsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNDQUFzQzs7QUFFdEMsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLHlDQUF5Qyx5Q0FBeUMscUNBQXFDLDBDQUEwQztBQUNqSztBQUNBO0FBQ0EsOERBQThEO0FBQzlELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRCx1RkFBdUY7O0FBRXZGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRCxzQ0FBc0M7OztBQUd0Qyx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQSxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQiw2QkFBNkI7O0FBRTdCLDZCQUE2Qjs7QUFFN0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhDQUE4QztBQUMxRjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQSxtRkFBbUY7OztBQUduRjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMERBQTBELHVEQUF1RDtBQUNqSCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsRUFBRTs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBLG1EQUFtRCx3QkFBd0IsRUFBRTtBQUM3RSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsOENBQThDOzs7QUFHOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGOztBQUU5RjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEOzs7QUFHckQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsdUhBQXVIO0FBQ3ZILElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7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QUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx1R0FBdUc7O0FBRXZHLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNOztBQUVOO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3REFBd0Q7QUFDeEQsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBLE1BQU07QUFDTjtBQUNBLDhDQUE4QztBQUM5QztBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUU7O0FBRVI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxFQUFFOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFD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LE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxFQUFFOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEVBQUU7O0FBRVI7QUFDQTs7QUFFQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFD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QUFDTiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvRkFBb0Y7O0FBRTFGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7O0FBRW5CLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUzs7QUFFZjtBQUNBO0FBQ0EsTUFBTSxTQUFTOztBQUVmO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sRUFBRTs7QUFFUjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtFQUFrRTs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBb0I7OztBQUcxQjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7OztBQUduRDtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELG1DQUFtQztBQUNwRjs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMENBQTBDLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEY7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvRUFBb0U7QUFDcEU7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxxRUFBcUU7QUFDNUk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQSxVQUFVOzs7QUFHVjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQSxZQUFZOztBQUVaOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0VBQW9FOzs7QUFHcEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkVBQTJFOztBQUV4SDtBQUNBLG1EQUFtRDs7QUFFbkQsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBLG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxRQUFRO0FBQ2QsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDLDRDQUE0Qzs7QUFFNUM7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUTs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTs7QUFFTix1R0FBdUc7O0FBRXZHO0FBQ0E7QUFDQSxNQUFN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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7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RUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkU7OztBQUczRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFOztBQUVSOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTs7QUFFQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0pBQW9KO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElB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Q0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtB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Q0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsNkhBQTZIO0FBQzdIOztBQUVBLDBIQUEwSCxxQ0FBcUMsaUJBQWlCLEVBQUUsd0JBQXdCO0FBQzFNO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMEVBQTBFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxxQkFBcUI7OztBQUczQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7O0FBRXpFOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCLDZHQUE2Rzs7O0FBRzdHO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsaUNBQWlDLDBCQUEwQixFQUFFLHdCQUF3Qjs7QUFFOUk7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4R0FBOEc7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNkZBQTZGOztBQUU3Rjs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjs7O0FBRzNCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGlIQUFpSDs7QUFFbEs7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1HQUFtRzs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGOztBQUU3Rjs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixvQ0FBb0M7O0FBRXBDLCtGQUErRjs7QUFFL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUU7O0FBRVI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7QUFFcEQsOEVBQThFOzs7QUFHOUU7QUFDQTtBQUNBLFFBQVEsaUJBQWlCOztBQUV6QjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRUFBMkU7OztBQUczRTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsaURBQWlEO0FBQ2hHO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7QUFDakgsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNEVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQSw0R0FBNEc7O0FBRTVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJCQUEyQjtBQUMzQixJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFOztBQUUxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBOztBQUVBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQyxrQ0FBa0M7O0FBRWxDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDOzs7QUFHMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTs7QUFFQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDOztBQUVBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLGtCQUFrQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxrQkFBa0I7QUFDdEQsc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU9BQXVPO0FBQ3ZPOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsY0FBYzs7QUFFN0QsQ0FBQyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9wdWJsaWMvanMvaW5kZXgudHNcIik7XG4iLCJpbXBvcnQgXCJ3ZWJpeFwiXHJcblxyXG5sZXQgcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB3ZWJpeC51aSh7XHJcbiAgICAgICAgY29udGFpbmVyOiBcImZvcm0tcGxhY2VcIixcclxuICAgICAgICB2aWV3OiBcImZvcm1cIixcclxuICAgICAgICBpZDogXCJsb2dpbl9mb3JtXCIsXHJcbiAgICAgICAgd2lkdGg6IDYwMCxcclxuICAgICAgICBlbGVtZW50czogW1xyXG4gICAgICAgICAgICB7dmlldzogXCJ0ZXh0XCIsIG5hbWU6IFwibG9naW5cIiwgbGFiZWw6IFwiTG9naW5cIn0sXHJcbiAgICAgICAgICAgIHt2aWV3OiBcInRleHRcIiwgbmFtZTogXCJwYXNzd29yZFwiLCB0eXBlOiBcInBhc3N3b3JkXCIsIGxhYmVsOiBcIlBhc3N3b3JkXCJ9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2xzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJMb2dpblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZvcm1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb246e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9uSXRlbUNsaWNrXCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoJCQoXCJsb2dpbl9mb3JtXCIpLmdldFZhbHVlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYml4LmFqYXgoKS5wb3N0KFwiL2F1dGhcIiwgZGF0YSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYml4Lm1lc3NhZ2UoXCJzdWNjZXNzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge3ZpZXc6IFwiYnV0dG9uXCIsIHZhbHVlOiBcIkNhbmNlbFwifVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJpdCdzIGFsbCBnb29kXCIpXHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgcmVuZGVyKTsiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiB3ZWJpeCBVSSB2LjYuMi4wXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGFsbG93ZWQgdG8gdXNlIHVuZGVyIEdQTCBvciB5b3UgbmVlZCB0byBvYnRhaW4gQ29tbWVyY2lhbCBMaWNlbnNlXG4gKiB0byB1c2UgaXQgaW4gbm9uLUdQTCBwcm9qZWN0LiBQbGVhc2UgY29udGFjdCBzYWxlc0B3ZWJpeC5jb20gZm9yIGRldGFpbHNcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwud2ViaXggPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgc3RhdGUgPSB7XG5cdCAgY29kZWJhc2U6IFwiLi9cIixcblx0ICBjZG46IFwiLy9jZG4ud2ViaXguY29tXCIsXG5cdCAgdG9wX3ZpZXdzOiBbXSxcblx0ICBfZ2xvYmFsX3Njb3BlOiBudWxsLFxuXHQgIF9nbG9iYWxfY29sbGVjdGlvbjogbnVsbCxcblx0ICBfY2hpbGRfc2l6aW5nX2FjdGl2ZTogbnVsbCxcblx0ICBfcmVzcG9uc2l2ZV9leGNlcHRpb246IG51bGwsXG5cdCAgX3Jlc3BvbnNpdmVfdGlua2VyeTogbnVsbCxcblx0ICBfZnJlZXplX3Jlc2l6ZTogbnVsbCxcblx0ICBfcGFyZW50X2NlbGw6IG51bGwsXG5cdCAgX2ZvY3VzX3RpbWU6IG51bGwsXG5cdCAgX3VpX2NyZWF0aW9uOiAwLFxuXHQgIF9lZGl0X29wZW5fdGltZTogbnVsbCxcblx0ICBfZmluYWxfZGVzdHJ1Y3Rpb246IG51bGwsXG5cdCAgX2V2ZW50czogW10sXG5cdCAgZGVzdHJ1Y3RvcnM6IFtdLFxuXHQgIHNlY3VyaXR5S2V5OiBcIlwiLFxuXHQgIF9ub3NlbGVjdF9lbGVtZW50OiBudWxsLFxuXHQgIF9tb2RhbGl0eTogMCxcblx0ICBfd2FpdF9hbmltYXRlOiBudWxsLFxuXHQgIG5vYW5pbWF0ZTogZmFsc2Vcblx0fTtcblxuXHR2YXIgZW52ID0ge307XG5cdGVudi5jZG4gPSBcIi8vY2RuLndlYml4LmNvbS9cIjtcblx0ZW52LmNvZGViYXNlID0gXCJcIjtcblx0ZW52LnpJbmRleEJhc2UgPSAxMDA7XG5cdGVudi5zY3JvbGxTaXplID0gMTc7XG5cdGVudi5zdHJpY3QgPSAhIXdpbmRvdy53ZWJpeF9zdHJpY3Q7XG5cdGVudi5odHRwcyA9IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuXHR2YXIgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHRlbnYuaXNNYWMgPSBhZ2VudC5pbmRleE9mKFwiTWFjXCIpICE9IC0xO1xuXHRpZiAoYWdlbnQuaW5kZXhPZihcIk1vYmlsZVwiKSAhPSAtMSB8fCBhZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSAhPSAtMSkgZW52Lm1vYmlsZSA9IHRydWU7XG5cdGlmIChlbnYubW9iaWxlIHx8IGFnZW50LmluZGV4T2YoXCJpUGFkXCIpICE9IC0xIHx8IGFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpICE9IC0xKSBlbnYudG91Y2ggPSB0cnVlO1xuXHRpZiAoYWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpICE9IC0xKSBlbnYuaXNPcGVyYSA9IHRydWU7ZWxzZSB7XG5cdCAgLy92ZXJ5IHJvdWdoIGRldGVjdGlvbiwgYnV0IGl0IGlzIGVub3VnaCBmb3IgY3VycmVudCBnb2Fsc1xuXHQgIGVudi5pc0lFID0gISFkb2N1bWVudC5hbGwgfHwgYWdlbnQuaW5kZXhPZihcIlRyaWRlbnRcIikgIT09IC0xO1xuXG5cdCAgaWYgKGVudi5pc0lFKSB7XG5cdCAgICB2YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQobmF2aWdhdG9yLmFwcFZlcnNpb24uc3BsaXQoXCJNU0lFXCIpWzFdKTtcblx0ICAgIGlmICh2ZXJzaW9uID09IDgpIGVudi5pc0lFOCA9IHRydWU7XG5cdCAgfVxuXG5cdCAgZW52LmlzRWRnZSA9IGFnZW50LmluZGV4T2YoXCJFZGdlXCIpICE9IC0xO1xuXHQgIGVudi5pc0ZGID0gYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgIT0gLTE7XG5cdCAgZW52LmlzV2ViS2l0ID0gYWdlbnQuaW5kZXhPZihcIktIVE1MXCIpICE9IC0xO1xuXHQgIGVudi5pc1NhZmFyaSA9IGVudi5pc1dlYktpdCAmJiBlbnYuaXNNYWMgJiYgYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PSAtMTsgLy9tYXhpbXVtIGhlaWdodC93aWR0aCBmb3IgSFRNTCBlbGVtZW50cyBpbiBwaXhlbHMgKHJvdWdoKSwgYmlnZ2VyIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQgYnkgYnJvd3NlclxuXG5cdCAgaWYgKGVudi5pc0lFIHx8IGVudi5pc0VkZ2UgfHwgZW52LmlzRkYpIGVudi5tYXhIVE1MRWxlbWVudFNpemUgPSAxMDAwMDAwMDtcblx0ICBpZiAoZW52LmlzU2FmYXJpKSBlbnYubWF4SFRNTEVsZW1lbnRTaXplID0gMTAwMDAwMDAwO1xuXHR9XG5cblx0aWYgKGFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT0gLTEpIHtcblx0ICBlbnYuaXNBbmRyb2lkID0gdHJ1ZTtcblxuXHQgIGlmIChhZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ0cmlkZW50XCIpICE9IC0xKSB7XG5cdCAgICBlbnYuaXNBbmRyb2lkID0gZmFsc2U7XG5cdCAgICBlbnYuaXNJRU1vYmlsZSA9IHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZW52LnRyYW5zZm9ybSA9IGZhbHNlO1xuXHRlbnYudHJhbnNpdGlvbiA9IGZhbHNlO1xuXHR2YXIgZm91bmRfaW5kZXggPSAtMTtcblx0dmFyIGpzX2xpc3QgPSBbXCJcIiwgXCJ3ZWJraXRcIiwgXCJNb3pcIiwgXCJPXCIsIFwibXNcIl07XG5cdHZhciBjc3NfbGlzdCA9IFtcIlwiLCBcIi13ZWJraXQtXCIsIFwiLU1vei1cIiwgXCItby1cIiwgXCItbXMtXCJdO1xuXHR2YXIgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCBqc19saXN0Lmxlbmd0aDsgaisrKSB7XG5cdCAgdmFyIG5hbWUgPSBqc19saXN0W2pdID8ganNfbGlzdFtqXSArIFwiVHJhbnNmb3JtXCIgOiBcInRyYW5zZm9ybVwiO1xuXG5cdCAgaWYgKHR5cGVvZiBkLnN0eWxlW25hbWVdICE9IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgIGZvdW5kX2luZGV4ID0gajtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXG5cdGlmIChmb3VuZF9pbmRleCA+IC0xKSB7XG5cdCAgZW52LmNzc1ByZWZpeCA9IGNzc19saXN0W2ZvdW5kX2luZGV4XTtcblx0ICB2YXIganAgPSBlbnYuanNQcmVmaXggPSBqc19saXN0W2ZvdW5kX2luZGV4XTtcblx0ICBlbnYudHJhbnNmb3JtID0ganAgPyBqcCArIFwiVHJhbnNmb3JtXCIgOiBcInRyYW5zZm9ybVwiO1xuXHQgIGVudi50cmFuc2l0aW9uID0ganAgPyBqcCArIFwiVHJhbnNpdGlvblwiIDogXCJ0cmFuc2l0aW9uXCI7XG5cdCAgZW52LnRyYW5zaXRpb25EdXJhdGlvbiA9IGpwID8ganAgKyBcIlRyYW5zaXRpb25EdXJhdGlvblwiIDogXCJ0cmFuc2l0aW9uRHVyYXRpb25cIjtcblx0ICBkLnN0eWxlW2Vudi50cmFuc2Zvcm1dID0gXCJ0cmFuc2xhdGUzZCgwLDAsMClcIjtcblx0ICBlbnYudHJhbnNsYXRlID0gZC5zdHlsZVtlbnYudHJhbnNmb3JtXSA/IFwidHJhbnNsYXRlM2RcIiA6IFwidHJhbnNsYXRlXCI7XG5cdCAgZW52LnRyYW5zaXRpb25FbmQgPSBlbnYuY3NzUHJlZml4ID09IFwiLU1vei1cIiA/IFwidHJhbnNpdGlvbmVuZFwiIDoganAgPyBqcCArIFwiVHJhbnNpdGlvbkVuZFwiIDogXCJ0cmFuc2l0aW9uZW5kXCI7XG5cdH1cblxuXHRlbnYucG9pbnRlcmV2ZW50cyA9ICFlbnYuaXNJRSB8fCBuZXcgUmVnRXhwKFwiVHJpZGVudC8uKnJ2OjExXCIpLmV4ZWMoYWdlbnQpICE9PSBudWxsOyAvL3RvdWNoIGV2ZW50cyB0aGF0IGNhbiBiZSBwcmV2ZW50ZWRcblxuXHRlbnYucGFzc2l2ZUV2ZW50TGlzdGVuZXJzID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0ICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJwYXNzaXZlXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdCAgICAgIGVudi5wYXNzaXZlRXZlbnRMaXN0ZW5lcnMgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIiwgbnVsbCwgb3B0cyk7XG5cdCAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLCBudWxsLCBvcHRzKTtcblx0fSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5cblx0ZW52LnN2ZyA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIik7XG5cdH0oKTtcblxuXHRlbnYuc3ZnYW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjU1ZHLWFuaW1hdGlvblwiLCBcIjEuMVwiKTtcblx0fSgpO1xuXG5cdGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG5cdCAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG5cdCAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIG9iajtcblx0ICAgIH07XG5cdCAgfSBlbHNlIHtcblx0ICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICByZXR1cm4gX3R5cGVvZihvYmopO1xuXHR9XG5cblx0Ly8gcmVzb2x2ZXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cdC8vIHF1aWNrIHNvbHV0aW9uLCBtdXN0IGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgdmVyc2lvbnNcblx0dmFyIHNlcnZpY2VzID0ge307XG5cdGZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWx1ZSkge1xuXHQgIHNlcnZpY2VzW25hbWVdID0gdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gdXNlKG5hbWUpIHtcblx0ICByZXR1cm4gc2VydmljZXNbbmFtZV07XG5cdH1cblxuXHRmdW5jdGlvbiBhc3NlcnQodGVzdCwgbXNnKSB7XG5cdCAgaWYgKCF0ZXN0KSB7XG5cdCAgICBsb2coXCJlcnJvclwiLCBtc2cpO1xuXHQgICAgdmFyIG1lc3NhZ2UgPSB1c2UoXCJtZXNzYWdlXCIpO1xuXHQgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1zZyA9PSBcInN0cmluZ1wiKSBtZXNzYWdlKHtcblx0ICAgICAgdHlwZTogXCJkZWJ1Z1wiLFxuXHQgICAgICB0ZXh0OiBtc2csXG5cdCAgICAgIGV4cGlyZTogLTFcblx0ICAgIH0pO1xuXHQgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0ICB9XG5cdH0gLy9zaG93IGxvZyBtZXNzYWdlXG5cblx0ZnVuY3Rpb24gbG9nKHR5cGUsIG1lc3NhZ2UsIGRldGFpbHMpIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG5cdCAgICBtZXNzYWdlID0gdHlwZTtcblx0ICAgIHR5cGUgPSBcImxvZ1wiO1xuXHQgIH1cblxuXHQgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcblx0ICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBpZiAod2luZG93LmNvbnNvbGVbdHlwZV0pIHdpbmRvdy5jb25zb2xlW3R5cGVdKG1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO2Vsc2Ugd2luZG93LmNvbnNvbGUubG9nKHR5cGUgKyBcIjogXCIgKyBtZXNzYWdlKTtcblx0ICAgIGlmIChkZXRhaWxzKSB3aW5kb3cuY29uc29sZS5sb2coZGV0YWlscyk7XG5cdCAgfVxuXHR9XG5cdHZhciBkZWJ1Z19tb2RlID0ge307XG5cdGZ1bmN0aW9uIGRlYnVnKG1vZGUpIHtcblx0ICBpZiAoIW1vZGUpIGRlYnVnX21vZGUgPSB7fTtlbHNlIGlmIChfdHlwZW9mKG1vZGUpICE9PSBcIm9iamVjdFwiKSBkZWJ1Z19tb2RlID0ge1xuXHQgICAgZXZlbnRzOiB0cnVlXG5cdCAgfTtlbHNlIGZvciAodmFyIGtleSBpbiBtb2RlKSB7XG5cdCAgICBkZWJ1Z19tb2RlW2tleV0gPSBtb2RlW2tleV07XG5cdCAgfVxuXHR9XG5cdHZhciBkZWJ1Z19zaXplX2luZGVudCA9IDA7XG5cblx0ZnVuY3Rpb24gZGVidWdfc2l6ZV9zdGVwKCkge1xuXHQgIHZhciBzdHIgPSBcIlwiO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z19zaXplX2luZGVudDsgaSsrKSB7XG5cdCAgICBzdHIgKz0gXCJ8ICBcIjtcblx0ICB9XG5cblx0ICByZXR1cm4gc3RyO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVidWdfc2l6ZV9ib3hfc3RhcnQoY29tcCwgZ2V0KSB7XG5cdCAgaWYgKCFkZWJ1Z19tb2RlLnNpemUpIHJldHVybjtcblx0ICBpZiAoIWRlYnVnX3NpemVfaW5kZW50KSBsb2coZ2V0ID8gXCItLS0gZ2V0IHNpemVzIC0tLVwiIDogXCItLS0gc2V0IHNpemVzIC0tLVwiKTtcblx0ICBsb2coZGVidWdfc2l6ZV9zdGVwKCkgKyBjb21wLm5hbWUgKyBcIkBcIiArIGNvbXAuY29uZmlnLmlkKTtcblx0ICBkZWJ1Z19zaXplX2luZGVudCsrO1xuXHR9XG5cdGZ1bmN0aW9uIGRlYnVnX3NpemVfYm94X2VuZChjb21wLCBzaXplcykge1xuXHQgIGlmICghZGVidWdfbW9kZS5zaXplKSByZXR1cm47XG5cdCAgZGVidWdfc2l6ZV9pbmRlbnQtLTtcblx0ICBsb2coZGVidWdfc2l6ZV9zdGVwKCkgKyBzaXplcy5qb2luKFwiLFwiKSk7XG5cdH1cblx0ZnVuY3Rpb24gZGVidWdfc2l6ZV9ib3goY29tcCwgc2l6ZXMsIGdldCkge1xuXHQgIGlmICghZGVidWdfbW9kZS5zaXplKSByZXR1cm47XG5cdCAgaWYgKCFkZWJ1Z19zaXplX2luZGVudCkgbG9nKGdldCA/IFwiLS0tIGdldCBzaXplcyAtLS1cIiA6IFwiLS0tIHNldCBzaXplcyAtLS1cIik7XG5cdCAgbG9nKGRlYnVnX3NpemVfc3RlcCgpICsgY29tcC5uYW1lICsgXCJAXCIgKyBjb21wLmNvbmZpZy5pZCArIFwiIFwiICsgc2l6ZXMuam9pbihcIixcIikpO1xuXHR9XG5cblx0dmFyIGxldmVsID0gMDtcblx0ZnVuY3Rpb24gbGV2ZWxfaW4oKSB7XG5cdCAgbGV2ZWwrKztcblx0ICBhc3NlcnQobGV2ZWwgIT09IDEwMCwgXCJBdHRlbXB0IHRvIGNvcHkgb2JqZWN0IHdpdGggc2VsZiByZWZlcmVuY2VcIik7XG5cdH1cblx0ZnVuY3Rpb24gbGV2ZWxfb3V0KCkge1xuXHQgIGxldmVsLS07XG5cdH0gLy9jb2RpbmcgaGVscGVyc1xuXG5cdGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuXHQgIHZhciBmID0gY2xvbmUuX2Z1bmN0aW9uO1xuXHQgIGYucHJvdG90eXBlID0gc291cmNlO1xuXHQgIHJldHVybiBuZXcgZigpO1xuXHR9XG5cblx0Y2xvbmUuX2Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge307IC8vY29waWVzIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGhlIHRhcmdldFxuXG5cblx0ZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAoYmFzZSwgc291cmNlLCBmb3JjZSkge1xuXHQgIGFzc2VydChiYXNlLCBcIkludmFsaWQgbWl4aW5nIHRhcmdldFwiKTtcblx0ICBhc3NlcnQoc291cmNlLCBcIkludmFsaWQgbWl4aW5nIHNvdXJjZVwiKTtcblxuXHQgIGlmIChiYXNlLiRwcm90b1dhaXQpIHtcblx0ICAgIFBvd2VyQXJyYXkuaW5zZXJ0QXQuY2FsbChiYXNlLiRwcm90b1dhaXQsIHNvdXJjZSwgMSk7XG5cdCAgICByZXR1cm4gYmFzZTtcblx0ICB9IC8vY29weSBtZXRob2RzLCBvdmVyd3JpdGUgZXhpc3Rpbmcgb25lcyBpbiBjYXNlIG9mIGNvbmZsaWN0XG5cblxuXHQgIGZvciAodmFyIG1ldGhvZCBpbiBzb3VyY2UpIHtcblx0ICAgIGlmICghKG1ldGhvZCBpbiBiYXNlKSB8fCBmb3JjZSkgYmFzZVttZXRob2RdID0gc291cmNlW21ldGhvZF07XG5cdCAgfSAvL2luIGNhc2Ugb2YgZGVmYXVsdHMgLSBwcmVmZmVyIHRvcCBvbmVcblxuXG5cdCAgaWYgKHNvdXJjZS5kZWZhdWx0cykgZXhwb3J0cy5leHRlbmQoYmFzZS5kZWZhdWx0cywgc291cmNlLmRlZmF1bHRzKTsgLy9pZiBzb3VyY2Ugb2JqZWN0IGhhcyBpbml0IGNvZGUgLSBjYWxsIGluaXQgYWdhaW5zdCB0YXJnZXRcblxuXHQgIGlmIChzb3VyY2UuJGluaXQpIHNvdXJjZS4kaW5pdC5jYWxsKGJhc2UpO1xuXHQgIHJldHVybiBiYXNlO1xuXHR9OyAvL2NvcGllcyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRoZSB0YXJnZXQgZnJvbSBhbGwgbGV2ZWxzXG5cblxuXHRmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuXHQgIGFzc2VydChzb3VyY2UsIFwiSW52YWxpZCBtaXhpbmcgdGFyZ2V0XCIpO1xuXHQgIGxldmVsX2luKCk7XG5cdCAgdmFyIGVzTW9kZXJuID0gISF3aW5kb3cuTWFwICYmICEhd2luZG93LlNldCAmJiAhIXdpbmRvdy5XZWFrTWFwICYmICEhd2luZG93LldlYWtTZXQ7XG5cdCAgdmFyIHRhcmdldDtcblxuXHQgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHQgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXHQgICAgc291cmNlID0gYXJndW1lbnRzWzFdO1xuXHQgIH0gZWxzZSB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG5cdCAgZm9yICh2YXIgbWV0aG9kIGluIHNvdXJjZSkge1xuXHQgICAgdmFyIGZyb20gPSBzb3VyY2VbbWV0aG9kXTtcblxuXHQgICAgaWYgKGZyb20gJiYgX3R5cGVvZihmcm9tKSA9PSBcIm9iamVjdFwiICYmICEoZnJvbSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcblx0ICAgICAgaWYgKGlzRGF0ZShmcm9tKSkgdGFyZ2V0W21ldGhvZF0gPSBuZXcgRGF0ZShmcm9tKTtcblx0ICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuXHQgICAgICBlbHNlIGlmIChlc01vZGVybiAmJiAoZnJvbSBpbnN0YW5jZW9mIE1hcCB8fCBmcm9tIGluc3RhbmNlb2YgU2V0IHx8IGZyb20gaW5zdGFuY2VvZiBXZWFrTWFwIHx8IGZyb20gaW5zdGFuY2VvZiBXZWFrU2V0KSkgdGFyZ2V0W21ldGhvZF0gPSBmcm9tO1xuXHQgICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRhcmdldFttZXRob2RdID0gaXNBcnJheShmcm9tKSA/IFtdIDoge307XG5cdCAgICAgICAgICAgIGNvcHkodGFyZ2V0W21ldGhvZF0sIGZyb20pO1xuXHQgICAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGFyZ2V0W21ldGhvZF0gPSBmcm9tO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGxldmVsX291dCgpO1xuXHQgIHJldHVybiB0YXJnZXQ7XG5cdH1cblx0ZnVuY3Rpb24gc2luZ2xlKHNvdXJjZSkge1xuXHQgIHZhciBpbnN0YW5jZSA9IG51bGw7XG5cblx0ICB2YXIgdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghaW5zdGFuY2UpIGluc3RhbmNlID0gbmV3IHNvdXJjZSh7fSk7XG5cdCAgICBpZiAoaW5zdGFuY2UuX3JlaW5pdCkgaW5zdGFuY2UuX3JlaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIHQ7XG5cdH0gLy9jcmVhdGVzIGZ1bmN0aW9uIHdpdGggc3BlY2lmaWVkIFwidGhpc1wiIHBvaW50ZXJcblxuXHRmdW5jdGlvbiBiaW5kKGZ1bmN0b3IsIG9iamVjdCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rvci5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblx0fSAvL2V2YWx1YXRlIGphdmFzY3JpcHQgY29kZSBpbiB0aGUgZ2xvYmFsIHNjb29wZVxuXG5cdGZ1bmN0aW9uIGV4ZWMoY29kZSkge1xuXHQgIGlmICh3aW5kb3cuZXhlY1NjcmlwdCkgLy9zcGVjaWFsIGhhbmRsaW5nIGZvciBJRVxuXHQgICAgd2luZG93LmV4ZWNTY3JpcHQoY29kZSk7ZWxzZSB3aW5kb3cuZXZhbChjb2RlKTtcblx0fVxuXHRmdW5jdGlvbiB3cmFwKGNvZGUsIHdyYXApIHtcblx0ICBpZiAoIWNvZGUpIHJldHVybiB3cmFwO1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gY29kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgd3JhcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHR9IC8vY2hlY2sgPT09IHVuZGVmaW5lZFxuXG5cdGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGEpIHtcblx0ICByZXR1cm4gdHlwZW9mIGEgPT0gXCJ1bmRlZmluZWRcIjtcblx0fSAvL2RlbGF5IGNhbGwgdG8gYWZ0ZXItcmVuZGVyIHRpbWVcblxuXHRmdW5jdGlvbiBkZWxheShtZXRob2QsIG9iaiwgcGFyYW1zLCBkZWxheSkge1xuXHQgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIShvYmogJiYgb2JqLiRkZXN0cnVjdGVkKSkge1xuXHQgICAgICB2YXIgcmV0ID0gbWV0aG9kLmFwcGx5KG9iaiwgcGFyYW1zIHx8IFtdKTtcblx0ICAgICAgbWV0aG9kID0gb2JqID0gcGFyYW1zID0gbnVsbDtcblx0ICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH1cblx0ICB9LCBkZWxheSB8fCAxKTtcblx0fVxuXHRmdW5jdGlvbiBvbmNlKG1ldGhvZCkge1xuXHQgIHZhciBmbGFnID0gdHJ1ZTtcblx0ICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGZsYWcpIHtcblx0ICAgICAgZmxhZyA9IGZhbHNlO1xuXHQgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9IC8vY29tbW9uIGhlbHBlcnNcblx0Ly9nZW5lcmF0ZXMgdW5pcXVlIElEICh1bmlxdWUgcGVyIHdpbmRvdywgbm9nIEdVSUQpXG5cblx0dmFyIF9zZWVkID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG5cblx0ZnVuY3Rpb24gdWlkKCkge1xuXHQgIF9zZWVkKys7XG5cdCAgcmV0dXJuIF9zZWVkO1xuXHR9IC8vcmVzb2x2ZSBJRCBhcyBodG1sIG9iamVjdFxuXG5cdGZ1bmN0aW9uIHRvTm9kZShub2RlKSB7XG5cdCAgaWYgKHR5cGVvZiBub2RlID09IFwic3RyaW5nXCIpIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlKTtcblx0ICByZXR1cm4gbm9kZTtcblx0fSAvL2FkZHMgZXh0cmEgbWV0aG9kcyBmb3IgdGhlIGFycmF5XG5cblx0ZnVuY3Rpb24gdG9BcnJheShhcnJheSkge1xuXHQgIHJldHVybiBleHBvcnRzLmV4dGVuZChhcnJheSB8fCBbXSwgUG93ZXJBcnJheSwgdHJ1ZSk7XG5cdH0gLy9yZXNvbHZlIGZ1bmN0aW9uIG5hbWVcblxuXHRmdW5jdGlvbiB0b0Z1bmN0b3Ioc3RyLCBzY29wZSkge1xuXHQgIGlmICh0eXBlb2Ygc3RyID09IFwic3RyaW5nXCIpIHtcblx0ICAgIHZhciBtZXRob2QgPSBzdHIucmVwbGFjZShcIigpXCIsIFwiXCIpO1xuXHQgICAgaWYgKHNjb3BlICYmIHNjb3BlW21ldGhvZF0pIHJldHVybiBzY29wZVttZXRob2RdO1xuXHQgICAgcmV0dXJuIHdpbmRvd1ttZXRob2RdIHx8IHdpbmRvdy5ldmFsKHN0cik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXHQvKmNoZWNrcyB3aGVyZSBhbiBvYmplY3QgaXMgaW5zdGFuY2Ugb2YgQXJyYXkqL1xuXG5cdGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG5cdCAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXHR9XG5cdGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcblx0ICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGF0ZTtcblx0fSAvL2NhbiBiZSB1c2VkIGJ5IHRvQXJyYXkoKVxuXG5cdHZhciBQb3dlckFycmF5ID0ge1xuXHQgIC8vcmVtb3ZlIGVsZW1lbnQgYXQgc3BlY2lmaWVkIHBvc2l0aW9uXG5cdCAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChwb3MsIGxlbikge1xuXHQgICAgaWYgKHBvcyA+PSAwKSB0aGlzLnNwbGljZShwb3MsIGxlbiB8fCAxKTtcblx0ICB9LFxuXHQgIC8vZmluZCBlbGVtZW50IGluIGNvbGxlY3Rpb24gYW5kIHJlbW92ZSBpdCBcblx0ICByZW1vdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5yZW1vdmVBdCh0aGlzLmZpbmQodmFsdWUpKTtcblx0ICB9LFxuXHQgIC8vYWRkIGVsZW1lbnQgdG8gY29sbGVjdGlvbiBhdCBzcGVjaWZpYyBwb3NpdGlvblxuXHQgIGluc2VydEF0OiBmdW5jdGlvbiAoZGF0YSwgcG9zKSB7XG5cdCAgICBpZiAoIXBvcyAmJiBwb3MgIT09IDApIC8vYWRkIHRvIHRoZSBlbmQgYnkgZGVmYXVsdFxuXHQgICAgICB0aGlzLnB1c2goZGF0YSk7ZWxzZSB7XG5cdCAgICAgIHRoaXMuc3BsaWNlKHBvcywgMCwgZGF0YSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL3JldHVybiBpbmRleCBvZiBlbGVtZW50LCAtMSBpZiBpdCBkb2Vzbid0IGV4aXN0c1xuXHQgIGZpbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGRhdGEgPT0gdGhpc1tpXSkgcmV0dXJuIGk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAtMTtcblx0ICB9LFxuXHQgIC8vZXhlY3V0ZSBzb21lIG1ldGhvZCBmb3IgZWFjaCBlbGVtZW50IG9mIGFycmF5XG5cdCAgZWFjaDogZnVuY3Rpb24gKGZ1bmN0b3IsIG1hc3Rlcikge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGZ1bmN0b3IuY2FsbChtYXN0ZXIgfHwgdGhpcywgdGhpc1tpXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2NyZWF0ZSBuZXcgYXJyYXkgZnJvbSBzb3VyY2UsIGJ5IHVzaW5nIHJlc3VsdHMgb2YgZnVuY3RvciBcblx0ICBtYXA6IGZ1bmN0aW9uIChmdW5jdG9yLCBtYXN0ZXIpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzW2ldID0gZnVuY3Rvci5jYWxsKG1hc3RlciB8fCB0aGlzLCB0aGlzW2ldKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfSxcblx0ICBmaWx0ZXI6IGZ1bmN0aW9uIChmdW5jdG9yLCBtYXN0ZXIpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoIWZ1bmN0b3IuY2FsbChtYXN0ZXIgfHwgdGhpcywgdGhpc1tpXSkpIHtcblx0ICAgICAgICB0aGlzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICBpLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXHR9OyAvL2hvb2sgZm9yIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yXG5cblx0e1xuXHQgIGlmICh3aW5kb3cud2ViaXhfb25fY29yZV9yZWFkeSkge1xuXHQgICAgZXhwb3J0cy5leHRlbmQgPSB3aW5kb3cud2ViaXhfb25fY29yZV9yZWFkeSh7XG5cdCAgICAgIGV4dGVuZDogZXhwb3J0cy5leHRlbmRcblx0ICAgIH0pLmV4dGVuZDtcblx0ICB9XG5cdH1cblxuXHR2YXIgRXZlbnRTeXN0ZW0gPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fZXZzX2V2ZW50cykge1xuXHQgICAgICB0aGlzLl9ldnNfZXZlbnRzID0ge307IC8vaGFzaCBvZiBldmVudCBoYW5kbGVycywgbmFtZSA9PiBoYW5kbGVyXG5cblx0ICAgICAgdGhpcy5fZXZzX2hhbmRsZXJzID0ge307IC8vaGFzaCBvZiBldmVudCBoYW5kbGVycywgSUQgPT4gaGFuZGxlclxuXG5cdCAgICAgIHRoaXMuX2V2c19tYXAgPSB7fTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vdGVtcG9yYXJ5IGJsb2NrIGV2ZW50IHRyaWdnZXJpbmdcblx0ICBibG9ja0V2ZW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9ldnNfZXZlbnRzLl9ibG9jayA9IHRydWU7XG5cdCAgfSxcblx0ICAvL3JlLWVuYWJsZSBldmVudCB0cmlnZ2VyaW5nXG5cdCAgdW5ibG9ja0V2ZW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9ldnNfZXZlbnRzLl9ibG9jayA9IGZhbHNlO1xuXHQgIH0sXG5cdCAgbWFwRXZlbnQ6IGZ1bmN0aW9uIChtYXApIHtcblx0ICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMuX2V2c19tYXAsIG1hcCwgdHJ1ZSk7XG5cdCAgfSxcblx0ICBvbl9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcpIHtcblx0ICAgICAgZm9yICh2YXIgaSBpbiBjb25maWcpIHtcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdG9GdW5jdG9yKGNvbmZpZ1tpXSwgdGhpcy4kc2NvcGUpO1xuXHQgICAgICAgIHZhciBzdWIgPSBpLmluZGV4T2YoXCItPlwiKTtcblxuXHQgICAgICAgIGlmIChzdWIgIT09IC0xKSB7XG5cdCAgICAgICAgICB0aGlzW2kuc3Vic3RyKDAsIHN1YildLmF0dGFjaEV2ZW50KGkuc3Vic3RyKHN1YiArIDIpLCBiaW5kKG1ldGhvZCwgdGhpcykpO1xuXHQgICAgICAgIH0gZWxzZSB0aGlzLmF0dGFjaEV2ZW50KGksIG1ldGhvZCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vdHJpZ2dlciBldmVudFxuXHQgIGNhbGxFdmVudDogZnVuY3Rpb24gKHR5cGUsIHBhcmFtcykge1xuXHQgICAgdmFyIG1hc3RlciA9IHRoaXMuX2V2ZW50X21hc3RlciB8fCB0aGlzO1xuXHQgICAgaWYgKHRoaXMuX2V2c19ldmVudHMuX2Jsb2NrKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgIHZhciBldmVudF9zdGFjayA9IHRoaXMuX2V2c19ldmVudHNbdHlwZS50b0xvd2VyQ2FzZSgpXTsgLy9hbGwgZXZlbnRzIGZvciBwcm92aWRlZCBuYW1lXG5cblxuXHQgICAgdmFyIHJldHVybl92YWx1ZSA9IHRydWU7XG5cdCAgICBpZiAoKGRlYnVnX21vZGUuZXZlbnRzIHx8IHRoaXMuZGVidWcpICYmIHR5cGUgIT09IFwib25tb3VzZW1vdmluZ1wiKSAvL2NhbiBzbG93ZG93biBhIGxvdFxuXHQgICAgICBsb2coXCJpbmZvXCIsIFwiW1wiICsgdGhpcy5uYW1lICsgXCJAXCIgKyAodGhpcy5fc2V0dGluZ3MgfHwge30pLmlkICsgXCJdIGV2ZW50OlwiICsgdHlwZSwgcGFyYW1zKTtcblx0ICAgIGlmIChldmVudF9zdGFjaykgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudF9zdGFjay5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvKlxuXHQgICAgICBcdENhbGwgZXZlbnRzIG9uZSBieSBvbmVcblx0ICAgICAgXHRJZiBhbnkgZXZlbnQgcmV0dXJuIGZhbHNlIC0gcmVzdWx0IG9mIHdob2xlIGV2ZW50IHdpbGwgYmUgZmFsc2Vcblx0ICAgICAgXHRIYW5kbGVycyB3aGljaCBhcmUgbm90IHJldHVybmluZyBhbnl0aGluZyAtIGNvdW50ZWQgYXMgcG9zaXRpdmVcblx0ICAgICAgKi9cblx0ICAgICAgaWYgKGV2ZW50X3N0YWNrW2ldLmFwcGx5KG1hc3RlciwgcGFyYW1zIHx8IFtdKSA9PT0gZmFsc2UpIHJldHVybl92YWx1ZSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fZXZzX21hcFt0eXBlXSkge1xuXHQgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZXZzX21hcFt0eXBlXTtcblx0ICAgICAgdGFyZ2V0LiRldmVudFNvdXJjZSA9IHRoaXM7XG5cdCAgICAgIGlmICghdGFyZ2V0LmNhbGxFdmVudCh0eXBlLCBwYXJhbXMpKSByZXR1cm5fdmFsdWUgPSBmYWxzZTtcblx0ICAgICAgdGFyZ2V0LiRldmVudFNvdXJjZSA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXR1cm5fdmFsdWU7XG5cdCAgfSxcblx0ICAvL2Fzc2lnbiBoYW5kbGVyIGZvciBzb21lIG5hbWVkIGV2ZW50XG5cdCAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBmdW5jdG9yLCBpZCkge1xuXHQgICAgYXNzZXJ0KGZ1bmN0b3IsIFwiSW52YWxpZCBldmVudCBoYW5kbGVyIGZvciBcIiArIHR5cGUpO1xuXHQgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0ICAgIGlkID0gaWQgfHwgdWlkKCk7IC8vSUQgY2FuIGJlIHVzZWQgZm9yIGRldGFjaEV2ZW50XG5cblx0ICAgIGZ1bmN0b3IgPSB0b0Z1bmN0b3IoZnVuY3RvciwgdGhpcy4kc2NvcGUpOyAvL2Z1bmN0b3IgY2FuIGJlIGEgbmFtZSBvZiBtZXRob2RcblxuXHQgICAgdmFyIGV2ZW50X3N0YWNrID0gdGhpcy5fZXZzX2V2ZW50c1t0eXBlXSB8fCB0b0FycmF5KCk7IC8vc2F2ZSBuZXcgZXZlbnQgaGFuZGxlclxuXG5cdCAgICBpZiAoYXJndW1lbnRzWzNdKSBldmVudF9zdGFjay51bnNoaWZ0KGZ1bmN0b3IpO2Vsc2UgZXZlbnRfc3RhY2sucHVzaChmdW5jdG9yKTtcblx0ICAgIHRoaXMuX2V2c19ldmVudHNbdHlwZV0gPSBldmVudF9zdGFjaztcblx0ICAgIHRoaXMuX2V2c19oYW5kbGVyc1tpZF0gPSB7XG5cdCAgICAgIGY6IGZ1bmN0b3IsXG5cdCAgICAgIHQ6IHR5cGVcblx0ICAgIH07XG5cdCAgICByZXR1cm4gaWQ7XG5cdCAgfSxcblx0ICAvL3JlbW92ZSBldmVudCBoYW5kbGVyXG5cdCAgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKCF0aGlzLl9ldnNfaGFuZGxlcnNbaWRdKSB7XG5cdCAgICAgIHZhciBuYW1lID0gKGlkICsgXCJcIikudG9Mb3dlckNhc2UoKTtcblxuXHQgICAgICBpZiAodGhpcy5fZXZzX2V2ZW50c1tuYW1lXSkge1xuXHQgICAgICAgIHRoaXMuX2V2c19ldmVudHNbbmFtZV0gPSB0b0FycmF5KCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciB0eXBlID0gdGhpcy5fZXZzX2hhbmRsZXJzW2lkXS50O1xuXHQgICAgdmFyIGZ1bmN0b3IgPSB0aGlzLl9ldnNfaGFuZGxlcnNbaWRdLmY7IC8vcmVtb3ZlIGZyb20gYWxsIGNvbGxlY3Rpb25zXG5cblx0ICAgIHZhciBldmVudF9zdGFjayA9IHRoaXMuX2V2c19ldmVudHNbdHlwZV07XG5cdCAgICBldmVudF9zdGFjay5yZW1vdmUoZnVuY3Rvcik7XG5cdCAgICBkZWxldGUgdGhpcy5fZXZzX2hhbmRsZXJzW2lkXTtcblx0ICB9LFxuXHQgIGhhc0V2ZW50OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhciBzdGFjayA9IHRoaXMuX2V2c19ldmVudHNbdHlwZV07XG5cdCAgICBpZiAoc3RhY2sgJiYgc3RhY2subGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLl9ldnNfbWFwW3R5cGVdO1xuXHQgICAgaWYgKHBhcmVudCkgcmV0dXJuIHBhcmVudC5oYXNFdmVudCh0eXBlKTtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH07XG5cblx0dmFyIGV2cyA9IHt9O1xuXHRleHBvcnRzLmV4dGVuZChldnMsIEV2ZW50U3lzdGVtLCB0cnVlKTtcblx0dmFyIGNhbGxFdmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgcmV0dXJuIGV2cy5jYWxsRXZlbnQoYSwgYik7XG5cdH07XG5cdHZhciBhdHRhY2hFdmVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG5cdCAgcmV0dXJuIGV2cy5hdHRhY2hFdmVudChhLCBiLCBjLCBkKTtcblx0fTtcblx0dmFyIGRldGFjaEV2ZW50ID0gZnVuY3Rpb24gKGEpIHtcblx0ICByZXR1cm4gZXZzLmRldGFjaEV2ZW50KGEpO1xuXHR9O1xuXHR2YXIgYmxvY2tFdmVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gZXZzLmJsb2NrRXZlbnQoKTtcblx0fTtcblx0dmFyIHVuYmxvY2tFdmVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gZXZzLnVuYmxvY2tFdmVudCgpO1xuXHR9O1xuXHR2YXIgbWFwRXZlbnQgPSBmdW5jdGlvbiAobWFwKSB7XG5cdCAgcmV0dXJuIGV2cy5tYXBFdmVudChtYXApO1xuXHR9O1xuXHR2YXIgaGFzRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHQgIHJldHVybiBldnMuaGFzRXZlbnQodHlwZSk7XG5cdH07XG5cblx0dmFyIF9uYXRpdmVfb25fc2VsZWN0c3RhcnQgPSAwO1xuXHR2YXIgX3N0eWxlX2VsZW1lbnQgPSB7fTtcblx0dmFyIF9zdHlsZV9jYWNoZSA9IHt9O1xuXHRmdW5jdGlvbiBkZW55U2VsZWN0KCkge1xuXHQgIGlmICghX25hdGl2ZV9vbl9zZWxlY3RzdGFydCkgX25hdGl2ZV9vbl9zZWxlY3RzdGFydCA9IGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQ7XG5cdCAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IHN0b3BFdmVudDtcblx0fVxuXHRmdW5jdGlvbiBhbGxvd1NlbGVjdCgpIHtcblx0ICBpZiAoX25hdGl2ZV9vbl9zZWxlY3RzdGFydCAhPT0gMCkge1xuXHQgICAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IF9uYXRpdmVfb25fc2VsZWN0c3RhcnQgfHwgbnVsbDtcblx0ICB9XG5cblx0ICBfbmF0aXZlX29uX3NlbGVjdHN0YXJ0ID0gMDtcblx0fVxuXHRmdW5jdGlvbiBpbmRleChub2RlKSB7XG5cdCAgdmFyIGsgPSAwOyAvL211c3QgYmUgPSwgaXQgaXMgbm90IGEgY29tcGFyYXRpb24hXG5cblx0ICB3aGlsZSAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG5cdCAgICBrKys7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGs7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlQ3NzKHJ1bGUsIHN1Zml4KSB7XG5cdCAgdmFyIHRleHQgPSBcIlwiO1xuXHQgIHN1Zml4ID0gc3VmaXggfHwgXCJcIjtcblxuXHQgIGZvciAodmFyIGtleSBpbiBydWxlKSB7XG5cdCAgICB0ZXh0ICs9IGtleSArIFwiOlwiICsgcnVsZVtrZXldICsgXCI7XCI7XG5cdCAgfVxuXG5cdCAgdmFyIG5hbWUgPSBfc3R5bGVfY2FjaGVbdGV4dCArIHN1Zml4XTtcblxuXHQgIGlmICghbmFtZSkge1xuXHQgICAgbmFtZSA9IFwic1wiICsgdWlkKCk7XG5cdCAgICBhZGRTdHlsZShcIi5cIiArIG5hbWUgKyAoc3VmaXggfHwgXCJcIikgKyBcIntcIiArIHRleHQgKyBcIn1cIik7XG5cdCAgICBfc3R5bGVfY2FjaGVbdGV4dCArIHN1Zml4XSA9IG5hbWU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5hbWU7XG5cdH1cblx0ZnVuY3Rpb24gYWRkU3R5bGUocnVsZSwgZ3JvdXApIHtcblx0ICB2YXIgc3R5bGUgPSBncm91cCA/IF9zdHlsZV9lbGVtZW50W2dyb3VwXSA6IF9zdHlsZV9lbGVtZW50W1wiZGVmYXVsdFwiXTtcblxuXHQgIGlmICghc3R5bGUpIHtcblx0ICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHQgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuXHQgICAgc3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgXCJzY3JlZW4scHJpbnRcIik7XG5cdCAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHQgICAgaWYgKGdyb3VwKSBfc3R5bGVfZWxlbWVudFtncm91cF0gPSBzdHlsZTtlbHNlIF9zdHlsZV9lbGVtZW50W1wiZGVmYXVsdFwiXSA9IHN0eWxlO1xuXHQgIH1cblx0ICAvKklFOCovXG5cblxuXHQgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgKz0gcnVsZTtlbHNlIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGUpKTtcblx0fVxuXHRmdW5jdGlvbiByZW1vdmVTdHlsZShncm91cCkge1xuXHQgIHZhciBib3ggPSBfc3R5bGVfZWxlbWVudFtncm91cCB8fCBcImRlZmF1bHRcIl07XG5cdCAgaWYgKGJveCkgYm94LmlubmVySFRNTCA9IFwiXCI7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGF0dHJzLCBodG1sKSB7XG5cdCAgYXR0cnMgPSBhdHRycyB8fCB7fTtcblx0ICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG5cblx0ICBmb3IgKHZhciBhdHRyX25hbWUgaW4gYXR0cnMpIHtcblx0ICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJfbmFtZSwgYXR0cnNbYXR0cl9uYW1lXSk7XG5cdCAgfVxuXG5cdCAgaWYgKGF0dHJzLnN0eWxlKSBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRycy5zdHlsZTtcblx0ICBpZiAoYXR0cnNbXCJjbGFzc1wiXSkgbm9kZS5jbGFzc05hbWUgPSBhdHRyc1tcImNsYXNzXCJdO1xuXHQgIGlmIChodG1sKSBub2RlLmlubmVySFRNTCA9IGh0bWw7XG5cdCAgcmV0dXJuIG5vZGU7XG5cdH0gLy9yZXR1cm4gbm9kZSB2YWx1ZSwgZGlmZmVyZW50IGxvZ2ljIGZvciBkaWZmZXJlbnQgaHRtbCBlbGVtZW50c1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUpIHtcblx0ICBub2RlID0gdG9Ob2RlKG5vZGUpO1xuXHQgIGlmICghbm9kZSkgcmV0dXJuIFwiXCI7XG5cdCAgcmV0dXJuIGlzVW5kZWZpbmVkKG5vZGUudmFsdWUpID8gbm9kZS5pbm5lckhUTUwgOiBub2RlLnZhbHVlO1xuXHR9IC8vcmVtb3ZlIGh0bWwgbm9kZSwgY2FuIHByb2Nlc3MgYW4gYXJyYXkgb2Ygbm9kZXMgYXQgb25jZVxuXG5cdGZ1bmN0aW9uIHJlbW92ZShub2RlKSB7XG5cdCAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICByZW1vdmUobm9kZVtpXSk7XG5cdCAgfSBlbHNlIGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuXHR9IC8vaW5zZXJ0IG5ldyBub2RlIGJlZm9yZSBzaWJsaW5nLCBvciBhdCB0aGUgZW5kIGlmIHNpYmxpbmcgZG9lc24ndCBleGlzdFxuXG5cdGZ1bmN0aW9uIGluc2VydEJlZm9yZShub2RlLCBiZWZvcmUsIHJlc2N1ZSkge1xuXHQgIGlmICghbm9kZSkgcmV0dXJuO1xuXHQgIGlmIChiZWZvcmUgJiYgYmVmb3JlLnBhcmVudE5vZGUpIGJlZm9yZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpO2Vsc2UgcmVzY3VlLmFwcGVuZENoaWxkKG5vZGUpO1xuXHR9IC8vcmV0dXJuIGN1c3RvbSBJRCBmcm9tIGh0bWwgZWxlbWVudCBcblx0Ly93aWxsIGNoZWNrIGFsbCBwYXJlbnRzIHN0YXJ0aW5nIGZyb20gZXZlbnQncyB0YXJnZXRcblxuXHRmdW5jdGlvbiBsb2NhdGUoZSwgaWQpIHtcblx0ICB2YXIgdHJnO1xuXHQgIGlmIChlLnRhZ05hbWUpIHRyZyA9IGU7ZWxzZSB7XG5cdCAgICBlID0gZSB8fCBldmVudDtcblx0ICAgIHRyZyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0ICB9XG5cblx0ICB3aGlsZSAodHJnKSB7XG5cdCAgICBpZiAodHJnLmdldEF0dHJpYnV0ZSkge1xuXHQgICAgICAvL3RleHQgbm9kZXMgaGFzIG5vdCBnZXRBdHRyaWJ1dGVcblx0ICAgICAgdmFyIHRlc3QgPSB0cmcuZ2V0QXR0cmlidXRlKGlkKTtcblx0ICAgICAgaWYgKHRlc3QpIHJldHVybiB0ZXN0O1xuXHQgICAgfVxuXG5cdCAgICB0cmcgPSB0cmcucGFyZW50Tm9kZTtcblx0ICB9XG5cblx0ICByZXR1cm4gbnVsbDtcblx0fSAvL3JldHVybnMgcG9zaXRpb24gb2YgaHRtbCBlbGVtZW50IG9uIHRoZSBwYWdlXG5cblx0ZnVuY3Rpb24gb2Zmc2V0KGVsZW0pIHtcblx0ICBpZiAoZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcblx0ICAgIC8vSFRNTDUgbWV0aG9kXG5cdCAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0ICAgIHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHQgICAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcblx0ICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cdCAgICB2YXIgY2xpZW50VG9wID0gZG9jRWxlbS5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcblx0ICAgIHZhciBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuXHQgICAgdmFyIHRvcCA9IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XG5cdCAgICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB5OiBNYXRoLnJvdW5kKHRvcCksXG5cdCAgICAgIHg6IE1hdGgucm91bmQobGVmdCksXG5cdCAgICAgIHdpZHRoOiBlbGVtLm9mZnNldFdpZHRoLFxuXHQgICAgICBoZWlnaHQ6IGVsZW0ub2Zmc2V0SGVpZ2h0XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvL2ZhbGxiYWNrIHRvIG5haXZlIGFwcHJvYWNoXG5cdCAgICB2YXIgX3RvcCA9IDAsXG5cdCAgICAgICAgX2xlZnQgPSAwO1xuXG5cdCAgICB3aGlsZSAoZWxlbSkge1xuXHQgICAgICBfdG9wID0gX3RvcCArIHBhcnNlSW50KGVsZW0ub2Zmc2V0VG9wLCAxMCk7XG5cdCAgICAgIF9sZWZ0ID0gX2xlZnQgKyBwYXJzZUludChlbGVtLm9mZnNldExlZnQsIDEwKTtcblx0ICAgICAgZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB5OiBfdG9wLFxuXHQgICAgICB4OiBfbGVmdCxcblx0ICAgICAgd2lkdGg6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxuXHQgICAgICBoZWlnaHQ6IGVsZW0ub2Zmc2V0V2lkdGhcblx0ICAgIH07XG5cdCAgfVxuXHR9IC8vcmV0dXJucyByZWxhdGl2ZSBwb3NpdGlvbiBvZiBldmVudFxuXG5cdGZ1bmN0aW9uIHBvc1JlbGF0aXZlKGV2KSB7XG5cdCAgZXYgPSBldiB8fCBldmVudDtcblx0ICBpZiAoIWlzVW5kZWZpbmVkKGV2Lm9mZnNldFgpKSByZXR1cm4ge1xuXHQgICAgeDogZXYub2Zmc2V0WCxcblx0ICAgIHk6IGV2Lm9mZnNldFlcblx0ICB9OyAvL2llLCB3ZWJraXRcblx0ICBlbHNlIHJldHVybiB7XG5cdCAgICAgIHg6IGV2LmxheWVyWCxcblx0ICAgICAgeTogZXYubGF5ZXJZXG5cdCAgICB9OyAvL2ZpcmVmb3hcblx0fSAvL3JldHVybnMgcG9zaXRpb24gb2YgZXZlbnRcblxuXHRmdW5jdGlvbiBwb3MoZXYpIHtcblx0ICBldiA9IGV2IHx8IGV2ZW50O1xuXHQgIGlmIChldi50b3VjaGVzICYmIGV2LnRvdWNoZXNbMF0pIGV2ID0gZXYudG91Y2hlc1swXTtcblx0ICBpZiAoZXYucGFnZVggfHwgZXYucGFnZVkpIC8vRkYsIEtIVE1MXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB4OiBldi5wYWdlWCxcblx0ICAgICAgeTogZXYucGFnZVlcblx0ICAgIH07IC8vSUVcblxuXHQgIHZhciBkID0gZW52LmlzSUUgJiYgZG9jdW1lbnQuY29tcGF0TW9kZSAhPSBcIkJhY2tDb21wYXRcIiA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmJvZHk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHg6IGV2LmNsaWVudFggKyBkLnNjcm9sbExlZnQgLSBkLmNsaWVudExlZnQsXG5cdCAgICB5OiBldi5jbGllbnRZICsgZC5zY3JvbGxUb3AgLSBkLmNsaWVudFRvcFxuXHQgIH07XG5cdH0gLy9wcmV2ZW50IGV2ZW50IGFjdGlvblxuXG5cdGZ1bmN0aW9uIHByZXZlbnRFdmVudChlKSB7XG5cdCAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgIGlmIChlKSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdCAgcmV0dXJuIHN0b3BFdmVudChlKTtcblx0fSAvL3N0b3AgZXZlbnQgYnViYmxpbmdcblxuXHRmdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuXHQgIGUgPSBlIHx8IGV2ZW50O1xuXHQgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdGZ1bmN0aW9uIHRyaWdnZXJFdmVudChub2RlLCB0eXBlLCBuYW1lKSB7XG5cdCAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSB7XG5cdCAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuXHQgICAgaWYgKG5vZGUuZmlyZUV2ZW50KSBub2RlLmZpcmVFdmVudChcIm9uXCIgKyBuYW1lLCBldik7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBfZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCh0eXBlKTtcblxuXHQgICAgX2V2LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcblxuXHQgICAgaWYgKG5vZGUuZGlzcGF0Y2hFdmVudCkgbm9kZS5kaXNwYXRjaEV2ZW50KF9ldik7XG5cdCAgfVxuXHR9IC8vYWRkIGNzcyBjbGFzcyB0byB0aGUgbm9kZVxuXG5cdGZ1bmN0aW9uIGFkZENzcyhub2RlLCBuYW1lLCBjaGVjaykge1xuXHQgIGlmICghY2hlY2sgfHwgbm9kZS5jbGFzc05hbWUuaW5kZXhPZihuYW1lKSA9PT0gLTEpIG5vZGUuY2xhc3NOYW1lICs9IFwiIFwiICsgbmFtZTtcblx0fSAvL3JlbW92ZSBjc3MgY2xhc3MgZnJvbSB0aGUgbm9kZVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUNzcyhub2RlLCBuYW1lKSB7XG5cdCAgbm9kZS5jbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZS5yZXBsYWNlKFJlZ0V4cChcIiBcIiArIG5hbWUsIFwiZ1wiKSwgXCJcIik7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0VGV4dFNpemUodGV4dCwgY3NzLCBiYXNld2lkdGgpIHtcblx0ICB2YXIgZCA9IGNyZWF0ZShcIkRJVlwiLCB7XG5cdCAgICBcImNsYXNzXCI6IFwid2ViaXhfdmlldyB3ZWJpeF9tZWFzdXJlX3NpemUgXCIgKyAoY3NzIHx8IFwiXCIpXG5cdCAgfSwgXCJcIik7XG5cdCAgZC5zdHlsZS5jc3NUZXh0ID0gXCJoZWlnaHQ6YXV0bzt2aXNpYmlsaXR5OmhpZGRlbjsgcG9zaXRpb246YWJzb2x1dGU7IHRvcDowcHg7IGxlZnQ6MHB4OyBvdmVyZmxvdzpoaWRkZW47XCIgKyAoYmFzZXdpZHRoID8gXCJ3aWR0aDpcIiArIGJhc2V3aWR0aCArIFwicHg7XCIgOiBcIndpZHRoOmF1dG87d2hpdGUtc3BhY2U6bm93cmFwO1wiKTtcblx0ICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpO1xuXHQgIHZhciBhbGwgPSBfdHlwZW9mKHRleHQpICE9PSBcIm9iamVjdFwiID8gW3RleHRdIDogdGV4dDtcblx0ICB2YXIgd2lkdGggPSAwO1xuXHQgIHZhciBoZWlnaHQgPSAwO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcblx0ICAgIGQuaW5uZXJIVE1MID0gYWxsW2ldO1xuXHQgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgZC5vZmZzZXRXaWR0aCk7XG5cdCAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGQub2Zmc2V0SGVpZ2h0KTtcblx0ICB9XG5cblx0ICByZW1vdmUoZCk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHdpZHRoOiB3aWR0aCxcblx0ICAgIGhlaWdodDogaGVpZ2h0XG5cdCAgfTtcblx0fVxuXHRmdW5jdGlvbiBkb3dubG9hZChkYXRhLCBmaWxlbmFtZSkge1xuXHQgIHZhciBvYmpVcmwgPSBmYWxzZTtcblxuXHQgIGlmIChfdHlwZW9mKGRhdGEpID09IFwib2JqZWN0XCIpIHtcblx0ICAgIC8vYmxvYlxuXHQgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYikgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYihkYXRhLCBmaWxlbmFtZSk7ZWxzZSB7XG5cdCAgICAgIGRhdGEgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcblx0ICAgICAgb2JqVXJsID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9IC8vZGF0YSB1cmwgb3IgYmxvYiB1cmxcblxuXG5cdCAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0ICBsaW5rLmhyZWYgPSBkYXRhO1xuXHQgIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcblx0ICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuXHQgIGxpbmsuY2xpY2soKTtcblx0ICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAob2JqVXJsKSB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChkYXRhKTtcblx0ICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG5cdCAgICBsaW5rLnJlbW92ZSgpO1xuXHQgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIF9nZXRDbGFzc05hbWUobm9kZSkge1xuXHQgIGlmICghbm9kZSkgcmV0dXJuIFwiXCI7XG5cdCAgdmFyIGNsYXNzTmFtZSA9IG5vZGUuY2xhc3NOYW1lIHx8IFwiXCI7XG5cdCAgaWYgKGNsYXNzTmFtZS5iYXNlVmFsKSAvLydjbGFzc05hbWUnIGV4aXN0IGJ1dCBub3QgYSBzdHJpbmcgLSBJRSBzdmcgZWxlbWVudCBpbiBET01cblx0ICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5iYXNlVmFsO1xuXHQgIGlmICghY2xhc3NOYW1lLmluZGV4T2YpIGNsYXNzTmFtZSA9IFwiXCI7XG5cdCAgcmV0dXJuIGNsYXNzTmFtZTtcblx0fVxuXHRmdW5jdGlvbiBzZXRTZWxlY3Rpb25SYW5nZShub2RlLCBzdGFydCwgZW5kKSB7XG5cdCAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXHQgIGVuZCA9IGVuZCB8fCBzdGFydDtcblx0ICBub2RlLmZvY3VzKCk7XG5cdCAgaWYgKG5vZGUuc2V0U2VsZWN0aW9uUmFuZ2UpIG5vZGUuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7ZWxzZSB7XG5cdCAgICAvL2llOFxuXHQgICAgdmFyIHRleHRSYW5nZSA9IG5vZGUuY3JlYXRlVGV4dFJhbmdlKCk7XG5cdCAgICB0ZXh0UmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG5cdCAgICB0ZXh0UmFuZ2UubW92ZUVuZChcImNoYXJhY3RlclwiLCBlbmQpO1xuXHQgICAgdGV4dFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG5cdCAgICB0ZXh0UmFuZ2Uuc2VsZWN0KCk7XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlKG5vZGUpIHtcblx0ICBpZiAoXCJzZWxlY3Rpb25TdGFydFwiIGluIG5vZGUpIHJldHVybiB7XG5cdCAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCB8fCAwLFxuXHQgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZCB8fCAwXG5cdCAgfTtlbHNlIHtcblx0ICAgIC8vaWU4XG5cdCAgICBub2RlLmZvY3VzKCk7XG5cdCAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG5cdCAgICB2YXIgYm9va21hcmsgPSBzZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcblx0ICAgIHZhciB0ZXh0UmFuZ2UgPSBub2RlLmNyZWF0ZVRleHRSYW5nZSgpO1xuXHQgICAgdGV4dFJhbmdlLm1vdmVUb0Jvb2ttYXJrKGJvb2ttYXJrKTtcblx0ICAgIHZhciBsZW5ndGggPSB0ZXh0UmFuZ2UudGV4dC5sZW5ndGg7XG5cdCAgICB0ZXh0UmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG5cdCAgICB0ZXh0UmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIC1ub2RlLnZhbHVlLmxlbmd0aCk7XG5cdCAgICB2YXIgc3RhcnQgPSB0ZXh0UmFuZ2UudGV4dC5sZW5ndGg7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogc3RhcnQgKyBsZW5ndGhcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cdGZ1bmN0aW9uIGFkZE1ldGEobmFtZSwgdmFsdWUpIHtcblx0ICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIikuaXRlbSgwKS5hcHBlbmRDaGlsZChjcmVhdGUoXCJtZXRhXCIsIHtcblx0ICAgIG5hbWU6IG5hbWUsXG5cdCAgICBjb250ZW50OiB2YWx1ZVxuXHQgIH0pKTtcblx0fVxuXG5cdHZhciBpMThuID0ge1xuXHQgIHBhcnNlRm9ybWF0OiBcIiVZLSVtLSVkICVIOiVpOiVzXCIsXG5cdCAgcGFyc2VUaW1lRm9ybWF0OiBcIiVIOiVpOiVzXCJcblx0fTtcblxuXHRmdW5jdGlvbiBzdHJpbmdpZnkob2JqKSB7XG5cdCAgdmFyIG9yaWdpbiA9IERhdGUucHJvdG90eXBlLnRvSlNPTjtcblxuXHQgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBpMThuLnBhcnNlRm9ybWF0U3RyKHRoaXMpO1xuXHQgIH07XG5cblx0ICB2YXIgcmVzdWx0O1xuXHQgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSByZXN1bHQgPSBvYmoudG9KU09OKCk7ZWxzZSByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXHQgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IG9yaWdpbjtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0dmFyIGdsb2JhbCA9IHdpbmRvdztcblx0dmFyIHF1ZXVlSWQgPSAxO1xuXHR2YXIgcXVldWUgPSB7fTtcblx0dmFyIGlzUnVubmluZ1Rhc2sgPSBmYWxzZTtcblx0aWYgKCFnbG9iYWwuc2V0SW1tZWRpYXRlICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gKGUpIHtcblx0ICBpZiAoZS5zb3VyY2UgPT0gZ2xvYmFsKSB7XG5cdCAgICBpZiAoaXNSdW5uaW5nVGFzaykgbmV4dFRpY2socXVldWVbZS5kYXRhXSk7ZWxzZSB7XG5cdCAgICAgIGlzUnVubmluZ1Rhc2sgPSB0cnVlO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgcXVldWVbZS5kYXRhXSgpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuXHQgICAgICB9XG5cblx0ICAgICAgZGVsZXRlIHF1ZXVlW2UuZGF0YV07XG5cdCAgICAgIGlzUnVubmluZ1Rhc2sgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG5cdCAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIGdsb2JhbC5zZXRJbW1lZGlhdGUoZm4pOyAvLyBpZiBpbnNpZGUgb2Ygd2ViIHdvcmtlclxuXHQgIGVsc2UgaWYgKGdsb2JhbC5pbXBvcnRTY3JpcHRzIHx8ICFnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikgc2V0VGltZW91dChmbik7ZWxzZSB7XG5cdCAgICAgIHF1ZXVlSWQrKztcblx0ICAgICAgcXVldWVbcXVldWVJZF0gPSBmbjtcblx0ICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKHF1ZXVlSWQsIFwiKlwiKTtcblx0ICAgIH1cblx0fVxuXG5cdERlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICBpZiAoISh0aGlzLl9kID09IDEpKSB0aHJvdyBUeXBlRXJyb3IoKTtcblx0ICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWZlcnJlZCkgcmV0dXJuIHZhbHVlO1xuXHQgIHJldHVybiBuZXcgRGVmZXJyZWQoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgIHJlc29sdmUodmFsdWUpO1xuXHQgIH0pO1xuXHR9O1xuXG5cdERlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgIGlmICghKHRoaXMuX2QgPT0gMSkpIHRocm93IFR5cGVFcnJvcigpO1xuXHQgIHJldHVybiBuZXcgRGVmZXJyZWQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgcmVqZWN0KHZhbHVlKTtcblx0ICB9KTtcblx0fTtcblxuXHREZWZlcnJlZC5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgaWYgKCEodGhpcy5fZCA9PSAxKSkgdGhyb3cgVHlwZUVycm9yKCk7XG5cdCAgaWYgKCEoYXJyIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm4gRGVmZXJyZWQucmVqZWN0KFR5cGVFcnJvcigpKTtcblx0ICB2YXIgZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG5cdCAgZnVuY3Rpb24gZG9uZShlLCB2KSB7XG5cdCAgICBpZiAodikgcmV0dXJuIGQucmVzb2x2ZSh2KTtcblx0ICAgIGlmIChlKSByZXR1cm4gZC5yZWplY3QoZSk7XG5cdCAgICB2YXIgdW5yZXNvbHZlZCA9IGFyci5yZWR1Y2UoZnVuY3Rpb24gKGNudCwgdikge1xuXHQgICAgICBpZiAodiAmJiB2LnRoZW4pIHJldHVybiBjbnQgKyAxO1xuXHQgICAgICByZXR1cm4gY250O1xuXHQgICAgfSwgMCk7XG5cdCAgICBpZiAodW5yZXNvbHZlZCA9PSAwKSBkLnJlc29sdmUoYXJyKTtcblx0ICAgIGFyci5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcblx0ICAgICAgaWYgKHYgJiYgdi50aGVuKSB2LnRoZW4oZnVuY3Rpb24gKHIpIHtcblx0ICAgICAgICBhcnJbaV0gPSByO1xuXHQgICAgICAgIGRvbmUoKTtcblx0ICAgICAgICByZXR1cm4gcjtcblx0ICAgICAgfSwgZG9uZSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICBkb25lKCk7XG5cdCAgcmV0dXJuIGQ7XG5cdH07XG5cblx0RGVmZXJyZWQucmFjZSA9IGZ1bmN0aW9uIChhcnIpIHtcblx0ICBpZiAoISh0aGlzLl9kID09IDEpKSB0aHJvdyBUeXBlRXJyb3IoKTtcblx0ICBpZiAoIShhcnIgaW5zdGFuY2VvZiBBcnJheSkpIHJldHVybiBEZWZlcnJlZC5yZWplY3QoVHlwZUVycm9yKCkpO1xuXHQgIGlmIChhcnIubGVuZ3RoID09IDApIHJldHVybiBuZXcgRGVmZXJyZWQoKTtcblx0ICB2YXIgZCA9IG5ldyBEZWZlcnJlZCgpO1xuXG5cdCAgZnVuY3Rpb24gZG9uZShlLCB2KSB7XG5cdCAgICBpZiAodikgcmV0dXJuIGQucmVzb2x2ZSh2KTtcblx0ICAgIGlmIChlKSByZXR1cm4gZC5yZWplY3QoZSk7XG5cdCAgICB2YXIgdW5yZXNvbHZlZCA9IGFyci5yZWR1Y2UoZnVuY3Rpb24gKGNudCwgdikge1xuXHQgICAgICBpZiAodiAmJiB2LnRoZW4pIHJldHVybiBjbnQgKyAxO1xuXHQgICAgICByZXR1cm4gY250O1xuXHQgICAgfSwgMCk7XG5cdCAgICBpZiAodW5yZXNvbHZlZCA9PSAwKSBkLnJlc29sdmUoYXJyKTtcblx0ICAgIGFyci5tYXAoZnVuY3Rpb24gKHYpIHtcblx0ICAgICAgaWYgKHYgJiYgdi50aGVuKSB2LnRoZW4oZnVuY3Rpb24gKHIpIHtcblx0ICAgICAgICBkb25lKG51bGwsIHIpO1xuXHQgICAgICB9LCBkb25lKTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGRvbmUoKTtcblx0ICByZXR1cm4gZDtcblx0fTtcblxuXHREZWZlcnJlZC5fZCA9IDE7XG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cblx0ZnVuY3Rpb24gRGVmZXJyZWQocmVzb2x2ZXIpIHtcblxuXHQgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT0gXCJmdW5jdGlvblwiICYmIHJlc29sdmVyICE9IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCk7XG5cdCAgaWYgKF90eXBlb2YodGhpcykgIT0gXCJvYmplY3RcIiB8fCB0aGlzICYmIHRoaXMudGhlbikgdGhyb3cgVHlwZUVycm9yKCk7IC8vIHN0YXRlc1xuXHQgIC8vIDA6IHBlbmRpbmdcblx0ICAvLyAxOiByZXNvbHZpbmdcblx0ICAvLyAyOiByZWplY3Rpbmdcblx0ICAvLyAzOiByZXNvbHZlZFxuXHQgIC8vIDQ6IHJlamVjdGVkXG5cblx0ICB2YXIgc2VsZiA9IHRoaXMsXG5cdCAgICAgIHN0YXRlID0gMCxcblx0ICAgICAgdmFsID0gMCxcblx0ICAgICAgbmV4dCA9IFtdLFxuXHQgICAgICBmbixcblx0ICAgICAgZXI7XG5cdCAgc2VsZltcInByb21pc2VcIl0gPSBzZWxmO1xuXG5cdCAgc2VsZltcInJlc29sdmVcIl0gPSBmdW5jdGlvbiAodikge1xuXHQgICAgZm4gPSBzZWxmLmZuO1xuXHQgICAgZXIgPSBzZWxmLmVyO1xuXG5cdCAgICBpZiAoIXN0YXRlKSB7XG5cdCAgICAgIHZhbCA9IHY7XG5cdCAgICAgIHN0YXRlID0gMTtcblx0ICAgICAgbmV4dFRpY2soZmlyZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZWxmO1xuXHQgIH07XG5cblx0ICBzZWxmW1wicmVqZWN0XCJdID0gZnVuY3Rpb24gKHYpIHtcblx0ICAgIGZuID0gc2VsZi5mbjtcblx0ICAgIGVyID0gc2VsZi5lcjtcblxuXHQgICAgaWYgKCFzdGF0ZSkge1xuXHQgICAgICB2YWwgPSB2O1xuXHQgICAgICBzdGF0ZSA9IDI7XG5cdCAgICAgIG5leHRUaWNrKGZpcmUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2VsZjtcblx0ICB9O1xuXG5cdCAgc2VsZltcIl9kXCJdID0gMTtcblxuXHQgIHNlbGZbXCJ0aGVuXCJdID0gZnVuY3Rpb24gKF9mbiwgX2VyKSB7XG5cdCAgICBpZiAoISh0aGlzLl9kID09IDEpKSB0aHJvdyBUeXBlRXJyb3IoKTtcblx0ICAgIHZhciBkID0gbmV3IERlZmVycmVkKCk7XG5cdCAgICBkLmZuID0gX2ZuO1xuXHQgICAgZC5lciA9IF9lcjtcblxuXHQgICAgaWYgKHN0YXRlID09IDMpIHtcblx0ICAgICAgZC5yZXNvbHZlKHZhbCk7XG5cdCAgICB9IGVsc2UgaWYgKHN0YXRlID09IDQpIHtcblx0ICAgICAgZC5yZWplY3QodmFsKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5leHQucHVzaChkKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGQ7XG5cdCAgfTtcblxuXHQgIHNlbGZbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKF9oYW5kbGVyKSB7XG5cdCAgICB2YXIgX3ZhbHVlO1xuXG5cdCAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICBfdmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgcmV0dXJuIF9oYW5kbGVyKCk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBfdmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gc2VsZi50aGVuKGhhbmRsZXIsIGhhbmRsZXIpLnRoZW4odmFsdWUsIHZhbHVlKTtcblx0ICB9O1xuXG5cdCAgc2VsZltcImNhdGNoXCJdID0gZnVuY3Rpb24gKF9lcikge1xuXHQgICAgcmV0dXJuIHNlbGZbXCJ0aGVuXCJdKG51bGwsIF9lcik7XG5cdCAgfTsgLy9jb21wYXRpYmlsaXR5IHdpdGggb2xkIHZlcnNpb24gb2YgcHJvbWl6IGxpYlxuXG5cblx0ICBzZWxmW1wiZmFpbFwiXSA9IGZ1bmN0aW9uIChfZXIpIHtcblx0ICAgIHJldHVybiBzZWxmW1widGhlblwiXShudWxsLCBfZXIpO1xuXHQgIH07XG5cblx0ICB2YXIgZmluaXNoID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgIHN0YXRlID0gdHlwZSB8fCA0O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHAgPSBuZXh0W2ldO1xuXHQgICAgICBzdGF0ZSA9PSAzICYmIHAucmVzb2x2ZSh2YWwpIHx8IHAucmVqZWN0KHZhbCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHRyeSB7XG5cdCAgICBpZiAodHlwZW9mIHJlc29sdmVyID09IFwiZnVuY3Rpb25cIikgcmVzb2x2ZXIoc2VsZltcInJlc29sdmVcIl0sIHNlbGZbXCJyZWplY3RcIl0pO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHNlbGZbXCJyZWplY3RcIl0oZSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNlbGY7IC8vIHJlZiA6IHJlZmVyZW5jZSB0byAndGhlbicgZnVuY3Rpb25cblx0ICAvLyBjYiwgZWMsIGNuIDogc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2ssIG5vdFRoZW5uYWJsZUNhbGxiYWNrXG5cblx0ICBmdW5jdGlvbiB0aGVubmFibGUocmVmLCBjYiwgZWMsIGNuKSB7XG5cdCAgICAvLyBQcm9taXNlcyBjYW4gYmUgcmVqZWN0ZWQgd2l0aCBvdGhlciBwcm9taXNlcywgd2hpY2ggc2hvdWxkIHBhc3MgdGhyb3VnaFxuXHQgICAgaWYgKHN0YXRlID09IDIpIHtcblx0ICAgICAgcmV0dXJuIGNuKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICgoX3R5cGVvZih2YWwpID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiByZWYgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgLy8gY250IHByb3RlY3RzIGFnYWluc3QgYWJ1c2UgY2FsbHMgZnJvbSBzcGVjIGNoZWNrZXJcblx0ICAgICAgICB2YXIgY250ID0gMDtcblx0ICAgICAgICByZWYuY2FsbCh2YWwsIGZ1bmN0aW9uICh2KSB7XG5cdCAgICAgICAgICBpZiAoY250KyspIHJldHVybjtcblx0ICAgICAgICAgIHZhbCA9IHY7XG5cdCAgICAgICAgICBjYigpO1xuXHQgICAgICAgIH0sIGZ1bmN0aW9uICh2KSB7XG5cdCAgICAgICAgICBpZiAoY250KyspIHJldHVybjtcblx0ICAgICAgICAgIHZhbCA9IHY7XG5cdCAgICAgICAgICBlYygpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgdmFsID0gZTtcblx0ICAgICAgICBlYygpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjbigpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZpcmUoKSB7XG5cdCAgICAvLyBjaGVjayBpZiBpdCdzIGEgdGhlbmFibGVcblx0ICAgIHZhciByZWY7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlZiA9IHZhbCAmJiB2YWwudGhlbjtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgdmFsID0gZTtcblx0ICAgICAgc3RhdGUgPSAyO1xuXHQgICAgICByZXR1cm4gZmlyZSgpO1xuXHQgICAgfVxuXG5cdCAgICB0aGVubmFibGUocmVmLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHN0YXRlID0gMTtcblx0ICAgICAgZmlyZSgpO1xuXHQgICAgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICBzdGF0ZSA9IDI7XG5cdCAgICAgIGZpcmUoKTtcblx0ICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBpZiAoc3RhdGUgPT0gMSAmJiB0eXBlb2YgZm4gPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICB2YWwgPSBmbih2YWwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gMiAmJiB0eXBlb2YgZXIgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICB2YWwgPSBlcih2YWwpO1xuXHQgICAgICAgICAgc3RhdGUgPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHZhbCA9IGU7XG5cdCAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHZhbCA9PSBzZWxmKSB7XG5cdCAgICAgICAgdmFsID0gVHlwZUVycm9yKCk7XG5cdCAgICAgICAgZmluaXNoKCk7XG5cdCAgICAgIH0gZWxzZSB0aGVubmFibGUocmVmLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZmluaXNoKDMpO1xuXHQgICAgICB9LCBmaW5pc2gsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmaW5pc2goc3RhdGUgPT0gMSAmJiAzKTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICB9XG5cdH0gLy8gcHJvbWlzZSBmYWN0b3J5XG5cblxuXHREZWZlcnJlZC5kZWZlciA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gbmV3IERlZmVycmVkKG51bGwpO1xuXHR9O1xuXG5cdHZhciB4bWwgPSB7XG5cdCAgX2lzVmFsaWRYTUw6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gbnVsbDtcblx0ICAgIGlmIChkYXRhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSByZXR1cm4gbnVsbDtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgLy9jb252ZXJ0IHhtbCBzdHJpbmcgdG8geG1sIG9iamVjdCBpZiBuZWNlc3Nhcnlcblx0ICB0b09iamVjdDogZnVuY3Rpb24gKHRleHQsIHJlc3BvbnNlKSB7XG5cdCAgICB2YXIgZGF0YSA9IHJlc3BvbnNlID8gcmVzcG9uc2UucmF3eG1sID8gcmVzcG9uc2UucmF3eG1sKCkgOiByZXNwb25zZSA6IG51bGw7XG5cdCAgICBpZiAodGhpcy5faXNWYWxpZFhNTChkYXRhKSkgcmV0dXJuIGRhdGE7XG5cdCAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikgZGF0YSA9IHRoaXMuZnJvbVN0cmluZyh0ZXh0LnJlcGxhY2UoL15bXFxzXSsvLCBcIlwiKSk7ZWxzZSBkYXRhID0gdGV4dDtcblx0ICAgIGlmICh0aGlzLl9pc1ZhbGlkWE1MKGRhdGEpKSByZXR1cm4gZGF0YTtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgLy9nZXQgYXJyYXkgb2YgcmVjb3Jkc1xuXHQgIGdldFJlY29yZHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICByZXR1cm4gdGhpcy54cGF0aChkYXRhLCB0aGlzLnJlY29yZHMpO1xuXHQgIH0sXG5cdCAgcmVjb3JkczogXCIvKi9pdGVtXCIsXG5cdCAgY2hpbGQ6IFwiaXRlbVwiLFxuXHQgIGNvbmZpZzogXCIvKi9jb25maWdcIixcblx0ICAvL2dldCBoYXNoIG9mIHByb3BlcnRpZXMgZm9yIHNpbmdsZSByZWNvcmRcblx0ICBnZXREZXRhaWxzOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgcmV0dXJuIHRoaXMudGFnVG9PYmplY3QoZGF0YSwge30pO1xuXHQgIH0sXG5cdCAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgLy9nZXQgY291bnQgb2YgZGF0YSBhbmQgcG9zaXRpb24gYXQgd2hpY2ggbmV3IGRhdGFfbG9hZGluZyBuZWVkIHRvIGJlIGluc2VydGVkXG5cdCAgZ2V0SW5mbzogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLnhwYXRoKGRhdGEsIHRoaXMuY29uZmlnKTtcblx0ICAgIGlmIChjb25maWcubGVuZ3RoKSBjb25maWcgPSB0aGlzLmFzc2lnblR5cGVzKHRoaXMudGFnVG9PYmplY3QoY29uZmlnWzBdLCB7fSkpO2Vsc2UgY29uZmlnID0gbnVsbDtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHNpemU6IGRhdGEuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInRvdGFsX2NvdW50XCIpIHx8IDAsXG5cdCAgICAgIGZyb206IGRhdGEuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInBvc1wiKSxcblx0ICAgICAgcGFyZW50OiBkYXRhLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwYXJlbnRcIikgfHwgMCxcblx0ICAgICAgY29uZmlnOiBjb25maWcsXG5cdCAgICAgIGtleTogZGF0YS5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2ViaXhfc2VjdXJpdHlcIikgfHwgbnVsbFxuXHQgICAgfTtcblx0ICB9LFxuXHQgIC8veHBhdGggaGVscGVyXG5cdCAgeHBhdGg6IGZ1bmN0aW9uICh4bWwsIHBhdGgpIHtcblx0ICAgIGlmICh3aW5kb3cuWFBhdGhSZXN1bHQpIHtcblx0ICAgICAgLy9GRiwgS0hUTUwsIE9wZXJhXG5cdCAgICAgIHZhciBub2RlID0geG1sO1xuXHQgICAgICBpZiAoeG1sLm5vZGVOYW1lLmluZGV4T2YoXCJkb2N1bWVudFwiKSA9PSAtMSkgeG1sID0geG1sLm93bmVyRG9jdW1lbnQ7XG5cdCAgICAgIHZhciByZXMgPSBbXTtcblx0ICAgICAgdmFyIGNvbCA9IHhtbC5ldmFsdWF0ZShwYXRoLCBub2RlLCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG5cdCAgICAgIHZhciB0ZW1wID0gY29sLml0ZXJhdGVOZXh0KCk7XG5cblx0ICAgICAgd2hpbGUgKHRlbXApIHtcblx0ICAgICAgICByZXMucHVzaCh0ZW1wKTtcblx0ICAgICAgICB0ZW1wID0gY29sLml0ZXJhdGVOZXh0KCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIHRlc3QgPSB0cnVlO1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiB4bWwuc2VsZWN0Tm9kZXMgPT0gXCJ1bmRlZmluZWRcIikgdGVzdCA9IGZhbHNlO1xuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgICAvKklFNyBhbmQgYmVsb3cgY2FuJ3Qgb3BlcmF0ZSB3aXRoIHhtbCBvYmplY3QqL1xuXHQgICAgICAvL0lFXG5cblxuXHQgICAgICBpZiAodGVzdCkgcmV0dXJuIHhtbC5zZWxlY3ROb2RlcyhwYXRoKTtlbHNlIHtcblx0ICAgICAgICAvL3RoZXJlIGlzIG5vIGludGVyZmFjZSB0byBkbyBYUGF0aFxuXHQgICAgICAgIC8vdXNlIG5haXZlIGFwcHJvYWNoXG5cdCAgICAgICAgdmFyIG5hbWUgPSBwYXRoLnNwbGl0KFwiL1wiKS5wb3AoKTtcblx0ICAgICAgICByZXR1cm4geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBhc3NpZ25UeXBlczogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgZm9yICh2YXIgayBpbiBvYmopIHtcblx0ICAgICAgdmFyIHRlc3QgPSBvYmpba107XG5cdCAgICAgIGlmIChfdHlwZW9mKHRlc3QpID09IFwib2JqZWN0XCIpIHRoaXMuYXNzaWduVHlwZXModGVzdCk7ZWxzZSBpZiAodHlwZW9mIHRlc3QgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGlmICh0ZXN0ID09PSBcIlwiKSBjb250aW51ZTtcblx0ICAgICAgICBpZiAodGVzdCA9PSBcInRydWVcIikgb2JqW2tdID0gdHJ1ZTtlbHNlIGlmICh0ZXN0ID09IFwiZmFsc2VcIikgb2JqW2tdID0gZmFsc2U7ZWxzZSBpZiAodGVzdCA9PSB0ZXN0ICogMSkgb2JqW2tdID0gb2JqW2tdICogMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH0sXG5cdCAgLy9jb252ZXJ0IHhtbCB0YWcgdG8ganMgb2JqZWN0LCBhbGwgc3VidGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbWFwcGVkIHRvIHRoZSBwcm9wZXJ0aWVzIG9mIHJlc3VsdCBvYmplY3Rcblx0ICB0YWdUb09iamVjdDogZnVuY3Rpb24gKHRhZywgeikge1xuXHQgICAgdmFyIGlzQXJyYXkgPSB0YWcubm9kZVR5cGUgPT0gMSAmJiB0YWcuZ2V0QXR0cmlidXRlKFwic3RhY2tcIik7XG5cdCAgICB2YXIgaGFzU3ViVGFncyA9IDA7XG5cblx0ICAgIGlmICghaXNBcnJheSkge1xuXHQgICAgICB6ID0geiB8fCB7fTsgLy9tYXAgYXR0cmlidXRlc1xuXG5cdCAgICAgIHZhciBhID0gdGFnLmF0dHJpYnV0ZXM7XG5cdCAgICAgIGlmIChhICYmIGEubGVuZ3RoKSBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB6W2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuXHQgICAgICAgIGhhc1N1YlRhZ3MgPSAxO1xuXHQgICAgICB9IC8vbWFwIHN1YnRhZ3NcblxuXHQgICAgICB2YXIgYiA9IHRhZy5jaGlsZE5vZGVzO1xuXG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBiLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIGlmIChiW19pXS5ub2RlVHlwZSA9PSAxKSB7XG5cdCAgICAgICAgICB2YXIgbmFtZSA9IGJbX2ldLnRhZ05hbWU7XG5cblx0ICAgICAgICAgIGlmICh6W25hbWVdKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgeltuYW1lXS5wdXNoICE9IFwiZnVuY3Rpb25cIikgeltuYW1lXSA9IFt6W25hbWVdXTtcblx0ICAgICAgICAgICAgeltuYW1lXS5wdXNoKHRoaXMudGFnVG9PYmplY3QoYltfaV0sIHt9KSk7XG5cdCAgICAgICAgICB9IGVsc2UgeltuYW1lXSA9IHRoaXMudGFnVG9PYmplY3QoYltfaV0sIHt9KTsgLy9zdWItb2JqZWN0IGZvciBjb21wbGV4IHN1YnRhZ3NcblxuXG5cdCAgICAgICAgICBoYXNTdWJUYWdzID0gMjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWhhc1N1YlRhZ3MpIHJldHVybiB0aGlzLm5vZGVWYWx1ZSh0YWcpOyAvL2VhY2ggb2JqZWN0IHdpbGwgaGF2ZSBpdHMgdGV4dCBjb250ZW50IGFzIFwidmFsdWVcIiBwcm9wZXJ0eVxuXHQgICAgICAvL29ubHkgaWYgaGFzIG5vdCBzdWIgdGFnc1xuXG5cdCAgICAgIGlmIChoYXNTdWJUYWdzIDwgMikgei52YWx1ZSA9IHoudmFsdWUgfHwgdGhpcy5ub2RlVmFsdWUodGFnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHogPSBbXTtcblx0ICAgICAgdmFyIF9iID0gdGFnLmNoaWxkTm9kZXM7XG5cblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2IubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgIGlmIChfYltfaTJdLm5vZGVUeXBlID09IDEpIHoucHVzaCh0aGlzLnRhZ1RvT2JqZWN0KF9iW19pMl0sIHt9KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHo7XG5cdCAgfSxcblx0ICAvL2dldCB2YWx1ZSBvZiB4bWwgbm9kZSBcblx0ICBub2RlVmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICBpZiAobm9kZS5maXJzdENoaWxkKSB7XG5cdCAgICAgIHJldHVybiBub2RlLmZpcnN0Q2hpbGQud2hvbGVUZXh0IHx8IG5vZGUuZmlyc3RDaGlsZC5kYXRhO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gXCJcIjtcblx0ICB9LFxuXHQgIC8vY29udmVydCBYTUwgc3RyaW5nIHRvIFhNTCBvYmplY3Rcblx0ICBmcm9tU3RyaW5nOiBmdW5jdGlvbiAoeG1sU3RyaW5nKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBpZiAod2luZG93LkRPTVBhcnNlcikgLy8gRkYsIEtIVE1MLCBPcGVyYVxuXHQgICAgICAgIHJldHVybiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhtbFN0cmluZywgXCJ0ZXh0L3htbFwiKTtcblx0ICAgICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cblxuXHQgICAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcblx0ICAgICAgICAvLyBJRSwgdXRmLTggb25seSBcblx0ICAgICAgICB2YXIgdGVtcCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LnhtbERPTVwiKTtcblx0ICAgICAgICB0ZW1wLmxvYWRYTUwoeG1sU3RyaW5nKTtcblx0ICAgICAgICByZXR1cm4gdGVtcDtcblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBhc3NlcnQoMCwgZSk7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBhc3NlcnQoMCwgXCJMb2FkIGZyb20geG1sIHN0cmluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIganNvbiA9IHtcblx0ICAvL2NvbnZlcnQganNvbiBzdHJpbmcgdG8ganNvbiBvYmplY3QgaWYgbmVjZXNzYXJ5XG5cdCAgdG9PYmplY3Q6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGlmICh0aGlzLnBhcnNlRGF0ZXMpIHtcblx0ICAgICAgICAgIHZhciBpc29kYXRlID0gL1xcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KC5cXGR7MS0zfSk/Wi87XG5cdCAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICBpZiAoaXNvZGF0ZS50ZXN0KHZhbHVlKSkgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBsb2coZSk7XG5cdCAgICAgICAgbG9nKGRhdGEpO1xuXHQgICAgICAgIGFzc2VydCgwLCBcIkludmFsaWQgSlNPTiBkYXRhIGZvciBwYXJzaW5nXCIpO1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgLy9nZXQgYXJyYXkgb2YgcmVjb3Jkc1xuXHQgIGdldFJlY29yZHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEpIGRhdGEgPSBkYXRhLmRhdGE7XG5cdCAgICBpZiAoZGF0YSAmJiAhaXNBcnJheShkYXRhKSkgcmV0dXJuIFtkYXRhXTtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgLy9nZXQgaGFzaCBvZiBwcm9wZXJ0aWVzIGZvciBzaW5nbGUgcmVjb3JkXG5cdCAgZ2V0RGV0YWlsczogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKSByZXR1cm4ge1xuXHQgICAgICBpZDogZGF0YSB8fCB1aWQoKSxcblx0ICAgICAgdmFsdWU6IGRhdGFcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIGdldE9wdGlvbnM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICByZXR1cm4gZGF0YS5jb2xsZWN0aW9ucztcblx0ICB9LFxuXHQgIC8vZ2V0IGNvdW50IG9mIGRhdGEgYW5kIHBvc2l0aW9uIGF0IHdoaWNoIG5ldyBkYXRhIG5lZWQgdG8gYmUgaW5zZXJ0ZWRcblx0ICBnZXRJbmZvOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgc2l6ZTogZGF0YS50b3RhbF9jb3VudCB8fCAwLFxuXHQgICAgICBmcm9tOiBkYXRhLnBvcyxcblx0ICAgICAgcGFyZW50OiBkYXRhLnBhcmVudCB8fCAwLFxuXHQgICAgICBjb25maWc6IGRhdGEuY29uZmlnLFxuXHQgICAgICBrZXk6IGRhdGEud2ViaXhfc2VjdXJpdHlcblx0ICAgIH07XG5cdCAgfSxcblx0ICBjaGlsZDogXCJkYXRhXCIsXG5cdCAgcGFyc2VEYXRlczogZmFsc2Vcblx0fTtcblxuXHR2YXIgX3hocl9hYm9ydGVkID0gdG9BcnJheSgpO1xuXHRmdW5jdGlvbiBhamF4KHVybCwgcGFyYW1zLCBjYWxsKSB7XG5cdCAgLy9pZiBwYXJhbWV0ZXJzIHdhcyBwcm92aWRlZCAtIG1hZGUgZmFzdCBjYWxsXG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcblx0ICAgIHJldHVybiBuZXcgYWpheCgpLmdldCh1cmwsIHBhcmFtcywgY2FsbCk7XG5cdCAgfVxuXG5cdCAgaWYgKCF0aGlzIHx8ICF0aGlzLmdldFhIUikgcmV0dXJuIG5ldyBhamF4KCk7IC8vYWxsb3cgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGRpcmVjdCBuZXcgZGVjbGFyYXRpb25cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9XG5cdGFqYXguY291bnQgPSAwO1xuXHRhamF4LnByb3RvdHlwZSA9IHtcblx0ICBtYXN0ZXI6IG51bGwsXG5cdCAgLy9jcmVhdGVzIHhtbEhUVFAgb2JqZWN0XG5cdCAgZ2V0WEhSOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgfSxcblx0ICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHJldHVybiBzdHJpbmdpZnkob2JqKTtcblx0ICB9LFxuXG5cdCAgLypcblx0ICBcdHNlbmQgZGF0YSB0byB0aGUgc2VydmVyXG5cdCAgXHRwYXJhbXMgLSBoYXNoIG9mIHByb3BlcnRpZXMgd2hpY2ggd2lsbCBiZSBhZGRlZCB0byB0aGUgdXJsXG5cdCAgXHRjYWxsIC0gY2FsbGJhY2ssIGNhbiBiZSBhbiBvYmplY3Qgd2l0aCBzdWNjZXNzIGFuZCBlcnJvciBmdW5jdGlvbnNcblx0ICAqL1xuXHQgIF9zZW5kOiBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNhbGwsIG1vZGUpIHtcblx0ICAgIHZhciBtYXN0ZXI7IC8vd2ViaXguYWpheCh1cmwsIGNhbGxiYWNrKSAtIGNhbiBiZSBjYWxsZWQgb25seSBieSB1c2VyXG5cblx0ICAgIGlmIChwYXJhbXMgJiYgKGlzQXJyYXkocGFyYW1zKSB8fCB0eXBlb2YgKHBhcmFtcy5zdWNjZXNzIHx8IHBhcmFtcy5lcnJvciB8fCBwYXJhbXMpID09IFwiZnVuY3Rpb25cIikpIHtcblx0ICAgICAgbWFzdGVyID0gY2FsbDtcblx0ICAgICAgY2FsbCA9IHBhcmFtcztcblx0ICAgICAgcGFyYW1zID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRlZmVyID0gRGVmZXJyZWQuZGVmZXIoKTtcblx0ICAgIHZhciB4ID0gdGhpcy5nZXRYSFIoKTtcblx0ICAgIHZhciBoZWFkZXJzID0gdGhpcy5faGVhZGVyIHx8IHt9O1xuXHQgICAgaWYgKCFjYWxsRXZlbnQoXCJvbkJlZm9yZUFqYXhcIiwgW21vZGUsIHVybCwgcGFyYW1zLCB4LCBoZWFkZXJzLCBudWxsLCBkZWZlcl0pKSByZXR1cm47IC8vYWRkIGNvbnRlbnQtdHlwZSB0byBQT1NUfFBVVHxERUxFVEVcblxuXHQgICAgdmFyIGpzb25fbW9kZSA9IGZhbHNlO1xuXG5cdCAgICBpZiAobW9kZSAhPT0gXCJHRVRcIikge1xuXHQgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuXHQgICAgICAgIGlmIChrZXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09IFwiY29udGVudC10eXBlXCIpIHtcblx0ICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICAgIGlmIChoZWFkZXJzW2tleV0gPT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIGpzb25fbW9kZSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFmb3VuZCAmJiAhKHdpbmRvdy5Gb3JtRGF0YSAmJiBwYXJhbXMgaW5zdGFuY2VvZiB3aW5kb3cuRm9ybURhdGEpKSBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblx0ICAgIH0gLy9hZGQgZXh0cmEgcGFyYW1zIHRvIHRoZSB1cmxcblxuXG5cdCAgICBpZiAoX3R5cGVvZihwYXJhbXMpID09IFwib2JqZWN0XCIgJiYgISh3aW5kb3cuRm9ybURhdGEgJiYgcGFyYW1zIGluc3RhbmNlb2Ygd2luZG93LkZvcm1EYXRhKSkge1xuXHQgICAgICBpZiAoanNvbl9tb2RlKSBwYXJhbXMgPSB0aGlzLnN0cmluZ2lmeShwYXJhbXMpO2Vsc2Uge1xuXHQgICAgICAgIHZhciB0ID0gW107XG5cblx0ICAgICAgICBmb3IgKHZhciBhIGluIHBhcmFtcykge1xuXHQgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2FdO1xuXHQgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gXCJcIjtcblx0ICAgICAgICAgIGlmIChfdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIikgdmFsdWUgPSB0aGlzLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdCAgICAgICAgICB0LnB1c2goYSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7IC8vIHV0Zi04IGVzY2FwaW5nXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcGFyYW1zID0gdC5qb2luKFwiJlwiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocGFyYW1zICYmIG1vZGUgPT09IFwiR0VUXCIpIHtcblx0ICAgICAgdXJsID0gdXJsICsgKHVybC5pbmRleE9mKFwiP1wiKSAhPSAtMSA/IFwiJlwiIDogXCI/XCIpICsgcGFyYW1zO1xuXHQgICAgICBwYXJhbXMgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICB4Lm9wZW4obW9kZSwgdXJsLCAhdGhpcy5fc3luYyk7XG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuX3Jlc3BvbnNlO1xuXHQgICAgaWYgKHR5cGUpIHgucmVzcG9uc2VUeXBlID0gdHlwZTsgLy9pZiBoZWFkZXIgd2FzIHByb3ZpZGVkIC0gdXNlIGl0XG5cblx0ICAgIGZvciAodmFyIF9rZXkgaW4gaGVhZGVycykge1xuXHQgICAgICB4LnNldFJlcXVlc3RIZWFkZXIoX2tleSwgaGVhZGVyc1tfa2V5XSk7XG5cdCAgICB9IC8vYXN5bmMgbW9kZSwgZGVmaW5lIGxvYWRpbmcgY2FsbGJhY2tcblxuXG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICB0aGlzLm1hc3RlciA9IHRoaXMubWFzdGVyIHx8IG1hc3RlcjtcblxuXHQgICAgeC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICgheC5yZWFkeVN0YXRlIHx8IHgucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdCAgICAgICAgYWpheC5jb3VudCsrO1xuXG5cdCAgICAgICAgaWYgKCF4LmFib3J0ZWQpIHtcblx0ICAgICAgICAgIC8vSUU4IGFuZCBJRTksIGhhbmRsaW5nIC5hYm9ydCBjYWxsXG5cdCAgICAgICAgICBpZiAoX3hocl9hYm9ydGVkLmZpbmQoeCkgIT0gLTEpIHJldHVybiBfeGhyX2Fib3J0ZWQucmVtb3ZlKHgpO1xuXHQgICAgICAgICAgdmFyIGlzX2Vycm9yID0geC5zdGF0dXMgPj0gNDAwIHx8IHguc3RhdHVzID09PSAwO1xuXHQgICAgICAgICAgdmFyIHRleHQsIGRhdGE7XG5cblx0ICAgICAgICAgIGlmICh4LnJlc3BvbnNlVHlwZSA9PSBcImJsb2JcIiB8fCB4LnJlc3BvbnNlVHlwZSA9PSBcImFycmF5YnVmZmVyXCIpIHtcblx0ICAgICAgICAgICAgdGV4dCA9IFwiXCI7XG5cdCAgICAgICAgICAgIGRhdGEgPSB4LnJlc3BvbnNlO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0IHx8IFwiXCI7XG5cdCAgICAgICAgICAgIGRhdGEgPSBzZWxmLl9kYXRhKHgpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoaXNfZXJyb3IpIHtcblx0ICAgICAgICAgICAgY2FsbEV2ZW50KFwib25BamF4RXJyb3JcIiwgW3hdKTtcblx0ICAgICAgICAgICAgZGVmZXIucmVqZWN0KHgpO1xuXHQgICAgICAgICAgICBpZiAoY2FsbCkgYWpheC4kY2FsbGJhY2soc2VsZi5tYXN0ZXIgfHwgd2luZG93LCBjYWxsLCB0ZXh0LCBkYXRhLCB4LCBpc19lcnJvcik7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBkZWZlci5yZXNvbHZlKGRhdGEpO1xuXHQgICAgICAgICAgICBpZiAoY2FsbCkgYWpheC4kY2FsbGJhY2soc2VsZi5tYXN0ZXIgfHwgd2luZG93LCBjYWxsLCB0ZXh0LCBkYXRhLCB4LCBpc19lcnJvcik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vYW50aS1sZWFrXG5cdCAgICAgICAgICBzZWxmLm1hc3RlciA9IG51bGw7XG5cdCAgICAgICAgICBjYWxsID0gc2VsZiA9IG1hc3RlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBpZiAodGhpcy5fdGltZW91dCkgeC50aW1lb3V0ID0gdGhpcy5fdGltZW91dDsgLy9JRSBjYW4gdXNlIHN5bmMgbW9kZSBzb21ldGltZXMsIGZpeCBpdFxuXG5cdCAgICBpZiAoIXRoaXMuX3N5bmMpIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoIXguYWJvcnRlZCkge1xuXHQgICAgICAgIC8vYWJvcnQgaGFuZGxpbmcgaW4gSUU5XG5cdCAgICAgICAgaWYgKF94aHJfYWJvcnRlZC5maW5kKHgpICE9IC0xKSBfeGhyX2Fib3J0ZWQucmVtb3ZlKHgpO2Vsc2Uge1xuXHQgICAgICAgICAgeC5zZW5kKHBhcmFtcyB8fCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0sIDEpO2Vsc2UgeC5zZW5kKHBhcmFtcyB8fCBudWxsKTtcblxuXHQgICAgaWYgKHRoaXMubWFzdGVyICYmIHRoaXMubWFzdGVyLl9hamF4X3F1ZXVlICYmICF0aGlzLl9zeW5jKSB7XG5cdCAgICAgIHRoaXMubWFzdGVyLl9hamF4X3F1ZXVlLnB1c2goeCk7XG5cblx0ICAgICAgZGVmZXIudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHNlbGYubWFzdGVyLl9hamF4X3F1ZXVlLnJlbW92ZSh4KTsgLy9hbnRpLWxlYWtcblxuXG5cdCAgICAgICAgc2VsZi5tYXN0ZXIgPSBudWxsO1xuXHQgICAgICAgIGNhbGwgPSBzZWxmID0gbWFzdGVyID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl9zeW5jID8geCA6IGRlZmVyOyAvL3JldHVybiBYSFIsIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNhc2Ugb2Ygc3luYy4gbW9kZVxuXHQgIH0sXG5cdCAgX2RhdGE6IGZ1bmN0aW9uICh4KSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB4bWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgcmV0dXJuIHhtbC50YWdUb09iamVjdCh4bWwudG9PYmplY3QoeC5yZXNwb25zZVRleHQsIHRoaXMpKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICBsb2coeC5yZXNwb25zZVRleHQpO1xuXHQgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICBhc3NlcnQoMCwgXCJJbnZhbGlkIHhtbCBkYXRhIGZvciBwYXJzaW5nXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgcmF3eG1sOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF3aW5kb3cuWFBhdGhSZXN1bHQpIHJldHVybiB4bWwuZnJvbVN0cmluZyh4LnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgICAgcmV0dXJuIHgucmVzcG9uc2VYTUw7XG5cdCAgICAgIH0sXG5cdCAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4geC5yZXNwb25zZVRleHQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIGpzb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4ganNvbi50b09iamVjdCh4LnJlc3BvbnNlVGV4dCwgZmFsc2UpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgLy9HRVQgcmVxdWVzdFxuXHQgIGdldDogZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBjYWxsKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2VuZCh1cmwsIHBhcmFtcywgY2FsbCwgXCJHRVRcIik7XG5cdCAgfSxcblx0ICAvL1BPU1QgcmVxdWVzdFxuXHQgIHBvc3Q6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NlbmQodXJsLCBwYXJhbXMsIGNhbGwsIFwiUE9TVFwiKTtcblx0ICB9LFxuXHQgIC8vUFVUIHJlcXVlc3Rcblx0ICBwdXQ6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NlbmQodXJsLCBwYXJhbXMsIGNhbGwsIFwiUFVUXCIpO1xuXHQgIH0sXG5cdCAgLy9ERUxFVEUgcmVxdWVzdFxuXHQgIGRlbDogZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBjYWxsKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2VuZCh1cmwsIHBhcmFtcywgY2FsbCwgXCJERUxFVEVcIik7XG5cdCAgfSxcblx0ICAvL1BBVENIIHJlcXVlc3Rcblx0ICBwYXRjaDogZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBjYWxsKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2VuZCh1cmwsIHBhcmFtcywgY2FsbCwgXCJQQVRDSFwiKTtcblx0ICB9LFxuXHQgIHN5bmM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3N5bmMgPSB0cnVlO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfSxcblx0ICB0aW1lb3V0OiBmdW5jdGlvbiAobnVtKSB7XG5cdCAgICB0aGlzLl90aW1lb3V0ID0gbnVtO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfSxcblx0ICByZXNwb25zZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9yZXNwb25zZSA9IHZhbHVlO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfSxcblx0ICBoZWFkZXJzOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdCAgICB0aGlzLl9oZWFkZXIgPSBleHBvcnRzLmV4dGVuZCh0aGlzLl9oZWFkZXIgfHwge30sIGhlYWRlcik7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9LFxuXHQgIGJpbmQ6IGZ1bmN0aW9uIChtYXN0ZXIpIHtcblx0ICAgIHRoaXMubWFzdGVyID0gbWFzdGVyO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXHR9O1xuXG5cdGFqYXguJGNhbGxiYWNrID0gZnVuY3Rpb24gKG93bmVyLCBjYWxsLCB0ZXh0LCBkYXRhLCB4LCBpc19lcnJvcikge1xuXHQgIGlmIChvd25lci4kZGVzdHJ1Y3RlZCkgcmV0dXJuO1xuXHQgIGlmICh4ID09PSAtMSAmJiBkYXRhICYmIHR5cGVvZiBkYXRhLmpzb24gPT0gXCJmdW5jdGlvblwiKSBkYXRhID0gZGF0YS5qc29uKCk7XG5cdCAgaWYgKGlzX2Vycm9yKSBjYWxsRXZlbnQoXCJvbkFqYXhFcnJvclwiLCBbeF0pO1xuXG5cdCAgaWYgKGNhbGwpIHtcblx0ICAgIHZhciBtZXRob2QgPSBjYWxsLnN1Y2Nlc3MgfHwgY2FsbDtcblx0ICAgIGlmIChpc19lcnJvcikgbWV0aG9kID0gY2FsbC5lcnJvcjtcblx0ICAgIGlmIChtZXRob2QgJiYgbWV0aG9kLmNhbGwpIG1ldGhvZC5jYWxsKG93bmVyLCB0ZXh0LCBkYXRhLCB4KTtcblx0ICB9XG5cdH07XG5cblx0dmFyIENvZGVQYXJzZXIgPSB7XG5cdCAgLy9jb252ZXJ0cyBhIGNvbXBsZXggb2JqZWN0IGludG8gYW4gb2JqZWN0IHdpdGggcHJpbWl0aXZlcyBwcm9wZXJ0aWVzXG5cdCAgY29sbGFwc2VOYW1lczogZnVuY3Rpb24gKGJhc2UsIHByZWZpeCwgZGF0YSkge1xuXHQgICAgZGF0YSA9IGRhdGEgfHwge307XG5cdCAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJcIjtcblx0ICAgIGlmICghYmFzZSB8fCBfdHlwZW9mKGJhc2UpICE9IFwib2JqZWN0XCIpIHJldHVybiBudWxsO1xuXG5cdCAgICBmb3IgKHZhciBwcm9wIGluIGJhc2UpIHtcblx0ICAgICAgaWYgKGJhc2VbcHJvcF0gJiYgX3R5cGVvZihiYXNlW3Byb3BdKSA9PSBcIm9iamVjdFwiICYmICFpc0RhdGUoYmFzZVtwcm9wXSkgJiYgIWlzQXJyYXkoYmFzZVtwcm9wXSkpIHtcblx0ICAgICAgICBDb2RlUGFyc2VyLmNvbGxhcHNlTmFtZXMoYmFzZVtwcm9wXSwgcHJlZml4ICsgcHJvcCArIFwiLlwiLCBkYXRhKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkYXRhW3ByZWZpeCArIHByb3BdID0gYmFzZVtwcm9wXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIC8vY29udmVydHMgYW4gb2JqZWN0IHdpdGggcHJpbWl0aXZlIHByb3BlcnRpZXMgaW50byBhbiBvYmplY3Qgd2l0aCBjb21wbGV4IHByb3BlcnRpZXNcblx0ICBleHBhbmROYW1lczogZnVuY3Rpb24gKGJhc2UpIHtcblx0ICAgIHZhciBkYXRhID0ge30sXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBsYXN0SW5kZXgsXG5cdCAgICAgICAgbmFtZSxcblx0ICAgICAgICBvYmosXG5cdCAgICAgICAgcHJvcDtcblxuXHQgICAgZm9yIChwcm9wIGluIGJhc2UpIHtcblx0ICAgICAgbmFtZSA9IHByb3Auc3BsaXQoXCIuXCIpO1xuXHQgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XG5cdCAgICAgIG9iaiA9IGRhdGE7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKCFvYmpbbmFtZVtpXV0pIG9ialtuYW1lW2ldXSA9IHt9O1xuXHQgICAgICAgIG9iaiA9IG9ialtuYW1lW2ldXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG9ialtuYW1lW2xhc3RJbmRleF1dID0gYmFzZVtwcm9wXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdFx0VGVtcGxhdGUgLSBoYW5kbGVzIGh0bWwgdGVtcGxhdGVzXG5cdCovXG5cdHZhciBfY2FjaGUgPSB7fTtcblx0dmFyIF9jc3BfY2FjaGUgPSB7fTtcblx0dmFyIG5ld2xpbmVzID0gbmV3IFJlZ0V4cChcIihcXFxcclxcXFxufFxcXFxuKVwiLCBcImdcIik7XG5cdHZhciBxdW90ZXMgPSBuZXcgUmVnRXhwKFwiKFxcXFxcXFwiKVwiLCBcImdcIik7XG5cdHZhciBzbGFzaGVzID0gbmV3IFJlZ0V4cChcIihcXFxcXFxcXClcIiwgXCJnXCIpO1xuXHR2YXIgZXNjYXBlJDEgPSB7XG5cdCAgXCImXCI6IFwiJmFtcDtcIixcblx0ICBcIjxcIjogXCImbHQ7XCIsXG5cdCAgXCI+XCI6IFwiJmd0O1wiLFxuXHQgIFwiXFxcIlwiOiBcIiZxdW90O1wiLFxuXHQgIFwiJ1wiOiBcIiYjeDI3O1wiLFxuXHQgIFwiYFwiOiBcIiYjeDYwO1wiXG5cdH07XG5cdHZhciBiYWRDaGFycyA9IC9bJjw+XCInYF0vZztcblxuXHR2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uIChjaHIpIHtcblx0ICByZXR1cm4gZXNjYXBlJDFbY2hyXSB8fCBcIiZhbXA7XCI7XG5cdH07XG5cblx0ZnVuY3Rpb24gdGVtcGxhdGUoc3RyKSB7XG5cdCAgaWYgKHR5cGVvZiBzdHIgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gc3RyO1xuXHQgIGlmIChfY2FjaGVbc3RyXSkgcmV0dXJuIF9jYWNoZVtzdHJdO1xuXHQgIHN0ciA9IChzdHIgfHwgXCJcIikudG9TdHJpbmcoKTtcblxuXHQgIGlmIChzdHIuaW5kZXhPZihcIi0+XCIpICE9IC0xKSB7XG5cdCAgICB2YXIgdGVzdHN0ciA9IHN0ci5zcGxpdChcIi0+XCIpO1xuXG5cdCAgICBzd2l0Y2ggKHRlc3RzdHJbMF0pIHtcblx0ICAgICAgY2FzZSBcImh0bWxcIjpcblx0ICAgICAgICAvL2xvYWQgZnJvbSBzb21lIGNvbnRhaW5lciBvbiB0aGUgcGFnZVxuXHQgICAgICAgIHN0ciA9IGdldFZhbHVlKHRlc3RzdHJbMV0pO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgXCJodHRwXCI6XG5cdCAgICAgICAgLy9sb2FkIGZyb20gZXh0ZXJuYWwgZmlsZVxuXHQgICAgICAgIHN0ciA9IG5ldyBhamF4KCkuc3luYygpLmdldCh0ZXN0c3RyWzFdLCB7XG5cdCAgICAgICAgICB1aWQ6IHVpZCgpXG5cdCAgICAgICAgfSkucmVzcG9uc2VUZXh0O1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgLy9kbyBub3RoaW5nLCB3aWxsIHVzZSB0ZW1wbGF0ZSBhcyBpc1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH0gLy9zdXBwb3J0ZWQgaWRpb21zXG5cdCAgLy8ge29iai5hdHRyfSA9PiBuYW1lZCBhdHRyaWJ1dGUgb3IgdmFsdWUgb2Ygc3ViLXRhZyBpbiBjYXNlIG9mIHhtbFxuXG5cblx0ICBzdHIgPSAoc3RyIHx8IFwiXCIpLnRvU3RyaW5nKCk7IC8vIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGVuYWJsZWRcblxuXHQgIGlmIChlbnYuc3RyaWN0KSB7XG5cdCAgICBpZiAoIV9jc3BfY2FjaGVbc3RyXSkge1xuXHQgICAgICBfY3NwX2NhY2hlW3N0cl0gPSBbXTsgLy8gZ2V0IGFuIGFycmF5IG9mIG9iamVjdHMgKG5vdCBzb3J0ZWQgYnkgcG9zaXRpb24pXG5cblx0ICAgICAgdmFyIHRlbXBfcmVzID0gW107XG5cdCAgICAgIHN0ci5yZXBsYWNlKC9cXHtvYmpcXC4oW159P10rKVxcPyhbXjpdKik6KFtefV0qKVxcfS9nLCBmdW5jdGlvbiAoc2VhcmNoLCBzMSwgczIsIHMzLCBwb3MkJDEpIHtcblx0ICAgICAgICB0ZW1wX3Jlcy5wdXNoKHtcblx0ICAgICAgICAgIHBvczogcG9zJCQxLFxuXHQgICAgICAgICAgc3RyOiBzZWFyY2gsXG5cdCAgICAgICAgICBmbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gb2JqW3MxXSA/IHMyIDogczM7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBzdHIucmVwbGFjZSgvXFx7Y29tbW9uXFwuKFtefShdKilcXH0vZywgZnVuY3Rpb24gKHNlYXJjaCwgcywgcG9zJCQxKSB7XG5cdCAgICAgICAgdGVtcF9yZXMucHVzaCh7XG5cdCAgICAgICAgICBwb3M6IHBvcyQkMSxcblx0ICAgICAgICAgIHN0cjogc2VhcmNoLFxuXHQgICAgICAgICAgZm46IGZ1bmN0aW9uIChfLCBjb21tb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbW1vbltzXSB8fCBcIlwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgICAgc3RyLnJlcGxhY2UoL1xce2NvbW1vblxcLihbXn0oXSopXFwoXFwpXFx9L2csIGZ1bmN0aW9uIChzZWFyY2gsIHMsIHBvcyQkMSkge1xuXHQgICAgICAgIHRlbXBfcmVzLnB1c2goe1xuXHQgICAgICAgICAgcG9zOiBwb3MkJDEsXG5cdCAgICAgICAgICBzdHI6IHNlYXJjaCxcblx0ICAgICAgICAgIGZuOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbW1vbltzXSA/IGNvbW1vbltzXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogXCJcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHN0ci5yZXBsYWNlKC9cXHtvYmpcXC4oW146fV0qKVxcfS9nLCBmdW5jdGlvbiAoc2VhcmNoLCBzLCBwb3MkJDEpIHtcblx0ICAgICAgICB0ZW1wX3Jlcy5wdXNoKHtcblx0ICAgICAgICAgIHBvczogcG9zJCQxLFxuXHQgICAgICAgICAgc3RyOiBzZWFyY2gsXG5cdCAgICAgICAgICBmbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gb2JqW3NdO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgICAgc3RyLnJlcGxhY2UoXCJ7b2JqfVwiLCBmdW5jdGlvbiAoc2VhcmNoLCBwb3MkJDEpIHtcblx0ICAgICAgICB0ZW1wX3Jlcy5wdXNoKHtcblx0ICAgICAgICAgIHBvczogcG9zJCQxLFxuXHQgICAgICAgICAgc3RyOiBzZWFyY2gsXG5cdCAgICAgICAgICBmbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9KTtcblx0ICAgICAgc3RyLnJlcGxhY2UoLyMoW14jJ1wiOywgXSspIy9naSwgZnVuY3Rpb24gKHNlYXJjaCwgcywgcG9zJCQxKSB7XG5cdCAgICAgICAgaWYgKHMuY2hhckF0KDApID09IFwiIVwiKSB7XG5cdCAgICAgICAgICBzID0gcy5zdWJzdHIoMSk7XG5cdCAgICAgICAgICB0ZW1wX3Jlcy5wdXNoKHtcblx0ICAgICAgICAgICAgcG9zOiBwb3MkJDEsXG5cdCAgICAgICAgICAgIHN0cjogc2VhcmNoLFxuXHQgICAgICAgICAgICBmbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YoXCIuXCIpICE9IC0xKSBvYmogPSBDb2RlUGFyc2VyLmNvbGxhcHNlTmFtZXMob2JqKTsgLy8gYXBwbHkgY29tcGxleCBwcm9wZXJ0aWVzXG5cblx0ICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUuZXNjYXBlKG9ialtzXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0ZW1wX3Jlcy5wdXNoKHtcblx0ICAgICAgICAgICAgcG9zOiBwb3MkJDEsXG5cdCAgICAgICAgICAgIHN0cjogc2VhcmNoLFxuXHQgICAgICAgICAgICBmbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YoXCIuXCIpICE9IC0xKSBvYmogPSBDb2RlUGFyc2VyLmNvbGxhcHNlTmFtZXMob2JqKTsgLy8gYXBwbHkgY29tcGxleCBwcm9wZXJ0aWVzXG5cblx0ICAgICAgICAgICAgICByZXR1cm4gb2JqW3NdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pOyAvLyBzb3J0IHRlbXBsYXRlIHBhcnRzIGJ5IHBvc2l0aW9uXG5cblx0ICAgICAgdGVtcF9yZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhLnBvcyA+IGIucG9zID8gMSA6IC0xO1xuXHQgICAgICB9KTsgLy8gY3JlYXRlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBwYXJ0cyBvZiBodG1sIHN0cmluZ1xuXG5cdCAgICAgIGlmICh0ZW1wX3Jlcy5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgbGFzdFBvcyA9IDA7XG5cblx0ICAgICAgICB2YXIgYWRkU3RyID0gZnVuY3Rpb24gKHN0ciwgbjAsIG4xKSB7XG5cdCAgICAgICAgICBfY3NwX2NhY2hlW3N0cl0ucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UobjAsIG4xKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBfcmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgcG9zJCQxID0gdGVtcF9yZXNbaV0ucG9zO1xuXHQgICAgICAgICAgYWRkU3RyKHN0ciwgbGFzdFBvcywgcG9zJCQxKTtcblxuXHQgICAgICAgICAgX2NzcF9jYWNoZVtzdHJdLnB1c2godGVtcF9yZXNbaV0uZm4pO1xuXG5cdCAgICAgICAgICBsYXN0UG9zID0gcG9zJCQxICsgdGVtcF9yZXNbaV0uc3RyLmxlbmd0aDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBhZGRTdHIoc3RyLCBsYXN0UG9zLCBzdHIubGVuZ3RoKTtcblx0ICAgICAgfSBlbHNlIF9jc3BfY2FjaGVbc3RyXS5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gc3RyO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHMgPSBcIlwiO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NzcF9jYWNoZVtzdHJdLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcyArPSBfY3NwX2NhY2hlW3N0cl1baV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBzO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICB2YXIgaGVscGVycyA9IGZhbHNlO1xuXHQgIHN0ciA9IHN0ci5yZXBsYWNlKHNsYXNoZXMsIFwiXFxcXFxcXFxcIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UobmV3bGluZXMsIFwiXFxcXG5cIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UocXVvdGVzLCBcIlxcXFxcXFwiXCIpO1xuXHQgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHtvYmpcXC4oW159P10rKVxcPyhbXjpdKik6KFtefV0qKVxcfS9nLCBcIlxcXCIrKG9iai4kMT9cXFwiJDJcXFwiOlxcXCIkM1xcXCIpK1xcXCJcIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UoL1xce2NvbW1vblxcLihbXn0oXSopXFx9L2csIFwiXFxcIisoY29tbW9uLiQxfHwnJykrXFxcIlwiKTtcblx0ICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7Y29tbW9uXFwuKFtefShdKilcXChcXClcXH0vZywgXCJcXFwiKyhjb21tb24uJDE/Y29tbW9uLiQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk6XFxcIlxcXCIpK1xcXCJcIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UoL1xce29ialxcLihbXn1dKilcXH0vZywgXCJcXFwiKyhvYmouJDEpK1xcXCJcIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UoXCJ7b2JqfVwiLCBcIlxcXCIrb2JqK1xcXCJcIik7XG5cdCAgc3RyID0gc3RyLnJlcGxhY2UoLyMoW14jJ1wiOywgXSspIy9naSwgZnVuY3Rpb24gKHN0ciwga2V5KSB7XG5cdCAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PSBcIiFcIikge1xuXHQgICAgICBoZWxwZXJzID0gdHJ1ZTtcblx0ICAgICAgcmV0dXJuIFwiXFxcIit0ZW1wbGF0ZS5lc2NhcGUob2JqLlwiICsga2V5LnN1YnN0cigxKSArIFwiKStcXFwiXCI7XG5cdCAgICB9IGVsc2UgcmV0dXJuIFwiXFxcIisob2JqLlwiICsga2V5ICsgXCIpK1xcXCJcIjtcblx0ICB9KTtcblxuXHQgIHRyeSB7XG5cdCAgICBpZiAoaGVscGVycykge1xuXHQgICAgICB2YXIgdGVtcCA9IEZ1bmN0aW9uKFwib2JqXCIsIFwiY29tbW9uXCIsIFwibWFya3NcIiwgXCJ2YWx1ZVwiLCBcInRlbXBsYXRlXCIsIFwicmV0dXJuIFxcXCJcIiArIHN0ciArIFwiXFxcIjtcIik7XG5cblx0ICAgICAgX2NhY2hlW3N0cl0gPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuXHQgICAgICAgIHJldHVybiB0ZW1wKGEsIGIsIGMsIGQsIHRlbXBsYXRlKTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF9jYWNoZVtzdHJdID0gRnVuY3Rpb24oXCJvYmpcIiwgXCJjb21tb25cIiwgXCJyZXR1cm4gXFxcIlwiICsgc3RyICsgXCJcXFwiO1wiKTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICBhc3NlcnQoMCwgXCJJbnZhbGlkIHRlbXBsYXRlOlwiICsgc3RyKTtcblx0ICB9XG5cblx0ICByZXR1cm4gX2NhY2hlW3N0cl07XG5cdH1cblxuXHR0ZW1wbGF0ZS5lc2NhcGUgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkIHx8IHN0ciA9PT0gbnVsbCkgcmV0dXJuIFwiXCI7XG5cdCAgcmV0dXJuIChzdHIudG9TdHJpbmcoKSB8fCBcIlwiKS5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcblx0fTtcblxuXHR0ZW1wbGF0ZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gXCJcIjtcblx0fTtcblxuXHQvKlxuXHRcdGFkZHMgbmV3IHRlbXBsYXRlLXR5cGVcblx0XHRvYmogLSBvYmplY3QgdG8gd2hpY2ggdGVtcGxhdGUgd2lsbCBiZSBhZGRlZFxuXHRcdGRhdGEgLSBwcm9wZXJ0aWVzIG9mIHRlbXBsYXRlXG5cdCovXG5cblx0ZnVuY3Rpb24gdHlwZShvYmosIGRhdGEpIHtcblx0ICBpZiAob2JqLiRwcm90b1dhaXQpIHtcblx0ICAgIGlmICghb2JqLl93ZWJpeF90eXBlX3dhaXQpIG9iai5fd2ViaXhfdHlwZV93YWl0ID0gW107XG5cblx0ICAgIG9iai5fd2ViaXhfdHlwZV93YWl0LnB1c2goZGF0YSk7XG5cblx0ICAgIHJldHVybjtcblx0ICB9IC8vYXV0byBzd2l0Y2ggdG8gcHJvdG90eXBlLCBpZiBuYW1lIG9mIGNsYXNzIHdhcyBwcm92aWRlZFxuXG5cblx0ICBpZiAodHlwZW9mIG9iaiA9PSBcImZ1bmN0aW9uXCIpIG9iaiA9IG9iai5wcm90b3R5cGU7XG5cblx0ICBpZiAoIW9iai50eXBlcykge1xuXHQgICAgb2JqLnR5cGVzID0ge1xuXHQgICAgICBcImRlZmF1bHRcIjogb2JqLnR5cGVcblx0ICAgIH07XG5cdCAgICBvYmoudHlwZS5uYW1lID0gXCJkZWZhdWx0XCI7XG5cdCAgfVxuXG5cdCAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG5cdCAgdmFyIHR5cGUgPSBvYmoudHlwZTtcblx0ICBpZiAobmFtZSkgdHlwZSA9IG9iai50eXBlc1tuYW1lXSA9IGNsb25lKGRhdGEuYmFzZVR5cGUgPyBvYmoudHlwZXNbZGF0YS5iYXNlVHlwZV0gOiBvYmoudHlwZSk7XG5cblx0ICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHQgICAgaWYgKGtleS5pbmRleE9mKFwidGVtcGxhdGVcIikgPT09IDApIHR5cGVba2V5XSA9IHRlbXBsYXRlKGRhdGFba2V5XSk7ZWxzZSB0eXBlW2tleV0gPSBkYXRhW2tleV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5hbWU7XG5cdH1cblxuXHR2YXIgdmlld3MgPSB7fTtcblxuXHRmdW5jdGlvbiB1aShjb25maWcsIHBhcmVudCwgaWQpIHtcblx0ICB2YXIgcmVzO1xuXHQgIHN0YXRlLl91aV9jcmVhdGlvbisrOyAvLyBzYXZlIG9sZCB2YWx1ZSBvZiBnbG9iYWwgc2NvcGVcblxuXHQgIHZhciB0ZW1wID0gc3RhdGUuX2dsb2JhbF9zY29wZTsgLy8gc2V0IGdsb2JhbCBzY29wZSB0byB0aGUgc2NvcGUgb2YgbmV3IFVJIG9yIHRvIHByZXZpb3VzIHZhbHVlXG5cdCAgLy8gYXMgcmVzdWx0IGlubmVyIHdlYml4LnVpIGNhbGxzIHdpbGwgaGF2ZSBhY2Nlc3MgdGhlIHNjb3BlIG9mIG1hc3RlciB2aWV3XG5cdCAgLy8gbWFpbmx5IG5lY2Vzc2FyeSBmb3Igc3VnZ2VzdHNcblxuXHQgIHN0YXRlLl9nbG9iYWxfc2NvcGUgPSBjb25maWcuJHNjb3BlIHx8IHRlbXA7XG5cblx0ICB0cnkge1xuXHQgICAgcmVzID0gX3VpX2NyZWF0b3IoY29uZmlnLCBwYXJlbnQsIGlkKTtcblx0ICB9IGZpbmFsbHkge1xuXHQgICAgc3RhdGUuX3VpX2NyZWF0aW9uLS07IC8vIHJlc3RvcmUgZ2xvYmFsIHNjb3BlXG5cblx0ICAgIHN0YXRlLl9nbG9iYWxfc2NvcGUgPSB0ZW1wO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXM7XG5cdH1cblxuXHR1aS52aWV3cyA9IHZpZXdzO1xuXG5cdGZ1bmN0aW9uIF91aV9jcmVhdG9yKGNvbmZpZywgcGFyZW50LCBpZCkge1xuXHQgIHZhciBtdWx0aXNldCA9IGlzQXJyYXkoY29uZmlnKTtcblx0ICB2YXIgbm9kZSA9IHRvTm9kZShjb25maWcuY29udGFpbmVyIHx8IHBhcmVudCB8fCBkb2N1bWVudC5ib2R5KTsgLy8gc29sdmUgcHJvYmxlbSB3aXRoIG5vbi11bmlxdWUgaWRzXG5cblx0ICBpZiAobm9kZS5fc2V0dGluZ3MpIGlkID0gX2NvcnJlY3RJZChub2RlLCBtdWx0aXNldCwgaWQpO1xuXHQgIHZhciB0b3Bfbm9kZTtcblx0ICB2YXIgbW92aW5nID0gZmFsc2U7XG5cdCAgdmFyIGJvZHlfY2hpbGQgPSBub2RlID09IGRvY3VtZW50LmJvZHk7XG5cblx0ICBpZiAoY29uZmlnLl9zZXR0aW5ncyB8fCBub2RlICYmIG11bHRpc2V0KSB7XG5cdCAgICB0b3Bfbm9kZSA9IGNvbmZpZztcblx0ICAgIG1vdmluZyA9IHRydWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChub2RlICYmIGJvZHlfY2hpbGQpIGNvbmZpZy4kdG9wVmlldyA9IHRydWU7XG5cdCAgICBpZiAoIWNvbmZpZy5faW5uZXIpIGNvbmZpZy5faW5uZXIgPSB7fTtcblxuXHQgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuZ2V0UGFyZW50Vmlldykge1xuXHQgICAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSAhaWQgJiYgaWQgIT09IDAgPyBwYXJlbnQuZ2V0UGFyZW50VmlldygpIDogcGFyZW50O1xuXHQgICAgfVxuXG5cdCAgICB0b3Bfbm9kZSA9IF92aWV3KGNvbmZpZyk7XG5cdCAgfVxuXG5cdCAgaWYgKGJvZHlfY2hpbGQgJiYgIXRvcF9ub2RlLnNldFBvc2l0aW9uICYmICF0b3Bfbm9kZS4kYXBpT25seSkgdXNlKFwiX2ZpeEhlaWdodFwiKSgpO1xuXG5cdCAgaWYgKHRvcF9ub2RlLl9zZXR0aW5ncyAmJiB0b3Bfbm9kZS5fc2V0dGluZ3MuX2hpZGRlbiAmJiAhbm9kZS4kdmlldykge1xuXHQgICAgdG9wX25vZGUuX3NldHRpbmdzLl9jb250YWluZXIgPSBub2RlO1xuXHQgIH0gZWxzZSBpZiAoIXRvcF9ub2RlLiRhcGlPbmx5KSB7XG5cdCAgICBpZiAobm9kZS5hcHBlbmRDaGlsZCkgX2FwcGVuZERvbShub2RlLCB0b3Bfbm9kZSwgY29uZmlnKTtlbHNlIGlmIChub2RlLmRlc3RydWN0b3IpIHtcblx0ICAgICAgdmFyIHRhcmdldCA9IG5vZGU7IC8vYWRkVmlldyBvciB2aWV3IG1vdmluZyB3aXRoIHRhcmdldCBpZFxuXG5cdCAgICAgIGlmICghaWQgJiYgaWQgIT09IDAgJiYgIWlzQXJyYXkodG9wX25vZGUpKSB7XG5cdCAgICAgICAgaWQgPSBub2RlO1xuXHQgICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudFZpZXcoKTtcblx0ICAgICAgfSAvL2lmIHRhcmdldCBzdXBwb3J0cyB2aWV3IGFkZGluZ1xuXG5cblx0ICAgICAgaWYgKG5vZGUgJiYgbm9kZS5fcmVwbGFjZSkge1xuXHQgICAgICAgIGlmIChtb3ZpbmcgJiYgdG9wX25vZGUuZ2V0UGFyZW50Vmlldykge1xuXHQgICAgICAgICAgLy9pZiBzb3VyY2Ugc3VwcG9ydHMgdmlldyByZW1vdmluZ1xuXHQgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0b3Bfbm9kZS5nZXRQYXJlbnRWaWV3KCk7XG5cblx0ICAgICAgICAgIGlmIChfcGFyZW50ICYmIF9wYXJlbnQuX3JlbW92ZSkge1xuXHQgICAgICAgICAgICBfcGFyZW50Ll9yZW1vdmUodG9wX25vZGUpO1xuXHQgICAgICAgICAgfSAvL2FkanVzdCBwYXJlbnQgbGluayBhbmQgc2NvcGVcblxuXG5cdCAgICAgICAgICB0b3Bfbm9kZS5fcGFyZW50X2NlbGwgPSBub2RlO1xuXHQgICAgICAgICAgdG9wX25vZGUuJHNjb3BlID0gbm9kZS4kc2NvcGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbm9kZS5fcmVwbGFjZSh0b3Bfbm9kZSwgaWQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBfcGFyZW50MiA9IHRhcmdldC4kdmlldy5wYXJlbnROb2RlO1xuXHQgICAgICAgIHRhcmdldC5kZXN0cnVjdG9yKCk7XG5cblx0ICAgICAgICBfYXBwZW5kRG9tKF9wYXJlbnQyLCB0b3Bfbm9kZSwgY29uZmlnKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGFzc2VydCgwLCBcIk5vdCBleGlzdGluZyBwYXJlbnQ6XCIgKyBjb25maWcuY29udGFpbmVyKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdG9wX25vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBfYXBwZW5kRG9tKG5vZGUsIHRvcF9ub2RlLCBjb25maWcpIHtcblx0ICBub2RlLmFwcGVuZENoaWxkKHRvcF9ub2RlLl92aWV3b2JqKTtcblx0ICBpZiAodG9wX25vZGUuZ2V0UGFyZW50VmlldygpKSByZXR1cm47IC8vcmVzaXplIHdpbmRvdyB3aXRoIHBvc2l0aW9uIGNlbnRlciBvciB0b3Bcblx0ICAvL2RvIG5vdCByZXNpemUgb3RoZXIgd2luZG93cyBhbmQgZWxlbWVudHNcblx0ICAvLyB3aGljaCBhcmUgYXR0YWNoZWQgdG8gY3VzdG9tIGh0bWwgY29udGFpbmVyc1xuXG5cdCAgaWYgKCghdG9wX25vZGUuc2V0UG9zaXRpb24gfHwgdG9wX25vZGUuX3NldHRpbmdzLmZ1bGxzY3JlZW4pICYmIG5vZGUgPT0gZG9jdW1lbnQuYm9keSB8fCB0b3Bfbm9kZS5fc2V0dGluZ3MucG9zaXRpb24pIHN0YXRlLnRvcF92aWV3cy5wdXNoKHRvcF9ub2RlLl9kZXN0cnVjdG9yX2hhbmRsZXIpO1xuXHQgIGlmICghY29uZmlnLnNraXBSZXNpemUpIHRvcF9ub2RlLmFkanVzdCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2NvcnJlY3RJZCh0YXJnZXQsIG11bHRpc2V0LCBpZCkge1xuXHQgIC8vcmVwbGFjZSB2aWV3XG5cdCAgdmFyIHZpZXdzID0gW3RhcmdldF07IC8vcmVwbGFjZSBjb250ZW50IG9mIGxheW91dFxuXG5cdCAgaWYgKG11bHRpc2V0KSB2aWV3cyA9IHRhcmdldC5nZXRDaGlsZFZpZXdzKCk7IC8vcmVwbGFjZSBjb250ZW50IG9mIHdpbmRvd1xuXHQgIGVsc2UgaWYgKHRhcmdldC5fYm9keV9jZWxsKSB2aWV3cyA9IFt0YXJnZXQuX2JvZHlfY2VsbF07IC8vYWRkIGNlbGwgaW4gbGF5b3V0IGJ5IG51bWJlclxuXHQgICAgZWxzZSBpZiAodHlwZW9mIGlkID09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICByZXR1cm4gaWQ7IC8vcmVwbGFjZSBjZWxsIGluIGxheW91dCBieSBpZFxuXHQgICAgICB9IGVsc2UgaWYgKGlkKSB7XG5cdCAgICAgICAgdmlld3MgPSBbJCQoaWQpXTtcblxuXHQgICAgICAgIF9kZWxldGVJZHModmlld3MpO1xuXG5cdCAgICAgICAgcmV0dXJuIHZpZXdzWzBdLmNvbmZpZy5pZDtcblx0ICAgICAgfVxuXG5cdCAgX2RlbGV0ZUlkcyh2aWV3cyk7XG5cblx0ICByZXR1cm4gaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBfZGVsZXRlSWRzKHVpcykge1xuXHQgIGZvciAodmFyIGkgPSB1aXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgIHZhciBjdXJyZW50ID0gdWlzW2ldOyAvL3JlbW92ZSBvcmlnaW5hbCBpZFxuXG5cdCAgICBkZWxldGUgdmlld3NbY3VycmVudC5jb25maWcuaWRdOyAvL2NyZWF0ZSB0ZW1wIGlkXG5cblx0ICAgIGN1cnJlbnQuY29uZmlnLmlkID0gXCJ4XCIgKyB1aWQoKTtcblx0ICAgIHZpZXdzW2N1cnJlbnQuY29uZmlnLmlkXSA9IGN1cnJlbnQ7IC8vcHJvY2VzcyBjaGlsZHNcblxuXHQgICAgaWYgKGN1cnJlbnQuZ2V0Q2hpbGRWaWV3cykgX2RlbGV0ZUlkcyhjdXJyZW50LmdldENoaWxkVmlld3MoKSk7IC8vcHJvY2VzcyByZWxhdGVkIFVJXG5cblx0ICAgIGlmIChjdXJyZW50Ll9kZXN0cm95X3dpdGhfbWUpIF9kZWxldGVJZHMoY3VycmVudC5fZGVzdHJveV93aXRoX21lKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNNZXRob2QodmlldywgbWV0aG9kKSB7XG5cdCAgdmFyIG9iaiA9IHVpW3ZpZXddO1xuXHQgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cdCAgaWYgKG9iai4kcHJvdG9XYWl0KSBvYmogPSBvYmouY2FsbCgtMSk7XG5cdCAgcmV0dXJuICEhdWlbdmlld10ucHJvdG90eXBlW21ldGhvZF07XG5cdH1cblxuXHRmdW5jdGlvbiBfdmlldyhjb25maWcpIHtcblx0ICB7XG5cdCAgICAvLyBjaGVjayBmb3IgdHJhaWxpbmcgY29tbWFcblx0ICAgIHZhciBjb2xsID0gY29uZmlnLmNlbGxzIHx8IGNvbmZpZy5yb3dzIHx8IGNvbmZpZy5lbGVtZW50cyB8fCBjb25maWcuY29scztcblx0ICAgIGlmIChjb2xsKSBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGwubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGNvbGxbaV0gPT09IG51bGwgfHwgdHlwZW9mIGNvbGxbaV0gPT09IFwidW5kZWZpbmVkXCIpIGFzc2VydCgwLCBcIllvdSBoYXZlIHRyYWlsaW5nIGNvbW1hIG9yIE51bGwgZWxlbWVudCBpbiBjb2xsZWN0aW9uJ3MgY29uZmlndXJhdGlvblwiKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoY29uZmlnLnZpZXcpIHtcblx0ICAgIHZhciB2aWV3ID0gY29uZmlnLnZpZXc7XG5cdCAgICBhc3NlcnQodWlbdmlld10sIFwidW5rbm93biB2aWV3OlwiICsgdmlldyk7XG5cdCAgICByZXR1cm4gbmV3IHVpW3ZpZXddKGNvbmZpZyk7XG5cdCAgfSBlbHNlIGlmIChjb25maWcucm93cyB8fCBjb25maWcuY29scykge1xuXHQgICAgdmFyIGNlbGxzID0gY29uZmlnLnJvd3MgfHwgY29uZmlnLmNvbHM7XG5cdCAgICB2YXIgYWNjb3JkaW9uID0gZmFsc2U7XG5cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjZWxscy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgaWYgKGNlbGxzW19pXS5ib2R5ICYmICFjZWxsc1tfaV0udmlldyAmJiAhY2VsbHNbX2ldLmFsaWduKSBhY2NvcmRpb24gPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYWNjb3JkaW9uKSB7XG5cdCAgICAgIHJldHVybiBuZXcgdWkuaGVhZGVybGF5b3V0KGNvbmZpZyk7XG5cdCAgICB9IGVsc2UgcmV0dXJuIG5ldyB1aS5sYXlvdXQoY29uZmlnKTtcblx0ICB9IGVsc2UgaWYgKGNvbmZpZy5jZWxscykgcmV0dXJuIG5ldyB1aS5tdWx0aXZpZXcoY29uZmlnKTtlbHNlIGlmIChjb25maWcudGVtcGxhdGUgfHwgY29uZmlnLmNvbnRlbnQpIHJldHVybiBuZXcgdWkudGVtcGxhdGUoY29uZmlnKTtlbHNlIGlmIChjb25maWcuYWxpZ24gJiYgY29uZmlnLmJvZHkpIHtcblx0ICAgIHJldHVybiBuZXcgdWkuYWxpZ24oY29uZmlnKTtcblx0ICB9IGVsc2UgcmV0dXJuIG5ldyB1aS5zcGFjZXIoY29uZmlnKTtcblx0fSAvL0ZJWE1FXG5cblxuXHR1aS5fdmlldyA9IF92aWV3O1xuXG5cdGZ1bmN0aW9uICQkKGlkKSB7XG5cdCAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XG5cdCAgaWYgKHZpZXdzW2lkXSkgcmV0dXJuIHZpZXdzW2lkXTtcblx0ICB2YXIgbmFtZSA9IGlkO1xuXG5cdCAgaWYgKF90eXBlb2YoaWQpID09IFwib2JqZWN0XCIpIHtcblx0ICAgIGlmIChpZC5fc2V0dGluZ3MpIHJldHVybiBpZDtcblx0ICAgIG5hbWUgPSBpZC50YXJnZXQgfHwgaWQuc3JjRWxlbWVudCB8fCBpZDtcblx0ICB9XG5cblx0ICByZXR1cm4gdmlld3NbbG9jYXRlKHtcblx0ICAgIHRhcmdldDogdG9Ob2RlKG5hbWUpXG5cdCAgfSwgXCJ2aWV3X2lkXCIpXTtcblx0fVxuXG5cdGlmICh0eXBlb2Ygd2luZG93LiQkID09PSBcInVuZGVmaW5lZFwiKSB3aW5kb3cuJCQgPSAkJDtcblxuXHRleHBvcnRzLnByb3RvVUkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIG9yaWdpbnMgPSBhcmd1bWVudHM7XG5cdCAgdmFyIHNlbGZuYW1lID0gb3JpZ2luc1swXS5uYW1lO1xuXG5cdCAgdmFyIHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKCF0KSByZXR1cm4gdWlbc2VsZm5hbWVdLnByb3RvdHlwZTtcblx0ICAgIHZhciBvcmlnaW5zID0gdC4kcHJvdG9XYWl0O1xuXG5cdCAgICBpZiAob3JpZ2lucykge1xuXHQgICAgICB2YXIgcGFyYW1zID0gW29yaWdpbnNbMF1dO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb3JpZ2lucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHBhcmFtc1tpXSA9IG9yaWdpbnNbaV07XG5cdCAgICAgICAgaWYgKHBhcmFtc1tpXS4kcHJvdG9XYWl0KSBwYXJhbXNbaV0gPSBwYXJhbXNbaV0uY2FsbCgtMSwgcGFyYW1zW2ldLm5hbWUpO1xuXHQgICAgICAgIGlmIChwYXJhbXNbaV0ucHJvdG90eXBlICYmIHBhcmFtc1tpXS5wcm90b3R5cGUubmFtZSkgdWlbcGFyYW1zW2ldLnByb3RvdHlwZS5uYW1lXSA9IHBhcmFtc1tpXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHVpW3NlbGZuYW1lXSA9IGV4cG9ydHMucHJvdG8uYXBwbHkoLTEsIHBhcmFtcyk7XG5cdCAgICAgIGlmICh0Ll93ZWJpeF90eXBlX3dhaXQpIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHQuX3dlYml4X3R5cGVfd2FpdC5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgdHlwZSh1aVtzZWxmbmFtZV0sIHQuX3dlYml4X3R5cGVfd2FpdFtfaTJdKTtcblx0ICAgICAgfVxuXHQgICAgICB0ID0gb3JpZ2lucyA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzICE9IC0xKSByZXR1cm4gbmV3IHVpW3NlbGZuYW1lXShkYXRhKTtlbHNlIHJldHVybiB1aVtzZWxmbmFtZV07XG5cdCAgfTtcblxuXHQgIHQuJHByb3RvV2FpdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdCAgcmV0dXJuIHVpW3NlbGZuYW1lXSA9IHQ7XG5cdH07XG5cblx0ZXhwb3J0cy5wcm90byA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgb3JpZ2lucyA9IGFyZ3VtZW50cztcblx0ICB2YXIgY29tcGlsYXRpb24gPSBvcmlnaW5zWzBdO1xuXHQgIHZhciBoYXNfY29uc3RydWN0b3IgPSAhIWNvbXBpbGF0aW9uLiRpbml0O1xuXHQgIHZhciBjb25zdHJ1Y3QgPSBbXTtcblx0ICBhc3NlcnQoY29tcGlsYXRpb24sIFwiSW52YWxpZCBtaXhpbmcgdGFyZ2V0XCIpO1xuXG5cdCAgZm9yICh2YXIgaSA9IG9yaWdpbnMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuXHQgICAgYXNzZXJ0KG9yaWdpbnNbaV0sIFwiSW52YWxpZCBtaXhpbmcgc291cmNlXCIpO1xuXHQgICAgaWYgKHR5cGVvZiBvcmlnaW5zW2ldID09IFwiZnVuY3Rpb25cIikgb3JpZ2luc1tpXSA9IG9yaWdpbnNbaV0ucHJvdG90eXBlO1xuXHQgICAgaWYgKG9yaWdpbnNbaV0uJGluaXQpIGNvbnN0cnVjdC5wdXNoKG9yaWdpbnNbaV0uJGluaXQpO1xuXG5cdCAgICBpZiAob3JpZ2luc1tpXS5kZWZhdWx0cykge1xuXHQgICAgICB2YXIgZGVmYXVsdHMgPSBvcmlnaW5zW2ldLmRlZmF1bHRzO1xuXHQgICAgICBpZiAoIWNvbXBpbGF0aW9uLmRlZmF1bHRzKSBjb21waWxhdGlvbi5kZWZhdWx0cyA9IHt9O1xuXG5cdCAgICAgIGZvciAodmFyIGRlZiBpbiBkZWZhdWx0cykge1xuXHQgICAgICAgIGlmIChpc1VuZGVmaW5lZChjb21waWxhdGlvbi5kZWZhdWx0c1tkZWZdKSkgY29tcGlsYXRpb24uZGVmYXVsdHNbZGVmXSA9IGRlZmF1bHRzW2RlZl07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKG9yaWdpbnNbaV0udHlwZSAmJiBjb21waWxhdGlvbi50eXBlKSB7XG5cdCAgICAgIGZvciAodmFyIF9kZWYgaW4gb3JpZ2luc1tpXS50eXBlKSB7XG5cdCAgICAgICAgaWYgKCFjb21waWxhdGlvbi50eXBlW19kZWZdKSBjb21waWxhdGlvbi50eXBlW19kZWZdID0gb3JpZ2luc1tpXS50eXBlW19kZWZdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBvcmlnaW5zW2ldKSB7XG5cdCAgICAgIGlmICghY29tcGlsYXRpb25ba2V5XSAmJiBjb21waWxhdGlvbltrZXldICE9PSBmYWxzZSkgY29tcGlsYXRpb25ba2V5XSA9IG9yaWdpbnNbaV1ba2V5XTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoaGFzX2NvbnN0cnVjdG9yKSBjb25zdHJ1Y3QucHVzaChjb21waWxhdGlvbi4kaW5pdCk7XG5cblx0ICBjb21waWxhdGlvbi4kaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RydWN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGNvbnN0cnVjdFtpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBpZiAoY29tcGlsYXRpb24uJHNraW4pIGNvbXBpbGF0aW9uLiRza2luKCk7XG5cblx0ICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy4kcmVhZHkgPSBbXTtcblx0ICAgIGFzc2VydCh0aGlzLiRpbml0LCBcIm9iamVjdCB3aXRob3V0IGluaXQgbWV0aG9kXCIpO1xuXHQgICAgdGhpcy4kaW5pdChjb25maWcpO1xuXHQgICAgaWYgKHRoaXMuX3BhcnNlU2V0dGluZ3MpIHRoaXMuX3BhcnNlU2V0dGluZ3MoY29uZmlnLCB0aGlzLmRlZmF1bHRzKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLiRyZWFkeS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLiRyZWFkeVtpXS5jYWxsKHRoaXMpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXN1bHQucHJvdG90eXBlID0gY29tcGlsYXRpb247XG5cdCAgY29tcGlsYXRpb24gPSBvcmlnaW5zID0gbnVsbDtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGF0dGFjaEV2ZW50KFwib25DbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuXHQgIHZhciBlbGVtZW50ID0gJCQoZSk7XG5cblx0ICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRvdWNoYWJsZSkge1xuXHQgICAgdXNlKFwiVUlNYW5hZ2VyXCIpLmFwcGx5Q2hhbmdlcyhlbGVtZW50KTsgLy9mb3IgaW5saW5lIGVsZW1lbnRzIC0gcmVzdG9yZSBwb2ludGVyIHRvIHRoZSBtYXN0ZXIgZWxlbWVudFxuXG5cdCAgICBlbGVtZW50LmdldE5vZGUoZSk7IC8vcmVhY3Rpb24gb24gY3VzdG9tIGNzcyBlbGVtZW50cyBpbiBidXR0b25zXG5cblx0ICAgIHZhciB0cmcgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cdCAgICBpZiAodHJnLmNsYXNzTmFtZSA9PSBcIndlYml4X2Rpc2FibGVkXCIpIHJldHVybjtcblx0ICAgIHZhciBjc3MgPSBcIlwiO1xuXHQgICAgaWYgKHRyZy5jbGFzc05hbWUgJiYgdHJnLmNsYXNzTmFtZS50b1N0cmluZygpLmluZGV4T2YoXCJ3ZWJpeF92aWV3XCIpID09PSAwKSByZXR1cm47XG5cdCAgICBpZiAoZWxlbWVudCkgdXNlKFwiVUlNYW5hZ2VyXCIpLl9mb2N1c19hY3Rpb24oZWxlbWVudCk7IC8vbG9vcCB0aHJvdWdoIGFsbCBwYXJlbnRzXG5cblx0ICAgIHdoaWxlICh0cmcgJiYgdHJnLnBhcmVudE5vZGUpIHtcblx0ICAgICAgaWYgKHRyZy5nZXRBdHRyaWJ1dGUpIHtcblx0ICAgICAgICBpZiAodHJnLmdldEF0dHJpYnV0ZShcInZpZXdfaWRcIikpIGJyZWFrO1xuXHQgICAgICAgIGNzcyA9IHRyZy5jbGFzc05hbWU7XG5cblx0ICAgICAgICBpZiAoY3NzKSB7XG5cdCAgICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKS5zcGxpdChcIiBcIik7XG5cblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50Lm9uX2NsaWNrW2Nzc1tpXV0pIHtcblx0ICAgICAgICAgICAgICB2YXIgcmVzID0gZWxlbWVudC5vbl9jbGlja1tjc3NbaV1dLmNhbGwoZWxlbWVudCwgZSwgZWxlbWVudC5fc2V0dGluZ3MuaWQsIHRyZyk7XG5cdCAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRyZyA9IHRyZy5wYXJlbnROb2RlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZWxlbWVudC5fc2V0dGluZ3MuY2xpY2spIHtcblx0ICAgICAgdmFyIGNvZGUgPSB0b0Z1bmN0b3IoZWxlbWVudC5fc2V0dGluZ3MuY2xpY2ssIGVsZW1lbnQuJHNjb3BlKTtcblx0ICAgICAgaWYgKGNvZGUgJiYgY29kZS5jYWxsKSBjb2RlLmNhbGwoZWxlbWVudCwgZWxlbWVudC5fc2V0dGluZ3MuaWQsIGUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcG9wdXAgPSBlbGVtZW50Ll9zZXR0aW5ncy5wb3B1cDtcblxuXHQgICAgaWYgKGVsZW1lbnQuX3NldHRpbmdzLnBvcHVwICYmICFlbGVtZW50Ll9zZXR0aW5ncy5yZWFkb25seSkge1xuXHQgICAgICBpZiAoX3R5cGVvZihwb3B1cCkgPT0gXCJvYmplY3RcIiAmJiAhcG9wdXAubmFtZSkgcG9wdXAgPSBlbGVtZW50Ll9zZXR0aW5ncy5wb3B1cCA9IHVpKHBvcHVwKS5fc2V0dGluZ3MuaWQ7XG5cdCAgICAgIHBvcHVwID0gJCQocG9wdXApO1xuXHQgICAgICBhc3NlcnQocG9wdXAsIFwiVW5rbm93biBwb3B1cFwiKTtcblxuXHQgICAgICBpZiAoIXBvcHVwLmlzVmlzaWJsZSgpKSB7XG5cdCAgICAgICAgcG9wdXAuX3NldHRpbmdzLm1hc3RlciA9IGVsZW1lbnQuX3NldHRpbmdzLmlkO1xuXHQgICAgICAgIHBvcHVwLnNob3coZWxlbWVudC5nZXRJbnB1dE5vZGUoKSB8fCBlbGVtZW50LmdldE5vZGUoKSwgbnVsbCwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZWxlbWVudC5jYWxsRXZlbnQoXCJvbkl0ZW1DbGlja1wiLCBbZWxlbWVudC5fc2V0dGluZ3MuaWQsIGVdKTtcblx0ICB9XG5cdH0pOyAvL2hvb2sgZm9yIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yXG5cblx0e1xuXHQgIGlmICh3aW5kb3cud2ViaXhfb25fY29yZV9yZWFkeSkge1xuXHQgICAgdmFyIG1vZCA9IHdpbmRvdy53ZWJpeF9vbl9jb3JlX3JlYWR5KHtcblx0ICAgICAgcHJvdG86IGV4cG9ydHMucHJvdG8sXG5cdCAgICAgIHByb3RvVUk6IGV4cG9ydHMucHJvdG9VSVxuXHQgICAgfSk7XG5cdCAgICBleHBvcnRzLnByb3RvID0gbW9kLnByb3RvO1xuXHQgICAgZXhwb3J0cy5wcm90b1VJID0gbW9kLnByb3RvVUk7XG5cdCAgfVxuXHR9XG5cblx0dmFyIF9ldmVudHMgPSB7fTtcblx0ZnVuY3Rpb24gX2V2ZW50c19maW5hbF9kZXN0cnVjdG9yKCkge1xuXHQgIC8vZGV0YWNoIGFsbCBrbm93biBET00gZXZlbnRzXG5cdCAgZm9yICh2YXIgYSBpbiBfZXZlbnRzKSB7XG5cdCAgICBldmVudFJlbW92ZShhKTtcblx0ICB9XG5cdH0gLy9wcml2YXRlIHZlcnNpb24gb2YgQVBJLCBkbyBub3QgcmVnaXN0ZXIgSUQgZm9yIGV2ZW50IGRldGFjaGluZ1xuXG5cdGZ1bmN0aW9uIF9ldmVudChhLCBiLCBjLCBkKSB7XG5cdCAgZCA9IGQgfHwge307XG5cdCAgZC5pbm5lciA9IHRydWU7XG5cdCAgZXZlbnQkMShhLCBiLCBjLCBkKTtcblx0fSAvL2F0dGFjaCBldmVudCB0byB0aGUgRE9NIGVsZW1lbnRcblxuXHRmdW5jdGlvbiBldmVudCQxKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBjb250ZXh0KSB7XG5cdCAgY29udGV4dCA9IGNvbnRleHQgfHwge307XG5cdCAgbm9kZSA9IHRvTm9kZShub2RlKTtcblx0ICBhc3NlcnQobm9kZSwgXCJJbnZhbGlkIG5vZGUgYXMgdGFyZ2V0IGZvciB3ZWJpeC5ldmVudFwiKTtcblx0ICB2YXIgaWQgPSBjb250ZXh0LmlkIHx8IHVpZCgpO1xuXHQgIGlmIChjb250ZXh0LmJpbmQpIGhhbmRsZXIgPSBiaW5kKGhhbmRsZXIsIGNvbnRleHQuYmluZCk7XG5cdCAgdmFyIGluZm8gPSBbbm9kZSwgZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQuY2FwdHVyZV07XG5cdCAgaWYgKCFjb250ZXh0LmlubmVyKSBfZXZlbnRzW2lkXSA9IGluZm87IC8vc3RvcmUgZXZlbnQgaW5mbywgZm9yIGRldGFjaGluZ1xuXG5cdCAgdmFyIGNhcHR1cmUgPSAhIWNvbnRleHQuY2FwdHVyZTtcblx0ICBpZiAoIWlzVW5kZWZpbmVkKGNvbnRleHQucGFzc2l2ZSkgJiYgZW52LnBhc3NpdmVFdmVudExpc3RlbmVycykgLy9ibG9ja2FibGUgdG91Y2ggZXZlbnRzXG5cdCAgICBjYXB0dXJlID0ge1xuXHQgICAgICBwYXNzaXZlOiBjb250ZXh0LnBhc3NpdmUsXG5cdCAgICAgIGNhcHR1cmU6IGNhcHR1cmVcblx0ICAgIH07IC8vdXNlIElFJ3Mgb2YgRkYncyB3YXkgb2YgZXZlbnQncyBhdHRhY2hpbmdcblxuXHQgIGlmIChub2RlLmFkZEV2ZW50TGlzdGVuZXIpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSk7ZWxzZSBpZiAobm9kZS5hdHRhY2hFdmVudCkgbm9kZS5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgaW5mb1syXSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBoYW5kbGVyLmFwcGx5KG5vZGUsIGFyZ3VtZW50cyk7IC8vSUU4IGZpeFxuXHQgIH0pO1xuXHQgIHJldHVybiBpZDsgLy9yZXR1cm4gaWQgb2YgbmV3bHkgY3JlYXRlZCBldmVudCwgY2FuIGJlIHVzZWQgaW4gZXZlbnRSZW1vdmVcblx0fSAvL3JlbW92ZSBwcmV2aW91c2x5IGF0dGFjaGVkIGV2ZW50XG5cblx0ZnVuY3Rpb24gZXZlbnRSZW1vdmUoaWQpIHtcblx0ICBpZiAoIWlkKSByZXR1cm47XG5cdCAgYXNzZXJ0KF9ldmVudHNbaWRdLCBcIlJlbW92aW5nIG5vbi1leGlzdGluZyBldmVudFwiKTtcblx0ICB2YXIgZXYgPSBfZXZlbnRzW2lkXTsgLy9icm93c2VyIHNwZWNpZmljIGV2ZW50IHJlbW92aW5nXG5cblx0ICBpZiAoZXZbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikgZXZbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldlsxXSwgZXZbMl0sICEhZXZbM10pO2Vsc2UgaWYgKGV2WzBdLmRldGFjaEV2ZW50KSBldlswXS5kZXRhY2hFdmVudChcIm9uXCIgKyBldlsxXSwgZXZbMl0pO1xuXHQgIGRlbGV0ZSBfZXZlbnRzW2lkXTsgLy9kZWxldGUgYWxsIHRyYWNlc1xuXHR9XG5cblx0dmFyIEFjdGl2ZUNvbnRlbnQgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcuYWN0aXZlQ29udGVudCkge1xuXHQgICAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX2luaXRfYWN0aXZlX2NvbnRlbnRfbGlzdCk7XG5cdCAgICAgIHRoaXMuX2FjdGl2ZV9ob2xkZXJzID0ge307XG5cdCAgICAgIHRoaXMuX2FjdGl2ZV9ob2xkZXJzX2l0ZW0gPSB7fTtcblx0ICAgICAgdGhpcy5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzID0ge307XG5cdCAgICAgIHRoaXMuX2FjdGl2ZV9yZWZlcmVuY2VzID0ge307XG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIGNvbmZpZy5hY3RpdmVDb250ZW50KSB7XG5cdCAgICAgICAgdGhpc1trZXldID0gdGhpcy5fYmluZF9hY3RpdmVfY29udGVudChrZXkpO1xuXG5cdCAgICAgICAgaWYgKGNvbmZpZy5hY3RpdmVDb250ZW50W2tleV0uZWFybHlJbml0KSB7XG5cdCAgICAgICAgICB2YXIgdGVtcCA9IHN0YXRlLl9wYXJlbnRfY2VsbDtcblx0ICAgICAgICAgIHN0YXRlLl9wYXJlbnRfY2VsbCA9IG51bGw7XG5cdCAgICAgICAgICB0aGlzW2tleV0uY2FsbCh0aGlzLCB7fSwgdGhpcywgY29uZmlnLmFjdGl2ZUNvbnRlbnQpO1xuXHQgICAgICAgICAgc3RhdGUuX3BhcmVudF9jZWxsID0gdGVtcDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9kZXN0cnVjdEFjdGl2ZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9hY3RpdmVfcmVmZXJlbmNlcykge1xuXHQgICAgICB2YXIgZWxlbSA9IHRoaXMuX2FjdGl2ZV9yZWZlcmVuY2VzW2tleV07XG5cdCAgICAgIGlmIChlbGVtLmRlc3RydWN0b3IpIGVsZW0uZGVzdHJ1Y3RvcigpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2luaXRfYWN0aXZlX2NvbnRlbnRfbGlzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uRGVzdHJ1Y3RcIiwgYmluZCh0aGlzLl9kZXN0cnVjdEFjdGl2ZUNvbnRlbnQsIHRoaXMpKTtcblxuXHQgICAgX2V2ZW50KHRoaXMuJHZpZXcsIFwiYmx1clwiLCBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldCB8fCBldi5zcmNFbGVtZW50OyAvLyBmb3IgaW5wdXRzIG9ubHlcblxuXHQgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgIT0gXCJCVVRUT05cIikge1xuXHQgICAgICAgIHZhciBlbCA9ICQkKGV2KTtcblxuXHQgICAgICAgIGlmIChlbCAmJiBlbCAhPT0gdGhpcyAmJiBlbC5nZXRWYWx1ZSAmJiBlbC5zZXRWYWx1ZSkge1xuXHQgICAgICAgICAgZWwuZ2V0Tm9kZShldik7XG5cdCAgICAgICAgICB2YXIgbmV3dmFsdWUgPSBlbC5nZXRWYWx1ZSgpO1xuXHQgICAgICAgICAgaWYgKG5ld3ZhbHVlICE9IGVsLl9zZXR0aW5ncy52YWx1ZSkgZWwuc2V0VmFsdWUobmV3dmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICBiaW5kOiB0aGlzLFxuXHQgICAgICBjYXB0dXJlOiB0cnVlXG5cdCAgICB9KTtcblxuXHQgICAgaWYgKHRoaXMuZmlsdGVyKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9zZXR0aW5ncy5hY3RpdmVDb250ZW50KSB7XG5cdCAgICAgICAgdGhpcy50eXBlW2tleV0gPSB0aGlzW2tleV07XG5cdCAgICAgICAgdGhpc1trZXldID0gdGhpcy5fbG9jYXRlX2FjdGl2ZV9jb250ZW50X2J5X2lkKGtleSk7XG5cdCAgICAgIH0gLy9yZWFsbHkgYmFkIVxuXG5cblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnR5cGUubWFzdGVyVUkgPSB0aGlzO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy50eXBlLm1hc3RlclVJID0gdGhpcztcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9sb2NhdGVfYWN0aXZlX2NvbnRlbnRfYnlfaWQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2FjdGl2ZV9yZWZlcmVuY2VzW2tleV07XG5cdCAgICAgIHZhciBidXR0b25faWQgPSBidXR0b24uX3NldHRpbmdzLmlkO1xuXHQgICAgICB2YXIgaHRtbCA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRElWXCIpO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHRtbC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChodG1sW2ldLmdldEF0dHJpYnV0ZShcInZpZXdfaWRcIikgPT0gYnV0dG9uX2lkKSB7XG5cdCAgICAgICAgICBidXR0b24uX3ZpZXdvYmogPSBidXR0b24uX2RhdGFvYmogPSBodG1sW2ldO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGJ1dHRvbjtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfZ2V0X2FjdGl2ZV9ub2RlOiBmdW5jdGlvbiAoZWwsIGtleSwgbWFzdGVyKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgaWYgKGUpIHtcblx0ICAgICAgICB2YXIgdHJnID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdCAgICAgICAgd2hpbGUgKHRyZykge1xuXHQgICAgICAgICAgaWYgKHRyZy5nZXRBdHRyaWJ1dGUgJiYgdHJnLmdldEF0dHJpYnV0ZShcInZpZXdfaWRcIikpIHtcblx0ICAgICAgICAgICAgbWFzdGVyLl9zZXRBY3RpdmVDb250ZW50VmlldyhlbCwgdHJnKTtcblxuXHQgICAgICAgICAgICBpZiAobWFzdGVyLmxvY2F0ZSkge1xuXHQgICAgICAgICAgICAgIHZhciBpZCA9IG1hc3Rlci5sb2NhdGUodHJnLnBhcmVudE5vZGUpO1xuXHQgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hc3Rlci5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzW2tleV1baWRdO1xuXHQgICAgICAgICAgICAgIGVsLl9zZXR0aW5ncy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgIGVsLl9zZXR0aW5ncy4kbWFzdGVySWQgPSBpZDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cmc7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRyZyA9IHRyZy5wYXJlbnROb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBlbC5fdmlld29iajtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfc2V0X25ld19hY3RpdmVfdmFsdWU6IGZ1bmN0aW9uIChrZXksIG1hc3Rlcikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICB2YXIgZGF0YSA9IG1hc3Rlci5kYXRhO1xuXG5cdCAgICAgIGlmIChtYXN0ZXIuZmlsdGVyKSB7XG5cdCAgICAgICAgdmFyIGlkID0gbWFzdGVyLmxvY2F0ZSh0aGlzLl92aWV3b2JqLnBhcmVudE5vZGUpO1xuXHQgICAgICAgIGRhdGEgPSBtYXN0ZXIuZ2V0SXRlbShpZCk7IC8vWE1MU2VyaWFsaXplciAtIEZGIFwiZmVhdHVyZVwiXG5cblx0ICAgICAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgICAgICBtYXN0ZXIuX2FjdGl2ZV9ob2xkZXJzX2l0ZW1ba2V5XVtpZF0gPSB0aGlzLl92aWV3b2JqLm91dGVySFRNTCB8fCBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgICAgIG1hc3Rlci5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzW2tleV1baWRdID0gdmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZGF0YSkgZGF0YVtrZXldID0gdmFsdWU7XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2JpbmRfYWN0aXZlX2NvbnRlbnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBjb21tb24sIGFjdGl2ZSkge1xuXHQgICAgICB2YXIgb2JqZWN0ID0gY29tbW9uLl9hY3RpdmVfaG9sZGVycyA/IGNvbW1vbiA6IGNvbW1vbi5tYXN0ZXJVSTtcblxuXHQgICAgICBpZiAoIW9iamVjdC5fYWN0aXZlX2hvbGRlcnNba2V5XSkge1xuXHQgICAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcblx0ICAgICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgb2JqZWN0Ll9zZXR0aW5ncy5hY3RpdmVDb250ZW50O1xuXHQgICAgICAgIHZhciBlbCA9IHVpKGFjdGl2ZVtrZXldLCBkKTtcblxuXHQgICAgICAgIGlmIChlbnYuaXNJRTgpIHtcblx0ICAgICAgICAgIGQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJvbmNsaWNrXCIsIFwiZXZlbnQucHJvY2Vzc2VkID0gdHJ1ZTsgZXZlbnQuc3JjRWxlbWVudC53X3ZpZXcgPSAnXCIgKyBlbC5fc2V0dGluZ3MuaWQgKyBcIic7XCIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBkLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwib25jbGlja1wiLCBcImV2ZW50LnByb2Nlc3NlZCA9IHRydWU7IFwiKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBlbC5nZXROb2RlID0gb2JqZWN0Ll9nZXRfYWN0aXZlX25vZGUoZWwsIGtleSwgb2JqZWN0KTtcblx0ICAgICAgICBlbC5hdHRhY2hFdmVudChcIm9uQ2hhbmdlXCIsIG9iamVjdC5fc2V0X25ld19hY3RpdmVfdmFsdWUoa2V5LCBvYmplY3QpKTtcblx0ICAgICAgICBvYmplY3QuX2FjdGl2ZV9yZWZlcmVuY2VzW2tleV0gPSBlbDtcblx0ICAgICAgICBvYmplY3QuX2FjdGl2ZV9ob2xkZXJzW2tleV0gPSBkLmlubmVySFRNTDtcblx0ICAgICAgICBvYmplY3QuX2FjdGl2ZV9ob2xkZXJzX2l0ZW1ba2V5XSA9IHt9O1xuXHQgICAgICAgIG9iamVjdC5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzW2tleV0gPSB7fTtcblx0ICAgICAgICBlbC4kYWN0aXZlRWwgPSBlbC4kdmlldztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChvYmplY3QuZmlsdGVyICYmIG9ialtrZXldICE9IG9iamVjdC5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzW2tleV0gJiYgIWlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuXHQgICAgICAgIHZhciBfZWwgPSBvYmplY3QuX2FjdGl2ZV9yZWZlcmVuY2VzW2tleV07XG5cblx0ICAgICAgICBfZWwuYmxvY2tFdmVudCgpO1xuXG5cdCAgICAgICAgb2JqZWN0Ll9zZXRBY3RpdmVDb250ZW50VmlldyhfZWwsIF9lbC4kYWN0aXZlRWwpOyAvL2luIElFIHdlIGNhbiBsb3N0IGNvbnRlbnQgb2YgYWN0aXZlIGVsZW1lbnQgZHVyaW5nIHBhcmVudCByZXBhaW50aW5nXG5cblxuXHQgICAgICAgIGlmICghX2VsLiR2aWV3LmZpcnN0Q2hpbGQpIF9lbC5yZWZyZXNoKCk7XG5cblx0ICAgICAgICBfZWwuc2V0VmFsdWUob2JqW2tleV0pO1xuXG5cdCAgICAgICAgX2VsLnJlZnJlc2goKTtcblxuXHQgICAgICAgIF9lbC51bmJsb2NrRXZlbnQoKTtcblxuXHQgICAgICAgIG9iamVjdC5fYWN0aXZlX2hvbGRlcnNfdmFsdWVzW2tleV1bb2JqLmlkXSA9IG9ialtrZXldO1xuXHQgICAgICAgIG9iamVjdC5fYWN0aXZlX2hvbGRlcnNfaXRlbVtrZXldW29iai5pZF0gPSBfZWwuX3ZpZXdvYmoub3V0ZXJIVE1MIHx8IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoX2VsLl92aWV3b2JqKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBvYmplY3QuX2FjdGl2ZV9ob2xkZXJzX2l0ZW1ba2V5XVtvYmouaWRdIHx8IG9iamVjdC5fYWN0aXZlX2hvbGRlcnNba2V5XTtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfc2V0QWN0aXZlQ29udGVudFZpZXc6IGZ1bmN0aW9uIChlbCwgdmlldykge1xuXHQgICAgZWwuX2RhdGFvYmogPSBlbC5fdmlld29iaiA9IGVsLiR2aWV3ID0gdmlldztcblx0ICB9XG5cdH07XG5cblx0dmFyIHByb3h5ID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBsb2FkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcGFydHMgPSB0aGlzLnNvdXJjZS5zcGxpdChcIkBcIik7XG5cdCAgICB2YXIgZXh0ID0gcGFydHNbMF0uc3BsaXQoXCIuXCIpLnBvcCgpO1xuXHQgICAgcmV0dXJuIGFqYXgoKS5yZXNwb25zZShcImFycmF5YnVmZmVyXCIpLmdldChwYXJ0c1swXSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgIHZhciBvcHRpb25zID0ge1xuXHQgICAgICAgIGV4dDogZXh0LFxuXHQgICAgICAgIGRhdGF1cmw6IHBhcnRzWzFdXG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGF0YTogcmVzLFxuXHQgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgcHJveHkkMSA9IHtcblx0ICAkcHJveHk6IHRydWUsXG5cdCAgY29ubmVjdG9yTmFtZTogXCIhbmF0aXZlZWRpdG9yX3N0YXR1c1wiLFxuXHQgIGxvYWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBhamF4KHRoaXMuc291cmNlKTtcblx0ICB9LFxuXHQgIHNhdmVBbGw6IGZ1bmN0aW9uICh2aWV3LCB1cGRhdGVzKSB7XG5cdCAgICB2YXIgdXJsID0gdGhpcy5zb3VyY2U7XG5cdCAgICB2YXIgZGF0YSA9IHt9O1xuXHQgICAgdmFyIGlkcyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZXNbaV07XG5cdCAgICAgIGlkcy5wdXNoKGFjdGlvbi5pZCk7XG5cblx0ICAgICAgZm9yICh2YXIgaiBpbiBhY3Rpb24uZGF0YSkge1xuXHQgICAgICAgIGlmIChqLmluZGV4T2YoXCIkXCIpICE9PSAwKSBkYXRhW2FjdGlvbi5pZCArIFwiX1wiICsgal0gPSBhY3Rpb24uZGF0YVtqXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGRhdGFbYWN0aW9uLmlkICsgXCJfXCIgKyB0aGlzLmNvbm5lY3Rvck5hbWVdID0gYWN0aW9uLm9wZXJhdGlvbjtcblx0ICAgIH1cblxuXHQgICAgZGF0YS5pZHMgPSBpZHMuam9pbihcIixcIik7XG5cdCAgICBkYXRhLndlYml4X3NlY3VyaXR5ID0gc3RhdGUuc2VjdXJpdHlLZXk7XG5cdCAgICB1cmwgKz0gdXJsLmluZGV4T2YoXCI/XCIpID09IC0xID8gXCI/XCIgOiBcIiZcIjtcblx0ICAgIHVybCArPSBcImVkaXRpbmc9dHJ1ZVwiO1xuXHQgICAgcmV0dXJuIGFqYXgoKS5wb3N0KHVybCwgZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICBkYXRhID0gZGF0YS54bWwoKTtcblx0ICAgICAgaWYgKCFkYXRhKSB0aHJvdyBcIkRhdGEgbG9hZGluZyBlcnJvclwiO1xuXHQgICAgICB2YXIgYWN0aW9ucyA9IGRhdGEuZGF0YS5hY3Rpb247XG5cdCAgICAgIGlmICghYWN0aW9ucy5sZW5ndGgpIGFjdGlvbnMgPSBbYWN0aW9uc107XG5cdCAgICAgIHZhciBoYXNoID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG9iaiA9IGFjdGlvbnNbaV07XG5cdCAgICAgICAgb2JqLnN0YXR1cyA9IG9iai50eXBlO1xuXHQgICAgICAgIG9iai5pZCA9IG9iai5zaWQ7XG5cdCAgICAgICAgb2JqLm5ld2lkID0gb2JqLnRpZDtcblx0ICAgICAgICBoYXNoLnB1c2gob2JqKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcm94eSQyID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBsb2FkOiBmdW5jdGlvbiAoKSB7fSxcblx0ICBzYXZlOiBmdW5jdGlvbiAodiwgdSwgZCkge1xuXHQgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCJbRFBdIFwiICsgdS5pZCArIFwiIC0+IFwiICsgdS5vcGVyYXRpb24sIHUuZGF0YSk7XG5cdCAgICAgIHZhciBkYXRhID0ge1xuXHQgICAgICAgIGlkOiB1LmRhdGEuaWQsXG5cdCAgICAgICAgbmV3aWQ6IHUuZGF0YS5pZCxcblx0ICAgICAgICBzdGF0dXM6IHUuZGF0YS5vcGVyYXRpb25cblx0ICAgICAgfTtcblx0ICAgICAgZC5wcm9jZXNzUmVzdWx0KGRhdGEsIGRhdGEpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcm94eSQzID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNsaWVudElkID0gdGhpcy5jbGllbnRJZCB8fCB1aWQoKTtcblx0ICB9LFxuXHQgIGxvYWQ6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICB2YXIgc2VsZmlkID0gdGhpcy5jbGllbnRJZDtcblx0ICAgIHRoaXMuY2xpZW50LnN1YnNjcmliZSh0aGlzLnNvdXJjZSwgZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHQgICAgICBpZiAodXBkYXRlLmNsaWVudElkID09IHNlbGZpZCkgcmV0dXJuO1xuXHQgICAgICB1c2UoXCJkcFwiKSh2aWV3KS5pZ25vcmUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh1cGRhdGUub3BlcmF0aW9uID09IFwiZGVsZXRlXCIpIHZpZXcucmVtb3ZlKHVwZGF0ZS5kYXRhLmlkKTtlbHNlIGlmICh1cGRhdGUub3BlcmF0aW9uID09IFwiaW5zZXJ0XCIpIHZpZXcuYWRkKHVwZGF0ZS5kYXRhKTtlbHNlIGlmICh1cGRhdGUub3BlcmF0aW9uID09IFwidXBkYXRlXCIpIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdmlldy5nZXRJdGVtKHVwZGF0ZS5kYXRhLmlkKTtcblxuXHQgICAgICAgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgICAgICAgZXhwb3J0cy5leHRlbmQoaXRlbSwgdXBkYXRlLmRhdGEsIHRydWUpO1xuXHQgICAgICAgICAgICB2aWV3LnJlZnJlc2goaXRlbS5pZCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgc2F2ZTogZnVuY3Rpb24gKHZpZXcsIHVwZGF0ZSkge1xuXHQgICAgdXBkYXRlLmNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcblx0ICAgIHRoaXMuY2xpZW50LnB1Ymxpc2godGhpcy5zb3VyY2UsIHVwZGF0ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBpbmRleGRiID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBjcmVhdGU6IGZ1bmN0aW9uIChkYiwgY29uZmlnLCB2ZXJzaW9uLCBjYWxsYmFjaykge1xuXHQgICAgdGhpcy5zb3VyY2UgPSBkYiArIFwiL1wiO1xuXG5cdCAgICB0aGlzLl9nZXRfZGIoY2FsbGJhY2ssIHZlcnNpb24sIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBkYiA9IGUudGFyZ2V0LnJlc3VsdDtcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gY29uZmlnKSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBjb25maWdba2V5XTtcblx0ICAgICAgICB2YXIgc3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShrZXksIHtcblx0ICAgICAgICAgIGtleVBhdGg6IFwiaWRcIixcblx0ICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgc3RvcmUucHV0KGRhdGFbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfZ2V0X2RiOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHZlcnNpb24sIHVwZ3JhZGUpIHtcblx0ICAgIGlmICh0aGlzLnNvdXJjZS5pbmRleE9mKFwiL1wiKSAhPSAtMSkge1xuXHQgICAgICB2YXIgcGFydHMgPSB0aGlzLnNvdXJjZS5zcGxpdChcIi9cIik7XG5cdCAgICAgIHRoaXMuc291cmNlID0gcGFydHNbMV07XG5cdCAgICAgIHZlcnNpb24gPSB2ZXJzaW9uIHx8IHBhcnRzWzJdO1xuXG5cdCAgICAgIHZhciBfaW5kZXggPSB3aW5kb3cuaW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1vekluZGV4ZWREQjtcblxuXHQgICAgICB2YXIgZGI7XG5cdCAgICAgIGlmICh2ZXJzaW9uKSBkYiA9IF9pbmRleC5vcGVuKHBhcnRzWzBdLCB2ZXJzaW9uKTtlbHNlIGRiID0gX2luZGV4Lm9wZW4ocGFydHNbMF0pO1xuXHQgICAgICBpZiAodXBncmFkZSkgZGIub251cGdyYWRlbmVlZGVkID0gdXBncmFkZTtcblxuXHQgICAgICBkYi5vbmVycm9yID0gZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgZGIub25ibG9ja2VkID0gZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgZGIub25zdWNjZXNzID0gYmluZChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHRoaXMuZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cdCAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5jYWxsKHRoaXMpO1xuXHQgICAgICB9LCB0aGlzKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5kYikgY2FsbGJhY2suY2FsbCh0aGlzKTtlbHNlIGRlbGF5KHRoaXMuX2dldF9kYiwgdGhpcywgW2NhbGxiYWNrXSwgNTApO1xuXHQgIH0sXG5cdCAgbG9hZDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHdhaXREYXRhID0gRGVmZXJyZWQuZGVmZXIoKTtcblxuXHQgICAgdGhpcy5fZ2V0X2RiKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHN0b3JlID0gdGhpcy5kYi50cmFuc2FjdGlvbih0aGlzLnNvdXJjZSkub2JqZWN0U3RvcmUodGhpcy5zb3VyY2UpO1xuXHQgICAgICB2YXIgZGF0YSA9IFtdO1xuXHQgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcigpO1xuXG5cdCAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBlLnRhcmdldC5yZXN1bHQ7XG5cblx0ICAgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgICBkYXRhLnB1c2gocmVzdWx0LnZhbHVlKTtcblx0ICAgICAgICAgIHJlc3VsdFtcImNvbnRpbnVlXCJdKCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHdhaXREYXRhLnJlc29sdmUoZGF0YSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB3YWl0RGF0YS5yZWplY3QoZSk7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIHdhaXREYXRhO1xuXHQgIH0sXG5cdCAgc2F2ZTogZnVuY3Rpb24gKHZpZXcsIHVwZGF0ZSkge1xuXHQgICAgdmFyIHdhaXREYXRhID0gRGVmZXJyZWQuZGVmZXIoKTtcblxuXHQgICAgdGhpcy5fZ2V0X2RiKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIG1vZGUgPSB1cGRhdGUub3BlcmF0aW9uO1xuXHQgICAgICB2YXIgZGF0YSA9IHVwZGF0ZS5kYXRhO1xuXHQgICAgICB2YXIgaWQgPSB1cGRhdGUuaWQ7XG5cdCAgICAgIHZhciBzdG9yZSA9IHRoaXMuZGIudHJhbnNhY3Rpb24oW3RoaXMuc291cmNlXSwgXCJyZWFkd3JpdGVcIikub2JqZWN0U3RvcmUodGhpcy5zb3VyY2UpO1xuXHQgICAgICB2YXIgcmVxO1xuXHQgICAgICBpZiAobW9kZSA9PSBcImRlbGV0ZVwiKSByZXEgPSBzdG9yZVtcImRlbGV0ZVwiXShpZCk7ZWxzZSBpZiAobW9kZSA9PSBcInVwZGF0ZVwiKSByZXEgPSBzdG9yZS5wdXQoZGF0YSk7ZWxzZSBpZiAobW9kZSA9PSBcImluc2VydFwiKSB7XG5cdCAgICAgICAgZGVsZXRlIGRhdGEuaWQ7XG5cdCAgICAgICAgcmVxID0gc3RvcmUuYWRkKGRhdGEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICAgIHN0YXR1czogbW9kZSxcblx0ICAgICAgICAgIGlkOiB1cGRhdGUuaWRcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChtb2RlID09IFwiaW5zZXJ0XCIpIHJlc3VsdC5uZXdpZCA9IGUudGFyZ2V0LnJlc3VsdDtcblx0ICAgICAgICB3YWl0RGF0YS5yZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHdhaXREYXRhLnJlamVjdChlKTtcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gd2FpdERhdGE7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcm94eSQ0ID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBsb2FkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gYWpheCh0aGlzLnNvdXJjZSk7XG5cdCAgfSxcblx0ICBzYXZlOiBmdW5jdGlvbiAodmlldywgdXBkYXRlKSB7XG5cdCAgICByZXR1cm4gcHJveHkkNC5fc2F2ZV9sb2dpYy5jYWxsKHRoaXMsIHVwZGF0ZSwgYWpheCgpKTtcblx0ICB9LFxuXHQgIF9zYXZlX2xvZ2ljOiBmdW5jdGlvbiAodXBkYXRlLCBhamF4JCQxKSB7XG5cdCAgICB2YXIgdXJsID0gdGhpcy5zb3VyY2U7XG5cdCAgICB2YXIgcXVlcnkgPSBcIlwiO1xuXHQgICAgdmFyIG1hcmsgPSB1cmwuaW5kZXhPZihcIj9cIik7XG5cblx0ICAgIGlmIChtYXJrICE9PSAtMSkge1xuXHQgICAgICBxdWVyeSA9IHVybC5zdWJzdHIobWFyayk7XG5cdCAgICAgIHVybCA9IHVybC5zdWJzdHIoMCwgbWFyayk7XG5cdCAgICB9XG5cblx0ICAgIHVybCArPSB1cmwuY2hhckF0KHVybC5sZW5ndGggLSAxKSA9PSBcIi9cIiA/IFwiXCIgOiBcIi9cIjtcblx0ICAgIHZhciBtb2RlID0gdXBkYXRlLm9wZXJhdGlvbjtcblx0ICAgIHZhciBkYXRhID0gdXBkYXRlLmRhdGE7XG5cdCAgICBpZiAobW9kZSA9PSBcImluc2VydFwiKSBkZWxldGUgZGF0YS5pZDsgLy9jYWxsIHJlc3QgVVJJXG5cblx0ICAgIGlmIChtb2RlID09IFwidXBkYXRlXCIpIHtcblx0ICAgICAgcmV0dXJuIGFqYXgkJDEucHV0KHVybCArIGRhdGEuaWQgKyBxdWVyeSwgZGF0YSk7XG5cdCAgICB9IGVsc2UgaWYgKG1vZGUgPT0gXCJkZWxldGVcIikge1xuXHQgICAgICByZXR1cm4gYWpheCQkMS5kZWwodXJsICsgZGF0YS5pZCArIHF1ZXJ5LCBkYXRhKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBhamF4JCQxLnBvc3QodXJsICsgcXVlcnksIGRhdGEpO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgcHJveHkkNSA9IHtcblx0ICAkcHJveHk6IHRydWUsXG5cdCAgbG9hZDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGFqYXgodGhpcy5zb3VyY2UpO1xuXHQgIH0sXG5cdCAgc2F2ZTogZnVuY3Rpb24gKHZpZXcsIHVwZGF0ZSkge1xuXHQgICAgdmFyIHhociA9IGFqYXgoKS5oZWFkZXJzKHtcblx0ICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHByb3h5JDQuX3NhdmVfbG9naWMuY2FsbCh0aGlzLCB1cGRhdGUsIHhocik7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcm94eSQ2ID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBsb2FkOiBmdW5jdGlvbiAodmlldywgcGFyYW1zKSB7XG5cdCAgICBwYXJhbXMgPSBleHBvcnRzLmV4dGVuZChwYXJhbXMgfHwge30sIHRoaXMucGFyYW1zIHx8IHt9LCB0cnVlKTtcblx0ICAgIHJldHVybiBhamF4KCkucG9zdCh0aGlzLnNvdXJjZSwgcGFyYW1zKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIGpzYXJyYXkgPSB7XG5cdCAgLy9wYXJzZSBqc2FycmF5IHN0cmluZyB0byBqc2FycmF5IG9iamVjdCBpZiBuZWNlc3Nhcnlcblx0ICB0b09iamVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKSByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgLy9nZXQgYXJyYXkgb2YgcmVjb3Jkc1xuXHQgIGdldFJlY29yZHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEpIGRhdGEgPSBkYXRhLmRhdGE7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIC8vZ2V0IGhhc2ggb2YgcHJvcGVydGllcyBmb3Igc2luZ2xlIHJlY29yZCwgaW4gY2FzZSBvZiBhcnJheSB0aGV5IHdpbGwgaGF2ZSBuYW1lcyBhcyBcImRhdGF7aW5kZXh9XCJcblx0ICBnZXREZXRhaWxzOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcmVzdWx0W1wiZGF0YVwiICsgaV0gPSBkYXRhW2ldO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5pZENvbHVtbiAhPT0gbnVsbCkgcmVzdWx0LmlkID0gZGF0YVt0aGlzLmlkQ29sdW1uXTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBnZXRPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICAvL2R5biBsb2FkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkganMtYXJyYXkgZGF0YSBzb3VyY2Vcblx0ICBnZXRJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzaXplOiAwXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgaWRDb2x1bW46IG51bGxcblx0fTtcblxuXHR2YXIgY3N2ID0ge1xuXHQgIC8vaW5jb21pbmcgZGF0YSBhbHdheXMgYSBzdHJpbmdcblx0ICB0b09iamVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgLy9nZXQgYXJyYXkgb2YgcmVjb3Jkc1xuXHQgIGdldFJlY29yZHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICByZXR1cm4gZGF0YS5zcGxpdCh0aGlzLnJvdyk7XG5cdCAgfSxcblx0ICAvL2dldCBoYXNoIG9mIHByb3BlcnRpZXMgZm9yIHNpbmdsZSByZWNvcmQsIGRhdGEgbmFtZWQgYXMgXCJkYXRhe2luZGV4fVwiXG5cdCAgZ2V0RGV0YWlsczogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIGRhdGEgPSB0aGlzLnN0cmluZ1RvQXJyYXkoZGF0YSk7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByZXN1bHRbXCJkYXRhXCIgKyBpXSA9IGRhdGFbaV07XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmlkQ29sdW1uICE9PSBudWxsKSByZXN1bHQuaWQgPSBkYXRhW3RoaXMuaWRDb2x1bW5dO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9LFxuXHQgIGdldE9wdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9LFxuXHQgIC8vZHluIGxvYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBieSBjc3YgZGF0YSBzb3VyY2Vcblx0ICBnZXRJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzaXplOiAwXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgLy9zcGxpdCBzdHJpbmcgaW4gYXJyYXksIHRha2VzIHN0cmluZyBzdXJyb3VuZGluZyBxdW90ZXMgaW4gYWNjb3VudFxuXHQgIHN0cmluZ1RvQXJyYXk6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBkYXRhID0gZGF0YS5zcGxpdCh0aGlzLmNlbGwpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZGF0YVtpXSA9IGRhdGFbaV0ucmVwbGFjZSgvXlsgXFx0XFxuXFxyXSooXCJ8KS9nLCBcIlwiKS5yZXBsYWNlKC8oXCJ8KVsgXFx0XFxuXFxyXSokL2csIFwiXCIpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIGlkQ29sdW1uOiBudWxsLFxuXHQgIHJvdzogXCJcXG5cIixcblx0ICAvL2RlZmF1bHQgcm93IHNlcGFyYXRvclxuXHQgIGNlbGw6IFwiLFwiIC8vZGVmYXVsdCBjZWxsIHNlcGFyYXRvclxuXG5cdH07XG5cblx0dmFyIGh0bWwgPSB7XG5cdCAgLypcblx0ICBcdGluY29taW5nIGRhdGEgY2FuIGJlXG5cdCAgXHQgLSBJRCBvZiBwYXJlbnQgY29udGFpbmVyXG5cdCAgXHQgLSBIVE1MIHRleHRcblx0ICAqL1xuXHQgIHRvT2JqZWN0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgdmFyIHQgPSBudWxsO1xuXHQgICAgICBpZiAoZGF0YS5pbmRleE9mKFwiPFwiKSA9PSAtMSkgLy9pZiBubyB0YWdzIGluc2lkZSAtIHByb2JhYmx5IGl0cyBhbiBJRFxuXHQgICAgICAgIHQgPSB0b05vZGUoZGF0YSk7XG5cblx0ICAgICAgaWYgKCF0KSB7XG5cdCAgICAgICAgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG5cdCAgICAgICAgdC5pbm5lckhUTUwgPSBkYXRhO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHQuZmlyc3RDaGlsZDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfSxcblx0ICAvL2dldCBhcnJheSBvZiByZWNvcmRzXG5cdCAgZ2V0UmVjb3JkczogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgIHJldHVybiBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRoaXMudGFnKTtcblx0ICB9LFxuXHQgIC8vZ2V0IGhhc2ggb2YgcHJvcGVydGllcyBmb3Igc2luZ2xlIHJlY29yZFxuXHQgIGdldERldGFpbHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICByZXR1cm4geG1sLnRhZ1RvT2JqZWN0KGRhdGEpO1xuXHQgIH0sXG5cdCAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgLy9keW4gbG9hZGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IEhUTUwgZGF0YSBzb3VyY2Vcblx0ICBnZXRJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzaXplOiAwXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgdGFnOiBcIkxJXCJcblx0fTtcblxuXHR2YXIgaHRtbHRhYmxlID0ge1xuXHQgIC8vY29udmVydCBqc29uIHN0cmluZyB0byBqc29uIG9iamVjdCBpZiBuZWNlc3Nhcnlcblx0ICB0b09iamVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIGRhdGEgPSB0b05vZGUoZGF0YSk7XG5cdCAgICBhc3NlcnQoZGF0YSwgXCJ0YWJsZSBpcyBub3QgZm91bmRcIik7XG5cdCAgICBhc3NlcnQoZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGFibGVcIiwgXCJJbmNvcnJlY3QgdGFibGUgb2JqZWN0XCIpO1xuXHQgICAgdmFyIHRyID0gZGF0YS5yb3dzO1xuXHQgICAgcmVtb3ZlKGRhdGEpO1xuXHQgICAgcmV0dXJuIHRyO1xuXHQgIH0sXG5cdCAgLy9nZXQgYXJyYXkgb2YgcmVjb3Jkc1xuXHQgIGdldFJlY29yZHM6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICB2YXIgbmV3X2RhdGEgPSBbXTsgLy9za2lwIGhlYWRlciByb3dzIGlmIG5lY2Vzc2FyeVxuXG5cdCAgICB2YXIgaSA9IGRhdGFbMF0gJiYgZGF0YVswXS5fd2ViaXhfc2tpcCA/IDEgOiAwO1xuXG5cdCAgICBmb3IgKDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgbmV3X2RhdGEucHVzaChkYXRhW2ldKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ld19kYXRhO1xuXHQgIH0sXG5cdCAgLy9nZXQgaGFzaCBvZiBwcm9wZXJ0aWVzIGZvciBzaW5nbGUgcmVjb3JkXG5cdCAgZ2V0RGV0YWlsczogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHZhciB0ZCA9IGRhdGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZFwiKTtcblx0ICAgIGRhdGEgPSB7fTsgLy9nZXQgaGFzaCBvZiBwcm9wZXJ0aWVzIGZvciBzaW5nbGUgcmVjb3JkLCBkYXRhIG5hbWVkIGFzIFwiZGF0YXtpbmRleH1cIlxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRhdGFbXCJkYXRhXCIgKyBpXSA9IHRkW2ldLmlubmVySFRNTDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfSxcblx0ICAvL2dldCBjb3VudCBvZiBkYXRhIGFuZCBwb3NpdGlvbiBhdCB3aGljaCBuZXcgZGF0YSBuZWVkIHRvIGJlIGluc2VydGVkXG5cdCAgZ2V0SW5mbzogZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gZHluIGxvYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgaHRtbHRhYmxlXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzaXplOiAwXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgZ2V0T3B0aW9uczogZnVuY3Rpb24gKCkge30sXG5cblx0ICAvKiEgZ2V0cyBoZWFkZXIgZnJvbSBmaXJzdCB0YWJsZSByb3dcblx0ICAgKiovXG5cdCAgZ2V0Q29uZmlnOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIGNvbHVtbnMgPSBbXTtcblx0ICAgIHZhciB0ZCA9IGRhdGFbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aFwiKTtcblx0ICAgIGlmICh0ZC5sZW5ndGgpIGRhdGFbMF0uX3dlYml4X3NraXAgPSB0cnVlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjb2wgPSB7XG5cdCAgICAgICAgaWQ6IFwiZGF0YVwiICsgaSxcblx0ICAgICAgICBoZWFkZXI6IHRoaXMuX2RlX2pzb24odGRbaV0uaW5uZXJIVE1MKVxuXHQgICAgICB9O1xuXG5cdCAgICAgIHZhciBhdHRycyA9IHRoaXMuX2dldF9hdHRycyh0ZFtpXSk7XG5cblx0ICAgICAgY29sID0gZXhwb3J0cy5leHRlbmQoY29sLCBhdHRycyk7XG5cdCAgICAgIGNvbHVtbnMucHVzaChjb2wpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY29sdW1ucztcblx0ICB9LFxuXHQgIF9kZV9qc29uOiBmdW5jdGlvbiAoc3RyKSB7XG5cdCAgICB2YXIgcG9zJCQxID0gc3RyLmluZGV4T2YoXCJqc29uOi8vXCIpO1xuXHQgICAgaWYgKHBvcyQkMSAhPSAtMSkgc3RyID0gSlNPTi5wYXJzZShzdHIuc3Vic3RyKHBvcyQkMSArIDcpKTtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfSxcblxuXHQgIC8qISBnZXRzIGhhc2ggb2YgaHRtbC1lbGVtZW50IGF0dHJpYnV0ZXNcblx0ICAgKiovXG5cdCAgX2dldF9hdHRyczogZnVuY3Rpb24gKGVsKSB7XG5cdCAgICB2YXIgYXR0ciA9IGVsLmF0dHJpYnV0ZXM7XG5cdCAgICB2YXIgaGFzaCA9IHt9O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaGFzaFthdHRyW2ldLm5vZGVOYW1lXSA9IHRoaXMuX2RlX2pzb24oYXR0cltpXS5ub2RlVmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICBoYXNoLndpZHRoID0gcGFyc2VJbnQoaGFzaC53aWR0aCwgMTApO1xuXHQgICAgcmV0dXJuIGhhc2g7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBfbW9kdWxlcyA9IHt9OyAvL2hhc2ggb2YgYWxyZWFkeSBsb2FkZWQgbW9kdWxlc1xuXHQvL2xvYWRzIG1vZHVsZSBmcm9tIGV4dGVybmFsIGpzIGZpbGVcblxuXHRmdW5jdGlvbiByZXF1aXJlKG1vZHVsZSwgY2FsbGJhY2ssIG1hc3Rlcikge1xuXHQgIHZhciBwcm9taXNlID0gRGVmZXJyZWQuZGVmZXIoKTtcblx0ICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IHRydWUpIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgY2FsbGJhY2suY2FsbChtYXN0ZXIgfHwgdGhpcyk7XG5cdCAgfSk7XG5cblx0ICBpZiAocmVxdWlyZS5kaXNhYmxlZCkge1xuXHQgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICByZXR1cm4gcHJvbWlzZTtcblx0ICB9IC8vbXVsdGlwbGUgZmlsZXMgcmVxdWlyZWQgYXQgb25jZVxuXG5cblx0ICBpZiAodHlwZW9mIG1vZHVsZSAhPSBcInN0cmluZ1wiKSB7XG5cdCAgICB2YXIgY291bnQgPSBtb2R1bGUubGVuZ3RoIHx8IDA7XG5cblx0ICAgIGlmICghY291bnQpIHtcblx0ICAgICAgLy8geyBmaWxlOiB0cnVlLCBvdGhlcjogdHJ1ZSB9XG5cdCAgICAgIGZvciAodmFyIGZpbGUgaW4gbW9kdWxlKSB7XG5cdCAgICAgICAgY291bnQrKztcblx0ICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblxuXHQgICAgICB2YXIgY2FsbGJhY2syID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGNvdW50LS07XG5cdCAgICAgICAgaWYgKGNvdW50ID09PSAwKSBwcm9taXNlLnJlc29sdmUoKTtcblx0ICAgICAgfTtcblxuXHQgICAgICBmb3IgKHZhciBfZmlsZSBpbiBtb2R1bGUpIHtcblx0ICAgICAgICByZXF1aXJlKF9maWxlLCBjYWxsYmFjazIsIG1hc3Rlcik7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFsgZmlsZSwgb3RoZXIgXVxuXHQgICAgICB2YXIgX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmIChjb3VudCkge1xuXHQgICAgICAgICAgY291bnQtLTtcblxuXHQgICAgICAgICAgcmVxdWlyZShtb2R1bGVbbW9kdWxlLmxlbmd0aCAtIGNvdW50IC0gMV0sIF9jYWxsYmFjaywgbWFzdGVyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIF9jYWxsYmFjaygpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcHJvbWlzZTtcblx0ICB9XG5cblx0ICBpZiAoX21vZHVsZXNbbW9kdWxlXSAhPT0gdHJ1ZSkge1xuXHQgICAgdmFyIGZ1bGxwYXRoID0gbW9kdWxlOyAvL2NzcywgYXN5bmMsIG5vIHdhaXRpbmdcblxuXHQgICAgdmFyIHBhcnRzID0gbW9kdWxlLnNwbGl0KFwiP1wiKTtcblxuXHQgICAgaWYgKHBhcnRzWzBdLnN1YnN0cihwYXJ0c1swXS5sZW5ndGggLSA0KSA9PSBcIi5jc3NcIikge1xuXHQgICAgICB2YXIgbGluayA9IGNyZWF0ZShcIkxJTktcIiwge1xuXHQgICAgICAgIHR5cGU6IFwidGV4dC9jc3NcIixcblx0ICAgICAgICByZWw6IFwic3R5bGVzaGVldFwiLFxuXHQgICAgICAgIGhyZWY6IGZ1bGxwYXRoXG5cdCAgICAgIH0pO1xuXHQgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQobGluayk7XG5cdCAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH0gLy9qcywgYXN5bmMsIHdhaXRpbmdcblxuXG5cdCAgICBpZiAoY2FsbGJhY2sgPT09IHRydWUpIHtcblx0ICAgICAgLy9zeW5jIG1vZGVcblx0ICAgICAgZXhlYyhhamF4KCkuc3luYygpLmdldChmdWxscGF0aCkucmVzcG9uc2VUZXh0KTtcblx0ICAgICAgX21vZHVsZXNbbW9kdWxlXSA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoIV9tb2R1bGVzW21vZHVsZV0pIHtcblx0ICAgICAgICAvL2ZpcnN0IGNhbGxcblx0ICAgICAgICBfbW9kdWxlc1ttb2R1bGVdID0gW3Byb21pc2VdO1xuXHQgICAgICAgIHZhciBuZXdTY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHQgICAgICAgIHZhciBjYWxscyA9IF9tb2R1bGVzW21vZHVsZV07IC8vY2FsbGJhY2tzXG5cblx0ICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIF9tb2R1bGVzW21vZHVsZV0gPSBmYWxzZTtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjYWxsc1tpXS5yZWplY3QoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIF9tb2R1bGVzW21vZHVsZV0gPSB0cnVlO1xuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNhbGxzW2ldLnJlc29sdmUoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKG5ld1NjcmlwdCk7XG5cdCAgICAgICAgbmV3U2NyaXB0LnNyYyA9IGZ1bGxwYXRoO1xuXHQgICAgICB9IGVsc2UgLy9tb2R1bGUgYWxyZWFkeSBsb2FkaW5nXG5cdCAgICAgICAgX21vZHVsZXNbbW9kdWxlXS5wdXNoKHByb21pc2UpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBwcm9taXNlLnJlc29sdmUoKTtcblxuXHQgIHJldHVybiBwcm9taXNlO1xuXHR9XG5cblx0dmFyIGV4Y2VsID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgIHRvT2JqZWN0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKCFkYXRhLmV4Y2VsKSB7XG5cdCAgICAgIHZhciBvcHRzID0gZGF0YS5vcHRpb25zIHx8IHt9O1xuXHQgICAgICBpZiAob3B0cy5kYXRhdXJsKSBleHBvcnRzLmV4dGVuZChvcHRzLCB0aGlzLl91cmxUb09wdGlvbnMob3B0cy5kYXRhdXJsKSk7XG5cdCAgICAgIGRhdGEgPSBkYXRhLmRhdGEgfHwgZGF0YTtcblx0ICAgICAgdmFyIHByb21pc2UgPSBEZWZlcnJlZC5kZWZlcigpO1xuXG5cdCAgICAgIGlmIChkYXRhLm5hbWUpIHtcblx0ICAgICAgICAvL2ZpbGVcblx0ICAgICAgICBvcHRzLmV4dCA9IGRhdGEubmFtZS5zcGxpdChcIi5cIikucG9wKCk7XG5cdCAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzLnBhcnNlRGF0YShlLnRhcmdldC5yZXN1bHQsIG9wdHMpKTtcblx0ICAgICAgICB9LCB0aGlzKTtcblx0ICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG5cdCAgICAgIH0gZWxzZSAvL2FycmF5YnVmZmVyXG5cdCAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHRoaXMucGFyc2VEYXRhKGRhdGEsIG9wdHMpKTtcblxuXHQgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH0gLy9wbGFpbiBqc2FycmF5IG9yIGhhc2hcblxuXG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIHBhcnNlRGF0YTogZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICAgIHZhciBhcnIgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgIT0gZGF0YS5sZW5ndGg7ICsraSkge1xuXHQgICAgICBhcnJbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZXh0ID0gKG9wdGlvbnMuZXh0IHx8IG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBpZiAoZXh0ICE9IFwieGxzXCIpIGV4dCA9IFwieGxzeFwiO1xuXHQgICAgcmV0dXJuIHJlcXVpcmUoZW52LmNkbiArIFwiL2V4dHJhcy94bHN4LmNvcmUuc3R5bGVzLm1pbi5qc1wiKS50aGVuKGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAvKiBnbG9iYWwgWExTLCBYTFNYICovXG5cdCAgICAgIHZhciB3YiA9IGV4dCA9PSBcInhsc1wiID8gWExTLnJlYWQoYXJyLmpvaW4oXCJcIiksIHtcblx0ICAgICAgICB0eXBlOiBcImJpbmFyeVwiLFxuXHQgICAgICAgIGNlbGxTdHlsZXM6IHRydWUsXG5cdCAgICAgICAgY2VsbERhdGVzOiB0cnVlXG5cdCAgICAgIH0pIDogWExTWC5yZWFkKGFyci5qb2luKFwiXCIpLCB7XG5cdCAgICAgICAgdHlwZTogXCJiaW5hcnlcIixcblx0ICAgICAgICBjZWxsU3R5bGVzOiB0cnVlLFxuXHQgICAgICAgIGNlbGxEYXRlczogdHJ1ZVxuXHQgICAgICB9KTtcblx0ICAgICAgdmFyIHJlcyA9IHtcblx0ICAgICAgICBzaGVldHM6IHdiLlNoZWV0cyxcblx0ICAgICAgICBuYW1lczogd2IuU2hlZXROYW1lcyxcblx0ICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuXHQgICAgICAgIHJhbmdlczogd2IuV29ya2Jvb2sgPyB3Yi5Xb3JrYm9vay5OYW1lcyB8fCBbXSA6IFtdXG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh0aGlzLmdldFNoZWV0KHJlcywgb3B0aW9ucyksIHJlcyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgfSxcblx0ICBnZXRTaGVldDogZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IGRhdGEubmFtZXNbMF07XG5cdCAgICBkYXRhID0gdGhpcy5zaGVldFRvQXJyYXkoZGF0YS5zaGVldHNbbmFtZV0sIG9wdGlvbnMpO1xuXHQgICAgaWYgKG9wdGlvbnMucm93cyAmJiBvcHRpb25zLnJvd3MubGVuZ3RoKSBkYXRhLmRhdGEgPSBkYXRhLmRhdGEuc3BsaWNlKG9wdGlvbnMucm93c1swXSwgTWF0aC5taW4ob3B0aW9ucy5yb3dzWzFdLCBkYXRhLmRhdGEubGVuZ3RoKSAtIG9wdGlvbnMucm93c1swXSk7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIHNoZWV0VG9BcnJheTogZnVuY3Rpb24gKHNoZWV0LCBvcHRpb25zKSB7XG5cdCAgICB2YXIgYWxsID0gW107XG5cdCAgICB2YXIgc3BhbnMgPSBbXTtcblx0ICAgIHZhciBzdHlsZXMgPSBbXTtcblx0ICAgIHZhciBzaXplcyA9IFtdO1xuXG5cdCAgICBpZiAoc2hlZXQgJiYgc2hlZXRbXCIhcmVmXCJdKSB7XG5cdCAgICAgIHZhciByYW5nZSA9IFhMUy51dGlscy5kZWNvZGVfcmFuZ2Uoc2hlZXRbXCIhcmVmXCJdKSxcblx0ICAgICAgICAgIHJvdyxcblx0ICAgICAgICAgIGNvbCxcblx0ICAgICAgICAgIGNlbGxDb29yZCxcblx0ICAgICAgICAgIGNlbGwsXG5cdCAgICAgICAgICB4Q29ycmVjdGlvbiA9IHJhbmdlLnMuYyxcblx0ICAgICAgICAgIHlDb3JyZWN0aW9uID0gcmFuZ2Uucy5yICsgKG9wdGlvbnMucm93cyA/IG9wdGlvbnMucm93c1swXSA6IDApO1xuXG5cdCAgICAgIGZvciAocm93ID0gcmFuZ2Uucy5yOyByb3cgPD0gcmFuZ2UuZS5yOyByb3crKykge1xuXHQgICAgICAgIHZhciBucm93ID0gW107XG5cblx0ICAgICAgICBmb3IgKGNvbCA9IHJhbmdlLnMuYzsgY29sIDw9IHJhbmdlLmUuYzsgY29sKyspIHtcblx0ICAgICAgICAgIGNlbGxDb29yZCA9IFhMUy51dGlscy5lbmNvZGVfY2VsbCh7XG5cdCAgICAgICAgICAgIHI6IHJvdyxcblx0ICAgICAgICAgICAgYzogY29sXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIGNlbGwgPSBzaGVldFtjZWxsQ29vcmRdO1xuXHQgICAgICAgICAgaWYgKCFjZWxsKSBucm93LnB1c2goXCJcIik7ZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBuY2VsbCA9IFwiXCI7XG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGggJiYgY2VsbC5mKSAvLyBnZXQgZm9ybXVsYVxuXHQgICAgICAgICAgICAgIG5jZWxsID0gY2VsbC5mLmNoYXJBdCgwKSA9PSBcIj1cIiA/IGNlbGwuZiA6IFwiPVwiICsgY2VsbC5mO2Vsc2UgaWYgKGNlbGwudCA9PSBcImRcIiAmJiBpc0RhdGUoY2VsbC52KSkgbmNlbGwgPSBpMThuLmRhdGVGb3JtYXRTdHIoY2VsbC52KTtlbHNlIG5jZWxsID0gY2VsbC52O1xuXHQgICAgICAgICAgICBucm93LnB1c2gobmNlbGwpO1xuXHQgICAgICAgICAgICBpZiAoY2VsbC5zKSBzdHlsZXMucHVzaChbcm93IC0geUNvcnJlY3Rpb24sIGNvbCAtIHhDb3JyZWN0aW9uLCBjZWxsLnNdKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBhbGwucHVzaChucm93KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzaGVldFtcIiFtZXJnZXNcIl0pIHtcblx0ICAgICAgICB2YXIgbWVyZ2VzID0gc2hlZXRbXCIhbWVyZ2VzXCJdO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXJnZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciBzID0gbWVyZ2VzW2ldLnM7XG5cdCAgICAgICAgICB2YXIgZSA9IG1lcmdlc1tpXS5lO1xuXHQgICAgICAgICAgaWYgKCFvcHRpb25zLnJvd3MgfHwgcy5yIC0geUNvcnJlY3Rpb24gPj0gMCAmJiBlLnIgLSB5Q29ycmVjdGlvbiA8PSBvcHRpb25zLnJvd3NbMV0pIHNwYW5zLnB1c2goW3MuciAtIHlDb3JyZWN0aW9uLCBzLmMgLSB4Q29ycmVjdGlvbiwgZS5jIC0gcy5jICsgMSwgZS5yIC0gcy5yICsgMV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzaGVldFtcIiFjb2xzXCJdKSB7XG5cdCAgICAgICAgdmFyIHdpZHRocyA9IHNoZWV0W1wiIWNvbHNcIl07XG5cblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgd2lkdGhzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgaWYgKHdpZHRoc1tfaV0pIHNpemVzLnB1c2goW1wiY29sdW1uXCIsIF9pIC0geENvcnJlY3Rpb24sIE1hdGgucm91bmQod2lkdGhzW19pXS53Y2ggLyAoOC40MyAvIDcwKSldKTtcblx0ICAgICAgICB9IC8vbW9kZSwgY29saW5kLCB2YWx1ZVxuXG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoc2hlZXRbXCIhcm93c1wiXSkge1xuXHQgICAgICAgIHZhciBoZWlnaHRzID0gc2hlZXRbXCIhcm93c1wiXTtcblxuXHQgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGhlaWdodHMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgaWYgKGhlaWdodHNbX2kyXSkgc2l6ZXMucHVzaChbXCJyb3dcIiwgX2kyIC0geUNvcnJlY3Rpb24sIGhlaWdodHNbX2kyXS5ocHhdKTtcblx0ICAgICAgICB9IC8vbW9kZSAoXCJyb3dcIiwgXCJjb2x1bW5cIiksIHJvd2luZCwgdmFsdWVcblxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGRhdGE6IGFsbCxcblx0ICAgICAgc3BhbnM6IHNwYW5zLFxuXHQgICAgICBzdHlsZXM6IHN0eWxlcyxcblx0ICAgICAgc2l6ZXM6IHNpemVzLFxuXHQgICAgICBleGNlbDogdHJ1ZVxuXHQgICAgfTtcblx0ICB9LFxuXHQgIF91cmxUb09wdGlvbnM6IGZ1bmN0aW9uIChkZXRhaWxzKSB7XG5cdCAgICB2YXIgcGFydHMgPSBkZXRhaWxzLnNwbGl0KFwiW1wiKTtcblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICBvcHRpb25zLm5hbWUgPSBwYXJ0c1swXTtcblxuXHQgICAgaWYgKHBhcnRzWzFdKSB7XG5cdCAgICAgIHZhciByb3dzID0gcGFydHNbMV0uc3BsaXQoL1teMC05XSsvZyk7XG5cdCAgICAgIHJvd3NbMF0gPSByb3dzWzBdICogMSB8fCAwO1xuXHQgICAgICByb3dzWzFdID0gcm93c1sxXSAqIDEgfHwgOTk5OTk5OTtcblx0ICAgICAgb3B0aW9ucy5yb3dzID0gcm93cztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgfVxuXHR9LCBqc2FycmF5KTtcblxuXHR2YXIgRGF0YURyaXZlciA9IHtcblx0ICBqc29uOiBqc29uLFxuXHQgIGpzYXJyYXk6IGpzYXJyYXksXG5cdCAgeG1sOiB4bWwsXG5cdCAgY3N2OiBjc3YsXG5cdCAgaHRtbDogaHRtbCxcblx0ICBodG1sdGFibGU6IGh0bWx0YWJsZSxcblx0ICBleGNlbDogZXhjZWxcblx0fTtcblxuXHR2YXIgc3RvcmFnZSA9IHt9O1xuXG5cdHN0b3JhZ2UucHJlZml4ID0gZnVuY3Rpb24gKHNjb3BlLCBzdG9yYWdlKSB7XG5cdCAgc2NvcGUgPSBzY29wZSArIFwiLlwiO1xuXHQgIHJldHVybiB7XG5cdCAgICBwdXQ6IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG5cdCAgICAgIHJldHVybiBzdG9yYWdlLnB1dChzY29wZSArIG5hbWUsIGRhdGEpO1xuXHQgICAgfSxcblx0ICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0KHNjb3BlICsgbmFtZSk7XG5cdCAgICB9LFxuXHQgICAgcmVtb3ZlOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICByZXR1cm4gc3RvcmFnZS5yZW1vdmUoc2NvcGUgKyBuYW1lKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9O1xuXG5cdHN0b3JhZ2UubG9jYWwgPSB7XG5cdCAgcHV0OiBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuXHQgICAgaWYgKG5hbWUgJiYgd2luZG93LkpTT04gJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuXHQgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgc3RyaW5naWZ5KGRhdGEpKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIGlmIChuYW1lICYmIHdpbmRvdy5KU09OICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcblx0ICAgICAgdmFyIGpzb24gPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG5cdCAgICAgIGlmICghanNvbikgcmV0dXJuIG51bGw7XG5cdCAgICAgIHJldHVybiBEYXRhRHJpdmVyLmpzb24udG9PYmplY3QoanNvbik7XG5cdCAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICByZW1vdmU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICBpZiAobmFtZSAmJiB3aW5kb3cuSlNPTiAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG5cdCAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCk7XG5cdCAgfVxuXHR9O1xuXHRzdG9yYWdlLnNlc3Npb24gPSB7XG5cdCAgcHV0OiBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuXHQgICAgaWYgKG5hbWUgJiYgd2luZG93LkpTT04gJiYgd2luZG93LnNlc3Npb25TdG9yYWdlKSB7XG5cdCAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHN0cmluZ2lmeShkYXRhKSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICBpZiAobmFtZSAmJiB3aW5kb3cuSlNPTiAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIHtcblx0ICAgICAgdmFyIGpzb24gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcblx0ICAgICAgaWYgKCFqc29uKSByZXR1cm4gbnVsbDtcblx0ICAgICAgcmV0dXJuIERhdGFEcml2ZXIuanNvbi50b09iamVjdChqc29uKTtcblx0ICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIHJlbW92ZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIGlmIChuYW1lICYmIHdpbmRvdy5KU09OICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZSkge1xuXHQgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuY2xlYXIoKTtcblx0ICB9XG5cdH07XG5cdHN0b3JhZ2UuY29va2llID0ge1xuXHQgIHB1dDogZnVuY3Rpb24gKG5hbWUsIGRhdGEsIGRvbWFpbiwgZXhwaXJlcykge1xuXHQgICAgaWYgKG5hbWUgJiYgd2luZG93LkpTT04pIHtcblx0ICAgICAgZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiICsgZXNjYXBlKHN0cmluZ2lmeShkYXRhKSkgKyAoZXhwaXJlcyAmJiBleHBpcmVzIGluc3RhbmNlb2YgRGF0ZSA/IFwiO2V4cGlyZXM9XCIgKyBleHBpcmVzLnRvVVRDU3RyaW5nKCkgOiBcIlwiKSArIChkb21haW4gPyBcIjtkb21haW49XCIgKyBkb21haW4gOiBcIlwiKSArIChlbnYuaHR0cHMgPyBcIjtzZWN1cmVcIiA6IFwiXCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0UmF3OiBmdW5jdGlvbiAoY2hlY2tfbmFtZSkge1xuXHQgICAgLy8gZmlyc3Qgd2UnbGwgc3BsaXQgdGhpcyBjb29raWUgdXAgaW50byBuYW1lL3ZhbHVlIHBhaXJzXG5cdCAgICAvLyBub3RlOiBkb2N1bWVudC5jb29raWUgb25seSByZXR1cm5zIG5hbWU9dmFsdWUsIG5vdCB0aGUgb3RoZXIgY29tcG9uZW50c1xuXHQgICAgdmFyIGFfYWxsX2Nvb2tpZXMgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpO1xuXHQgICAgdmFyIGFfdGVtcF9jb29raWUgPSBcIlwiO1xuXHQgICAgdmFyIGNvb2tpZV9uYW1lID0gXCJcIjtcblx0ICAgIHZhciBjb29raWVfdmFsdWUgPSBcIlwiO1xuXHQgICAgdmFyIGJfY29va2llX2ZvdW5kID0gZmFsc2U7IC8vIHNldCBib29sZWFuIHQvZiBkZWZhdWx0IGZcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhX2FsbF9jb29raWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vIG5vdyB3ZSdsbCBzcGxpdCBhcGFydCBlYWNoIG5hbWU9dmFsdWUgcGFpclxuXHQgICAgICBhX3RlbXBfY29va2llID0gYV9hbGxfY29va2llc1tpXS5zcGxpdChcIj1cIik7IC8vIGFuZCB0cmltIGxlZnQvcmlnaHQgd2hpdGVzcGFjZSB3aGlsZSB3ZSdyZSBhdCBpdFxuXG5cdCAgICAgIGNvb2tpZV9uYW1lID0gYV90ZW1wX2Nvb2tpZVswXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTsgLy8gaWYgdGhlIGV4dHJhY3RlZCBuYW1lIG1hdGNoZXMgcGFzc2VkIGNoZWNrX25hbWVcblxuXHQgICAgICBpZiAoY29va2llX25hbWUgPT0gY2hlY2tfbmFtZSkge1xuXHQgICAgICAgIGJfY29va2llX2ZvdW5kID0gdHJ1ZTsgLy8gd2UgbmVlZCB0byBoYW5kbGUgY2FzZSB3aGVyZSBjb29raWUgaGFzIG5vIHZhbHVlIGJ1dCBleGlzdHMgKG5vID0gc2lnbiwgdGhhdCBpcyk6XG5cblx0ICAgICAgICBpZiAoYV90ZW1wX2Nvb2tpZS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICBjb29raWVfdmFsdWUgPSB1bmVzY2FwZShhX3RlbXBfY29va2llWzFdLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpKTtcblx0ICAgICAgICB9IC8vIG5vdGUgdGhhdCBpbiBjYXNlcyB3aGVyZSBjb29raWUgaXMgaW5pdGlhbGl6ZWQgYnV0IG5vIHZhbHVlLCBudWxsIGlzIHJldHVybmVkXG5cblxuXHQgICAgICAgIHJldHVybiBjb29raWVfdmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBhX3RlbXBfY29va2llID0gbnVsbDtcblx0ICAgICAgY29va2llX25hbWUgPSBcIlwiO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWJfY29va2llX2ZvdW5kKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIGlmIChuYW1lICYmIHdpbmRvdy5KU09OKSB7XG5cdCAgICAgIHZhciBqc29uID0gdGhpcy5nZXRSYXcobmFtZSk7XG5cdCAgICAgIGlmICghanNvbikgcmV0dXJuIG51bGw7XG5cdCAgICAgIHJldHVybiBEYXRhRHJpdmVyLmpzb24udG9PYmplY3QodW5lc2NhcGUoanNvbikpO1xuXHQgICAgfSBlbHNlIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgcmVtb3ZlOiBmdW5jdGlvbiAobmFtZSwgZG9tYWluKSB7XG5cdCAgICBpZiAobmFtZSAmJiB0aGlzLmdldFJhdyhuYW1lKSkgZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiICsgKGRvbWFpbiA/IFwiO2RvbWFpbj1cIiArIGRvbWFpbiA6IFwiXCIpICsgXCI7ZXhwaXJlcz1UaHUsIDAxLUphbi0xOTcwIDAwOjAwOjAxIEdNVFwiO1xuXHQgIH0sXG5cdCAgY2xlYXI6IGZ1bmN0aW9uIChkb21haW4pIHtcblx0ICAgIHZhciBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRvY3VtZW50LmNvb2tpZSA9IC9eW149XSsvLmV4ZWMoY29va2llc1tpXSlbMF0gKyBcIj1cIiArIChkb21haW4gPyBcIjtkb21haW49XCIgKyBkb21haW4gOiBcIlwiKSArIFwiO2V4cGlyZXM9VGh1LCAwMS1KYW4tMTk3MCAwMDowMDowMSBHTVRcIjtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIHByb3h5JDcgPSB7XG5cdCAgJHByb3h5OiB0cnVlLFxuXHQgIHN0b3JhZ2U6IHN0b3JhZ2UubG9jYWwsXG5cdCAgY2FjaGU6IGZhbHNlLFxuXHQgIGxvY2FsOiBmYWxzZSxcblx0ICBkYXRhOiBcIlwiLFxuXHQgIF9pc19vZmZsaW5lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuY2FjaGUgJiYgIWVudi5vZmZsaW5lKSB7XG5cdCAgICAgIGNhbGxFdmVudChcIm9uT2ZmbGluZU1vZGVcIiwgW10pO1xuXHQgICAgICBlbnYub2ZmbGluZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaXNfb25saW5lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuY2FjaGUgJiYgZW52Lm9mZmxpbmUpIHtcblx0ICAgICAgZW52Lm9mZmxpbmUgPSBmYWxzZTtcblx0ICAgICAgY2FsbEV2ZW50KFwib25PbmxpbmVNb2RlXCIsIFtdKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9vbl9zdWNjZXNzOiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgdGhpcy5faXNfb25saW5lKCk7XG5cblx0ICAgIHRoaXMuc2V0Q2FjaGUodGV4dCk7XG5cdCAgfSxcblx0ICBfb25fZXJyb3I6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICAvL2Fzc3VtaW5nIG9mZmxpbmUgbW9kZVxuXHQgICAgdGhpcy5faXNfb2ZmbGluZSgpO1xuXG5cdCAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0Q2FjaGUoKSB8fCB0aGlzLmRhdGE7XG5cdCAgICB2aWV3LnBhcnNlKHRleHQpO1xuXHQgIH0sXG5cdCAgbG9hZDogZnVuY3Rpb24gKHZpZXcpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIC8vaW4gY2FjaGUgbW9kZSAtIGFsd2F5cyBsb2FkIGRhdGEgZnJvbSBjYWNoZVxuXHQgICAgaWYgKHRoaXMuY2FjaGUgJiYgdGhpcy5nZXRDYWNoZSgpKSB7XG5cdCAgICAgIHRoaXMuX29uX2Vycm9yKHZpZXcpO1xuXHQgICAgfSAvL2Vsc2UgdHJ5IHRvIGxvYWQgYWN0dWFsIGRhdGEgZmlyc3Rcblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgaWYgKHRoaXMuc291cmNlLiRwcm94eSkgcmVzdWx0ID0gdGhpcy5zb3VyY2UubG9hZCh2aWV3KTtlbHNlIHJlc3VsdCA9IGFqYXgoKS5nZXQodGhpcy5zb3VyY2UpO1xuXG5cdCAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHQgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX29uX3N1Y2Nlc3MoZGF0YS50ZXh0KCkpO1xuXHQgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBfdGhpcy5fb25fZXJyb3Iodmlldyk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9XG5cdCAgfSxcblx0ICBnZXRDYWNoZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQodGhpcy5fZGF0YV9uYW1lKCkpO1xuXHQgIH0sXG5cdCAgY2xlYXJDYWNoZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLl9kYXRhX25hbWUoKSk7XG5cdCAgfSxcblx0ICBzZXRDYWNoZTogZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgIHRoaXMuc3RvcmFnZS5wdXQodGhpcy5fZGF0YV9uYW1lKCksIHRleHQpO1xuXHQgIH0sXG5cdCAgX2RhdGFfbmFtZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuc291cmNlLiRwcm94eSkgcmV0dXJuIHRoaXMuc291cmNlLnNvdXJjZSArIFwiXyRwcm94eSRfZGF0YVwiO2Vsc2UgcmV0dXJuIHRoaXMuc291cmNlICsgXCJfJHByb3h5JF9kYXRhXCI7XG5cdCAgfSxcblx0ICBzYXZlOiBmdW5jdGlvbiAobWFzdGVyLCBkYXRhLCB2aWV3KSB7XG5cdCAgICBpZiAoIWVudi5vZmZsaW5lICYmICF0aGlzLmNhY2hlKSB7XG5cdCAgICAgIGlmICh0aGlzLnNvdXJjZS4kcHJveHkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2F2ZShtYXN0ZXIsIGRhdGEsIHZpZXcpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBhamF4KCkucG9zdCh0aGlzLnNvdXJjZSwgZGF0YS5kYXRhKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgc2F2ZUFsbDogZnVuY3Rpb24gKHZpZXcsIHVwZGF0ZSkge1xuXHQgICAgdGhpcy5zZXRDYWNoZSh2aWV3LnNlcmlhbGl6ZSgpKTtcblx0ICAgIHVwZGF0ZSA9IHRoaXMuY2FjaGUgfHwgZW52Lm9mZmxpbmUgPyB1cGRhdGUgOiBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdXBkYXRlW2ldID0ge1xuXHQgICAgICAgIGlkOiB1cGRhdGVbaV0uaWQsXG5cdCAgICAgICAgc3RhdHVzOiB1cGRhdGVbaV0ub3BlcmF0aW9uXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBEZWZlcnJlZC5yZXNvbHZlKHVwZGF0ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcm94eSQ4ID0ge1xuXHQgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIHByb3h5JDcpO1xuXHQgIH0sXG5cdCAgY2FjaGU6IHRydWVcblx0fTtcblxuXHR2YXIgcHJveHkkOSA9IHtcblx0ICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBwcm94eSQ3KTtcblx0ICB9LFxuXHQgIGNhY2hlOiB0cnVlLFxuXHQgIGxvY2FsOiB0cnVlLFxuXHQgIGRhdGE6IFtdXG5cdH07XG5cblx0ZnVuY3Rpb24gdW5ib3goZGF0YSkge1xuXHQgIGlmICghZGF0YSB8fCAhX3R5cGVvZihkYXRhKSA9PT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gZGF0YTtcblx0ICB2YXIgbGtleSA9IFwiXCI7XG5cdCAgdmFyIGNvdW50ID0gMDtcblxuXHQgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdCAgICBjb3VudCsrO1xuXHQgICAgaWYgKGNvdW50ID09IDIpIHJldHVybiBkYXRhO1xuXHQgICAgbGtleSA9IGtleTtcblx0ICB9XG5cblx0ICByZXR1cm4gZGF0YVtsa2V5XTtcblx0fVxuXG5cdHZhciBHcmFwaFFMID0ge1xuXHQgICRwcm94eTogdHJ1ZSxcblx0ICBzYXZlOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgcmV0dXJuIHRoaXMubG9hZChkYXRhKTtcblx0ICB9LFxuXHQgIGxvYWQ6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICB2YXIgcGFyYW1zID0ge1xuXHQgICAgICBxdWVyeTogdGhpcy5zb3VyY2Vcblx0ICAgIH07XG5cblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIHBhcmFtcy52YXJpYWJsZXMgPSB2aWV3O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWpheCgpLmhlYWRlcnMoe1xuXHQgICAgICBcIkNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuXHQgICAgfSkucG9zdCh0aGlzLnVybCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgIHJldHVybiB1bmJveChkYXRhLmpzb24oKS5kYXRhKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBwcm94eSRhKG5hbWUsIHNvdXJjZSwgZXh0cmEpIHtcblx0ICBhc3NlcnQocHJveHkkYVtuYW1lXSwgXCJJbnZhbGlkIHByb3h5IG5hbWU6IFwiICsgbmFtZSk7XG5cdCAgdmFyIGNvcHkkJDEgPSBjb3B5KHByb3h5JGFbbmFtZV0pO1xuXHQgIGNvcHkkJDEuc291cmNlID0gc291cmNlO1xuXHQgIGlmIChleHRyYSkgZXhwb3J0cy5leHRlbmQoY29weSQkMSwgZXh0cmEsIHRydWUpO1xuXHQgIGlmIChjb3B5JCQxLmluaXQpIGNvcHkkJDEuaW5pdCgpO1xuXHQgIHJldHVybiBjb3B5JCQxO1xuXHR9XG5cblx0cHJveHkkYS4kcGFyc2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgJiYgdmFsdWUuaW5kZXhPZihcIi0+XCIpICE9IC0xKSB7XG5cdCAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdChcIi0+XCIpO1xuXHQgICAgcmV0dXJuIHByb3h5JGEocGFydHNbMF0sIHBhcnRzWzFdKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0cHJveHkkYS5iaW5hcnkgPSBwcm94eTtcblx0cHJveHkkYS5jb25uZWN0b3IgPSBwcm94eSQxO1xuXHRwcm94eSRhLmRlYnVnID0gcHJveHkkMjtcblx0cHJveHkkYS5mYXllID0gcHJveHkkMztcblx0cHJveHkkYS5pbmRleGRiID0gaW5kZXhkYjtcblx0cHJveHkkYS5qc29uID0gcHJveHkkNTtcblx0cHJveHkkYS5wb3N0ID0gcHJveHkkNjtcblx0cHJveHkkYS5yZXN0ID0gcHJveHkkNDtcblx0cHJveHkkYS5vZmZsaW5lID0gcHJveHkkNztcblx0cHJveHkkYS5jYWNoZSA9IHByb3h5JDg7XG5cdHByb3h5JGEubG9jYWwgPSBwcm94eSQ5O1xuXHRwcm94eSRhLmxvY2FsID0gcHJveHkkOTtcblx0cHJveHkkYS5HcmFwaFFMID0gR3JhcGhRTDtcblxuXHR2YXIgQXRvbURhdGFMb2FkZXIgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIC8vcHJlcGFyZSBkYXRhIHN0b3JlXG5cdCAgICB0aGlzLmRhdGEgPSB7fTtcblx0ICAgIHRoaXMud2FpdERhdGEgPSBEZWZlcnJlZC5kZWZlcigpO1xuXHQgICAgaWYgKGNvbmZpZykgdGhpcy5fc2V0dGluZ3MuZGF0YXR5cGUgPSBjb25maWcuZGF0YXR5cGUgfHwgXCJqc29uXCI7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX2xvYWRfd2hlbl9yZWFkeSk7XG5cdCAgfSxcblx0ICBfbG9hZF93aGVuX3JlYWR5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9yZWFkeV9mb3JfZGF0YSA9IHRydWU7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudXJsKSB0aGlzLnVybF9zZXR0ZXIodGhpcy5fc2V0dGluZ3MudXJsKTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5kYXRhKSB0aGlzLmRhdGFfc2V0dGVyKHRoaXMuX3NldHRpbmdzLmRhdGEpO1xuXHQgIH0sXG5cdCAgdXJsX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHByb3h5JGEuJHBhcnNlKHZhbHVlKTtcblx0ICAgIGlmICghdGhpcy5fcmVhZHlfZm9yX2RhdGEpIHJldHVybiB2YWx1ZTtcblx0ICAgIHRoaXMubG9hZCh2YWx1ZSwgdGhpcy5fc2V0dGluZ3MuZGF0YXR5cGUpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgZGF0YV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKCF0aGlzLl9yZWFkeV9mb3JfZGF0YSkgcmV0dXJuIHZhbHVlO1xuXHQgICAgdGhpcy5wYXJzZSh2YWx1ZSwgdGhpcy5fc2V0dGluZ3MuZGF0YXR5cGUpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICAvL2xvYWRzIGRhdGEgZnJvbSBleHRlcm5hbCBVUkxcblx0ICBsb2FkOiBmdW5jdGlvbiAodXJsLCBjYWxsKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICB2YXIgZGV0YWlscyA9IGFyZ3VtZW50c1syXSB8fCBudWxsO1xuXHQgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlTG9hZFwiLCBbXSkpIHJldHVybiBEZWZlcnJlZC5yZWplY3QoKTtcblxuXHQgICAgaWYgKHR5cGVvZiBjYWxsID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgLy9zZWNvbmQgcGFyYW1ldGVyIGNhbiBiZSBhIGxvYWRpbmcgdHlwZSBvciBjYWxsYmFja1xuXHQgICAgICAvL3dlIGFyZSBub3QgdXNpbmcgc2V0RHJpdmVyIGFzIGRhdGEgbWF5IGJlIGEgbm9uLWRhdGFzdG9yZSBoZXJlXG5cdCAgICAgIHRoaXMuZGF0YS5kcml2ZXIgPSBEYXRhRHJpdmVyW2NhbGxdO1xuXHQgICAgICBjYWxsID0gYXJndW1lbnRzWzJdO1xuXHQgICAgfSBlbHNlIGlmICghdGhpcy5kYXRhLmRyaXZlcikgdGhpcy5kYXRhLmRyaXZlciA9IERhdGFEcml2ZXIuanNvbjtcblxuXHQgICAgdmFyIHJlc3VsdDsgLy9wcm94eVx0XG5cblx0ICAgIHVybCA9IHByb3h5JGEuJHBhcnNlKHVybCk7XG5cblx0ICAgIGlmICh1cmwuJHByb3h5ICYmIHVybC5sb2FkKSB7XG5cdCAgICAgIHJlc3VsdCA9IHVybC5sb2FkKHRoaXMsIGRldGFpbHMpO1xuXHQgICAgfSAvL3Byb21pemVcblx0ICAgIGVsc2UgaWYgKHR5cGVvZiB1cmwgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgIHJlc3VsdCA9IHVybC5jYWxsKHRoaXMsIGRldGFpbHMpO1xuXHQgICAgICB9IC8vbm9ybWFsIHVybFxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IGFqYXgoKS5iaW5kKHRoaXMpLmdldCh1cmwpO1xuXHQgICAgICAgIH0gLy93ZSB3cmFwIHBsYWluIGRhdGEgaW4gcHJvbWlzZSB0byBrZWVwIHRoZSBzYW1lIHByb2Nlc3NpbmcgZm9yIGl0XG5cblxuXHQgICAgaWYgKHJlc3VsdCAmJiAhcmVzdWx0LnRoZW4pIHtcblx0ICAgICAgcmVzdWx0ID0gRGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdCAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgaWYgKF90aGlzLiRkZXN0cnVjdGVkKSByZXR1cm47XG5cblx0ICAgICAgICBfdGhpcy5fb25Mb2FkKGRhdGEpO1xuXG5cdCAgICAgICAgaWYgKGNhbGwpIGFqYXguJGNhbGxiYWNrKF90aGlzLCBjYWxsLCBcIlwiLCBkYXRhLCAtMSk7XG5cdCAgICAgIH0sIGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgX3RoaXMuX29uTG9hZEVycm9yKHgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9LFxuXHQgIC8vbG9hZHMgZGF0YSBmcm9tIG9iamVjdFxuXHQgIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkge1xuXHQgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEudGhlbiA9PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgcmV0dXJuIGRhdGEudGhlbihiaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5wYXJzZShkYXRhLCB0eXBlKTtcblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgfSAvL2xvYWRpbmcgZGF0YSBmcm9tIG90aGVyIGNvbXBvbmVudFxuXG5cblx0ICAgIGlmIChkYXRhICYmIGRhdGEuc3luYyAmJiB0aGlzLnN5bmMpIHJldHVybiB0aGlzLl9zeW5jRGF0YShkYXRhKTtcblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUxvYWRcIiwgW10pKSByZXR1cm4gRGVmZXJyZWQucmVqZWN0KCk7XG5cdCAgICB0aGlzLmRhdGEuZHJpdmVyID0gRGF0YURyaXZlclt0eXBlIHx8IFwianNvblwiXTtcblxuXHQgICAgdGhpcy5fb25Mb2FkKGRhdGEpO1xuXHQgIH0sXG5cdCAgX3N5bmNEYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKHRoaXMuZGF0YSkgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TeW5jQXBwbHlcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jYWxsX29ucmVhZHkpIHRoaXMuX2NhbGxfb25yZWFkeSgpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgdGhpcy5zeW5jKGRhdGEpO1xuXHQgIH0sXG5cdCAgX3BhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIHBhcnNlZCxcblx0ICAgICAgICByZWNvcmQsXG5cdCAgICAgICAgZHJpdmVyID0gdGhpcy5kYXRhLmRyaXZlcjtcblx0ICAgIHJlY29yZCA9IGRyaXZlci5nZXRSZWNvcmRzKGRhdGEpWzBdO1xuXHQgICAgcGFyc2VkID0gcmVjb3JkID8gZHJpdmVyLmdldERldGFpbHMocmVjb3JkKSA6IHt9O1xuXHQgICAgaWYgKHRoaXMuc2V0VmFsdWVzKSB0aGlzLnNldFZhbHVlcyhwYXJzZWQpO2Vsc2UgdGhpcy5kYXRhID0gcGFyc2VkO1xuXHQgIH0sXG5cdCAgX29uTG9hZENvbnRpbnVlOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKGRhdGEpIHtcblx0ICAgICAgaWYgKCF0aGlzLiRvbkxvYWQgfHwgIXRoaXMuJG9uTG9hZChkYXRhLCB0aGlzLmRhdGEuZHJpdmVyKSkge1xuXHQgICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLl9wYXJzZSkgdGhpcy5kYXRhLl9wYXJzZShkYXRhKTsgLy9kYXRhc3RvcmVcblx0ICAgICAgICBlbHNlIHRoaXMuX3BhcnNlKGRhdGEpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgdGhpcy5fb25Mb2FkRXJyb3IoZGF0YSk7IC8vZGF0YSBsb2FkZWQsIHZpZXcgcmVuZGVyZWQsIGNhbGwgb25yZWFkeSBoYW5kbGVyXG5cblxuXHQgICAgaWYgKHRoaXMuX2NhbGxfb25yZWFkeSkgdGhpcy5fY2FsbF9vbnJlYWR5KCk7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJMb2FkXCIsIFtdKTtcblx0ICAgIHRoaXMud2FpdERhdGEucmVzb2x2ZSgpO1xuXHQgIH0sXG5cdCAgLy9kZWZhdWx0IGFmdGVyIGxvYWRpbmcgY2FsbGJhY2tcblx0ICBfb25Mb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhLnRleHQgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICBkYXRhID0gZGF0YS50ZXh0KCk7XG5cdCAgICB9XG5cblx0ICAgIGRhdGEgPSB0aGlzLmRhdGEuZHJpdmVyLnRvT2JqZWN0KGRhdGEpO1xuXHQgICAgaWYgKGRhdGEgJiYgZGF0YS50aGVuKSBkYXRhLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgX3RoaXMyLl9vbkxvYWRDb250aW51ZShkYXRhKTtcblx0ICAgIH0pO2Vsc2UgdGhpcy5fb25Mb2FkQ29udGludWUoZGF0YSk7XG5cdCAgfSxcblx0ICBfb25Mb2FkRXJyb3I6IGZ1bmN0aW9uICh4aHR0cCkge1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyTG9hZFwiLCBbXSk7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uTG9hZEVycm9yXCIsIGFyZ3VtZW50cyk7XG5cdCAgICBjYWxsRXZlbnQoXCJvbkxvYWRFcnJvclwiLCBbeGh0dHAsIHRoaXNdKTtcblx0ICB9LFxuXHQgIF9jaGVja19kYXRhX2ZlZWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmRhdGFGZWVkIHx8IHRoaXMuX2lnbm9yZV9mZWVkIHx8ICFkYXRhKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHZhciB1cmwgPSB0aGlzLl9zZXR0aW5ncy5kYXRhRmVlZDtcblx0ICAgIGlmICh0eXBlb2YgdXJsID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHVybC5jYWxsKHRoaXMsIGRhdGEuaWQgfHwgZGF0YSwgZGF0YSk7XG5cdCAgICB1cmwgPSB1cmwgKyAodXJsLmluZGV4T2YoXCI/XCIpID09IC0xID8gXCI/XCIgOiBcIiZcIikgKyBcImFjdGlvbj1nZXQmaWQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YS5pZCB8fCBkYXRhKTtcblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUxvYWRcIiwgW10pKSByZXR1cm4gZmFsc2U7XG5cdCAgICBhamF4KHVybCwgZnVuY3Rpb24gKHRleHQsIHhtbCwgbG9hZGVyKSB7XG5cdCAgICAgIHRoaXMuX2lnbm9yZV9mZWVkID0gdHJ1ZTtcblx0ICAgICAgdmFyIGRyaXZlciA9IERhdGFEcml2ZXIuanNvbjtcblx0ICAgICAgdmFyIGRhdGEgPSBkcml2ZXIudG9PYmplY3QodGV4dCwgeG1sKTtcblx0ICAgICAgaWYgKGRhdGEpIHRoaXMuc2V0VmFsdWVzKGRyaXZlci5nZXREZXRhaWxzKGRyaXZlci5nZXRSZWNvcmRzKGRhdGEpWzBdKSk7ZWxzZSB0aGlzLl9vbkxvYWRFcnJvcihsb2FkZXIpO1xuXHQgICAgICB0aGlzLl9pZ25vcmVfZmVlZCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJMb2FkXCIsIFtdKTtcblx0ICAgIH0sIHRoaXMpO1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgQXRvbVJlbmRlciA9IHtcblx0ICAvL2NvbnZlcnQgaXRlbSB0byB0aGUgSFRNTCB0ZXh0XG5cdCAgX3RvSFRNTDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgaWYgKG9iai4kZW1wdHkpIHJldHVybiBcIlwiO1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnRlbXBsYXRlKG9iaiwgdGhpcyk7XG5cdCAgfSxcblx0ICAvL3JlbmRlciBzZWxmLCBieSB0ZW1wbGF0aW5nIGRhdGEgb2JqZWN0XG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY2ZnID0gdGhpcy5fc2V0dGluZ3M7XG5cblx0ICAgIGlmICh0aGlzLmlzVmlzaWJsZShjZmcuaWQpKSB7XG5cdCAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQgfHwgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGhpcy5kYXRhXSkpIHtcblx0ICAgICAgICBpZiAodGhpcy5kYXRhICYmICFjZmcuY29udGVudCkge1xuXHQgICAgICAgICAgLy9pdCBpcyBjcml0aWNhbCB0byBoYXZlIHRoaXMgYXMgdHdvIGNvbW1hbmRzXG5cdCAgICAgICAgICAvL2l0cyBwcmV2ZW50IGRlc3RydWN0aW9uIHJhY2UgaW4gQ2hyb21lXG5cdCAgICAgICAgICB0aGlzLl9kYXRhb2JqLmlubmVySFRNTCA9IFwiXCI7XG5cdCAgICAgICAgICB0aGlzLl9kYXRhb2JqLmlubmVySFRNTCA9IHRoaXMuX3RvSFRNTCh0aGlzLmRhdGEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0aGlzLmNhbGxFdmVudCkgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFtdKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBzeW5jOiBmdW5jdGlvbiAoc291cmNlKSB7XG5cdCAgICB0aGlzLl9iYWNrYm9uZV9zeW5jID0gZmFsc2U7XG5cblx0ICAgIGlmIChzb3VyY2UubmFtZSAhPSBcIkRhdGFTdG9yZVwiKSB7XG5cdCAgICAgIGlmIChzb3VyY2UuZGF0YSAmJiBzb3VyY2UubmFtZSA9PSBcIkRhdGFTdG9yZVwiKSB7XG5cdCAgICAgICAgc291cmNlID0gc291cmNlLmRhdGE7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fYmFja2JvbmVfc3luYyA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX2JhY2tib25lX3N5bmMpIHNvdXJjZS5iaW5kKFwiY2hhbmdlXCIsIGJpbmQoZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgaWYgKGRhdGEuaWQgPT0gdGhpcy5kYXRhLmlkKSB7XG5cdCAgICAgICAgdGhpcy5kYXRhID0gZGF0YS5hdHRyaWJ1dGVzO1xuXHQgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKSk7ZWxzZSBzb3VyY2UuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBpZiAoIWlkIHx8IGlkID09IHRoaXMuZGF0YS5pZCkge1xuXHQgICAgICAgIHRoaXMuZGF0YSA9IHNvdXJjZS5wdWxsW2lkXTtcblx0ICAgICAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcykpO1xuXHQgIH0sXG5cdCAgdGVtcGxhdGVfc2V0dGVyOiB0ZW1wbGF0ZVxuXHR9O1xuXG5cdHZhciBBdXRvU2Nyb2xsID0ge1xuXHQgIF9hdXRvX3Njcm9sbDogZnVuY3Rpb24gKHBvcyQkMSkge1xuXHQgICAgdmFyIHlzY3JvbGwgPSAxO1xuXHQgICAgdmFyIHhzY3JvbGwgPSAwO1xuXHQgICAgdmFyIG1vZGUgPSB0aGlzLl9zZXR0aW5ncy5kcmFnc2Nyb2xsO1xuXG5cdCAgICBpZiAodHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICB4c2Nyb2xsID0gbW9kZS5pbmRleE9mKFwieFwiKSAhPSAtMTtcblx0ICAgICAgeXNjcm9sbCA9IG1vZGUuaW5kZXhPZihcInlcIikgIT0gLTE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkYXRhID0gdGhpcy5fYm9keSB8fCB0aGlzLiR2aWV3O1xuXHQgICAgdmFyIGJveCA9IG9mZnNldChkYXRhKTtcblx0ICAgIHZhciB0b3AgPSBib3gueTtcblx0ICAgIHZhciBib3R0b20gPSB0b3AgKyBkYXRhLm9mZnNldEhlaWdodDtcblx0ICAgIHZhciBsZWZ0ID0gYm94Lng7XG5cdCAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgZGF0YS5vZmZzZXRXaWR0aDtcblx0ICAgIHZhciBzY3JvbGwgPSB0aGlzLmdldFNjcm9sbFN0YXRlKCk7XG5cdCAgICB2YXIgcmVzZXQgPSBmYWxzZTtcblx0ICAgIHZhciBzZW5zZSA9IE1hdGgubWF4KHRoaXMudHlwZSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh0aGlzLnR5cGUuaGVpZ2h0KSkgPyB0aGlzLnR5cGUuaGVpZ2h0ICsgNSA6IDAsIDQwKTsgLy9kbmQgYXV0by1zY3JvbGwgc2Vuc2l2aXR5XG5cblx0ICAgIGlmICh5c2Nyb2xsKSB7XG5cdCAgICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblxuXHQgICAgICBpZiAoY29uZmlnLnRvcFNwbGl0KSB7XG5cdCAgICAgICAgdmFyIHRvcFNwbGl0UG9zID0gdGhpcy5fY2VsbFBvc2l0aW9uKHRoaXMuZ2V0SWRCeUluZGV4KGNvbmZpZy50b3BTcGxpdCAtIDEpLCB0aGlzLmNvbHVtbklkKDApKTtcblxuXHQgICAgICAgIHRvcCArPSB0b3BTcGxpdFBvcy50b3AgKyB0b3BTcGxpdFBvcy5oZWlnaHQ7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocG9zJCQxLnkgPCB0b3AgKyBzZW5zZSkge1xuXHQgICAgICAgIHRoaXMuX2F1dG9fc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55IC0gc2Vuc2UgKiAyLCBwb3MkJDEpO1xuXG5cdCAgICAgICAgcmVzZXQgPSB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKHBvcyQkMS55ID4gYm90dG9tIC0gc2Vuc2UpIHtcblx0ICAgICAgICB0aGlzLl9hdXRvX3Njcm9sbFRvKHNjcm9sbC54LCBzY3JvbGwueSArIHNlbnNlICogMiwgcG9zJCQxKTtcblxuXHQgICAgICAgIHJlc2V0ID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoeHNjcm9sbCkge1xuXHQgICAgICBpZiAocG9zJCQxLnggPCBsZWZ0ICsgc2Vuc2UpIHtcblx0ICAgICAgICB0aGlzLl9hdXRvX3Njcm9sbFRvKHNjcm9sbC54IC0gc2Vuc2UgKiAyLCBzY3JvbGwueSwgcG9zJCQxKTtcblxuXHQgICAgICAgIHJlc2V0ID0gdHJ1ZTtcblx0ICAgICAgfSBlbHNlIGlmIChwb3MkJDEueCA+IHJpZ2h0IC0gc2Vuc2UpIHtcblx0ICAgICAgICB0aGlzLl9hdXRvX3Njcm9sbFRvKHNjcm9sbC54ICsgc2Vuc2UgKiAyLCBzY3JvbGwueSwgcG9zJCQxKTtcblxuXHQgICAgICAgIHJlc2V0ID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzZXQpIHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5ID0gZGVsYXkodGhpcy5fYXV0b19zY3JvbGwsIHRoaXMsIFtwb3MkJDFdLCAxMDApO1xuXHQgIH0sXG5cdCAgX2F1dG9fc2Nyb2xsVG86IGZ1bmN0aW9uICh4LCB5LCBwb3MkJDEpIHtcblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQXV0b1Njcm9sbFwiLCBbcG9zJCQxXSkpIHRoaXMuc2Nyb2xsVG8oeCwgeSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBUb29sdGlwQ29udHJvbCA9IHtcblx0ICBfdG9vbHRpcF9tYXN0ZXJzOiB0b0FycmF5KFtcImR1bW15XCJdKSxcblx0ICBfdG9vbHRpcF9leGlzdDogMCxcblx0ICBkZWxheTogNDAwLFxuXHQgIGFkZFRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQsIGNvbmZpZykge1xuXHQgICAgdmFyIG5vZGUsIGN0cmw7XG5cdCAgICB0YXJnZXQgPSB0b05vZGUodGFyZ2V0KTtcblx0ICAgIGFzc2VydCh0YXJnZXQsIFwiVGFyZ2V0IGlzbid0IGRlZmluZWRcIik7XG5cblx0ICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG5cdCAgICAgIG5vZGUgPSB0YXJnZXQ7XG5cdCAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSBcInN0cmluZ1wiKSBub2RlLnNldEF0dHJpYnV0ZShcIndlYml4X3Rvb2x0aXBcIiwgY29uZmlnKTtlbHNlIGN0cmwgPSBjb25maWc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBub2RlID0gdGFyZ2V0LiR2aWV3O1xuXHQgICAgICBjdHJsID0gdGFyZ2V0O1xuXHQgICAgfVxuXG5cdCAgICBjdHJsID0gY3RybCB8fCB0aGlzO1xuXG5cdCAgICB2YXIgaW5kZXgkJDEgPSB0aGlzLl90b29sdGlwX21hc3RlcnMuZmluZChjdHJsKTtcblxuXHQgICAgaWYgKGluZGV4JCQxID09PSAtMSkge1xuXHQgICAgICBpbmRleCQkMSA9IHRoaXMuX3Rvb2x0aXBfbWFzdGVycy5sZW5ndGg7XG5cblx0ICAgICAgdGhpcy5fdG9vbHRpcF9tYXN0ZXJzLnB1c2goY3RybCk7XG5cdCAgICB9XG5cblx0ICAgIG5vZGUud2ViaXhfdG9vbHRpcCA9IGluZGV4JCQxO1xuXHQgICAgdGhpcy5fdG9vbHRpcF9leGlzdCsrO1xuXG5cdCAgICBpZiAoIXRoaXMuX3Rvb2x0aXApIHtcblx0ICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyB1aS50b29sdGlwKHt9KTtcblx0ICAgICAgdGhpcy5fd2ViaXhfdG9vbHRpcF9tbSA9IGV2ZW50JDEoZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmVfdG9vbHRpcCwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMuX3dlYml4X3Rvb2x0aXBfbWwgPSBldmVudCQxKGRvY3VtZW50LCBcIm1vdXNlbGVhdmVcIiwgdGhpcy5faGlkZV90b29sdGlwLCB7XG5cdCAgICAgICAgYmluZDogdGhpc1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5fZHJhZ19ldmVudCA9IGF0dGFjaEV2ZW50KFwib25EcmFnTW9kZVwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKFRvb2x0aXBDb250cm9sLl90b29sdGlwX2V4aXN0KSBUb29sdGlwQ29udHJvbC5faGlkZV90b29sdGlwKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0VG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cdCAgfSxcblx0ICBfbW92ZV90b29sdGlwOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIG5vZGUgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cdCAgICB2YXIgdGV4dDtcblxuXHQgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50YWdOYW1lICE9IFwiSFRNTFwiKSB7XG5cdCAgICAgIGlmIChub2RlLndlYml4X3Rvb2x0aXApIHtcblx0ICAgICAgICBpZiAodGhpcy5fbGFzdCAmJiB0aGlzLl9sYXN0ICE9IG5vZGUpIHtcblx0ICAgICAgICAgIHRoaXMuJHRvb2x0aXBPdXQodGhpcy5fbGFzdCwgbm9kZSwgZSk7XG5cdCAgICAgICAgICB0aGlzLl9sYXN0ID0gbnVsbDtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXRoaXMuX2xhc3QpIHRoaXMuX2xhc3QgPSB0aGlzLiR0b29sdGlwSW4obm9kZSwgZSk7XG5cdCAgICAgICAgdGhpcy4kdG9vbHRpcE1vdmUobm9kZSwgZSwgdGV4dCk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGV4dCA9IHRleHQgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoXCJ3ZWJpeF90b29sdGlwXCIpO1xuXHQgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fbGFzdCkgdGhpcy5fbGFzdCA9IHRoaXMuJHRvb2x0aXBPdXQodGhpcy5fbGFzdCwgbnVsbCwgZSk7XG5cdCAgfSxcblx0ICBfaGlkZV90b29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBjbGVhclRpbWVvdXQodGhpcy5fYmVmb3JlX3Nob3dfZGVsYXkpO1xuXG5cdCAgICB0aGlzLl90b29sdGlwLmhpZGUoKTtcblx0ICB9LFxuXHQgIGdldE1hc3RlcjogZnVuY3Rpb24gKHQpIHtcblx0ICAgIHJldHVybiB0aGlzLl90b29sdGlwX21hc3RlcnNbdC53ZWJpeF90b29sdGlwXTtcblx0ICB9LFxuXHQgIHJlbW92ZVRvb2x0aXA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgIHZhciBub2RlO1xuXHQgICAgYXNzZXJ0KHRhcmdldCwgXCJUYXJnZXQgaXNuJ3QgZGVmaW5lZFwiKTtcblx0ICAgIHRhcmdldCA9IHRvTm9kZSh0YXJnZXQpO1xuXHQgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIG5vZGUgPSB0YXJnZXQ7ZWxzZSBub2RlID0gdGFyZ2V0LiR2aWV3O1xuXG5cdCAgICBpZiAobm9kZS53ZWJpeF90b29sdGlwKSB7XG5cdCAgICAgIGRlbGV0ZSBub2RlLndlYml4X3Rvb2x0aXA7XG5cdCAgICAgIHRoaXMuX3Rvb2x0aXBfZXhpc3QtLTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLl90b29sdGlwX2V4aXN0ICYmIHRoaXMuX3Rvb2x0aXApIHtcblx0ICAgICAgdGhpcy5fd2ViaXhfdG9vbHRpcF9tbSA9IGV2ZW50UmVtb3ZlKHRoaXMuX3dlYml4X3Rvb2x0aXBfbW0pO1xuXHQgICAgICB0aGlzLl93ZWJpeF90b29sdGlwX21sID0gZXZlbnRSZW1vdmUodGhpcy5fd2ViaXhfdG9vbHRpcF9tbCk7XG5cdCAgICAgIHRoaXMuX2RyYWdfZXZlbnQgPSBkZXRhY2hFdmVudCh0aGlzLl9kcmFnX2V2ZW50KTtcblxuXHQgICAgICB0aGlzLl90b29sdGlwLmRlc3RydWN0b3IoKTtcblxuXHQgICAgICB0aGlzLl90b29sdGlwID0gdGhpcy5fbGFzdCA9IG51bGw7XG5cdCAgICAgIHRoaXMuX3Rvb2x0aXBfbWFzdGVycyA9IHRvQXJyYXkoW1wiZHVtbXlcIl0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHRvb2x0aXBJbjogZnVuY3Rpb24gKHQsIGUpIHtcblx0ICAgIHZhciBtID0gdGhpcy5fdG9vbHRpcF9tYXN0ZXJzW3Qud2ViaXhfdG9vbHRpcF07XG5cdCAgICBpZiAobS4kdG9vbHRpcEluICYmIG0gIT0gdGhpcykgcmV0dXJuIG0uJHRvb2x0aXBJbih0LCBlKTtcblxuXHQgICAgdGhpcy5fdG9vbHRpcC5kZWZpbmUoe1xuXHQgICAgICBkeDogMjAsXG5cdCAgICAgIGR5OiAwLFxuXHQgICAgICB0ZW1wbGF0ZTogdC5nZXRBdHRyaWJ1dGUoXCJ3ZWJpeF90b29sdGlwXCIpIHx8IFwiXCIsXG5cdCAgICAgIGNzczogXCJcIlxuXHQgICAgfSk7XG5cblx0ICAgIHJldHVybiB0O1xuXHQgIH0sXG5cdCAgJHRvb2x0aXBPdXQ6IGZ1bmN0aW9uICh0LCBuLCBlKSB7XG5cdCAgICB2YXIgbSA9IHRoaXMuX3Rvb2x0aXBfbWFzdGVyc1t0LndlYml4X3Rvb2x0aXBdO1xuXHQgICAgaWYgKG0uJHRvb2x0aXBPdXQgJiYgbSAhPSB0aGlzKSByZXR1cm4gbS4kdG9vbHRpcE91dCh0LCBuLCBlKTtcblxuXHQgICAgdGhpcy5faGlkZV90b29sdGlwKCk7XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgJHRvb2x0aXBNb3ZlOiBmdW5jdGlvbiAodCwgZSwgdGV4dCkge1xuXHQgICAgdmFyIG0gPSB0aGlzLl90b29sdGlwX21hc3RlcnNbdC53ZWJpeF90b29sdGlwXTtcblx0ICAgIGlmIChtLiR0b29sdGlwTW92ZSAmJiBtICE9IHRoaXMpIHJldHVybiBtLiR0b29sdGlwTW92ZSh0LCBlLCB0ZXh0KTtcblxuXHQgICAgdGhpcy5fdG9vbHRpcC5oaWRlKCk7XG5cblx0ICAgIGNsZWFyVGltZW91dCh0aGlzLl9iZWZvcmVfc2hvd19kZWxheSk7XG5cdCAgICB0aGlzLl9iZWZvcmVfc2hvd19kZWxheSA9IGRlbGF5KHRoaXMuX3Rvb2x0aXAuc2hvdywgdGhpcy5fdG9vbHRpcCwgW3RleHQgfHwge30sIHBvcyhlKV0sIHRoaXMuZGVsYXkpO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBfdWlkKG5hbWUpIHtcblx0ICByZXR1cm4gXCIkXCIgKyBuYW1lICsgKF9uYW1lY291bnRbbmFtZV0gPSAoX25hbWVjb3VudFtuYW1lXSB8fCAwKSArIDEpO1xuXHR9XG5cdHZhciBfbmFtZWNvdW50ID0ge307XG5cdHZhciBfZnJlZXplX3Jlc2l6ZSA9IGZhbHNlO1xuXHRmdW5jdGlvbiBmcmVlemUoaGFuZGxlciwgdHJpZ2dlcikge1xuXHQgIF9mcmVlemVfcmVzaXplID0gdHJ1ZTtcblx0ICB2YXIgcmVzID0gaGFuZGxlcigpO1xuXG5cdCAgaWYgKHJlcyAmJiByZXMudGhlbikge1xuXHQgICAgcmVzID0gcmVzLnRoZW4oZnVuY3Rpb24gKGFueSkge1xuXHQgICAgICBfZnJlZXplX3Jlc2l6ZSA9IGZhbHNlO1xuXHQgICAgICBpZiAodHJpZ2dlciAhPT0gZmFsc2UpIHJlc2l6ZSgpO1xuXHQgICAgICByZXR1cm4gYW55O1xuXHQgICAgfSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIF9mcmVlemVfcmVzaXplID0gZmFsc2U7XG5cdCAgICBpZiAodHJpZ2dlciAhPT0gZmFsc2UpIHJlc2l6ZSgpO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0ZnVuY3Rpb24gcmVzaXplKCkge1xuXHQgIHVzZShcIlVJTWFuYWdlclwiKS5hcHBseUNoYW5nZXMoKTtcblx0ICBjYWxsRXZlbnQoXCJvbkNsaWNrXCIsIFtdKTtcblx0ICBzdGF0ZS5fZm9yY2VfcmVzaXplID0gdHJ1ZTtcblx0ICBpZiAoIV9mcmVlemVfcmVzaXplKSBmb3IgKHZhciBpID0gc3RhdGUudG9wX3ZpZXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICBpZiAoc3RhdGUudG9wX3ZpZXdzW2ldLm9iaikgc3RhdGUudG9wX3ZpZXdzW2ldLm9iai5yZXNpemUoKTtcblx0ICB9XG5cdCAgc3RhdGUuX2ZvcmNlX3Jlc2l6ZSA9IGZhbHNlO1xuXHR9XG5cdGZ1bmN0aW9uIGVhY2gocGFyZW50LCBsb2dpYywgbWFzdGVyLCBpbmNsdWRlKSB7XG5cdCAgaWYgKHBhcmVudCkge1xuXHQgICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZSA/IFtwYXJlbnRdIDogcGFyZW50LmdldENoaWxkVmlld3MoKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAobG9naWMuY2FsbChtYXN0ZXIsIGNoaWxkcmVuW2ldKSAhPT0gZmFsc2UpIGVhY2goY2hpbGRyZW5baV0sIGxvZ2ljLCBtYXN0ZXIpO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiB6SW5kZXgoKSB7XG5cdCAgcmV0dXJuIGVudi56SW5kZXhCYXNlKys7XG5cdH1cblx0ZXZlbnQkMSh3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAvLyBjaGVjayBmb3IgdmlydHVhbCBrZXlib2FyZFxuXHQgIGlmIChlbnYudG91Y2ggJiYgKHN0YXRlLl9mb2N1c190aW1lICYmIG5ldyBEYXRlKCkgLSBzdGF0ZS5fZm9jdXNfdGltZSA8IDEwMDApKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJlc2l6ZSgpO1xuXHQgIH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gcmVhZHkoY29kZSkge1xuXHQgIGlmIChfcmVhZHkpIGNvZGUuY2FsbCgpO2Vsc2UgX3JlYWR5X2NvZGUucHVzaChjb2RlKTtcblx0fVxuXG5cdHZhciBfcmVhZHkgPSBmYWxzZTtcblx0dmFyIF9yZWFkeV9jb2RlID0gW107IC8vYXV0b2RldGVjdCBjb2RlYmFzZSBmb2xkZXJcblxuXHR2YXIgdGVtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiU0NSSVBUXCIpOyAvL2N1cnJlbnQgc2NyaXB0LCBtb3N0IHByb2JhYmx5XG5cblx0YXNzZXJ0KHRlbXAubGVuZ3RoLCBcIkNhbid0IGxvY2F0ZSBjb2RlYmFzZVwiKTtcblxuXHRpZiAodGVtcC5sZW5ndGgpIHtcblx0ICAvL2Z1bGwgcGF0aCB0byBzY3JpcHRcblx0ICB0ZW1wID0gKHRlbXBbdGVtcC5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCJcIikuc3BsaXQoXCIvXCIpOyAvL2dldCBmb2xkZXIgbmFtZVxuXG5cdCAgdGVtcC5zcGxpY2UodGVtcC5sZW5ndGggLSAxLCAxKTtcblx0ICBlbnYuY29kZWJhc2UgPSB0ZW1wLnNsaWNlKDAsIHRlbXAubGVuZ3RoKS5qb2luKFwiL1wiKSArIFwiL1wiO1xuXHR9XG5cblx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKGVudi5pc0lFKSBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9pZVwiO1xuXHQgIGNhbGxFdmVudChcIm9uUmVhZHlcIiwgW10pO1xuXHR9O1xuXG5cdHZhciBkb2l0ID0gZnVuY3Rpb24gKCkge1xuXHQgIF9yZWFkeSA9IHRydWU7XG5cdCAgLyogZ2xvYmFsIHdlYml4X3JlYWR5ICovXG5cblx0ICBpZiAod2luZG93LndlYml4X3JlYWR5ICYmIGlzQXJyYXkod2ViaXhfcmVhZHkpKSBfcmVhZHlfY29kZSA9IHdlYml4X3JlYWR5LmNvbmNhdChfcmVhZHlfY29kZSk7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IF9yZWFkeV9jb2RlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBfcmVhZHlfY29kZVtpXS5jYWxsKCk7XG5cdCAgfVxuXG5cdCAgX3JlYWR5X2NvZGUgPSBbXTtcblx0fTtcblxuXHRhdHRhY2hFdmVudChcIm9uUmVhZHlcIiwgZnVuY3Rpb24gKGZvcmNlKSB7XG5cdCAgaWYgKGZvcmNlKSBkb2l0KCk7ZWxzZSBkZWxheShkb2l0KTtcblx0fSk7XG5cdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikgaGFuZGxlcigpO2Vsc2UgZXZlbnQkMSh3aW5kb3csIFwibG9hZFwiLCBoYW5kbGVyKTtcblx0cmVhZHkoZnVuY3Rpb24gKCkge1xuXHQgIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgY2FsbEV2ZW50KFwib25DbGlja1wiLCBbZSB8fCBldmVudCQxXSk7XG5cdCAgfSk7XG5cdH0pO1xuXG5cdHZhciBVSU1hbmFnZXIgPSB7XG5cdCAgX3ZpZXc6IG51bGwsXG5cdCAgX2hvdGtleXM6IHt9LFxuXHQgIF9mb2N1c190aW1lOiAwLFxuXHQgIF90YWJfdGltZTogMCxcblx0ICBfbW91c2VfdGltZTogMCxcblx0ICBfY29udHJvbHM6IHtcblx0ICAgIFwiZW50ZXJcIjogMTMsXG5cdCAgICBcInRhYlwiOiA5LFxuXHQgICAgXCJlc2NcIjogMjcsXG5cdCAgICBcImVzY2FwZVwiOiAyNyxcblx0ICAgIFwidXBcIjogMzgsXG5cdCAgICBcImRvd25cIjogNDAsXG5cdCAgICBcImxlZnRcIjogMzcsXG5cdCAgICBcInJpZ2h0XCI6IDM5LFxuXHQgICAgXCJwZ2Rvd25cIjogMzQsXG5cdCAgICBcInBhZ2Vkb3duXCI6IDM0LFxuXHQgICAgXCJwZ3VwXCI6IDMzLFxuXHQgICAgXCJwYWdldXBcIjogMzMsXG5cdCAgICBcImVuZFwiOiAzNSxcblx0ICAgIFwiaG9tZVwiOiAzNixcblx0ICAgIFwiaW5zZXJ0XCI6IDQ1LFxuXHQgICAgXCJkZWxldGVcIjogNDYsXG5cdCAgICBcImJhY2tzcGFjZVwiOiA4LFxuXHQgICAgXCJzcGFjZVwiOiAzMixcblx0ICAgIFwibWV0YVwiOiA5MSxcblx0ICAgIFwid2luXCI6IDkxLFxuXHQgICAgXCJtYWNcIjogOTEsXG5cdCAgICBcIm11bHRpcGx5XCI6IDEwNixcblx0ICAgIFwiYWRkXCI6IDEwNyxcblx0ICAgIFwic3VidHJhY3RcIjogMTA5LFxuXHQgICAgXCJkZWNpbWFsXCI6IDExMCxcblx0ICAgIFwiZGl2aWRlXCI6IDExMSxcblx0ICAgIFwic2Nyb2xsb2NrXCI6IDE0NSxcblx0ICAgIFwicGF1c2VicmVha1wiOiAxOSxcblx0ICAgIFwibnVtbG9ja1wiOiAxNDQsXG5cdCAgICBcIjVudW1sb2NrZWRcIjogMTIsXG5cdCAgICBcInNoaWZ0XCI6IDE2LFxuXHQgICAgXCJjYXBzbG9ja1wiOiAyMFxuXHQgIH0sXG5cdCAgX2lucHV0czoge1xuXHQgICAgXCJpbnB1dFwiOiAxLFxuXHQgICAgXCJidXR0b25cIjogMSxcblx0ICAgIFwidGV4dGFyZWFcIjogMSxcblx0ICAgIFwic2VsZWN0XCI6IDFcblx0ICB9LFxuXHQgIF9lbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIGF0dGFjaGluZyBldmVudHMgaGVyZVxuXHQgICAgZXZlbnQkMShkb2N1bWVudC5ib2R5LCBcImNsaWNrXCIsIGJpbmQodGhpcy5fZm9jdXNfY2xpY2ssIHRoaXMpKTtcblx0ICAgIGV2ZW50JDEoZG9jdW1lbnQsIFwia2V5ZG93blwiLCBiaW5kKHRoaXMuX2tleXByZXNzLCB0aGlzKSk7XG5cblx0ICAgIF9ldmVudChkb2N1bWVudC5ib2R5LCBcIm1vdXNlZG93blwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fbW91c2VfdGltZSA9IG5ldyBEYXRlKCk7XG5cdCAgICB9LCB0aGlzKSk7XG5cblx0ICAgIGlmIChkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIpIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgXCJmb2N1c1wiLCB0aGlzLl9mb2N1c190YWIsIHtcblx0ICAgICAgY2FwdHVyZTogdHJ1ZSxcblx0ICAgICAgYmluZDogdGhpc1xuXHQgICAgfSk7XG5cdCAgICBzdGF0ZS5kZXN0cnVjdG9ycy5wdXNoKHtcblx0ICAgICAgb2JqOiB0aGlzXG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIFVJTWFuYWdlci5fdmlldyA9IG51bGw7XG5cdCAgfSxcblx0ICBnZXRGb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG5cdCAgfSxcblx0ICBfZm9jdXNfYWN0aW9uOiBmdW5jdGlvbiAodmlldykge1xuXHQgICAgdGhpcy5fZm9jdXNfd2FzX3RoZXJlID0gdGhpcy5fZm9jdXNfd2FzX3RoZXJlIHx8IHZpZXcuX3NldHRpbmdzLmlkO1xuXHQgIH0sXG5cdCAgc2V0Rm9jdXM6IGZ1bmN0aW9uICh2aWV3LCBvbmx5X2FwaSwgdGFiKSB7XG5cdCAgICAvL3ZpZXcgY2FuIGJlIGVtcHR5XG5cdCAgICB2aWV3ID0gJCQodmlldyk7IC8vdW5mb2N1cyBpZiB2aWV3IGlzIGhpZGRlblxuXG5cdCAgICBpZiAodmlldyAmJiAhdmlldy4kdmlldykgdmlldyA9IG51bGw7IC8vc3RvcmUgbGFzdCBjbGljayB0aW1lLCBpdCBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCByZWZvY3VzaW5nXG5cdCAgICAvL2ZvciBleGFtcGxlIHdoZW4gdXNlciBtb3ZlcyBmb2N1cyBmcm9tIG9uY2xpY2sgaGFuZGxlciBzb21ld2hlclxuXHQgICAgLy9hbmQgd2Ugd2FudCB0byBwcmV2ZW50IGF1dG9mb2N1c2luZywgd2hlbiBldmVudCB3aWxsIHJlYWNoIGRvY3VtZW50LmJvZHlcblxuXHQgICAgdGhpcy5fZm9jdXNfdGltZSA9IHN0YXRlLl9mb2N1c190aW1lID0gbmV3IERhdGUoKTtcblx0ICAgIGlmICh0aGlzLl92aWV3ID09PSB2aWV3KSByZXR1cm4gdHJ1ZTtcblx0ICAgIGlmICh0aGlzLl92aWV3ICYmIHRoaXMuX3ZpZXcuY2FsbEV2ZW50KSB0aGlzLl92aWV3LmNhbGxFdmVudChcIm9uQmx1clwiLCBbdGhpcy5fdmlld10pO1xuXG5cdCAgICBpZiAodmlldyAmJiB2aWV3LmNhbGxFdmVudCkge1xuXHQgICAgICB2aWV3LmNhbGxFdmVudChcIm9uRm9jdXNcIiwgW3ZpZXcsIHRoaXMuX3ZpZXddKTtcblx0ICAgICAgaWYgKHRhYikgdmlldy5jYWxsRXZlbnQoXCJvblRhYkZvY3VzXCIsIFt2aWV3LCB0aGlzLl92aWV3XSk7XG5cdCAgICB9XG5cblx0ICAgIGNhbGxFdmVudChcIm9uRm9jdXNDaGFuZ2VcIiwgW3ZpZXcsIHRoaXMuX3ZpZXddKTtcblx0ICAgIGlmICh0aGlzLl92aWV3ICYmIHRoaXMuX3ZpZXcuYmx1ciAmJiAhb25seV9hcGkpIHRoaXMuX3ZpZXcuYmx1cigpO1xuXHQgICAgdGhpcy5fdmlldyA9IHZpZXc7XG5cdCAgICBpZiAodmlldyAmJiB2aWV3LmZvY3VzICYmICFvbmx5X2FwaSkgdmlldy5mb2N1cygpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBhcHBseUNoYW5nZXM6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICB2YXIgdmlldyA9IHRoaXMuZ2V0Rm9jdXMoKTtcblx0ICAgIGlmICh2aWV3ICYmIHZpZXcgIT0gZWxlbWVudCAmJiB2aWV3Ll9hcHBseUNoYW5nZXMpIHZpZXcuX2FwcGx5Q2hhbmdlcyhlbGVtZW50KTtcblx0ICB9LFxuXHQgIGhhc0ZvY3VzOiBmdW5jdGlvbiAodmlldykge1xuXHQgICAgcmV0dXJuIHZpZXcgPT09IHRoaXMuX3ZpZXcgPyB0cnVlIDogZmFsc2U7XG5cdCAgfSxcblx0ICBfZm9jdXM6IGZ1bmN0aW9uIChlLCBkb250X2NsZWFyKSB7XG5cdCAgICB2YXIgdmlldyA9IGxvY2F0ZShlLCBcInZpZXdfaWRcIikgfHwgdGhpcy5fZm9jdXNfd2FzX3RoZXJlOyAvL2lmIGh0bWwgd2FzIHJlcGFpbnRlZCB3ZSBjYW4gbWlzcyB0aGUgdmlldywgc28gY2hlY2tpbmcgbGFzdCBwcm9jZXNzZWQgb25lXG5cblxuXHQgICAgdmlldyA9ICQkKHZpZXcpO1xuXHQgICAgdGhpcy5fZm9jdXNfd2FzX3RoZXJlID0gbnVsbDsgLy9zZXQgdGltZXIsIHRvIGZpeCBpc3N1ZSB3aXRoIEFuZHJvaWQgaW5wdXQgZm9jdXNpblxuXG5cdCAgICBzdGF0ZS5fZm9jdXNfdGltZSA9IG5ldyBEYXRlKCk7XG5cdCAgICBpZiAodmlldyA9PSB0aGlzLl92aWV3KSByZXR1cm47XG5cdCAgICBpZiAoIWRvbnRfY2xlYXIpIHRoaXMuX2ZvY3VzX3dhc190aGVyZSA9IG51bGw7XG5cblx0ICAgIGlmICh2aWV3KSB7XG5cdCAgICAgIHZpZXcgPSAkJCh2aWV3KTtcblxuXHQgICAgICBpZiAodGhpcy5jYW5Gb2N1cyh2aWV3KSkge1xuXHQgICAgICAgIC8vW0FDVElWRUNPTlRFTlRdIGZvY3VzIG9wZXJhdGlvbnMgZm9yIGFjdGl2ZSBjb250ZW50XG5cdCAgICAgICAgaWYgKHZpZXcuZ2V0Tm9kZSkgdmlldy5nZXROb2RlKGUpO1xuXHQgICAgICAgIHRoaXMuc2V0Rm9jdXModmlldyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoIWRvbnRfY2xlYXIpIHRoaXMuc2V0Rm9jdXMobnVsbCk7XG5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgX2ZvY3VzX2NsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgLy8gaWYgaXQgd2FzIG9uZm9jdXMvb25jbGljayBsZXNzIHRoZW4gMTAwbXMgYmVob3JlIHRoZW4gd2UgaWdub3JlIGl0XG5cdCAgICBpZiAobmV3IERhdGUoKSAtIHRoaXMuX2ZvY3VzX3RpbWUgPCAxMDApIHtcblx0ICAgICAgdGhpcy5fZm9jdXNfd2FzX3RoZXJlID0gbnVsbDtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fZm9jdXMoZSk7XG5cdCAgfSxcblx0ICBfZm9jdXNfdGFiOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKCF0aGlzLl9pbnB1dHNbZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pIHJldHVybiBmYWxzZTtcblx0ICAgIHJldHVybiB0aGlzLl9mb2N1cyhlLCB0cnVlKTtcblx0ICB9LFxuXHQgIGNhbkZvY3VzOiBmdW5jdGlvbiAodmlldykge1xuXHQgICAgcmV0dXJuIHZpZXcuaXNWaXNpYmxlKCkgJiYgdmlldy5pc0VuYWJsZWQoKSAmJiAhdmlldy5xdWVyeVZpZXcoe1xuXHQgICAgICBkaXNhYmxlZDogdHJ1ZVxuXHQgICAgfSwgXCJwYXJlbnRcIik7XG5cdCAgfSxcblx0ICBfbW92ZUNoaWxkRm9jdXM6IGZ1bmN0aW9uIChjaGVja192aWV3KSB7XG5cdCAgICB2YXIgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7IC8vd2UgaGF2ZSBub3QgZm9jdXMgaW5zaWRlIG9mIGNsb3NpbmcgaXRlbVxuXG5cdCAgICBpZiAoY2hlY2tfdmlldyAmJiAhdGhpcy5faXNfY2hpbGRfb2YoY2hlY2tfdmlldywgZm9jdXMpKSByZXR1cm4gZmFsc2U7XG5cdCAgICBpZiAoIXRoaXMuX2ZvY3VzX2xvZ2ljKFwiZ2V0UHJldlwiLCBjaGVja192aWV3KSkgdGhpcy5fdmlldyA9IG51bGw7XG5cdCAgfSxcblx0ICBfdHJhbnNsYXRpb25fdGFibGU6IHt9LFxuXHQgIF9pc19jaGlsZF9vZjogZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcblx0ICAgIGlmICghcGFyZW50KSByZXR1cm4gZmFsc2U7XG5cdCAgICBpZiAoIWNoaWxkKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIHdoaWxlIChjaGlsZCkge1xuXHQgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuIHRydWU7XG5cdCAgICAgIGNoaWxkID0gY2hpbGQuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBfa2V5cHJlc3NfdGltZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzICYmIHRoaXMuY2FsbEV2ZW50KSB0aGlzLmNhbGxFdmVudChcIm9uVGltZWRLZXlQcmVzc1wiLCBbXSk7XG5cdCAgfSxcblx0ICBfaXNOdW1QYWQ6IGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICByZXR1cm4gY29kZSA8IDExMiAmJiBjb2RlID4gMTA1O1xuXHQgIH0sXG5cdCAgX2tleXByZXNzOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIGNvZGUgPSBlLndoaWNoIHx8IGUua2V5Q29kZTtcblx0ICAgIGlmIChjb2RlID4gOTUgJiYgY29kZSA8IDEwNikgY29kZSAtPSA0ODsgLy9udW1wYWQgc3VwcG9ydCAobnVtYmVycylcblxuXHQgICAgY29kZSA9IHRoaXMuX3RyYW5zbGF0aW9uX3RhYmxlW2NvZGVdIHx8IGNvZGU7XG5cdCAgICB2YXIgY3RybCA9IGUuY3RybEtleTtcblx0ICAgIHZhciBzaGlmdCA9IGUuc2hpZnRLZXk7XG5cdCAgICB2YXIgYWx0ID0gZS5hbHRLZXk7XG5cdCAgICB2YXIgbWV0YSA9IGUubWV0YUtleTtcblxuXHQgICAgdmFyIGNvZGVpZCA9IHRoaXMuX2tleWNvZGUoY29kZSwgY3RybCwgc2hpZnQsIGFsdCwgbWV0YSk7XG5cblx0ICAgIHZhciB2aWV3ID0gdGhpcy5nZXRGb2N1cygpO1xuXG5cdCAgICBpZiAodmlldyAmJiB2aWV3LmNhbGxFdmVudCkge1xuXHQgICAgICBpZiAodmlldy5jYWxsRXZlbnQoXCJvbktleVByZXNzXCIsIFtjb2RlLCBlXSkgPT09IGZhbHNlKSBwcmV2ZW50RXZlbnQoZSk7XG5cblx0ICAgICAgaWYgKHZpZXcuaGFzRXZlbnQoXCJvblRpbWVkS2V5UHJlc3NcIikpIHtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodmlldy5fa2V5X3ByZXNzX3RpbWVvdXQpO1xuXHQgICAgICAgIHZpZXcuX2tleV9wcmVzc190aW1lb3V0ID0gZGVsYXkodGhpcy5fa2V5cHJlc3NfdGltZWQsIHZpZXcsIFtdLCB2aWV3Ll9zZXR0aW5ncy5rZXlQcmVzc1RpbWVvdXQgfHwgMjUwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuX2lzTnVtUGFkKGNvZGUpKSBjb2RlaWQgPSB0aGlzLl9rZXljb2RlKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksIGN0cmwsIHNoaWZ0LCBhbHQsIG1ldGEpOyAvL2ZsYWcsIHRoYXQgc29tZSBub24tc3BlY2lhbCBrZXkgd2FzIHByZXNzZWRcblxuXHQgICAgdmFyIGlzX2FueSA9ICFjdHJsICYmICFhbHQgJiYgIW1ldGEgJiYgY29kZSAhPSA5ICYmIGNvZGUgIT0gMjcgJiYgY29kZSAhPSAxMztcblxuXHQgICAgaWYgKHRoaXMuX2NoZWNrX2tleWNvZGUoY29kZWlkLCBpc19hbnksIGUpID09PSBmYWxzZSkge1xuXHQgICAgICBwcmV2ZW50RXZlbnQoZSk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vIGRpciAtIGdldE5leHQgb3IgZ2V0UHJldlxuXHQgIF9mb2N1c19sb2dpYzogZnVuY3Rpb24gKGRpcikge1xuXHQgICAgaWYgKCF0aGlzLmdldEZvY3VzKCkpIHJldHVybiBudWxsO1xuXHQgICAgZGlyID0gZGlyIHx8IFwiZ2V0TmV4dFwiO1xuXHQgICAgdmFyIG5leHQgPSB0aGlzLmdldEZvY3VzKCk7XG5cdCAgICB2YXIgc3RhcnQgPSBuZXh0O1xuXHQgICAgdmFyIG1hcmtlciA9IHVpZCgpO1xuXG5cdCAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdCAgICAgIG5leHQgPSB0aGlzW2Rpcl0obmV4dCk7IC8vIHZpZXcgd2l0aCBmb2N1cyBhYmlsaXR5XG5cblx0ICAgICAgaWYgKG5leHQgJiYgdGhpcy5jYW5Gb2N1cyhuZXh0KSkgcmV0dXJuIHRoaXMuc2V0Rm9jdXMobmV4dCk7IC8vIGVsZW1lbnRzIHdpdGggZm9jdXMgYWJpbGl0eSBub3QgZm91bmRcblxuXHQgICAgICBpZiAobmV4dCA9PT0gc3RhcnQgfHwgbmV4dC4kZm1hcmtlciA9PSBtYXJrZXIpIHJldHVybiBudWxsOyAvL3ByZXZlbnRzIGluZmluaXR5IGxvb3BcblxuXHQgICAgICBuZXh0LiRmbWFya2VyID0gbWFya2VyO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3RhYl9sb2dpYzogZnVuY3Rpb24gKHZpZXcsIGUpIHtcblx0ICAgIHZhciBtb2RlID0gIWUuc2hpZnRLZXk7XG5cdCAgICBVSU1hbmFnZXIuX3RhYl90aW1lID0gbmV3IERhdGUoKTtcblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuX2N1c3RvbV90YWJfaGFuZGxlciAmJiAhdmlldy5fY3VzdG9tX3RhYl9oYW5kbGVyKG1vZGUsIGUpKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuX2luX2VkaXRfbW9kZSkge1xuXHQgICAgICBpZiAodmlldy5lZGl0TmV4dCkgcmV0dXJuIHZpZXcuZWRpdE5leHQobW9kZSk7ZWxzZSBpZiAodmlldy5lZGl0U3RvcCkge1xuXHQgICAgICAgIHZpZXcuZWRpdFN0b3AoKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgVUlNYW5hZ2VyLnNldEZvY3VzKCQkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLCB0cnVlLCB0cnVlKTtcblx0ICAgIH0sIDEpO1xuXHQgIH0sXG5cdCAgZ2V0VG9wOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBuZXh0LFxuXHQgICAgICAgIHZpZXcgPSAkJChpZCk7XG5cblx0ICAgIHdoaWxlICh2aWV3ICYmIChuZXh0ID0gdmlldy5nZXRQYXJlbnRWaWV3KCkpKSB7XG5cdCAgICAgIHZpZXcgPSBuZXh0O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmlldztcblx0ICB9LFxuXHQgIGdldE5leHQ6IGZ1bmN0aW9uICh2aWV3LCBfaW5uZXJfY2FsbCkge1xuXHQgICAgdmFyIGNlbGxzID0gdmlldy5nZXRDaGlsZFZpZXdzKCk7IC8vdGFiIHRvIGZpcnN0IGNoaWxkcmVuXG5cblx0ICAgIGlmIChjZWxscy5sZW5ndGggJiYgIV9pbm5lcl9jYWxsKSByZXR1cm4gY2VsbHNbMF07IC8vdW5pcXVlIGNhc2UgLSBzaW5nbGUgdmlldyB3aXRob3V0IGNoaWxkIGFuZCBwYXJlbnRcblxuXHQgICAgdmFyIHBhcmVudCA9IHZpZXcuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgaWYgKCFwYXJlbnQpIHJldHVybiB2aWV3O1xuXHQgICAgdmFyIHBfY2VsbHMgPSBwYXJlbnQuZ2V0Q2hpbGRWaWV3cygpO1xuXG5cdCAgICBpZiAocF9jZWxscy5sZW5ndGgpIHtcblx0ICAgICAgdmFyIGluZGV4JCQxID0gUG93ZXJBcnJheS5maW5kLmNhbGwocF9jZWxscywgdmlldykgKyAxO1xuXG5cdCAgICAgIHdoaWxlIChpbmRleCQkMSA8IHBfY2VsbHMubGVuZ3RoKSB7XG5cdCAgICAgICAgLy9uZXh0IHZpc2libGUgY2hpbGRcblx0ICAgICAgICBpZiAodGhpcy5jYW5Gb2N1cyhwX2NlbGxzW2luZGV4JCQxXSkpIHJldHVybiBwX2NlbGxzW2luZGV4JCQxXTtcblx0ICAgICAgICBpbmRleCQkMSsrO1xuXHQgICAgICB9XG5cdCAgICB9IC8vc2libGluZyBvZiBwYXJlbnRcblxuXG5cdCAgICByZXR1cm4gdGhpcy5nZXROZXh0KHBhcmVudCwgdHJ1ZSk7XG5cdCAgfSxcblx0ICBnZXRQcmV2OiBmdW5jdGlvbiAodmlldywgX2lubmVyX2NhbGwpIHtcblx0ICAgIHZhciBjZWxscyA9IHZpZXcuZ2V0Q2hpbGRWaWV3cygpOyAvL2xhc3QgY2hpbGQgb2YgbGFzdCBjaGlsZFxuXG5cdCAgICBpZiAoY2VsbHMubGVuZ3RoICYmIF9pbm5lcl9jYWxsKSByZXR1cm4gdGhpcy5nZXRQcmV2KGNlbGxzW2NlbGxzLmxlbmd0aCAtIDFdLCB0cnVlKTtcblx0ICAgIGlmIChfaW5uZXJfY2FsbCkgcmV0dXJuIHZpZXc7IC8vZmFsbGJhY2sgZnJvbSB0b3AgdG8gYm90dG9tXG5cblx0ICAgIHZhciBwYXJlbnQgPSB2aWV3LmdldFBhcmVudFZpZXcoKTtcblx0ICAgIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5nZXRQcmV2KHZpZXcsIHRydWUpO1xuXHQgICAgdmFyIHBfY2VsbHMgPSBwYXJlbnQuZ2V0Q2hpbGRWaWV3cygpO1xuXG5cdCAgICBpZiAocF9jZWxscykge1xuXHQgICAgICB2YXIgaW5kZXgkJDEgPSBQb3dlckFycmF5LmZpbmQuY2FsbChwX2NlbGxzLCB2aWV3KSAtIDE7XG5cblx0ICAgICAgd2hpbGUgKGluZGV4JCQxID49IDApIHtcblx0ICAgICAgICBpZiAodGhpcy5jYW5Gb2N1cyhwX2NlbGxzW2luZGV4JCQxXSkpIHJldHVybiB0aGlzLmdldFByZXYocF9jZWxsc1tpbmRleCQkMV0sIHRydWUpO1xuXHQgICAgICAgIGluZGV4JCQxLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBhcmVudDtcblx0ICB9LFxuXHQgIGFkZEhvdEtleTogZnVuY3Rpb24gKGtleXMsIGhhbmRsZXIsIHZpZXcpIHtcblx0ICAgIGFzc2VydChoYW5kbGVyLCBcIkhvdCBrZXkgaGFuZGxlciBpcyBub3QgZGVmaW5lZFwiKTtcblxuXHQgICAgdmFyIHBhY2sgPSB0aGlzLl9wYXJzZV9rZXlzKGtleXMpO1xuXG5cdCAgICBhc3NlcnQocGFjay5sZXR0ZXIsIFwiVW5rbm93biBrZXkgY29kZVwiKTtcblx0ICAgIGlmICghdmlldykgdmlldyA9IG51bGw7XG5cdCAgICBwYWNrLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHQgICAgcGFjay52aWV3ID0gdmlldztcblxuXHQgICAgdmFyIGNvZGUgPSB0aGlzLl9rZXljb2RlKHBhY2subGV0dGVyLCBwYWNrLmN0cmwsIHBhY2suc2hpZnQsIHBhY2suYWx0LCBwYWNrLm1ldGEpO1xuXG5cdCAgICBpZiAoIXRoaXMuX2hvdGtleXNbY29kZV0pIHRoaXMuX2hvdGtleXNbY29kZV0gPSBbXTtcblxuXHQgICAgdGhpcy5faG90a2V5c1tjb2RlXS5wdXNoKHBhY2spO1xuXG5cdCAgICByZXR1cm4ga2V5cztcblx0ICB9LFxuXHQgIHJlbW92ZUhvdEtleTogZnVuY3Rpb24gKGtleXMsIGZ1bmMsIHZpZXcpIHtcblx0ICAgIHZhciBwYWNrID0gdGhpcy5fcGFyc2Vfa2V5cyhrZXlzKTtcblxuXHQgICAgdmFyIGNvZGUgPSB0aGlzLl9rZXljb2RlKHBhY2subGV0dGVyLCBwYWNrLmN0cmwsIHBhY2suc2hpZnQsIHBhY2suYWx0LCBwYWNrLm1ldGEpO1xuXG5cdCAgICBpZiAoIWZ1bmMgJiYgIXZpZXcpIGRlbGV0ZSB0aGlzLl9ob3RrZXlzW2NvZGVdO2Vsc2Uge1xuXHQgICAgICB2YXIgdCA9IHRoaXMuX2hvdGtleXNbY29kZV07XG5cblx0ICAgICAgaWYgKHQpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgaWYgKHZpZXcgJiYgdFtpXS52aWV3ICE9PSB2aWV3KSBjb250aW51ZTtcblx0ICAgICAgICAgIGlmIChmdW5jICYmIHRbaV0uaGFuZGxlciAhPT0gZnVuYykgY29udGludWU7XG5cdCAgICAgICAgICB0LnNwbGljZShpLCAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXQubGVuZ3RoKSBkZWxldGUgdGhpcy5faG90a2V5c1tjb2RlXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2tleWNvZGU6IGZ1bmN0aW9uIChjb2RlLCBjdHJsLCBzaGlmdCwgYWx0LCBtZXRhKSB7XG5cdCAgICByZXR1cm4gY29kZSArIFwiX1wiICsgW1wiXCIsIGN0cmwgPyBcIjFcIiA6IFwiMFwiLCBzaGlmdCA/IFwiMVwiIDogXCIwXCIsIGFsdCA/IFwiMVwiIDogXCIwXCIsIG1ldGEgPyBcIjFcIiA6IFwiMFwiXS5qb2luKFwiXCIpO1xuXHQgIH0sXG5cdCAgX2NoZWNrX2tleWNvZGU6IGZ1bmN0aW9uIChjb2RlLCBpc19hbnksIGUpIHtcblx0ICAgIHZhciBmb2N1cyA9IHRoaXMuZ2V0Rm9jdXMoKTtcblx0ICAgIGlmICh0aGlzLl9ob3RrZXlzW2NvZGVdKSByZXR1cm4gdGhpcy5fcHJvY2Vzc19jYWxscyh0aGlzLl9ob3RrZXlzW2NvZGVdLCBmb2N1cywgZSk7ZWxzZSBpZiAoaXNfYW55ICYmIHRoaXMuX2hvdGtleXNbXCJBTllfMDAwMFwiXSkgcmV0dXJuIHRoaXMuX3Byb2Nlc3NfY2FsbHModGhpcy5faG90a2V5c1tcIkFOWV8wMDAwXCJdLCBmb2N1cywgZSk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF9wcm9jZXNzX2NhbGxzOiBmdW5jdGlvbiAoY2FsbHMsIGZvY3VzLCBlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSBjYWxsc1tpXTtcblx0ICAgICAgaWYgKGtleS52aWV3ICE9PSBudWxsICYmIC8vY29tbW9uIGhvdC1rZXlcblx0ICAgICAgZm9jdXMgIT09IGtleS52aWV3ICYmICggLy9ob3Qta2V5IGZvciBjdXJyZW50IHZpZXdcblx0ICAgICAgLy9ob3RrZXkgZm9yIGN1cnJlbnQgdHlwZSBvZiB2aWV3XG5cdCAgICAgIHR5cGVvZiBrZXkudmlldyAhPT0gXCJzdHJpbmdcIiB8fCAhZm9jdXMgfHwgZm9jdXMubmFtZSAhPT0ga2V5LnZpZXcpKSBjb250aW51ZTtcblx0ICAgICAgdmFyIHRlbXBfcmVzdWx0ID0ga2V5LmhhbmRsZXIoZm9jdXMsIGUpO1xuXHQgICAgICBpZiAoISF0ZW1wX3Jlc3VsdCA9PT0gdGVtcF9yZXN1bHQpIHJldHVybiB0ZW1wX3Jlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBfcGFyc2Vfa2V5czogZnVuY3Rpb24gKGtleXMpIHtcblx0ICAgIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzO1xuXHQgICAgdmFyIHBhcnRzID0ga2V5cy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9bK1xcLV9dLyk7XG5cdCAgICB2YXIgY3RybCwgc2hpZnQsIGFsdCwgbWV0YTtcblx0ICAgIGN0cmwgPSBzaGlmdCA9IGFsdCA9IG1ldGEgPSAwO1xuXHQgICAgdmFyIGxldHRlciA9IFwiXCI7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHBhcnRzW2ldID09PSBcImN0cmxcIikgY3RybCA9IDE7ZWxzZSBpZiAocGFydHNbaV0gPT09IFwic2hpZnRcIikgc2hpZnQgPSAxO2Vsc2UgaWYgKHBhcnRzW2ldID09PSBcImFsdFwiKSBhbHQgPSAxO2Vsc2UgaWYgKHBhcnRzW2ldID09PSBcImNvbW1hbmRcIikgbWV0YSA9IDE7ZWxzZSB7XG5cdCAgICAgICAgaWYgKGNvbnRyb2xzW3BhcnRzW2ldXSkge1xuXHQgICAgICAgICAgdmFyIGNvZGUgPSBjb250cm9sc1twYXJ0c1tpXV07XG5cdCAgICAgICAgICBpZiAodGhpcy5faXNOdW1QYWQoY29kZSkpIGxldHRlciA9IGNvZGUudG9TdHJpbmcoKTtlbHNlIGxldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGxldHRlciA9IHBhcnRzW2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBsZXR0ZXI6IGxldHRlci50b1VwcGVyQ2FzZSgpLFxuXHQgICAgICBjdHJsOiBjdHJsLFxuXHQgICAgICBzaGlmdDogc2hpZnQsXG5cdCAgICAgIGFsdDogYWx0LFxuXHQgICAgICBtZXRhOiBtZXRhLFxuXHQgICAgICBkZWJ1Zzoga2V5c1xuXHQgICAgfTtcblx0ICB9LFxuXHQgIGdldFN0YXRlOiBmdW5jdGlvbiAobm9kZSwgY2hpbGRyZW4pIHtcblx0ICAgIGNoaWxkcmVuID0gY2hpbGRyZW4gfHwgZmFsc2U7XG5cdCAgICBub2RlID0gJCQobm9kZSk7XG5cdCAgICB2YXIgc3RhdGUkJDEgPSB7XG5cdCAgICAgIGlkOiBub2RlLmNvbmZpZy5pZCxcblx0ICAgICAgd2lkdGg6IG5vZGUuY29uZmlnLndpZHRoLFxuXHQgICAgICBoZWlnaHQ6IG5vZGUuY29uZmlnLmhlaWdodCxcblx0ICAgICAgZ3Jhdml0eTogbm9kZS5jb25maWcuZ3Jhdml0eVxuXHQgICAgfTtcblx0ICAgIGlmICghaXNVbmRlZmluZWQobm9kZS5jb25maWcuY29sbGFwc2VkKSkgc3RhdGUkJDEuY29sbGFwc2VkID0gbm9kZS5jb25maWcuY29sbGFwc2VkO1xuXHQgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJ0YWJzXCIgfHwgbm9kZS5uYW1lID09PSBcInRhYmJhclwiKSBzdGF0ZSQkMS5hY3RpdmVDZWxsID0gbm9kZS5nZXRWYWx1ZSgpO1xuXG5cdCAgICBpZiAoY2hpbGRyZW4pIHtcblx0ICAgICAgc3RhdGUkJDEgPSBbc3RhdGUkJDFdO1xuXG5cdCAgICAgIGlmIChub2RlLl9jZWxscykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHN0YXRlJCQxID0gc3RhdGUkJDEuY29uY2F0KHRoaXMuZ2V0U3RhdGUobm9kZS5fY2VsbHNbaV0sIGNoaWxkcmVuKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzdGF0ZSQkMTtcblx0ICB9LFxuXHQgIHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGVzKSB7XG5cdCAgICBpZiAoIWlzQXJyYXkoc3RhdGVzKSkgc3RhdGVzID0gW3N0YXRlc107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBzdGF0ZSQkMSA9IHN0YXRlc1tpXTtcblx0ICAgICAgdmFyIG5vZGUgPSAkJChzdGF0ZSQkMS5pZCk7XG5cdCAgICAgIGlmICghbm9kZSkgY29udGludWU7XG5cdCAgICAgIGlmICghaXNVbmRlZmluZWQoc3RhdGUkJDEuY29sbGFwc2VkKSkgbm9kZS5kZWZpbmUoXCJjb2xsYXBzZWRcIiwgc3RhdGUkJDEuY29sbGFwc2VkKTtcblx0ICAgICAgaWYgKCFpc1VuZGVmaW5lZChzdGF0ZSQkMS5hY3RpdmVDZWxsKSkgbm9kZS5zZXRWYWx1ZShzdGF0ZSQkMS5hY3RpdmVDZWxsKTtcblx0ICAgICAgbm9kZS5kZWZpbmUoXCJ3aWR0aFwiLCBzdGF0ZSQkMS53aWR0aCk7XG5cdCAgICAgIG5vZGUuZGVmaW5lKFwiaGVpZ2h0XCIsIHN0YXRlJCQxLmhlaWdodCk7XG5cdCAgICAgIG5vZGUuZGVmaW5lKFwiZ3Jhdml0eVwiLCBzdGF0ZSQkMS5ncmF2aXR5KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHRvcCA9ICQkKHN0YXRlc1swXS5pZCk7XG5cdCAgICBpZiAodG9wKSB0b3AucmVzaXplKCk7XG5cdCAgfVxuXHR9O1xuXHRyZWFkeShmdW5jdGlvbiAoKSB7XG5cdCAgVUlNYW5hZ2VyLl9lbmFibGUoKTtcblxuXHQgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJlbnRlclwiLCBmdW5jdGlvbiAodmlldywgZXYpIHtcblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuY2FsbEV2ZW50KSB2aWV3LmNhbGxFdmVudChcIm9uRW50ZXJcIiwgW2V2XSk7XG5cblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuZWRpdFN0b3AgJiYgdmlldy5faW5fZWRpdF9tb2RlKSB7XG5cdCAgICAgIHZpZXcuZWRpdFN0b3AoKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKHZpZXcgJiYgdmlldy50b3VjaGFibGUpIHtcblx0ICAgICAgdmFyIGZvcm0gPSB2aWV3LmdldEZvcm1WaWV3KCk7XG5cdCAgICAgIGlmIChmb3JtICYmICF2aWV3Ll9za2lwU3VibWl0KSBmb3JtLmNhbGxFdmVudChcIm9uU3VibWl0XCIsIFt2aWV3LCBldl0pO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJlc2NcIiwgZnVuY3Rpb24gKHZpZXcpIHtcblx0ICAgIGlmICh2aWV3KSB7XG5cdCAgICAgIGlmICh2aWV3LmVkaXRDYW5jZWwgJiYgdmlldy5faW5fZWRpdF9tb2RlKSB7XG5cdCAgICAgICAgdmlldy5lZGl0Q2FuY2VsKCk7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdG9wID0gdmlldy5nZXRUb3BQYXJlbnRWaWV3KCk7XG5cdCAgICAgIGlmICh0b3AgJiYgdG9wLnNldFBvc2l0aW9uKSB0b3AuX2hpZGUoKTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICBVSU1hbmFnZXIuYWRkSG90S2V5KFwic2hpZnQrdGFiXCIsIFVJTWFuYWdlci5fdGFiX2xvZ2ljKTtcblx0ICBVSU1hbmFnZXIuYWRkSG90S2V5KFwidGFiXCIsIFVJTWFuYWdlci5fdGFiX2xvZ2ljKTtcblx0fSk7XG5cdGRlZmluZShcIlVJTWFuYWdlclwiLCBVSU1hbmFnZXIpO1xuXG5cdHZhciBTZXR0aW5ncyA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgLyogXG5cdCAgICBcdHByb3BlcnR5IGNhbiBiZSBhY2Nlc3NlZCBhcyB0aGlzLmNvbmZpZy5zb21lXG5cdCAgICBcdGluIHNhbWUgdGltZSBmb3IgaW5uZXIgY2FsbCBpdCBoYXZlIHNlbnNlIHRvIHVzZSBfc2V0dGluZ3Ncblx0ICAgIFx0YmVjYXVzZSBpdCB3aWxsIGJlIG1pbmlmaWVkIGluIGZpbmFsIHZlcnNpb25cblx0ICAgICovXG5cdCAgICB0aGlzLl9zZXR0aW5ncyA9IHRoaXMuY29uZmlnID0ge307XG5cdCAgfSxcblx0ICBkZWZpbmU6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcblx0ICAgIGlmIChfdHlwZW9mKHByb3BlcnR5KSA9PSBcIm9iamVjdFwiKSByZXR1cm4gdGhpcy5fcGFyc2VTZWV0aW5nQ29sbChwcm9wZXJ0eSk7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmaW5lKHByb3BlcnR5LCB2YWx1ZSk7XG5cdCAgfSxcblx0ICBfZGVmaW5lOiBmdW5jdGlvbiAocHJvcGVydHksIHZhbHVlKSB7XG5cdCAgICAvL21ldGhvZCB3aXRoIG5hbWUge3Byb3B9X3NldHRlciB3aWxsIGJlIHVzZWQgYXMgcHJvcGVydHkgc2V0dGVyXG5cdCAgICAvL3NldHRlciBpcyBvcHRpb25hbFxuXHQgICAgdmFyIHNldHRlciA9IHRoaXNbcHJvcGVydHkgKyBcIl9zZXR0ZXJcIl07XG5cdCAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3NbcHJvcGVydHldID0gc2V0dGVyID8gc2V0dGVyLmNhbGwodGhpcywgdmFsdWUsIHByb3BlcnR5KSA6IHZhbHVlO1xuXHQgIH0sXG5cdCAgLy9wcm9jZXNzIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAgX3BhcnNlU2VldGluZ0NvbGw6IGZ1bmN0aW9uIChjb2xsKSB7XG5cdCAgICBpZiAoY29sbCkge1xuXHQgICAgICBmb3IgKHZhciBhIGluIGNvbGwpIHtcblx0ICAgICAgICAvL2ZvciBlYWNoIHNldHRpbmdcblx0ICAgICAgICB0aGlzLl9kZWZpbmUoYSwgY29sbFthXSk7XG5cdCAgICAgIH0gLy9zZXQgdmFsdWUgdGhyb3VnaCBjb25maWdcblxuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9oZWxwZXIgZm9yIG9iamVjdCBpbml0aWFsaXphdGlvblxuXHQgIF9wYXJzZVNldHRpbmdzOiBmdW5jdGlvbiAob2JqLCBpbml0aWFsKSB7XG5cdCAgICAvL2luaXRpYWwgLSBzZXQgb2YgZGVmYXVsdCB2YWx1ZXNcblx0ICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuXHQgICAgaWYgKGluaXRpYWwpIHNldHRpbmdzID0gZXhwb3J0cy5leHRlbmQoc2V0dGluZ3MsIGluaXRpYWwpOyAvL2NvZGUgYmVsb3cgd2lsbCBjb3B5IGFsbCBwcm9wZXJ0aWVzIG92ZXIgZGVmYXVsdCBvbmVcblxuXHQgICAgaWYgKF90eXBlb2Yob2JqKSA9PSBcIm9iamVjdFwiICYmICFvYmoudGFnTmFtZSkgZXhwb3J0cy5leHRlbmQoc2V0dGluZ3MsIG9iaiwgdHJ1ZSk7IC8vY2FsbCBjb25maWcgZm9yIGVhY2ggc2V0dGluZ1xuXG5cdCAgICB0aGlzLl9wYXJzZVNlZXRpbmdDb2xsKHNldHRpbmdzKTtcblx0ICB9LFxuXHQgIF9tZXJnZVNldHRpbmdzOiBmdW5jdGlvbiAoY29uZmlnLCBkZWZhdWx0cykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG5cdCAgICAgIHN3aXRjaCAoX3R5cGVvZihjb25maWdba2V5XSkpIHtcblx0ICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG5cdCAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX21lcmdlU2V0dGluZ3MoY29uZmlnW2tleV0gfHwge30sIGRlZmF1bHRzW2tleV0pO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG5cdCAgICAgICAgICBjb25maWdba2V5XSA9IGRlZmF1bHRzW2tleV07XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAvL2RvIG5vdGhpbmdcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBEZXN0cnVjdGlvbiA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgLy93cmFwIGluIG9iamVjdCB0byBzaW1wbGlmeSByZW1vdmluZyBzZWxmLXJlZmVyZW5jZVxuXHQgICAgdmFyIHQgPSB0aGlzLl9kZXN0cnVjdG9yX2hhbmRsZXIgPSB7XG5cdCAgICAgIG9iajogdGhpc1xuXHQgICAgfTsgLy9yZWdpc3RlciBzZWxmIGluIGdsb2JhbCBsaXN0IG9mIGRlc3RydWN0b3JzXG5cblx0ICAgIHN0YXRlLmRlc3RydWN0b3JzLnB1c2godCk7XG5cdCAgfSxcblx0ICAvL3dpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgb24gdW5sb2FkLCBjYW4gYmUgY2FsbGVkIG1hbnVhbGx5XG5cdCAgLy9zaW1wbGlmaWVzIGpvYiBvZiBHQ1xuXHQgIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGlmICh0aGlzLl9sYXN0X2VkaXRvcikgdGhpcy5lZGl0Q2FuY2VsKCk7XG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQpIHRoaXMuY2FsbEV2ZW50KFwib25EZXN0cnVjdFwiLCBbXSk7IC8vZGVzdHJ1Y3RvciBjYW4gYmUgY2FsbGVkIG9ubHkgb25jZVxuXG5cdCAgICB0aGlzLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7fTsgLy9yZW1vdmUgc2VsZiByZWZlcmVuY2UgZnJvbSBnbG9iYWwgZGVzdHJ1Y3Rpb25zIGNvbGxlY3Rpb25cblxuXG5cdCAgICB0aGlzLl9kZXN0cnVjdG9yX2hhbmRsZXIub2JqID0gbnVsbDsgLy9kZXN0cm95IGNoaWxkIGFuZCByZWxhdGVkIGNlbGxzXG5cblx0ICAgIGlmICh0aGlzLmdldENoaWxkVmlld3MpIHtcblx0ICAgICAgdmFyIGNlbGxzID0gdGhpcy5nZXRDaGlsZFZpZXdzKCk7XG5cdCAgICAgIGlmIChjZWxscykgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGNlbGxzW2ldLmRlc3RydWN0b3IoKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fZGVzdHJveV93aXRoX21lKSBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5fZGVzdHJveV93aXRoX21lLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZVtfaV0uZGVzdHJ1Y3RvcigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGRlbGV0ZSB1aS52aWV3c1tjb25maWcuaWRdO1xuXG5cdCAgICBpZiAoY29uZmlnLiRpZCkge1xuXHQgICAgICB2YXIgdG9wID0gdGhpcy5nZXRUb3BQYXJlbnRWaWV3KCk7XG5cdCAgICAgIGlmICh0b3AgJiYgdG9wLl9kZXN0cm95X2NoaWxkKSB0b3AuX2Rlc3Ryb3lfY2hpbGQoY29uZmlnLiRpZCk7XG5cdCAgICB9IC8vaHRtbCBjb2xsZWN0aW9uXG5cblxuXHQgICAgdGhpcy5faHRtbG1hcCA9IG51bGw7XG5cdCAgICB0aGlzLl9odG1scm93cyA9IG51bGw7XG5cdCAgICB0aGlzLl9odG1sID0gbnVsbDtcblxuXHQgICAgaWYgKHRoaXMuX2NvbnRlbnRvYmopIHtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgPSBcIlwiO1xuXHQgICAgICB0aGlzLl9jb250ZW50b2JqLl9odG1sbWFwID0gbnVsbDtcblx0ICAgIH0gLy9yZW1vdmVzIHZpZXcgY29udGFpbmVyXG5cblxuXHQgICAgaWYgKHRoaXMuX3ZpZXdvYmogJiYgdGhpcy5fdmlld29iai5wYXJlbnROb2RlKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl92aWV3b2JqKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZGVzdHJ1Y3RvcikgdGhpcy5kYXRhLmRlc3RydWN0b3IoKTtcblx0ICAgIGlmICh0aGlzLnVuYmluZCkgdGhpcy51bmJpbmQoKTtcblx0ICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cdCAgICB0aGlzLl92aWV3b2JqID0gdGhpcy4kdmlldyA9IHRoaXMuX2NvbnRlbnRvYmogPSB0aGlzLl9kYXRhb2JqID0gbnVsbDtcblx0ICAgIHRoaXMuX2V2c19ldmVudHMgPSB0aGlzLl9ldnNfaGFuZGxlcnMgPSB7fTsgLy9yZW1vdmUgZm9jdXMgZnJvbSBkZXN0cnVjdGVkIHZpZXdcblxuXHQgICAgaWYgKFVJTWFuYWdlci5fdmlldyA9PSB0aGlzKSBVSU1hbmFnZXIuX3ZpZXcgPSBudWxsO1xuXHQgICAgdmFyIHVybCA9IGNvbmZpZy51cmw7XG5cdCAgICBpZiAodXJsICYmIHVybC4kcHJveHkgJiYgdXJsLnJlbGVhc2UpIHVybC5yZWxlYXNlKCk7XG5cdCAgICB0aGlzLiRzY29wZSA9IG51bGw7IC8vIHRoaXMgZmxhZyBpcyBjaGVja2VkIGluIGRlbGF5IG1ldGhvZFxuXG5cdCAgICB0aGlzLiRkZXN0cnVjdGVkID0gdHJ1ZTtcblx0ICB9XG5cdH07IC8vZ2xvYmFsIGxpc3Qgb2YgZGVzdHJ1Y3RvcnNcblxuXHRldmVudCQxKHdpbmRvdywgXCJ1bmxvYWRcIiwgZnVuY3Rpb24gKCkge1xuXHQgIGNhbGxFdmVudChcInVubG9hZFwiLCBbXSk7XG5cdCAgc3RhdGUuX2ZpbmFsX2Rlc3RydWN0aW9uID0gdHJ1ZTsgLy9jYWxsIGFsbCByZWdpc3RlcmVkIGRlc3RydWN0b3JzXG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRlc3RydWN0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgb2JqID0gc3RhdGUuZGVzdHJ1Y3RvcnNbaV0ub2JqO1xuXHQgICAgaWYgKG9iaikgb2JqLmRlc3RydWN0b3IoKTtcblx0ICB9XG5cblx0ICBzdGF0ZS5kZXN0cnVjdG9ycyA9IFtdO1xuXHQgIHN0YXRlLl9wb3B1cHMgPSB0b0FycmF5KCk7XG5cblx0ICBfZXZlbnRzX2ZpbmFsX2Rlc3RydWN0b3IoKTtcblx0fSk7XG5cblx0dmFyIENvbGxlY3Rpb25CaW5kID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU2VsZWN0Q2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCgpO1xuXHQgICAgICB0aGlzLnNldEN1cnNvcihzZWwgPyBzZWwuaWQgfHwgc2VsIDogbnVsbCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyQ3Vyc29yQ2hhbmdlXCIsIHRoaXMuX3VwZGF0ZV9iaW5kcyk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlckRlbGV0ZVwiLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgaWYgKGlkID09IHRoaXMuZ2V0Q3Vyc29yKCkpIHRoaXMuc2V0Q3Vyc29yKG51bGwpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uIChpZCwgZGF0YSwgbW9kZSkge1xuXHQgICAgICAvL3BhaW50IC0gaWdub3JlZFxuXHQgICAgICAvL2RlbGV0ZSAtIGhhbmRsZWQgYnkgb25BZnRlckRlbGV0ZSBhYm92ZVxuXHQgICAgICBpZiAoaWQgJiYgaWQgPT0gdGhpcy5nZXRDdXJzb3IoKSAmJiBtb2RlICE9IFwicGFpbnRcIiAmJiBtb2RlICE9IFwiZGVsZXRlXCIpIHRoaXMuX3VwZGF0ZV9iaW5kcygpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25DbGVhckFsbFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uSWRDaGFuZ2VcIiwgYmluZChmdW5jdGlvbiAob2xkaWQsIG5ld2lkKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jdXJzb3IgPT0gb2xkaWQpIHtcblx0ICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXdpZDtcblxuXHQgICAgICAgIHRoaXMuX3VwZGF0ZV9iaW5kcygpO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgfSxcblx0ICByZWZyZXNoQ3Vyc29yOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fY3Vyc29yKSB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJDdXJzb3JDaGFuZ2VcIiwgW3RoaXMuX2N1cnNvcl0pO1xuXHQgIH0sXG5cdCAgc2V0Q3Vyc29yOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmIChpZCA9PSB0aGlzLl9jdXJzb3IgfHwgaWQgIT09IG51bGwgJiYgIXRoaXMuZ2V0SXRlbShpZCkpIHJldHVybjtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVDdXJzb3JDaGFuZ2VcIiwgW3RoaXMuX2N1cnNvcl0pO1xuXHQgICAgdGhpcy5fY3Vyc29yID0gaWQ7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJDdXJzb3JDaGFuZ2VcIiwgW2lkXSk7XG5cdCAgfSxcblx0ICBnZXRDdXJzb3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9jdXJzb3I7XG5cdCAgfSxcblx0ICBfYmluZF91cGRhdGU6IGZ1bmN0aW9uICh0YXJnZXQsIHJ1bGUsIGZvcm1hdCkge1xuXHQgICAgaWYgKHJ1bGUgPT0gXCIkbGV2ZWxcIiAmJiB0aGlzLmRhdGEuZ2V0QnJhbmNoKSByZXR1cm4gKHRhcmdldC5kYXRhIHx8IHRhcmdldCkuaW1wb3J0RGF0YSh0aGlzLmRhdGEuZ2V0QnJhbmNoKHRoaXMuZ2V0Q3Vyc29yKCkpKTtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5nZXRJdGVtKHRoaXMuZ2V0Q3Vyc29yKCkpIHx8IHRoaXMuX3NldHRpbmdzLmRlZmF1bHREYXRhIHx8IG51bGw7XG5cblx0ICAgIGlmIChydWxlID09IFwiJGRhdGFcIikge1xuXHQgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gXCJmdW5jdGlvblwiKSBmb3JtYXQuY2FsbCh0YXJnZXQsIGRhdGEsIHRoaXMpO2Vsc2UgdGFyZ2V0LmRhdGEuaW1wb3J0RGF0YShkYXRhID8gZGF0YVtmb3JtYXRdIDogW10pO1xuXHQgICAgICB0YXJnZXQuY2FsbEV2ZW50KFwib25CaW5kQXBwbHlcIiwgW2RhdGEsIHJ1bGUsIHRoaXNdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChmb3JtYXQpIGRhdGEgPSBmb3JtYXQoZGF0YSk7XG5cblx0ICAgICAgdGhpcy5fYmluZF91cGRhdGVfY29tbW9uKHRhcmdldCwgcnVsZSwgZGF0YSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBWYWx1ZUJpbmQgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkNoYW5nZVwiLCB0aGlzLl91cGRhdGVfYmluZHMpO1xuXHQgIH0sXG5cdCAgX2JpbmRfdXBkYXRlOiBmdW5jdGlvbiAodGFyZ2V0LCBydWxlLCBmb3JtYXQpIHtcblx0ICAgIHJ1bGUgPSBydWxlIHx8IFwidmFsdWVcIjtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5nZXRWYWx1ZSgpIHx8IFwiXCI7XG5cdCAgICBpZiAoZm9ybWF0KSBkYXRhID0gZm9ybWF0KGRhdGEpO1xuXHQgICAgaWYgKHRhcmdldC5zZXRWYWx1ZSkgdGFyZ2V0LnNldFZhbHVlKGRhdGEpO2Vsc2UgaWYgKCF0YXJnZXQuZmlsdGVyKSB7XG5cdCAgICAgIHZhciBwb2QgPSB7fTtcblx0ICAgICAgcG9kW3J1bGVdID0gZGF0YTtcblx0ICAgICAgaWYgKHRhcmdldC5fY2hlY2tfZGF0YV9mZWVkKGRhdGEpKSB0YXJnZXQuc2V0VmFsdWVzKHBvZCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0YXJnZXQuZGF0YS5zaWxlbnQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuZmlsdGVyKHJ1bGUsIGRhdGEpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHRhcmdldC5jYWxsRXZlbnQoXCJvbkJpbmRBcHBseVwiLCBbZGF0YSwgcnVsZSwgdGhpc10pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgUmVjb3JkQmluZCA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMuX3VwZGF0ZV9iaW5kcyk7XG5cdCAgfSxcblx0ICBfYmluZF91cGRhdGU6IGZ1bmN0aW9uICh0YXJnZXQsIHJ1bGUsIGZvcm1hdCkge1xuXHQgICAgdmFyIGRhdGEgPSB0aGlzLmdldFZhbHVlcygpIHx8IG51bGw7XG5cdCAgICBpZiAoZm9ybWF0KSBkYXRhID0gZm9ybWF0KGRhdGEpO1xuXG5cdCAgICB0aGlzLl9iaW5kX3VwZGF0ZV9jb21tb24odGFyZ2V0LCBydWxlLCBkYXRhKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIEJpbmRTb3VyY2UgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2JpbmRfaGFzaCA9IHt9OyAvL3J1bGVzIHBlciB0YXJnZXRcblxuXHQgICAgdGhpcy5fYmluZF91cGRhdGVkID0ge307IC8vdXBkYXRlIGZsYWdzXG5cblx0ICAgIHRoaXMuX2lnbm9yZV9iaW5kcyA9IHt9OyAvL2FwcGx5IHNwZWNpZmljIGJpbmQgZXh0ZW5zaW9uXG5cblx0ICAgIHRoaXMuX2JpbmRfc3BlY2lmaWNfcnVsZXModGhpcyk7XG5cdCAgfSxcblx0ICBzYXZlQmF0Y2g6IGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICB0aGlzLl9kb19ub3RfdXBkYXRlX2JpbmRzID0gdHJ1ZTtcblx0ICAgIGNvZGUuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2RvX25vdF91cGRhdGVfYmluZHMgPSBmYWxzZTtcblxuXHQgICAgdGhpcy5fdXBkYXRlX2JpbmRzKCk7XG5cdCAgfSxcblx0ICBzZXRCaW5kRGF0YTogZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuXHQgICAgLy9zYXZlIGNhbGxlZCwgdXBkYXRpbmcgbWFzdGVyIGRhdGFcblx0ICAgIGlmIChrZXkpIHRoaXMuX2lnbm9yZV9iaW5kc1trZXldID0gdHJ1ZTtcblx0ICAgIGlmICh0aGlzLnNldFZhbHVlKSB0aGlzLnNldFZhbHVlKGRhdGEpO2Vsc2UgaWYgKHRoaXMuc2V0VmFsdWVzKSB0aGlzLnNldFZhbHVlcyhkYXRhKTtlbHNlIHtcblx0ICAgICAgdmFyIGlkID0gdGhpcy5nZXRDdXJzb3IoKTtcblx0ICAgICAgaWYgKGlkKSB0aGlzLnVwZGF0ZUl0ZW0oaWQsIGRhdGEpO2Vsc2UgdGhpcy5hZGQoZGF0YSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmluZFVwZGF0ZVwiLCBbZGF0YSwga2V5XSk7XG5cdCAgICBpZiAodGhpcy5zYXZlKSB0aGlzLnNhdmUoKTtcblx0ICAgIGlmIChrZXkpIHRoaXMuX2lnbm9yZV9iaW5kc1trZXldID0gZmFsc2U7XG5cdCAgfSxcblx0ICAvL2ZpbGwgdGFyZ2V0IHdpdGggZGF0YVxuXHQgIGdldEJpbmREYXRhOiBmdW5jdGlvbiAoa2V5LCB1cGRhdGUpIHtcblx0ICAgIC8vZmlyZSBvbmx5IGlmIHdlIGhhdmUgZGF0YSB1cGRhdGVzIGZyb20gdGhlIGxhc3QgdGltZVxuXHQgICAgaWYgKHRoaXMuX2JpbmRfdXBkYXRlZFtrZXldKSByZXR1cm4gZmFsc2U7XG5cdCAgICB2YXIgdGFyZ2V0ID0gJCQoa2V5KTsgLy9maWxsIHRhcmdldCBvbmx5IHdoZW4gaXQgdmlzaWJsZVxuXG5cdCAgICBpZiAodGFyZ2V0LmlzVmlzaWJsZSh0YXJnZXQuX3NldHRpbmdzLmlkKSkge1xuXHQgICAgICB0aGlzLl9iaW5kX3VwZGF0ZWRba2V5XSA9IHRydWU7XG5cblx0ICAgICAgdGhpcy5fYmluZF91cGRhdGUodGFyZ2V0LCB0aGlzLl9iaW5kX2hhc2hba2V5XVswXSwgdGhpcy5fYmluZF9oYXNoW2tleV1bMV0pOyAvL3RyaWdnZXIgY29tcG9uZW50IHNwZWNpZmljIHVwZGF0aW5nIGxvZ2ljXG5cblxuXHQgICAgICBpZiAodXBkYXRlICYmIHRhcmdldC5maWx0ZXIpIHRhcmdldC5yZWZyZXNoKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2FkZCBvbmUgbW9yZSBiaW5kIHRhcmdldFxuXHQgIGFkZEJpbmQ6IGZ1bmN0aW9uIChzb3VyY2UsIHJ1bGUsIGZvcm1hdCkge1xuXHQgICAgdGhpcy5fYmluZF9oYXNoW3NvdXJjZV0gPSBbcnVsZSwgZm9ybWF0XTtcblx0ICB9LFxuXHQgIHJlbW92ZUJpbmQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLl9iaW5kX2hhc2hbc291cmNlXTtcblx0ICAgIGRlbGV0ZSB0aGlzLl9iaW5kX3VwZGF0ZWRbc291cmNlXTtcblx0ICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVfYmluZHNbc291cmNlXTtcblx0ICB9LFxuXHQgIC8vcmV0dXJucyB0cnVlIGlmIG9iamVjdCBiZWxvbmcgdG8gXCJjb2xsZWN0aW9uXCIgdHlwZVxuXHQgIF9iaW5kX3NwZWNpZmljX3J1bGVzOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAob2JqLmZpbHRlcikgZXhwb3J0cy5leHRlbmQodGhpcywgQ29sbGVjdGlvbkJpbmQpO2Vsc2UgaWYgKG9iai5zZXRWYWx1ZSkgZXhwb3J0cy5leHRlbmQodGhpcywgVmFsdWVCaW5kKTtlbHNlIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIFJlY29yZEJpbmQpO1xuXHQgIH0sXG5cdCAgLy9pbmZvcm0gYWxsIGJpbmRlZCBvYmplY3RzLCB0aGF0IHNvdXJjZSBkYXRhIHdhcyB1cGRhdGVkXG5cdCAgX3VwZGF0ZV9iaW5kczogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLl9kb19ub3RfdXBkYXRlX2JpbmRzKSBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYmluZF9oYXNoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9pZ25vcmVfYmluZHNba2V5XSkgY29udGludWU7XG5cdCAgICAgIHRoaXMuX2JpbmRfdXBkYXRlZFtrZXldID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuZ2V0QmluZERhdGEoa2V5LCB0cnVlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vY29weSBkYXRhIGZyb20gc291cmNlIHRvIHRoZSB0YXJnZXRcblx0ICBfYmluZF91cGRhdGVfY29tbW9uOiBmdW5jdGlvbiAodGFyZ2V0LCBydWxlLCBkYXRhKSB7XG5cdCAgICBpZiAodGFyZ2V0LnNldFZhbHVlKSB0YXJnZXQuc2V0VmFsdWUoZGF0YSAmJiBydWxlID8gZGF0YVtydWxlXSA6IGRhdGEpO2Vsc2UgaWYgKCF0YXJnZXQuZmlsdGVyKSB7XG5cdCAgICAgIGlmICghZGF0YSAmJiB0YXJnZXQuY2xlYXIpIHRhcmdldC5jbGVhcigpO2Vsc2Uge1xuXHQgICAgICAgIGlmICh0YXJnZXQuX2NoZWNrX2RhdGFfZmVlZChkYXRhKSkgdGFyZ2V0LnNldFZhbHVlcyhjbG9uZShkYXRhKSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRhcmdldC5kYXRhLnNpbGVudChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIocnVsZSwgZGF0YSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdGFyZ2V0LmNhbGxFdmVudChcIm9uQmluZEFwcGx5XCIsIFtkYXRhLCBydWxlLCB0aGlzXSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBCYXNlQmluZCA9IHtcblx0ICBiaW5kOiBmdW5jdGlvbiAodGFyZ2V0LCBydWxlLCBmb3JtYXQpIHtcblx0ICAgIGlmICghdGhpcy5hdHRhY2hFdmVudCkgZXhwb3J0cy5leHRlbmQodGhpcywgRXZlbnRTeXN0ZW0pO1xuXHQgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gXCJzdHJpbmdcIikgdGFyZ2V0ID0gJCQodGFyZ2V0KTtcblx0ICAgIGlmICh0YXJnZXQuX2luaXRCaW5kU291cmNlKSB0YXJnZXQuX2luaXRCaW5kU291cmNlKCk7XG5cdCAgICBpZiAodGhpcy5faW5pdEJpbmRTb3VyY2UpIHRoaXMuX2luaXRCaW5kU291cmNlKCk7XG5cdCAgICBpZiAoIXRhcmdldC5nZXRCaW5kRGF0YSkgZXhwb3J0cy5leHRlbmQodGFyZ2V0LCBCaW5kU291cmNlKTtcblxuXHQgICAgdGhpcy5fYmluZF9yZWFkeSgpO1xuXG5cdCAgICB0YXJnZXQuYWRkQmluZCh0aGlzLl9zZXR0aW5ncy5pZCwgcnVsZSwgZm9ybWF0KTtcblx0ICAgIHRoaXMuX2JpbmRfc291cmNlID0gdGFyZ2V0Ll9zZXR0aW5ncy5pZDtcblx0ICAgIHZhciB0YXJnZXRfaWQgPSB0aGlzLl9zZXR0aW5ncy5pZDsgLy9GSVhNRSAtIGNoZWNrIGZvciB0b3VjaGFibGUgaXMgbm90IHRoZSBiZXN0IHNvbHV0aW9uLCB0byBkZXRlY3QgbmVjZXNzYXJ5IGV2ZW50XG5cblx0ICAgIHRoaXMuX2JpbmRfcmVmcmVzaF9oYW5kbGVyID0gdGhpcy5hdHRhY2hFdmVudCh0aGlzLnRvdWNoYWJsZSA/IFwib25BZnRlclJlbmRlclwiIDogXCJvbkJpbmRSZXF1ZXN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRhcmdldC5nZXRCaW5kRGF0YSh0YXJnZXRfaWQpO1xuXHQgICAgfSk7XG5cdCAgICBpZiAodGhpcy5yZWZyZXNoICYmIHRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSkgdGhpcy5yZWZyZXNoKCk7XG5cdCAgfSxcblx0ICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9iaW5kX3NvdXJjZSkge1xuXHQgICAgICB2YXIgdGFyZ2V0ID0gJCQodGhpcy5fYmluZF9zb3VyY2UpO1xuXHQgICAgICBpZiAodGFyZ2V0KSB0YXJnZXQucmVtb3ZlQmluZCh0aGlzLl9zZXR0aW5ncy5pZCk7XG5cdCAgICAgIHRoaXMuZGV0YWNoRXZlbnQodGhpcy5fYmluZF9yZWZyZXNoX2hhbmRsZXIpO1xuXHQgICAgICB0aGlzLl9iaW5kX3NvdXJjZSA9IG51bGw7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfYmluZF9yZWFkeTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAodGhpcy5maWx0ZXIpIHtcblx0ICAgICAgdmFyIGtleSA9IGNvbmZpZy5pZDtcblx0ICAgICAgdGhpcy5kYXRhLl9vbl9zeW5jID0gYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgJCQodGhpcy5fYmluZF9zb3VyY2UpLl9iaW5kX3VwZGF0ZWRba2V5XSA9IGZhbHNlO1xuXHQgICAgICB9LCB0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG9sZF9yZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuXHQgICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9pbl9iaW5kX3Byb2Nlc3NpbmcpIHJldHVybjtcblx0ICAgICAgdGhpcy5faW5fYmluZF9wcm9jZXNzaW5nID0gdHJ1ZTtcblx0ICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2FsbEV2ZW50KFwib25CaW5kUmVxdWVzdFwiKTtcblx0ICAgICAgdGhpcy5faW5fYmluZF9wcm9jZXNzaW5nID0gZmFsc2U7XG5cdCAgICAgIHJldHVybiBvbGRfcmVuZGVyLmFwcGx5KHRoaXMsIHJlc3VsdCA9PT0gZmFsc2UgPyBhcmd1bWVudHMgOiBbXSk7XG5cdCAgICB9O1xuXG5cdCAgICBpZiAodGhpcy5nZXRWYWx1ZSB8fCB0aGlzLmdldFZhbHVlcykgdGhpcy5zYXZlID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgdmFyIHNvdXJjZSA9ICQkKHRoaXMuX2JpbmRfc291cmNlKTtcblx0ICAgICAgaWYgKGRhdGEpIHNvdXJjZS5zZXRCaW5kRGF0YShkYXRhKTtlbHNlIHtcblx0ICAgICAgICBpZiAodGhpcy52YWxpZGF0ZSAmJiAhdGhpcy52YWxpZGF0ZSgpKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWUgPyB0aGlzLmdldFZhbHVlIDogdGhpcy5nZXRWYWx1ZXMoKTtcblx0ICAgICAgICBzb3VyY2Uuc2V0QmluZERhdGEodmFsdWVzLCB0aGlzLl9zZXR0aW5ncy5pZCk7IC8vcmVzZXQgZm9ybSwgc28gaXQgd2lsbCBiZSBjb3VudGVkIGFzIHNhdmVkXG5cblx0ICAgICAgICBpZiAodGhpcy5zZXREaXJ0eSkgdGhpcy5zZXREaXJ0eShmYWxzZSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHRoaXMuX2JpbmRfcmVhZHkgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICB9XG5cdH07XG5cblx0dmFyIFVJRXh0ZW5zaW9uID0gd2luZG93LndlYml4X3ZpZXcgfHwge307XG5cdHZhciBhcGkgPSB7XG5cdCAgbmFtZTogXCJiYXNldmlld1wiLFxuXHQgIC8vYXR0cmlidXRlICwgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBJRCBzdG9yaW5nXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmICghY29uZmlnLmlkKSBjb25maWcuaWQgPSBfdWlkKHRoaXMubmFtZSk7XG5cdCAgICB0aGlzLl9wYXJlbnRfY2VsbCA9IHN0YXRlLl9wYXJlbnRfY2VsbDtcblx0ICAgIHN0YXRlLl9wYXJlbnRfY2VsbCA9IG51bGw7IC8vIGlmIHNjb3BlIG5vdCBwcm92aWRlZCBkaXJlY3RseSwgYW5kIHRoZXJlIGlzIG5vIHBhcmVudCB2aWV3XG5cdCAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgZ2xvYmFsIHNjb3BlXG5cblx0ICAgIHRoaXMuJHNjb3BlID0gY29uZmlnLiRzY29wZSB8fCAodGhpcy5fcGFyZW50X2NlbGwgPyB0aGlzLl9wYXJlbnRfY2VsbC4kc2NvcGUgOiBzdGF0ZS5fZ2xvYmFsX3Njb3BlKTtcblxuXHQgICAgaWYgKCF0aGlzLl92aWV3b2JqKSB7XG5cdCAgICAgIHRoaXMuX2NvbnRlbnRvYmogPSB0aGlzLl92aWV3b2JqID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfdmlld1wiXG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLiR2aWV3ID0gdGhpcy5fdmlld29iajtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRza2luOiBmYWxzZSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgd2lkdGg6IDAsXG5cdCAgICBoZWlnaHQ6IDAsXG5cdCAgICBncmF2aXR5OiAxXG5cdCAgfSxcblx0ICBnZXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdmlld29iajtcblx0ICB9LFxuXHQgIGdldFBhcmVudFZpZXc6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wYXJlbnRfY2VsbCB8fCBudWxsO1xuXHQgIH0sXG5cdCAgZ2V0VG9wUGFyZW50VmlldzogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5nZXRUb3BQYXJlbnRWaWV3KCkgOiB0aGlzO1xuXHQgIH0sXG5cdCAgZ2V0Rm9ybVZpZXc6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFZpZXcoKTtcblx0ICAgIHJldHVybiAhcGFyZW50IHx8IHBhcmVudC5zZXRWYWx1ZXMgPyBwYXJlbnQgOiBwYXJlbnQuZ2V0Rm9ybVZpZXcoKTtcblx0ICB9LFxuXHQgIGdldENoaWxkVmlld3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBbXTtcblx0ICB9LFxuXHQgIHF1ZXJ5VmlldzogZnVuY3Rpb24gKHNlYXJjaCwgYWxsKSB7XG5cdCAgICB2YXIgY29uZmlybTtcblx0ICAgIGlmICh0eXBlb2Ygc2VhcmNoID09PSBcInN0cmluZ1wiKSBzZWFyY2ggPSB7XG5cdCAgICAgIHZpZXc6IHNlYXJjaFxuXHQgICAgfTtcblxuXHQgICAgaWYgKF90eXBlb2Yoc2VhcmNoKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAvL0lFOCBjb21wYXRpYmlsaXR5XG5cdCAgICAgIGNvbmZpcm0gPSBmdW5jdGlvbiAodGVzdCkge1xuXHQgICAgICAgIHZhciBjb25maWcgPSB0ZXN0LmNvbmZpZztcblxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBzZWFyY2gpIHtcblx0ICAgICAgICAgIGlmIChjb25maWdba2V5XSAhPSBzZWFyY2hba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIGNvbmZpcm0gPSBzZWFyY2g7XG5cblx0ICAgIGlmIChhbGwgPT09IFwic2VsZlwiICYmIGNvbmZpcm0odGhpcykpIHJldHVybiB0aGlzO1xuXHQgICAgdmFyIHJlc3VsdHMgPSBhbGwgPT09IFwiYWxsXCIgPyBbXSA6IGZhbHNlO1xuXHQgICAgdmFyIGRpcmVjdGlvbiA9IGFsbCA9PT0gXCJwYXJlbnRcIiA/IHRoaXMuX3F1ZXJ5R29VcCA6IHRoaXMuX3F1ZXJ5R29Eb3duO1xuXG5cdCAgICB2YXIgZm91bmQgPSB0aGlzLl9xdWVyeVZpZXcoY29uZmlybSwgZGlyZWN0aW9uLCByZXN1bHRzKTtcblxuXHQgICAgcmV0dXJuIGFsbCA9PT0gXCJhbGxcIiA/IHJlc3VsdHMgOiBmb3VuZDtcblx0ICB9LFxuXHQgIF9xdWVyeUdvRG93bjogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgIHJldHVybiBub2RlLmdldENoaWxkVmlld3MoKTtcblx0ICB9LFxuXHQgIF9xdWVyeUdvVXA6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRWaWV3KCk7XG5cdCAgICByZXR1cm4gcGFyZW50ID8gW3BhcmVudF0gOiBbXTtcblx0ICB9LFxuXHQgIF9xdWVyeVZpZXc6IGZ1bmN0aW9uIChjb25maXJtLCBuZXh0LCBhbGwpIHtcblx0ICAgIHZhciBraWRzID0gbmV4dCh0aGlzKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBraWRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChjb25maXJtKGtpZHNbaV0pKSB7XG5cdCAgICAgICAgaWYgKGFsbCkgYWxsLnB1c2goa2lkc1tpXSk7ZWxzZSByZXR1cm4ga2lkc1tpXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBzdWIgPSBraWRzW2ldLl9xdWVyeVZpZXcoY29uZmlybSwgbmV4dCwgYWxsKTtcblxuXHQgICAgICBpZiAoc3ViICYmICFhbGwpIHtcblx0ICAgICAgICByZXR1cm4gc3ViO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoYmFzZV9pZCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhpZGRlbikge1xuXHQgICAgICBpZiAoYmFzZV9pZCkge1xuXHQgICAgICAgIGlmICghdGhpcy5faGlkZGVuX3JlbmRlcikge1xuXHQgICAgICAgICAgdGhpcy5faGlkZGVuX3JlbmRlciA9IFtdO1xuXHQgICAgICAgICAgdGhpcy5faGlkZGVuX2hhc2ggPSB7fTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXRoaXMuX2hpZGRlbl9oYXNoW2Jhc2VfaWRdKSB7XG5cdCAgICAgICAgICB0aGlzLl9oaWRkZW5faGFzaFtiYXNlX2lkXSA9IHRydWU7XG5cblx0ICAgICAgICAgIHRoaXMuX2hpZGRlbl9yZW5kZXIucHVzaChiYXNlX2lkKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFZpZXcoKTtcblx0ICAgIGlmIChwYXJlbnQpIHJldHVybiBwYXJlbnQuaXNWaXNpYmxlKGJhc2VfaWQsIHRoaXMuX3NldHRpbmdzLmlkKTtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fZGlzYWJsZV9jb3ZlcikgcmV0dXJuIGZhbHNlO1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgaWYgKHBhcmVudCkgcmV0dXJuIHBhcmVudC5pc0VuYWJsZWQoKTtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmVtb3ZlKHRoaXMuX2Rpc2FibGVfY292ZXIpO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuZGlzYWJsZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5fZGlzYWJsZV9jb3ZlciA9IGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9kaXNhYmxlZFwiXG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fdmlld29iai5hcHBlbmRDaGlsZCh0aGlzLl9kaXNhYmxlX2NvdmVyKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiKTtcblxuXHQgICAgYWRkQ3NzKHRoaXMuX3ZpZXdvYmosIFwid2ViaXhfZGlzYWJsZWRfdmlld1wiLCB0cnVlKTtcblxuXHQgICAgVUlNYW5hZ2VyLl9tb3ZlQ2hpbGRGb2N1cyh0aGlzKTtcblx0ICB9LFxuXHQgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuZGlzYWJsZWQgPSBmYWxzZTtcblxuXHQgICAgaWYgKHRoaXMuX2Rpc2FibGVfY292ZXIpIHtcblx0ICAgICAgcmVtb3ZlKHRoaXMuX2Rpc2FibGVfY292ZXIpO1xuXHQgICAgICByZW1vdmVDc3ModGhpcy5fdmlld29iaiwgXCJ3ZWJpeF9kaXNhYmxlZF92aWV3XCIpO1xuXG5cdCAgICAgIHRoaXMuX3ZpZXdvYmoucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiKTtcblxuXHQgICAgICB0aGlzLl9kaXNhYmxlX2NvdmVyID0gbnVsbDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGRpc2FibGVkX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuZGlzYWJsZSgpO2Vsc2UgdGhpcy5lbmFibGUoKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGNvbnRhaW5lcl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgYXNzZXJ0KHRvTm9kZSh2YWx1ZSksIFwiSW52YWxpZCBjb250YWluZXJcIik7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIGNzc19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKF90eXBlb2YodmFsdWUpID09IFwib2JqZWN0XCIpIHZhbHVlID0gY3JlYXRlQ3NzKHZhbHVlKTtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIFwiICsgdmFsdWU7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBpZF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHN0YXRlLl9nbG9iYWxfY29sbGVjdGlvbiAmJiAoc3RhdGUuX2dsb2JhbF9jb2xsZWN0aW9uICE9IHRoaXMgfHwgdGhpcy5fcHJldl9nbG9iYWxfY29sKSkge1xuXHQgICAgICB2YXIgb2xkdmFsdWUgPSB0aGlzLmNvbmZpZy4kaWQgPSB2YWx1ZTtcblx0ICAgICAgKHRoaXMuX3ByZXZfZ2xvYmFsX2NvbCB8fCBzdGF0ZS5fZ2xvYmFsX2NvbGxlY3Rpb24pLl9lbGVtZW50c1t2YWx1ZV0gPSB0aGlzO1xuXHQgICAgICB2YWx1ZSA9IF91aWQodGhpcy5uYW1lKTtcblx0ICAgICAgKHRoaXMuX3ByZXZfZ2xvYmFsX2NvbCB8fCBzdGF0ZS5fZ2xvYmFsX2NvbGxlY3Rpb24pLl90cmFuc2xhdGVfaWRzW3ZhbHVlXSA9IG9sZHZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICBhc3NlcnQoIXVpLnZpZXdzW3ZhbHVlXSwgXCJOb24gdW5pcXVlIHZpZXcgaWQ6IFwiICsgdmFsdWUpO1xuXHQgICAgdWkudmlld3NbdmFsdWVdID0gdGhpcztcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJ2aWV3X2lkXCIsIHZhbHVlKTtcblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICB2YXIgbGFzdCA9IHRoaXMuX2xhc3Rfc2l6ZTtcblxuXHQgICAgaWYgKGxhc3QgJiYgbGFzdFswXSA9PSB4ICYmIGxhc3RbMV0gPT0geSkge1xuXHQgICAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBbeCwgeSwgXCJub3QgY2hhbmdlZFwiXSk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgZGVidWdfc2l6ZV9ib3godGhpcywgW3gsIHldKTtcblx0ICAgIHRoaXMuX2xhc3Rfc2l6ZSA9IFt4LCB5XTtcblx0ICAgIHRoaXMuJHdpZHRoID0gdGhpcy5fY29udGVudF93aWR0aCA9IHggLSAodGhpcy5fc2Nyb2xsX3kgPyBlbnYuc2Nyb2xsU2l6ZSA6IDApO1xuXHQgICAgdGhpcy4kaGVpZ2h0ID0gdGhpcy5fY29udGVudF9oZWlnaHQgPSB5IC0gKHRoaXMuX3Njcm9sbF94ID8gZW52LnNjcm9sbFNpemUgOiAwKTtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblxuXHQgICAgaWYgKCFjb25maWcuZmxleCkge1xuXHQgICAgICB0aGlzLl92aWV3b2JqLnN0eWxlLndpZHRoID0geCArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fdmlld29iai5zdHlsZS5oZWlnaHQgPSB5ICsgXCJweFwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICB2YXIgcyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgdmFyIHNpemUgPSBbKHMud2lkdGggfHwgcy5taW5XaWR0aCB8fCAwKSAqIDEsIChzLndpZHRoIHx8IHMubWF4V2lkdGggfHwgMTAwMDAwKSAqIDEsIChzLmhlaWdodCB8fCBzLm1pbkhlaWdodCB8fCAwKSAqIDEsIChzLmhlaWdodCB8fCBzLm1heEhlaWdodCB8fCAxMDAwMDApICogMSwgcy5ncmF2aXR5XTtcblxuXHQgICAgaWYgKGFzc2VydCkge1xuXHQgICAgICB2YXIgY2hlY2sgPSBpc05hTihzaXplWzBdKSB8fCBpc05hTihzaXplWzFdKSB8fCBpc05hTihzaXplWzJdKSB8fCBpc05hTihzaXplWzNdKTtcblxuXHQgICAgICBpZiAoY2hlY2spIHtcblx0ICAgICAgICBhc3NlcnQoZmFsc2UsIFwiU2l6ZSBpcyBub3QgYSBudW1iZXIgXCIgKyB0aGlzLl9zZXR0aW5ncy5pZCk7XG5cdCAgICAgICAgcy53aWR0aCA9IHMuaGVpZ2h0ID0gcy5tYXhXaWR0aCA9IHMubWF4SGVpZ2h0ID0gcy5taW5XaWR0aCA9IHMubWluSGVpZ2h0ID0gMDtcblx0ICAgICAgICBzaXplID0gWzAsIDAsIDEwMDAwMCwgMTAwMDAwLCAxXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBzaXplWzBdICs9IGR4O1xuXHQgICAgc2l6ZVsxXSArPSBkeDtcblx0ICAgIHNpemVbMl0gKz0gZHk7XG5cdCAgICBzaXplWzNdICs9IGR5O1xuXHQgICAgcmV0dXJuIHNpemU7XG5cdCAgfSxcblx0ICBzaG93OiBmdW5jdGlvbiAoZm9yY2UsIGFuaW1hdGVfc2V0dGluZ3MpIHtcblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFZpZXcoKTtcblx0ICAgIHZhciBzaG93ID0gIWFyZ3VtZW50c1syXTtcblxuXHQgICAgaWYgKHBhcmVudCkge1xuXHQgICAgICBpZiAoIWFuaW1hdGVfc2V0dGluZ3MgJiYgYW5pbWF0ZV9zZXR0aW5ncyAhPT0gZmFsc2UgJiYgdGhpcy5fc2V0dGluZ3MuYW5pbWF0ZSkgaWYgKHBhcmVudC5fc2V0dGluZ3MuYW5pbWF0ZSkgYW5pbWF0ZV9zZXR0aW5ncyA9IGV4cG9ydHMuZXh0ZW5kKHBhcmVudC5fc2V0dGluZ3MuYW5pbWF0ZSA/IGV4cG9ydHMuZXh0ZW5kKHt9LCBwYXJlbnQuX3NldHRpbmdzLmFuaW1hdGUpIDoge30sIHRoaXMuX3NldHRpbmdzLmFuaW1hdGUsIHRydWUpO1xuXHQgICAgICBpZiAoc2hvdyA/IHBhcmVudC5fc2hvdyA6IHBhcmVudC5faGlkZSkgKHNob3cgPyBwYXJlbnQuX3Nob3cgOiBwYXJlbnQuX2hpZGUpLmNhbGwocGFyZW50LCB0aGlzLCBhbmltYXRlX3NldHRpbmdzKTtcblx0ICAgICAgaWYgKHNob3cpIHRoaXMuX3JlbmRlcl9oaWRkZW5fdmlld3MoKTsgLy9mb3JjZSBzaG93IG9mIHBhcmVudCB2aWV3XG5cdCAgICAgIC8vc3RvcCBmdXJ0aGVyIHByb2Nlc3NpbmcgaXMgdmlldyBpcyBhIHBhcnQgb2YgaXNvbGF0ZWQgc2NvcGVcblxuXHQgICAgICBpZiAoZm9yY2UgJiYgc2hvdykgcGFyZW50LnNob3cocGFyZW50LiQkID8gZmFsc2UgOiBmb3JjZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGlkZGVuKSB7XG5cdCAgICAgICAgaWYgKHNob3cpIHtcblx0ICAgICAgICAgIHZhciBub2RlID0gdG9Ob2RlKHRoaXMuX3NldHRpbmdzLl9jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuaGlkZGVuID0gZmFsc2U7XG5cdCAgICAgICAgICB0aGlzLmFkanVzdCgpO1xuXG5cdCAgICAgICAgICB0aGlzLl9yZW5kZXJfaGlkZGVuX3ZpZXdzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICghc2hvdykge1xuXHQgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuaGlkZGVuID0gdGhpcy5fc2V0dGluZ3MuX2hpZGRlbiA9IHRydWU7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl92aWV3b2JqKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzLl9jb250YWluZXIgPSB0aGlzLl92aWV3b2JqLnBhcmVudE5vZGU7XG5cdCAgICAgICAgICAgIHJlbW92ZSh0aGlzLl92aWV3b2JqKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9yZW5kZXJfaGlkZGVuX3ZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5faGlkZGVuX3JlbmRlcikge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hpZGRlbl9yZW5kZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgdWlfdG9fcmVuZGVyID0gJCQodGhpcy5faGlkZGVuX3JlbmRlcltpXSk7XG5cdCAgICAgICAgaWYgKHVpX3RvX3JlbmRlcikgdWlfdG9fcmVuZGVyLnJlbmRlcigpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5faGlkZGVuX3JlbmRlciA9IFtdO1xuXHQgICAgICB0aGlzLl9oaWRkZW5faGFzaCA9IHt9O1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX29uS2V5UHJlc3M6IGZ1bmN0aW9uIChjb2RlLCBlKSB7XG5cdCAgICB2YXIgdGFyZ2V0ID0gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0LFxuXHQgICAgICAgIHJvbGUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKTtcblxuXHQgICAgaWYgKChjb2RlID09PSAxMyB8fCBjb2RlID09PSAzMikgJiYgKHJvbGUgPT0gXCJidXR0b25cIiB8fCByb2xlID09IFwidGFiXCIpICYmICF0aGlzLl9zZXR0aW5ncy5kaXNhYmxlZCkge1xuXHQgICAgICB0cmlnZ2VyRXZlbnQodGFyZ2V0LCBcIk1vdXNlRXZlbnRzXCIsIFwiY2xpY2tcIik7XG5cdCAgICAgIHByZXZlbnRFdmVudChlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGhpZGRlbl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB0aGlzLmhpZGUoKTtcblx0ICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5oaWRkZW47XG5cdCAgfSxcblx0ICBoaWRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnNob3cobnVsbCwgbnVsbCwgdHJ1ZSk7XG5cblx0ICAgIFVJTWFuYWdlci5fbW92ZUNoaWxkRm9jdXModGhpcyk7XG5cdCAgfSxcblx0ICBhZGp1c3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fdmlld29iai5wYXJlbnROb2RlKSByZXR1cm4gZmFsc2U7XG5cdCAgICB2YXIgeCA9IHRoaXMuX3ZpZXdvYmoucGFyZW50Tm9kZS5jbGllbnRXaWR0aCB8fCAwO1xuXHQgICAgdmFyIHkgPSB0aGlzLl92aWV3b2JqLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0IHx8IDA7XG5cdCAgICB2YXIgc2l6ZXMgPSB0aGlzLiRnZXRTaXplKDAsIDApO1xuXHQgICAgdmFyIGZ1bGxzY3JlZW4gPSB0aGlzLl92aWV3b2JqLnBhcmVudE5vZGUgPT0gZG9jdW1lbnQuYm9keSAmJiAhdGhpcy5zZXRQb3NpdGlvbjsgLy9taW5XaWR0aFxuXG5cdCAgICBpZiAoc2l6ZXNbMF0gPiB4KSB4ID0gc2l6ZXNbMF07IC8vbWluSGVpZ2h0XG5cblx0ICAgIGlmIChzaXplc1syXSA+IHkpIHkgPSBzaXplc1syXTsgLy9tYXhXaWR0aCBydWxlXG5cblx0ICAgIGlmICgoIWZ1bGxzY3JlZW4gfHwgdGhpcy5fc2V0dGluZ3Mud2lkdGgpICYmIHggPiBzaXplc1sxXSkgeCA9IHNpemVzWzFdOyAvL21heEhlaWdodCBydWxlXG5cblx0ICAgIGlmICgoIWZ1bGxzY3JlZW4gfHwgdGhpcy5fc2V0dGluZ3MuaGVpZ2h0KSAmJiB5ID4gc2l6ZXNbM10pIHkgPSBzaXplc1szXTtcblx0ICAgIHRoaXMuJHNldFNpemUoeCwgeSk7XG5cblx0ICAgIGlmIChzdGF0ZS5fcmVzcG9uc2l2ZV9leGNlcHRpb24pIHtcblx0ICAgICAgc3RhdGUuX3Jlc3BvbnNpdmVfZXhjZXB0aW9uID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuYWRqdXN0KCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZXNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChzdGF0ZS5fY2hpbGRfc2l6aW5nX2FjdGl2ZSB8fCBzdGF0ZS5fZnJlZXplX3Jlc2l6ZSB8fCBzdGF0ZS5fcmVzcG9uc2l2ZV90aW5rZXJ5KSByZXR1cm47XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRWaWV3KCk7XG5cblx0ICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgaWYgKHBhcmVudC5yZXNpemVDaGlsZHJlbikgcGFyZW50LnJlc2l6ZUNoaWxkcmVuKCk7ZWxzZSBwYXJlbnQucmVzaXplKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmFkanVzdCgpO1xuXHQgICAgICBjYWxsRXZlbnQoXCJvblJlc2l6ZVwiLCBbXSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyA9IGV4cG9ydHMucHJvdG9VSShhcGksIFNldHRpbmdzLCBEZXN0cnVjdGlvbiwgQmFzZUJpbmQsIFVJRXh0ZW5zaW9uKTtcblx0dmFyIGJhc2V2aWV3ID0ge1xuXHQgIGFwaTogYXBpLFxuXHQgIHZpZXc6IHZpZXdcblx0fTtcblxuXHR2YXIgYXBpJDEgPSB7XG5cdCAgbmFtZTogXCJ2aWV3XCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuX3NldF9pbm5lcihjb25maWcpO1xuXHQgIH0sXG5cdCAgLy9kZXNpZGUsIHdpbGwgY29tcG9uZW50IHVzZSBib3JkZXJzIG9yIG5vdFxuXHQgIF9zZXRfaW5uZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHZhciBib3JkZXJfbm90X3NldCA9IGlzVW5kZWZpbmVkKGNvbmZpZy5ib3JkZXJsZXNzKTtcblxuXHQgICAgaWYgKGJvcmRlcl9ub3Rfc2V0ICYmICF0aGlzLnNldFBvc2l0aW9uICYmIGNvbmZpZy4kdG9wVmlldykge1xuXHQgICAgICBjb25maWcuYm9yZGVybGVzcyA9IHRydWU7XG5cdCAgICAgIGJvcmRlcl9ub3Rfc2V0ID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmIChib3JkZXJfbm90X3NldCAmJiB0aGlzLmRlZmF1bHRzLmJvcmRlcmxlc3MgfHwgY29uZmlnLmJvcmRlcmxlc3MpIHtcblx0ICAgICAgLy9idXR0b24gYW5kIGN1c3RvbSBib3JkZXJsZXNzXG5cdCAgICAgIGNvbmZpZy5faW5uZXIgPSB7XG5cdCAgICAgICAgdG9wOiB0cnVlLFxuXHQgICAgICAgIGxlZnQ6IHRydWUsXG5cdCAgICAgICAgYm90dG9tOiB0cnVlLFxuXHQgICAgICAgIHJpZ2h0OiB0cnVlXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvL2RlZmF1bHQgYm9yZGVyc1xuXHQgICAgICBpZiAoIWNvbmZpZy5faW5uZXIpIGNvbmZpZy5faW5uZXIgPSB7fTtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS5ib3JkZXJXaWR0aCA9IFwiMXB4XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgdmFyIF9ib3JkZXJzID0gdGhpcy5fc2V0dGluZ3MuX2lubmVyO1xuXG5cdCAgICBpZiAoX2JvcmRlcnMpIHtcblx0ICAgICAgZHggKz0gKF9ib3JkZXJzLmxlZnQgPyAwIDogMSkgKyAoX2JvcmRlcnMucmlnaHQgPyAwIDogMSk7XG5cdCAgICAgIGR5ICs9IChfYm9yZGVycy50b3AgPyAwIDogMSkgKyAoX2JvcmRlcnMuYm90dG9tID8gMCA6IDEpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2l6ZSA9IGJhc2V2aWV3LmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cdCAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBzaXplLCB0cnVlKTtcblx0ICAgIHJldHVybiBzaXplO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBbeCwgeV0pO1xuXHQgICAgdmFyIF9ib3JkZXJzID0gdGhpcy5fc2V0dGluZ3MuX2lubmVyO1xuXG5cdCAgICBpZiAoX2JvcmRlcnMpIHtcblx0ICAgICAgeCAtPSAoX2JvcmRlcnMubGVmdCA/IDAgOiAxKSArIChfYm9yZGVycy5yaWdodCA/IDAgOiAxKTtcblx0ICAgICAgeSAtPSAoX2JvcmRlcnMudG9wID8gMCA6IDEpICsgKF9ib3JkZXJzLmJvdHRvbSA/IDAgOiAxKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJhc2V2aWV3LmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMSA9IGV4cG9ydHMucHJvdG9VSShhcGkkMSwgYmFzZXZpZXcudmlldyk7XG5cdHZhciBiYXNlID0ge1xuXHQgIGFwaTogYXBpJDEsXG5cdCAgdmlldzogdmlldyQxXG5cdH07IC8vbm90IG5lY2Vzc2FyeSBhbnltb3JlXG5cdC8vcHJlc2VydmluZyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5cdHZpZXckMS5jYWxsKC0xKTtcblxuXHQvKlxuXHRcdFJFbmRlcnMgc2luZ2xlIGl0ZW0uIFxuXHRcdENhbiBiZSB1c2VkIGZvciBlbGVtZW50cyB3aXRob3V0IGRhdGFzdG9yZSwgb3Igd2l0aCBjb21wbGV4IGN1c3RvbSByZW5kZXJpbmcgbG9naWNcblx0XHRcblx0XHRAZXhwb3J0XG5cdFx0XHRyZW5kZXJcblx0Ki9cblxuXHR2YXIgU2luZ2xlUmVuZGVyID0gZXhwb3J0cy5wcm90byh7XG5cdCAgdGVtcGxhdGVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMudHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlKHZhbHVlKTtcblx0ICB9LFxuXHQgIC8vY29udmVydCBpdGVtIHRvIHRoZSBIVE1MIHRleHRcblx0ICBfdG9IVE1MOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgdHlwZSQkMSA9IHRoaXMudHlwZTtcblx0ICAgIHJldHVybiAodHlwZSQkMS50ZW1wbGF0ZVN0YXJ0ID8gdHlwZSQkMS50ZW1wbGF0ZVN0YXJ0KG9iaiwgdHlwZSQkMSkgOiBcIlwiKSArIHR5cGUkJDEudGVtcGxhdGUob2JqLCB0eXBlJCQxKSArICh0eXBlJCQxLnRlbXBsYXRlRW5kID8gdHlwZSQkMS50ZW1wbGF0ZUVuZChvYmosIHR5cGUkJDEpIDogXCJcIik7XG5cdCAgfSxcblx0ICBjdXN0b21pemU6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHR5cGUodGhpcywgb2JqKTtcblx0ICB9XG5cdH0sIEF0b21SZW5kZXIpO1xuXG5cdC8qXG5cdFx0VUk6IFRvb2x0aXBcblx0XHRcblx0XHRAZXhwb3J0XG5cdFx0XHRzaG93XG5cdFx0XHRoaWRlXG5cdCovXG5cdC8vICNpbmNsdWRlIGNvcmUvdGVtcGxhdGUuanNcblx0Ly8gI2luY2x1ZGUgY29yZS9zaW5nbGVfcmVuZGVyLmpzXG5cblx0dmFyIGFwaSQyID0ge1xuXHQgIG5hbWU6IFwidG9vbHRpcFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBkeTogMCxcblx0ICAgIGR4OiAyMFxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0ICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgY29udGFpbmVyID0ge1xuXHQgICAgICAgIHRlbXBsYXRlOiBjb250YWluZXJcblx0ICAgICAgfTtcblx0ICAgIH0gLy9jcmVhdGUgIGNvbnRhaW5lciBmb3IgZnV0dXJlIHRvb2x0aXBcblxuXG5cdCAgICB0aGlzLiR2aWV3ID0gdGhpcy5fdmlld29iaiA9IHRoaXMuX2NvbnRlbnRvYmogPSB0aGlzLl9kYXRhb2JqID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgcm9sZTogXCJhbGVydFwiLFxuXHQgICAgICBcImFyaWEtYXRvbWljXCI6IFwidHJ1ZVwiXG5cdCAgICB9KTtcblx0ICAgIHRoaXMuX2NvbnRlbnRvYmouY2xhc3NOYW1lID0gXCJ3ZWJpeF90b29sdGlwXCI7XG5cdCAgICBpbnNlcnRCZWZvcmUodGhpcy5fY29udGVudG9iaiwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkLCBkb2N1bWVudC5ib2R5KTtcblx0ICAgIHRoaXMuX2hpZGVIYW5kbGVyID0gYXR0YWNoRXZlbnQoXCJvbkNsaWNrXCIsIGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgaWYgKHRoaXMuX3Zpc2libGUgJiYgJCQoZSkgIT0gdGhpcykgdGhpcy5oaWRlKCk7XG5cdCAgICB9LCB0aGlzKSk7IC8vZGV0YWNoIGdsb2JhbCBldmVudCBoYW5kbGVyIG9uIGRlc3RydWN0aW9uXG5cblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZGV0YWNoRXZlbnQodGhpcy5faGlkZUhhbmRsZXIpO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBhZGp1c3Q6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIC8vc2hvdyB0b29wdGlwXG5cdCAgLy9wb3MgLSBvYmplY3QsIHBvcy54IC0gbGVmdCwgcG94LnkgLSB0b3Bcblx0ICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuXHQgIH0sXG5cdCAgX2FsdF9yZW5kZXI6IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGV4dF0pKSB7XG5cdCAgICAgIC8vaXQgaXMgY3JpdGljYWwgdG8gaGF2ZSB0aGlzIGFzIHR3byBjb21tYW5kc1xuXHQgICAgICAvL2l0cyBwcmV2ZW50IGRlc3RydWN0aW9uIHJhY2UgaW4gQ2hyb21lXG5cdCAgICAgIHRoaXMuX2RhdGFvYmouaW5uZXJIVE1MID0gXCJcIjtcblx0ICAgICAgdGhpcy5fZGF0YW9iai5pbm5lckhUTUwgPSB0ZXh0O1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgW10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgY3NzX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHZhbHVlID0gY3JlYXRlQ3NzKHZhbHVlKTtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lID0gXCJ3ZWJpeF90b29sdGlwIFwiICsgdmFsdWU7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBzaG93OiBmdW5jdGlvbiAoZGF0YSwgcG9zJCQxKSB7XG5cdCAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHJldHVybjtcblx0ICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuXHQgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB0aGlzLl9hbHRfcmVuZGVyKGRhdGEpO2Vsc2Uge1xuXHQgICAgICB0aGlzLmRhdGEgPSBleHBvcnRzLmV4dGVuZCh7fSwgZGF0YSk7XG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9kYXRhb2JqLmZpcnN0Q2hpbGQpIHtcblx0ICAgICAgLy9zaG93IGF0IHNwZWNpZmllZCBwb3NpdGlvblxuXHQgICAgICB2YXIgdyA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG5cdCAgICAgIHZhciBoID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXHQgICAgICB2YXIgcG9zaXRpb25YID0gdyAtIHBvcyQkMS54O1xuXHQgICAgICB2YXIgcG9zaXRpb25ZID0gaCAtIHBvcyQkMS55O1xuXHQgICAgICB0aGlzLl9jb250ZW50b2JqLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdCAgICAgIGlmIChwb3NpdGlvblggLSB0aGlzLl9zZXR0aW5ncy5keCA+IHRoaXMuX2NvbnRlbnRvYmoub2Zmc2V0V2lkdGgpIHBvc2l0aW9uWCA9IHBvcyQkMS54O2Vsc2Uge1xuXHQgICAgICAgIHBvc2l0aW9uWCA9IHBvcyQkMS54IC0gdGhpcy5fc2V0dGluZ3MuZHggKiAyIC0gdGhpcy5fY29udGVudG9iai5vZmZzZXRXaWR0aDtcblx0ICAgICAgICBpZiAocG9zaXRpb25YIDw9IDApIHBvc2l0aW9uWCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHBvc2l0aW9uWSAtIHRoaXMuX3NldHRpbmdzLmR5ID4gdGhpcy5fY29udGVudG9iai5vZmZzZXRIZWlnaHQpIHBvc2l0aW9uWSA9IHBvcyQkMS55O2Vsc2UgcG9zaXRpb25ZID0gcG9zJCQxLnkgLSB0aGlzLl9zZXR0aW5ncy5keSAtIHRoaXMuX2NvbnRlbnRvYmoub2Zmc2V0SGVpZ2h0O1xuXHQgICAgICB0aGlzLl9jb250ZW50b2JqLnN0eWxlLmxlZnQgPSBwb3NpdGlvblggKyB0aGlzLl9zZXR0aW5ncy5keCArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS50b3AgPSBwb3NpdGlvblkgKyB0aGlzLl9zZXR0aW5ncy5keSArIFwicHhcIjtcblx0ICAgIH0gZWxzZSB0aGlzLmhpZGUoKTtcblx0ICB9LFxuXHQgIC8vaGlkZSB0b29sdGlwXG5cdCAgaGlkZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kYXRhID0gbnVsbDsgLy9udWxpZnksIHRvIGJlIHN1cmUgdGhhdCBvbiBuZXh0IHNob3cgaXQgd2lsbCBiZSBmcmVzaC1yZW5kZXJlZFxuXG5cdCAgICB0aGlzLl9jb250ZW50b2JqLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcblx0ICB9LFxuXHQgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2Rpc2FibGVkID0gdHJ1ZTtcblx0ICB9LFxuXHQgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcblx0ICB9LFxuXHQgIHR5cGU6IHtcblx0ICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZShcIntvYmoudmFsdWV9XCIpLFxuXHQgICAgdGVtcGxhdGVTdGFydDogdGVtcGxhdGUuZW1wdHksXG5cdCAgICB0ZW1wbGF0ZUVuZDogdGVtcGxhdGUuZW1wdHlcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JDIgPSBleHBvcnRzLnByb3RvVUkoYXBpJDIsIFNpbmdsZVJlbmRlciwgU2V0dGluZ3MsIEV2ZW50U3lzdGVtLCBiYXNlLnZpZXcpO1xuXG5cdC8qXG5cdFx0QmVoYXZpb3I6IEF1dG9Ub29sdGlwIC0gbGlua3MgdG9vbHRpcCB0byBkYXRhIGRyaXZlbiBpdGVtXG5cdCovXG5cblx0dmFyIEF1dG9Ub29sdGlwID0ge1xuXHQgIHRvb2x0aXBfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB2YWx1ZSA9IHtcblx0ICAgICAgICB0ZW1wbGF0ZTogdmFsdWVcblx0ICAgICAgfTtcblx0ICAgICAgaWYgKF90eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB2YWx1ZSA9IHt9O1xuXHQgICAgICBUb29sdGlwQ29udHJvbC5hZGRUb29sdGlwKHRoaXMpO1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25EZXN0cnVjdFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9vbHRpcENvbnRyb2wucmVtb3ZlVG9vbHRpcCh0aGlzKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoVG9vbHRpcENvbnRyb2wuX3Rvb2x0aXBfZXhpc3QpIFRvb2x0aXBDb250cm9sLl9oaWRlX3Rvb2x0aXAoKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICR0b29sdGlwSW46IGZ1bmN0aW9uICh0KSB7XG5cdCAgICB2YXIgdG9vbHRpcCA9IFRvb2x0aXBDb250cm9sLl90b29sdGlwO1xuXHQgICAgdmFyIGRlZiA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICAgICAgZHg6IDIwLFxuXHQgICAgICBkeTogMCxcblx0ICAgICAgdGVtcGxhdGU6IFwie29iai52YWx1ZX1cIixcblx0ICAgICAgY3NzOiBcIlwiXG5cdCAgICB9LCB0aGlzLl9zZXR0aW5ncy50b29sdGlwLCB0cnVlKTtcblx0ICAgIHRvb2x0aXAuZGVmaW5lKGRlZik7XG5cdCAgICByZXR1cm4gdDtcblx0ICB9LFxuXHQgICR0b29sdGlwT3V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBUb29sdGlwQ29udHJvbC5faGlkZV90b29sdGlwKCk7XG5cblx0ICAgIGRlbGV0ZSBUb29sdGlwQ29udHJvbC5fdG9vbHRpcC50eXBlLmNvbHVtbjtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgJHRvb2x0aXBNb3ZlOiBmdW5jdGlvbiAodCwgZSwgdGV4dCkge1xuXHQgICAgVG9vbHRpcENvbnRyb2wuX3Rvb2x0aXAuaGlkZSgpO1xuXG5cdCAgICBjbGVhclRpbWVvdXQoVG9vbHRpcENvbnRyb2wuX2JlZm9yZV9zaG93X2RlbGF5KTtcblx0ICAgIFRvb2x0aXBDb250cm9sLl9iZWZvcmVfc2hvd19kZWxheSA9IGRlbGF5KHRoaXMuX3Nob3dfdG9vbHRpcCwgdGhpcywgW3QsIGUsIHRleHRdLCBUb29sdGlwQ29udHJvbC5kZWxheSk7XG5cdCAgfSxcblx0ICBfc2hvd190b29sdGlwOiBmdW5jdGlvbiAodCwgZSwgdGV4dCkge1xuXHQgICAgdmFyIGRhdGEgPSB0ZXh0IHx8IHRoaXMuX2dldF90b29sdGlwX2RhdGEodCwgZSk7XG5cblx0ICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG5cdCAgICBUb29sdGlwQ29udHJvbC5fdG9vbHRpcC5zaG93KGRhdGEsIHBvcyhlKSk7XG5cdCAgfSxcblx0ICBfZ2V0X3Rvb2x0aXBfZGF0YTogZnVuY3Rpb24gKHQsIGUpIHtcblx0ICAgIGlmICh0aGlzLmxvY2F0ZSAmJiB0aGlzLmdldEl0ZW0pIHtcblx0ICAgICAgdmFyIGlkID0gdGhpcy5sb2NhdGUoZSk7XG5cdCAgICAgIGlmICghaWQpIHJldHVybiBudWxsO1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgQ2FudmFzID0gZXhwb3J0cy5wcm90byh7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcblx0ICAgIHRoaXMuX2NhbnZhc19sYWJlbHMgPSBbXTtcblx0ICAgIHRoaXMuX2NhbnZhc19zZXJpZXMgPSAhaXNVbmRlZmluZWQoY29udGFpbmVyLnNlcmllcykgPyBjb250YWluZXIuc2VyaWVzIDogY29udGFpbmVyLm5hbWU7XG5cdCAgICB0aGlzLl9vYmogPSB0b05vZGUoY29udGFpbmVyLmNvbnRhaW5lciB8fCBjb250YWluZXIpO1xuXHQgICAgdmFyIHdpZHRoID0gY29udGFpbmVyLndpZHRoICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuXHQgICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG5cdCAgICB2YXIgc3R5bGUgPSBjb250YWluZXIuc3R5bGUgfHwgXCJcIjtcblx0ICAgIHN0eWxlICs9IFwiO3dpZHRoOlwiICsgY29udGFpbmVyLndpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyBjb250YWluZXIuaGVpZ2h0ICsgXCJweDtcIjtcblxuXHQgICAgdGhpcy5fcHJlcGFyZUNhbnZhcyhjb250YWluZXIubmFtZSwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGNvbnRhaW5lci50aXRsZSk7XG5cdCAgfSxcblx0ICBfcHJlcGFyZUNhbnZhczogZnVuY3Rpb24gKG5hbWUsIHN0eWxlLCB4LCB5LCB0aXRsZSkge1xuXHQgICAgLy9jYW52YXMgaGFzIHRoZSBzYW1lIHNpemUgYXMgbWFzdGVyIG9iamVjdFxuXHQgICAgdGhpcy5fY2FudmFzID0gY3JlYXRlKFwiY2FudmFzXCIsIHtcblx0ICAgICAgdGl0bGU6IHRpdGxlLFxuXHQgICAgICB3aWR0aDogeCxcblx0ICAgICAgaGVpZ2h0OiB5LFxuXHQgICAgICBjYW52YXNfaWQ6IG5hbWUsXG5cdCAgICAgIHN0eWxlOiBzdHlsZSB8fCBcIlwiXG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fb2JqLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7IC8vdXNlIGV4Y2FudmFzIGluIElFXG5cblxuXHQgICAgaWYgKCF0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCkge1xuXHQgICAgICBpZiAoZW52LmlzSUUpIHtcblx0ICAgICAgICByZXF1aXJlKFwibGVnYWN5L2V4Y2FudmFzL2V4Y2FudmFzLmpzXCIsIHRydWUpOyAvL3N5bmMgbG9hZGluZ1xuXG5cdCAgICAgICAgLyogZ2xvYmFsIEdfdm1sQ2FudmFzTWFuYWdlciAqL1xuXG5cblx0ICAgICAgICBHX3ZtbENhbnZhc01hbmFnZXIuaW5pdF8oZG9jdW1lbnQpO1xuXHQgICAgICAgIEdfdm1sQ2FudmFzTWFuYWdlci5pbml0RWxlbWVudCh0aGlzLl9jYW52YXMpO1xuXHQgICAgICB9IGVsc2UgLy9zb21lIG90aGVyIG5vdCBzdXBwb3J0ZWQgYnJvd3NlclxuXHQgICAgICAgIGFzc2VydCh0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCwgXCJDYW52YXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlclwiKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcblx0ICB9LFxuXHQgIGdldENhbnZhczogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgIHZhciBjdHggPSAodGhpcy5fY2FudmFzIHx8IHRoaXMuX3ByZXBhcmVDYW52YXModGhpcy5fY29udGVudG9iaikpLmdldENvbnRleHQoY29udGV4dCB8fCBcIjJkXCIpO1xuXG5cdCAgICBpZiAoIXRoaXMuX3dlYml4RGV2aWNlUGl4ZWxSYXRpbykge1xuXHQgICAgICB0aGlzLl93ZWJpeERldmljZVBpeGVsUmF0aW8gPSB0cnVlO1xuXHQgICAgICBjdHguc2NhbGUod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjdHg7XG5cdCAgfSxcblx0ICBfcmVzaXplQ2FudmFzOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuXHQgICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgeCAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSk7XG5cblx0ICAgICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB5ICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKTtcblxuXHQgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB4ICsgXCJweFwiO1xuXHQgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0geSArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fd2ViaXhEZXZpY2VQaXhlbFJhdGlvID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZW5kZXJUZXh0OiBmdW5jdGlvbiAoeCwgeSwgdGV4dCwgY3NzLCB3KSB7XG5cdCAgICBpZiAoIXRleHQpIHJldHVybjsgLy9pZ25vcmUgZW1wdHkgdGV4dFxuXG5cdCAgICBpZiAodykgdyA9IE1hdGgubWF4KHcsIDApO1xuXHQgICAgaWYgKHkpIHkgPSBNYXRoLm1heCh5LCAwKTtcblx0ICAgIHZhciB0ID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X2NhbnZhc190ZXh0XCIgKyAoY3NzID8gXCIgXCIgKyBjc3MgOiBcIlwiKSxcblx0ICAgICAgXCJzdHlsZVwiOiBcImxlZnQ6XCIgKyB4ICsgXCJweDsgdG9wOlwiICsgeSArIFwicHg7XCIsXG5cdCAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcblx0ICAgIH0sIHRleHQpO1xuXG5cdCAgICB0aGlzLl9vYmouYXBwZW5kQ2hpbGQodCk7XG5cblx0ICAgIHRoaXMuX2NhbnZhc19sYWJlbHMucHVzaCh0KTsgLy9kZXN0cnVjdG9yP1xuXG5cblx0ICAgIGlmICh3KSB0LnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcblx0ICAgIHJldHVybiB0O1xuXHQgIH0sXG5cdCAgcmVuZGVyVGV4dEF0OiBmdW5jdGlvbiAodmFsaWduLCBhbGlnbiwgeCwgeSwgdCwgYywgdykge1xuXHQgICAgdmFyIHRleHQgPSB0aGlzLnJlbmRlclRleHQuY2FsbCh0aGlzLCB4LCB5LCB0LCBjLCB3KTtcblxuXHQgICAgaWYgKHRleHQpIHtcblx0ICAgICAgaWYgKHZhbGlnbikge1xuXHQgICAgICAgIGlmICh2YWxpZ24gPT0gXCJtaWRkbGVcIikgdGV4dC5zdHlsZS50b3AgPSBwYXJzZUludCh5IC0gdGV4dC5vZmZzZXRIZWlnaHQgLyAyLCAxMCkgKyBcInB4XCI7ZWxzZSB0ZXh0LnN0eWxlLnRvcCA9IHkgLSB0ZXh0Lm9mZnNldEhlaWdodCArIFwicHhcIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChhbGlnbikge1xuXHQgICAgICAgIGlmIChhbGlnbiA9PSBcImxlZnRcIikgdGV4dC5zdHlsZS5sZWZ0ID0geCAtIHRleHQub2Zmc2V0V2lkdGggKyBcInB4XCI7ZWxzZSB0ZXh0LnN0eWxlLmxlZnQgPSBwYXJzZUludCh4IC0gdGV4dC5vZmZzZXRXaWR0aCAvIDIsIDEwKSArIFwicHhcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGV4dDtcblx0ICB9LFxuXHQgIGNsZWFyQ2FudmFzOiBmdW5jdGlvbiAoc2tpcE1hcCkge1xuXHQgICAgdmFyIGFyZWFzID0gW107XG5cdCAgICByZW1vdmUodGhpcy5fY2FudmFzX2xhYmVscyk7XG5cdCAgICB0aGlzLl9jYW52YXNfbGFiZWxzID0gW107XG5cblx0ICAgIGlmICghc2tpcE1hcCAmJiB0aGlzLl9vYmouX2h0bWxtYXApIHtcblx0ICAgICAgLy9hcmVhcyB0aGF0IGNvcnJlc3BvbmQgdGhpcyBjYW52YXMgbGF5ZXJcblx0ICAgICAgYXJlYXMgPSB0aGlzLl9nZXRNYXBBcmVhcygpOyAvL3JlbW92ZXMgYXJlYXMgb2YgdGhpcyBjYW52YXNcblxuXHQgICAgICB3aGlsZSAoYXJlYXMubGVuZ3RoKSB7XG5cdCAgICAgICAgYXJlYXNbMF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhcmVhc1swXSk7XG5cdCAgICAgICAgYXJlYXMuc3BsaWNlKDAsIDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXJlYXMgPSBudWxsOyAvL3JlbW92ZXMgX2h0bWxtYXAgb2JqZWN0IGlmIGFsbCBpdHMgY2hpbGQgbm9kZXMgYXJlIHJlbW92ZWRcblxuXHQgICAgICBpZiAoIXRoaXMuX29iai5faHRtbG1hcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkFSRUFcIikubGVuZ3RoKSB7XG5cdCAgICAgICAgdGhpcy5fb2JqLl9odG1sbWFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fb2JqLl9odG1sbWFwKTtcblxuXHQgICAgICAgIHRoaXMuX29iai5faHRtbG1hcCA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH0gLy9GRiBicmVha3MsIHdoZW4gd2UgYXJlIHVzaW5nIGNsZWFyIGNhbnZhcyBhbmQgY2FsbCBjbGVhclJlY3Qgd2l0aG91dCBwYXJhbWV0ZXJzXG5cdCAgICAvL3dpZHRofGhlaWdodCBhcmUgdXNlZCBpbnNlYWQgb2Ygb2Zmc2V0V2lkdGh8b2Zmc2V0SGVpZ2h0IGZvciBoaWRkZW4gY2FudmFzIChzZXJpZXMpXG5cblxuXHQgICAgdGhpcy5nZXRDYW52YXMoKS5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLm9mZnNldFdpZHRoIHx8IE1hdGguZmxvb3IodGhpcy5fY2FudmFzLndpZHRoIC8gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSwgdGhpcy5fY2FudmFzLm9mZnNldEhlaWdodCB8fCBNYXRoLmZsb29yKHRoaXMuX2NhbnZhcy5oZWlnaHQgLyAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpKTtcblx0ICB9LFxuXHQgIHRvZ2dsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdG9nZ2xlQ2FudmFzKHRoaXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKTtcblx0ICB9LFxuXHQgIHNob3dDYW52YXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3RvZ2dsZUNhbnZhcyh0cnVlKTtcblx0ICB9LFxuXHQgIGhpZGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3RvZ2dsZUNhbnZhcyhmYWxzZSk7XG5cdCAgfSxcblx0ICBfdG9nZ2xlQ2FudmFzOiBmdW5jdGlvbiAoc2hvdykge1xuXHQgICAgdmFyIGFyZWFzLCBpO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fY2FudmFzX2xhYmVscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9jYW52YXNfbGFiZWxzW2ldLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gXCJcIiA6IFwibm9uZVwiO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fb2JqLl9odG1sbWFwKSB7XG5cdCAgICAgIGFyZWFzID0gdGhpcy5fZ2V0TWFwQXJlYXMoKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJlYXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoc2hvdykgYXJlYXNbaV0ucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7ZWxzZSBhcmVhc1tpXS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcInRydWVcIik7XG5cdCAgICAgIH1cblx0ICAgIH0gLy9GRiBicmVha3MsIHdoZW4gd2UgYXJlIHVzaW5nIGNsZWFyIGNhbnZhcyBhbmQgY2FsbCBjbGVhclJlY3Qgd2l0aG91dCBwYXJhbWV0ZXJzXG5cblxuXHQgICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gXCJcIiA6IFwibm9uZVwiO1xuXHQgIH0sXG5cdCAgX2dldE1hcEFyZWFzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmVzID0gW10sXG5cdCAgICAgICAgYXJlYXMsXG5cdCAgICAgICAgaTtcblx0ICAgIGFyZWFzID0gdGhpcy5fb2JqLl9odG1sbWFwLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQVJFQVwiKTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGFyZWFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChhcmVhc1tpXS5nZXRBdHRyaWJ1dGUoXCJ1c2VyZGF0YVwiKSA9PSB0aGlzLl9jYW52YXNfc2VyaWVzKSB7XG5cdCAgICAgICAgcmVzLnB1c2goYXJlYXNbaV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfVxuXHR9KTtcblxuXHR2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uIChodG1sX2VsZW1lbnQsIGNvbmZpZykge1xuXHQgIHZhciBhbmltYXRpb24gPSBjb25maWc7XG5cblx0ICBpZiAoaXNBcnJheShodG1sX2VsZW1lbnQpKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh0bWxfZWxlbWVudC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoaXNBcnJheShjb25maWcpKSBhbmltYXRpb24gPSBjb25maWdbaV07XG5cblx0ICAgICAgaWYgKGFuaW1hdGlvbi50eXBlID09IFwic2xpZGVcIikge1xuXHQgICAgICAgIGlmIChhbmltYXRpb24uc3VidHlwZSA9PSBcIm91dFwiICYmIGkgPT09IDApIHtcblx0ICAgICAgICAgIC8vIG5leHRcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChhbmltYXRpb24uc3VidHlwZSA9PSBcImluXCIgJiYgaSA9PSAxKSB7XG5cdCAgICAgICAgICAvLyBjdXJyZW50XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoYW5pbWF0aW9uLnR5cGUgPT0gXCJmbGlwXCIpIHtcblx0ICAgICAgICB2YXIgYW5pbWF0aW9uX2NvcHkgPSBjbG9uZShhbmltYXRpb24pO1xuXG5cdCAgICAgICAgaWYgKGkgPT09IDApIHtcblx0ICAgICAgICAgIC8vIG5leHRcblx0ICAgICAgICAgIGFuaW1hdGlvbl9jb3B5LnR5cGUgPSBcImZsaXBiYWNrXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGkgPT0gMSkge1xuXHQgICAgICAgICAgLy8gY3VycmVudFxuXHQgICAgICAgICAgYW5pbWF0aW9uX2NvcHkuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGFuaW1hdGUoaHRtbF9lbGVtZW50W2ldLCBhbmltYXRpb25fY29weSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBhbmltYXRlKGh0bWxfZWxlbWVudFtpXSwgYW5pbWF0aW9uKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXHQgIHZhciBub2RlID0gdG9Ob2RlKGh0bWxfZWxlbWVudCk7XG5cdCAgaWYgKG5vZGUuX2hhc19hbmltYXRpb24pIGFuaW1hdGUuZW5kKG5vZGUsIGFuaW1hdGlvbik7ZWxzZSBhbmltYXRlLnN0YXJ0KG5vZGUsIGFuaW1hdGlvbik7XG5cdH07XG5cblx0YW5pbWF0ZS5lbmQgPSBmdW5jdGlvbiAobm9kZSwgYW5pbWF0aW9uKSB7XG5cdCAgLy9zdG9wIGFuaW1hdGlvblxuXHQgIG5vZGUuc3R5bGVbZW52LnRyYW5zaXRpb25EdXJhdGlvbl0gPSBcIjFtc1wiO1xuXHQgIG5vZGUuX2hhc19hbmltYXRpb24gPSBudWxsOyAvL2NsZWFyIGFuaW1hdGlvbiB3YWl0IG9yZGVyLCBpZiBhbnlcblxuXHQgIGlmIChzdGF0ZS5fd2FpdF9hbmltYXRlKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHN0YXRlLl93YWl0X2FuaW1hdGUpOyAvL3BsYW4gbmV4dCBhbmltYXRpb24sIGlmIGFueVxuXG5cdCAgc3RhdGUuX3dhaXRfYW5pbWF0ZSA9IGRlbGF5KGFuaW1hdGUsIHRoaXMsIFtub2RlLCBhbmltYXRpb25dLCAxMCk7XG5cdH07XG5cblx0YW5pbWF0ZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gIXN0YXRlLm5vYW5pbWF0ZSAmJiBlbnYudHJhbnNmb3JtICYmIGVudi50cmFuc2l0aW9uICYmICFlbnYuaXNPcGVyYTtcblx0fTtcblxuXHRhbmltYXRlLmZvcm1MaW5lID0gZnVuY3Rpb24gKG5leHQsIGN1cnJlbnQsIGFuaW1hdGlvbikge1xuXHQgIHZhciBkaXJlY3Rpb24gPSBhbmltYXRpb24uZGlyZWN0aW9uOyAvL3NvbWV0aW1lcyB1c2VyIGNhbiBpbml0aWF0ZSBhbmltYXRpb24gbXVsdGlwbGUgdGltZXMgKCBmYXN0IGNsaWNraW5nIClcblx0ICAvL2FzIHJlc3VsdCBhbmltYXRpb24gbWF5IGJlIGNhbGxlZCBhZ2FpbnN0IGFscmVhZHkgcmVtb3ZlZCBmcm9tIHRoZSBkb20gbm9kZVxuXG5cdCAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSkgY3VycmVudC5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHQgIGN1cnJlbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdCAgbmV4dC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjsgLy90aGlzIGlzIGluaXRpYWwgc2hpZnQgb2Ygc2Vjb25kIHZpZXcgaW4gYW5pbWF0aW9uXG5cdCAgLy9ub3JtYWxseSB3ZSBuZWVkIHRvIGhhdmUgdGhpcyB2YWx1ZSBhcyAwXG5cdCAgLy9idXQgRkYgaGFzIGJ1ZyB3aXRoIGFuaW1hdGlvbiBpbml0aWFsbHkgaW52aXNpYmxlIGVsZW1lbnRzXG5cdCAgLy9zbyB3ZSBhcmUgYWRqdXN0aW5nIHRoaXMgdmFsdWUsIHRvIG1ha2UgMXB4IG9mIHNlY29uZCB2aWV3IHZpc2libGVcblxuXHQgIHZhciBkZWZBbmlQb3MgPSBlbnYuaXNGRiA/IGRpcmVjdGlvbiA9PSBcInRvcFwiIHx8IGRpcmVjdGlvbiA9PSBcImxlZnRcIiA/IC0xIDogMSA6IDA7XG5cblx0ICBpZiAoZGlyZWN0aW9uID09IFwidG9wXCIgfHwgZGlyZWN0aW9uID09IFwiYm90dG9tXCIpIHtcblx0ICAgIG5leHQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG5cdCAgICBuZXh0LnN0eWxlLnRvcCA9IChhbmltYXRpb24udG9wIHx8IGRlZkFuaVBvcykgKyAoZGlyZWN0aW9uID09IFwidG9wXCIgPyAxIDogLTEpICogY3VycmVudC5vZmZzZXRIZWlnaHQgKyBcInB4XCI7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG5leHQuc3R5bGUudG9wID0gKGFuaW1hdGlvbi50b3AgfHwgMCkgKyBcInB4XCI7XG5cdCAgICBuZXh0LnN0eWxlLmxlZnQgPSBkZWZBbmlQb3MgKyAoZGlyZWN0aW9uID09IFwibGVmdFwiID8gMSA6IC0xKSAqIGN1cnJlbnQub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cdCAgfSAvLyBhcHBseSAna2VlcFZpZXdzJyBtb2RlLCBpZnJhbWUsIGRhdGF0YWJsZSB3aXRoIHggc2Nyb2xsIHNvbHV0aW9uXG5cdCAgLy8oIGtlZXBWaWV3cyB3b24ndCB3b3JrIGluIGNhc2Ugb2YgXCJpblwiIGFuZCBcIm91dFwiIHN1YnR5cGVzIClcblxuXG5cdCAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSA9PSBuZXh0LnBhcmVudE5vZGUgJiYgYW5pbWF0aW9uLmtlZXBWaWV3cykgbmV4dC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtlbHNlIGluc2VydEJlZm9yZShuZXh0LCBjdXJyZW50Lm5leHRTaWJsaW5nLCBjdXJyZW50LnBhcmVudE5vZGUpO1xuXG5cdCAgaWYgKGFuaW1hdGlvbi50eXBlID09IFwic2xpZGVcIiAmJiBhbmltYXRpb24uc3VidHlwZSA9PSBcIm91dFwiKSB7XG5cdCAgICBuZXh0LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuXHQgICAgbmV4dC5zdHlsZS50b3AgPSAoYW5pbWF0aW9uLnRvcCB8fCAwKSArIFwicHhcIjtcblx0ICAgIGN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50KTtcblx0ICAgIGluc2VydEJlZm9yZShjdXJyZW50LCBuZXh0Lm5leHRTaWJsaW5nLCBuZXh0LnBhcmVudE5vZGUpO1xuXHQgIH1cblxuXHQgIHJldHVybiBbbmV4dCwgY3VycmVudF07XG5cdH07XG5cblx0YW5pbWF0ZS5icmVha0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuXHQgIGlmIChhcmd1bWVudHNbMV0pIGxpbmVbMV0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyAvLyAna2VlcFZpZXdzJyBtdWx0aXZpZXcgbW9kZVxuXHQgIGVsc2UgcmVtb3ZlKGxpbmVbMV0pOyAvLyAxID0gY3VycmVudFxuXG5cdCAgYW5pbWF0ZS5jbGVhcihsaW5lWzBdKTtcblx0ICBhbmltYXRlLmNsZWFyKGxpbmVbMV0pO1xuXHQgIGxpbmVbMF0uc3R5bGUucG9zaXRpb24gPSBcIlwiO1xuXHR9O1xuXG5cdGFuaW1hdGUuY2xlYXIgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgIG5vZGUuc3R5bGVbZW52LnRyYW5zZm9ybV0gPSBcIm5vbmVcIjtcblx0ICBub2RlLnN0eWxlW2Vudi50cmFuc2l0aW9uXSA9IFwibm9uZVwiO1xuXHQgIG5vZGUuc3R5bGUudG9wID0gbm9kZS5zdHlsZS5sZWZ0ID0gXCJcIjtcblx0fTtcblxuXHRhbmltYXRlLmRlZmF1bHRzID0ge1xuXHQgIHR5cGU6IFwic2xpZGVcIixcblx0ICBkZWxheTogXCIwXCIsXG5cdCAgZHVyYXRpb246IFwiNTAwXCIsXG5cdCAgdGltaW5nOiBcImVhc2UtaW4tb3V0XCIsXG5cdCAgeDogMCxcblx0ICB5OiAwXG5cdH07XG5cblx0YW5pbWF0ZS5zdGFydCA9IGZ1bmN0aW9uIChub2RlLCBhbmltYXRpb24pIHtcblx0ICAvL2dldHRpbmcgY29uZmlnIG9iamVjdCBieSBtZXJnaW5nIHNwZWNpZmllZCBhbmQgZGVmYXVsdCBvcHRpb25zXG5cdCAgaWYgKHR5cGVvZiBhbmltYXRpb24gPT0gXCJzdHJpbmdcIikgYW5pbWF0aW9uID0ge1xuXHQgICAgdHlwZTogYW5pbWF0aW9uXG5cdCAgfTtcblx0ICBhbmltYXRpb24gPSBTZXR0aW5ncy5fbWVyZ2VTZXR0aW5ncyhhbmltYXRpb24sIGFuaW1hdGUuZGVmYXVsdHMpO1xuXHQgIHZhciBwcmVmaXggPSBlbnYuY3NzUHJlZml4O1xuXHQgIHZhciBzZXR0aW5ncyA9IG5vZGUuX2hhc19hbmltYXRpb24gPSBhbmltYXRpb247XG5cdCAgdmFyIHNrZXdfb3B0aW9ucywgc2NhbGVfdHlwZTsgLy9qc2hpbnQgLVcwODY6dHJ1ZVxuXG5cdCAgc3dpdGNoIChzZXR0aW5ncy50eXBlID09IFwic2xpZGVcIiAmJiBzZXR0aW5ncy5kaXJlY3Rpb24pIHtcblx0ICAgIC8vIGdldHRpbmcgbmV3IHgsIHkgaW4gY2FzZSBpdCBpcyBzbGlkZSB3aXRoIGRpcmVjdGlvblxuXHQgICAgY2FzZSBcInJpZ2h0XCI6XG5cdCAgICAgIHNldHRpbmdzLnggPSBub2RlLm9mZnNldFdpZHRoO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBcImxlZnRcIjpcblx0ICAgICAgc2V0dGluZ3MueCA9IC1ub2RlLm9mZnNldFdpZHRoO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBcInRvcFwiOlxuXHQgICAgICBzZXR0aW5ncy55ID0gLW5vZGUub2Zmc2V0SGVpZ2h0O1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBcImJvdHRvbVwiOlxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgc2V0dGluZ3MueSA9IHNldHRpbmdzLnkgfHwgbm9kZS5vZmZzZXRIZWlnaHQ7XG5cdCAgICAgIGJyZWFrO1xuXHQgIH1cblxuXHQgIGlmIChzZXR0aW5ncy50eXBlID09IFwiZmxpcFwiIHx8IHNldHRpbmdzLnR5cGUgPT0gXCJmbGlwYmFja1wiKSB7XG5cdCAgICBza2V3X29wdGlvbnMgPSBbMCwgMF07XG5cdCAgICBzY2FsZV90eXBlID0gXCJzY2FsZVhcIjtcblxuXHQgICAgaWYgKHNldHRpbmdzLnN1YnR5cGUgPT0gXCJ2ZXJ0aWNhbFwiKSB7XG5cdCAgICAgIHNrZXdfb3B0aW9uc1swXSA9IDIwO1xuXHQgICAgICBzY2FsZV90eXBlID0gXCJzY2FsZVlcIjtcblx0ICAgIH0gZWxzZSBza2V3X29wdGlvbnNbMV0gPSAyMDtcblxuXHQgICAgaWYgKHNldHRpbmdzLmRpcmVjdGlvbiA9PSBcInJpZ2h0XCIgfHwgc2V0dGluZ3MuZGlyZWN0aW9uID09IFwiYm90dG9tXCIpIHtcblx0ICAgICAgc2tld19vcHRpb25zWzBdICo9IC0xO1xuXHQgICAgICBza2V3X29wdGlvbnNbMV0gKj0gLTE7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGR1cmF0aW9uID0gc2V0dGluZ3MuZHVyYXRpb24gKyBcIm1zIFwiICsgc2V0dGluZ3MudGltaW5nICsgXCIgXCIgKyBzZXR0aW5ncy5kZWxheSArIFwibXNcIjtcblx0ICB2YXIgY3NzX2dlbmVyYWwgPSBwcmVmaXggKyBcIlRyYW5zZm9ybVN0eWxlOiBwcmVzZXJ2ZS0zZDtcIjsgLy8gZ2VuZXJhbCBjc3MgcnVsZXNcblxuXHQgIHZhciBjc3NfdHJhbnNpdGlvbiA9IFwiXCI7XG5cdCAgdmFyIGNzc190cmFuc2Zvcm0gPSBcIlwiO1xuXG5cdCAgc3dpdGNoIChzZXR0aW5ncy50eXBlKSB7XG5cdCAgICBjYXNlIFwiZmFkZVwiOlxuXHQgICAgICAvLyBjaGFuZ2VzIG9wYWNpdHkgdG8gMFxuXHQgICAgICBjc3NfdHJhbnNpdGlvbiA9IFwib3BhY2l0eSBcIiArIGR1cmF0aW9uO1xuXHQgICAgICBjc3NfZ2VuZXJhbCA9IFwib3BhY2l0eTogMDtcIjtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgXCJzaG93XCI6XG5cdCAgICAgIC8vIGNoYW5nZXMgb3BhY2l0eSB0byAxXG5cdCAgICAgIGNzc190cmFuc2l0aW9uID0gXCJvcGFjaXR5IFwiICsgZHVyYXRpb247XG5cdCAgICAgIGNzc19nZW5lcmFsID0gXCJvcGFjaXR5OiAxO1wiO1xuXHQgICAgICBicmVhaztcblxuXHQgICAgY2FzZSBcImZsaXBcIjpcblx0ICAgICAgZHVyYXRpb24gPSBzZXR0aW5ncy5kdXJhdGlvbiAvIDIgKyBcIm1zIFwiICsgc2V0dGluZ3MudGltaW5nICsgXCIgXCIgKyBzZXR0aW5ncy5kZWxheSArIFwibXNcIjtcblx0ICAgICAgY3NzX3RyYW5zZm9ybSA9IFwic2tldyhcIiArIHNrZXdfb3B0aW9uc1swXSArIFwiZGVnLCBcIiArIHNrZXdfb3B0aW9uc1sxXSArIFwiZGVnKSBcIiArIHNjYWxlX3R5cGUgKyBcIigwLjAwMDAxKVwiO1xuXHQgICAgICBjc3NfdHJhbnNpdGlvbiA9IFwiYWxsIFwiICsgZHVyYXRpb247XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIFwiZmxpcGJhY2tcIjpcblx0ICAgICAgc2V0dGluZ3MuZGVsYXkgKz0gc2V0dGluZ3MuZHVyYXRpb24gLyAyO1xuXHQgICAgICBkdXJhdGlvbiA9IHNldHRpbmdzLmR1cmF0aW9uIC8gMiArIFwibXMgXCIgKyBzZXR0aW5ncy50aW1pbmcgKyBcIiBcIiArIHNldHRpbmdzLmRlbGF5ICsgXCJtc1wiO1xuXHQgICAgICBub2RlLnN0eWxlW2Vudi50cmFuc2Zvcm1dID0gXCJza2V3KFwiICsgLTEgKiBza2V3X29wdGlvbnNbMF0gKyBcImRlZywgXCIgKyAtMSAqIHNrZXdfb3B0aW9uc1sxXSArIFwiZGVnKSBcIiArIHNjYWxlX3R5cGUgKyBcIigwLjAwMDAxKVwiO1xuXHQgICAgICBub2RlLnN0eWxlLmxlZnQgPSBcIjBcIjtcblx0ICAgICAgY3NzX3RyYW5zZm9ybSA9IFwic2tldygwZGVnLCAwZGVnKSBcIiArIHNjYWxlX3R5cGUgKyBcIigxKVwiO1xuXHQgICAgICBjc3NfdHJhbnNpdGlvbiA9IFwiYWxsIFwiICsgZHVyYXRpb247XG5cdCAgICAgIGJyZWFrO1xuXG5cdCAgICBjYXNlIFwic2xpZGVcIjpcblx0ICAgICAgLy8gbW92ZXMgb2JqZWN0IHRvIHNwZWNpZmllZCBsb2NhdGlvblxuXHQgICAgICB2YXIgeCA9IHNldHRpbmdzLnggKyBcInB4XCI7XG5cdCAgICAgIHZhciB5ID0gc2V0dGluZ3MueSArIFwicHhcIjsgLy8gdHJhbnNsYXRlKHgsIHkpIE9SIHRyYW5zbGF0ZTNkKHgsIHksIDApXG5cblx0ICAgICAgY3NzX3RyYW5zZm9ybSA9IGVudi50cmFuc2xhdGUgKyBcIihcIiArIHggKyBcIiwgXCIgKyB5ICsgKGVudi50cmFuc2xhdGUgPT0gXCJ0cmFuc2xhdGUzZFwiID8gXCIsIDBcIiA6IFwiXCIpICsgXCIpXCI7XG5cdCAgICAgIGNzc190cmFuc2l0aW9uID0gcHJlZml4ICsgXCJ0cmFuc2Zvcm0gXCIgKyBkdXJhdGlvbjtcblx0ICAgICAgYnJlYWs7XG5cblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIGJyZWFrO1xuXHQgIH0gLy9zZXQgc3R5bGVzIG9ubHkgYWZ0ZXIgYXBwbHlpbmcgdHJhbnNpdGlvbiBzZXR0aW5nc1xuXG5cblx0ICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICBub2RlLnN0eWxlW2Vudi50cmFuc2l0aW9uXSA9IGNzc190cmFuc2l0aW9uO1xuXHQgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoY3NzX2dlbmVyYWwpIG5vZGUuc3R5bGUuY3NzVGV4dCArPSBjc3NfZ2VuZXJhbDtcblx0ICAgICAgaWYgKGNzc190cmFuc2Zvcm0pIG5vZGUuc3R5bGVbZW52LnRyYW5zZm9ybV0gPSBjc3NfdHJhbnNmb3JtO1xuXHQgICAgICB2YXIgdHJhbnNpdGlvbkVuZGVkID0gZmFsc2U7XG5cdCAgICAgIHZhciB0aWQgPSBldmVudCQxKG5vZGUsIGVudi50cmFuc2l0aW9uRW5kLCBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgICBub2RlLl9oYXNfYW5pbWF0aW9uID0gbnVsbDtcblx0ICAgICAgICBpZiAoc2V0dGluZ3MuY2FsbGJhY2spIHNldHRpbmdzLmNhbGxiYWNrLmNhbGwoc2V0dGluZ3MubWFzdGVyIHx8IHdpbmRvdywgbm9kZSwgc2V0dGluZ3MsIGV2KTtcblx0ICAgICAgICB0cmFuc2l0aW9uRW5kZWQgPSB0cnVlO1xuXHQgICAgICAgIGV2ZW50UmVtb3ZlKHRpZCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF0cmFuc2l0aW9uRW5kZWQpIHtcblx0ICAgICAgICAgIG5vZGUuX2hhc19hbmltYXRpb24gPSBudWxsO1xuXHQgICAgICAgICAgaWYgKHNldHRpbmdzLmNhbGxiYWNrKSBzZXR0aW5ncy5jYWxsYmFjay5jYWxsKHNldHRpbmdzLm1hc3RlciB8fCB3aW5kb3csIG5vZGUsIHNldHRpbmdzKTtcblx0ICAgICAgICAgIHRyYW5zaXRpb25FbmRlZCA9IHRydWU7XG5cdCAgICAgICAgICBldmVudFJlbW92ZSh0aWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgKHNldHRpbmdzLmR1cmF0aW9uICogMSArIHNldHRpbmdzLmRlbGF5ICogMSkgKiAxLjMpO1xuXHQgICAgfSk7XG5cdCAgfSk7XG5cdH07XG5cblx0dmFyIHNraW4gPSB7XG5cdCAgdG9wTGF5b3V0OiBcInNwYWNlXCIsXG5cdCAgLy9iYXIgaW4gYWNjb3JkaW9uXG5cdCAgYmFySGVpZ2h0OiA0NCxcblx0ICAvLyEhIVNldCB0aGUgc2FtZSBpbiBza2luLmxlc3MhISFcblx0ICB0YWJiYXJIZWlnaHQ6IDQyLFxuXHQgIHNpZGViYXJUaXRsZUhlaWdodDogNDQsXG5cdCAgcm93SGVpZ2h0OiAzNixcblx0ICB0b29sYmFySGVpZ2h0OiA0NCxcblx0ICBsaXN0SXRlbUhlaWdodDogMzYsXG5cdCAgLy9saXN0LCBncm91cGxpc3QsIGRhdGF2aWV3LCBldGMuXG5cdCAgaW5wdXRIZWlnaHQ6IDM4LFxuXHQgIGJ1dHRvbkhlaWdodDogMzgsXG5cdCAgaW5wdXRQYWRkaW5nOiAzLFxuXHQgIG1lbnVIZWlnaHQ6IDM2LFxuXHQgIGxhYmVsVG9wSGVpZ2h0OiAyMixcblx0ICBwcm9wZXJ0eUl0ZW1IZWlnaHQ6IDI4LFxuXHQgIHVuaXRIZWFkZXJIZWlnaHQ6IDM2LFxuXHQgIGlucHV0U3BhY2luZzogNCxcblx0ICBib3JkZXJXaWR0aDogMSxcblx0ICBzbGlkZXJIYW5kbGVXaWR0aDogMTQsXG5cdCAgc2xpZGVyUGFkZGluZzogMTAsXG5cdCAgc2xpZGVyQm9yZGVyOiAxLFxuXHQgIHZTbGlkZXJQYWRkaW5nOiAxNSxcblx0ICB2U2xpZGVySGVpZ2h0OiAxMDAsXG5cdCAgc3dpdGNoSGVpZ2h0OiAyMixcblx0ICBzd2l0Y2hXaWR0aDogNTAsXG5cdCAgLy9tYXJnaW4gLSBkaXN0YW5jZSBiZXR3ZWVuIGNlbGxzXG5cdCAgbGF5b3V0TWFyZ2luOiB7XG5cdCAgICBzcGFjZTogMTAsXG5cdCAgICB3aWRlOiAxMCxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogNCxcblx0ICAgIGxpbmU6IC0xLFxuXHQgICAgdG9vbGJhcjogNCxcblx0ICAgIGZvcm06IDgsXG5cdCAgICBhY2NvcmRpb246IDJcblx0ICB9LFxuXHQgIC8vcGFkZGluZyAtIGRpc3RhbmNlIGluc2lkZSBjZWxsIGJldHdlZW4gY2VsbCBib3JkZXIgYW5kIGNlbGwgY29udGVudFxuXHQgIGxheW91dFBhZGRpbmc6IHtcblx0ICAgIHNwYWNlOiAxMCxcblx0ICAgIHdpZGU6IDAsXG5cdCAgICBjbGVhbjogMCxcblx0ICAgIGhlYWQ6IDAsXG5cdCAgICBsaW5lOiAwLFxuXHQgICAgdG9vbGJhcjogMixcblx0ICAgIGZvcm06IDE3LFxuXHQgICAgYWNjb3JkaW9uOiAwXG5cdCAgfSxcblx0ICAvL3NwYWNlIGJldHdlZW4gdGFicyBpbiB0YWJiYXJcblx0ICB0YWJNYXJnaW46IDAsXG5cdCAgdGFiT2Zmc2V0OiAwLFxuXHQgIHRhYkJvdHRvbU9mZnNldDogMCxcblx0ICB0YWJUb3BPZmZzZXQ6IDAsXG5cdCAgdGFiQm9yZGVyOiB0cnVlLFxuXHQgIGN1c3RvbUNoZWNrYm94OiB0cnVlLFxuXHQgIGN1c3RvbVJhZGlvOiB0cnVlLFxuXHQgIHNpZGViYXJNYXJrQWxsOiB0cnVlLFxuXHQgIHBvcHVwTm9Qb2ludDogdHJ1ZSxcblx0ICBib3JkZXJsZXNzUG9wdXA6IHRydWUsXG5cdCAgcG9wdXBQYWRkaW5nOiAwLFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICB0aW1lcGlja2VySGVpZ2h0OiAyNFxuXHQgIH0sXG5cdCAgY2FsZW5kYXJIZWlnaHQ6IDcwLFxuXHQgIHBhZGRpbmc6IDAsXG5cdCAgYWNjb3JkaW9uVHlwZTogXCJhY2NvcmRpb25cIixcblx0ICBvcHRpb25IZWlnaHQ6IDMyLFxuXHQgIG9yZ2Fub2dyYW1MaW5lQ29sb3I6IFwiI0NDRDdFNlwiXG5cdH07XG5cblx0dmFyIHNraW4kMSA9IHtcblx0ICB0b3BMYXlvdXQ6IFwic3BhY2VcIixcblx0ICAvL2JhciBpbiBhY2NvcmRpb25cblx0ICBiYXJIZWlnaHQ6IDM2LFxuXHQgIC8vISEhU2V0IHRoZSBzYW1lIGluIHNraW4ubGVzcyEhIVxuXHQgIHRhYmJhckhlaWdodDogMzQsXG5cdCAgc2lkZWJhclRpdGxlSGVpZ2h0OiAzNixcblx0ICByb3dIZWlnaHQ6IDI4LFxuXHQgIHRvb2xiYXJIZWlnaHQ6IDM2LFxuXHQgIGxpc3RJdGVtSGVpZ2h0OiAyOCxcblx0ICAvL2xpc3QsIGdyb3VwbGlzdCwgZGF0YXZpZXcsIGV0Yy5cblx0ICBpbnB1dEhlaWdodDogMzAsXG5cdCAgYnV0dG9uSGVpZ2h0OiAzMCxcblx0ICBpbnB1dFBhZGRpbmc6IDMsXG5cdCAgbWVudUhlaWdodDogMjgsXG5cdCAgbGFiZWxUb3BIZWlnaHQ6IDE2LFxuXHQgIHByb3BlcnR5SXRlbUhlaWdodDogMjQsXG5cdCAgdW5pdEhlYWRlckhlaWdodDogMjgsXG5cdCAgaW5wdXRTcGFjaW5nOiA0LFxuXHQgIGJvcmRlcldpZHRoOiAxLFxuXHQgIHNsaWRlckhhbmRsZVdpZHRoOiAxMixcblx0ICBzbGlkZXJQYWRkaW5nOiAxMCxcblx0ICBzbGlkZXJCb3JkZXI6IDEsXG5cdCAgdlNsaWRlclBhZGRpbmc6IDEzLFxuXHQgIHZTbGlkZXJIZWlnaHQ6IDEwMCxcblx0ICBzd2l0Y2hIZWlnaHQ6IDIwLFxuXHQgIHN3aXRjaFdpZHRoOiA0MCxcblx0ICAvL21hcmdpbiAtIGRpc3RhbmNlIGJldHdlZW4gY2VsbHNcblx0ICBsYXlvdXRNYXJnaW46IHtcblx0ICAgIHNwYWNlOiA1LFxuXHQgICAgd2lkZTogNSxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogNCxcblx0ICAgIGxpbmU6IC0xLFxuXHQgICAgdG9vbGJhcjogNCxcblx0ICAgIGZvcm06IDgsXG5cdCAgICBhY2NvcmRpb246IDJcblx0ICB9LFxuXHQgIC8vcGFkZGluZyAtIGRpc3RhbmNlIGluc2lkZSBjZWxsIGJldHdlZW4gY2VsbCBib3JkZXIgYW5kIGNlbGwgY29udGVudFxuXHQgIGxheW91dFBhZGRpbmc6IHtcblx0ICAgIHNwYWNlOiA1LFxuXHQgICAgd2lkZTogMCxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogMCxcblx0ICAgIGxpbmU6IDAsXG5cdCAgICB0b29sYmFyOiAyLFxuXHQgICAgZm9ybTogMTIsXG5cdCAgICBhY2NvcmRpb246IDBcblx0ICB9LFxuXHQgIC8vc3BhY2UgYmV0d2VlbiB0YWJzIGluIHRhYmJhclxuXHQgIHRhYk1hcmdpbjogMCxcblx0ICB0YWJPZmZzZXQ6IDAsXG5cdCAgdGFiQm90dG9tT2Zmc2V0OiAwLFxuXHQgIHRhYlRvcE9mZnNldDogMCxcblx0ICB0YWJCb3JkZXI6IHRydWUsXG5cdCAgY3VzdG9tQ2hlY2tib3g6IHRydWUsXG5cdCAgY3VzdG9tUmFkaW86IHRydWUsXG5cdCAgc2lkZWJhck1hcmtBbGw6IHRydWUsXG5cdCAgcG9wdXBOb1BvaW50OiB0cnVlLFxuXHQgIGJvcmRlcmxlc3NQb3B1cDogdHJ1ZSxcblx0ICBwb3B1cFBhZGRpbmc6IDAsXG5cdCAgY2FsZW5kYXI6IHtcblx0ICAgIHRpbWVwaWNrZXJIZWlnaHQ6IDI0XG5cdCAgfSxcblx0ICBjYWxlbmRhckhlaWdodDogNzAsXG5cdCAgcGFkZGluZzogMCxcblx0ICBhY2NvcmRpb25UeXBlOiBcImFjY29yZGlvblwiLFxuXHQgIG9wdGlvbkhlaWdodDogMjQsXG5cdCAgb3JnYW5vZ3JhbUxpbmVDb2xvcjogXCIjQ0NEN0U2XCJcblx0fTtcblxuXHR2YXIgc2tpbiQyID0ge1xuXHQgIHRvcExheW91dDogXCJzcGFjZVwiLFxuXHQgIC8vYmFyIGluIGFjY29yZGlvblxuXHQgIGJhckhlaWdodDogNDYsXG5cdCAgLy8hISFTZXQgdGhlIHNhbWUgaW4gc2tpbi5sZXNzISEhXG5cdCAgdGFiYmFySGVpZ2h0OiA0Nixcblx0ICByb3dIZWlnaHQ6IDM0LFxuXHQgIHRvb2xiYXJIZWlnaHQ6IDQ2LFxuXHQgIHNpZGViYXJUaXRsZUhlaWdodDogNDUsXG5cdCAgbGlzdEl0ZW1IZWlnaHQ6IDM0LFxuXHQgIC8vbGlzdCwgZ3JvdXBsaXN0LCBkYXRhdmlldywgZXRjLlxuXHQgIGlucHV0SGVpZ2h0OiAzOCxcblx0ICBidXR0b25IZWlnaHQ6IDM4LFxuXHQgIGlucHV0UGFkZGluZzogMyxcblx0ICBtZW51SGVpZ2h0OiAzNCxcblx0ICBsYWJlbFRvcEhlaWdodDogMjIsXG5cdCAgdW5pdEhlYWRlckhlaWdodDogMjAsXG5cdCAgcHJvcGVydHlJdGVtSGVpZ2h0OiAyOCxcblx0ICBpbnB1dFNwYWNpbmc6IDQsXG5cdCAgYm9yZGVyV2lkdGg6IDEsXG5cdCAgc2xpZGVySGFuZGxlV2lkdGg6IDE0LFxuXHQgIHNsaWRlclBhZGRpbmc6IDEwLFxuXHQgIHNsaWRlckJvcmRlcjogMSxcblx0ICB2U2xpZGVyUGFkZGluZzogMTUsXG5cdCAgdlNsaWRlckhlaWdodDogMTAwLFxuXHQgIHN3aXRjaEhlaWdodDogMjIsXG5cdCAgc3dpdGNoV2lkdGg6IDUwLFxuXHQgIC8vbWFyZ2luIC0gZGlzdGFuY2UgYmV0d2VlbiBjZWxsc1xuXHQgIGxheW91dE1hcmdpbjoge1xuXHQgICAgc3BhY2U6IDEwLFxuXHQgICAgd2lkZTogMTAsXG5cdCAgICBjbGVhbjogMCxcblx0ICAgIGhlYWQ6IDQsXG5cdCAgICBsaW5lOiAtMSxcblx0ICAgIHRvb2xiYXI6IDQsXG5cdCAgICBmb3JtOiA4LFxuXHQgICAgYWNjb3JkaW9uOiAxMFxuXHQgIH0sXG5cdCAgLy9wYWRkaW5nIC0gZGlzdGFuY2UgaW5zZWRlIGNlbGwgYmV0d2VlbiBjZWxsIGJvcmRlciBhbmQgY2VsbCBjb250ZW50XG5cdCAgbGF5b3V0UGFkZGluZzoge1xuXHQgICAgc3BhY2U6IDEwLFxuXHQgICAgd2lkZTogMCxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogMCxcblx0ICAgIGxpbmU6IDAsXG5cdCAgICB0b29sYmFyOiAzLFxuXHQgICAgZm9ybTogMTcsXG5cdCAgICBhY2NvcmRpb246IDBcblx0ICB9LFxuXHQgIC8vc3BhY2UgYmV0d2VlbiB0YWJzIGluIHRhYmJhclxuXHQgIHRhYk1hcmdpbjogNCxcblx0ICB0YWJPZmZzZXQ6IDAsXG5cdCAgdGFiQm90dG9tT2Zmc2V0OiA2LFxuXHQgIHRhYlRvcE9mZnNldDogMSxcblx0ICBjdXN0b21DaGVja2JveDogdHJ1ZSxcblx0ICBjdXN0b21SYWRpbzogdHJ1ZSxcblx0ICBwb3B1cFBhZGRpbmc6IDgsXG5cdCAgY2FsZW5kYXJIZWlnaHQ6IDcwLFxuXHQgIHBhZGRpbmc6IDAsXG5cdCAgYWNjb3JkaW9uVHlwZTogXCJhY2NvcmRpb25cIixcblx0ICBvcHRpb25IZWlnaHQ6IDMyXG5cdH07XG5cblx0dmFyIHNraW4kMyA9IHtcblx0ICB0b3BMYXlvdXQ6IFwic3BhY2VcIixcblx0ICAvL2JhciBpbiBhY2NvcmRpb25cblx0ICBiYXJIZWlnaHQ6IDM0LFxuXHQgIC8vISEhU2V0IHRoZSBzYW1lIGluIHNraW4ubGVzcyEhIVxuXHQgIHRhYmJhckhlaWdodDogMzQsXG5cdCAgc2lkZWJhclRpdGxlSGVpZ2h0OiAzNCxcblx0ICByb3dIZWlnaHQ6IDI0LFxuXHQgIHRvb2xiYXJIZWlnaHQ6IDM0LFxuXHQgIGxpc3RJdGVtSGVpZ2h0OiAyOCxcblx0ICAvL2xpc3QsIGdyb3VwbGlzdCwgZGF0YXZpZXcsIGV0Yy5cblx0ICB1bml0SGVhZGVySGVpZ2h0OiAyMCxcblx0ICBwcm9wZXJ0eUl0ZW1IZWlnaHQ6IDI0LFxuXHQgIGlucHV0SGVpZ2h0OiAzMCxcblx0ICBidXR0b25IZWlnaHQ6IDMwLFxuXHQgIGlucHV0UGFkZGluZzogMyxcblx0ICBtZW51SGVpZ2h0OiAyOCxcblx0ICBsYWJlbFRvcEhlaWdodDogMTYsXG5cdCAgaW5wdXRTcGFjaW5nOiA0LFxuXHQgIGJvcmRlcldpZHRoOiAxLFxuXHQgIHNsaWRlckhhbmRsZVdpZHRoOiAxMixcblx0ICBzbGlkZXJQYWRkaW5nOiAxMCxcblx0ICBzbGlkZXJCb3JkZXI6IDEsXG5cdCAgdlNsaWRlclBhZGRpbmc6IDEzLFxuXHQgIHZTbGlkZXJIZWlnaHQ6IDEwMCxcblx0ICBzd2l0Y2hIZWlnaHQ6IDIwLFxuXHQgIHN3aXRjaFdpZHRoOiA0MCxcblx0ICAvL21hcmdpbiAtIGRpc3RhbmNlIGJldHdlZW4gY2VsbHNcblx0ICBsYXlvdXRNYXJnaW46IHtcblx0ICAgIHNwYWNlOiA1LFxuXHQgICAgd2lkZTogNSxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogNCxcblx0ICAgIGxpbmU6IC0xLFxuXHQgICAgdG9vbGJhcjogNCxcblx0ICAgIGZvcm06IDQsXG5cdCAgICBhY2NvcmRpb246IDVcblx0ICB9LFxuXHQgIC8vcGFkZGluZyAtIGRpc3RhbmNlIGluc2lkZSBjZWxsIGJldHdlZW4gY2VsbCBib3JkZXIgYW5kIGNlbGwgY29udGVudFxuXHQgIGxheW91dFBhZGRpbmc6IHtcblx0ICAgIHNwYWNlOiA1LFxuXHQgICAgd2lkZTogMCxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogMCxcblx0ICAgIGxpbmU6IDAsXG5cdCAgICB0b29sYmFyOiAxLFxuXHQgICAgZm9ybTogMTIsXG5cdCAgICBhY2NvcmRpb246IDBcblx0ICB9LFxuXHQgIC8vc3BhY2UgYmV0d2VlbiB0YWJzIGluIHRhYmJhclxuXHQgIHRhYk1hcmdpbjogMyxcblx0ICB0YWJPZmZzZXQ6IDAsXG5cdCAgdGFiQm90dG9tT2Zmc2V0OiAzLFxuXHQgIHRhYlRvcE9mZnNldDogMSxcblx0ICBjdXN0b21DaGVja2JveDogdHJ1ZSxcblx0ICBjdXN0b21SYWRpbzogdHJ1ZSxcblx0ICBwb3B1cFBhZGRpbmc6IDgsXG5cdCAgY2FsZW5kYXJIZWlnaHQ6IDcwLFxuXHQgIHBhZGRpbmc6IDAsXG5cdCAgYWNjb3JkaW9uVHlwZTogXCJhY2NvcmRpb25cIixcblx0ICBvcHRpb25IZWlnaHQ6IDIzXG5cdH07XG5cblx0dmFyIHNraW4kNCA9IHtcblx0ICB0b3BMYXlvdXQ6IFwic3BhY2VcIixcblx0ICAvL2JhciBpbiBhY2NvcmRpb25cblx0ICBiYXJIZWlnaHQ6IDQ2LFxuXHQgIC8vICEhIVNldCB0aGUgc2FtZSBpbiBza2luLmxlc3MhISFcblx0ICB0YWJiYXJIZWlnaHQ6IDQ2LFxuXHQgIHJvd0hlaWdodDogMzQsXG5cdCAgdG9vbGJhckhlaWdodDogNDYsXG5cdCAgc2lkZWJhclRpdGxlSGVpZ2h0OiA0NSxcblx0ICBsaXN0SXRlbUhlaWdodDogMzQsXG5cdCAgLy8gbGlzdCwgZ3JvdXBsaXN0LCBkYXRhdmlldywgZXRjLlxuXHQgIHVuaXRIZWFkZXJIZWlnaHQ6IDIwLFxuXHQgIGlucHV0SGVpZ2h0OiAzOCxcblx0ICBidXR0b25IZWlnaHQ6IDM4LFxuXHQgIGlucHV0UGFkZGluZzogMyxcblx0ICBtZW51SGVpZ2h0OiAzNCxcblx0ICBsYWJlbFRvcEhlaWdodDogMjIsXG5cdCAgcHJvcGVydHlJdGVtSGVpZ2h0OiAyOCxcblx0ICBpbnB1dFNwYWNpbmc6IDQsXG5cdCAgYm9yZGVyV2lkdGg6IDEsXG5cdCAgc2xpZGVySGFuZGxlV2lkdGg6IDE0LFxuXHQgIHNsaWRlclBhZGRpbmc6IDEwLFxuXHQgIHNsaWRlckJvcmRlcjogMSxcblx0ICB2U2xpZGVyUGFkZGluZzogMTUsXG5cdCAgdlNsaWRlckhlaWdodDogMTAwLFxuXHQgIHN3aXRjaEhlaWdodDogMjIsXG5cdCAgc3dpdGNoV2lkdGg6IDUwLFxuXHQgIC8vbWFyZ2luIC0gZGlzdGFuY2UgYmV0d2VlbiBjZWxsc1xuXHQgIGxheW91dE1hcmdpbjoge1xuXHQgICAgc3BhY2U6IDEwLFxuXHQgICAgd2lkZTogMTAsXG5cdCAgICBjbGVhbjogMCxcblx0ICAgIGhlYWQ6IDQsXG5cdCAgICBsaW5lOiAtMSxcblx0ICAgIHRvb2xiYXI6IDgsXG5cdCAgICBmb3JtOiA4LFxuXHQgICAgYWNjb3JkaW9uOiAxMFxuXHQgIH0sXG5cdCAgLy9wYWRkaW5nIC0gZGlzdGFuY2UgaW5zaWRlIGNlbGwgYmV0d2VlbiBjZWxsIGJvcmRlciBhbmQgY2VsbCBjb250ZW50XG5cdCAgbGF5b3V0UGFkZGluZzoge1xuXHQgICAgc3BhY2U6IDEwLFxuXHQgICAgd2lkZTogMCxcblx0ICAgIGNsZWFuOiAwLFxuXHQgICAgaGVhZDogMCxcblx0ICAgIGxpbmU6IDAsXG5cdCAgICB0b29sYmFyOiAzLFxuXHQgICAgZm9ybTogMTcsXG5cdCAgICBhY2NvcmRpb246IDBcblx0ICB9LFxuXHQgIC8vc3BhY2UgYmV0d2VlbiB0YWJzIGluIHRhYmJhclxuXHQgIHRhYk1hcmdpbjogNCxcblx0ICB0YWJPZmZzZXQ6IDAsXG5cdCAgdGFiQm90dG9tT2Zmc2V0OiA2LFxuXHQgIHRhYlRvcE9mZnNldDogMSxcblx0ICBjdXN0b21DaGVja2JveDogdHJ1ZSxcblx0ICBjdXN0b21SYWRpbzogdHJ1ZSxcblx0ICBwb3B1cFBhZGRpbmc6IDgsXG5cdCAgY2FsZW5kYXJIZWlnaHQ6IDcwLFxuXHQgIHBhZGRpbmc6IDAsXG5cdCAgYWNjb3JkaW9uVHlwZTogXCJhY2NvcmRpb25cIixcblx0ICBvcHRpb25IZWlnaHQ6IDMyXG5cdH07XG5cblx0dmFyICRhY3RpdmUsICRuYW1lO1xuXHRmdW5jdGlvbiBzZXQkMShuYW1lKSB7XG5cdCAgYXNzZXJ0KHNraW4kNVtuYW1lXSwgXCJJbmNvcnJlY3Qgc2tpbiBuYW1lOiBcIiArIG5hbWUpO1xuXHQgIGlmICgkbmFtZSA9PT0gbmFtZSkgcmV0dXJuO1xuXHQgIHNraW4kNS4kYWN0aXZlID0gJGFjdGl2ZSA9IHNraW4kNVtuYW1lXTtcblx0ICBza2luJDUuJG5hbWUgPSAkbmFtZSA9IG5hbWU7XG5cblx0ICBpZiAodWkpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiB1aSkge1xuXHQgICAgICB2YXIgdmlldyA9IHVpW2tleV07XG5cdCAgICAgIGlmICh2aWV3ICYmIHZpZXcucHJvdG90eXBlICYmIHZpZXcucHJvdG90eXBlLiRza2luKSB2aWV3LnByb3RvdHlwZS4kc2tpbih2aWV3LnByb3RvdHlwZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHZhciBza2luJDUgPSB7XG5cdCAgc2V0OiBzZXQkMSxcblx0ICBtYXRlcmlhbDogc2tpbixcblx0ICBtaW5pOiBza2luJDEsXG5cdCAgZmxhdDogc2tpbiQyLFxuXHQgIGNvbXBhY3Q6IHNraW4kMyxcblx0ICBjb250cmFzdDogc2tpbiQ0XG5cdH07XG5cdHNldCQxKHdpbmRvdy53ZWJpeF9za2luIHx8IFwibWF0ZXJpYWxcIik7IC8vbmVjZXNzYXJ5IGZvciBza2luIGJ1aWxkZXJcblxuXHR2YXIgVG91Y2ggPSB7XG5cdCAgY29uZmlnOiB7XG5cdCAgICBsb25nVG91Y2hEZWxheTogMTAwMCxcblx0ICAgIHNjcm9sbERlbGF5OiAxNTAsXG5cdCAgICBncmF2aXR5OiA1MDAsXG5cdCAgICBkZWx0YVN0ZXA6IDMwLFxuXHQgICAgc3BlZWQ6IFwiMG1zXCIsXG5cdCAgICBmaW5pc2g6IDE1MDAsXG5cdCAgICBlbGxhc3RpYzogdHJ1ZSxcblx0ICAgIGZhc3RDbGljazogdHJ1ZVxuXHQgIH0sXG5cdCAgbGltaXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgVG91Y2guX2xpbWl0ZWQgPSB2YWx1ZSAhPT0gZmFsc2U7XG5cdCAgfSxcblx0ICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBUb3VjaC5fZGlzYWJsZWQgPSB0cnVlO1xuXHQgIH0sXG5cdCAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBUb3VjaC5fZGlzYWJsZWQgPSBmYWxzZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBUb3VjaC4kaW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdCAgICBldmVudCQxKGRvY3VtZW50LmJvZHksIG1vdXNlLmRvd24sIFRvdWNoLl90b3VjaHN0YXJ0LCB7XG5cdCAgICAgIHBhc3NpdmU6IGZhbHNlXG5cdCAgICB9KTtcblx0ICAgIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgbW91c2UubW92ZSwgVG91Y2guX3RvdWNobW92ZSwge1xuXHQgICAgICBwYXNzaXZlOiBmYWxzZVxuXHQgICAgfSk7XG5cdCAgICBldmVudCQxKGRvY3VtZW50LmJvZHksIG1vdXNlLnVwLCBUb3VjaC5fdG91Y2hlbmQpO1xuXHQgICAgZXZlbnQkMShkb2N1bWVudC5ib2R5LCBcImRyYWdzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoVG91Y2guX2Rpc2FibGVkIHx8IFRvdWNoLl9saW1pdGVkKSByZXR1cm47XG5cdCAgICAgIHJldHVybiBwcmV2ZW50RXZlbnQoZSk7XG5cdCAgICB9KTtcblx0ICAgIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmIChUb3VjaC5fZGlzYWJsZWQgfHwgVG91Y2guX2xpbWl0ZWQgfHwgIVRvdWNoLmNvbmZpZy5mYXN0Q2xpY2spIHJldHVybjsgLy9mYXN0IGNsaWNrIG1vZGUgZm9yIGlPU1xuXHQgICAgICAvL1RvIGhhdmUgd29ya2luZyBmb3JtIGVsZW1lbnRzIEFuZHJvaWQgbXVzdCBub3QgYmxvY2sgZXZlbnQgLSBzbyB0aGVyZSBhcmUgbm8gZmFzdCBjbGlja3MgZm9yIEFuZHJvaWRcblx0ICAgICAgLy9TZWxlY3RzIHN0aWxsIGRvbid0IHdvcmsgd2l0aCBmYXN0IGNsaWNrc1xuXG5cdCAgICAgIGlmIChlbnYuaXNTYWZhcmkpIHtcblx0ICAgICAgICB2YXIgdGFnID0gZS5zcmNFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIiB8fCB0YWcgPT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZyA9PSBcInNlbGVjdFwiIHx8IHRhZyA9PSBcImxhYmVsXCIpIHJldHVybiB0cnVlO1xuXHQgICAgICAgIFRvdWNoLl9maXJlX2Zhc3RfZXZlbnQgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiBwcmV2ZW50RXZlbnQoZSk7XG5cdCAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgcGFzc2l2ZTogZmFsc2Vcblx0ICAgIH0pO1xuXG5cdCAgICBUb3VjaC5fY2xlYXJfYXJ0ZWZhY3RzKCk7XG5cblx0ICAgIFRvdWNoLl9zY3JvbGwgPSBbbnVsbCwgbnVsbF07XG5cdCAgICBUb3VjaC4kYWN0aXZlID0gdHJ1ZTtcblx0ICB9LFxuXHQgIF9jbGVhcl9hcnRlZmFjdHM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIFRvdWNoLl9zdGFydF9jb250ZXh0ID0gVG91Y2guX2N1cnJlbnRfY29udGV4dCA9IFRvdWNoLl9wcmV2X2NvbnRleHQgPSBUb3VjaC5fc2Nyb2xsX2NvbnRleHQgPSBudWxsO1xuXHQgICAgVG91Y2guX3Njcm9sbF9tb2RlID0gVG91Y2guX3Njcm9sbF9ub2RlID0gVG91Y2guX3Njcm9sbF9zdGF0ID0gdGhpcy5fbG9uZ190b3VjaGVkID0gbnVsbDsgLy9yZW1vdmUoVG91Y2guX3Njcm9sbCk7XG5cdCAgICAvL1RvdWNoLl9zY3JvbGwgPSBbbnVsbCwgbnVsbF07XG5cblx0ICAgIFRvdWNoLl9kZWx0YSA9IHtcblx0ICAgICAgX3hfbW9tZW50OiAwLFxuXHQgICAgICBfeV9tb21lbnQ6IDAsXG5cdCAgICAgIF90aW1lOiAwXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoVG91Y2guX2Nzc19idXR0b25fcmVtb3ZlKSB7XG5cdCAgICAgIHJlbW92ZUNzcyhUb3VjaC5fY3NzX2J1dHRvbl9yZW1vdmUsIFwid2ViaXhfdG91Y2hcIik7XG5cdCAgICAgIFRvdWNoLl9jc3NfYnV0dG9uX3JlbW92ZSA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoVG91Y2guX2xvbmdfdG91Y2hfdGltZXIpO1xuXHQgICAgVG91Y2guX3dhc19ub3RfbW92ZWQgPSB0cnVlO1xuXHQgICAgVG91Y2guX2F4aXNfeCA9IHRydWU7XG5cdCAgICBUb3VjaC5fYXhpc195ID0gdHJ1ZTtcblx0ICAgIGlmICghVG91Y2guX2FjdGl2ZV90cmFuc2lvbikgVG91Y2guX3Njcm9sbF9lbmQoKTtcblx0ICB9LFxuXHQgIF90b3VjaGVuZDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmIChUb3VjaC5fc3RhcnRfY29udGV4dCkge1xuXHQgICAgICBpZiAoIVRvdWNoLl9zY3JvbGxfbW9kZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5fbG9uZ190b3VjaGVkKSB7XG5cdCAgICAgICAgICBpZiAoVG91Y2guX2F4aXNfeSAmJiAhVG91Y2guX2F4aXNfeCkge1xuXHQgICAgICAgICAgICBUb3VjaC5fdHJhbnNsYXRlX2V2ZW50KFwib25Td2lwZVhcIik7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKFRvdWNoLl9heGlzX3ggJiYgIVRvdWNoLl9heGlzX3kpIHtcblx0ICAgICAgICAgICAgVG91Y2guX3RyYW5zbGF0ZV9ldmVudChcIm9uU3dpcGVZXCIpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGVudi5pc1NhZmFyaSAmJiBUb3VjaC5fZmlyZV9mYXN0X2V2ZW50KSB7XG5cdCAgICAgICAgICAgICAgLy9uZWVkIHRvIHRlc3QgZm9yIG1vYmlsZSBmZiBhbmQgYmxhY2tiZXJ5XG5cdCAgICAgICAgICAgICAgVG91Y2guX2ZpcmVfZmFzdF9ldmVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBUb3VjaC5fc3RhcnRfY29udGV4dC50YXJnZXQ7IC8vZGFyayBpT1MgbWFnaWMsIHdpdGhvdXQgZGVsYXkgaXQgY2FuIHNraXAgcmVwYWludGluZ1xuXG5cdCAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNsaWNrX2V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcblx0ICAgICAgICAgICAgICAgIGNsaWNrX2V2ZW50LmluaXRFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoY2xpY2tfZXZlbnQpO1xuXHQgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciB0ZW1wID0gVG91Y2guX2dldF9tYXRyaXgoVG91Y2guX3Njcm9sbF9ub2RlKTtcblxuXHQgICAgICAgIHZhciB4ID0gdGVtcC5lO1xuXHQgICAgICAgIHZhciB5ID0gdGVtcC5mO1xuXHQgICAgICAgIHZhciBmaW5pc2ggPSBUb3VjaC5jb25maWcuZmluaXNoO1xuXG5cdCAgICAgICAgdmFyIGRlbHRhID0gVG91Y2guX2dldF9kZWx0YShlLCB0cnVlKTtcblxuXHQgICAgICAgIHZhciB2aWV3ID0gJCQoVG91Y2guX3Njcm9sbF9ub2RlKTtcblx0ICAgICAgICB2YXIgZ3Jhdml0eSA9IHZpZXcgJiYgdmlldy4kc2Nyb2xsID8gdmlldy4kc2Nyb2xsLmdyYXZpdHkgOiBUb3VjaC5jb25maWcuZ3Jhdml0eTtcblxuXHQgICAgICAgIGlmIChkZWx0YS5fdGltZSkge1xuXHQgICAgICAgICAgdmFyIG54ID0geCArIGdyYXZpdHkgKiBkZWx0YS5feF9tb21lbnQgLyBkZWx0YS5fdGltZTtcblx0ICAgICAgICAgIHZhciBueSA9IHkgKyBncmF2aXR5ICogZGVsdGEuX3lfbW9tZW50IC8gZGVsdGEuX3RpbWU7XG5cdCAgICAgICAgICB2YXIgY254ID0gVG91Y2guX3Njcm9sbFswXSA/IFRvdWNoLl9jb3JyZWN0X21pbm1heChueCwgZmFsc2UsIGZhbHNlLCBUb3VjaC5fc2Nyb2xsX3N0YXQuZHgsIFRvdWNoLl9zY3JvbGxfc3RhdC5weCkgOiB4O1xuXHQgICAgICAgICAgdmFyIGNueSA9IFRvdWNoLl9zY3JvbGxbMV0gPyBUb3VjaC5fY29ycmVjdF9taW5tYXgobnksIGZhbHNlLCBmYWxzZSwgVG91Y2guX3Njcm9sbF9zdGF0LmR5LCBUb3VjaC5fc2Nyb2xsX3N0YXQucHkpIDogeTtcblx0ICAgICAgICAgIHZhciBzaXplID0gTWF0aC5tYXgoTWF0aC5hYnMoY254IC0geCksIE1hdGguYWJzKGNueSAtIHkpKTtcblx0ICAgICAgICAgIGlmIChzaXplIDwgMTUwKSBmaW5pc2ggPSBmaW5pc2ggKiBzaXplIC8gMTUwO1xuXHQgICAgICAgICAgaWYgKGNueCAhPSB4IHx8IGNueSAhPSB5KSBmaW5pc2ggPSBNYXRoLnJvdW5kKGZpbmlzaCAqIE1hdGgubWF4KChjbnggLSB4KSAvIChueCAtIHgpLCAoY255IC0geSkgLyAobnkgLSB5KSkpO1xuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICAgICAgZTogY254LFxuXHQgICAgICAgICAgICBmOiBjbnlcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICB2aWV3ID0gJCQoVG91Y2guX3Njcm9sbF9ub2RlKTtcblx0ICAgICAgICAgIGlmICh2aWV3ICYmIHZpZXcuYWRqdXN0U2Nyb2xsKSB2aWV3LmFkanVzdFNjcm9sbChyZXN1bHQpOyAvL2ZpbmlzaCA9IE1hdGgubWF4KDEwMCwoVG91Y2guX2Zhc3RfY29ycmVjdGlvbj8xMDA6ZmluaXNoKSk7XG5cblx0ICAgICAgICAgIGZpbmlzaCA9IE1hdGgubWF4KDEwMCwgZmluaXNoKTtcblxuXHQgICAgICAgICAgaWYgKHggIT0gcmVzdWx0LmUgfHwgeSAhPSByZXN1bHQuZikge1xuXHQgICAgICAgICAgICBUb3VjaC5fc2V0X21hdHJpeChUb3VjaC5fc2Nyb2xsX25vZGUsIHJlc3VsdC5lLCByZXN1bHQuZiwgZmluaXNoICsgXCJtc1wiKTtcblxuXHQgICAgICAgICAgICBpZiAoVG91Y2guX3Njcm9sbF9tYXN0ZXIpIFRvdWNoLl9zY3JvbGxfbWFzdGVyLl9zeW5jX3Njcm9sbChyZXN1bHQuZSwgcmVzdWx0LmYsIGZpbmlzaCArIFwibXNcIik7XG5cblx0ICAgICAgICAgICAgVG91Y2guX3NldF9zY3JvbGwocmVzdWx0LmUsIHJlc3VsdC5mLCBmaW5pc2ggKyBcIm1zXCIpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgVG91Y2guX3Njcm9sbF9lbmQoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgVG91Y2guX3Njcm9sbF9lbmQoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIFRvdWNoLl90cmFuc2xhdGVfZXZlbnQoXCJvblRvdWNoRW5kXCIpO1xuXG5cdCAgICAgIFRvdWNoLl9jbGVhcl9hcnRlZmFjdHMoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF90b3VjaG1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAoIVRvdWNoLl9zY3JvbGxfY29udGV4dCB8fCAhVG91Y2guX3N0YXJ0X2NvbnRleHQpIHJldHVybjtcblxuXHQgICAgdmFyIGRlbHRhID0gVG91Y2guX2dldF9kZWx0YShlKTtcblxuXHQgICAgVG91Y2guX3RyYW5zbGF0ZV9ldmVudChcIm9uVG91Y2hNb3ZlXCIpO1xuXG5cdCAgICBpZiAoVG91Y2guX3Njcm9sbF9tb2RlKSB7XG5cdCAgICAgIFRvdWNoLl9zZXRfc2Nyb2xsX3BvcyhkZWx0YSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBUb3VjaC5fYXhpc194ID0gVG91Y2guX2F4aXNfY2hlY2soZGVsdGEuX3gsIFwieFwiLCBUb3VjaC5fYXhpc194KTtcblx0ICAgICAgVG91Y2guX2F4aXNfeSA9IFRvdWNoLl9heGlzX2NoZWNrKGRlbHRhLl95LCBcInlcIiwgVG91Y2guX2F4aXNfeSk7XG5cblx0ICAgICAgaWYgKFRvdWNoLl9zY3JvbGxfbW9kZSkge1xuXHQgICAgICAgIHZhciB2aWV3ID0gVG91Y2guX2dldF9ldmVudF92aWV3KFwib25CZWZvcmVTY3JvbGxcIiwgdHJ1ZSk7XG5cblx0ICAgICAgICBpZiAodmlldykge1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcblx0ICAgICAgICAgIHZpZXcuY2FsbEV2ZW50KFwib25CZWZvcmVTY3JvbGxcIiwgW2RhdGFdKTtcblxuXHQgICAgICAgICAgaWYgKGRhdGEudXBkYXRlKSB7XG5cdCAgICAgICAgICAgIFRvdWNoLmNvbmZpZy5zcGVlZCA9IGRhdGEuc3BlZWQ7XG5cdCAgICAgICAgICAgIFRvdWNoLmNvbmZpZy5zY2FsZSA9IGRhdGEuc2NhbGU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgVG91Y2guX2luaXRfc2Nyb2xsZXIoZGVsdGEpOyAvL2FwcGx5IHNjcm9sbGluZ1xuXG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHByZXZlbnRFdmVudChlKTtcblx0ICB9LFxuXHQgIF9zZXRfc2Nyb2xsX3BvczogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFUb3VjaC5fc2Nyb2xsX25vZGUpIHJldHVybjtcblxuXHQgICAgdmFyIHRlbXAgPSBUb3VjaC5fZ2V0X21hdHJpeChUb3VjaC5fc2Nyb2xsX25vZGUpO1xuXG5cdCAgICB2YXIgcHJldiA9IFRvdWNoLl9wcmV2X2NvbnRleHQgfHwgVG91Y2guX3N0YXJ0X2NvbnRleHQ7XG5cdCAgICB2YXIgdmlldyA9ICQkKFRvdWNoLl9zY3JvbGxfbm9kZSk7XG5cdCAgICB2YXIgZWxsYXN0aWMgPSB2aWV3ICYmIHZpZXcuJHNjcm9sbCA/IHZpZXcuJHNjcm9sbC5lbGxhc3RpYyA6IFRvdWNoLmNvbmZpZy5lbGxhc3RpYztcblx0ICAgIGlmIChUb3VjaC5fc2Nyb2xsWzBdKSB0ZW1wLmUgPSBUb3VjaC5fY29ycmVjdF9taW5tYXgodGVtcC5lIC0gcHJldi54ICsgVG91Y2guX2N1cnJlbnRfY29udGV4dC54LCBlbGxhc3RpYywgdGVtcC5lLCBUb3VjaC5fc2Nyb2xsX3N0YXQuZHgsIFRvdWNoLl9zY3JvbGxfc3RhdC5weCk7XG5cdCAgICBpZiAoVG91Y2guX3Njcm9sbFsxXSkgdGVtcC5mID0gVG91Y2guX2NvcnJlY3RfbWlubWF4KHRlbXAuZiAtIHByZXYueSArIFRvdWNoLl9jdXJyZW50X2NvbnRleHQueSwgZWxsYXN0aWMsIHRlbXAuZiwgVG91Y2guX3Njcm9sbF9zdGF0LmR5LCBUb3VjaC5fc2Nyb2xsX3N0YXQucHkpO1xuXG5cdCAgICBUb3VjaC5fc2V0X21hdHJpeChUb3VjaC5fc2Nyb2xsX25vZGUsIHRlbXAuZSwgdGVtcC5mLCBcIjBtc1wiKTtcblxuXHQgICAgaWYgKFRvdWNoLl9zY3JvbGxfbWFzdGVyKSBUb3VjaC5fc2Nyb2xsX21hc3Rlci5fc3luY19zY3JvbGwodGVtcC5lLCB0ZW1wLmYsIFwiMG1zXCIpO1xuXG5cdCAgICBUb3VjaC5fc2V0X3Njcm9sbCh0ZW1wLmUsIHRlbXAuZiwgXCIwbXNcIik7XG5cdCAgfSxcblx0ICBfc2V0X3Njcm9sbDogZnVuY3Rpb24gKGR4LCBkeSwgc3BlZWQpIHtcblx0ICAgIHZhciBlZHggPSBUb3VjaC5fc2Nyb2xsX3N0YXQucHggLyBUb3VjaC5fc2Nyb2xsX3N0YXQuZHggKiAtZHg7XG5cdCAgICB2YXIgZWR5ID0gVG91Y2guX3Njcm9sbF9zdGF0LnB5IC8gVG91Y2guX3Njcm9sbF9zdGF0LmR5ICogLWR5O1xuXHQgICAgaWYgKFRvdWNoLl9zY3JvbGxbMF0pIFRvdWNoLl9zZXRfbWF0cml4KFRvdWNoLl9zY3JvbGxbMF0sIGVkeCwgMCwgc3BlZWQpO1xuXHQgICAgaWYgKFRvdWNoLl9zY3JvbGxbMV0pIFRvdWNoLl9zZXRfbWF0cml4KFRvdWNoLl9zY3JvbGxbMV0sIDAsIGVkeSwgc3BlZWQpO1xuXHQgIH0sXG5cdCAgc2Nyb2xsVG86IGZ1bmN0aW9uIChub2RlLCB4LCB5LCBzcGVlZCkge1xuXHQgICAgVG91Y2guX3NldF9tYXRyaXgobm9kZSwgeCwgeSwgc3BlZWQpO1xuXHQgIH0sXG5cdCAgX3NldF9tYXRyaXg6IGZ1bmN0aW9uIChub2RlLCB4diwgeXYsIHNwZWVkKSB7XG5cdCAgICBpZiAoIVRvdWNoLl9pbl9hbmltX2ZyYW1lICYmIHdpbmRvdy5zZXRBbmltYXRpb25GcmFtZSkge1xuXHQgICAgICB3aW5kb3cuc2V0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvdWNoLl9pbl9hbmltX2ZyYW1lID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gVG91Y2guX3NldF9tYXRyaXgobm9kZSwgeHYsIHl2LCBzcGVlZCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBUb3VjaC5faW5fYW5pbV9mcmFtZSA9IG51bGw7XG5cdCAgICBUb3VjaC5fYWN0aXZlX3RyYW5zaW9uID0gdHJ1ZTtcblxuXHQgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgdmFyIHRyYW5zID0gVG91Y2guY29uZmlnLnRyYW5zbGF0ZSB8fCBlbnYudHJhbnNsYXRlO1xuXHQgICAgICBub2RlLnN0eWxlW2Vudi50cmFuc2Zvcm1dID0gdHJhbnMgKyBcIihcIiArIE1hdGgucm91bmQoeHYpICsgXCJweCwgXCIgKyBNYXRoLnJvdW5kKHl2KSArIFwicHhcIiArICh0cmFucyA9PSBcInRyYW5zbGF0ZTNkXCIgPyBcIiwgMFwiIDogXCJcIikgKyBcIilcIjtcblx0ICAgICAgbm9kZS5zdHlsZVtlbnYudHJhbnNpdGlvbkR1cmF0aW9uXSA9IHNwZWVkO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldF9tYXRyaXg6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICB2YXIgbWF0cml4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSlbZW52LnRyYW5zZm9ybV07XG5cdCAgICB2YXIgdG1hdHJpeDtcblx0ICAgIGlmIChtYXRyaXggPT0gXCJub25lXCIpIHRtYXRyaXggPSB7XG5cdCAgICAgIGU6IDAsXG5cdCAgICAgIGY6IDBcblx0ICAgIH07ZWxzZSB7XG5cdCAgICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KVxuXHQgICAgICAgIC8qIGdsb2JhbCBXZWJLaXRDU1NNYXRyaXggKi9cblx0ICAgICAgICB0bWF0cml4ID0gbmV3IFdlYktpdENTU01hdHJpeChtYXRyaXgpO2Vsc2UgaWYgKHdpbmRvdy5NU0NTU01hdHJpeClcblx0ICAgICAgICAvKiBnbG9iYWwgTVNDU1NNYXRyaXggKi9cblx0ICAgICAgICB0bWF0cml4ID0gbmV3IE1TQ1NTTWF0cml4KG1hdHJpeCk7ZWxzZSB7XG5cdCAgICAgICAgLy8gbWF0cml4KDEsIDAsIDAsIDEsIDAsIDApIC0tPiAxLCAwLCAwLCAxLCAwLCAwXG5cdCAgICAgICAgdmFyIF90bWF0cml4ID0gbWF0cml4LnJlcGxhY2UoLyhtYXRyaXhcXCgpKC4qKShcXCkpL2dpLCBcIiQyXCIpOyAvLyAxLCAwLCAwLCAxLCAwLCAwIC0tPiAxLDAsMCwxLDAsMFxuXG5cblx0ICAgICAgICBfdG1hdHJpeCA9IF90bWF0cml4LnJlcGxhY2UoL1xccy9naSwgXCJcIik7XG5cdCAgICAgICAgX3RtYXRyaXggPSBfdG1hdHJpeC5zcGxpdChcIixcIik7XG5cdCAgICAgICAgdG1hdHJpeCA9IHt9O1xuXHQgICAgICAgIHZhciB0a2V5ID0gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCJdO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0a2V5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB0bWF0cml4W3RrZXlbaV1dID0gcGFyc2VJbnQoX3RtYXRyaXhbaV0sIDEwKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChUb3VjaC5fc2Nyb2xsX21hc3RlcikgVG91Y2guX3Njcm9sbF9tYXN0ZXIuX3N5bmNfcG9zKHRtYXRyaXgpO1xuXHQgICAgcmV0dXJuIHRtYXRyaXg7XG5cdCAgfSxcblx0ICBfY29ycmVjdF9taW5tYXg6IGZ1bmN0aW9uICh2YWx1ZSwgYWxsb3csIGN1cnJlbnQsIGR4LCBweCkge1xuXHQgICAgaWYgKHZhbHVlID09PSBjdXJyZW50KSByZXR1cm4gdmFsdWU7XG5cdCAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyh2YWx1ZSAtIGN1cnJlbnQpO1xuXHQgICAgdmFyIHNpZ24gPSBkZWx0YSAvICh2YWx1ZSAtIGN1cnJlbnQpOyAvL1x0VG91Y2guX2Zhc3RfY29ycmVjdGlvbiA9IHRydWU7XG5cblx0ICAgIGlmICh2YWx1ZSA+IDApIHJldHVybiBhbGxvdyA/IGN1cnJlbnQgKyBzaWduICogTWF0aC5zcXJ0KGRlbHRhKSA6IDA7XG5cdCAgICB2YXIgbWF4ID0gZHggLSBweDtcblx0ICAgIGlmIChtYXggKyB2YWx1ZSA8IDApIHJldHVybiBhbGxvdyA/IGN1cnJlbnQgLSBNYXRoLnNxcnQoLSh2YWx1ZSAtIGN1cnJlbnQpKSA6IC1tYXg7IC8vXHRUb3VjaC5fZmFzdF9jb3JyZWN0aW9uID0gZmFsc2U7XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9pbml0X3Njcm9sbF9ub2RlOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgaWYgKCFub2RlLnNjcm9sbF9lbmFibGVkKSB7XG5cdCAgICAgIG5vZGUuc2Nyb2xsX2VuYWJsZWQgPSB0cnVlO1xuXHQgICAgICBub2RlLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdCAgICAgIHZhciBwcmVmaXggPSBlbnYuY3NzUHJlZml4O1xuXHQgICAgICBub2RlLnN0eWxlLmNzc1RleHQgKz0gcHJlZml4ICsgXCJ0cmFuc2l0aW9uOiBcIiArIHByZWZpeCArIFwidHJhbnNmb3JtOyBcIiArIHByZWZpeCArIFwidXNlci1zZWxlY3Q6bm9uZTsgXCIgKyBwcmVmaXggKyBcInRyYW5zZm9ybS1zdHlsZTpmbGF0O1wiO1xuXHQgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZW52LnRyYW5zaXRpb25FbmQsIFRvdWNoLl9zY3JvbGxfZW5kLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaW5pdF9zY3JvbGxlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKFRvdWNoLl9zY3JvbGxfbW9kZS5pbmRleE9mKFwieFwiKSAhPSAtMSkgVG91Y2guX3Njcm9sbFswXSA9IFRvdWNoLl9jcmVhdGVfc2Nyb2xsKFwieFwiLCBUb3VjaC5fc2Nyb2xsX3N0YXQuZHgsIFRvdWNoLl9zY3JvbGxfc3RhdC5weCwgXCJ3aWR0aFwiKTtcblx0ICAgIGlmIChUb3VjaC5fc2Nyb2xsX21vZGUuaW5kZXhPZihcInlcIikgIT0gLTEpIFRvdWNoLl9zY3JvbGxbMV0gPSBUb3VjaC5fY3JlYXRlX3Njcm9sbChcInlcIiwgVG91Y2guX3Njcm9sbF9zdGF0LmR5LCBUb3VjaC5fc2Nyb2xsX3N0YXQucHksIFwiaGVpZ2h0XCIpO1xuXG5cdCAgICBUb3VjaC5faW5pdF9zY3JvbGxfbm9kZShUb3VjaC5fc2Nyb2xsX25vZGUpO1xuXG5cdCAgICB3aW5kb3cuc2V0VGltZW91dChUb3VjaC5fc2V0X3Njcm9sbF9wb3MsIDEpO1xuXHQgIH0sXG5cdCAgX2NyZWF0ZV9zY3JvbGw6IGZ1bmN0aW9uIChtb2RlLCBkeSwgcHksIGRpbSkge1xuXHQgICAgaWYgKGR5IC0gcHkgPCAyKSB7XG5cdCAgICAgIHZhciBtYXRyaXggPSBUb3VjaC5fZ2V0X21hdHJpeChUb3VjaC5fc2Nyb2xsX25vZGUpO1xuXG5cdCAgICAgIHZhciBlID0gbW9kZSA9PSBcInlcIiA/IG1hdHJpeC5lIDogMDtcblx0ICAgICAgdmFyIGYgPSBtb2RlID09IFwieVwiID8gMCA6IG1hdHJpeC5mO1xuXHQgICAgICBpZiAoIVRvdWNoLl9zY3JvbGxfbWFzdGVyKSBUb3VjaC5fc2V0X21hdHJpeChUb3VjaC5fc2Nyb2xsX25vZGUsIGUsIGYsIFwiMG1zXCIpO1xuXHQgICAgICBUb3VjaC5fc2Nyb2xsX21vZGUgPSBUb3VjaC5fc2Nyb2xsX21vZGUucmVwbGFjZShtb2RlLCBcIlwiKTtcblx0ICAgICAgcmV0dXJuIFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzY3JvbGwgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICBcImNsYXNzXCI6IFwid2ViaXhfc2Nyb2xsX1wiICsgbW9kZVxuXHQgICAgfSwgXCJcIik7XG5cdCAgICBzY3JvbGwuc3R5bGVbZGltXSA9IE1hdGgubWF4KHB5ICogcHkgLyBkeSAtIDcsIDEwKSArIFwicHhcIjtcblx0ICAgIGlmIChUb3VjaC5fc2Nyb2xsX3N0YXQubGVmdCkgaWYgKG1vZGUgPT09IFwieFwiKSBzY3JvbGwuc3R5bGUubGVmdCA9IFRvdWNoLl9zY3JvbGxfc3RhdC5sZWZ0ICsgXCJweFwiO2Vsc2Ugc2Nyb2xsLnN0eWxlLnJpZ2h0ID0gLVRvdWNoLl9zY3JvbGxfc3RhdC5sZWZ0ICsgXCJweFwiO1xuXHQgICAgaWYgKFRvdWNoLl9zY3JvbGxfc3RhdC5oaWRkZW4pIHNjcm9sbC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuXHQgICAgVG91Y2guX3Njcm9sbF9ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2Nyb2xsKTtcblxuXHQgICAgcmV0dXJuIHNjcm9sbDtcblx0ICB9LFxuXHQgIF9heGlzX2NoZWNrOiBmdW5jdGlvbiAodmFsdWUsIG1vZGUsIG9sZCkge1xuXHQgICAgaWYgKHZhbHVlID4gVG91Y2guY29uZmlnLmRlbHRhU3RlcCkge1xuXHQgICAgICBpZiAoVG91Y2guX3dhc19ub3RfbW92ZWQpIHtcblx0ICAgICAgICBUb3VjaC5fbG9uZ19tb3ZlKG1vZGUpO1xuXG5cdCAgICAgICAgVG91Y2guX2xvY2F0ZShtb2RlKTtcblxuXHQgICAgICAgIGlmICgoVG91Y2guX3Njcm9sbF9tb2RlIHx8IFwiXCIpLmluZGV4T2YobW9kZSkgPT0gLTEpIFRvdWNoLl9zY3JvbGxfbW9kZSA9IFwiXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvbGQ7XG5cdCAgfSxcblx0ICBfc2Nyb2xsX2VuZDogZnVuY3Rpb24gKCkge1xuXHQgICAgLy9zZW5kaW5nIGV2ZW50IHRvIHRoZSBvd25lciBvZiB0aGUgc2Nyb2xsIG9ubHlcblx0ICAgIHZhciByZXN1bHQsIHN0YXRlLCB2aWV3O1xuXHQgICAgdmlldyA9ICQkKFRvdWNoLl9zY3JvbGxfbm9kZSB8fCB0aGlzKTtcblxuXHQgICAgaWYgKHZpZXcpIHtcblx0ICAgICAgaWYgKFRvdWNoLl9zY3JvbGxfbm9kZSkgcmVzdWx0ID0gVG91Y2guX2dldF9tYXRyaXgoVG91Y2guX3Njcm9sbF9ub2RlKTtlbHNlIGlmICh2aWV3LmdldFNjcm9sbFN0YXRlKSB7XG5cdCAgICAgICAgc3RhdGUgPSB2aWV3LmdldFNjcm9sbFN0YXRlKCk7XG5cdCAgICAgICAgcmVzdWx0ID0ge1xuXHQgICAgICAgICAgZTogc3RhdGUueCxcblx0ICAgICAgICAgIGY6IHN0YXRlLnlcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIGNhbGxFdmVudChcIm9uQWZ0ZXJTY3JvbGxcIiwgW3Jlc3VsdF0pO1xuXHQgICAgICBpZiAodmlldy5jYWxsRXZlbnQpIHZpZXcuY2FsbEV2ZW50KFwib25BZnRlclNjcm9sbFwiLCBbcmVzdWx0XSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghVG91Y2guX3Njcm9sbF9tb2RlKSB7XG5cdCAgICAgIHJlbW92ZShUb3VjaC5fc2Nyb2xsKTtcblx0ICAgICAgVG91Y2guX3Njcm9sbCA9IFtudWxsLCBudWxsXTtcblx0ICAgIH1cblxuXHQgICAgVG91Y2guX2FjdGl2ZV90cmFuc2lvbiA9IGZhbHNlO1xuXHQgIH0sXG5cdCAgX2xvbmdfbW92ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgd2luZG93LmNsZWFyVGltZW91dChUb3VjaC5fbG9uZ190b3VjaF90aW1lcik7XG5cdCAgICBUb3VjaC5fd2FzX25vdF9tb3ZlZCA9IGZhbHNlO1xuXHQgIH0sXG5cdCAgX3N0b3Bfb2xkX3Njcm9sbDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmIChUb3VjaC5fc2Nyb2xsWzBdIHx8IFRvdWNoLl9zY3JvbGxbMV0pIHtcblx0ICAgICAgVG91Y2guX3N0b3Bfc2Nyb2xsKGUsIFRvdWNoLl9zY3JvbGxbMF0gPyBcInhcIiA6IFwieVwiKTtcblx0ICAgIH0gZWxzZSByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF90b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGV2ZW50JDEuc3JjRWxlbWVudDtcblx0ICAgIGlmIChUb3VjaC5fZGlzYWJsZWQgfHwgdGFyZ2V0LnRhZ05hbWUgJiYgdGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRleHRhcmVhXCIgJiYgdGFyZ2V0Lm9mZnNldEhlaWdodCA8IHRhcmdldC5zY3JvbGxIZWlnaHQpIHJldHVybjtcblx0ICAgIFRvdWNoLl9sb25nX3RvdWNoZWQgPSBudWxsO1xuXHQgICAgVG91Y2guX3Njcm9sbF9jb250ZXh0ID0gVG91Y2guX3N0YXJ0X2NvbnRleHQgPSBtb3VzZS5jb250ZXh0KGUpOyAvLyBpbiBcImxpbWl0ZWRcIiBtb2RlIHdlIHNob3VsZCBoYXZlIHBvc3NpYmlsaXR5IHRvIHVzZSBzbGlkZXJcblxuXHQgICAgdmFyIGVsZW1lbnQgPSAkJChlKTtcblxuXHQgICAgaWYgKFRvdWNoLl9saW1pdGVkICYmICFUb3VjaC5faXNfc2Nyb2xsKCkgJiYgIShlbGVtZW50ICYmIGVsZW1lbnQuJHRvdWNoQ2FwdHVyZSkpIHtcblx0ICAgICAgVG91Y2guX3Njcm9sbF9jb250ZXh0ID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgVG91Y2guX3RyYW5zbGF0ZV9ldmVudChcIm9uVG91Y2hTdGFydFwiKTtcblxuXHQgICAgaWYgKFRvdWNoLl9zdG9wX29sZF9zY3JvbGwoZSkpIFRvdWNoLl9sb25nX3RvdWNoX3RpbWVyID0gd2luZG93LnNldFRpbWVvdXQoVG91Y2guX2xvbmdfdG91Y2gsIFRvdWNoLmNvbmZpZy5sb25nVG91Y2hEZWxheSk7XG5cblx0ICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudG91Y2hhYmxlICYmICghdGFyZ2V0LmNsYXNzTmFtZSB8fCB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoXCJ3ZWJpeF92aWV3XCIpICE9PSAwKSkge1xuXHQgICAgICBUb3VjaC5fY3NzX2J1dHRvbl9yZW1vdmUgPSBlbGVtZW50LmdldE5vZGUoZSk7XG5cdCAgICAgIGFkZENzcyhUb3VjaC5fY3NzX2J1dHRvbl9yZW1vdmUsIFwid2ViaXhfdG91Y2hcIik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfbG9uZ190b3VjaDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKFRvdWNoLl9zdGFydF9jb250ZXh0KSB7XG5cdCAgICAgIFRvdWNoLl90cmFuc2xhdGVfZXZlbnQoXCJvbkxvbmdUb3VjaFwiKTtcblxuXHQgICAgICBjYWxsRXZlbnQoXCJvbkNsaWNrXCIsIFtUb3VjaC5fc3RhcnRfY29udGV4dF0pO1xuXHQgICAgICBUb3VjaC5fbG9uZ190b3VjaGVkID0gdHJ1ZTsgLy9Ub3VjaC5fY2xlYXJfYXJ0ZWZhY3RzKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfc3RvcF9zY3JvbGw6IGZ1bmN0aW9uIChlLCBzdG9wX21vZGUpIHtcblx0ICAgIFRvdWNoLl9sb2NhdGUoc3RvcF9tb2RlKTtcblxuXHQgICAgdmFyIHNjcm9sbCA9IFRvdWNoLl9zY3JvbGxbMF0gfHwgVG91Y2guX3Njcm9sbFsxXTtcblxuXHQgICAgaWYgKHNjcm9sbCkge1xuXHQgICAgICB2YXIgdmlldyA9IFRvdWNoLl9nZXRfZXZlbnRfdmlldyhcIm9uQmVmb3JlU2Nyb2xsXCIsIHRydWUpO1xuXG5cdCAgICAgIGlmICh2aWV3KSB2aWV3LmNhbGxFdmVudChcIm9uQmVmb3JlU2Nyb2xsXCIsIFtUb3VjaC5fc3RhcnRfY29udGV4dCwgVG91Y2guX2N1cnJlbnRfY29udGV4dF0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2Nyb2xsICYmICghVG91Y2guX3Njcm9sbF9ub2RlIHx8IHNjcm9sbC5wYXJlbnROb2RlICE9IFRvdWNoLl9zY3JvbGxfbm9kZS5wYXJlbnROb2RlKSkge1xuXHQgICAgICBUb3VjaC5fY2xlYXJfYXJ0ZWZhY3RzKCk7XG5cblx0ICAgICAgVG91Y2guX3Njcm9sbF9lbmQoKTtcblxuXHQgICAgICBUb3VjaC5fc3RhcnRfY29udGV4dCA9IG1vdXNlLmNvbnRleHQoZSk7XG5cdCAgICB9XG5cblx0ICAgIFRvdWNoLl90b3VjaG1vdmUoZSk7XG5cdCAgfSxcblx0ICBfZ2V0X2RlbHRhOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgVG91Y2guX3ByZXZfY29udGV4dCA9IFRvdWNoLl9jdXJyZW50X2NvbnRleHQ7XG5cdCAgICBUb3VjaC5fY3VycmVudF9jb250ZXh0ID0gbW91c2UuY29udGV4dChlKTtcblx0ICAgIFRvdWNoLl9kZWx0YS5feCA9IE1hdGguYWJzKFRvdWNoLl9zdGFydF9jb250ZXh0LnggLSBUb3VjaC5fY3VycmVudF9jb250ZXh0LngpO1xuXHQgICAgVG91Y2guX2RlbHRhLl95ID0gTWF0aC5hYnMoVG91Y2guX3N0YXJ0X2NvbnRleHQueSAtIFRvdWNoLl9jdXJyZW50X2NvbnRleHQueSk7XG5cblx0ICAgIGlmIChUb3VjaC5fcHJldl9jb250ZXh0KSB7XG5cdCAgICAgIGlmIChUb3VjaC5fY3VycmVudF9jb250ZXh0LnRpbWUgLSBUb3VjaC5fcHJldl9jb250ZXh0LnRpbWUgPCBUb3VjaC5jb25maWcuc2Nyb2xsRGVsYXkpIHtcblx0ICAgICAgICBUb3VjaC5fZGVsdGEuX3hfbW9tZW50ID0gVG91Y2guX2RlbHRhLl94X21vbWVudCAvIDEuMyArIFRvdWNoLl9jdXJyZW50X2NvbnRleHQueCAtIFRvdWNoLl9wcmV2X2NvbnRleHQueDtcblx0ICAgICAgICBUb3VjaC5fZGVsdGEuX3lfbW9tZW50ID0gVG91Y2guX2RlbHRhLl95X21vbWVudCAvIDEuMyArIFRvdWNoLl9jdXJyZW50X2NvbnRleHQueSAtIFRvdWNoLl9wcmV2X2NvbnRleHQueTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBUb3VjaC5fZGVsdGEuX3lfbW9tZW50ID0gVG91Y2guX2RlbHRhLl94X21vbWVudCA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICBUb3VjaC5fZGVsdGEuX3RpbWUgPSBUb3VjaC5fZGVsdGEuX3RpbWUgLyAxLjMgKyAoVG91Y2guX2N1cnJlbnRfY29udGV4dC50aW1lIC0gVG91Y2guX3ByZXZfY29udGV4dC50aW1lKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFRvdWNoLl9kZWx0YTtcblx0ICB9LFxuXHQgIF9nZXRfc2l6ZXM6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICBUb3VjaC5fc2Nyb2xsX3N0YXQgPSB7XG5cdCAgICAgIGR4OiBub2RlLm9mZnNldFdpZHRoLFxuXHQgICAgICBkeTogbm9kZS5vZmZzZXRIZWlnaHQsXG5cdCAgICAgIHB4OiBub2RlLnBhcmVudE5vZGUub2Zmc2V0V2lkdGgsXG5cdCAgICAgIHB5OiBub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2lzX3Njcm9sbDogZnVuY3Rpb24gKGxvY2F0ZV9tb2RlKSB7XG5cdCAgICB2YXIgbm9kZSA9IFRvdWNoLl9zdGFydF9jb250ZXh0LnRhcmdldDtcblx0ICAgIGlmICghZW52LnRvdWNoICYmICFlbnYudHJhbnNpdGlvbiAmJiAhZW52LnRyYW5zZm9ybSkgcmV0dXJuIG51bGw7XG5cblx0ICAgIHdoaWxlIChub2RlICYmIG5vZGUudGFnTmFtZSAhPSBcIkJPRFlcIikge1xuXHQgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUpIHtcblx0ICAgICAgICB2YXIgbW9kZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwidG91Y2hfc2Nyb2xsXCIpO1xuXHQgICAgICAgIGlmIChtb2RlICYmICghbG9jYXRlX21vZGUgfHwgbW9kZS5pbmRleE9mKGxvY2F0ZV9tb2RlKSAhPSAtMSkpIHJldHVybiBbbm9kZSwgbW9kZV07XG5cdCAgICAgIH1cblxuXHQgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIF9sb2NhdGU6IGZ1bmN0aW9uIChsb2NhdGVfbW9kZSkge1xuXHQgICAgdmFyIHN0YXRlID0gdGhpcy5faXNfc2Nyb2xsKGxvY2F0ZV9tb2RlKTtcblxuXHQgICAgaWYgKHN0YXRlKSB7XG5cdCAgICAgIFRvdWNoLl9zY3JvbGxfbW9kZSA9IHN0YXRlWzFdO1xuXHQgICAgICBUb3VjaC5fc2Nyb2xsX25vZGUgPSBzdGF0ZVswXTtcblxuXHQgICAgICBUb3VjaC5fZ2V0X3NpemVzKHN0YXRlWzBdKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN0YXRlO1xuXHQgIH0sXG5cdCAgX3RyYW5zbGF0ZV9ldmVudDogZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgIGNhbGxFdmVudChuYW1lLCBbVG91Y2guX3N0YXJ0X2NvbnRleHQsIFRvdWNoLl9jdXJyZW50X2NvbnRleHRdKTtcblxuXHQgICAgdmFyIHZpZXcgPSBUb3VjaC5fZ2V0X2V2ZW50X3ZpZXcobmFtZSk7XG5cblx0ICAgIGlmICh2aWV3KSB2aWV3LmNhbGxFdmVudChuYW1lLCBbVG91Y2guX3N0YXJ0X2NvbnRleHQsIFRvdWNoLl9jdXJyZW50X2NvbnRleHRdKTtcblx0ICB9LFxuXHQgIF9nZXRfZXZlbnRfdmlldzogZnVuY3Rpb24gKG5hbWUsIGFjdGl2ZSkge1xuXHQgICAgdmFyIHZpZXcgPSAkJChhY3RpdmUgPyBUb3VjaC5fc2Nyb2xsX25vZGUgOiBUb3VjaC5fc3RhcnRfY29udGV4dCk7XG5cdCAgICBpZiAoIXZpZXcpIHJldHVybiBudWxsO1xuXG5cdCAgICB3aGlsZSAodmlldykge1xuXHQgICAgICBpZiAodmlldy5oYXNFdmVudCAmJiB2aWV3Lmhhc0V2ZW50KG5hbWUpKSByZXR1cm4gdmlldztcblx0ICAgICAgdmlldyA9IHZpZXcuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIF9nZXRfY29udGV4dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmICghZS50b3VjaGVzWzBdKSB7XG5cdCAgICAgIHZhciB0ZW1wID0gVG91Y2guX2N1cnJlbnRfY29udGV4dDtcblx0ICAgICAgdGVtcC50aW1lID0gbmV3IERhdGUoKTtcblx0ICAgICAgcmV0dXJuIHRlbXA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHRhcmdldDogZS50YXJnZXQsXG5cdCAgICAgIHg6IGUudG91Y2hlc1swXS5wYWdlWCxcblx0ICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZLFxuXHQgICAgICB0aW1lOiBuZXcgRGF0ZSgpXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2dldF9jb250ZXh0X206IGZ1bmN0aW9uIChlKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB0YXJnZXQ6IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcblx0ICAgICAgeDogZS5wYWdlWCxcblx0ICAgICAgeTogZS5wYWdlWSxcblx0ICAgICAgdGltZTogbmV3IERhdGUoKVxuXHQgICAgfTtcblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gdG91Y2hJbml0KCkge1xuXHQgIGlmIChlbnYudG91Y2gpIHtcblx0ICAgIFRvdWNoLiRpbml0KCk7IC8vbm90IGZ1bGwgc2NyZWVuIG1vZGVcblxuXHQgICAgaWYgKGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lLmluZGV4T2YoXCJ3ZWJpeF9mdWxsX3NjcmVlblwiKSA9PSAtMSkgVG91Y2gubGltaXQodHJ1ZSk7XG5cdCAgICBpZiAod2luZG93Lk1TQ1NTTWF0cml4KSBhZGRTdHlsZShcIi53ZWJpeF92aWV3eyAtbXMtdG91Y2gtYWN0aW9uOiBub25lOyB9XCIpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgaWQgPSBldmVudCQxKGRvY3VtZW50LmJvZHksIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoICYmIGV2LnRvdWNoZXNbMF0ucmFkaXVzWCA+IDQpIHtcblx0ICAgICAgICBlbnYudG91Y2ggPSB0cnVlO1xuXHQgICAgICAgIHNldE1vdXNlKG1vdXNlKTtcblx0ICAgICAgICB0b3VjaEluaXQoKTtcblxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB1aS52aWV3cykge1xuXHQgICAgICAgICAgdmFyIHZpZXcgPSB1aS52aWV3c1trZXldO1xuXHQgICAgICAgICAgaWYgKHZpZXcgJiYgdmlldy4kdG91Y2gpIHZpZXcuJHRvdWNoKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZXZlbnRSZW1vdmUoaWQpO1xuXHQgICAgfSwge1xuXHQgICAgICBjYXB0dXJlOiB0cnVlXG5cdCAgICB9KTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRNb3VzZShtb3VzZSkge1xuXHQgIG1vdXNlLmRvd24gPSBcInRvdWNoc3RhcnRcIjtcblx0ICBtb3VzZS5tb3ZlID0gXCJ0b3VjaG1vdmVcIjtcblx0ICBtb3VzZS51cCA9IFwidG91Y2hlbmRcIjtcblx0ICBtb3VzZS5jb250ZXh0ID0gVG91Y2guX2dldF9jb250ZXh0O1xuXHR9XG5cblx0cmVhZHkodG91Y2hJbml0KTtcblx0dmFyIG1vdXNlID0gZW52Lm1vdXNlID0ge1xuXHQgIGRvd246IFwibW91c2Vkb3duXCIsXG5cdCAgdXA6IFwibW91c2V1cFwiLFxuXHQgIG1vdmU6IFwibW91c2Vtb3ZlXCIsXG5cdCAgY29udGV4dDogVG91Y2guX2dldF9jb250ZXh0X21cblx0fTtcblxuXHRpZiAod2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuXHQgIG1vdXNlLmRvd24gPSBcInBvaW50ZXJkb3duXCI7XG5cdCAgbW91c2UubW92ZSA9IFwicG9pbnRlcm1vdmVcIjtcblx0ICBtb3VzZS51cCA9IFwicG9pbnRlcnVwXCI7XG5cdH0gZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdCAgbW91c2UuZG93biA9IFwiTVNQb2ludGVyRG93blwiO1xuXHQgIG1vdXNlLm1vdmUgPSBcIk1TUG9pbnRlck1vdmVcIjtcblx0ICBtb3VzZS51cCA9IFwiTVNQb2ludGVyVXBcIjtcblx0fSBlbHNlIGlmIChlbnYudG91Y2gpIHNldE1vdXNlKG1vdXNlKTtcblxuXHQvKlxuXHRcdEJlaGF2aW9yOkRORCAtIGxvdy1sZXZlbCBkbmQgaGFuZGxpbmdcblx0XHRAZXhwb3J0XG5cdFx0XHRnZXRDb250ZXh0XG5cdFx0XHRhZGREcm9wXG5cdFx0XHRhZGREcmFnXG5cdFx0XHRcblx0XHRETkQgbWFzdGVyIGNhbiBkZWZpbmUgbmV4dCBoYW5kbGVyc1xuXHRcdFx0b25DcmVhdGVEcmFnXG5cdFx0XHRvbkRyYWdJbmdcblx0XHRcdG9uRHJhZ091dFxuXHRcdFx0b25EcmFnXG5cdFx0XHRvbkRyb3Bcblx0XHRhbGwgYXJlIG9wdGlvbmFsXG5cdCovXG5cblx0dmFyIERyYWdDb250cm9sID0ge1xuXHQgIC8vaGFzIG9mIGtub3duIGRuZCBtYXN0ZXJzXG5cdCAgX2RyYWdfbWFzdGVyczogdG9BcnJheShbXCJkdW1teVwiXSksXG5cblx0ICAvKlxuXHQgIFx0cmVnaXN0ZXIgZHJvcCBhcmVhXG5cdCAgXHRAcGFyYW0gbm9kZSBcdFx0XHRodG1sIG5vZGUgb3IgSURcblx0ICBcdEBwYXJhbSBjdHJsIFx0XHRcdG9wdGlvbnMgZG5kIG1hc3RlclxuXHQgIFx0QHBhcmFtIG1hc3Rlcl9tb2RlIFx0XHR0cnVlIGlmIHlvdSBoYXZlIGNvbXBsZXggZHJhZy1hcmVhIHJ1bGVzXG5cdCAgKi9cblx0ICBhZGREcm9wOiBmdW5jdGlvbiAobm9kZSwgY3RybCwgbWFzdGVyX21vZGUpIHtcblx0ICAgIG5vZGUgPSB0b05vZGUobm9kZSk7XG5cdCAgICBub2RlLndlYml4X2Ryb3AgPSB0aGlzLl9nZXRDdHJsKGN0cmwpO1xuXHQgICAgaWYgKG1hc3Rlcl9tb2RlKSBub2RlLndlYml4X21hc3RlciA9IHRydWU7XG5cdCAgfSxcblx0ICAvL3JldHVybiBpbmRleCBvZiBtYXN0ZXIgaW4gY29sbGVjdGlvblxuXHQgIC8vaXQgZG9uZSBpbiBzdWNoIHdheSB0byBwcmV2ZW50IGRuZCBtYXN0ZXIgZHVwbGljYXRpb25cblx0ICAvL3Byb2JhYmx5IHVzZWxlc3MsIHVzZWQgb25seSBieSBhZGREcm9wIGFuZCBhZGREcmFnIG1ldGhvZHNcblx0ICBfZ2V0Q3RybDogZnVuY3Rpb24gKGN0cmwpIHtcblx0ICAgIGN0cmwgPSBjdHJsIHx8IERyYWdDb250cm9sO1xuXG5cdCAgICB2YXIgaW5kZXgkJDEgPSB0aGlzLl9kcmFnX21hc3RlcnMuZmluZChjdHJsKTtcblxuXHQgICAgaWYgKGluZGV4JCQxIDwgMCkge1xuXHQgICAgICBpbmRleCQkMSA9IHRoaXMuX2RyYWdfbWFzdGVycy5sZW5ndGg7XG5cblx0ICAgICAgdGhpcy5fZHJhZ19tYXN0ZXJzLnB1c2goY3RybCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBpbmRleCQkMTtcblx0ICB9LFxuXHQgIF9jcmVhdGVUb3VjaERyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgZHJhZ0N0cmwgPSBEcmFnQ29udHJvbDtcblxuXHQgICAgdmFyIG1hc3RlciA9IHRoaXMuX2dldEFjdGl2ZURyYWdNYXN0ZXIoKTsgLy8gZm9yIGRhdGEgaXRlbXMgb25seVxuXG5cblx0ICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLl9nZXREcmFnSXRlbVBvcykge1xuXHQgICAgICBpZiAoIWRyYWdDdHJsLl9odG1sKSBkcmFnQ3RybC5jcmVhdGVEcmFnKGUpO1xuXHQgICAgICB2YXIgY3R4ID0gZHJhZ0N0cmwuX2RyYWdfY29udGV4dDtcblx0ICAgICAgZHJhZ0N0cmwuX2h0bWwuc3R5bGUubGVmdCA9IGUueCArIGRyYWdDdHJsLmxlZnQgKyAoY3R4Lnhfb2Zmc2V0IHx8IDApICsgXCJweFwiO1xuXHQgICAgICBkcmFnQ3RybC5faHRtbC5zdHlsZS50b3AgPSBlLnkgKyBkcmFnQ3RybC50b3AgKyAoY3R4Lnlfb2Zmc2V0IHx8IDApICsgXCJweFwiO1xuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0cmVnaXN0ZXIgZHJhZyBhcmVhXG5cdCAgXHRAcGFyYW0gbm9kZSBcdGh0bWwgbm9kZSBvciBJRFxuXHQgIFx0QHBhcmFtIGN0cmwgXHRvcHRpb25zIGRuZCBtYXN0ZXJcblx0ICAqL1xuXHQgIGFkZERyYWc6IGZ1bmN0aW9uIChub2RlLCBjdHJsKSB7XG5cdCAgICBub2RlID0gdG9Ob2RlKG5vZGUpO1xuXHQgICAgbm9kZS53ZWJpeF9kcmFnID0gdGhpcy5fZ2V0Q3RybChjdHJsKTtcblxuXHQgICAgX2V2ZW50KG5vZGUsIGVudi5tb3VzZS5kb3duLCB0aGlzLl9wcmVTdGFydCwge1xuXHQgICAgICBiaW5kOiBub2RlXG5cdCAgICB9KTtcblxuXHQgICAgX2V2ZW50KG5vZGUsIFwiZHJhZ3N0YXJ0XCIsIHByZXZlbnRFdmVudCk7XG5cdCAgfSxcblx0ICAvL2xvZ2ljIG9mIGRyYWcgLSBzdGFydCwgd2UgYXJlIG5vdCBjcmVhdGluZyBkcmFnIGltbWVkaWF0ZWx5LCBpbnN0ZWFkIG9mIHRoYXQgd2UgaGVhcnMgbW91c2UgbW92aW5nXG5cdCAgX3ByZVN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKERyYWdDb250cm9sLl9hY3RpdmUpIHtcblx0ICAgICAgLy9pZiB3ZSBoYXZlIG5lc3RlZCBkcmFnIGFyZWFzLCB1c2UgdGhlIHRvcCBvbmUgYW5kIGlnbm9yZSB0aGUgaW5uZXIgb25lXG5cdCAgICAgIGlmIChEcmFnQ29udHJvbC5fc2F2ZWRfZXZlbnQgPT0gZSkgcmV0dXJuO1xuXG5cdCAgICAgIERyYWdDb250cm9sLl9wcmVTdGFydEZhbHNlKCk7XG5cblx0ICAgICAgRHJhZ0NvbnRyb2wuZGVzdHJveURyYWcoZSk7XG5cdCAgICB9XG5cblx0ICAgIERyYWdDb250cm9sLl9hY3RpdmUgPSB0aGlzO1xuXHQgICAgdmFyIGV2b2JqID0gZW52Lm1vdXNlLmNvbnRleHQoZSk7XG5cdCAgICBEcmFnQ29udHJvbC5fc3RhcnRfcG9zID0gZXZvYmo7XG5cdCAgICBEcmFnQ29udHJvbC5fc2F2ZWRfZXZlbnQgPSBlO1xuXHQgICAgRHJhZ0NvbnRyb2wuX3dlYml4X2RyYWdfbW0gPSBldmVudCQxKGRvY3VtZW50LmJvZHksIGVudi5tb3VzZS5tb3ZlLCBEcmFnQ29udHJvbC5fc3RhcnREcmFnKTtcblx0ICAgIERyYWdDb250cm9sLl93ZWJpeF9kcmFnX211ID0gZXZlbnQkMShkb2N1bWVudCwgZW52Lm1vdXNlLnVwLCBEcmFnQ29udHJvbC5fcHJlU3RhcnRGYWxzZSk7IC8vbmVlZCB0byBydW4gaGVyZSwgb3Igd2lsbCBub3Qgd29yayBpbiBJRVxuXG5cdCAgICBhZGRDc3MoZG9jdW1lbnQuYm9keSwgXCJ3ZWJpeF9ub3NlbGVjdFwiLCAxKTtcblx0ICB9LFxuXHQgIC8vaWYgbW91c2Ugd2FzIHJlbGVhc2VkIGJlZm9yZSBtb3ZpbmcgLSB0aGlzIGlzIG5vdCBhIGRuZCwgcmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG5cdCAgX3ByZVN0YXJ0RmFsc2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIERyYWdDb250cm9sLl9jbGVhbl9kb21fYWZ0ZXJfZHJhZygpO1xuXHQgIH0sXG5cdCAgLy9tb3VzZSB3YXMgbW92ZWQgd2l0aG91dCBidXR0b24gcmVsZWFzZWQgLSBkbmQgc3RhcnRlZCwgdXBkYXRlIGV2ZW50IGhhbmRsZXJzXG5cdCAgX3N0YXJ0RHJhZzogZnVuY3Rpb24gKGUpIHtcblx0ICAgIC8vcHJldmVudCB1bndhbnRlZCBkbmRcblx0ICAgIHZhciBwb3MkJDEgPSBlbnYubW91c2UuY29udGV4dChlKTtcblxuXHQgICAgdmFyIG1hc3RlciA9IERyYWdDb250cm9sLl9nZXRBY3RpdmVEcmFnTWFzdGVyKCk7IC8vIG9ubHkgbG9uZy10b3VjaGVkIGVsZW1lbnRzIGNhbiBiZSBkcmFnZ2VkXG5cblxuXHQgICAgdmFyIGxvbmdUb3VjaExpbWl0ID0gbWFzdGVyICYmIGVudi50b3VjaCAmJiBtYXN0ZXIuX2dldERyYWdJdGVtUG9zICYmICFUb3VjaC5fbG9uZ190b3VjaGVkO1xuXHQgICAgaWYgKGxvbmdUb3VjaExpbWl0IHx8IE1hdGguYWJzKHBvcyQkMS54IC0gRHJhZ0NvbnRyb2wuX3N0YXJ0X3Bvcy54KSA8IDUgJiYgTWF0aC5hYnMocG9zJCQxLnkgLSBEcmFnQ29udHJvbC5fc3RhcnRfcG9zLnkpIDwgNSkgcmV0dXJuO1xuXG5cdCAgICBEcmFnQ29udHJvbC5fY2xlYW5fZG9tX2FmdGVyX2RyYWcodHJ1ZSk7XG5cblx0ICAgIGlmICghRHJhZ0NvbnRyb2wuX2h0bWwpIGlmICghRHJhZ0NvbnRyb2wuY3JlYXRlRHJhZyhEcmFnQ29udHJvbC5fc2F2ZWRfZXZlbnQpKSByZXR1cm47XG5cdCAgICBEcmFnQ29udHJvbC5zZW5kU2lnbmFsKFwic3RhcnRcIik7IC8vdXNlbGVzcyBmb3Igbm93XG5cblx0ICAgIERyYWdDb250cm9sLl93ZWJpeF9kcmFnX21tID0gZXZlbnQkMShkb2N1bWVudC5ib2R5LCBlbnYubW91c2UubW92ZSwgRHJhZ0NvbnRyb2wuX21vdmVEcmFnKTtcblx0ICAgIERyYWdDb250cm9sLl93ZWJpeF9kcmFnX211ID0gZXZlbnQkMShkb2N1bWVudCwgZW52Lm1vdXNlLnVwLCBEcmFnQ29udHJvbC5fc3RvcERyYWcpO1xuXG5cdCAgICBEcmFnQ29udHJvbC5fbW92ZURyYWcoZSk7XG5cblx0ICAgIGlmIChlbnYudG91Y2gpIHJldHVybiBwcmV2ZW50RXZlbnQoZSk7XG5cdCAgfSxcblx0ICAvL21vdXNlIHdhcyByZWxlYXNlZCB3aGlsZSBkbmQgaXMgYWN0aXZlIC0gcHJvY2VzcyB0YXJnZXRcblx0ICBfc3RvcERyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBEcmFnQ29udHJvbC5fY2xlYW5fZG9tX2FmdGVyX2RyYWcoKTtcblxuXHQgICAgRHJhZ0NvbnRyb2wuX3NhdmVkX2V2ZW50ID0gbnVsbDtcblxuXHQgICAgaWYgKERyYWdDb250cm9sLl9sYXN0KSB7XG5cdCAgICAgIC8vaWYgc29tZSBkcm9wIHRhcmdldCB3YXMgY29uZmlybWVkXG5cdCAgICAgIERyYWdDb250cm9sLiRkcm9wKERyYWdDb250cm9sLl9hY3RpdmUsIERyYWdDb250cm9sLl9sYXN0LCBlKTtcblx0ICAgICAgRHJhZ0NvbnRyb2wuJGRyYWdPdXQoRHJhZ0NvbnRyb2wuX2FjdGl2ZSwgRHJhZ0NvbnRyb2wuX2xhc3QsIG51bGwsIGUpO1xuXHQgICAgfVxuXG5cdCAgICBEcmFnQ29udHJvbC5kZXN0cm95RHJhZyhlKTtcblx0ICAgIERyYWdDb250cm9sLnNlbmRTaWduYWwoXCJzdG9wXCIpOyAvL3VzZWxlc3MgZm9yIG5vd1xuXHQgIH0sXG5cdCAgX2NsZWFuX2RvbV9hZnRlcl9kcmFnOiBmdW5jdGlvbiAoc3RpbGxfZHJhZykge1xuXHQgICAgdGhpcy5fd2ViaXhfZHJhZ19tbSA9IGV2ZW50UmVtb3ZlKHRoaXMuX3dlYml4X2RyYWdfbW0pO1xuXHQgICAgdGhpcy5fd2ViaXhfZHJhZ19tdSA9IGV2ZW50UmVtb3ZlKHRoaXMuX3dlYml4X2RyYWdfbXUpO1xuXHQgICAgaWYgKCFzdGlsbF9kcmFnKSByZW1vdmVDc3MoZG9jdW1lbnQuYm9keSwgXCJ3ZWJpeF9ub3NlbGVjdFwiKTtcblx0ICB9LFxuXHQgIC8vZG5kIGlzIGFjdGl2ZSBhbmQgbW91c2UgcG9zaXRpb24gd2FzIGNoYW5nZWRcblx0ICBfbW92ZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgZHJhZ0N0cmwgPSBEcmFnQ29udHJvbDtcblx0ICAgIHZhciBwb3MkJDEgPSBwb3MoZSk7IC8vZ2l2ZSBwb3NzaWJpbGl0eSB0byBjdXN0b21pemUgZHJhZyBwb3NpdGlvblxuXG5cdCAgICB2YXIgY3VzdG9tUG9zID0gZHJhZ0N0cmwuJGRyYWdQb3MocG9zJCQxLCBlKTsgLy9hZGp1c3QgZHJhZyBtYXJrZXIgcG9zaXRpb25cblxuXHQgICAgdmFyIGN0eCA9IGRyYWdDdHJsLl9kcmFnX2NvbnRleHQ7XG5cdCAgICBkcmFnQ3RybC5faHRtbC5zdHlsZS50b3AgPSBwb3MkJDEueSArIGRyYWdDdHJsLnRvcCArIChjdXN0b21Qb3MgfHwgIWN0eC55X29mZnNldCA/IDAgOiBjdHgueV9vZmZzZXQpICsgXCJweFwiO1xuXHQgICAgZHJhZ0N0cmwuX2h0bWwuc3R5bGUubGVmdCA9IHBvcyQkMS54ICsgZHJhZ0N0cmwubGVmdCArIChjdXN0b21Qb3MgfHwgIWN0eC54X29mZnNldCA/IDAgOiBjdHgueF9vZmZzZXQpICsgXCJweFwiO1xuXHQgICAgdmFyIGV2b2JqID0gZTtcblx0ICAgIGlmIChkcmFnQ3RybC5fc2tpcCkgZHJhZ0N0cmwuX3NraXAgPSBmYWxzZTtlbHNlIHtcblx0ICAgICAgaWYgKGVudi50b3VjaCkge1xuXHQgICAgICAgIHZhciBjb250ZXh0ID0gZW52Lm1vdXNlLmNvbnRleHQoZSk7XG5cdCAgICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoY29udGV4dC54LCBjb250ZXh0LnkpO1xuXHQgICAgICAgIGV2b2JqID0gbmV3IFByb3h5KGUsIHtcblx0ICAgICAgICAgIGdldDogZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuXHQgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJ0YXJnZXRcIikge1xuXHQgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgcmVzID0gb2JqW3Byb3BdO1xuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzID09PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gcmVzLmJpbmQoZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgZHJhZ0N0cmwuX2NoZWNrTGFuZChldm9iai50YXJnZXQgfHwgZXZvYmouc3JjRWxlbWVudCwgZXZvYmopO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHByZXZlbnRFdmVudChlKTtcblx0ICB9LFxuXHQgIC8vY2hlY2sgaWYgaXRlbSB1bmRlciBtb3VzZSBjYW4gYmUgdXNlZCBhcyBkcm9wIGxhbmRpbmdcblx0ICBfY2hlY2tMYW5kOiBmdW5jdGlvbiAobm9kZSwgZSkge1xuXHQgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50YWdOYW1lICE9IFwiQk9EWVwiKSB7XG5cdCAgICAgIGlmIChub2RlLndlYml4X2Ryb3ApIHtcblx0ICAgICAgICAvL2lmIGRyb3AgYXJlYSByZWdpc3RlcmVkXG5cdCAgICAgICAgaWYgKHRoaXMuX2xhc3QgJiYgKHRoaXMuX2xhc3QgIT0gbm9kZSB8fCBub2RlLndlYml4X21hc3RlcikpIC8vaWYgdGhpcyBhcmVhIHdpdGggY29tcGxleCBkbmQgbWFzdGVyXG5cdCAgICAgICAgICB0aGlzLiRkcmFnT3V0KHRoaXMuX2FjdGl2ZSwgdGhpcy5fbGFzdCwgbm9kZSwgZSk7IC8vaW5mb3JtIG1hc3RlciBhYm91dCBwb3NzaWJsZSBtb3VzZS1vdXRcblxuXHQgICAgICAgIGlmICghdGhpcy5fbGFzdCB8fCB0aGlzLl9sYXN0ICE9IG5vZGUgfHwgbm9kZS53ZWJpeF9tYXN0ZXIpIHtcblx0ICAgICAgICAgIC8vaWYgdGhpcyBpcyBuZXcgYXJlIG9yIGFyZWEgd2l0aCBjb21wbGV4IGRuZCBtYXN0ZXJcblx0ICAgICAgICAgIHRoaXMuX2xhc3QgPSBudWxsOyAvL2luZm9ybSBtYXN0ZXIgYWJvdXQgcG9zc2libGUgbW91c2UtaW5cblxuXHQgICAgICAgICAgdGhpcy5fbGFuZGluZyA9IHRoaXMuJGRyYWdJbihEcmFnQ29udHJvbC5fYWN0aXZlLCBub2RlLCBlKTtcblx0ICAgICAgICAgIGlmICh0aGlzLl9sYW5kaW5nKSAvL2xhbmRpbmcgd2FzIHJlamVjdGVkXG5cdCAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBub2RlO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9sYXN0KSAvL21vdXNlIHdhcyBtb3ZlZCBvdXQgb2YgcHJldmlvdXMgbGFuZGluZywgYW5kIHdpdGhvdXQgZmluZGluZyBuZXcgb25lIFxuXHQgICAgICB0aGlzLl9sYXN0ID0gdGhpcy5fbGFuZGluZyA9IHRoaXMuJGRyYWdPdXQodGhpcy5fYWN0aXZlLCB0aGlzLl9sYXN0LCBudWxsLCBlKTtcblx0ICB9LFxuXHQgIC8vbW9zdGx5IHVzZWxlc3MgZm9yIG5vdywgY2FuIGJlIHVzZWQgdG8gYWRkIGNyb3NzLWZyYW1lIGRuZFxuXHQgIHNlbmRTaWduYWw6IGZ1bmN0aW9uIChzaWduYWwpIHtcblx0ICAgIERyYWdDb250cm9sLmFjdGl2ZSA9IHNpZ25hbCA9PSBcInN0YXJ0XCI7XG5cdCAgICBjYWxsRXZlbnQoXCJvbkRyYWdNb2RlXCIsIFtzaWduYWxdKTtcblx0ICB9LFxuXHQgIC8vcmV0dXJuIG1hc3RlciBmb3IgaHRtbCBhcmVhXG5cdCAgZ2V0TWFzdGVyOiBmdW5jdGlvbiAodCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2RyYWdfbWFzdGVyc1t0LndlYml4X2RyYWcgfHwgdC53ZWJpeF9kcm9wXTtcblx0ICB9LFxuXHQgIC8vcmV0dXJuIGRoZC1jb250ZXh0IG9iamVjdFxuXHQgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kcmFnX2NvbnRleHQ7XG5cdCAgfSxcblx0ICBnZXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5faHRtbDtcblx0ICB9LFxuXHQgIC8vY2FsbGVkIHdoZW4gZG5kIGlzIGluaXRpYXRlZCwgbXVzdCBjcmVhdGUgZHJhZyByZXByZXNlbnRhdGlvblxuXHQgIGNyZWF0ZURyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgZHJhZ0N0bCA9IERyYWdDb250cm9sO1xuXHQgICAgdmFyIGEgPSBkcmFnQ3RsLl9hY3RpdmU7XG5cdCAgICBkcmFnQ3RsLl9kcmFnX2NvbnRleHQgPSB7fTtcblx0ICAgIHZhciBtYXN0ZXIgPSB0aGlzLl9kcmFnX21hc3RlcnNbYS53ZWJpeF9kcmFnXTtcblx0ICAgIHZhciBkcmFnX2NvbnRhaW5lcjsgLy9pZiBjdXN0b20gbWV0aG9kIGlzIGRlZmluZWQgLSB1c2UgaXRcblxuXHQgICAgaWYgKG1hc3Rlci4kZHJhZ0NyZWF0ZSkge1xuXHQgICAgICBkcmFnX2NvbnRhaW5lciA9IG1hc3Rlci4kZHJhZ0NyZWF0ZShhLCBlKTtcblx0ICAgICAgaWYgKCFkcmFnX2NvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgIHRoaXMuX3NldERyYWdPZmZzZXQoZSk7XG5cblx0ICAgICAgZHJhZ19jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvL292ZXJ2aXNlIHVzZSBkZWZhdWx0IG9uZVxuXHQgICAgICB2YXIgdGV4dCA9IGRyYWdDdGwuJGRyYWcoYSwgZSk7XG5cblx0ICAgICAgZHJhZ0N0bC5fc2V0RHJhZ09mZnNldChlKTtcblxuXHQgICAgICBpZiAoIXRleHQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgZHJhZ19jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuXHQgICAgICBkcmFnX2NvbnRhaW5lci5pbm5lckhUTUwgPSB0ZXh0O1xuXHQgICAgICBkcmFnX2NvbnRhaW5lci5jbGFzc05hbWUgPSBcIndlYml4X2RyYWdfem9uZVwiO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdfY29udGFpbmVyKTtcblx0ICAgICAgdmFyIGNvbnRleHQgPSBkcmFnQ3RsLl9kcmFnX2NvbnRleHQ7XG5cblx0ICAgICAgaWYgKGNvbnRleHQuaHRtbCAmJiBlbnYucG9pbnRlcmV2ZW50cykge1xuXHQgICAgICAgIGNvbnRleHQueF9vZmZzZXQgPSAtTWF0aC5yb3VuZChkcmFnX2NvbnRhaW5lci5vZmZzZXRXaWR0aCAqIDAuNSk7XG5cdCAgICAgICAgY29udGV4dC55X29mZnNldCA9IC1NYXRoLnJvdW5kKGRyYWdfY29udGFpbmVyLm9mZnNldEhlaWdodCAqIDAuNzUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKlxuXHQgICAgXHRkcmFnZ2VkIGl0ZW0gbXVzdCBoYXZlIHRvcG1vc3Qgei1pbmRleFxuXHQgICAgXHRpbiBzb21lIGNhc2VzIGl0ZW0gYWxyZWFkeSBoYXZlIHotaW5kZXhcblx0ICAgIFx0c28gd2Ugd2lsbCBwcmVzZXJ2ZSBpdCBpZiBwb3NzaWJsZVxuXHQgICAgKi9cblxuXG5cdCAgICBkcmFnX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBNYXRoLm1heChkcmFnX2NvbnRhaW5lci5zdHlsZS56SW5kZXgsIHpJbmRleCgpKTtcblx0ICAgIERyYWdDb250cm9sLl9za2lwRHJvcEggPSBldmVudCQxKGRyYWdfY29udGFpbmVyLCBlbnYubW91c2UubW92ZSwgRHJhZ0NvbnRyb2wuX3NraXBfbWFyayk7XG5cdCAgICBpZiAoIURyYWdDb250cm9sLl9kcmFnX2NvbnRleHQuZnJvbSkgRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dCA9IHtcblx0ICAgICAgc291cmNlOiBhLFxuXHQgICAgICBmcm9tOiBhXG5cdCAgICB9O1xuXHQgICAgRHJhZ0NvbnRyb2wuX2h0bWwgPSBkcmFnX2NvbnRhaW5lcjtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgLy9oZWxwZXIsIHByZXZlbnRzIHVud2FudGVkIG1vdXNlLW91dCBldmVudHNcblx0ICBfc2tpcF9tYXJrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBEcmFnQ29udHJvbC5fc2tpcCA9IHRydWU7XG5cdCAgfSxcblx0ICAvL2FmdGVyIGRuZCBlbmQsIHJlbW92ZSBhbGwgdHJhY2VzIGFuZCB1c2VkIGh0bWwgZWxlbWVudHNcblx0ICBkZXN0cm95RHJhZzogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBhID0gRHJhZ0NvbnRyb2wuX2FjdGl2ZTtcblx0ICAgIHZhciBtYXN0ZXIgPSB0aGlzLl9kcmFnX21hc3RlcnNbYS53ZWJpeF9kcmFnXTtcblxuXHQgICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuJGRyYWdEZXN0cm95KSB7XG5cdCAgICAgIERyYWdDb250cm9sLl9za2lwRHJvcEggPSBldmVudFJlbW92ZShEcmFnQ29udHJvbC5fc2tpcERyb3BIKTtcblx0ICAgICAgaWYgKERyYWdDb250cm9sLl9odG1sKSBtYXN0ZXIuJGRyYWdEZXN0cm95KGEsIERyYWdDb250cm9sLl9odG1sLCBlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlbW92ZShEcmFnQ29udHJvbC5faHRtbCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChEcmFnQ29udHJvbC5fZHJvcEhUTUwpIHJlbW92ZShEcmFnQ29udHJvbC5fZHJvcEhUTUwpO1xuXHQgICAgRHJhZ0NvbnRyb2wuX2xhbmRpbmcgPSBEcmFnQ29udHJvbC5fYWN0aXZlID0gRHJhZ0NvbnRyb2wuX2xhc3QgPSBEcmFnQ29udHJvbC5faHRtbCA9IERyYWdDb250cm9sLl9kcm9wSFRNTCA9IG51bGw7IC8vRHJhZ0NvbnRyb2wuX3hfb2Zmc2V0ID0gRHJhZ0NvbnRyb2wuX3lfb2Zmc2V0ID0gbnVsbDtcblx0ICB9LFxuXHQgIF9nZXRBY3RpdmVEcmFnTWFzdGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gRHJhZ0NvbnRyb2wuX2RyYWdfbWFzdGVyc1tEcmFnQ29udHJvbC5fYWN0aXZlLndlYml4X2RyYWddO1xuXHQgIH0sXG5cdCAgdG9wOiAwLFxuXHQgIC8vcmVsYXRpdmUgcG9zaXRpb24gb2YgZHJhZyBtYXJrZXIgdG8gbW91c2UgY3Vyc29yXG5cdCAgbGVmdDogMCxcblx0ICBfc2V0RHJhZ09mZnNldDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBkcmFnQ3RsID0gRHJhZ0NvbnRyb2w7XG5cdCAgICB2YXIgcG9zJCQxID0gZHJhZ0N0bC5fc3RhcnRfcG9zO1xuXHQgICAgdmFyIGN0eCA9IGRyYWdDdGwuX2RyYWdfY29udGV4dDtcblx0ICAgIGlmICh0eXBlb2YgY3R4Lnhfb2Zmc2V0ICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGN0eC55X29mZnNldCAhPSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcblx0ICAgIGN0eC54X29mZnNldCA9IGN0eC55X29mZnNldCA9IDA7XG5cblx0ICAgIGlmIChlbnYucG9pbnRlcmV2ZW50cykge1xuXHQgICAgICB2YXIgbSA9IERyYWdDb250cm9sLl9nZXRBY3RpdmVEcmFnTWFzdGVyKCk7XG5cblx0ICAgICAgaWYgKG0uX2dldERyYWdJdGVtUG9zICYmIG0gIT09IHRoaXMpIHtcblx0ICAgICAgICB2YXIgaXRlbVBvcyA9IG0uX2dldERyYWdJdGVtUG9zKHBvcyQkMSwgZSk7XG5cblx0ICAgICAgICBpZiAoaXRlbVBvcykge1xuXHQgICAgICAgICAgY3R4Lnhfb2Zmc2V0ID0gaXRlbVBvcy54IC0gcG9zJCQxLng7XG5cdCAgICAgICAgICBjdHgueV9vZmZzZXQgPSBpdGVtUG9zLnkgLSBwb3MkJDEueTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgICRkcmFnUG9zOiBmdW5jdGlvbiAocG9zJCQxLCBlKSB7XG5cdCAgICB2YXIgbSA9IHRoaXMuX2RyYWdfbWFzdGVyc1tEcmFnQ29udHJvbC5fYWN0aXZlLndlYml4X2RyYWddO1xuXG5cdCAgICBpZiAobS4kZHJhZ1BvcyAmJiBtICE9IHRoaXMpIHtcblx0ICAgICAgbS4kZHJhZ1Bvcyhwb3MkJDEsIGUsIERyYWdDb250cm9sLl9odG1sKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2NhbGxlZCB3aGVuIG1vdXNlIHdhcyBtb3ZlZCBpbiBkcm9wIGFyZWFcblx0ICAkZHJhZ0luOiBmdW5jdGlvbiAocywgdCwgZSkge1xuXHQgICAgdmFyIG0gPSB0aGlzLl9kcmFnX21hc3RlcnNbdC53ZWJpeF9kcm9wXTtcblx0ICAgIGlmIChtLiRkcmFnSW4gJiYgbSAhPSB0aGlzKSByZXR1cm4gbS4kZHJhZ0luKHMsIHQsIGUpO1xuXHQgICAgdC5jbGFzc05hbWUgPSB0LmNsYXNzTmFtZSArIFwiIHdlYml4X2Ryb3Bfem9uZVwiO1xuXHQgICAgcmV0dXJuIHQ7XG5cdCAgfSxcblx0ICAvL2NhbGxlZCB3aGVuIG1vdXNlIHdhcyBtb3ZlZCBvdXQgZHJvcCBhcmVhXG5cdCAgJGRyYWdPdXQ6IGZ1bmN0aW9uIChzLCB0LCBuLCBlKSB7XG5cdCAgICB2YXIgbSA9IHRoaXMuX2RyYWdfbWFzdGVyc1t0LndlYml4X2Ryb3BdO1xuXHQgICAgaWYgKG0uJGRyYWdPdXQgJiYgbSAhPSB0aGlzKSByZXR1cm4gbS4kZHJhZ091dChzLCB0LCBuLCBlKTtcblx0ICAgIHQuY2xhc3NOYW1lID0gdC5jbGFzc05hbWUucmVwbGFjZShcIndlYml4X2Ryb3Bfem9uZVwiLCBcIlwiKTtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgLy9jYWxsZWQgd2hlbiBtb3VzZSB3YXMgcmVsZWFzZWQgb3ZlciBkcm9wIGFyZWFcblx0ICAkZHJvcDogZnVuY3Rpb24gKHMsIHQsIGUpIHtcblx0ICAgIHZhciBtID0gdGhpcy5fZHJhZ19tYXN0ZXJzW3Qud2ViaXhfZHJvcF07XG5cdCAgICBEcmFnQ29udHJvbC5fZHJhZ19jb250ZXh0LmZyb20gPSBEcmFnQ29udHJvbC5nZXRNYXN0ZXIocyk7XG5cdCAgICBpZiAobS4kZHJvcCAmJiBtICE9IHRoaXMpIHJldHVybiBtLiRkcm9wKHMsIHQsIGUpO1xuXHQgICAgdC5hcHBlbmRDaGlsZChzKTtcblx0ICB9LFxuXHQgIC8vY2FsbGVkIHdoZW4gZG5kIGp1c3Qgc3RhcnRlZFxuXHQgICRkcmFnOiBmdW5jdGlvbiAocywgZSkge1xuXHQgICAgdmFyIG0gPSB0aGlzLl9kcmFnX21hc3RlcnNbcy53ZWJpeF9kcmFnXTtcblx0ICAgIGlmIChtLiRkcmFnICYmIG0gIT0gdGhpcykgcmV0dXJuIG0uJGRyYWcocywgZSk7XG5cdCAgICByZXR1cm4gXCI8ZGl2IHN0eWxlPSdcIiArIHMuc3R5bGUuY3NzVGV4dCArIFwiJz5cIiArIHMuaW5uZXJIVE1MICsgXCI8L2Rpdj5cIjtcblx0ICB9XG5cdH07IC8vZ2xvYmFsIHRvdWNoLWRyYWcgaGFuZGxlclxuXG5cdGF0dGFjaEV2ZW50KFwib25Mb25nVG91Y2hcIiwgZnVuY3Rpb24gKGV2KSB7XG5cdCAgaWYgKERyYWdDb250cm9sLl9hY3RpdmUpIERyYWdDb250cm9sLl9jcmVhdGVUb3VjaERyYWcoZXYpO1xuXHR9KTtcblxuXHR2YXIgTW92YWJsZSA9IHtcblx0ICBtb3ZlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5fbW92ZV9hZG1pbiA9IGNsb25lKHRoaXMuX21vdmVfYWRtaW4pO1xuXHQgICAgICB0aGlzLl9tb3ZlX2FkbWluLm1hc3RlciA9IHRoaXM7XG5cdCAgICAgIERyYWdDb250cm9sLmFkZERyYWcodGhpcy5faGVhZG9iaiA/IHRoaXMuX2hlYWRvYmogOiB0aGlzLiR2aWV3LCB0aGlzLl9tb3ZlX2FkbWluKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX21vdmVfYWRtaW46IHtcblx0ICAgICRkcmFnQ3JlYXRlOiBmdW5jdGlvbiAob2JqZWN0LCBlKSB7XG5cdCAgICAgIGlmICh0aGlzLm1hc3Rlci5jb25maWcubW92ZSkge1xuXHQgICAgICAgIHZhciBlbE9mZnNldCA9IG9mZnNldChvYmplY3QpO1xuXHQgICAgICAgIHZhciBlbFBvcyA9IHBvcyhlKTtcblx0ICAgICAgICBEcmFnQ29udHJvbC50b3AgPSBlbE9mZnNldC55IC0gZWxQb3MueTtcblx0ICAgICAgICBEcmFnQ29udHJvbC5sZWZ0ID0gZWxPZmZzZXQueCAtIGVsUG9zLng7XG5cdCAgICAgICAgcmV0dXJuIHRvTm9kZSh0aGlzLm1hc3Rlci5fdmlld29iaik7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICAkZHJhZ0Rlc3Ryb3k6IGZ1bmN0aW9uIChub2RlLCBkcmFnKSB7XG5cdCAgICAgIHZhciB2aWV3ID0gdGhpcy5tYXN0ZXI7XG5cblx0ICAgICAgaWYgKHZpZXcuX3NldHRpbmdzKSB7XG5cdCAgICAgICAgdmlldy5fc2V0dGluZ3MudG9wID0gcGFyc2VJbnQoZHJhZy5zdHlsZS50b3AsIDEwKTtcblx0ICAgICAgICB2aWV3Ll9zZXR0aW5ncy5sZWZ0ID0gcGFyc2VJbnQoZHJhZy5zdHlsZS5sZWZ0LCAxMCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBEcmFnQ29udHJvbC50b3AgPSBEcmFnQ29udHJvbC5sZWZ0ID0gMDtcblx0ICAgICAgdGhpcy5tYXN0ZXIuY2FsbEV2ZW50KFwib25WaWV3TW92ZUVuZFwiLCBbXSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH0sXG5cdCAgICAkZHJhZ1BvczogZnVuY3Rpb24gKHBvcyQkMSwgZSkge1xuXHQgICAgICB0aGlzLm1hc3Rlci5jYWxsRXZlbnQoXCJvblZpZXdNb3ZlXCIsIFtwb3MkJDEsIGVdKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1vZGFsaXR5ID0ge1xuXHQgIF9tb2RhbF9zZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgIGlmICghdGhpcy5fbW9kYWxfY292ZXIpIHtcblx0ICAgICAgICB0aGlzLl9tb2RhbF9jb3ZlciA9IGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfbW9kYWxcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qXHR3aXRoIGJlbG93IGNvZGUgd2Ugd2lsbCBoYXZlIHRoZSBzYW1lIHpJbmRleCBmb3IgbW9kYWwgbGF5ZXIgYXMgZm9yIHRoZSBwcmV2aW91cyBcblx0ICAgICAgICBcdGFicyBwb3NpdGlvbmVkIGVsZW1lbnQsIGJ1dCBiZWNhdXNlIG9mIGF0dGFjaGluZyBvcmRlciBtb2RhbCBsYXllciB3aWxsIGJlIG9uIHRvcCBhbnl3YXlcblx0ICAgICAgICAqL1xuXG5cdCAgICAgICAgdmFyIGluZGV4JCQxID0gdGhpcy5fc2V0dGluZ3MuekluZGV4IHx8IHpJbmRleCgpOyAvL3NldCB0b3Btb3N0IG1vZGFsIGxheWVyXG5cblx0ICAgICAgICB0aGlzLl9wcmV2aW91c19tb2RhbGl0eSA9IHN0YXRlLl9tb2RhbGl0eTtcblx0ICAgICAgICBzdGF0ZS5fbW9kYWxpdHkgPSBpbmRleCQkMTtcblx0ICAgICAgICB0aGlzLl9tb2RhbF9jb3Zlci5zdHlsZS56SW5kZXggPSBpbmRleCQkMSAtIDE7XG5cdCAgICAgICAgdGhpcy5fdmlld29iai5zdHlsZS56SW5kZXggPSBpbmRleCQkMTtcblx0ICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX21vZGFsX2NvdmVyKTtcblx0ICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuXHQgICAgICAgIF9ldmVudCh0aGlzLl9tb2RhbF9jb3ZlciwgXCJjbGlja1wiLCBiaW5kKHRoaXMuX2lnbm9yZV9jbGlja3MsIHRoaXMpKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHRoaXMuX21vZGFsX2NvdmVyKSB7XG5cdCAgICAgICAgcmVtb3ZlKHRoaXMuX21vZGFsX2NvdmVyKTtcblx0ICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIjsgLy9yZXN0b3JlIHRvcG1vc3QgbW9kYWwgbGF5ZXJcblx0ICAgICAgICAvL3NldCBkZWxheSwgYXMgY3VycmVudCB3aW5kb3cgY2xvc2luZyBtYXkgaGF2ZSBub3QgZmluaXNoZWQgY2xpY2sgZXZlbnRcblx0ICAgICAgICAvL25lZWQgdG8gd2FpdCB3aGlsZSBpdCBpcyBub3QgZnVsbHkgcHJvY2Vzc2VkXG5cblx0ICAgICAgICB2YXIgdG9wbW9zdCA9IHRoaXMuX3ByZXZpb3VzX21vZGFsaXR5O1xuXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgc3RhdGUuX21vZGFsaXR5ID0gdG9wbW9zdDtcblx0ICAgICAgICB9LCAxKTtcblx0ICAgICAgICB0aGlzLl9tb2RhbF9jb3ZlciA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgUmVzaXplQXJlYSA9IHtcblx0ICByZXNpemVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcmVzaXplSGFuZGxlcnMpIHRoaXMuX3JlbmRlclJlc2l6ZUhhbmRsZXIoKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9yZW5kZXJSZXNpemVIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX3J3SGFuZGxlKSB7XG5cdCAgICAgIHZhciBycCA9IHRoaXMuX3ZpZXdvYmo7XG5cblx0ICAgICAgaWYgKHJwLmZpcnN0Q2hpbGQpIHtcblx0ICAgICAgICBycCA9IHJwLmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgcnAuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9yd0hhbmRsZSA9IGNyZWF0ZShcIkRJVlwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Jlc2l6ZV9oYW5kbGVcIixcblx0ICAgICAgICBcIndlYml4X2Rpc2FibGVfZHJhZ1wiOiBcInRydWVcIlxuXHQgICAgICB9KTtcblx0ICAgICAgcnAuYXBwZW5kQ2hpbGQodGhpcy5fcndIYW5kbGUpO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl9yd0hhbmRsZSwgZW52Lm1vdXNlLmRvd24sIHRoaXMuX3dyRG93biwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfc2hvd1Jlc2l6ZUZyYW1lOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuXHQgICAgaWYgKCF0aGlzLl9yZXNpemVGcmFtZSkge1xuXHQgICAgICB0aGlzLl9yZXNpemVGcmFtZSA9IGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Jlc2l6ZV9mcmFtZVwiXG5cdCAgICAgIH0sIFwiXCIpO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3Jlc2l6ZUZyYW1lKTtcblx0ICAgICAgdmFyIGVsUG9zID0gb2Zmc2V0KHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgICB0aGlzLl9yZXNpemVGcmFtZS5zdHlsZS5sZWZ0ID0gZWxQb3MueCArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fcmVzaXplRnJhbWUuc3R5bGUudG9wID0gZWxQb3MueSArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fcmVzaXplRnJhbWUuc3R5bGUuekluZGV4ID0gekluZGV4KCk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3Jlc2l6ZUZyYW1lLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9yZXNpemVGcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG5cdCAgfSxcblx0ICBfd3JEb3duOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5jb25maWcucmVzaXplKSB7XG5cdCAgICAgIGFkZENzcyhkb2N1bWVudC5ib2R5LCBcIndlYml4X25vc2VsZWN0IHdlYml4X3Jlc2l6ZV9jdXJzb3JcIik7XG5cdCAgICAgIHRoaXMuX3dzUmVhZHkgPSBvZmZzZXQodGhpcy5fdmlld29iaik7XG5cdCAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXJzTW92ZSA9IGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgZW52Lm1vdXNlLm1vdmUsIHRoaXMuX3dyTW92ZSwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXJzVXAgPSBldmVudCQxKGRvY3VtZW50LmJvZHksIGVudi5tb3VzZS51cCwgdGhpcy5fd3JVcCwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfd3JNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKHRoaXMuX3dzUmVhZHkgIT09IGZhbHNlKSB7XG5cdCAgICAgIHZhciBlbFBvcyA9IHBvcyhlKTtcblx0ICAgICAgdmFyIHByb2dyZXNzID0ge1xuXHQgICAgICAgIHg6IGVsUG9zLnggLSB0aGlzLl93c1JlYWR5LnggKyAxMCxcblx0ICAgICAgICB5OiBlbFBvcy55IC0gdGhpcy5fd3NSZWFkeS55ICsgMTBcblx0ICAgICAgfTtcblx0ICAgICAgaWYgKHRoaXMuJHJlc2l6ZU1vdmUpIHRoaXMuJHJlc2l6ZU1vdmUocHJvZ3Jlc3MpO2Vsc2Uge1xuXHQgICAgICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKHRoaXMuX3dzUmVhZHkueCAtIGVsUG9zLngpLFxuXHQgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLl93c1JlYWR5LnkgLSBlbFBvcy55KTtcblx0ICAgICAgICBpZiAod2lkdGggPCAodGhpcy5jb25maWcubWluV2lkdGggfHwgMTAwKSB8fCBoZWlnaHQgPCAodGhpcy5jb25maWcubWluSGVpZ2h0IHx8IDEwMCkgfHwgd2lkdGggPiB0aGlzLl9zZXR0aW5ncy5tYXhXaWR0aCB8fCBoZWlnaHQgPiB0aGlzLl9zZXR0aW5ncy5tYXhIZWlnaHQpIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl93c1Byb2dyZXNzID0gcHJvZ3Jlc3M7XG5cblx0ICAgICAgdGhpcy5fc2hvd1Jlc2l6ZUZyYW1lKHByb2dyZXNzLngsIHByb2dyZXNzLnkpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3dyVXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHJlbW92ZSByZXNpemUgZnJhbWUgYW5kIGNzcyBzdHlsZXNcblx0ICAgIGlmICh0aGlzLl9yZXNpemVGcmFtZSkgdGhpcy5fcmVzaXplRnJhbWUgPSByZW1vdmUodGhpcy5fcmVzaXplRnJhbWUpO1xuXHQgICAgcmVtb3ZlQ3NzKGRvY3VtZW50LmJvZHksIFwid2ViaXhfcmVzaXplX2N1cnNvclwiKTtcblx0ICAgIHJlbW92ZUNzcyhkb2N1bWVudC5ib2R5LCBcIndlYml4X25vc2VsZWN0XCIpO1xuXHQgICAgZXZlbnRSZW1vdmUodGhpcy5fcmVzaXplSGFuZGxlcnNNb3ZlKTtcblx0ICAgIGV2ZW50UmVtb3ZlKHRoaXMuX3Jlc2l6ZUhhbmRsZXJzVXApOyAvLyBzZXQgV2luZG93IHNpemVzXG5cblx0ICAgIGlmICh0aGlzLl93c1Byb2dyZXNzKSB7XG5cdCAgICAgIGlmICh0aGlzLiRyZXNpemVFbmQpIHRoaXMuJHJlc2l6ZUVuZCh0aGlzLl93c1Byb2dyZXNzKTtlbHNlIHtcblx0ICAgICAgICB0aGlzLmNvbmZpZy53aWR0aCA9IHRoaXMuX3dzUHJvZ3Jlc3MueDtcblx0ICAgICAgICB0aGlzLmNvbmZpZy5oZWlnaHQgPSB0aGlzLl93c1Byb2dyZXNzLnk7XG5cdCAgICAgICAgdGhpcy5yZXNpemUoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl93c1JlYWR5ID0gdGhpcy5fd3NQcm9ncmVzcyA9IGZhbHNlO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblZpZXdSZXNpemVcIiwgW10pO1xuXHQgIH1cblx0fTtcblxuXHRzdGF0ZS5fcG9wdXBzID0gdG9BcnJheSgpO1xuXHR2YXIgYXBpJDMgPSB7XG5cdCAgbmFtZTogXCJ3aW5kb3dcIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy5fdmlld29iai5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3dpbl9jb250ZW50Jz48ZGl2IGNsYXNzPSd3ZWJpeF93aW5faGVhZCc+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfd2luX2JvZHknPjwvZGl2PjwvZGl2PlwiO1xuXHQgICAgdGhpcy5fY29udGVudG9iaiA9IHRoaXMuX3ZpZXdvYmouZmlyc3RDaGlsZDtcblx0ICAgIHRoaXMuX2hlYWRvYmogPSB0aGlzLl9jb250ZW50b2JqLmNoaWxkTm9kZXNbMF07XG5cdCAgICB0aGlzLl9kYXRhb2JqID0gdGhpcy5fYm9keW9iaiA9IHRoaXMuX2NvbnRlbnRvYmouY2hpbGROb2Rlc1sxXTtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X3dpbmRvd1wiO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIik7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuXG5cdCAgICB0aGlzLl9oZWFkX2NlbGwgPSB0aGlzLl9ib2R5X2NlbGwgPSBudWxsO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuX2lubmVyID0ge1xuXHQgICAgICB0b3A6IGZhbHNlLFxuXHQgICAgICBsZWZ0OiBmYWxzZSxcblx0ICAgICAgcmlnaHQ6IGZhbHNlLFxuXHQgICAgICBib3R0b206IGZhbHNlXG5cdCAgICB9OyAvL3NldCBib3JkZXIgZmxhZ3NcblxuXHQgICAgaWYgKCFjb25maWcuaWQpIGNvbmZpZy5pZCA9IHVpZCgpO1xuXG5cdCAgICBfZXZlbnQodGhpcy5fY29udGVudG9iaiwgXCJjbGlja1wiLCBiaW5kKHRoaXMuX2lnbm9yZV9jbGlja3MsIHRoaXMpKTsgLy8gSUU4IGRvZXMgbm90IGFsbG93IHRvIGRlZmluZSBldmVudCBjYXB0dXJpbmdcblxuXG5cdCAgICBpZiAodGhpcy5fY29udGVudG9iai5hZGRFdmVudExpc3RlbmVyKSBfZXZlbnQodGhpcy5fY29udGVudG9iaiwgXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIGJyaW5ncyBhIHdpbmRvdyB0byB0aGUgZnJvbnQgb2Ygb3RoZXIgd2luZG93c1xuXHQgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnpJbmRleCAmJiB0aGlzLl9zZXR0aW5ncy50b0Zyb250KSB7XG5cdCAgICAgICAgdGhpcy5fdmlld29iai5zdHlsZS56SW5kZXggPSB6SW5kZXgoKTtcblx0ICAgICAgfVxuXHQgICAgfSwge1xuXHQgICAgICBiaW5kOiB0aGlzLFxuXHQgICAgICBjYXB0dXJlOiB0cnVlXG5cdCAgICB9KTsgLy8gaGlkZGVuX3NldHRlciBoYW5kbGluZ1xuXG5cdCAgICBpZiAoY29uZmlnLm1vZGFsKSB0aGlzLl9tb2RhbCA9IHRydWU7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25WaWV3TW92ZUVuZFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5wb3NpdGlvbikgZGVsZXRlIHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfaWdub3JlX2NsaWNrczogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBwb3B1cHMgPSBzdGF0ZS5fcG9wdXBzO1xuXHQgICAgdmFyIGluZGV4JCQxID0gcG9wdXBzLmZpbmQodGhpcyk7XG5cdCAgICBpZiAoaW5kZXgkJDEgPT0gLTEpIGluZGV4JCQxID0gcG9wdXBzLmxlbmd0aCAtIDE7XG5cdCAgICBlLmNsaWNrX3ZpZXcgPSBpbmRleCQkMTtcblx0ICAgIGlmIChlbnYuaXNJRTgpIGUuc3JjRWxlbWVudC5jbGlja192aWV3ID0gaW5kZXgkJDE7XG5cdCAgfSxcblx0ICBnZXRDaGlsZFZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5faGVhZF9jZWxsKSByZXR1cm4gW3RoaXMuX2hlYWRfY2VsbCwgdGhpcy5fYm9keV9jZWxsXTtlbHNlIHJldHVybiBbdGhpcy5fYm9keV9jZWxsXTtcblx0ICB9LFxuXHQgIHpJbmRleF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5fdmlld29iai5zdHlsZS56SW5kZXggPSB2YWx1ZTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9yZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2JvZHlfY2VsbCA9IHtcblx0ICAgICAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge31cblx0ICAgIH07XG5cdCAgfSxcblx0ICBfcmVwbGFjZTogZnVuY3Rpb24gKG5ld192aWV3KSB7XG5cdCAgICB0aGlzLl9ib2R5X2NlbGwuZGVzdHJ1Y3RvcigpO1xuXG5cdCAgICB0aGlzLl9ib2R5X2NlbGwgPSBuZXdfdmlldztcblxuXHQgICAgdGhpcy5fYm9keW9iai5hcHBlbmRDaGlsZCh0aGlzLl9ib2R5X2NlbGwuX3ZpZXdvYmopO1xuXG5cdCAgICB2YXIgY2VsbCA9IHRoaXMuX2JvZHlfY2VsbC5fdmlld29iai5zdHlsZTtcblx0ICAgIGNlbGwuYm9yZGVyVG9wV2lkdGggPSBjZWxsLmJvcmRlckJvdHRvbVdpZHRoID0gY2VsbC5ib3JkZXJMZWZ0V2lkdGggPSBjZWxsLmJvcmRlclJpZ2h0V2lkdGggPSBcIjFweFwiO1xuXHQgICAgdGhpcy5fYm9keV9jZWxsLl9zZXR0aW5ncy5faW5uZXIgPSBjbG9uZSh0aGlzLl9zZXR0aW5ncy5faW5uZXIpO1xuXHQgICAgdGhpcy5yZXNpemUodHJ1ZSk7XG5cdCAgfSxcblx0ICBzaG93OiBmdW5jdGlvbiAobm9kZSwgbW9kZSwgcG9pbnQpIHtcblx0ICAgIGlmIChub2RlID09PSB0cnVlKSB7XG5cdCAgICAgIC8vcmVjdXJzaXZlIGNhbGwgZnJvbSBzb21lIGNoaWxkIGl0ZW1cblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5oaWRkZW4pIHJldHVybjtcblx0ICAgICAgbm9kZSA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVNob3dcIiwgYXJndW1lbnRzKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuaGlkZGVuID0gZmFsc2U7XG5cdCAgICB0aGlzLl92aWV3b2JqLnN0eWxlLnpJbmRleCA9IHRoaXMuX3NldHRpbmdzLnpJbmRleCB8fCB6SW5kZXgoKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1vZGFsIHx8IHRoaXMuX21vZGFsKSB7XG5cdCAgICAgIHRoaXMuX21vZGFsX3NldCh0cnVlKTtcblxuXHQgICAgICB0aGlzLl9tb2RhbCA9IG51bGw7IC8vIGhpZGRlbl9zZXR0ZXIgaGFuZGxpbmdcblx0ICAgIH1cblxuXHQgICAgdmFyIGVsUG9zLCBkeCwgZHk7XG5cdCAgICBtb2RlID0gbW9kZSB8fCB7fTtcblx0ICAgIGlmICghbW9kZS5wb3MpIG1vZGUucG9zID0gdGhpcy5fc2V0dGluZ3MucmVsYXRpdmU7IC8vZ2V0IHBvc2l0aW9uIG9mIHNvdXJjZSBodG1sIG5vZGVcblx0ICAgIC8vd2UgbmVlZCB0byBzaG93IHBvcHVwIHdoaWNoIHBvaW50aW5nIHRvIHRoYXQgbm9kZVxuXG5cdCAgICBpZiAobm9kZSkge1xuXHQgICAgICAvL2lmIGV2ZW50IHdhcyBwcm92aWRlZCAtIGdldCBub2RlIGluZm8gZnJvbSBpdFxuXHQgICAgICBpZiAoX3R5cGVvZihub2RlKSA9PSBcIm9iamVjdFwiICYmICFub2RlLnRhZ05hbWUpIHtcblx0ICAgICAgICAvKmJlbG93IGxvZ2ljIGlzIGZhciBmcm9tIGlkZWFsKi9cblx0ICAgICAgICBpZiAobm9kZS50YXJnZXQgfHwgbm9kZS5zcmNFbGVtZW50KSB7XG5cdCAgICAgICAgICBlbFBvcyA9IHBvcyhub2RlKTtcblx0ICAgICAgICAgIGR4ID0gMjA7XG5cdCAgICAgICAgICBkeSA9IDU7XG5cdCAgICAgICAgfSBlbHNlIGVsUG9zID0gbm9kZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBub2RlID0gdG9Ob2RlKG5vZGUpO1xuXHQgICAgICAgIGFzc2VydChub2RlLCBcIk5vdCBleGlzdGluZyB0YXJnZXQgZm9yIHdpbmRvdzpzaG93XCIpO1xuXHQgICAgICAgIGVsUG9zID0gb2Zmc2V0KG5vZGUpO1xuXHQgICAgICB9IC8vc2l6ZSBvZiBib2R5LCB3ZSBuZWVkIHRvIGZpdCBwb3B1cCBpbnNpZGVcblxuXG5cdCAgICAgIHZhciB4ID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGggfHwgMCwgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCk7XG5cdCAgICAgIHZhciB5ID0gTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0IHx8IDAsIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0KTsgLy9zaXplIG9mIG5vZGUsIG5lYXIgd2hpY2ggcG9wdXAgd2lsbCBiZSByZW5kZXJlZFxuXG5cdCAgICAgIGR4ID0gZHggfHwgbm9kZS5vZmZzZXRXaWR0aCB8fCAwO1xuXHQgICAgICBkeSA9IGR5IHx8IG5vZGUub2Zmc2V0SGVpZ2h0IHx8IDA7IC8vc2l6ZSBvZiBwb3B1cCBlbGVtZW50XG5cblx0ICAgICAgdmFyIHNpemUgPSB0aGlzLl9sYXN0X3NpemU7XG5cdCAgICAgIHZhciBmaW5feCA9IGVsUG9zLng7XG5cdCAgICAgIHZhciBmaW5feSA9IGVsUG9zLnk7XG5cdCAgICAgIHZhciBwb2ludF95ID0gMDtcblx0ICAgICAgdmFyIHBvaW50X3ggPSAwO1xuXHQgICAgICB2YXIgc2Nyb2xsTGVmdCA9IDAsXG5cdCAgICAgICAgICBzY3JvbGxUb3AgPSAwO1xuXHQgICAgICB2YXIgZml0ID0gdGhpcy5fc2V0dGluZ3MuYXV0b2ZpdDtcblxuXHQgICAgICBpZiAoZml0KSB7XG5cdCAgICAgICAgdmFyIG5vY2hhbmdlID0gZml0ID09PSBcIm5vZGVcIjtcblx0ICAgICAgICB2YXIgZGVsdGFfeCA9IDY7XG5cdCAgICAgICAgdmFyIGRlbHRhX3kgPSA2O1xuXHQgICAgICAgIHZhciBkZWx0YV9wb2ludCA9IDY7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5wb2ludCkgZGVsdGFfeCA9IGRlbHRhX3kgPSBkZWx0YV9wb2ludCA9IDA7IC8vZGVmYXVsdCBwb2ludGVyIHBvc2l0aW9uIC0gdG9wIFxuXG5cdCAgICAgICAgcG9pbnQgPSBcInRvcFwiO1xuXHQgICAgICAgIGZpbl95ID0gMDtcblx0ICAgICAgICBmaW5feCA9IDA7XG5cdCAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7IC8vaWYgd2Ugd2FudCB0byBwbGFjZSBtZW51IGF0IHJpZ2gsIGJ1dCB0aGVyZSBpcyBubyBwbGFjZSBtb3ZlIGl0IHRvIGxlZnQgaW5zdGVhZFxuXG5cdCAgICAgICAgaWYgKHggLSBlbFBvcy54IC0gZHggPCBzaXplWzBdICYmIG1vZGUucG9zID09IFwicmlnaHRcIiAmJiAhbm9jaGFuZ2UpIG1vZGUucG9zID0gXCJsZWZ0XCI7XG5cblx0ICAgICAgICBpZiAobW9kZS5wb3MgPT0gXCJyaWdodFwiKSB7XG5cdCAgICAgICAgICBmaW5feCA9IGVsUG9zLnggKyBkZWx0YV94ICsgZHg7XG5cdCAgICAgICAgICBkZWx0YV95ID0gLWR5O1xuXHQgICAgICAgICAgcG9pbnQgPSBcImxlZnRcIjtcblx0ICAgICAgICAgIHBvaW50X3kgPSBNYXRoLnJvdW5kKGVsUG9zLnkgKyBkeSAvIDIpO1xuXHQgICAgICAgICAgcG9pbnRfeCA9IGZpbl94IC0gZGVsdGFfcG9pbnQ7XG5cdCAgICAgICAgfSBlbHNlIGlmIChtb2RlLnBvcyA9PSBcImxlZnRcIikge1xuXHQgICAgICAgICAgZmluX3ggPSBlbFBvcy54IC0gZGVsdGFfeCAtIHNpemVbMF0gLSAxO1xuXHQgICAgICAgICAgZGVsdGFfeSA9IC1keTtcblx0ICAgICAgICAgIHBvaW50ID0gXCJyaWdodFwiO1xuXHQgICAgICAgICAgcG9pbnRfeSA9IE1hdGgucm91bmQoZWxQb3MueSArIGR5IC8gMik7XG5cdCAgICAgICAgICBwb2ludF94ID0gZmluX3ggKyBzaXplWzBdICsgMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy9sZWZ0IGJvcmRlciBvZiBzY3JlZW5cblx0ICAgICAgICAgIGlmIChlbFBvcy54IDwgc2Nyb2xsTGVmdCkge1xuXHQgICAgICAgICAgICBmaW5feCA9IHNjcm9sbExlZnQ7IC8vcG9wdXAgZXhjZWVkIHRoZSByaWdodCBib3JkZXIgb2Ygc2NyZWVuXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHggKyBzY3JvbGxMZWZ0IC0gZWxQb3MueCA+IHNpemVbMF0pIHtcblx0ICAgICAgICAgICAgZmluX3ggPSBlbFBvcy54OyAvL2FsaWduZWRcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGZpbl94ID0geCArIHNjcm9sbExlZnQgLSBkZWx0YV94IC0gc2l6ZVswXTsgLy9ub3QgYWxpZ25lZFxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBwb2ludF94ID0gTWF0aC5yb3VuZChlbFBvcy54ICsgZHggLyAyKTsgLy93aGVuIHdlIGhhdmUgYSBzbWFsbCBwb3B1cCwgcG9pbnQgbmVlZCB0byBiZSByZW5kZXJlZCBhdCBjZW50ZXIgb2YgcG9wdXBcblxuXHQgICAgICAgICAgcG9pbnRfeCA9IE1hdGgubWluKHBvaW50X3gsIGZpbl94ICsgc2l6ZVswXSAtIGRlbHRhX3BvaW50ICogMyk7XG5cdCAgICAgICAgfSAvL2lmIGhlaWdodCBpcyBub3QgZml4ZWQgLSB1c2UgZGVmYXVsdCBwb3NpdGlvblxuXG5cblx0ICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcblxuXHQgICAgICAgIGlmICgoIXNpemVbMV0gfHwgeSArIHNjcm9sbFRvcCAtIGR5IC0gZWxQb3MueSAtIGRlbHRhX3kgPiBzaXplWzFdIHx8IG5vY2hhbmdlKSAmJiBtb2RlLnBvcyAhPSBcInRvcFwiKSB7XG5cdCAgICAgICAgICAvL2JvdHRvbVx0XG5cdCAgICAgICAgICBmaW5feSA9IGR5ICsgZWxQb3MueSArIGRlbHRhX3kgLSAoIXRoaXMuX3NldHRpbmdzLnBvaW50ID8gMCA6IDQpO1xuXG5cdCAgICAgICAgICBpZiAoIXBvaW50X3kpIHtcblx0ICAgICAgICAgICAgcG9pbnQgPSBcInRvcFwiO1xuXHQgICAgICAgICAgICBwb2ludF95ID0gZmluX3kgLSBkZWx0YV9wb2ludDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy90b3Bcblx0ICAgICAgICAgIGZpbl95ID0gZWxQb3MueSAtIGRlbHRhX3kgLSBzaXplWzFdO1xuXG5cdCAgICAgICAgICBpZiAoZmluX3kgPCAwKSB7XG5cdCAgICAgICAgICAgIGZpbl95ID0gMDsgLy9sZWZ0fHJpZ2h0IHBvaW50IGNhbiBiZSB1c2VkLCBidXQgdGhlcmUgaXMgbm8gcGxhY2UgZm9yIHRvcCBwb2ludFxuXG5cdCAgICAgICAgICAgIGlmIChwb2ludCA9PSBcInRvcFwiKSBwb2ludCA9IGZhbHNlO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghcG9pbnRfeSkge1xuXHQgICAgICAgICAgICBwb2ludCA9IFwiYm90dG9tXCI7XG5cdCAgICAgICAgICAgIGZpbl95LS07XG5cdCAgICAgICAgICAgIHBvaW50X3kgPSBmaW5feSArIHNpemVbMV0gKyAxO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBkZWx0YXggPSBtb2RlLnggfHwgMDtcblx0ICAgICAgdmFyIGRlbHRheSA9IG1vZGUueSB8fCAwO1xuXG5cdCAgICAgIHZhciBmaXhlZCA9IHRoaXMuX2NoZWNrRml4ZWRQb3NpdGlvbigpO1xuXG5cdCAgICAgIGlmIChmaXhlZCkge1xuXHQgICAgICAgIGZpbl95ID0gZmluX3kgLSBzY3JvbGxUb3A7XG5cdCAgICAgICAgcG9pbnRfeSA9IHBvaW50X3kgLSBzY3JvbGxUb3A7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLnNldFBvc2l0aW9uKGZpbl94ICsgZGVsdGF4LCBmaW5feSArIGRlbHRheSk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldF9wb2ludCkge1xuXHQgICAgICAgIGlmIChwb2ludCAmJiB0aGlzLl9zZXR0aW5ncy5wb2ludCkgdGhpcy5fc2V0X3BvaW50KHBvaW50LCBwb2ludF94ICsgZGVsdGF4LCBwb2ludF95ICsgZGVsdGF5LCBmaXhlZCk7ZWxzZSB0aGlzLl9oaWRlX3BvaW50KCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLl9zZXR0aW5ncy5sZWZ0LCB0aGlzLl9zZXR0aW5ncy50b3ApO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdCAgICB0aGlzLl9oaWRlX3RpbWVyID0gMTtcblx0ICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5faGlkZV90aW1lciA9IDA7XG5cdCAgICB9LCB0aGlzLCBbXSwgZW52LnRvdWNoID8gNDAwIDogMTAwKTtcblxuXHQgICAgdGhpcy5fcmVuZGVyX2hpZGRlbl92aWV3cygpO1xuXG5cdCAgICBpZiAodGhpcy5jb25maWcuYXV0b2ZvY3VzKSB7XG5cdCAgICAgIHRoaXMuX3ByZXZfZm9jdXMgPSBVSU1hbmFnZXIuZ2V0Rm9jdXMoKTtcblx0ICAgICAgVUlNYW5hZ2VyLnNldEZvY3VzKHRoaXMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoLTEgPT0gc3RhdGUuX3BvcHVwcy5maW5kKHRoaXMpKSBzdGF0ZS5fcG9wdXBzLnB1c2godGhpcyk7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU2hvd1wiLCBbXSk7XG5cdCAgfSxcblx0ICBfaGlkZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIC8vZG8gbm90IGhpZGUgbW9kYWwgd2luZG93c1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhpZGRlbiB8fCB0aGlzLl9zZXR0aW5ncy5tb2RhbCB8fCB0aGlzLl9oaWRlX3RpbWVyIHx8IGUgJiYgZS5zaG93cG9wdXApIHJldHVybjsgLy9kbyBub3QgaGlkZSBwb3B1cCwgd2hlbiB3ZSBoYXZlIG1vZGFsIGxheWVyIGFib3ZlIHRoZSBwb3B1cFxuXG5cdCAgICBpZiAoc3RhdGUuX21vZGFsaXR5ICYmIHRoaXMuX3NldHRpbmdzLnpJbmRleCA8PSBzdGF0ZS5fbW9kYWxpdHkpIHJldHVybjsgLy9pZ25vcmUgaW5zaWRlIGNsaWNrcyBhbmQgY2xpY2tzIGluIGNoaWxkLXBvcHVwc1xuXG5cdCAgICBpZiAoZSkge1xuXHQgICAgICB2YXIgaW5kZXgkJDEgPSBlbnYuaXNJRTggPyBlLnNyY0VsZW1lbnQuY2xpY2tfdmlldyA6IGUuY2xpY2tfdmlldztcblx0ICAgICAgaWYgKCFpbmRleCQkMSAmJiBpbmRleCQkMSAhPT0gMCkgaW5kZXgkJDEgPSAtMTtcblxuXHQgICAgICB2YXIgbXlpbmRleCA9IHN0YXRlLl9wb3B1cHMuZmluZCh0aGlzKTtcblxuXHQgICAgICBpZiAobXlpbmRleCA8PSBpbmRleCQkMSkgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmhpZGUoKTtcblx0ICB9LFxuXHQgIGhpZGRlbl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB0aGlzLmhpZGUoKTtlbHNlIHRoaXMuc2hvdygpO1xuXHQgICAgcmV0dXJuICEhdmFsdWU7XG5cdCAgfSxcblx0ICBoaWRlOiBmdW5jdGlvbiAoZm9yY2UpIHtcblx0ICAgIGlmICh0aGlzLiRkZXN0cnVjdGVkKSByZXR1cm47XG5cdCAgICBpZiAoIWZvcmNlKSBpZiAodGhpcy5fc2V0dGluZ3MuaGlkZGVuKSByZXR1cm47XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubW9kYWwpIHRoaXMuX21vZGFsX3NldChmYWxzZSk7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5wb3NpdGlvbiA9PSBcInRvcFwiKSB7XG5cdCAgICAgIGFuaW1hdGUodGhpcy5fdmlld29iaiwge1xuXHQgICAgICAgIHR5cGU6IFwic2xpZGVcIixcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IC0odGhpcy5fY29udGVudF9oZWlnaHQgKyAyMCksXG5cdCAgICAgICAgZHVyYXRpb246IDMwMCxcblx0ICAgICAgICBjYWxsYmFjazogdGhpcy5faGlkZV9jYWxsYmFjayxcblx0ICAgICAgICBtYXN0ZXI6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2UgdGhpcy5faGlkZV9jYWxsYmFjaygpO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2ZvY3VzKSB7XG5cdCAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IC8vYXMgcmVzdWx0IG9mIGhvdGtleSwgd2UgY2FuIGhhdmUgYSBhY3RpdmVFbGVtZW50IHNldCB0byBkb2N1bWVudC5ib2R5XG5cblx0ICAgICAgaWYgKGVsICYmIHRoaXMuX3ZpZXdvYmogJiYgKHRoaXMuX3ZpZXdvYmouY29udGFpbnMoZWwpIHx8IGVsID09PSBkb2N1bWVudC5ib2R5KSkge1xuXHQgICAgICAgIFVJTWFuYWdlci5zZXRGb2N1cyh0aGlzLl9wcmV2X2ZvY3VzKTtcblx0ICAgICAgICB0aGlzLl9wcmV2X2ZvY3VzID0gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9oaWRlX3N1Yl9wb3B1cHMoKTtcblx0ICB9LFxuXHQgIC8vaGlkZSBhbGwgY2hpbGQtcG9wdXBzXG5cdCAgX2hpZGVfc3ViX3BvcHVwczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG9yZGVyID0gc3RhdGUuX3BvcHVwcztcblx0ICAgIHZhciBpbmRleCQkMSA9IG9yZGVyLmZpbmQodGhpcyk7XG5cdCAgICB2YXIgc2l6ZSA9IG9yZGVyLmxlbmd0aCAtIDE7XG5cdCAgICBpZiAoaW5kZXgkJDEgPiAtMSkgZm9yICh2YXIgaSA9IHNpemU7IGkgPiBpbmRleCQkMTsgaS0tKSB7XG5cdCAgICAgIGlmIChvcmRlcltpXS5faGlkZV9wb2ludCkgLy9oaWRlIG9ubHkgcG9wdXBzLCBza2lwIHdpbmRvd3Ncblx0ICAgICAgICBvcmRlcltpXS5oaWRlKCk7XG5cdCAgICB9XG5cdCAgICBvcmRlci5yZW1vdmVBdChpbmRleCQkMSk7XG5cdCAgfSxcblx0ICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9tb2RhbF9zZXQoZmFsc2UpO1xuXG5cdCAgICByZW1vdmUodGhpcy5fdmlld29iaik7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvZm9jdXMpIHtcblx0ICAgICAgaWYgKCFzdGF0ZS5fZmluYWxfZGVzdHJ1Y3Rpb24pIFVJTWFuYWdlci5zZXRGb2N1cyh0aGlzLl9wcmV2X2ZvY3VzKTtcblx0ICAgICAgdGhpcy5fcHJldl9mb2N1cyA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2hpZGVfc3ViX3BvcHVwcygpO1xuXG5cdCAgICBpZiAodGhpcy5faGlkZV9wb2ludCkgdGhpcy5faGlkZV9wb2ludCgpO1xuXHQgICAgRGVzdHJ1Y3Rpb24uZGVzdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXSk7XG5cdCAgfSxcblx0ICBfaGlkZV9jYWxsYmFjazogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLiRkZXN0cnVjdGVkKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy5oaWRkZW4gPSB0cnVlO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uSGlkZVwiLCBbXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBjbG9zZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG5cdCAgfSxcblx0ICBfaW5uZXJfYm9keV9zZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZS5ib3JkZXJsZXNzID09IFwidW5kZWZpbmVkXCIpIHZhbHVlLmJvcmRlcmxlc3MgPSB0cnVlO1xuXHQgIH0sXG5cdCAgYm9keV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKF90eXBlb2YodmFsdWUpICE9IFwib2JqZWN0XCIpIHZhbHVlID0ge1xuXHQgICAgICB0ZW1wbGF0ZTogdmFsdWVcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuX2lubmVyX2JvZHlfc2V0KHZhbHVlKTtcblxuXHQgICAgc3RhdGUuX3BhcmVudF9jZWxsID0gdGhpcztcblx0ICAgIHRoaXMuX2JvZHlfY2VsbCA9IHVpLl92aWV3KHZhbHVlKTtcblxuXHQgICAgdGhpcy5fYm9keW9iai5hcHBlbmRDaGlsZCh0aGlzLl9ib2R5X2NlbGwuX3ZpZXdvYmopO1xuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBoZWFkX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gdmFsdWU7XG5cblx0ICAgIGlmIChfdHlwZW9mKHZhbHVlKSAhPSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB2YWx1ZSk7XG5cblx0ICAgICAgdmFsdWUgPSB7XG5cdCAgICAgICAgdGVtcGxhdGU6IHZhbHVlLFxuXHQgICAgICAgIHBhZGRpbmc6IDBcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFsdWUuYm9yZGVybGVzcyA9IHRydWU7XG5cdCAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSB0aGlzO1xuXHQgICAgdGhpcy5faGVhZF9jZWxsID0gdWkuX3ZpZXcodmFsdWUpO1xuXG5cdCAgICB0aGlzLl9oZWFkb2JqLmFwcGVuZENoaWxkKHRoaXMuX2hlYWRfY2VsbC5fdmlld29iaik7XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGdldEJvZHk6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9ib2R5X2NlbGw7XG5cdCAgfSxcblx0ICBnZXRIZWFkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5faGVhZF9jZWxsO1xuXHQgIH0sXG5cdCAgYWRqdXN0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5yZXNpemUoKTtcblx0ICB9LFxuXHQgIHJlc2l6ZUNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fYm9keV9jZWxsKSB0aGlzLnJlc2l6ZSgpO1xuXHQgIH0sXG5cdCAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBiYXNldmlldy5hcGkuYWRqdXN0LmNhbGwodGhpcyk7XG5cblx0ICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG5cdCAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX3NldHRpbmdzLmxlZnQsIHRoaXMuX3NldHRpbmdzLnRvcCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2hlY2tGaXhlZFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubWFzdGVyKSB7XG5cdCAgICAgIHZhciB0b3AgPSAkJCh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpLmdldFRvcFBhcmVudFZpZXcoKS4kdmlldztcblx0ICAgICAgcmV0dXJuIHRvcCAmJiB0b3Auc3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgX3NldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uIHx8IHRoaXMuX2NoZWNrRml4ZWRQb3NpdGlvbigpKSB7XG5cdCAgICAgIHRoaXMuJHZpZXcuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cdCAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2NvbnRlbnRfd2lkdGg7XG5cdCAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9jb250ZW50X2hlaWdodDtcblx0ICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHJldHVybjtcblx0ICAgICAgdmFyIG1heFdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuXHQgICAgICB2YXIgbWF4SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cdCAgICAgIHZhciBsZWZ0ID0gTWF0aC5yb3VuZCgobWF4V2lkdGggLSB3aWR0aCkgLyAyKTtcblx0ICAgICAgdmFyIHRvcCA9IE1hdGgucm91bmQoKG1heEhlaWdodCAtIGhlaWdodCkgLyAyKTtcblxuXHQgICAgICBpZiAodHlwZW9mIHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgIHZhciBzdGF0ZSQkMSA9IHtcblx0ICAgICAgICAgIGxlZnQ6IGxlZnQsXG5cdCAgICAgICAgICB0b3A6IHRvcCxcblx0ICAgICAgICAgIHdpZHRoOiB3aWR0aCxcblx0ICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuXHQgICAgICAgICAgbWF4V2lkdGg6IG1heFdpZHRoLFxuXHQgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdGhpcy5fc2V0dGluZ3MucG9zaXRpb24uY2FsbCh0aGlzLCBzdGF0ZSQkMSk7XG5cblx0ICAgICAgICBpZiAoc3RhdGUkJDEud2lkdGggIT0gd2lkdGggfHwgc3RhdGUkJDEuaGVpZ2h0ICE9IGhlaWdodCkgdGhpcy4kc2V0U2l6ZShzdGF0ZSQkMS53aWR0aCwgc3RhdGUkJDEuaGVpZ2h0KTtcblx0ICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXRlJCQxLmxlZnQsIHN0YXRlJCQxLnRvcCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uID09IFwidG9wXCIpIHtcblx0ICAgICAgICAgIGlmIChhbmltYXRlLmlzU3VwcG9ydGVkKCkpIHRvcCA9IC0xICogaGVpZ2h0O2Vsc2UgdG9wID0gMTA7XG5cdCAgICAgICAgfSAvL3BvcHVwIGluc2lkZSBhIGZpeGVkIHdpblxuXG5cblx0ICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnBvc2l0aW9uKSB7XG5cdCAgICAgICAgICBsZWZ0ID0gdGhpcy5fc2V0dGluZ3MubGVmdCB8fCBsZWZ0O1xuXHQgICAgICAgICAgdG9wID0gdGhpcy5fc2V0dGluZ3MudG9wIHx8IHRvcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLnNldFBvc2l0aW9uKGxlZnQsIHRvcCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MucG9zaXRpb24gPT0gXCJ0b3BcIikgYW5pbWF0ZSh0aGlzLl92aWV3b2JqLCB7XG5cdCAgICAgICAgdHlwZTogXCJzbGlkZVwiLFxuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogaGVpZ2h0IC0gKHRoaXMuX3NldHRpbmdzLnBhZGRpbmcgfHwgMCkgKiAyLFxuXHQgICAgICAgIGR1cmF0aW9uOiAzMDAsXG5cdCAgICAgICAgY2FsbGJhY2s6IHRoaXMuX3RvcFBvc2l0aW9uQ2FsbGJhY2ssXG5cdCAgICAgICAgbWFzdGVyOiB0aGlzXG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XG5cdCAgfSxcblx0ICBfdG9wUG9zaXRpb25DYWxsYmFjazogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgIGFuaW1hdGUuY2xlYXIobm9kZSk7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy50b3AgPSAtKCh0aGlzLl9zZXR0aW5ncy5wYWRkaW5nIHx8IDApICogMik7XG5cdCAgICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3NldHRpbmdzLmxlZnQsIHRoaXMuX3NldHRpbmdzLnRvcCk7XG5cdCAgfSxcblx0ICBzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUudG9wID0geSArIFwicHhcIjtcblx0ICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy5sZWZ0ID0geDtcblx0ICAgIHRoaXMuX3NldHRpbmdzLnRvcCA9IHk7XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgdmFyIF9ib3JkZXJzID0gdGhpcy5fc2V0dGluZ3MuX2lubmVyO1xuXG5cdCAgICBpZiAoX2JvcmRlcnMpIHtcblx0ICAgICAgZHggKz0gKF9ib3JkZXJzLmxlZnQgPyAwIDogMSkgKyAoX2JvcmRlcnMucmlnaHQgPyAwIDogMSk7XG5cdCAgICAgIGR5ICs9IChfYm9yZGVycy50b3AgPyAwIDogMSkgKyAoX2JvcmRlcnMuYm90dG9tID8gMCA6IDEpO1xuXHQgICAgfSAvL2xpbmUgYmV0d2VlbiBoZWFkIGFuZCBib2R5XG5cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWQpIGR5ICs9IDE7XG5cblx0ICAgIHZhciBzaXplID0gdGhpcy5fYm9keV9jZWxsLiRnZXRTaXplKDAsIDApO1xuXG5cdCAgICB2YXIgaGVhZE1pbldpZHRoID0gMDtcblxuXHQgICAgaWYgKHRoaXMuX2hlYWRfY2VsbCkge1xuXHQgICAgICB2YXIgaGVhZF9zaXplID0gdGhpcy5faGVhZF9jZWxsLiRnZXRTaXplKDAsIDApO1xuXG5cdCAgICAgIGlmIChoZWFkX3NpemVbM10gPT0gaGVhZF9zaXplWzJdKSB0aGlzLl9zZXR0aW5ncy5oZWFkSGVpZ2h0ID0gaGVhZF9zaXplWzNdO1xuXHQgICAgICBkeSArPSB0aGlzLl9zZXR0aW5ncy5oZWFkSGVpZ2h0O1xuXHQgICAgICBoZWFkTWluV2lkdGggPSBoZWFkX3NpemVbMF07XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5mdWxsc2NyZWVuKSB7XG5cdCAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG5cdCAgICAgIHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG5cdCAgICAgIHJldHVybiBbd2lkdGgsIHdpZHRoLCBoZWlnaHQsIGhlaWdodF07XG5cdCAgICB9IC8vZ2V0IGxheW91dCBzaXplc1xuXG5cblx0ICAgIHZhciBzZWxmX3NpemUgPSBiYXNlLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIDAsIDApOyAvL3VzZSBjaGlsZCBzZXR0aW5ncyBpZiBsYXlvdXQncyBvbmUgd2FzIG5vdCBkZWZpbmVkXG5cblx0ICAgIGlmIChoZWFkTWluV2lkdGggJiYgc2l6ZVsxXSA+IDEwMDAwMCkgc2l6ZVswXSA9IE1hdGgubWF4KGhlYWRNaW5XaWR0aCwgc2l6ZVswXSk7XG5cdCAgICBzZWxmX3NpemVbMV0gPSBNYXRoLm1pbihzZWxmX3NpemVbMV0sIChzaXplWzFdID49IDEwMDAwMCAmJiBzZWxmX3NpemVbMV0gPj0gMTAwMDAwID8gTWF0aC5tYXgoc2l6ZVswXSwgc2VsZl9zaXplWzBdKSA6IHNpemVbMV0pICsgZHgpO1xuXHQgICAgc2VsZl9zaXplWzNdID0gTWF0aC5taW4oc2VsZl9zaXplWzNdLCAoc2l6ZVszXSA+PSAxMDAwMDAgJiYgc2VsZl9zaXplWzNdID49IDEwMDAwMCA/IE1hdGgubWF4KHNpemVbMl0sIHNlbGZfc2l6ZVsyXSkgOiBzaXplWzNdKSArIGR5KTtcblx0ICAgIHNlbGZfc2l6ZVswXSA9IE1hdGgubWluKE1hdGgubWF4KHNlbGZfc2l6ZVswXSwgc2l6ZVswXSArIGR4KSwgc2VsZl9zaXplWzFdKTtcblx0ICAgIHNlbGZfc2l6ZVsyXSA9IE1hdGgubWluKE1hdGgubWF4KHNlbGZfc2l6ZVsyXSwgc2l6ZVsyXSArIGR5KSwgc2VsZl9zaXplWzNdKTtcblx0ICAgIHJldHVybiBzZWxmX3NpemU7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGJhc2UuYXBpLiRzZXRTaXplLmNhbGwodGhpcywgeCwgeSk7XG5cdCAgICB4ID0gdGhpcy5fY29udGVudF93aWR0aDtcblx0ICAgIHkgPSB0aGlzLl9jb250ZW50X2hlaWdodDtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWQgPT09IGZhbHNlKSB7XG5cdCAgICAgIHRoaXMuX2hlYWRvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG5cdCAgICAgIHRoaXMuX2JvZHlfY2VsbC4kc2V0U2l6ZSh4LCB5KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2hlYWRfY2VsbC4kc2V0U2l6ZSh4LCB0aGlzLl9zZXR0aW5ncy5oZWFkSGVpZ2h0KTtcblxuXHQgICAgICB0aGlzLl9ib2R5X2NlbGwuJHNldFNpemUoeCwgeSAtIHRoaXMuX3NldHRpbmdzLmhlYWRIZWlnaHQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmYXVsdHMuaGVhZEhlaWdodCA9ICRhY3RpdmUuYmFySGVpZ2h0O1xuXHQgIH0sXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRvcDogMCxcblx0ICAgIGxlZnQ6IDAsXG5cdCAgICBhdXRvZml0OiB0cnVlLFxuXHQgICAgcmVsYXRpdmU6IFwiYm90dG9tXCIsXG5cdCAgICBib2R5OiBcIlwiLFxuXHQgICAgaGVhZDogXCJcIixcblx0ICAgIGhpZGRlbjogdHJ1ZSxcblx0ICAgIGF1dG9mb2N1czogdHJ1ZSxcblx0ICAgIG1pbldpZHRoOiAzMDAsXG5cdCAgICBtaW5IZWlnaHQ6IDIwMFxuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMyA9IGV4cG9ydHMucHJvdG9VSShhcGkkMywgYmFzZS52aWV3LCBNb3ZhYmxlLCBNb2RhbGl0eSwgRXZlbnRTeXN0ZW0sIFJlc2l6ZUFyZWEpO1xuXHR2YXIgd2luZG93JDEgPSB7XG5cdCAgYXBpOiBhcGkkMyxcblx0ICB2aWV3OiB2aWV3JDNcblx0fTtcblxuXHR2YXIgQ29udGV4dEhlbHBlciA9IHtcblx0ICBkZWZhdWx0czoge1xuXHQgICAgcGFkZGluZzogXCI0XCIsXG5cdCAgICBoaWRkZW46IHRydWVcblx0ICB9LFxuXHQgIGJvZHlfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhbHVlID0gd2luZG93JDEuYXBpLmJvZHlfc2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuXHQgICAgdGhpcy5fYm9keV9jZWxsLl92aWV3b2JqLnN0eWxlLmJvcmRlcldpZHRoID0gXCIwcHhcIjtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGF0dGFjaFRvOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBhc3NlcnQob2JqLCBcIkludmFsaWQgdGFyZ2V0IGZvciBDb250ZXh0OjphdHRhY2hcIik7XG5cdCAgICB2YXIgaWQ7XG5cdCAgICBpZiAob2JqLm9uX2NvbnRleHQpIGlkID0gb2JqLmF0dGFjaEV2ZW50KFwib25BZnRlckNvbnRleHRNZW51XCIsIGJpbmQodGhpcy5fc2hvd19hdF91aSwgdGhpcykpO2Vsc2UgaWQgPSBldmVudCQxKG9iaiwgXCJjb250ZXh0bWVudVwiLCB0aGlzLl9zaG93X2F0X25vZGUsIHtcblx0ICAgICAgYmluZDogdGhpc1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25EZXN0cnVjdFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmIChvYmouY2FsbEV2ZW50KSBvYmouZGV0YWNoRXZlbnQoaWQpO2Vsc2UgZXZlbnRSZW1vdmUoaWQpO1xuXHQgICAgICBvYmogPSBudWxsO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fYXJlYTtcblx0ICB9LFxuXHQgIHNldENvbnRleHQ6IGZ1bmN0aW9uIChhcmVhKSB7XG5cdCAgICB0aGlzLl9hcmVhID0gYXJlYTtcblx0ICB9LFxuXHQgIF9zaG93X2F0X25vZGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB0aGlzLl9hcmVhID0gdG9Ob2RlKGUgfHwgZXZlbnQkMSk7XG5cdCAgICByZXR1cm4gdGhpcy5fc2hvd19hdChlKTtcblx0ICB9LFxuXHQgIF9zaG93X2F0X3VpOiBmdW5jdGlvbiAoaWQsIGUpIHtcblx0ICAgIHRoaXMuX2FyZWEgPSB7XG5cdCAgICAgIG9iajogJCQoZSksXG5cdCAgICAgIGlkOiBpZFxuXHQgICAgfTtcblx0ICAgIHJldHVybiB0aGlzLl9zaG93X2F0KGUpO1xuXHQgIH0sXG5cdCAgX3Nob3dfYXQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaG93KGUsIG51bGwsIHRydWUpO1xuXHQgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7IC8vZXZlbnQgZm9yY2VkIHRvIGNsb3NlIG90aGVyIHBvcHVwc3xjb250ZXh0IG1lbnVzXG5cblx0ICAgIGNhbGxFdmVudChcIm9uQ2xpY2tcIiwgW10pO1xuXHQgICAgcmV0dXJuIHByZXZlbnRFdmVudChlKTtcblx0ICB9LFxuXHQgIF9zaG93X29uX21vdXNlX291dDogdHJ1ZSxcblx0ICBtYXN0ZXJfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuYXR0YWNoVG8odmFsdWUpO1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBjbGlwYnVmZmVyID0ge1xuXHQgIF9hcmVhOiBudWxsLFxuXHQgIF9ibHVyX2lkOiBudWxsLFxuXHQgIF9jdHJsOiAwLFxuXG5cdCAgLyohIGNyZWF0ZSB0ZXh0YXJlYSBvciByZXR1cm5zIGV4aXN0aW5nXG5cdCAgICoqL1xuXHQgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHJldHVybnMgZXhpc3RpbmcgdGV4dGFyZWFcblx0ICAgIGlmICh0aGlzLl9hcmVhICE9PSBudWxsKSByZXR1cm4gdGhpcy5fYXJlYTtcblx0ICAgIHN0YXRlLmRlc3RydWN0b3JzLnB1c2goe1xuXHQgICAgICBvYmo6IHRoaXNcblx0ICAgIH0pOyAvLyBjcmVhdGVzIG5ldyB0ZXh0YXJlYVxuXG5cdCAgICB0aGlzLl9hcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuXHQgICAgdGhpcy5fYXJlYS5jbGFzc05hbWUgPSBcIndlYml4X2NsaXBidWZmZXJcIjtcblxuXHQgICAgdGhpcy5fYXJlYS5zZXRBdHRyaWJ1dGUoXCJ3ZWJpeGlnbm9yZVwiLCAxKTtcblxuXHQgICAgdGhpcy5fYXJlYS5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsIFwiZmFsc2VcIik7XG5cblx0ICAgIHRoaXMuX2FyZWEuc2V0QXR0cmlidXRlKFwiYXV0b2NhcGl0YWxpemVcIiwgXCJvZmZcIik7XG5cblx0ICAgIHRoaXMuX2FyZWEuc2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIiwgXCJvZmZcIik7XG5cblx0ICAgIHRoaXMuX2FyZWEuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpO1xuXG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2FyZWEpO1xuXHQgICAgZXZlbnQkMShkb2N1bWVudC5ib2R5LCBcImtleWRvd25cIiwgYmluZChmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIga2V5ID0gZS5rZXlDb2RlO1xuXHQgICAgICB2YXIgY3RybCA9ICEhKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpO1xuXG5cdCAgICAgIGlmIChrZXkgPT09IDg2ICYmIGN0cmwpIHtcblx0ICAgICAgICB0aGlzLl9hcmVhLnZhbHVlID0gXCJcIjtcblx0ICAgICAgICBkZWxheSh0aGlzLl9wYXN0ZSwgdGhpcywgW2VdLCAxMDApO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICByZXR1cm4gdGhpcy5fYXJlYTtcblx0ICB9LFxuXHQgIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2FyZWEgPSBudWxsO1xuXHQgIH0sXG5cblx0ICAvKiEgc2V0IHRleHQgaW50byBidWZmZXJcblx0ICAgKiovXG5cdCAgc2V0OiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgdGhpcy5pbml0KCk7XG5cdCAgICB0ZXh0ID0gdGV4dCA9PT0gXCJcIiA/IFwiXFxuXCIgOiB0ZXh0O1xuXHQgICAgdGhpcy5fYXJlYS52YWx1ZSA9IHRleHQ7XG5cdCAgICB0aGlzLmZvY3VzKCk7XG5cdCAgfSxcblxuXHQgIC8qISBzZWxlY3QgdGV4dCBpbiB0ZXh0YXJlYVxuXHQgICAqKi9cblx0ICBmb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gaWYgdGhlcmUgaXMgbmF0aXZlIGJyb3dzZXIgc2VsZWN0aW9uLCBza2lwIGZvY3VzXG5cdCAgICBpZiAoIXRoaXMuX2lzU2VsZWN0UmFuZ2UoKSkge1xuXHQgICAgICB0aGlzLmluaXQoKTtcblxuXHQgICAgICB0aGlzLl9hcmVhLmZvY3VzKCk7XG5cblx0ICAgICAgdGhpcy5fYXJlYS5zZWxlY3QoKTtcblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgLyohIGNoZWNrcyBkb2N1bWVudCBzZWxlY3Rpb25cblx0ICAgKiovXG5cdCAgX2lzU2VsZWN0UmFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB0ZXh0ID0gXCJcIjtcblxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cuZ2V0U2VsZWN0aW9uICE9IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgdGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuc2VsZWN0aW9uICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuc2VsZWN0aW9uLnR5cGUgPT0gXCJUZXh0XCIpIHtcblx0ICAgICAgdGV4dCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAhIXRleHQ7XG5cdCAgfSxcblxuXHQgIC8qISBwcm9jZXNzIGN0cmwrViBwcmVzc2luZ1xuXHQgICAqKi9cblx0ICBfcGFzdGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgdHJnID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdCAgICBpZiAodHJnID09PSB0aGlzLl9hcmVhKSB7XG5cdCAgICAgIHZhciB0ZXh0ID0gdGhpcy5fYXJlYS52YWx1ZTtcblx0ICAgICAgdmFyIGxhc3RfYWN0aXZlID0gVUlNYW5hZ2VyLmdldEZvY3VzKCk7XG5cblx0ICAgICAgaWYgKGxhc3RfYWN0aXZlICYmICghbGFzdF9hY3RpdmUuZ2V0RWRpdG9yIHx8ICFsYXN0X2FjdGl2ZS5nZXRFZGl0b3IoKSkpIHtcblx0ICAgICAgICBsYXN0X2FjdGl2ZS5jYWxsRXZlbnQoXCJvblBhc3RlXCIsIFt0ZXh0XSk7XG5cblx0ICAgICAgICB0aGlzLl9hcmVhLnNlbGVjdCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBDb3B5UGFzdGUgPSB7XG5cdCAgY2xpcGJvYXJkX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IDEpIHZhbHVlID0gXCJtb2RpZnlcIjtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2VsZWN0XCIsIGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICAgIHZhciB0ZXh0ID0gdGhpcy50eXBlLnRlbXBsYXRlQ29weShpdGVtKTtcblx0ICAgICAgY2xpcGJ1ZmZlci5zZXQodGV4dCwgdGhpcyk7XG5cdCAgICAgIGNsaXBidWZmZXIuZm9jdXMoKTtcblx0ICAgICAgVUlNYW5hZ2VyLnNldEZvY3VzKHRoaXMpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25QYXN0ZVwiLCBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX3Bhc3RlW3RoaXMuX3NldHRpbmdzLmNsaXBib2FyZF0pKSB0aGlzLl9wYXN0ZVt0aGlzLl9zZXR0aW5ncy5jbGlwYm9hcmRdLmNhbGwodGhpcywgdGV4dCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkZvY3VzXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgY2xpcGJ1ZmZlci5mb2N1cygpO1xuXHQgICAgfSk7IC8vIHNvbHV0aW9uIGZvciBjbGlja3Mgb24gc2VsZWN0ZWQgaXRlbXNcblxuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uSXRlbUNsaWNrXCIsIGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBpZiAoIXRoaXMuX3NlbGVjdGVkIHx8IHRoaXMuX3NlbGVjdGVkLmZpbmQoaWQpICE9PSAtMSkge1xuXHQgICAgICAgIGNsaXBidWZmZXIuZm9jdXMoKTtcblx0ICAgICAgICBVSU1hbmFnZXIuc2V0Rm9jdXModGhpcyk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX3Bhc3RlOiB7XG5cdCAgICAvLyBpbnNlcnQgbmV3IGl0ZW0gd2l0aCBwYXN0ZWQgdmFsdWVcblx0ICAgIGluc2VydDogZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgICAgdGhpcy5hZGQoe1xuXHQgICAgICAgIHZhbHVlOiB0ZXh0XG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIC8vIGNoYW5nZSB2YWx1ZSBvZiBlYWNoIHNlbGVjdGVkIGl0ZW1cblx0ICAgIG1vZGlmeTogZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMuZ2V0SXRlbShzZWxbaV0pLnZhbHVlID0gdGV4dDtcblx0ICAgICAgICB0aGlzLnJlZnJlc2goc2VsW2ldKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIC8vIGRvIG5vdGhpbmdcblx0ICAgIGN1c3RvbTogZnVuY3Rpb24gKCkge31cblx0ICB9LFxuXHQgIHRlbXBsYXRlQ29weV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy50eXBlLnRlbXBsYXRlQ29weSA9IHRlbXBsYXRlKHZhbHVlKTtcblx0ICB9LFxuXHQgIHR5cGU6IHtcblx0ICAgIHRlbXBsYXRlQ29weTogZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUoaXRlbSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBDdXN0b21QcmludCA9IHtcblx0ICAkY3VzdG9tUHJpbnQ6IGZ1bmN0aW9uIChvcHRpb25zLCBodG1sT25seSkge1xuXHQgICAgaWYgKHRoaXMuX3ByZVByaW50KG9wdGlvbnMsIGh0bWxPbmx5KSkgcmV0dXJuIHRydWU7XG5cblx0ICAgIHZhciB0YWJsZURhdGEgPSB0aGlzLl9nZXRUYWJsZUFycmF5KG9wdGlvbnMpO1xuXG5cdCAgICB2YXIgdGFibGUgPSB0aGlzLl9nZXRUYWJsZUhUTUwodGFibGVEYXRhLCBvcHRpb25zKTtcblxuXHQgICAgaWYgKGh0bWxPbmx5KSByZXR1cm4gdGFibGU7XG5cdCAgICB2YXIgZG9jID0gY3JlYXRlKFwiZGl2XCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3VpX3ByaW50XCJcblx0ICAgIH0pO1xuXHQgICAgZG9jLmFwcGVuZENoaWxkKHRhYmxlKTtcblx0ICAgIGluc2VydEJlZm9yZShkb2MsIG9wdGlvbnMuZG9jRm9vdGVyLCBkb2N1bWVudC5ib2R5KTtcblx0ICAgIHdpbmRvdy5wcmludCgpO1xuXHQgICAgcmVtb3ZlKGRvYyk7XG5cdCAgfSxcblx0ICBfcHJlUHJpbnQ6IGZ1bmN0aW9uIChvcHRpb25zLCBodG1sT25seSkge1xuXHQgICAgaWYgKCFodG1sT25seSAmJiAodGhpcy5jb25maWcubGF5b3V0ID09IFwieVwiIHx8IG9wdGlvbnMuc2Nyb2xsIHx8IHRoaXMuY29uZmlnLnByZXJlbmRlciB8fCB0aGlzLmNvbmZpZy5hdXRvaGVpZ2h0KSkgcmV0dXJuIHRydWU7XG5cdCAgICBpZiAodGhpcy5jb25maWcubGF5b3V0ID09IFwieFwiKSBleHBvcnRzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG5cdCAgICAgIHhDb3VudDogdGhpcy5jb3VudCgpLFxuXHQgICAgICBub2JyZWFrczogdHJ1ZVxuXHQgICAgfSwgdHJ1ZSk7XG5cdCAgfSxcblx0ICBfZ2V0UGFnZVdpZHRoOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMuZml0ID09IFwicGFnZVwiKSByZXR1cm4gSW5maW5pdHk7XG5cdCAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcblx0ICAgIHZhciB3aWR0aCA9IHNpemVbb3B0aW9ucy5tb2RlID09IFwicG9ydHJhaXRcIiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuXHQgICAgcmV0dXJuIE1hdGgubWluKHdpZHRoICogZW52LnByaW50UFBJIC0gMiAqIGVudi5wcmludE1hcmdpbik7XG5cdCAgfSxcblx0ICBfZ2V0VGFibGVBcnJheTogZnVuY3Rpb24gKG9wdGlvbnMsIGJhc2UsIHN0YXJ0KSB7XG5cdCAgICB2YXIgbWF4V2lkdGggPSB0aGlzLl9nZXRQYWdlV2lkdGgob3B0aW9ucyk7XG5cblx0ICAgIHZhciB4Q291bnQgPSBvcHRpb25zLnhDb3VudCB8fCB0aGlzLl9nZXRWaXNpYmxlUmFuZ2UoKS5fZHg7XG5cblx0ICAgIHZhciB0YWJsZUFycmF5ID0gW107XG5cdCAgICB2YXIgY29scm93ID0gW107XG5cdCAgICB2YXIgd2lkdGggPSAwO1xuXHQgICAgdmFyIG5ld1RhYmxlU3RhcnQsIHJvd251bSwgY29sbnVtO1xuXHQgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXHQgICAgYmFzZSA9IGJhc2UgfHwgW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLm9yZGVyLmxlbmd0aDspIHtcblx0ICAgICAgdmFyIG9iaiA9IHRoaXMuZGF0YS5wdWxsW3RoaXMuZGF0YS5vcmRlcltpXV07XG5cdCAgICAgIHJvd251bSA9IHBhcnNlSW50KGkgLyB4Q291bnQpO1xuXHQgICAgICBjb2xudW0gPSBpIC0gcm93bnVtICogeENvdW50O1xuXG5cdCAgICAgIGlmIChvYmogJiYgY29sbnVtID49IHN0YXJ0KSB7XG5cdCAgICAgICAgd2lkdGggKz0gdGhpcy50eXBlLndpZHRoOyAvL3N0YXJ0IGEgbmV3IHRhYmxlLCBpZiBjZWxscyBkbyBub3QgZml0IHBhZ2Ugd2lkdGhcblxuXHQgICAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoICYmIGNvbG51bSA+IHN0YXJ0KSB7XG5cdCAgICAgICAgICAvLyAnY29sbnVtPnN0YXJ0JyBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgbG9uZyBjZWxsIHdpbGwgaGF2ZSB0byBmaXQgdGhlIHBhZ2Vcblx0ICAgICAgICAgIG5ld1RhYmxlU3RhcnQgPSBjb2xyb3cubGVuZ3RoICsgc3RhcnQ7XG5cdCAgICAgICAgICB0YWJsZUFycmF5LnB1c2goY29scm93KTtcblx0ICAgICAgICAgIGkgPSBpICsgKHhDb3VudCAtIGNvbHJvdy5sZW5ndGgpO1xuXHQgICAgICAgICAgY29scm93ID0gW107XG5cdCAgICAgICAgICB3aWR0aCA9IDA7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2VsbFZhbHVlID0gdGhpcy50eXBlLnRlbXBsYXRlKG9iaiwgdGhpcy50eXBlKTtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5faXRlbUNsYXNzTmFtZTtcblx0ICAgICAgICB2YXIgc3R5bGUgPSB7XG5cdCAgICAgICAgICBkaXNwbGF5OiBcInRhYmxlLWNlbGxcIixcblx0ICAgICAgICAgIGhlaWdodDogdGhpcy50eXBlLmhlaWdodCArIFwicHhcIixcblx0ICAgICAgICAgIHdpZHRoOiB0aGlzLnR5cGUud2lkdGggKyBcInB4XCJcblx0ICAgICAgICB9OyAvL3B1c2ggYSBjZWxsIHRvIGEgcm93XG5cblx0ICAgICAgICBjb2xyb3cucHVzaCh7XG5cdCAgICAgICAgICB0eHQ6IGNlbGxWYWx1ZSxcblx0ICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lICsgXCIgXCIgKyAob2JqLiRjc3MgfHwgXCJcIiksXG5cdCAgICAgICAgICBzdHlsZTogc3R5bGVcblx0ICAgICAgICB9KTsgLy9wdXNoIGEgcm93IHRvIGEgdGFibGUgYW5kIHN0YXJ0IGEgbmV3IHJvd1xuXG5cdCAgICAgICAgaWYgKChpICsgMSkgJSB4Q291bnQgPT09IDApIHtcblx0ICAgICAgICAgIHRhYmxlQXJyYXkucHVzaChjb2xyb3cpO1xuXHQgICAgICAgICAgY29scm93ID0gW107XG5cdCAgICAgICAgICB3aWR0aCA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXG5cdCAgICBiYXNlLnB1c2godGFibGVBcnJheSk7XG5cdCAgICBpZiAobmV3VGFibGVTdGFydCkgdGhpcy5fZ2V0VGFibGVBcnJheShvcHRpb25zLCBiYXNlLCBuZXdUYWJsZVN0YXJ0KTtcblx0ICAgIHJldHVybiBiYXNlO1xuXHQgIH0sXG5cdCAgX2dldFRhYmxlSFRNTDogZnVuY3Rpb24gKHRhYmxlRGF0YSwgb3B0aW9ucykge1xuXHQgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZShcImRpdlwiKTtcblx0ICAgIHRhYmxlRGF0YS5mb3JFYWNoKGJpbmQoZnVuY3Rpb24gKHRhYmxlLCBpKSB7XG5cdCAgICAgIHZhciB0YWJsZUhUTUwgPSBjcmVhdGUoXCJ0YWJsZVwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3RhYmxlX3ByaW50IFwiICsgdGhpcy4kdmlldy5jbGFzc05hbWUsXG5cdCAgICAgICAgXCJzdHlsZVwiOiBcImJvcmRlci1jb2xsYXBzZTpjb2xsYXBzZVwiXG5cdCAgICAgIH0pO1xuXHQgICAgICB0YWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcblx0ICAgICAgICB2YXIgdHIgPSBjcmVhdGUoXCJ0clwiKTtcblx0ICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG5cdCAgICAgICAgICB2YXIgdGQgPSBjcmVhdGUoXCJ0ZFwiKTtcblx0ICAgICAgICAgIGlmIChjb2x1bW4udHh0KSB0ZC5pbm5lckhUTUwgPSBjb2x1bW4udHh0O1xuXHQgICAgICAgICAgaWYgKGNvbHVtbi5jbGFzc05hbWUpIHRkLmNsYXNzTmFtZSA9IGNvbHVtbi5jbGFzc05hbWU7XG5cblx0ICAgICAgICAgIGlmIChjb2x1bW4uc3R5bGUpIHtcblx0ICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb2x1bW4uc3R5bGUpO1xuXHQgICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgIGlmIChjb2x1bW4uc3R5bGVba2V5XSkgdGQuc3R5bGVba2V5XSA9IGNvbHVtbi5zdHlsZVtrZXldO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGNvbHVtbi5zcGFuKSB7XG5cdCAgICAgICAgICAgIGlmIChjb2x1bW4uc3Bhbi5jb2xzcGFuID4gMSkgdGQuY29sU3BhbiA9IGNvbHVtbi5zcGFuLmNvbHNwYW47XG5cdCAgICAgICAgICAgIGlmIChjb2x1bW4uc3Bhbi5yb3dzcGFuID4gMSkgdGQucm93U3BhbiA9IGNvbHVtbi5zcGFuLnJvd3NwYW47XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0YWJsZUhUTUwuYXBwZW5kQ2hpbGQodHIpO1xuXHQgICAgICB9KTtcblx0ICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRhYmxlSFRNTCk7XG5cblx0ICAgICAgaWYgKCFvcHRpb25zLm5vYnJlYWtzICYmIGkgKyAxIDwgdGFibGVEYXRhLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBiciA9IGNyZWF0ZShcIkRJVlwiLCB7XG5cdCAgICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfcHJpbnRfcGFnZWJyZWFrXCJcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYnIpO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICByZXR1cm4gY29udGFpbmVyO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgdGVtcCQxID0gbnVsbDtcblxuXHR2YXIgRGF0YU1hcmtzID0ge1xuXHQgIGFkZENzczogZnVuY3Rpb24gKGlkLCBjc3MsIHNpbGVudCkge1xuXHQgICAgaWYgKCF0aGlzLmFkZFJvd0NzcyAmJiAhc2lsZW50KSB7XG5cdCAgICAgIGlmICghdGhpcy5oYXNDc3MoaWQsIGNzcykpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXG5cdCAgICAgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgICAgIG5vZGUuY2xhc3NOYW1lICs9IFwiIFwiICsgY3NzO1xuXHQgICAgICAgICAgc2lsZW50ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuZGF0YS5hZGRNYXJrKGlkLCBjc3MsIDEsIDEsIHNpbGVudCk7XG5cdCAgfSxcblx0ICByZW1vdmVDc3M6IGZ1bmN0aW9uIChpZCwgY3NzLCBzaWxlbnQpIHtcblx0ICAgIGlmICghdGhpcy5hZGRSb3dDc3MgJiYgIXNpbGVudCkge1xuXHQgICAgICBpZiAodGhpcy5oYXNDc3MoaWQsIGNzcykpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXG5cdCAgICAgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWUucmVwbGFjZShjc3MsIFwiXCIpLnJlcGxhY2UoXCIgIFwiLCBcIiBcIik7XG5cdCAgICAgICAgICBzaWxlbnQgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5kYXRhLnJlbW92ZU1hcmsoaWQsIGNzcywgMSwgc2lsZW50KTtcblx0ICB9LFxuXHQgIGhhc0NzczogZnVuY3Rpb24gKGlkLCBtYXJrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kYXRhLmdldE1hcmsoaWQsIG1hcmspO1xuXHQgIH0sXG5cdCAgY2xlYXJDc3M6IGZ1bmN0aW9uIChjc3MsIHNpbGVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGF0YS5jbGVhck1hcmsoY3NzLCAxLCBzaWxlbnQpO1xuXHQgIH1cblx0fTtcblxuXHQvKlxuXHRcdEJlaGF2aW9yOkRhdGFNb3ZlIC0gYWxsb3dzIHRvIG1vdmUgYW5kIGNvcHkgZWxlbWVudHMsIGhlYXZpbHkgcmVsYXlzIG9uIERhdGFTdG9yZS5tb3ZlXG5cdFx0QGV4cG9ydFxuXHRcdFx0Y29weVxuXHRcdFx0bW92ZVxuXHQqL1xuXG5cdHZhciBEYXRhTW92ZSA9IHtcblx0ICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSBpdGVtXG5cdCAgY29weTogZnVuY3Rpb24gKHNpZCwgdGluZGV4LCB0b2JqLCBkZXRhaWxzKSB7XG5cdCAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTtcblx0ICAgIHZhciBuZXdfaWQgPSBkZXRhaWxzLm5ld0lkIHx8IHNpZDtcblx0ICAgIHRvYmogPSB0b2JqIHx8IHRoaXM7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SXRlbShzaWQpO1xuXHQgICAgYXNzZXJ0KGRhdGEsIFwiSW5jb3JyZWN0IElEIGluIERhdGFNb3ZlOjpjb3B5XCIpOyAvL21ha2UgZGF0YSBjb252ZXJzaW9uIGJldHdlZW4gb2JqZWN0c1xuXG5cdCAgICBpZiAodG9iaikgZGF0YSA9IHRvYmouX2V4dGVybmFsRGF0YShkYXRhKTsgLy9hZGRzIG5ldyBlbGVtZW50IHNhbWUgYXMgb3JpZ2luYWxcblxuXHQgICAgcmV0dXJuIHRvYmouZGF0YS5hZGQodG9iai5fZXh0ZXJuYWxEYXRhKGRhdGEsIG5ld19pZCksIHRpbmRleCwgZGV0YWlscy5wYXJlbnQgfHwgMCk7XG5cdCAgfSxcblx0ICBfbmV4dF9tb3ZlX2luZGV4OiBmdW5jdGlvbiAobmlkLCBuZXh0LCBzb3VyY2UpIHtcblx0ICAgIGlmIChuZXh0ICYmIG5pZCkge1xuXHQgICAgICB2YXIgbmV3X2luZGV4ID0gdGhpcy5nZXRJbmRleEJ5SWQobmlkKTtcblx0ICAgICAgcmV0dXJuIG5ld19pbmRleCArIChzb3VyY2UgPT0gdGhpcyAmJiBzb3VyY2UuZ2V0SW5kZXhCeUlkKG5leHQpIDwgbmV3X2luZGV4ID8gMCA6IDEpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9tb3ZlIGl0ZW0gdG8gdGhlIG5ldyBwb3NpdGlvblxuXHQgIG1vdmU6IGZ1bmN0aW9uIChzaWQsIHRpbmRleCwgdG9iaiwgZGV0YWlscykge1xuXHQgICAgZGV0YWlscyA9IGRldGFpbHMgfHwge307XG5cdCAgICB2YXIgbmV3X2lkID0gZGV0YWlscy5uZXdJZCB8fCBzaWQ7XG5cdCAgICB0b2JqID0gdG9iaiB8fCB0aGlzO1xuXHQgICAgYXNzZXJ0KHRvYmouZGF0YSwgXCJtb3ZpbmcgYXR0ZW1wdCB0byBjb21wb25lbnQgd2l0aG91dCBkYXRhc3RvcmVcIik7XG5cdCAgICBpZiAoIXRvYmouZGF0YSkgcmV0dXJuOyAvL2NhbiBwcm9jZXNzIGFuIGFycnlhIC0gaXQgYWxsb3dzIHRvIHVzZSBpdCBmcm9tIG9uRHJhZyBcblxuXHQgICAgaWYgKGlzQXJyYXkoc2lkKSkge1xuXHQgICAgICAvL2Jsb2NrIHNlcGFyYXRlIHJlcGFpbnQgb3BlcmF0aW9uc1xuXHQgICAgICBpZiAoc2lkLmxlbmd0aCA+IDMpIC8vaGV1cmlzdGljIHZhbHVlLCBkdXBsaWNhdGVkIGJlbG93XG5cdCAgICAgICAgdGhpcy4kYmxvY2tSZW5kZXIgPSB0b2JqLiRibG9ja1JlbmRlciA9IHRydWU7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAvL2luY3JlYXNlIGluZGV4IGZvciBlYWNoIG5leHQgaXRlbSBpbiB0aGUgc2V0LCBzbyBvcmRlciBvZiBpbnNlcnRpb24gd2lsbCBiZSBlcXVhbCB0byBvcmRlciBpbiB0aGUgYXJyYXlcblx0ICAgICAgICB2YXIgX25pZCA9IHRoaXMubW92ZShzaWRbaV0sIHRpbmRleCwgdG9iaiwgZGV0YWlscyk7XG5cblx0ICAgICAgICB0aW5kZXggPSB0b2JqLl9uZXh0X21vdmVfaW5kZXgoX25pZCwgc2lkW2kgKyAxXSwgdGhpcyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLiRibG9ja1JlbmRlciA9IHRvYmouJGJsb2NrUmVuZGVyID0gZmFsc2U7XG5cblx0ICAgICAgaWYgKHNpZC5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgLy9yZXBhaW50IHdob2xlIGNvbXBvbmVudFxuXHQgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgICAgIGlmICh0b2JqICE9IHRoaXMpIHRvYmoucmVmcmVzaCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbmlkID0gc2lkOyAvL2lkIGFmdGVyIG1vdmluZ1xuXG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0SXRlbShzaWQpO1xuXHQgICAgYXNzZXJ0KGRhdGEsIFwiSW5jb3JyZWN0IElEIGluIERhdGFNb3ZlOjptb3ZlXCIpO1xuXG5cdCAgICBpZiAoIXRvYmogfHwgdG9iaiA9PSB0aGlzKSB7XG5cdCAgICAgIGlmICh0aW5kZXggPCAwKSB0aW5kZXggPSB0aGlzLmRhdGEub3JkZXIubGVuZ3RoIC0gMTtcblx0ICAgICAgdGhpcy5kYXRhLm1vdmUodGhpcy5nZXRJbmRleEJ5SWQoc2lkKSwgdGluZGV4KTsgLy9tb3ZlIGluc2lkZSB0aGUgc2FtZSBvYmplY3RcblxuXHQgICAgICB0aGlzLmRhdGEuY2FsbEV2ZW50KFwib25EYXRhTW92ZVwiLCBbc2lkLCB0aW5kZXgsIG51bGwsIHRoaXMuZGF0YS5vcmRlclt0aW5kZXggKyAxXV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy9jb3B5IHRvIHRoZSBuZXcgb2JqZWN0XG5cdCAgICAgIG5pZCA9IHRvYmouZGF0YS5hZGQodG9iai5fZXh0ZXJuYWxEYXRhKGRhdGEsIG5ld19pZCksIHRpbmRleCwgZGV0YWlscy5wYXJlbnQgfHwgMCk7XG5cdCAgICAgIHRoaXMuZGF0YS5yZW1vdmUoc2lkKTsgLy9kZWxldGUgaW4gb2xkIG9iamVjdFxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmlkOyAvL3JldHVybiBJRCBvZiBpdGVtIGFmdGVyIG1vdmluZ1xuXHQgIH0sXG5cdCAgLy9tb3ZlIGl0ZW0gb24gb25lIHBvc2l0aW9uIHVwXG5cdCAgbW92ZVVwOiBmdW5jdGlvbiAoaWQsIHN0ZXApIHtcblx0ICAgIHJldHVybiB0aGlzLm1vdmUoaWQsIHRoaXMuZ2V0SW5kZXhCeUlkKGlkKSAtIChzdGVwIHx8IDEpKTtcblx0ICB9LFxuXHQgIC8vbW92ZSBpdGVtIG9uIG9uZSBwb3NpdGlvbiBkb3duXG5cdCAgbW92ZURvd246IGZ1bmN0aW9uIChpZCwgc3RlcCkge1xuXHQgICAgcmV0dXJuIHRoaXMubW92ZVVwKGlkLCAoc3RlcCB8fCAxKSAqIC0xKTtcblx0ICB9LFxuXHQgIC8vbW92ZSBpdGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvblxuXHQgIG1vdmVUb3A6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMubW92ZShpZCwgMCk7XG5cdCAgfSxcblx0ICAvL21vdmUgaXRlbSB0byB0aGUgbGFzdCBwb3NpdGlvblxuXHQgIG1vdmVCb3R0b206IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMubW92ZShpZCwgdGhpcy5kYXRhLmNvdW50KCkgLSAxKTtcblx0ICB9LFxuXG5cdCAgLypcblx0ICBcdHRoaXMgaXMgYSBzdHViIGZvciBmdXR1cmUgZnVuY3Rpb25hbGl0eVxuXHQgIFx0Y3VycmVudGx5IGl0IGp1c3QgbWFrZXMgYSBjb3B5IG9mIGRhdGEgb2JqZWN0LCB3aGljaCBpcyBlbm91Z2ggZm9yIGN1cnJlbnQgc2l0dWF0aW9uXG5cdCAgKi9cblx0ICBfZXh0ZXJuYWxEYXRhOiBmdW5jdGlvbiAoZGF0YSwgaWQpIHtcblx0ICAgIHZhciBuZXdkYXRhID0gZXhwb3J0cy5leHRlbmQoe30sIGRhdGEpO1xuXHQgICAgbmV3ZGF0YS5pZCA9ICFpZCB8fCB0aGlzLmRhdGEucHVsbFtpZF0gPyB1aWQoKSA6IGlkO1xuXHQgICAgbmV3ZGF0YS4kdGVtcGxhdGUgPSBudWxsO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmV4dGVybmFsRGF0YSkgbmV3ZGF0YSA9IHRoaXMuX3NldHRpbmdzLmV4dGVybmFsRGF0YS5jYWxsKHRoaXMsIG5ld2RhdGEsIGlkLCBkYXRhKTtcblx0ICAgIHJldHVybiBuZXdkYXRhO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgcnVsZXMgPSB7XG5cdCAgaXNFbWFpbDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gL1xcUytAW15AXFxzXStcXC5bXkBcXHNdKyQvLnRlc3QoKHZhbHVlIHx8IFwiXCIpLnRvU3RyaW5nKCkpO1xuXHQgIH0sXG5cdCAgaXNOdW1iZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpID09IHZhbHVlO1xuXHQgIH0sXG5cdCAgaXNDaGVja2VkOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSBcIjBcIjtcblx0ICB9LFxuXHQgIGlzTm90RW1wdHk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSAwIHx8IHZhbHVlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgVmFsaWRhdGVEYXRhID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fZXZlbnRzKSB0aGlzLmF0dGFjaEV2ZW50KFwib25DaGFuZ2VcIiwgdGhpcy5jbGVhclZhbGlkYXRpb24pO1xuXHQgIH0sXG5cdCAgY2xlYXJWYWxpZGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5lbGVtZW50cykge1xuXHQgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmVsZW1lbnRzKSB7XG5cdCAgICAgICAgdGhpcy5fY2xlYXJfaW52YWxpZChpZCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIHZhbGlkYXRlOiBmdW5jdGlvbiAobW9kZSwgb2JqKSB7XG5cdCAgICBhc3NlcnQodGhpcy5jYWxsRXZlbnQsIFwidXNpbmcgdmFsaWRhdGUgZm9yIGV2ZW50bGVzcyBvYmplY3RcIik7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlVmFsaWRhdGVcIiwgW10pO1xuXHQgICAgdmFyIGZhaWxlZCA9IHRoaXMuX3ZhbGlkYXRlX2RldGFpbHMgPSB7fTsgLy9vcHRpbWlzdGljIGJ5IGRlZmF1bHQgOikgXG5cblx0ICAgIHZhciByZXN1bHQgPSB0cnVlO1xuXHQgICAgdmFyIHJ1bGVzJCQxID0gdGhpcy5fc2V0dGluZ3MucnVsZXM7XG5cdCAgICB2YXIgaXNIaWRkZW4gPSB0aGlzLmlzVmlzaWJsZSAmJiAhdGhpcy5pc1Zpc2libGUoKTtcblx0ICAgIHZhciB2YWxpZGF0ZUhpZGRlbiA9IG1vZGUgJiYgbW9kZS5oaWRkZW47XG5cdCAgICB2YXIgdmFsaWRhdGVEaXNhYmxlZCA9IG1vZGUgJiYgbW9kZS5kaXNhYmxlZDsgLy9wcmV2ZW50IHZhbGlkYXRpb24gb2YgaGlkZGVuIGVsZW1lbnRzXG5cblx0ICAgIHZhciBlbGVtZW50cyA9IHt9LFxuXHQgICAgICAgIGhpZGRlbiA9IHt9O1xuXG5cdCAgICBmb3IgKHZhciBpIGluIHRoaXMuZWxlbWVudHMpIHtcblx0ICAgICAgdmFyIG5hbWUgPSB0aGlzLmVsZW1lbnRzW2ldLmNvbmZpZy5uYW1lOyAvL3dlIGFyZSBpZ25vcmluZyBoaWRkZW4gYW5kIGRpc2FibGVkIGZpZWxkcyBkdXJpbmcgdmFsaWRhdGlvblxuXHQgICAgICAvL2lmIG1vZGUgZG9lc24gbm90IGluc3RydWN0IHVzIG90aGVyd2lzZVxuXHQgICAgICAvL2lmIGZvcm0gaXRzZWxmIGlzIGhpZGRlbiwgd2UgY2FuJ3Qgc2VwYXJhdGUgaGlkZGVuIGZpZWxzLFxuXHQgICAgICAvL3NvIHdlIHdpbGwgdmFpZGF0ZSBhbGwgZmllbGRzXG5cblx0ICAgICAgaWYgKChpc0hpZGRlbiB8fCB0aGlzLmVsZW1lbnRzW2ldLmlzVmlzaWJsZSgpIHx8IHZhbGlkYXRlSGlkZGVuKSAmJiAodGhpcy5lbGVtZW50c1tpXS5pc0VuYWJsZWQoKSB8fCB2YWxpZGF0ZURpc2FibGVkKSkgZWxlbWVudHNbbmFtZV0gPSB0aGlzLmVsZW1lbnRzW2ldO2Vsc2Uge1xuXHQgICAgICAgIGhpZGRlbltuYW1lXSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHJ1bGVzJCQxIHx8IGVsZW1lbnRzKSBpZiAoIW9iaiAmJiB0aGlzLmdldFZhbHVlcykgb2JqID0gdGhpcy5nZXRWYWx1ZXMoKTtcblxuXHQgICAgaWYgKHJ1bGVzJCQxKSB7XG5cdCAgICAgIC8vY29tcGxleCBydWxlLCB3aGljaCBtYXkgY2hjZWsgYWxsIHByb3BlcnRpZXMgb2Ygb2JqZWN0XG5cdCAgICAgIGlmIChydWxlcyQkMS4kb2JqKSByZXN1bHQgPSB0aGlzLl92YWxpZGF0ZShydWxlcyQkMS4kb2JqLCBvYmosIG9iaiwgXCJcIikgJiYgcmVzdWx0OyAvL2FsbCAtIGFwcGxpZWQgdG8gYWxsIGZpZWxkc1xuXG5cdCAgICAgIHZhciBhbGwgPSBydWxlcyQkMS4kYWxsO1xuXHQgICAgICB2YXIgZGF0YSA9IG9iajtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNvbXBsZXhEYXRhKSBkYXRhID0gQ29kZVBhcnNlci5jb2xsYXBzZU5hbWVzKG9iaik7XG5cdCAgICAgIGlmIChhbGwpIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgaWYgKGhpZGRlbltfa2V5XSkgY29udGludWU7XG5cblx0ICAgICAgICB2YXIgc3VicmVzdWx0ID0gdGhpcy5fdmFsaWRhdGUoYWxsLCBkYXRhW19rZXldLCBvYmosIF9rZXkpO1xuXG5cdCAgICAgICAgaWYgKCFzdWJyZXN1bHQpIGZhaWxlZFtfa2V5XSA9IHRydWU7XG5cdCAgICAgICAgcmVzdWx0ID0gc3VicmVzdWx0ICYmIHJlc3VsdDtcblx0ICAgICAgfSAvL3Blci1maWVsZCBydWxlc1xuXG5cdCAgICAgIGZvciAodmFyIF9rZXkyIGluIHJ1bGVzJCQxKSB7XG5cdCAgICAgICAgaWYgKGhpZGRlbltfa2V5Ml0pIGNvbnRpbnVlO1xuXG5cdCAgICAgICAgaWYgKF9rZXkyLmluZGV4T2YoXCIkXCIpICE9PSAwICYmICFmYWlsZWRbX2tleTJdKSB7XG5cdCAgICAgICAgICBhc3NlcnQocnVsZXMkJDFbX2tleTJdLCBcIkludmFsaWQgcnVsZSBmb3I6XCIgKyBfa2V5Mik7XG5cblx0ICAgICAgICAgIHZhciBfc3VicmVzdWx0ID0gdGhpcy5fdmFsaWRhdGUocnVsZXMkJDFbX2tleTJdLCBkYXRhW19rZXkyXSwgb2JqLCBfa2V5Mik7XG5cblx0ICAgICAgICAgIGlmICghX3N1YnJlc3VsdCkgZmFpbGVkW19rZXkyXSA9IHRydWU7XG5cdCAgICAgICAgICByZXN1bHQgPSBfc3VicmVzdWx0ICYmIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy9jaGVjayBwZXJzb25hbCB2YWxpZGF0aW9uIHJ1bGVzXG5cblxuXHQgICAgaWYgKGVsZW1lbnRzKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBlbGVtZW50cykge1xuXHQgICAgICAgIGlmIChmYWlsZWRba2V5XSkgY29udGludWU7XG5cdCAgICAgICAgdmFyIHN1YnZpZXcgPSBlbGVtZW50c1trZXldO1xuXG5cdCAgICAgICAgaWYgKHN1YnZpZXcudmFsaWRhdGUpIHtcblx0ICAgICAgICAgIHZhciBfc3VicmVzdWx0MiA9IHN1YnZpZXcudmFsaWRhdGUoKTtcblxuXHQgICAgICAgICAgcmVzdWx0ID0gX3N1YnJlc3VsdDIgJiYgcmVzdWx0O1xuXHQgICAgICAgICAgaWYgKCFfc3VicmVzdWx0MikgZmFpbGVkW2tleV0gPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgaW5wdXQgPSBzdWJ2aWV3Ll9zZXR0aW5ncztcblxuXHQgICAgICAgICAgaWYgKGlucHV0KSB7XG5cdCAgICAgICAgICAgIC8vaWdub3JlIG5vbiB3ZWJpeCBpbnB1dHNcblx0ICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGlucHV0LnZhbGlkYXRlO1xuXHQgICAgICAgICAgICBpZiAoIXZhbGlkYXRvciAmJiBpbnB1dC5yZXF1aXJlZCkgdmFsaWRhdG9yID0gcnVsZXMkJDEuaXNOb3RFbXB0eTtcblxuXHQgICAgICAgICAgICBpZiAodmFsaWRhdG9yKSB7XG5cdCAgICAgICAgICAgICAgdmFyIF9zdWJyZXN1bHQzID0gdGhpcy5fdmFsaWRhdGUodmFsaWRhdG9yLCBvYmpba2V5XSwgb2JqLCBrZXkpO1xuXG5cdCAgICAgICAgICAgICAgaWYgKCFfc3VicmVzdWx0MykgZmFpbGVkW2tleV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgIHJlc3VsdCA9IF9zdWJyZXN1bHQzICYmIHJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJWYWxpZGF0aW9uXCIsIFtyZXN1bHQsIHRoaXMuX3ZhbGlkYXRlX2RldGFpbHNdKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBfdmFsaWRhdGU6IGZ1bmN0aW9uIChydWxlLCBkYXRhLCBvYmosIGtleSkge1xuXHQgICAgaWYgKHR5cGVvZiBydWxlID09IFwic3RyaW5nXCIpIHJ1bGUgPSBydWxlc1tydWxlXTtcblxuXHQgICAgaWYgKHJ1bGUuY2FsbCh0aGlzLCBkYXRhLCBvYmosIGtleSkpIHtcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25WYWxpZGF0aW9uU3VjY2Vzc1wiLCBba2V5LCBvYmpdKSAmJiB0aGlzLl9jbGVhcl9pbnZhbGlkKSB0aGlzLl9jbGVhcl9pbnZhbGlkKGtleSk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25WYWxpZGF0aW9uRXJyb3JcIiwgW2tleSwgb2JqXSkgJiYgdGhpcy5fbWFya19pbnZhbGlkKSB0aGlzLl9tYXJrX2ludmFsaWQoa2V5KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgX3B1bGwgPSB7fTtcblx0ZnVuY3Rpb24gZHAobmFtZSwgZ2V0T25seSkge1xuXHQgIGlmIChfdHlwZW9mKG5hbWUpID09IFwib2JqZWN0XCIgJiYgbmFtZS5fc2V0dGluZ3MpIG5hbWUgPSBuYW1lLl9zZXR0aW5ncy5pZDtcblx0ICBpZiAoX3B1bGxbbmFtZV0gfHwgZ2V0T25seSkgcmV0dXJuIF9wdWxsW25hbWVdO1xuXHQgIGlmICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBuYW1lID09IFwibnVtYmVyXCIpIG5hbWUgPSB7XG5cdCAgICBtYXN0ZXI6ICQkKG5hbWUpXG5cdCAgfTtcblx0ICB2YXIgZHAgPSBuZXcgRGF0YVByb2Nlc3NvcihuYW1lKTtcblx0ICB2YXIgbWFzdGVySWQgPSBkcC5fc2V0dGluZ3MubWFzdGVyLl9zZXR0aW5ncy5pZDtcblx0ICBfcHVsbFttYXN0ZXJJZF0gPSBkcDtcblx0ICAkJChtYXN0ZXJJZCkuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgIF9wdWxsW3RoaXMuX3NldHRpbmdzLmlkXSA9IG51bGw7XG5cdCAgICBkZWxldGUgX3B1bGxbdGhpcy5fc2V0dGluZ3MuaWRdO1xuXHQgIH0pO1xuXHQgIHJldHVybiBkcDtcblx0fVxuXHRkZWZpbmUoXCJkcFwiLCBkcCk7XG5cblx0ZHAuJCQgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICByZXR1cm4gX3B1bGxbaWRdO1xuXHR9O1xuXG5cdHZhciBEYXRhUHJvY2Vzc29yID0gZXhwb3J0cy5wcm90byh7XG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIGF1dG91cGRhdGU6IHRydWUsXG5cdCAgICB1cGRhdGVGcm9tUmVzcG9uc2U6IGZhbHNlLFxuXHQgICAgbW9kZTogXCJwb3N0XCIsXG5cdCAgICBvcGVyYXRpb25OYW1lOiBcIndlYml4X29wZXJhdGlvblwiLFxuXHQgICAgdHJhY2tNb3ZlOiBmYWxzZVxuXHQgIH0sXG5cblx0ICAvKiEgY29uc3RydWN0b3Jcblx0ICAgKiovXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVzZXQoKTtcblx0ICAgIHRoaXMuX2lnbm9yZSA9IGZhbHNlO1xuXHQgICAgdGhpcy5uYW1lID0gXCJEYXRhUHJvY2Vzc29yXCI7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX2FmdGVyX2luaXRfY2FsbCk7XG5cdCAgfSxcblx0ICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdXBkYXRlcyA9IFtdO1xuXHQgIH0sXG5cdCAgdXJsX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAvKlxuXHQgICAgXHR3ZSBjYW4gdXNlIHNpbXBsZSB1cmwgb3IgbW9kZS0+dXJsXG5cdCAgICAqL1xuXHQgICAgdmFyIG1vZGUgPSBcIlwiO1xuXG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgdmFyIHBhcnRzID0gdmFsdWUuc3BsaXQoXCItPlwiKTtcblxuXHQgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIHZhbHVlID0gcGFydHNbMV07XG5cdCAgICAgICAgbW9kZSA9IHBhcnRzWzBdO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLm1vZGUpIHtcblx0ICAgICAgbW9kZSA9IHZhbHVlLm1vZGU7XG5cdCAgICAgIHZhbHVlID0gdmFsdWUudXJsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kZSkgcmV0dXJuIHByb3h5JGEobW9kZSwgdmFsdWUpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgbWFzdGVyX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgc3RvcmUgPSB2YWx1ZTtcblx0ICAgIGlmICh2YWx1ZS5uYW1lICE9IFwiRGF0YVN0b3JlXCIpIHN0b3JlID0gdmFsdWUuZGF0YTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLnN0b3JlID0gc3RvcmU7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblxuXHQgIC8qISBhdHRhY2hpbmcgb25TdG9yZVVwZGF0ZWQgZXZlbnRcblx0ICAgKiovXG5cdCAgX2FmdGVyX2luaXRfY2FsbDogZnVuY3Rpb24gKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMuX3NldHRpbmdzLnN0b3JlLCBcInN0b3JlIG9yIG1hc3RlciBuZWVkIHRvIGJlIGRlZmluZWQgZm9yIHRoZSBkYXRhcHJvY2Vzc29yXCIpO1xuXG5cdCAgICB0aGlzLl9zZXR0aW5ncy5zdG9yZS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGJpbmQodGhpcy5fb25TdG9yZVVwZGF0ZWQsIHRoaXMpKTtcblxuXHQgICAgdGhpcy5fc2V0dGluZ3Muc3RvcmUuYXR0YWNoRXZlbnQoXCJvbkRhdGFNb3ZlXCIsIGJpbmQodGhpcy5fb25EYXRhTW92ZSwgdGhpcykpO1xuXHQgIH0sXG5cdCAgaWdub3JlOiBmdW5jdGlvbiAoY29kZSwgbWFzdGVyKSB7XG5cdCAgICB2YXIgdGVtcCA9IHRoaXMuX2lnbm9yZTtcblx0ICAgIHRoaXMuX2lnbm9yZSA9IHRydWU7XG5cdCAgICBjb2RlLmNhbGwobWFzdGVyIHx8IHRoaXMpO1xuXHQgICAgdGhpcy5faWdub3JlID0gdGVtcDtcblx0ICB9LFxuXHQgIG9mZjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5faWdub3JlID0gdHJ1ZTtcblx0ICB9LFxuXHQgIG9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9pZ25vcmUgPSBmYWxzZTtcblx0ICB9LFxuXHQgIF9jb3B5X2RhdGE6IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgIHZhciBvYmogPSB7fTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuXHQgICAgICBpZiAoa2V5LmluZGV4T2YoXCIkXCIpICE9PSAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH0sXG5cdCAgc2F2ZTogZnVuY3Rpb24gKGlkLCBvcGVyYXRpb24sIG9iaikge1xuXHQgICAgb3BlcmF0aW9uID0gb3BlcmF0aW9uIHx8IFwidXBkYXRlXCI7XG5cblx0ICAgIHRoaXMuX3NhdmVfaW5uZXIoaWQsIG9iaiB8fCB0aGlzLl9zZXR0aW5ncy5zdG9yZS5nZXRJdGVtKGlkKSwgb3BlcmF0aW9uKTtcblx0ICB9LFxuXHQgIF9zYXZlX2lubmVyOiBmdW5jdGlvbiAoaWQsIG9iaiwgb3BlcmF0aW9uKSB7XG5cdCAgICBpZiAoX3R5cGVvZihpZCkgPT0gXCJvYmplY3RcIikgaWQgPSBpZC50b1N0cmluZygpO1xuXHQgICAgaWYgKCFpZCB8fCB0aGlzLl9pZ25vcmUgPT09IHRydWUgfHwgIW9wZXJhdGlvbiB8fCBvcGVyYXRpb24gPT0gXCJwYWludFwiKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHZhciBzdG9yZSA9IHRoaXMuX3NldHRpbmdzLnN0b3JlO1xuXHQgICAgaWYgKHN0b3JlICYmIHN0b3JlLl9zY2hlbWVfc2VyaWFsaXplKSBvYmogPSBzdG9yZS5fc2NoZW1lX3NlcmlhbGl6ZShvYmopO1xuXHQgICAgdmFyIHVwZGF0ZSA9IHtcblx0ICAgICAgaWQ6IGlkLFxuXHQgICAgICBkYXRhOiB0aGlzLl9jb3B5X2RhdGEob2JqKSxcblx0ICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cblx0ICAgIH07IC8vc2F2ZSBwYXJlbnQgaWRcblxuXHQgICAgaWYgKCFpc1VuZGVmaW5lZChvYmouJHBhcmVudCkpIHVwZGF0ZS5kYXRhLnBhcmVudCA9IG9iai4kcGFyZW50O1xuXG5cdCAgICBpZiAodXBkYXRlLm9wZXJhdGlvbiAhPSBcImRlbGV0ZVwiKSB7XG5cdCAgICAgIC8vcHJldmVudCBzYXZpbmcgb2Ygbm90LXZhbGlkYXRlZCByZWNvcmRzXG5cdCAgICAgIHZhciBtYXN0ZXIgPSB0aGlzLl9zZXR0aW5ncy5tYXN0ZXI7XG5cdCAgICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLmRhdGEgJiYgbWFzdGVyLmRhdGEuZ2V0TWFyayAmJiBtYXN0ZXIuZGF0YS5nZXRNYXJrKGlkLCBcIndlYml4X2ludmFsaWRcIikpIHVwZGF0ZS5faW52YWxpZCA9IHRydWU7XG5cdCAgICAgIGlmICghdGhpcy52YWxpZGF0ZShudWxsLCB1cGRhdGUuZGF0YSkpIHVwZGF0ZS5faW52YWxpZCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9jaGVja191bmlxdWUodXBkYXRlKSkgdGhpcy5fdXBkYXRlcy5wdXNoKHVwZGF0ZSk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b3VwZGF0ZSkgdGhpcy5zZW5kKCk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF9vbkRhdGFNb3ZlOiBmdW5jdGlvbiAoc2lkLCB0aW5kZXgsIHBhcmVudCwgdGFyZ2V0aWQpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy50cmFja01vdmUpIHtcblx0ICAgICAgdmFyIG9iaiA9IGNvcHkodGhpcy5fc2V0dGluZ3Muc3RvcmUuZ2V0SXRlbShzaWQpKTtcblx0ICAgICAgb2JqLndlYml4X21vdmVfaW5kZXggPSB0aW5kZXg7XG5cdCAgICAgIG9iai53ZWJpeF9tb3ZlX2lkID0gdGFyZ2V0aWQ7XG5cdCAgICAgIG9iai53ZWJpeF9tb3ZlX3BhcmVudCA9IHBhcmVudDtcblxuXHQgICAgICB0aGlzLl9zYXZlX2lubmVyKHNpZCwgb2JqLCBcIm9yZGVyXCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX29uU3RvcmVVcGRhdGVkOiBmdW5jdGlvbiAoaWQsIG9iaiwgb3BlcmF0aW9uKSB7XG5cdCAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuXHQgICAgICBjYXNlIFwic2F2ZVwiOlxuXHQgICAgICAgIG9wZXJhdGlvbiA9IFwidXBkYXRlXCI7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuXHQgICAgICAgIG9wZXJhdGlvbiA9IFwidXBkYXRlXCI7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBcImFkZFwiOlxuXHQgICAgICAgIG9wZXJhdGlvbiA9IFwiaW5zZXJ0XCI7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuXHQgICAgICAgIG9wZXJhdGlvbiA9IFwiZGVsZXRlXCI7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX3NhdmVfaW5uZXIoaWQsIG9iaiwgb3BlcmF0aW9uKTtcblx0ICB9LFxuXHQgIF9jaGVja191bmlxdWU6IGZ1bmN0aW9uIChjaGVjaykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl91cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBvbmUgPSB0aGlzLl91cGRhdGVzW2ldO1xuXG5cdCAgICAgIGlmIChvbmUuaWQgPT0gY2hlY2suaWQgJiYgIW9uZS5faW5fcHJvZ3Jlc3MpIHtcblx0ICAgICAgICBpZiAoY2hlY2sub3BlcmF0aW9uID09IFwiZGVsZXRlXCIpIHtcblx0ICAgICAgICAgIGlmIChvbmUub3BlcmF0aW9uID09IFwiaW5zZXJ0XCIpIHRoaXMuX3VwZGF0ZXMuc3BsaWNlKGksIDEpO2Vsc2Ugb25lLm9wZXJhdGlvbiA9IFwiZGVsZXRlXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb25lLmRhdGEgPSBjaGVjay5kYXRhO1xuXHQgICAgICAgIG9uZS5faW52YWxpZCA9IGNoZWNrLl9pbnZhbGlkO1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3NlbmREYXRhKCk7XG5cdCAgfSxcblx0ICBfc2VuZERhdGE6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MudXJsKSByZXR1cm47XG5cdCAgICB2YXIgbWFya2VkID0gdGhpcy5fdXBkYXRlcztcblx0ICAgIHZhciB0b19zZW5kID0gW107XG5cdCAgICB2YXIgdXJsID0gdGhpcy5fc2V0dGluZ3MudXJsO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdG9zYXZlID0gbWFya2VkW2ldO1xuXHQgICAgICBpZiAodG9zYXZlLl9pbl9wcm9ncmVzcykgY29udGludWU7XG5cdCAgICAgIGlmICh0b3NhdmUuX2ludmFsaWQpIGNvbnRpbnVlO1xuXHQgICAgICB2YXIgaWQgPSB0b3NhdmUuaWQ7XG5cdCAgICAgIHZhciBvcGVyYXRpb24gPSB0b3NhdmUub3BlcmF0aW9uO1xuXHQgICAgICB2YXIgcHJlY2lzZV91cmwgPSBwcm94eSRhLiRwYXJzZShfdHlwZW9mKHVybCkgPT0gXCJvYmplY3RcIiAmJiAhdXJsLiRwcm94eSA/IHVybFtvcGVyYXRpb25dIDogdXJsKTtcblx0ICAgICAgdmFyIGN1c3RvbSA9IHByZWNpc2VfdXJsICYmIChwcmVjaXNlX3VybC4kcHJveHkgfHwgdHlwZW9mIHByZWNpc2VfdXJsID09PSBcImZ1bmN0aW9uXCIpO1xuXHQgICAgICBpZiAoIXByZWNpc2VfdXJsKSBjb250aW51ZTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnN0b3JlLl9zY2hlbWVfc2F2ZSkgdGhpcy5fc2V0dGluZ3Muc3RvcmUuX3NjaGVtZV9zYXZlKHRvc2F2ZS5kYXRhKTtcblx0ICAgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlXCIgKyBvcGVyYXRpb24sIFtpZCwgdG9zYXZlXSkpIGNvbnRpbnVlO1xuXHQgICAgICB0b3NhdmUuX2luX3Byb2dyZXNzID0gdHJ1ZTtcblx0ICAgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlRGF0YVNlbmRcIiwgW3Rvc2F2ZV0pKSByZXR1cm47XG5cdCAgICAgIHRvc2F2ZS5kYXRhID0gdGhpcy5fdXBkYXRlc0RhdGEodG9zYXZlLmRhdGEpO1xuXG5cdCAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX3NlbmRfY2FsbGJhY2soe1xuXHQgICAgICAgIGlkOiB0b3NhdmUuaWQsXG5cdCAgICAgICAgc3RhdHVzOiB0b3NhdmUub3BlcmF0aW9uXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGlmIChwcmVjaXNlX3VybC4kcHJveHkpIHtcblx0ICAgICAgICBpZiAocHJlY2lzZV91cmwuc2F2ZSkge1xuXHQgICAgICAgICAgLy9wcm94eVxuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9IHByZWNpc2VfdXJsLnNhdmUodGhpcy5jb25maWcubWFzdGVyLCB0b3NhdmUsIHRoaXMpO1xuXG5cdCAgICAgICAgICB0aGlzLl9wcm94eV9vbl9zYXZlKHJlc3VsdCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRvX3NlbmQucHVzaCh0b3NhdmUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChvcGVyYXRpb24gPT0gXCJpbnNlcnRcIikgZGVsZXRlIHRvc2F2ZS5kYXRhLmlkO1xuXG5cdCAgICAgICAgaWYgKGN1c3RvbSkge1xuXHQgICAgICAgICAgLy9zYXZlIGZ1bmN0aW9uXG5cdCAgICAgICAgICB2YXIgX3Jlc3VsdCA9IHByZWNpc2VfdXJsLmNhbGwodGhpcy5jb25maWcubWFzdGVyLCB0b3NhdmUuaWQsIHRvc2F2ZS5vcGVyYXRpb24sIHRvc2F2ZS5kYXRhKTtcblxuXHQgICAgICAgICAgdGhpcy5fcHJveHlfb25fc2F2ZShfcmVzdWx0LCBjYWxsYmFjayk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vbm9ybWFsIHVybFxuXHQgICAgICAgICAgdG9zYXZlLmRhdGFbdGhpcy5fc2V0dGluZ3Mub3BlcmF0aW9uTmFtZV0gPSBvcGVyYXRpb247XG5cblx0ICAgICAgICAgIHRoaXMuX3NlbmQocHJlY2lzZV91cmwsIHRvc2F2ZS5kYXRhLCB0aGlzLl9zZXR0aW5ncy5tb2RlLCBvcGVyYXRpb24sIGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJEYXRhU2VuZFwiLCBbdG9zYXZlXSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh1cmwuJHByb3h5ICYmIHVybC5zYXZlQWxsICYmIHRvX3NlbmQubGVuZ3RoKSB7XG5cdCAgICAgIHZhciBfcmVzdWx0MiA9IHVybC5zYXZlQWxsKHRoaXMuY29uZmlnLm1hc3RlciwgdG9fc2VuZCwgdGhpcyk7XG5cblx0ICAgICAgaWYgKF9yZXN1bHQyKSB7XG5cdCAgICAgICAgaWYgKCFfcmVzdWx0Mi50aGVuKSBfcmVzdWx0MiA9IERlZmVycmVkLnJlc29sdmUoX3Jlc3VsdDIpO1xuXG5cdCAgICAgICAgX3Jlc3VsdDIudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuanNvbiA9PSBcImZ1bmN0aW9uXCIpIGRhdGEgPSBkYXRhLmpzb24oKTtcblxuXHQgICAgICAgICAgX3RoaXMuX3Byb2Nlc3NSZXN1bHQoZGF0YSk7XG5cdCAgICAgICAgfSwgZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgIF90aGlzLl9wcm9jZXNzRXJyb3IobnVsbCwgXCJcIiwgbnVsbCwgeCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9wcm94eV9vbl9zYXZlOiBmdW5jdGlvbiAocmVzdWx0LCBjYWxsYmFjaykge1xuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICBpZiAoIXJlc3VsdC50aGVuKSByZXN1bHQgPSBEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuanNvbiA9PSBcImZ1bmN0aW9uXCIpIGRhdGEgPSBkYXRhLmpzb24oKTtcblx0ICAgICAgICBjYWxsYmFjay5zdWNjZXNzKFwiXCIsIGRhdGEsIC0xKTsgLy90ZXh0LCBkYXRhLCBsb2FkZXJcblx0ICAgICAgfSwgZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICBjYWxsYmFjay5lcnJvcihcIlwiLCBudWxsLCB4KTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIC8qISBwcm9jZXNzIHVwZGF0ZXMgbGlzdCB0byBQT1NUIGFuZCBHRVQgcGFyYW1zIGFjY29yZGluZyBkYXRhcHJvY2Vzc29yIHByb3RvY29sXG5cdCAgICpcdEBwYXJhbSB1cGRhdGVzXG5cdCAgICpcdFx0bGlzdCBvZiBvYmplY3RzIHsgaWQ6IFwiaXRlbSBpZFwiLCBkYXRhOiBcImRhdGEgaGFzaFwiLCBvcGVyYXRpb246IFwidHlwZSBvZiBvcGVyYXRpb25cIn1cblx0ICAgKlx0QHJldHVyblxuXHQgICAqXHRcdG9iamVjdCB7IHBvc3Q6IHsgaGFzaCBvZiBwb3N0IHBhcmFtcyBhcyBuYW1lOiB2YWx1ZSB9LCBnZXQ6IHsgaGFzaCBvZiBnZXQgcGFyYW1zIGFzIG5hbWU6IHZhbHVlIH0gfVxuXHQgICAqKi9cblx0ICBfdXBkYXRlc0RhdGE6IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgIHZhciB0YXJnZXQgPSB7fTtcblxuXHQgICAgZm9yICh2YXIgaiBpbiBzb3VyY2UpIHtcblx0ICAgICAgaWYgKGouaW5kZXhPZihcIiRcIikgIT09IDApIHRhcmdldFtqXSA9IHNvdXJjZVtqXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRhcmdldDtcblx0ICB9LFxuXG5cdCAgLyohIHNlbmQgZGF0YXByb2Nlc3NvciBxdWVyeSB0byBzZXJ2ZXJcblx0ICAgKlx0YW5kIGF0dGFjaCBldmVudCB0byBwcm9jZXNzIHJlc3VsdFxuXHQgICAqXHRAcGFyYW0gdXJsXG5cdCAgICpcdFx0c2VydmVyIHVybFxuXHQgICAqXHRAcGFyYW0gZ2V0XG5cdCAgICpcdFx0aGFzaCBvZiBnZXQgcGFyYW1zXG5cdCAgICpcdEBwYXJhbSBwb3N0XG5cdCAgICpcdFx0aGFzaCBvZiBwb3N0IHBhcmFtc1xuXHQgICAqXHRAbW9kZVxuXHQgICAqXHRcdCdwb3N0JyBvciAnZ2V0J1xuXHQgICAqKi9cblx0ICBfc2VuZDogZnVuY3Rpb24gKHVybCwgcG9zdCwgbW9kZSwgb3BlcmF0aW9uLCBjYWxsYmFjaykge1xuXHQgICAgYXNzZXJ0KHVybCwgXCJ1cmwgd2FzIG5vdCBzZXQgZm9yIERhdGFQcm9jZXNzb3JcIik7XG5cdCAgICBpZiAodHlwZW9mIHVybCA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB1cmwocG9zdCwgb3BlcmF0aW9uLCBjYWxsYmFjayk7XG5cdCAgICBhamF4KClbbW9kZV0odXJsLCBwb3N0LCBjYWxsYmFjayk7XG5cdCAgfSxcblx0ICBfc2VuZF9jYWxsYmFjazogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAodCwgZCwgbCkge1xuXHQgICAgICAgIHJldHVybiBzZWxmLl9wcm9jZXNzUmVzdWx0KGlkLCB0LCBkLCBsKTtcblx0ICAgICAgfSxcblx0ICAgICAgZXJyb3I6IGZ1bmN0aW9uICh0LCBkLCBsKSB7XG5cdCAgICAgICAgcmV0dXJuIHNlbGYuX3Byb2Nlc3NFcnJvcihpZCwgdCwgZCwgbCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSxcblx0ICBhdHRhY2hQcm9ncmVzczogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGVycm9yKSB7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEYXRhU2VuZFwiLCBzdGFydCk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlclN5bmNcIiwgZW5kKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2F2ZUVycm9yXCIsIGVycm9yKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkxvYWRFcnJvclwiLCBlcnJvcik7XG5cdCAgfSxcblx0ICBfcHJvY2Vzc0Vycm9yOiBmdW5jdGlvbiAoaWQsIHRleHQsIGRhdGEsIGxvYWRlcikge1xuXHQgICAgaWYgKGlkKSB0aGlzLl9pbm5lclByb2Nlc3NSZXN1bHQodHJ1ZSwgaWQuaWQsIGZhbHNlLCBpZC5zdGF0dXMsIGZhbHNlLCB7XG5cdCAgICAgIHRleHQ6IHRleHQsXG5cdCAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgIGxvYWRlcjogbG9hZGVyXG5cdCAgICB9KTtlbHNlIHtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkxvYWRFcnJvclwiLCBhcmd1bWVudHMpO1xuXHQgICAgICBjYWxsRXZlbnQoXCJvbkxvYWRFcnJvclwiLCBbdGV4dCwgZGF0YSwgbG9hZGVyLCB0aGlzXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaW5uZXJQcm9jZXNzUmVzdWx0OiBmdW5jdGlvbiAoZXJyb3IsIGlkLCBuZXdpZCwgc3RhdHVzLCBvYmosIGRldGFpbHMpIHtcblx0ICAgIHZhciBtYXN0ZXIgPSB0aGlzLl9zZXR0aW5ncy5tYXN0ZXI7XG5cdCAgICB2YXIgdXBkYXRlID0gdGhpcy5nZXRJdGVtU3RhdGUoaWQpO1xuXHQgICAgdXBkYXRlLl9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuXG5cdCAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTYXZlRXJyb3JcIiwgW2lkLCBzdGF0dXMsIG9iaiwgZGV0YWlsc10pKSB7XG5cdCAgICAgICAgdXBkYXRlLl9pbnZhbGlkID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy51bmRvT25FcnJvciAmJiBtYXN0ZXIuX3NldHRpbmdzLnVuZG8pIHtcblx0ICAgICAgICAgIHRoaXMuaWdub3JlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgbWFzdGVyLnVuZG8oaWQpO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB0aGlzLnNldEl0ZW1TdGF0ZShpZCwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclNhdmVFcnJvclwiLCBbaWQsIHN0YXR1cywgb2JqLCBkZXRhaWxzXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9IGVsc2UgdGhpcy5zZXRJdGVtU3RhdGUoaWQsIGZhbHNlKTsgLy91cGRhdGUgZnJvbSByZXNwb25zZVxuXG5cblx0ICAgIGlmIChuZXdpZCAmJiBpZCAhPSBuZXdpZCkgdGhpcy5fc2V0dGluZ3Muc3RvcmUuY2hhbmdlSWQoaWQsIG5ld2lkKTtcblx0ICAgIGlmIChvYmogJiYgc3RhdHVzICE9IFwiZGVsZXRlXCIgJiYgdGhpcy5fc2V0dGluZ3MudXBkYXRlRnJvbVJlc3BvbnNlKSB0aGlzLmlnbm9yZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnN0b3JlLnVwZGF0ZUl0ZW0obmV3aWQgfHwgaWQsIG9iaik7XG5cdCAgICB9KTsgLy9jbGVhbiB1bmRvIGhpc3RvcnksIGZvciB0aGUgc2F2ZWQgcmVjb3JkXG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy51bmRvT25FcnJvciAmJiBtYXN0ZXIuX3NldHRpbmdzLnVuZG8pIG1hc3Rlci5yZW1vdmVVbmRvKG5ld2lkIHx8IGlkKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclNhdmVcIiwgW29iaiwgaWQsIGRldGFpbHNdKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclwiICsgc3RhdHVzLCBbb2JqLCBpZCwgZGV0YWlsc10pO1xuXHQgIH0sXG5cdCAgcHJvY2Vzc1Jlc3VsdDogZnVuY3Rpb24gKHN0YXRlLCBoYXNoLCBkZXRhaWxzKSB7XG5cdCAgICAvL2NvbXBhdGliaWxpdHkgd2l0aCBjdXN0b20ganNvbiByZXNwb25zZVxuXHQgICAgdmFyIGVycm9yID0gaGFzaCAmJiAoaGFzaC5zdGF0dXMgPT0gXCJlcnJvclwiIHx8IGhhc2guc3RhdHVzID09IFwiaW52YWxpZFwiKTtcblx0ICAgIHZhciBuZXdpZCA9IGhhc2ggPyBoYXNoLm5ld2lkIHx8IGhhc2guaWQgOiBmYWxzZTtcblxuXHQgICAgdGhpcy5faW5uZXJQcm9jZXNzUmVzdWx0KGVycm9yLCBzdGF0ZS5pZCwgbmV3aWQsIHN0YXRlLnN0YXR1cywgaGFzaCwgZGV0YWlscyk7XG5cdCAgfSxcblx0ICAvLyBwcm9jZXNzIHNhdmluZyBmcm9tIHJlc3VsdFxuXHQgIF9wcm9jZXNzUmVzdWx0OiBmdW5jdGlvbiAoc3RhdGUsIHRleHQsIGRhdGEsIGxvYWRlcikge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTeW5jXCIsIFtzdGF0ZSwgdGV4dCwgZGF0YSwgbG9hZGVyXSk7XG5cblx0ICAgIGlmIChpc0FycmF5KHN0YXRlKSkge1xuXHQgICAgICAvL3NhdmVBbGwgcmVzdWx0c1xuXHQgICAgICBzdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChvbmUpIHtcblx0ICAgICAgICBfdGhpczIucHJvY2Vzc1Jlc3VsdChvbmUsIG9uZSwge30pO1xuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChsb2FkZXIgPT09IC0xKSB7XG5cdCAgICAgICAgLy9jYWxsYmFjayBmcm9tIHByb21pc2Vcblx0ICAgICAgICB0aGlzLnByb2Nlc3NSZXN1bHQoc3RhdGUsIGRhdGEsIHt9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgcHJveHkgPSB0aGlzLl9zZXR0aW5ncy51cmw7XG5cdCAgICAgICAgaWYgKHByb3h5LiRwcm94eSAmJiBwcm94eS5yZXN1bHQpIHByb3h5LnJlc3VsdChzdGF0ZSwgdGhpcy5fc2V0dGluZ3MubWFzdGVyLCB0aGlzLCB0ZXh0LCBkYXRhLCBsb2FkZXIpO2Vsc2Uge1xuXHQgICAgICAgICAgdmFyIGhhc2g7XG5cblx0ICAgICAgICAgIGlmICh0ZXh0KSB7XG5cdCAgICAgICAgICAgIGhhc2ggPSBkYXRhLmpzb24oKTsgLy9pbnZhbGlkIHJlc3BvbnNlXG5cblx0ICAgICAgICAgICAgaWYgKHRleHQgJiYgKGhhc2ggPT09IG51bGwgfHwgdHlwZW9mIGhhc2ggPT0gXCJ1bmRlZmluZWRcIikpIGhhc2ggPSB7XG5cdCAgICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0KHN0YXRlLCBoYXNoLCB7XG5cdCAgICAgICAgICAgIHRleHQ6IHRleHQsXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIGxvYWRlcjogbG9hZGVyXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU3luY1wiLCBbc3RhdGUsIHRleHQsIGRhdGEsIGxvYWRlcl0pO1xuXHQgIH0sXG5cblx0ICAvKiEgaWYgaXQncyBkZWZpbmVkIGVzY2FwZSBmdW5jdGlvbiAtIGNhbGwgaXRcblx0ICAgKlx0QHBhcmFtIHZhbHVlXG5cdCAgICpcdFx0dmFsdWUgdG8gZXNjYXBlXG5cdCAgICpcdEByZXR1cm5cblx0ICAgKlx0XHRlc2NhcGVkIHZhbHVlXG5cdCAgICoqL1xuXHQgIGVzY2FwZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZXNjYXBlKSByZXR1cm4gdGhpcy5fc2V0dGluZ3MuZXNjYXBlKHZhbHVlKTtlbHNlIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHQgIH0sXG5cdCAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fdXBkYXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMuX3VwZGF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgaWYgKHRoaXMuX3VwZGF0ZXNbaV0uX2luX3Byb2dyZXNzKSByZXR1cm4gXCJzYXZpbmdcIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBnZXRJdGVtU3RhdGU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIGluZGV4ID0gdGhpcy5fZ2V0X3N0YWNrX2luZGV4KGlkKTtcblxuXHQgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZXNbaW5kZXhdIHx8IG51bGw7XG5cdCAgfSxcblx0ICBzZXRJdGVtU3RhdGU6IGZ1bmN0aW9uIChpZCwgc3RhdGUpIHtcblx0ICAgIGlmIChzdGF0ZSkgdGhpcy5zYXZlKGlkLCBzdGF0ZSk7ZWxzZSB7XG5cdCAgICAgIHZhciBpbmRleCA9IHRoaXMuX2dldF9zdGFja19pbmRleChpZCk7XG5cblx0ICAgICAgaWYgKGluZGV4ID4gLTEpIHRoaXMuX3VwZGF0ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9nZXRfc3RhY2tfaW5kZXg6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIGluZGV4ID0gLTE7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fdXBkYXRlc1tpXS5pZCA9PSBpZCkge1xuXHQgICAgICAgIGluZGV4ID0gaTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaW5kZXg7XG5cdCAgfVxuXHR9LCBTZXR0aW5ncywgRXZlbnRTeXN0ZW0sIFZhbGlkYXRlRGF0YSk7XG5cblx0Lypcblx0XHREYXRhU3RvcmUgaXMgbm90IGEgYmVoYXZpb3IsIGl0IHN0YW5kYWxvbmUgb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIGNvbGxlY3Rpb24gb2YgZGF0YS5cblx0XHRDYWxsIHByb3ZpZGVBUEkgdG8gbWFwIGRhdGEgQVBJXG5cblx0XHRAZXhwb3J0XG5cdFx0XHRleGlzdHNcblx0XHRcdGdldElkQnlJbmRleFxuXHRcdFx0Z2V0SW5kZXhCeUlkXG5cdFx0XHRnZXRcblx0XHRcdHNldFxuXHRcdFx0cmVmcmVzaFxuXHRcdFx0Y291bnRcblx0XHRcdHNvcnRcblx0XHRcdGZpbHRlclxuXHRcdFx0bmV4dFxuXHRcdFx0cHJldmlvdXNcblx0XHRcdGNsZWFyQWxsXG5cdFx0XHRmaXJzdFxuXHRcdFx0bGFzdFxuXHQqL1xuXG5cdGZ1bmN0aW9uIERhdGFTdG9yZSgpIHtcblx0ICB0aGlzLm5hbWUgPSBcIkRhdGFTdG9yZVwiO1xuXHQgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIEV2ZW50U3lzdGVtKTtcblx0ICB0aGlzLnNldERyaXZlcihcImpzb25cIik7IC8vZGVmYXVsdCBkYXRhIHNvdXJjZSBpcyBhblxuXG5cdCAgdGhpcy5wdWxsID0ge307IC8vaGFzaCBvZiBJRHNcblxuXHQgIHRoaXMub3JkZXIgPSB0b0FycmF5KCk7IC8vb3JkZXIgb2YgSURzXG5cblx0ICB0aGlzLl9tYXJrcyA9IHt9O1xuXHR9XG5cblx0RGF0YVN0b3JlLnByb3RvdHlwZSA9IHtcblx0ICAvL2RlZmluZXMgdHlwZSBvZiB1c2VkIGRhdGEgZHJpdmVyXG5cdCAgLy9kYXRhIGRyaXZlciBpcyBhbiBhYnN0cmFjdGlvbiBvdGhlciBkaWZmZXJlbnQgZGF0YSBmb3JtYXRzIC0geG1sLCBqc29uLCBjc3YsIGV0Yy5cblx0ICBzZXREcml2ZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICBhc3NlcnQoRGF0YURyaXZlclt0eXBlXSwgXCJpbmNvcnJlY3QgRGF0YURyaXZlclwiKTtcblx0ICAgIHRoaXMuZHJpdmVyID0gRGF0YURyaXZlclt0eXBlXTtcblx0ICB9LFxuXHQgIC8vcHJvY2VzcyBpbmNvbWluZyByYXcgZGF0YVxuXHQgIF9wYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25QYXJzZVwiLCBbdGhpcy5kcml2ZXIsIGRhdGFdKTtcblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfb3JkZXIpIHRoaXMuZmlsdGVyKCk7IC8vZ2V0IHNpemUgYW5kIHBvc2l0aW9uIG9mIGRhdGFcblxuXHQgICAgdmFyIGluZm8gPSB0aGlzLmRyaXZlci5nZXRJbmZvKGRhdGEpOyAvL2dlbmVyYXRlZCBieSBjb25uZWN0b3JzIG9ubHlcblxuXHQgICAgaWYgKGluZm8ua2V5KSBzdGF0ZS5zZWN1cml0eUtleSA9IGluZm8ua2V5O1xuXHQgICAgaWYgKGluZm8uY29uZmlnKSB0aGlzLmNhbGxFdmVudChcIm9uU2VydmVyQ29uZmlnXCIsIFtpbmZvLmNvbmZpZ10pO1xuXHQgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmRyaXZlci5nZXRPcHRpb25zKGRhdGEpO1xuXHQgICAgaWYgKG9wdGlvbnMpIHRoaXMuY2FsbEV2ZW50KFwib25TZXJ2ZXJPcHRpb25zXCIsIFtvcHRpb25zXSk7IC8vZ2V0IGFycmF5IG9mIHJlY29yZHNcblxuXHQgICAgdmFyIHJlY3MgPSB0aGlzLmRyaXZlci5nZXRSZWNvcmRzKGRhdGEpO1xuXG5cdCAgICB0aGlzLl9pbm5lcl9wYXJzZShpbmZvLCByZWNzKTsgLy9pbiBjYXNlIG9mIHRyZWUgc3RvcmUgd2UgbWF5IHdhbnQgdG8gZ3JvdXAgZGF0YVxuXG5cblx0ICAgIGlmICh0aGlzLl9zY2hlbWVfZ3JvdXAgJiYgdGhpcy5fZ3JvdXBfcHJvY2Vzc2luZyAmJiAhdGhpcy5fbm90X2dyb3VwZWRfb3JkZXIpIHRoaXMuX2dyb3VwX3Byb2Nlc3NpbmcodGhpcy5fc2NoZW1lX2dyb3VwKTsgLy9vcHRpb25hbCBkYXRhIHNvcnRpbmdcblxuXHQgICAgaWYgKHRoaXMuX3NjaGVtZV9zb3J0KSB7XG5cdCAgICAgIHRoaXMuYmxvY2tFdmVudCgpO1xuXHQgICAgICB0aGlzLnNvcnQodGhpcy5fc2NoZW1lX3NvcnQpO1xuXHQgICAgICB0aGlzLnVuYmxvY2tFdmVudCgpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVMb2FkXCIsIFt0aGlzLmRyaXZlciwgZGF0YV0pOyAvL3JlcGFpbnQgc2VsZiBhZnRlciBkYXRhIGxvYWRpbmdcblxuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgfSxcblx0ICBfaW5uZXJfcGFyc2U6IGZ1bmN0aW9uIChpbmZvLCByZWNzKSB7XG5cdCAgICB2YXIgZnJvbSA9IGluZm8uZnJvbTtcblx0ICAgIHZhciBzdWJsb2FkID0gdHJ1ZTtcblx0ICAgIHZhciBtYXJrcyA9IGZhbHNlOyAvL3NvbWUgZGF0YSBpcyBsb2FkZWQgYW5kIG5ldyBkYXRhIGRvZXNuJ3QgaGF2ZSBcInBvc1wiIC0gYXNzdW1pbmcgdXBkYXRlXG5cblx0ICAgIGlmICghZnJvbSAmJiBmcm9tICE9PSAwICYmIHRoaXMub3JkZXJbMF0pIHtcblx0ICAgICAgaWYgKHRoaXMuX3JlbW92ZU1pc3NlZCkge1xuXHQgICAgICAgIC8vdXBkYXRlIG1vZGUsIGNyZWF0ZSBraWxsIGxpc3Rcblx0ICAgICAgICBtYXJrcyA9IHt9O1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBtYXJrc1t0aGlzLm9yZGVyW2ldXSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgc3VibG9hZCA9IGZhbHNlO1xuXHQgICAgICBmcm9tID0gdGhpcy5vcmRlci5sZW5ndGg7XG5cdCAgICB9IGVsc2UgZnJvbSA9IChmcm9tIHx8IDApICogMTtcblxuXHQgICAgdmFyIGogPSAwO1xuXG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmVjcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgLy9nZXQgaGFzaCBvZiBkZXRhaWxzIGZvciBlYWNoIHJlY29yZFxuXHQgICAgICB2YXIgdGVtcCA9IHRoaXMuZHJpdmVyLmdldERldGFpbHMocmVjc1tfaV0pO1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLmlkKHRlbXApOyAvL2dlbmVyYXRlIElEIGZvciB0aGUgcmVjb3JkXG5cblx0ICAgICAgaWYgKCF0aGlzLnB1bGxbaWRdKSB7XG5cdCAgICAgICAgLy9pZiBzdWNoIElEIGFscmVhZHkgZXhpc3RzIC0gdXBkYXRlIGluc3RlYWQgb2YgaW5zZXJ0XG5cdCAgICAgICAgdGhpcy5vcmRlcltqICsgZnJvbV0gPSBpZDtcblx0ICAgICAgICBqKys7XG5cdCAgICAgIH0gZWxzZSBpZiAoc3VibG9hZCAmJiB0aGlzLm9yZGVyW2ogKyBmcm9tXSkgaisrO1xuXG5cdCAgICAgIGlmICh0aGlzLnB1bGxbaWRdKSB7XG5cdCAgICAgICAgZXhwb3J0cy5leHRlbmQodGhpcy5wdWxsW2lkXSwgdGVtcCwgdHJ1ZSk7IC8vYWRkIG9ubHkgbmV3IHByb3BlcnRpZXNcblxuXHQgICAgICAgIGlmICh0aGlzLl9zY2hlbWVfdXBkYXRlKSB0aGlzLl9zY2hlbWVfdXBkYXRlKHRoaXMucHVsbFtpZF0pOyAvL3VwZGF0ZSBtb2RlLCByZW1vdmUgaXRlbSBmcm9tIGtpbGwgbGlzdFxuXG5cdCAgICAgICAgaWYgKG1hcmtzKSBkZWxldGUgbWFya3NbaWRdO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMucHVsbFtpZF0gPSB0ZW1wO1xuXHQgICAgICAgIGlmICh0aGlzLl9zY2hlbWVfaW5pdCkgdGhpcy5fc2NoZW1lX2luaXQodGVtcCk7XG5cdCAgICAgIH1cblx0ICAgIH0gLy91cGRhdGUgbW9kZSwgZGVsZXRlIGl0ZW1zIHdoaWNoIGFyZSBub3QgZXhpc3RpbmcgaW4gdGhlIG5ldyB4bWxcblxuXG5cdCAgICBpZiAobWFya3MpIHtcblx0ICAgICAgdGhpcy5ibG9ja0V2ZW50KCk7XG5cblx0ICAgICAgZm9yICh2YXIgZGVsaWQgaW4gbWFya3MpIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZShkZWxpZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLnVuYmxvY2tFdmVudCgpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZW5kcG9zID0gaW5mby5zaXplICogMTtcblxuXHQgICAgaWYgKGVuZHBvcykge1xuXHQgICAgICBpZiAoIXRoaXMub3JkZXJbZW5kcG9zIC0gMV0pIHRoaXMub3JkZXJbZW5kcG9zIC0gMV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgIGlmIChlbmRwb3MgPCB0aGlzLm9yZGVyLmxlbmd0aCkgdGhpcy5vcmRlciA9IHRoaXMub3JkZXIuc2xpY2UoMCwgZW5kcG9zKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vZ2VuZXJhdGUgaWQgZm9yIGRhdGEgb2JqZWN0XG5cdCAgaWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICByZXR1cm4gZGF0YS5pZCB8fCAoZGF0YS5pZCA9IHVpZCgpKTtcblx0ICB9LFxuXHQgIGNoYW5nZUlkOiBmdW5jdGlvbiAob2xkLCBuZXdpZCkge1xuXHQgICAgLy9hc3NlcnQodGhpcy5wdWxsW29sZF0sXCJDYW4ndCBjaGFuZ2UgaWQsIGZvciBub24gZXhpc3RpbmcgaXRlbTogXCIrb2xkKTtcblx0ICAgIGlmIChvbGQgPT0gbmV3aWQpIHJldHVybjtcblx0ICAgIGlmICh0aGlzLnB1bGxbb2xkXSkgdGhpcy5wdWxsW25ld2lkXSA9IHRoaXMucHVsbFtvbGRdO1xuXHQgICAgdGhpcy5wdWxsW25ld2lkXS5pZCA9IG5ld2lkO1xuXHQgICAgdGhpcy5vcmRlclt0aGlzLm9yZGVyLmZpbmQob2xkKV0gPSBuZXdpZDtcblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfb3JkZXIpIHRoaXMuX2ZpbHRlcl9vcmRlclt0aGlzLl9maWx0ZXJfb3JkZXIuZmluZChvbGQpXSA9IG5ld2lkO1xuXG5cdCAgICBpZiAodGhpcy5fbWFya3Nbb2xkXSkge1xuXHQgICAgICB0aGlzLl9tYXJrc1tuZXdpZF0gPSB0aGlzLl9tYXJrc1tvbGRdO1xuXHQgICAgICBkZWxldGUgdGhpcy5fbWFya3Nbb2xkXTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbklkQ2hhbmdlXCIsIFtvbGQsIG5ld2lkXSk7XG5cdCAgICBpZiAodGhpcy5fcmVuZGVyX2NoYW5nZV9pZCkgdGhpcy5fcmVuZGVyX2NoYW5nZV9pZChvbGQsIG5ld2lkKTtcblx0ICAgIGRlbGV0ZSB0aGlzLnB1bGxbb2xkXTtcblx0ICB9LFxuXHQgIC8vZ2V0IGRhdGEgZnJvbSBoYXNoIGJ5IGlkXG5cdCAgZ2V0SXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5wdWxsW2lkXTtcblx0ICB9LFxuXHQgIC8vYXNzaWducyBkYXRhIGJ5IGlkXG5cdCAgdXBkYXRlSXRlbTogZnVuY3Rpb24gKGlkLCB1cGRhdGUsIG1vZGUpIHtcblx0ICAgIGlmIChfdHlwZW9mKGlkKSA9PT0gXCJvYmplY3RcIikgaWQgPSBpZC50b1N0cmluZygpO1xuXHQgICAgdmFyIGRhdGEgPSB0aGlzLmdldEl0ZW0oaWQpO1xuXHQgICAgdmFyIG9sZCA9IG51bGw7IC8vY2hlY2sgaXMgY2hhbmdlIHRyYWNraW5nIGFjdGl2ZVxuXG5cdCAgICB2YXIgY2hhbmdlVHJhY2sgPSB0aGlzLmhhc0V2ZW50KFwib25EYXRhVXBkYXRlXCIpO1xuXHQgICAgYXNzZXJ0KGRhdGEsIFwiSW52YWxpZCBJRCBmb3IgdXBkYXRlSXRlbVwiKTtcblx0ICAgIGFzc2VydCghdXBkYXRlIHx8ICF1cGRhdGUuaWQgfHwgdXBkYXRlLmlkID09IGlkLCBcIkF0dGVtcHQgdG8gY2hhbmdlIElEIGluIHVwZGF0ZUl0ZW1cIik7XG5cblx0ICAgIGlmICghaXNVbmRlZmluZWQodXBkYXRlKSAmJiBkYXRhICE9PSB1cGRhdGUpIHtcblx0ICAgICAgLy9wcmVzZXJ2ZSBvcmlnaW5hbCBvYmplY3Rcblx0ICAgICAgaWYgKGNoYW5nZVRyYWNrKSBvbGQgPSBjb3B5KGRhdGEpO1xuXHQgICAgICBpZCA9IGRhdGEuaWQ7IC8vcHJlc2VydmUgaWRcblxuXHQgICAgICBleHBvcnRzLmV4dGVuZChkYXRhLCB1cGRhdGUsIHRydWUpO1xuXHQgICAgICBkYXRhLmlkID0gaWQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zY2hlbWVfdXBkYXRlKSB0aGlzLl9zY2hlbWVfdXBkYXRlKGRhdGEpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbaWQsIGRhdGEsIG1vZGUgfHwgXCJ1cGRhdGVcIl0pO1xuXHQgICAgaWYgKGNoYW5nZVRyYWNrKSB0aGlzLmNhbGxFdmVudChcIm9uRGF0YVVwZGF0ZVwiLCBbaWQsIGRhdGEsIG9sZF0pO1xuXHQgIH0sXG5cdCAgLy9zZW5kcyByZXBhaW50aW5nIHNpZ25hbFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKHRoaXMuX3NraXBfcmVmcmVzaCkgcmV0dXJuO1xuXG5cdCAgICBpZiAoaWQpIHtcblx0ICAgICAgaWYgKHRoaXMuZXhpc3RzKGlkKSkgdGhpcy5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbaWQsIHRoaXMucHVsbFtpZF0sIFwicGFpbnRcIl0pO1xuXHQgICAgfSBlbHNlIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW251bGwsIG51bGwsIG51bGxdKTtcblx0ICB9LFxuXHQgIHNpbGVudDogZnVuY3Rpb24gKGNvZGUsIG1hc3Rlcikge1xuXHQgICAgdGhpcy5fc2tpcF9yZWZyZXNoID0gdHJ1ZTtcblx0ICAgIGNvZGUuY2FsbChtYXN0ZXIgfHwgdGhpcyk7XG5cdCAgICB0aGlzLl9za2lwX3JlZnJlc2ggPSBmYWxzZTtcblx0ICB9LFxuXHQgIC8vY29udmVydHMgcmFuZ2UgSURzIHRvIGFycmF5IG9mIGFsbCBJRHMgYmV0d2VlbiB0aGVtXG5cdCAgZ2V0UmFuZ2U6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuXHQgICAgLy9pZiBzb21lIHBvaW50IGlzIG5vdCBkZWZpbmVkIC0gdXNlIGZpcnN0IG9yIGxhc3QgaWRcblx0ICAgIC8vQkVXQVJFIC0gZG8gbm90IHVzZSBlbXB0eSBvciBudWxsIElEXG5cdCAgICBpZiAoZnJvbSkgZnJvbSA9IHRoaXMuZ2V0SW5kZXhCeUlkKGZyb20pO2Vsc2UgZnJvbSA9IHRoaXMuJG1pbiB8fCB0aGlzLnN0YXJ0T2Zmc2V0IHx8IDA7XG5cdCAgICBpZiAodG8pIHRvID0gdGhpcy5nZXRJbmRleEJ5SWQodG8pO2Vsc2Uge1xuXHQgICAgICB0byA9IHRoaXMuJG1heCA9PT0gMCA/IDAgOiBNYXRoLm1pbih0aGlzLiRtYXggPyB0aGlzLiRtYXggLSAxIDogdGhpcy5lbmRPZmZzZXQgfHwgSW5maW5pdHksIHRoaXMuY291bnQoKSAtIDEpO1xuXHQgICAgICBpZiAodG8gPCAwKSB0byA9IDA7IC8vd2UgaGF2ZSBub3QgZGF0YSBpbiB0aGUgc3RvcmVcblx0ICAgIH1cblxuXHQgICAgaWYgKGZyb20gPiB0bykge1xuXHQgICAgICAvL2NhbiBiZSBpbiBjYXNlIG9mIGJhY2t3YXJkIHNoaWZ0LXNlbGVjdGlvblxuXHQgICAgICB2YXIgYSA9IHRvO1xuXHQgICAgICB0byA9IGZyb207XG5cdCAgICAgIGZyb20gPSBhO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5nZXRJbmRleFJhbmdlKGZyb20sIHRvKTtcblx0ICB9LFxuXHQgIC8vY29udmVydHMgcmFuZ2Ugb2YgaW5kZXhlcyB0byBhcnJheSBvZiBhbGwgSURzIGJldHdlZW4gdGhlbVxuXHQgIGdldEluZGV4UmFuZ2U6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuXHQgICAgdG8gPSBNYXRoLm1pbih0byA9PT0gMCA/IDAgOiB0byB8fCBJbmZpbml0eSwgdGhpcy5jb3VudCgpIC0gMSk7XG5cdCAgICB2YXIgcmV0ID0gdG9BcnJheSgpOyAvL3Jlc3VsdCBvZiBtZXRob2QgaXMgcmljaC1hcnJheVxuXG5cdCAgICBmb3IgKHZhciBpID0gZnJvbSB8fCAwOyBpIDw9IHRvOyBpKyspIHtcblx0ICAgICAgcmV0LnB1c2godGhpcy5nZXRJdGVtKHRoaXMub3JkZXJbaV0pKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9LFxuXHQgIC8vcmV0dXJucyB0b3RhbCBjb3VudCBvZiBlbGVtZW50c1xuXHQgIGNvdW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vcmRlci5sZW5ndGg7XG5cdCAgfSxcblx0ICAvL3JldHVybnMgdHJ1eSBpZiBpdGVtIHdpdGggc3VjaCBJRCBleGlzdHNcblx0ICBleGlzdHM6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuICEhdGhpcy5wdWxsW2lkXTtcblx0ICB9LFxuXHQgIC8vbmV4dG1ldGhvZCBpcyBub3QgdmlzaWJsZSBvbiBjb21wb25lbnQgbGV2ZWwsIGNoZWNrIERhdGFNb3ZlLm1vdmVcblx0ICAvL21vdmVzIGl0ZW0gZnJvbSBzb3VyY2UgaW5kZXggdG8gdGhlIHRhcmdldCBpbmRleFxuXHQgIG1vdmU6IGZ1bmN0aW9uIChzaW5kZXgsIHRpbmRleCkge1xuXHQgICAgYXNzZXJ0KHNpbmRleCA+PSAwICYmIHRpbmRleCA+PSAwLCBcIkRhdGFTdG9yZTo6bW92ZVwiLCBcIkluY29ycmVjdCBpbmRleGVzXCIpO1xuXHQgICAgaWYgKHNpbmRleCA9PSB0aW5kZXgpIHJldHVybjtcblx0ICAgIHZhciBpZCA9IHRoaXMuZ2V0SWRCeUluZGV4KHNpbmRleCk7XG5cdCAgICB2YXIgb2JqID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfb3JkZXIpIHRoaXMuX21vdmVfaW5uZXIodGhpcy5fZmlsdGVyX29yZGVyLCAwLCAwLCB0aGlzLmdldElkQnlJbmRleChzaW5kZXgpLCB0aGlzLmdldElkQnlJbmRleCh0aW5kZXgpKTtcblxuXHQgICAgdGhpcy5fbW92ZV9pbm5lcih0aGlzLm9yZGVyLCBzaW5kZXgsIHRpbmRleCk7IC8vcmVwYWludCBzaWduYWxcblxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFtpZCwgb2JqLCBcIm1vdmVcIl0pO1xuXHQgIH0sXG5cdCAgX21vdmVfaW5uZXI6IGZ1bmN0aW9uIChjb2wsIHNpbmRleCwgdGluZGV4LCBzaWQsIHRpZCkge1xuXHQgICAgaWYgKHNpZCB8fCB0aWQpIHtcblx0ICAgICAgc2luZGV4ID0gdGluZGV4ID0gLTE7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoY29sW2ldID09IHNpZCAmJiBzaW5kZXggPCAwKSBzaW5kZXggPSBpO1xuXHQgICAgICAgIGlmIChjb2xbaV0gPT0gdGlkICYmIHRpbmRleCA8IDApIHRpbmRleCA9IGk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGlkID0gY29sW3NpbmRleF07XG5cdCAgICBjb2wucmVtb3ZlQXQoc2luZGV4KTsgLy9yZW1vdmUgYXQgb2xkIHBvc2l0aW9uXG5cblx0ICAgIGNvbC5pbnNlcnRBdChpZCwgTWF0aC5taW4oY29sLmxlbmd0aCwgdGluZGV4KSk7IC8vaW5zZXJ0IGF0IG5ldyBwb3NpdGlvblxuXHQgIH0sXG5cdCAgc2NoZW1lOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLl9zY2hlbWUgPSB7fTtcblx0ICAgIHRoaXMuX3NjaGVtZV9zYXZlID0gY29uZmlnLiRzYXZlO1xuXHQgICAgdGhpcy5fc2NoZW1lX2luaXQgPSBjb25maWcuJGluaXQgfHwgY29uZmlnLiRjaGFuZ2U7XG5cdCAgICB0aGlzLl9zY2hlbWVfdXBkYXRlID0gY29uZmlnLiR1cGRhdGUgfHwgY29uZmlnLiRjaGFuZ2U7XG5cdCAgICB0aGlzLl9zY2hlbWVfc2VyaWFsaXplID0gY29uZmlnLiRzZXJpYWxpemU7XG5cdCAgICB0aGlzLl9zY2hlbWVfZ3JvdXAgPSBjb25maWcuJGdyb3VwO1xuXHQgICAgdGhpcy5fc2NoZW1lX3NvcnQgPSBjb25maWcuJHNvcnQ7XG5cdCAgICB0aGlzLl9zY2hlbWVfZXhwb3J0ID0gY29uZmlnLiRleHBvcnQ7IC8vaWdub3JlICQtc3RhcnRpbmcgcHJvcGVydGllcywgYXMgdGhleSBoYXZlIHNwZWNpYWwgbWVhbmluZ1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gY29uZmlnKSB7XG5cdCAgICAgIGlmIChrZXkuc3Vic3RyKDAsIDEpICE9IFwiJFwiKSB0aGlzLl9zY2hlbWVba2V5XSA9IGNvbmZpZ1trZXldO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgaW1wb3J0RGF0YTogZnVuY3Rpb24gKHRhcmdldCwgc2lsZW50KSB7XG5cdCAgICB2YXIgZGF0YSA9IHRhcmdldCA/IHRhcmdldC5kYXRhIHx8IHRhcmdldCA6IFtdO1xuXHQgICAgdGhpcy5fZmlsdGVyX29yZGVyID0gbnVsbDtcblxuXHQgICAgaWYgKHR5cGVvZiBkYXRhLnNlcmlhbGl6ZSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgdGhpcy5vcmRlciA9IHRvQXJyYXkoW10uY29uY2F0KGRhdGEub3JkZXIpKTsgLy9tYWtlIGZ1bGwgY29weSwgdG8gcHJlc2VydmUgb2JqZWN0IHByb3BlcnRpZXNcblx0ICAgICAgLy9bV0UtQ0FOLURPLUJFVFRFUl1cblxuXHQgICAgICBpZiAodGhpcy5fbWFrZV9mdWxsX2NvcHkpIHtcblx0ICAgICAgICB0aGlzLl9tYWtlX2Z1bGxfY29weSA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBvbGRwdWxsID0gdGhpcy5wdWxsO1xuXHQgICAgICAgIHRoaXMucHVsbCA9IHt9O1xuXG5cdCAgICAgICAgZm9yICh2YXIgX2tleSBpbiBkYXRhLnB1bGwpIHtcblx0ICAgICAgICAgIHZhciBvbGQgPSBvbGRwdWxsW19rZXldO1xuXHQgICAgICAgICAgdGhpcy5wdWxsW19rZXldID0gY29weShkYXRhLnB1bGxbX2tleV0pO1xuXHQgICAgICAgICAgaWYgKG9sZCAmJiBvbGQub3BlbikgdGhpcy5wdWxsW19rZXldLm9wZW4gPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHRoaXMucHVsbCA9IGRhdGEucHVsbDtcblxuXHQgICAgICBpZiAoZGF0YS5icmFuY2ggJiYgdGhpcy5icmFuY2gpIHtcblx0ICAgICAgICB0aGlzLmJyYW5jaCA9IGNvcHkoZGF0YS5icmFuY2gpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcl9icmFuY2ggPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLm9yZGVyID0gdG9BcnJheSgpO1xuXHQgICAgICB0aGlzLnB1bGwgPSB7fTtcblx0ICAgICAgdmFyIGlkLCBvYmo7XG5cdCAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIGZvciAodmFyIF9rZXkyID0gMDsgX2tleTIgPCB0YXJnZXQubGVuZ3RoOyBfa2V5MisrKSB7XG5cdCAgICAgICAgb2JqID0gaWQgPSB0YXJnZXRbX2tleTJdO1xuXHQgICAgICAgIGlmIChfdHlwZW9mKG9iaikgPT0gXCJvYmplY3RcIikgb2JqLmlkID0gb2JqLmlkIHx8IHVpZCgpO2Vsc2Ugb2JqID0ge1xuXHQgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgdmFsdWU6IGlkXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLm9yZGVyLnB1c2gob2JqLmlkKTtcblx0ICAgICAgICBpZiAodGhpcy5fc2NoZW1lX2luaXQpIHRoaXMuX3NjaGVtZV9pbml0KG9iaik7XG5cdCAgICAgICAgdGhpcy5wdWxsW29iai5pZF0gPSBvYmo7XG5cdCAgICAgIH0gZWxzZSBmb3IgKHZhciBfa2V5MyBpbiBkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5vcmRlci5wdXNoKF9rZXkzKTtcblx0ICAgICAgICB0aGlzLnB1bGxbX2tleTNdID0ge1xuXHQgICAgICAgICAgaWQ6IF9rZXkzLFxuXHQgICAgICAgICAgdmFsdWU6IGRhdGFbX2tleTNdXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fZXh0cmFQYXJzZXIgJiYgIWRhdGEuYnJhbmNoKSB7XG5cdCAgICAgIHRoaXMuYnJhbmNoID0ge1xuXHQgICAgICAgIDA6IFtdXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICghdGhpcy5fZGF0YWRyaXZlcl9jaGlsZCkgdGhpcy5fc2V0X2NoaWxkX3NjaGVtZShcImRhdGFcIik7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHRoaXMub3JkZXJbaV07XG5cblx0ICAgICAgICB0aGlzLl9leHRyYVBhcnNlcih0aGlzLnB1bGxba2V5XSwgMCwgMCwgZmFsc2UpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZUxvYWRcIiwgW10pO1xuXHQgICAgaWYgKCFzaWxlbnQpIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW10pO1xuXHQgIH0sXG5cdCAgc3luYzogZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCBzaWxlbnQpIHtcblx0ICAgIHRoaXMudW5zeW5jKCk7XG5cblx0ICAgIHZhciB0eXBlID0gX3R5cGVvZihzb3VyY2UpO1xuXG5cdCAgICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSBzb3VyY2UgPSAkJChzb3VyY2UpO1xuXG5cdCAgICBpZiAodHlwZSAhPSBcImZ1bmN0aW9uXCIgJiYgdHlwZSAhPSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIHNpbGVudCA9IGZpbHRlcjtcblx0ICAgICAgZmlsdGVyID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHNvdXJjZS5uYW1lICE9IFwiRGF0YVN0b3JlXCIpIHtcblx0ICAgICAgaWYgKHNvdXJjZS5kYXRhICYmIChzb3VyY2UuZGF0YS5uYW1lID09PSBcIkRhdGFTdG9yZVwiIHx8IHNvdXJjZS5kYXRhLm5hbWUgPT09IFwiVHJlZVN0b3JlXCIpKSBzb3VyY2UgPSBzb3VyY2UuZGF0YTtlbHNlIHtcblx0ICAgICAgICB0aGlzLl9zeW5jX3NvdXJjZSA9IHNvdXJjZTtcblx0ICAgICAgICByZXR1cm4gY2FsbEV2ZW50KFwib25TeW5jVW5rbm93blwiLCBbdGhpcywgc291cmNlLCBmaWx0ZXJdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgc3luY19sb2dpYyA9IGJpbmQoZnVuY3Rpb24gKGlkLCBkYXRhLCBtb2RlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9za2lwX25leHRfc3luYykgcmV0dXJuOyAvL3N5bmMgb2YgdHJlZS1zdHJ1Y3R1cmUgd2l0aCBhZnRlci1maWx0ZXJpbmdcblx0ICAgICAgLy93ZSBuZWVkIHRvIG1ha2UgYSBmdWxsIGNvcHksIHRvIHByZXNlcnZlICRjb3VudFxuXHQgICAgICAvL1tXRS1DQU4tRE8tQkVUVEVSXVxuXG5cdCAgICAgIGlmIChmaWx0ZXIgJiYgdGhpcy5icmFuY2gpIHRoaXMuX21ha2VfZnVsbF9jb3B5ID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5pbXBvcnREYXRhKHNvdXJjZSwgdHJ1ZSk7XG5cdCAgICAgIGlmIChmaWx0ZXIpIHRoaXMuc2lsZW50KGZpbHRlcik7XG5cdCAgICAgIGlmICh0aGlzLl9vbl9zeW5jKSB0aGlzLl9vbl9zeW5jKCk7XG5cdCAgICAgIGlmICghKGlkICYmIGRhdGEgJiYgbW9kZSkpIC8vY2xlYXJhbGxcblx0ICAgICAgICB0aGlzLl9tYXJrcyA9IHt9O1xuXHQgICAgICBpZiAobW9kZSA9PSBcImRlbGV0ZVwiICYmIHRoaXMuX21hcmtzW2lkXSkgZGVsZXRlIHRoaXMuX21hcmtzW2lkXTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN5bmNBcHBseVwiLCBbXSk7XG5cdCAgICAgIGlmICghc2lsZW50KSB0aGlzLnJlZnJlc2goKTtlbHNlIHNpbGVudCA9IGZhbHNlO1xuXHQgICAgfSwgdGhpcyk7XG5cdCAgICB0aGlzLl9zeW5jX2V2ZW50cyA9IFtzb3VyY2UuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBzeW5jX2xvZ2ljKSwgc291cmNlLmF0dGFjaEV2ZW50KFwib25JZENoYW5nZVwiLCBiaW5kKGZ1bmN0aW9uIChvbGQsIG5pZCkge1xuXHQgICAgICB0aGlzLmNoYW5nZUlkKG9sZCwgbmlkKTtcblx0ICAgICAgdGhpcy5yZWZyZXNoKG5pZCk7XG5cdCAgICB9LCB0aGlzKSldO1xuXHQgICAgdGhpcy5fc3luY19zb3VyY2UgPSBzb3VyY2U7IC8vYmFja3dhcmQgZGF0YSBzYXZpbmdcblxuXHQgICAgdGhpcy5fYmFja19zeW5jX2hhbmRsZXIgPSB0aGlzLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgZnVuY3Rpb24gKGlkLCBkYXRhLCBtb2RlKSB7XG5cdCAgICAgIGlmIChtb2RlID09IFwidXBkYXRlXCIgfHwgbW9kZSA9PSBcInNhdmVcIikge1xuXHQgICAgICAgIHRoaXMuX3NraXBfbmV4dF9zeW5jID0gMTtcblx0ICAgICAgICBzb3VyY2UudXBkYXRlSXRlbShpZCwgZGF0YSk7XG5cdCAgICAgICAgdGhpcy5fc2tpcF9uZXh0X3N5bmMgPSAwO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHN5bmNfbG9naWMoKTtcblx0ICB9LFxuXHQgIHVuc3luYzogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3N5bmNfc291cmNlKSB7XG5cdCAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zeW5jX3NvdXJjZTtcblxuXHQgICAgICBpZiAoc291cmNlLm5hbWUgIT0gXCJEYXRhU3RvcmVcIiAmJiAoIXNvdXJjZS5kYXRhIHx8IHNvdXJjZS5kYXRhLm5hbWUgIT0gXCJEYXRhU3RvcmVcIikpIHtcblx0ICAgICAgICAvL2RhdGEgc3luYyB3aXRoIGV4dGVybmFsIGNvbXBvbmVudFxuXHQgICAgICAgIGNhbGxFdmVudChcIm9uVW5TeW5jVW5rbm93blwiLCBbdGhpcywgc291cmNlXSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy9kYXRhIHN5bmMgd2l0aCB3ZWJpeCBjb21wb25lbnRcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N5bmNfZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBzb3VyY2UuZGV0YWNoRXZlbnQodGhpcy5fc3luY19ldmVudHNbaV0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGV0YWNoRXZlbnQodGhpcy5fYmFja19zeW5jX2hhbmRsZXIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fc3luY19zb3VyY2UgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy51bnN5bmMoKTtcblx0ICAgIHRoaXMucHVsbCA9IHRoaXMub3JkZXIgPSB0aGlzLl9tYXJrcyA9IG51bGw7XG5cdCAgICB0aGlzLl9ldnNfZXZlbnRzID0gdGhpcy5fZXZzX2hhbmRsZXJzID0ge307XG5cdCAgfSxcblx0ICAvL2FkZHMgaXRlbSB0byB0aGUgc3RvcmVcblx0ICBhZGQ6IGZ1bmN0aW9uIChvYmosIGluZGV4KSB7XG5cdCAgICAvL2RlZmF1bHQgdmFsdWVzXHRcdFxuXHQgICAgaWYgKHRoaXMuX3NjaGVtZSkgZm9yICh2YXIga2V5IGluIHRoaXMuX3NjaGVtZSkge1xuXHQgICAgICBpZiAoaXNVbmRlZmluZWQob2JqW2tleV0pKSBvYmpba2V5XSA9IHRoaXMuX3NjaGVtZVtrZXldO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX3NjaGVtZV9pbml0KSB0aGlzLl9zY2hlbWVfaW5pdChvYmopOyAvL2dlbmVyYXRlIGlkIGZvciB0aGUgaXRlbVxuXG5cdCAgICB2YXIgaWQgPSB0aGlzLmlkKG9iaik7IC8vaW4gY2FzZSBvZiB0cmVldGFibGUgb3JkZXIgaXMgc2VudCBhcyAzcmQgcGFyYW1ldGVyXG5cblx0ICAgIHZhciBvcmRlciA9IGFyZ3VtZW50c1syXSB8fCB0aGlzLm9yZGVyOyAvL2J5IGRlZmF1bHQgaXRlbSBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cblx0ICAgIHZhciBkYXRhX3NpemUgPSBvcmRlci5sZW5ndGg7XG5cdCAgICBpZiAoaXNVbmRlZmluZWQoaW5kZXgpIHx8IGluZGV4IDwgMCkgaW5kZXggPSBkYXRhX3NpemU7IC8vY2hlY2sgdG8gcHJldmVudCB0b28gYmlnIGluZGV4ZXNcdFx0XHRcblxuXHQgICAgaWYgKGluZGV4ID4gZGF0YV9zaXplKSB7XG5cdCAgICAgIGFzc2VydCgwLCBcIldhcm5pbmdcIiwgXCJEYXRhU3RvcmU6YWRkXCIsIFwiSW5kZXggb2Ygb3V0IG9mIGJvdW5kc1wiKTtcblx0ICAgICAgaW5kZXggPSBNYXRoLm1pbihvcmRlci5sZW5ndGgsIGluZGV4KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVBZGRcIiwgW2lkLCBvYmosIGluZGV4XSkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdCAgICBhc3NlcnQoIXRoaXMuZXhpc3RzKGlkKSwgXCJOb3QgdW5pcXVlIElEXCIpO1xuXHQgICAgdGhpcy5wdWxsW2lkXSA9IG9iajtcblx0ICAgIG9yZGVyLmluc2VydEF0KGlkLCBpbmRleCk7XG5cblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfb3JkZXIpIHtcblx0ICAgICAgLy9hZGRpbmcgZHVyaW5nIGZpbHRlcmluZ1xuXHQgICAgICAvL3dlIGNhbid0IGtub3cgdGhlIGxvY2F0aW9uIG9mIG5ldyBpdGVtIGluIGZ1bGwgZGF0YXNldCwgbWFraW5nIHN1Z2dlc3Rpb25cblx0ICAgICAgLy9wdXQgYXQgZW5kIG9mIG9yaWdpbmFsIGRhdGFzZXQgYnkgZGVmYXVsdFxuXHQgICAgICB2YXIgb3JpZ2luYWxfaW5kZXggPSB0aGlzLl9maWx0ZXJfb3JkZXIubGVuZ3RoOyAvL2lmIHNvbWUgZGF0YSBleGlzdHMsIHB1dCBhdCB0aGUgc2FtZSBwb3NpdGlvbiBpbiBvcmlnaW5hbCBhbmQgZmlsdGVyZWQgbGlzdHNcblxuXHQgICAgICBpZiAodGhpcy5vcmRlci5sZW5ndGgpIG9yaWdpbmFsX2luZGV4ID0gTWF0aC5taW4oaW5kZXggfHwgMCwgb3JpZ2luYWxfaW5kZXgpO1xuXG5cdCAgICAgIHRoaXMuX2ZpbHRlcl9vcmRlci5pbnNlcnRBdChpZCwgb3JpZ2luYWxfaW5kZXgpO1xuXHQgICAgfSAvL3JlcGFpbnQgc2lnbmFsXG5cblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbaWQsIG9iaiwgXCJhZGRcIl0pO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyQWRkXCIsIFtpZCwgaW5kZXhdKTtcblx0ICAgIHJldHVybiBvYmouaWQ7XG5cdCAgfSxcblx0ICAvL3JlbW92ZXMgZWxlbWVudCBmcm9tIGRhdGFzdG9yZVxuXHQgIHJlbW92ZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAvL2lkIGNhbiBiZSBhbiBhcnJheSBvZiBJRHMgLSByZXN1bHQgb2YgZ2V0U2VsZWN0LCBmb3IgZXhhbXBsZVxuXHQgICAgaWYgKGlzQXJyYXkoaWQpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZShpZFtpXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlRGVsZXRlXCIsIFtpZF0pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgYXNzZXJ0KHRoaXMuZXhpc3RzKGlkKSwgXCJOb3QgZXhpc3RpbmcgSUQgaW4gcmVtb3ZlIGNvbW1hbmRcIiArIGlkKTtcblx0ICAgIHZhciBvYmogPSB0aGlzLmdldEl0ZW0oaWQpOyAvL3NhdmUgZm9yIGxhdGVyIGV2ZW50XG5cdCAgICAvL2NsZWFyIGZyb20gY29sbGVjdGlvbnNcblxuXHQgICAgdGhpcy5vcmRlci5yZW1vdmUoaWQpO1xuXHQgICAgaWYgKHRoaXMuX2ZpbHRlcl9vcmRlcikgdGhpcy5fZmlsdGVyX29yZGVyLnJlbW92ZShpZCk7XG5cdCAgICBkZWxldGUgdGhpcy5wdWxsW2lkXTtcblx0ICAgIGlmICh0aGlzLl9tYXJrc1tpZF0pIGRlbGV0ZSB0aGlzLl9tYXJrc1tpZF07IC8vcmVwYWludCBzaWduYWxcblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbaWQsIG9iaiwgXCJkZWxldGVcIl0pO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRGVsZXRlXCIsIFtpZF0pO1xuXHQgIH0sXG5cdCAgLy9kZWxldGVzIGFsbCByZWNvcmRzIGluIGRhdGFzdG9yZVxuXHQgIGNsZWFyQWxsOiBmdW5jdGlvbiAoc29mdCkge1xuXHQgICAgLy9pbnN0ZWFkIG9mIGRlbGV0aW5nIG9uZSBieSBvbmUgLSBqdXN0IHJlc2V0IGlubmVyIGNvbGxlY3Rpb25zXG5cdCAgICB0aGlzLnB1bGwgPSB7fTtcblx0ICAgIHRoaXMuX21hcmtzID0ge307XG5cdCAgICB0aGlzLm9yZGVyID0gdG9BcnJheSgpOyAvL3RoaXMuZmVlZCA9IG51bGw7XG5cblx0ICAgIHRoaXMuX2ZpbHRlcl9vcmRlciA9IG51bGw7XG5cdCAgICBpZiAoIXNvZnQpIHRoaXMudXJsID0gbnVsbDtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25DbGVhckFsbFwiLCBbc29mdF0pO1xuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgfSxcblx0ICAvL2NvbnZlcnRzIGlkIHRvIGluZGV4XG5cdCAgZ2V0SWRCeUluZGV4OiBmdW5jdGlvbiAoaW5kZXgpIHtcblx0ICAgIGFzc2VydChpbmRleCA+PSAwLCBcIkRhdGFTdG9yZTo6Z2V0SWRCeUluZGV4IEluY29ycmVjdCBpbmRleFwiKTtcblx0ICAgIHJldHVybiB0aGlzLm9yZGVyW2luZGV4XTtcblx0ICB9LFxuXHQgIC8vY29udmVydHMgaW5kZXggdG8gaWRcblx0ICBnZXRJbmRleEJ5SWQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKCF0aGlzLnB1bGxbaWRdKSByZXR1cm4gLTE7ZWxzZSByZXR1cm4gdGhpcy5vcmRlci5maW5kKGlkKTsgLy9zbG93ZXIgdGhhbiBnZXRJZEJ5SW5kZXhcblx0ICB9LFxuXHQgIC8vcmV0dXJucyBJRCBvZiBuZXh0IGVsZW1lbnRcblx0ICBnZXROZXh0SWQ6IGZ1bmN0aW9uIChpZCwgc3RlcCkge1xuXHQgICAgcmV0dXJuIHRoaXMub3JkZXJbdGhpcy5nZXRJbmRleEJ5SWQoaWQpICsgKHN0ZXAgfHwgMSldO1xuXHQgIH0sXG5cdCAgLy9yZXR1cm5zIElEIG9mIGZpcnN0IGVsZW1lbnRcblx0ICBnZXRGaXJzdElkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vcmRlclswXTtcblx0ICB9LFxuXHQgIC8vcmV0dXJucyBJRCBvZiBsYXN0IGVsZW1lbnRcblx0ICBnZXRMYXN0SWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLm9yZGVyW3RoaXMub3JkZXIubGVuZ3RoIC0gMV07XG5cdCAgfSxcblx0ICAvL3JldHVybnMgSUQgb2YgcHJldmlvdXMgZWxlbWVudFxuXHQgIGdldFByZXZJZDogZnVuY3Rpb24gKGlkLCBzdGVwKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vcmRlclt0aGlzLmdldEluZGV4QnlJZChpZCkgLSAoc3RlcCB8fCAxKV07XG5cdCAgfSxcblxuXHQgIC8qXG5cdCAgXHRzb3J0IGRhdGEgaW4gY29sbGVjdGlvblxuXHQgIFx0XHRieSAtIHNldHRpbmdzIG9mIHNvcnRpbmdcblx0ICBcdFxuXHQgIFx0b3Jcblx0ICBcdFxuXHQgIFx0XHRieSAtIHNvcnRpbmcgZnVuY3Rpb25cblx0ICBcdFx0ZGlyIC0gXCJhc2NcIiBvciBcImRlc2NcIlxuXHQgIFx0XHRcblx0ICBcdG9yXG5cdCAgXHRcblx0ICBcdFx0YnkgLSBwcm9wZXJ0eVxuXHQgIFx0XHRkaXIgLSBcImFzY1wiIG9yIFwiZGVzY1wiXG5cdCAgXHRcdGFzIC0gdHlwZSBvZiBzb3J0aW5nc1xuXHQgIFx0XG5cdCAgXHRTb3J0aW5nIGZ1bmN0aW9uIHdpbGwgYWNjZXB0IDIgcGFyYW1ldGVycyBhbmQgbXVzdCByZXR1cm4gMSwwLC0xLCBiYXNlZCBvbiBkZXNpcmVkIG9yZGVyXG5cdCAgKi9cblx0ICBzb3J0OiBmdW5jdGlvbiAoYnksIGRpciwgYXMpIHtcblx0ICAgIHZhciBzb3J0ID0gYnk7XG5cdCAgICBpZiAodHlwZW9mIGJ5ID09IFwiZnVuY3Rpb25cIikgc29ydCA9IHtcblx0ICAgICAgYXM6IGJ5LFxuXHQgICAgICBkaXI6IGRpclxuXHQgICAgfTtlbHNlIGlmICh0eXBlb2YgYnkgPT0gXCJzdHJpbmdcIikgc29ydCA9IHtcblx0ICAgICAgYnk6IGJ5LnJlcGxhY2UoLyMvZywgXCJcIiksXG5cdCAgICAgIGRpcjogZGlyLFxuXHQgICAgICBhczogYXNcblx0ICAgIH07XG5cdCAgICB2YXIgcGFyYW1ldGVycyA9IFtzb3J0LmJ5LCBzb3J0LmRpciwgc29ydC5hcywgc29ydF07XG5cdCAgICBpZiAoIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTb3J0XCIsIHBhcmFtZXRlcnMpKSByZXR1cm47XG5cdCAgICB0aGlzLm9yZGVyID0gdGhpcy5fc29ydF9jb3JlKHNvcnQsIHRoaXMub3JkZXIpO1xuXHQgICAgaWYgKHRoaXMuX2ZpbHRlcl9vcmRlciAmJiB0aGlzLl9maWx0ZXJfb3JkZXIubGVuZ3RoICE9IHRoaXMub3JkZXIubGVuZ3RoKSB0aGlzLl9maWx0ZXJfb3JkZXIgPSB0aGlzLl9zb3J0X2NvcmUoc29ydCwgdGhpcy5fZmlsdGVyX29yZGVyKTsgLy9yZXBhaW50IHNlbGZcblxuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJTb3J0XCIsIHBhcmFtZXRlcnMpO1xuXHQgIH0sXG5cdCAgX3NvcnRfY29yZTogZnVuY3Rpb24gKHNvcnQsIG9yZGVyKSB7XG5cdCAgICB2YXIgc29ydGVyID0gdGhpcy5zb3J0aW5nLmNyZWF0ZShzb3J0KTtcblxuXHQgICAgaWYgKHRoaXMub3JkZXIubGVuZ3RoKSB7XG5cdCAgICAgIHZhciBwcmUgPSBvcmRlci5zcGxpY2UoMCwgdGhpcy4kZnJlZXplKTsgLy9nZXQgYXJyYXkgb2YgSURzXG5cblx0ICAgICAgdmFyIG5ld29yZGVyID0gdG9BcnJheSgpO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSBvcmRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgIG5ld29yZGVyW2ldID0gdGhpcy5wdWxsW29yZGVyW2ldXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5ld29yZGVyLnNvcnQoc29ydGVyKTtcblx0ICAgICAgcmV0dXJuIHRvQXJyYXkocHJlLmNvbmNhdChuZXdvcmRlci5tYXAoZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIGFzc2VydChvYmosIFwiQ2xpZW50IHNvcnRpbmcgY2FuJ3QgYmUgdXNlZCB3aXRoIGR5bmFtaWMgbG9hZGluZ1wiKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pZChvYmopO1xuXHQgICAgICB9LCB0aGlzKSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3JkZXI7XG5cdCAgfSxcblxuXHQgIC8qXG5cdCAgXHRGaWx0ZXIgZGF0YXNvdXJjZVxuXHQgIFx0XG5cdCAgXHR0ZXh0IC0gcHJvcGVydHksIGJ5IHdoaWNoIGZpbHRlclxuXHQgIFx0dmFsdWUgLSBmaWx0ZXIgbWFza1xuXHQgIFx0XG5cdCAgXHRvclxuXHQgIFx0XG5cdCAgXHR0ZXh0ICAtIGZpbHRlciBtZXRob2Rcblx0ICBcdFxuXHQgIFx0RmlsdGVyIG1ldGhvZCB3aWxsIHJlY2VpdmUgZGF0YSBvYmplY3QgYW5kIG11c3QgcmV0dXJuIHRydWUgb3IgZmFsc2Vcblx0ICAqL1xuXHQgIF9maWx0ZXJfcmVzZXQ6IGZ1bmN0aW9uIChwcmVzZXJ2ZSkge1xuXHQgICAgLy9yZW1vdmUgcHJldmlvdXMgZmlsdGVyaW5nICwgaWYgYW55XG5cdCAgICBpZiAodGhpcy5fZmlsdGVyX29yZGVyICYmICFwcmVzZXJ2ZSkge1xuXHQgICAgICB0aGlzLm9yZGVyID0gdGhpcy5fZmlsdGVyX29yZGVyO1xuXHQgICAgICBkZWxldGUgdGhpcy5fZmlsdGVyX29yZGVyO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2ZpbHRlcl9jb3JlOiBmdW5jdGlvbiAoZmlsdGVyLCB2YWx1ZSwgcHJlc2VydmUpIHtcblx0ICAgIHZhciBuZXdvcmRlciA9IHRvQXJyYXkoKTtcblx0ICAgIHZhciBmcmVlemUgPSB0aGlzLiRmcmVlemUgfHwgMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpZCA9IHRoaXMub3JkZXJbaV07XG5cdCAgICAgIGlmIChpIDwgZnJlZXplIHx8IGZpbHRlcih0aGlzLmdldEl0ZW0oaWQpLCB2YWx1ZSkpIG5ld29yZGVyLnB1c2goaWQpO1xuXHQgICAgfSAvL3NldCBuZXcgb3JkZXIgb2YgaXRlbXMsIHN0b3JlIG9yaWdpbmFsXG5cblxuXHQgICAgaWYgKCFwcmVzZXJ2ZSB8fCAhdGhpcy5fZmlsdGVyX29yZGVyKSB0aGlzLl9maWx0ZXJfb3JkZXIgPSB0aGlzLm9yZGVyO1xuXHQgICAgdGhpcy5vcmRlciA9IG5ld29yZGVyO1xuXHQgIH0sXG5cdCAgZmluZDogZnVuY3Rpb24gKGNvbmZpZywgZmlyc3QpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSBpbiB0aGlzLnB1bGwpIHtcblx0ICAgICAgdmFyIGRhdGEgPSB0aGlzLnB1bGxbaV07XG5cdCAgICAgIHZhciBtYXRjaCA9IHRydWU7XG5cblx0ICAgICAgaWYgKF90eXBlb2YoY29uZmlnKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbmZpZykge1xuXHQgICAgICAgICAgaWYgKGRhdGFba2V5XSAhPSBjb25maWdba2V5XSkge1xuXHQgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZyhkYXRhKSkgbWF0Y2ggPSBmYWxzZTtcblxuXHQgICAgICBpZiAobWF0Y2gpIHJlc3VsdC5wdXNoKGRhdGEpO1xuXHQgICAgICBpZiAoZmlyc3QgJiYgcmVzdWx0Lmxlbmd0aCkgcmV0dXJuIHJlc3VsdFswXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZpcnN0ID8gbnVsbCA6IHJlc3VsdDtcblx0ICB9LFxuXHQgIGZpbHRlcjogZnVuY3Rpb24gKHRleHQsIHZhbHVlLCBwcmVzZXJ2ZSkge1xuXHQgICAgLy91bmZpbHRlciBjYWxsIGJ1dCB3ZSBhbHJlYWR5IGluIG5vdC1maWx0ZXJlZCBzdGF0ZVxuXHQgICAgaWYgKCF0ZXh0ICYmICF0aGlzLl9maWx0ZXJfb3JkZXIgJiYgIXRoaXMuX2ZpbHRlcl9icmFuY2gpIHJldHVybjtcblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUZpbHRlclwiLCBbdGV4dCwgdmFsdWVdKSkgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9maWx0ZXJfcmVzZXQocHJlc2VydmUpO1xuXG5cdCAgICBpZiAoIXRoaXMub3JkZXIubGVuZ3RoKSByZXR1cm47IC8vaWYgdGV4dCBub3QgZGVmaW5lIC1qdXN0IHVuZmlsdGVyIHByZXZpb3VzIHN0YXRlIGFuZCBleGl0XG5cblx0ICAgIGlmICh0ZXh0KSB7XG5cdCAgICAgIHZhciBmaWx0ZXIgPSB0ZXh0O1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlIHx8IFwiXCI7XG5cblx0ICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8jL2csIFwiXCIpO1xuXHQgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICByZXR1cm4gdmFsdWUob2JqW3RleHRdKTtcblx0ICAgICAgICB9O2Vsc2Uge1xuXHQgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uIChvYmosIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIC8vZGVmYXVsdCBmaWx0ZXIgLSBzdHJpbmcgc3RhcnQgZnJvbSwgY2FzZSBpbi1zZW5zaXRpdmVcblx0ICAgICAgICAgICAgYXNzZXJ0KG9iaiwgXCJDbGllbnQgc2lkZSBmaWx0ZXJpbmcgY2FuJ3QgYmUgdXNlZCB3aXRoIGR5bmFtaWMgbG9hZGluZ1wiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIChvYmpbdGV4dF0gfHwgXCJcIikudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUpICE9IC0xO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9maWx0ZXJfY29yZShmaWx0ZXIsIHZhbHVlLCBwcmVzZXJ2ZSwgdGhpcy5fZmlsdGVyTW9kZSk7XG5cdCAgICB9IC8vcmVwYWludCBzZWxmXG5cblxuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJGaWx0ZXJcIiwgW10pO1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0SXRlcmF0ZSB0aHJvdWdoIGNvbGxlY3Rpb25cblx0ICAqL1xuXHQgIF9vYmpfYXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBkYXRhID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLm9yZGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIGRhdGFbaV0gPSB0aGlzLnB1bGxbdGhpcy5vcmRlcltpXV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgZWFjaDogZnVuY3Rpb24gKG1ldGhvZCwgbWFzdGVyLCBhbGwpIHtcblx0ICAgIHZhciBvcmRlciA9IHRoaXMub3JkZXI7XG5cdCAgICBpZiAoYWxsKSBvcmRlciA9IHRoaXMuX2ZpbHRlcl9vcmRlciB8fCBvcmRlcjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAob3JkZXJbaV0pIG1ldGhvZC5jYWxsKG1hc3RlciB8fCB0aGlzLCB0aGlzLmdldEl0ZW0ob3JkZXJbaV0pLCBpKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9tZXRob2RQdXNoOiBmdW5jdGlvbiAob2JqZWN0LCBtZXRob2QpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBvYmplY3RbbWV0aG9kXS5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0bWFwIGlubmVyIG1ldGhvZHMgdG8gc29tZSBkaXN0YW50IG9iamVjdFxuXHQgICovXG5cdCAgcHJvdmlkZUFwaTogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRhYmxlKSB7XG5cdCAgICBpZiAoZXZlbnRhYmxlKSB7XG5cdCAgICAgIHRoaXMubWFwRXZlbnQoe1xuXHQgICAgICAgIG9uYmVmb3Jlc29ydDogdGFyZ2V0LFxuXHQgICAgICAgIG9uYWZ0ZXJzb3J0OiB0YXJnZXQsXG5cdCAgICAgICAgb25iZWZvcmVhZGQ6IHRhcmdldCxcblx0ICAgICAgICBvbmFmdGVyYWRkOiB0YXJnZXQsXG5cdCAgICAgICAgb25iZWZvcmVkZWxldGU6IHRhcmdldCxcblx0ICAgICAgICBvbmFmdGVyZGVsZXRlOiB0YXJnZXQsXG5cdCAgICAgICAgb25kYXRhdXBkYXRlOiB0YXJnZXRcblx0ICAgICAgICAvKixcblx0ICAgICAgICBvbmFmdGVyZmlsdGVyOlx0dGFyZ2V0LFxuXHQgICAgICAgIG9uYmVmb3JlZmlsdGVyOlx0dGFyZ2V0Ki9cblxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGxpc3QgPSBbXCJzb3J0XCIsIFwiYWRkXCIsIFwicmVtb3ZlXCIsIFwiZXhpc3RzXCIsIFwiZ2V0SWRCeUluZGV4XCIsIFwiZ2V0SW5kZXhCeUlkXCIsIFwiZ2V0SXRlbVwiLCBcInVwZGF0ZUl0ZW1cIiwgXCJyZWZyZXNoXCIsIFwiY291bnRcIiwgXCJmaWx0ZXJcIiwgXCJmaW5kXCIsIFwiZ2V0TmV4dElkXCIsIFwiZ2V0UHJldklkXCIsIFwiY2xlYXJBbGxcIiwgXCJnZXRGaXJzdElkXCIsIFwiZ2V0TGFzdElkXCIsIFwic2VyaWFsaXplXCIsIFwic3luY1wiXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRhcmdldFtsaXN0W2ldXSA9IHRoaXMuX21ldGhvZFB1c2godGhpcywgbGlzdFtpXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBhZGRNYXJrOiBmdW5jdGlvbiAoaWQsIG1hcmssIGNzcywgdmFsdWUsIHNpbGVudCkge1xuXHQgICAgdmFyIG9iaiA9IHRoaXMuX21hcmtzW2lkXSB8fCB7fTtcblx0ICAgIHRoaXMuX21hcmtzW2lkXSA9IG9iajtcblxuXHQgICAgaWYgKCFvYmpbbWFya10pIHtcblx0ICAgICAgb2JqW21hcmtdID0gdmFsdWUgfHwgdHJ1ZTtcblxuXHQgICAgICBpZiAoY3NzKSB7XG5cdCAgICAgICAgdmFyIG9sZF9jc3MgPSBvYmouJGNzcyB8fCBcIlwiO1xuXHQgICAgICAgIG9iai4kY3NzID0gb2xkX2NzcyArIFwiIFwiICsgbWFyaztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghc2lsZW50KSB0aGlzLnJlZnJlc2goaWQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqW21hcmtdO1xuXHQgIH0sXG5cdCAgcmVtb3ZlTWFyazogZnVuY3Rpb24gKGlkLCBtYXJrLCBjc3MsIHNpbGVudCkge1xuXHQgICAgdmFyIG9iaiA9IHRoaXMuX21hcmtzW2lkXTtcblxuXHQgICAgaWYgKG9iaikge1xuXHQgICAgICBpZiAob2JqW21hcmtdKSBkZWxldGUgb2JqW21hcmtdO1xuXG5cdCAgICAgIGlmIChjc3MpIHtcblx0ICAgICAgICB2YXIgY3VycmVudF9jc3MgPSBvYmouJGNzcztcblxuXHQgICAgICAgIGlmIChjdXJyZW50X2Nzcykge1xuXHQgICAgICAgICAgb2JqLiRjc3MgPSBjdXJyZW50X2Nzcy5yZXBsYWNlKG1hcmssIFwiXCIpLnJlcGxhY2UoXCIgIFwiLCBcIiBcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFzaWxlbnQpIHRoaXMucmVmcmVzaChpZCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRNYXJrOiBmdW5jdGlvbiAoaWQsIG1hcmspIHtcblx0ICAgIHZhciBvYmogPSB0aGlzLl9tYXJrc1tpZF07XG5cdCAgICByZXR1cm4gb2JqID8gb2JqW21hcmtdIDogZmFsc2U7XG5cdCAgfSxcblx0ICBjbGVhck1hcms6IGZ1bmN0aW9uIChuYW1lLCBjc3MsIHNpbGVudCkge1xuXHQgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFya3MpIHtcblx0ICAgICAgdmFyIG9iaiA9IHRoaXMuX21hcmtzW2lkXTtcblxuXHQgICAgICBpZiAob2JqW25hbWVdKSB7XG5cdCAgICAgICAgZGVsZXRlIG9ialtuYW1lXTtcblx0ICAgICAgICBpZiAoY3NzICYmIG9iai4kY3NzKSBvYmouJGNzcyA9IG9iai4kY3NzLnJlcGxhY2UobmFtZSwgXCJcIikucmVwbGFjZShcIiAgXCIsIFwiIFwiKTtcblx0ICAgICAgICBpZiAoIXNpbGVudCkgdGhpcy5yZWZyZXNoKGlkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0c2VyaWFsaXplcyBkYXRhIHRvIGEganNvbiBvYmplY3Rcblx0ICAqL1xuXHQgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKGFsbCkge1xuXHQgICAgdmFyIGlkcyA9IHRoaXMub3JkZXI7XG5cdCAgICBpZiAoYWxsICYmIHRoaXMuX2ZpbHRlcl9vcmRlcikgaWRzID0gdGhpcy5fZmlsdGVyX29yZGVyO1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZWwgPSB0aGlzLnB1bGxbaWRzW2ldXTtcblxuXHQgICAgICBpZiAodGhpcy5fc2NoZW1lX3NlcmlhbGl6ZSkge1xuXHQgICAgICAgIGVsID0gdGhpcy5fc2NoZW1lX3NlcmlhbGl6ZShlbCk7XG5cdCAgICAgICAgaWYgKGVsID09PSBmYWxzZSkgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXN1bHQucHVzaChlbCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBzb3J0aW5nOiB7XG5cdCAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2Rpcihjb25maWcuZGlyLCB0aGlzLl9ieShjb25maWcuYnksIGNvbmZpZy5hcykpO1xuXHQgICAgfSxcblx0ICAgIGFzOiB7XG5cdCAgICAgIC8vaGFuZGxlZCBieSBkYXRhRmVlZFxuXHQgICAgICBcInNlcnZlclwiOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9LFxuXHQgICAgICBcImRhdGVcIjogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICBhID0gYSAtIDA7XG5cdCAgICAgICAgYiA9IGIgLSAwO1xuXHQgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICAgICAgfSxcblx0ICAgICAgXCJpbnRcIjogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICBhID0gYSAqIDE7XG5cdCAgICAgICAgYiA9IGIgKiAxO1xuXHQgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICAgICAgfSxcblx0ICAgICAgXCJzdHJpbmdfc3RyaWN0XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgYSA9IGEudG9TdHJpbmcoKTtcblx0ICAgICAgICBiID0gYi50b1N0cmluZygpO1xuXHQgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICAgICAgfSxcblx0ICAgICAgXCJzdHJpbmdcIjogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICBpZiAoIWIpIHJldHVybiAxO1xuXHQgICAgICAgIGlmICghYSkgcmV0dXJuIC0xO1xuXHQgICAgICAgIGEgPSBhLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBiID0gYi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuXHQgICAgICB9LFxuXHQgICAgICBcInJhd1wiOiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIF9ieTogZnVuY3Rpb24gKHByb3AsIG1ldGhvZCkge1xuXHQgICAgICBpZiAoIXByb3ApIHJldHVybiBtZXRob2Q7XG5cdCAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9IFwiZnVuY3Rpb25cIikgbWV0aG9kID0gdGhpcy5hc1ttZXRob2QgfHwgXCJzdHJpbmdcIl07XG5cdCAgICAgIGFzc2VydChtZXRob2QsIFwiSW52YWxpZCBzb3J0aW5nIG1ldGhvZFwiKTtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIG1ldGhvZChhW3Byb3BdLCBiW3Byb3BdKTtcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBfZGlyOiBmdW5jdGlvbiAocHJvcCwgbWV0aG9kKSB7XG5cdCAgICAgIGlmIChwcm9wID09IFwiYXNjXCIgfHwgIXByb3ApIHJldHVybiBtZXRob2Q7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBtZXRob2QoYSwgYikgKiAtMTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0Lypcblx0XHRCZWhhdmlvcjpEYXRhTG9hZGVyIC0gbG9hZCBkYXRhIGluIHRoZSBjb21wb25lbnRcblx0XHRcblx0XHRAZXhwb3J0XG5cdFx0XHRsb2FkXG5cdFx0XHRwYXJzZVxuXHQqL1xuXG5cdHZhciBEYXRhTG9hZGVyID0gZXhwb3J0cy5wcm90byh7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIC8vcHJlcGFyZSBkYXRhIHN0b3JlXG5cdCAgICBjb25maWcgPSBjb25maWcgfHwgXCJcIjsgLy9saXN0IG9mIGFsbCBhY3RpdmUgYWpheCByZXF1ZXN0c1xuXG5cdCAgICB0aGlzLl9hamF4X3F1ZXVlID0gdG9BcnJheSgpO1xuXHQgICAgdGhpcy5fZmVlZF9sYXN0ID0ge307XG5cdCAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVN0b3JlKCk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGJpbmQodGhpcy5fY2FsbF9vbmNsZWFyYWxsLCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblNlcnZlckNvbmZpZ1wiLCBiaW5kKHRoaXMuX2NhbGxfb25fY29uZmlnLCB0aGlzKSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25EZXN0cnVjdFwiLCB0aGlzLl9jYWxsX29uY2xlYXJhbGwpO1xuXHQgICAgdGhpcy5kYXRhLmZlZWQgPSB0aGlzLl9mZWVkO1xuXHQgICAgdGhpcy5kYXRhLm93bmVyID0gY29uZmlnLmlkO1xuXHQgIH0sXG5cdCAgX2ZlZWQ6IGZ1bmN0aW9uIChmcm9tLCBjb3VudCwgY2FsbGJhY2spIHtcblx0ICAgIC8vYWxsb3cgb25seSBzaW5nbGUgcmVxdWVzdCBhdCBzYW1lIHRpbWVcblx0ICAgIGlmICh0aGlzLl9sb2FkX2NvdW50KSByZXR1cm4gdGhpcy5fbG9hZF9jb3VudCA9IFtmcm9tLCBjb3VudCwgY2FsbGJhY2tdOyAvL3NhdmUgbGFzdCBpZ25vcmVkIHJlcXVlc3Rcblx0ICAgIGVsc2UgdGhpcy5fbG9hZF9jb3VudCA9IHRydWU7XG5cdCAgICB0aGlzLl9mZWVkX2xhc3QuZnJvbSA9IGZyb207XG5cdCAgICB0aGlzLl9mZWVkX2xhc3QuY291bnQgPSBjb3VudDtcblx0ICAgIHJldHVybiB0aGlzLl9mZWVkX2NvbW1vbi5jYWxsKHRoaXMsIGZyb20sIGNvdW50LCBjYWxsYmFjayk7XG5cdCAgfSxcblx0ICBfZmVlZF9jb21tb246IGZ1bmN0aW9uIChmcm9tLCBjb3VudCwgY2FsbGJhY2ssIHVybCwgZGV0YWlscykge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblxuXHQgICAgdmFyIHN0YXRlID0gbnVsbDtcblx0ICAgIHVybCA9IHVybCB8fCB0aGlzLmRhdGEudXJsO1xuXHQgICAgaWYgKGZyb20gPCAwKSBmcm9tID0gMDtcblx0ICAgIGlmICghZGV0YWlscykgZGV0YWlscyA9IHtcblx0ICAgICAgc3RhcnQ6IGZyb20sXG5cdCAgICAgIGNvdW50OiBjb3VudFxuXHQgICAgfTtcblx0ICAgIGlmICh0aGlzLmNvdW50KCkpIGRldGFpbHNbXCJjb250aW51ZVwiXSA9IFwidHJ1ZVwiO1xuXHQgICAgaWYgKHRoaXMuZ2V0U3RhdGUpIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpOyAvLyBwcm94eVxuXG5cdCAgICBpZiAodXJsICYmIHR5cGVvZiB1cmwgIT0gXCJzdHJpbmdcIikge1xuXHQgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICBpZiAoc3RhdGUuc29ydCkgZGV0YWlscy5zb3J0ID0gc3RhdGUuc29ydDtcblx0ICAgICAgICBpZiAoc3RhdGUuZmlsdGVyKSBkZXRhaWxzLmZpbHRlciA9IHN0YXRlLmZpbHRlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0aGlzLmxvYWQodXJsLCAwLCBkZXRhaWxzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgX3RoaXMuX2ZlZWRfY2FsbGJhY2soKTtcblxuXHQgICAgICAgIGlmIChjYWxsYmFjaykgYWpheC4kY2FsbGJhY2soX3RoaXMsIGNhbGxiYWNrLCBkYXRhKTtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBHRVRcblx0ICAgICAgdXJsID0gdXJsICsgKHVybC5pbmRleE9mKFwiP1wiKSA9PSAtMSA/IFwiP1wiIDogXCImXCIpO1xuXHQgICAgICB2YXIgcGFyYW1zID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgZCBpbiBkZXRhaWxzKSB7XG5cdCAgICAgICAgcGFyYW1zLnB1c2goZCArIFwiPVwiICsgZGV0YWlsc1tkXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoc3RhdGUpIHtcblx0ICAgICAgICBpZiAoc3RhdGUuc29ydCkgcGFyYW1zLnB1c2goXCJzb3J0W1wiICsgc3RhdGUuc29ydC5pZCArIFwiXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5zb3J0LmRpcikpO1xuXHQgICAgICAgIGlmIChzdGF0ZS5maWx0ZXIpIGZvciAodmFyIGtleSBpbiBzdGF0ZS5maWx0ZXIpIHtcblx0ICAgICAgICAgIHZhciBmaWx0ZXJWYWx1ZSA9IHN0YXRlLmZpbHRlcltrZXldO1xuXHQgICAgICAgICAgaWYgKF90eXBlb2YoZmlsdGVyVmFsdWUpID09IFwib2JqZWN0XCIpIGZpbHRlclZhbHVlID0gYWpheCgpLnN0cmluZ2lmeShmaWx0ZXJWYWx1ZSk7IC8vc2VydmVyIGRhdGVyYW5nZWZpbHRlclxuXG5cdCAgICAgICAgICBwYXJhbXMucHVzaChcImZpbHRlcltcIiArIGtleSArIFwiXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChmaWx0ZXJWYWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHVybCArPSBwYXJhbXMuam9pbihcIiZcIik7XG5cblx0ICAgICAgaWYgKHRoaXMuX2ZlZWRfbGFzdC51cmwgIT09IHVybCkge1xuXHQgICAgICAgIHRoaXMuX2ZlZWRfbGFzdC51cmwgPSB1cmw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9hZCh1cmwpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgIF90aGlzLl9mZWVkX2NhbGxiYWNrKCk7XG5cblx0ICAgICAgICAgIGlmIChjYWxsYmFjaykgYWpheC4kY2FsbGJhY2soX3RoaXMsIGNhbGxiYWNrLCBkYXRhKTtcblx0ICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2xvYWRfY291bnQgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2ZlZWRfY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vYWZ0ZXIgbG9hZGluZyBjaGVjayBpZiB3ZSBoYXZlIHNvbWUgaWdub3JlZCByZXF1ZXN0c1xuXHQgICAgdmFyIHRlbXAgPSB0aGlzLl9sb2FkX2NvdW50O1xuXHQgICAgdGhpcy5fbG9hZF9jb3VudCA9IGZhbHNlO1xuXHQgICAgaWYgKF90eXBlb2YodGVtcCkgPT0gXCJvYmplY3RcIikgdGhpcy5kYXRhLmZlZWQuYXBwbHkodGhpcywgdGVtcCk7IC8vbG9hZCBsYXN0IGlnbm9yZWQgcmVxdWVzdFxuXHQgIH0sXG5cdCAgLy9sb2FkcyBkYXRhIGZyb20gZXh0ZXJuYWwgVVJMXG5cdCAgbG9hZDogZnVuY3Rpb24gKHVybCkge1xuXHQgICAgdXJsID0gcHJveHkkYS4kcGFyc2UodXJsKTtcblx0ICAgIHZhciBhamF4JCQxID0gQXRvbURhdGFMb2FkZXIubG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvL3ByZXBhcmUgZGF0YSBmZWVkIGZvciBkeW4uIGxvYWRpbmdcblxuXHQgICAgaWYgKCF0aGlzLmRhdGEudXJsKSB0aGlzLmRhdGEudXJsID0gdXJsO1xuXHQgICAgcmV0dXJuIGFqYXgkJDE7XG5cdCAgfSxcblx0ICAvL2xvYWQgbmV4dCBzZXQgb2YgZGF0YSByb3dzXG5cdCAgbG9hZE5leHQ6IGZ1bmN0aW9uIChjb3VudCwgc3RhcnQsIGNhbGxiYWNrLCB1cmwsIG5vdykge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoY29uZmlnLmRhdGF0aHJvdHRsZSAmJiAhbm93KSB7XG5cdCAgICAgIGlmICh0aGlzLl90aHJvdHRsZV9yZXF1ZXN0KSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3Rocm90dGxlX3JlcXVlc3QpO1xuXHQgICAgICB0aGlzLl90aHJvdHRsZV9yZXF1ZXN0ID0gZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMubG9hZE5leHQoY291bnQsIHN0YXJ0LCBjYWxsYmFjaywgdXJsLCB0cnVlKTtcblx0ICAgICAgfSwgdGhpcywgMCwgY29uZmlnLmRhdGF0aHJvdHRsZSk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFzdGFydCAmJiBzdGFydCAhPT0gMCkgc3RhcnQgPSB0aGlzLmNvdW50KCk7XG5cdCAgICBpZiAoIWNvdW50KSBjb3VudCA9IGNvbmZpZy5kYXRhZmV0Y2ggfHwgdGhpcy5jb3VudCgpO1xuXHQgICAgdGhpcy5kYXRhLnVybCA9IHRoaXMuZGF0YS51cmwgfHwgdXJsO1xuXHQgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25EYXRhUmVxdWVzdFwiLCBbc3RhcnQsIGNvdW50LCBjYWxsYmFjaywgdXJsXSkgJiYgdGhpcy5kYXRhLnVybCkgcmV0dXJuIHRoaXMuZGF0YS5mZWVkLmNhbGwodGhpcywgc3RhcnQsIGNvdW50LCBjYWxsYmFjayk7XG5cdCAgfSxcblx0ICBfbWF5YmVfbG9hZGluZ19hbHJlYWR5OiBmdW5jdGlvbiAoY291bnQsIGZyb20pIHtcblx0ICAgIHZhciBsYXN0ID0gdGhpcy5fZmVlZF9sYXN0O1xuXG5cdCAgICBpZiAodGhpcy5fbG9hZF9jb3VudCAmJiBsYXN0LnVybCkge1xuXHQgICAgICBpZiAobGFzdC5mcm9tIDw9IGZyb20gJiYgbGFzdC5jb3VudCArIGxhc3QuZnJvbSA+PSBjb3VudCArIGZyb20pIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICByZW1vdmVNaXNzZWRfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0aGlzLmRhdGEuX3JlbW92ZU1pc3NlZCA9IHZhbHVlO1xuXHQgIH0sXG5cdCAgLy9pbml0IG9mIGRhdGFwcm9jZXNzb3IgZGVsYXllZCBhZnRlciBhbGwgc2V0dGluZ3MgcHJvY2Vzc2luZ1xuXHQgIC8vYmVjYXVzZSBpdCBuZWVkIHRvIGJlIHRoZSBsYXN0IGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG5cdCAgLy90byBnZXQgdmFsaWQgdmFsaWRhdGlvbiBzdGF0ZVxuXHQgIF9pbml0X2RhdGFwcm9jZXNzb3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB1cmwgPSB0aGlzLl9zZXR0aW5ncy5zYXZlO1xuXHQgICAgaWYgKHVybCA9PT0gdHJ1ZSkgdXJsID0gdGhpcy5fc2V0dGluZ3Muc2F2ZSA9IHRoaXMuX3NldHRpbmdzLnVybDtcblx0ICAgIHZhciBvYmogPSB7XG5cdCAgICAgIG1hc3RlcjogdGhpc1xuXHQgICAgfTtcblx0ICAgIGlmICh1cmwgJiYgdXJsLnVybCkgZXhwb3J0cy5leHRlbmQob2JqLCB1cmwpO2Vsc2Ugb2JqLnVybCA9IHVybDtcblx0ICAgIGRwKG9iaik7XG5cdCAgfSxcblx0ICBzYXZlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuJHJlYWR5LnB1c2godGhpcy5faW5pdF9kYXRhcHJvY2Vzc29yKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIHNjaGVtZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5kYXRhLnNjaGVtZSh2YWx1ZSk7XG5cdCAgfSxcblx0ICBkYXRhRmVlZF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSBwcm94eSRhLiRwYXJzZSh2YWx1ZSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUZpbHRlclwiLCBiaW5kKGZ1bmN0aW9uICh0ZXh0LCBmaWx0ZXJ2YWx1ZSkge1xuXHQgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgICAvL2NvbXBsZXggZmlsdGVyaW5nLCBjYW4ndCBiZSByb3V0ZWQgdG8gZGF0YUZlZWRcblx0ICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IC8vd2UgaGF2ZSBkYXRhRmVlZCBhbmQgc29tZSB0ZXh0XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmRhdGFGZWVkICYmICh0ZXh0IHx8IGZpbHRlcnZhbHVlKSkge1xuXHQgICAgICAgIHRleHQgPSB0ZXh0IHx8IFwiaWRcIjtcblx0ICAgICAgICBpZiAoZmlsdGVydmFsdWUgJiYgX3R5cGVvZihmaWx0ZXJ2YWx1ZSkgPT0gXCJvYmplY3RcIikgZmlsdGVydmFsdWUgPSBmaWx0ZXJ2YWx1ZS5pZDtcblx0ICAgICAgICB0aGlzLmNsZWFyQWxsKCk7XG5cdCAgICAgICAgdmFyIHVybCA9IHRoaXMuX3NldHRpbmdzLmRhdGFGZWVkOyAvL3VybCBkYXRhIGZlZWRcblxuXHQgICAgICAgIGlmICh0eXBlb2YgdXJsID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgIHZhciB1cmxkYXRhID0gXCJmaWx0ZXJbXCIgKyB0ZXh0ICsgXCJdPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGZpbHRlcnZhbHVlKTtcblx0ICAgICAgICAgIHRoaXMubG9hZCh1cmwgKyAodXJsLmluZGV4T2YoXCI/XCIpIDwgMCA/IFwiP1wiIDogXCImXCIpICsgdXJsZGF0YSwgdGhpcy5fc2V0dGluZ3MuZGF0YXR5cGUpO1xuXHQgICAgICAgIH0gLy9qcyBkYXRhIGZlZWRcblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHt9O1xuXHQgICAgICAgICAgICBmaWx0ZXJbdGV4dF0gPSBmaWx0ZXJ2YWx1ZTtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHVybCA9PSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgICB1cmwuY2FsbCh0aGlzLCBmaWx0ZXJ2YWx1ZSwgZmlsdGVyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwuJHByb3h5KSB7XG5cdCAgICAgICAgICAgICAgaWYgKHVybC5sb2FkKSB7XG5cdCAgICAgICAgICAgICAgICB1cmwubG9hZCh0aGlzLCB7XG5cdCAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgIF90aGlzMi5fb25Mb2FkKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgX3RoaXMyLl9vbkxvYWRFcnJvcih4KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfY2FsbF9vbnJlYWR5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MucmVhZHkgJiYgIXRoaXMuX3JlYWR5X3dhc191c2VkKSB7XG5cdCAgICAgIHZhciBjb2RlID0gdG9GdW5jdG9yKHRoaXMuX3NldHRpbmdzLnJlYWR5LCB0aGlzLiRzY29wZSk7XG5cdCAgICAgIGlmIChjb2RlKSBkZWxheShjb2RlLCB0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICBpZiAodGhpcy5jYWxsRXZlbnQpIGRlbGF5KHRoaXMuY2FsbEV2ZW50LCB0aGlzLCBbXCJvblJlYWR5XCIsIFtdXSk7XG5cdCAgICAgIHRoaXMuX3JlYWR5X3dhc191c2VkID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jYWxsX29uY2xlYXJhbGw6IGZ1bmN0aW9uIChzb2Z0KSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FqYXhfcXVldWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHhociA9IHRoaXMuX2FqYXhfcXVldWVbaV07IC8vSUU5IGFuZCBJRTggZGVueSBleHRlbmRpbmcgb2YgQWN0aXZlWCB3cmFwcGVyc1xuXG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgeGhyLmFib3J0ZWQgPSB0cnVlO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgX3hocl9hYm9ydGVkLnB1c2goeGhyKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHhoci5hYm9ydCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXNvZnQpIHtcblx0ICAgICAgdGhpcy5fbG9hZF9jb3VudCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9mZWVkX2xhc3QgPSB7fTtcblx0ICAgICAgdGhpcy5fYWpheF9xdWV1ZSA9IHRvQXJyYXkoKTtcblx0ICAgICAgdGhpcy53YWl0RGF0YSA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2FsbF9vbl9jb25maWc6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuX3BhcnNlU2VldGluZ0NvbGwoY29uZmlnKTtcblx0ICB9XG5cdH0sIEF0b21EYXRhTG9hZGVyKTtcblxuXHR2YXIgRGF0YVN0YXRlID0ge1xuXHQgIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29sc19uID0gdGhpcy5jb25maWcuY29sdW1ucy5sZW5ndGg7XG5cdCAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29uZmlnLmNvbHVtbnM7XG5cdCAgICB2YXIgc2V0dGluZ3MgPSB7XG5cdCAgICAgIGlkczogW10sXG5cdCAgICAgIHNpemU6IFtdLFxuXHQgICAgICBzZWxlY3Q6IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKSxcblx0ICAgICAgc2Nyb2xsOiB0aGlzLmdldFNjcm9sbFN0YXRlKClcblx0ICAgIH07XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sc19uOyBpKyspIHtcblx0ICAgICAgdmFyIGNvbCA9IGNvbHVtbnNbaV07XG5cdCAgICAgIHNldHRpbmdzLmlkcy5wdXNoKGNvbC5pZCk7XG5cdCAgICAgIHNldHRpbmdzLnNpemUucHVzaChjb2wuZmlsbHNwYWNlIHx8IGNvbC5hZGp1c3QgPyAtMSA6IGNvbC53aWR0aCk7XG5cdCAgICB9XG5cblx0ICAgIHNldHRpbmdzLm9yZGVyID0gW10uY29uY2F0KHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIubGVuZ3RoID8gdGhpcy5faGlkZGVuX2NvbHVtbl9vcmRlciA6IHNldHRpbmdzLmlkcyk7XG5cblx0ICAgIGlmICh0aGlzLl9sYXN0X3NvcnRlZCkge1xuXHQgICAgICBzZXR0aW5ncy5zb3J0ID0ge1xuXHQgICAgICAgIGlkOiB0aGlzLl9sYXN0X3NvcnRlZCxcblx0ICAgICAgICBkaXI6IHRoaXMuX2xhc3Rfb3JkZXJcblx0ICAgICAgfTtcblx0ICAgIH0gLy90aGlzIG1ldGhvZCB3aWxsIHRyeSB0byBhY2Nlc3MgdGhlIHJlbmRlcmVkIHZhbHVlc1xuXHQgICAgLy9qdXN0IGlnbm9yZSBpdCBpZiBncmlkIGlzIG5vdCByZW5kZXJlZCB5ZXRcblxuXG5cdCAgICBpZiAodGhpcy5fZmlsdGVyX2VsZW1lbnRzICYmIHRoaXMuX2R0YWJsZV9mdWxseV9yZWFkeSkge1xuXHQgICAgICB2YXIgZmlsdGVyID0ge307XG5cdCAgICAgIHZhciBhbnlfZmlsdGVyID0gMDtcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZmlsdGVyX2VsZW1lbnRzKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hpZGRlbl9jb2x1bW5faGFzaFtrZXldKSBjb250aW51ZTtcblx0ICAgICAgICB2YXIgZiA9IHRoaXMuX2ZpbHRlcl9lbGVtZW50c1trZXldO1xuXHQgICAgICAgIGZbMV0udmFsdWUgPSBmaWx0ZXJba2V5XSA9IGZbMl0uZ2V0VmFsdWUoZlswXSk7XG5cdCAgICAgICAgYW55X2ZpbHRlciA9IDE7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoYW55X2ZpbHRlcikgc2V0dGluZ3MuZmlsdGVyID0gZmlsdGVyO1xuXHQgICAgfVxuXG5cdCAgICBzZXR0aW5ncy5oaWRkZW4gPSBbXTtcblxuXHQgICAgZm9yICh2YXIgX2tleSBpbiB0aGlzLl9oaWRkZW5fY29sdW1uX2hhc2gpIHtcblx0ICAgICAgc2V0dGluZ3MuaGlkZGVuLnB1c2goX2tleSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZXR0aW5ncztcblx0ICB9LFxuXHQgIHNldFN0YXRlOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29uZmlnLmNvbHVtbnM7XG5cdCAgICBpZiAoIW9iaikgcmV0dXJuO1xuXHQgICAgdGhpcy5fbGFzdF9zb3J0ZWQgPSBudWxsO1xuXHQgICAgdGhpcy5ibG9ja0V2ZW50KCk7XG5cblx0ICAgIGlmIChvYmoub3JkZXIgJiYgb2JqLm9yZGVyLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLl9oaWRkZW5fY29sdW1uX29yZGVyID0gW10uY29uY2F0KG9iai5vcmRlcik7XG5cdCAgICAgIHRoaXMuX2hpZGRlbl9zcGxpdCA9IFt0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQsIG9iai5vcmRlci5sZW5ndGggLSB0aGlzLl9zZXR0aW5ncy5yaWdodFNwbGl0XTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9iai5oaWRkZW4pIHtcblx0ICAgICAgdmFyIGhpaGFzaCA9IHt9O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmhpZGRlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGhpaGFzaFtvYmouaGlkZGVuW2ldXSA9IHRydWU7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9oaWRkZW5fY29sdW1uX29yZGVyLmxlbmd0aCkgdGhpcy5oaWRlQ29sdW1uKG9iai5oaWRkZW5baV0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIubGVuZ3RoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICB2YXIgaGlrZXkgPSB0aGlzLl9oaWRkZW5fY29sdW1uX29yZGVyW19pXTtcblx0ICAgICAgICAgIGlmICghIWhpaGFzaFtoaWtleV0gPT0gIXRoaXMuX2hpZGRlbl9jb2x1bW5faGFzaFtoaWtleV0pIHRoaXMuaGlkZUNvbHVtbihoaWtleSwge30sIGZhbHNlLCAhIWhpaGFzaFtoaWtleV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLmlkcykge1xuXHQgICAgICB2YXIgcmVvcmRlciA9IGZhbHNlO1xuXHQgICAgICB2YXIgY29scyA9IHRoaXMuY29uZmlnLmNvbHVtbnM7XG5cblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY29scy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgaWYgKGNvbHNbX2kyXS5pZCAhPSBvYmouaWRzW19pMl0pIHJlb3JkZXIgPSB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHJlb3JkZXIpIHtcblx0ICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBvYmouaWRzLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgIGNvbHNbX2kzXSA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKG9iai5pZHNbX2kzXSkgfHwgY29sc1tfaTNdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMucmVmcmVzaENvbHVtbnMoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLnNpemUpIHtcblx0ICAgICAgdmFyIGNvbHNfbiA9IE1hdGgubWluKG9iai5zaXplLmxlbmd0aCwgY29sdW1ucy5sZW5ndGgpO1xuXG5cdCAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNvbHNfbjsgX2k0KyspIHtcblx0ICAgICAgICB2YXIgY29sID0gY29sdW1uc1tfaTRdO1xuXG5cdCAgICAgICAgaWYgKGNvbCAmJiBvYmouc2l6ZVtfaTRdID4gMCAmJiBjb2wud2lkdGggIT0gb2JqLnNpemVbX2k0XSkge1xuXHQgICAgICAgICAgZGVsZXRlIGNvbC5maWxsc3BhY2U7XG5cdCAgICAgICAgICBkZWxldGUgY29sLmFkanVzdDtcblxuXHQgICAgICAgICAgdGhpcy5fc2V0Q29sdW1uV2lkdGgoX2k0LCBvYmouc2l6ZVtfaTRdLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy51bmJsb2NrRXZlbnQoKTtcblx0ICAgIHZhciBzaWxlbnQgPSAhKHRoaXMuX3NldHRpbmdzLmxlZnRTcGxpdCB8fCB0aGlzLl9zZXR0aW5ncy5yaWdodFNwbGl0KTtcblxuXHQgICAgdGhpcy5fdXBkYXRlQ29sc1NpemVTZXR0aW5ncyhzaWxlbnQpO1xuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU3RydWN0dXJlVXBkYXRlXCIsIFtdKTtcblxuXHQgICAgaWYgKG9iai5zb3J0KSB7XG5cdCAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW3RoaXMuZ2V0Q29sdW1uSW5kZXgob2JqLnNvcnQuaWQpXTtcblx0ICAgICAgaWYgKGNvbHVtbikgdGhpcy5fc29ydChvYmouc29ydC5pZCwgb2JqLnNvcnQuZGlyLCBjb2x1bW4uc29ydCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvYmouZmlsdGVyKSB7XG5cdCAgICAgIC8vdGVtcG9yYXJ5IGRpc2FibGUgZmlsdGVyaW5nIFxuXHQgICAgICB2YXIgdGVtcCA9IHRoaXMuZmlsdGVyQnlBbGw7XG5cblx0ICAgICAgdGhpcy5maWx0ZXJCeUFsbCA9IGZ1bmN0aW9uICgpIHt9OyAvL2FwcGx5IGRlZmluZWQgZmlsdGVyc1xuXG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iai5maWx0ZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBvYmouZmlsdGVyW2tleV07XG5cdCAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJfZWxlbWVudHNba2V5XSkgY29udGludWU7XG5cdCAgICAgICAgdmFyIGYgPSB0aGlzLl9maWx0ZXJfZWxlbWVudHNba2V5XTtcblx0ICAgICAgICBmWzJdLnNldFZhbHVlKGZbMF0sIHZhbHVlKTtcblx0ICAgICAgICB2YXIgY29udGVudGlkID0gZlsxXS5jb250ZW50SWQ7XG5cdCAgICAgICAgaWYgKGNvbnRlbnRpZCkgdGhpcy5fYWN0aXZlX2hlYWRlcnNbY29udGVudGlkXS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICB9IC8vcmVtb3ZlIG9sZCBmaWx0ZXJzXG5cblxuXHQgICAgICBmb3IgKHZhciBfa2V5MiBpbiB0aGlzLl9maWx0ZXJfZWxlbWVudHMpIHtcblx0ICAgICAgICBpZiAoIW9iai5maWx0ZXJbX2tleTJdKSB7XG5cdCAgICAgICAgICB2YXIgX2YgPSB0aGlzLl9maWx0ZXJfZWxlbWVudHNbX2tleTJdO1xuXG5cdCAgICAgICAgICBfZlsyXS5zZXRWYWx1ZShfZlswXSwgXCJcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IC8vcmVzdG9yZSBhbmQgYXBwbHkgZmlsdGVyaW5nXG5cblxuXHQgICAgICB0aGlzLmZpbHRlckJ5QWxsID0gdGVtcDtcblx0ICAgICAgdGhpcy5maWx0ZXJCeUFsbCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLnNlbGVjdCAmJiB0aGlzLnNlbGVjdCkge1xuXHQgICAgICB2YXIgc2VsZWN0ID0gb2JqLnNlbGVjdDtcblx0ICAgICAgdGhpcy51bnNlbGVjdCgpO1xuXG5cdCAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNlbGVjdC5sZW5ndGg7IF9pNSsrKSB7XG5cdCAgICAgICAgaWYgKCFzZWxlY3RbX2k1XS5yb3cgfHwgdGhpcy5leGlzdHMoc2VsZWN0W19pNV0ucm93KSkgdGhpcy5fc2VsZWN0KHNlbGVjdFtfaTVdLCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLnNjcm9sbCkgdGhpcy5zY3JvbGxUbyhvYmouc2Nyb2xsLngsIG9iai5zY3JvbGwueSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdFx0QmVoYXZpb3I6RHJhZ0l0ZW0gLSBhZGRzIGFiaWxpdHkgdG8gbW92ZSBpdGVtcyBieSBkbmRcblx0XHRcblx0XHRkbmQgY29udGV4dCBjYW4gaGF2ZSBuZXh0IHByb3BlcnRpZXNcblx0XHRcdGZyb20gLSBzb3VyY2Ugb2JqZWN0XG5cdFx0XHR0byAtIHRhcmdldCBvYmplY3Rcblx0XHRcdHNvdXJjZSAtIGlkIG9mIGRyYWdnZWQgaXRlbShzKVxuXHRcdFx0dGFyZ2V0IC0gaWQgb2YgZHJvcCB0YXJnZXQsIG51bGwgZm9yIGRyb3Agb24gZW1wdHkgc3BhY2Vcblx0XHRcdHN0YXJ0IC0gaWQgZnJvbSB3aGljaCBETkQgd2FzIHN0YXJ0ZWRcblx0Ki9cblxuXHR2YXIgRHJhZ0l0ZW0gPSB7XG5cdCAgLy9oZWxwZXIgLSBkZWZpbmVzIGNvbXBvbmVudCdzIGNvbnRhaW5lciBhcyBhY3RpdmUgem9uZSBmb3IgZHJhZ2dpbmcgYW5kIGZvciBkcm9wcGluZ1xuXHQgIF9pbml0SGFuZGxlcnM6IGZ1bmN0aW9uIChvYmosIHNvdXJjZSwgdGFyZ2V0KSB7XG5cdCAgICBpZiAoIXNvdXJjZSkgRHJhZ0NvbnRyb2wuYWRkRHJvcChvYmouX2NvbnRlbnRvYmosIG9iaiwgdHJ1ZSk7XG5cdCAgICBpZiAoIXRhcmdldCkgRHJhZ0NvbnRyb2wuYWRkRHJhZyhvYmouX2NvbnRlbnRvYmosIG9iaik7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25EcmFnT3V0XCIsIGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgIHRoaXMuJGRyYWdNYXJrKGEsIGIpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVBdXRvU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGNvbnRleHQgPSBEcmFnQ29udHJvbC5nZXRDb250ZXh0KCk7XG5cdCAgICAgIHJldHVybiAhIShEcmFnQ29udHJvbC5fYWN0aXZlICYmIGNvbnRleHQgJiYgKGNvbnRleHQudG8gPT09IHRoaXMgfHwgdGhpcy5fYXV0b19zY3JvbGxfZm9yY2UpKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgZHJhZ19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIEF1dG9TY3JvbGwsIHRydWUpO1xuXHQgICAgICBpZiAodmFsdWUgPT0gXCJvcmRlclwiIHx8IHZhbHVlID09IFwibW92ZVwiKSBleHBvcnRzLmV4dGVuZCh0aGlzLCB1c2UoXCJEcmFnT3JkZXJcIiksIHRydWUpO1xuXHQgICAgICBpZiAodmFsdWUgPT0gXCJpbm5lclwiIHx8IHZhbHVlID09IFwib3JkZXJcIikgdGhpcy5faW5uZXJfZHJhZ19vbmx5ID0gdHJ1ZTtcblxuXHQgICAgICB0aGlzLl9pbml0SGFuZGxlcnModGhpcywgdmFsdWUgPT0gXCJzb3VyY2VcIiwgdmFsdWUgPT0gXCJ0YXJnZXRcIik7XG5cblx0ICAgICAgZGVsZXRlIHRoaXMuZHJhZ19zZXR0ZXI7IC8vcHJldmVudCBkb3VibGUgaW5pdGlhbGl6YXRpb25cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0cyAtIHNvdXJjZSBodG1sIGVsZW1lbnRcblx0ICBcdHQgLSB0YXJnZXQgaHRtbCBlbGVtZW50XG5cdCAgXHRkIC0gZHJvcC1vbiBodG1sIGVsZW1lbnQgKCBjYW4gYmUgbm90IGVxdWFsIHRvIHRoZSB0YXJnZXQgKVxuXHQgIFx0ZSAtIG5hdGl2ZSBodG1sIGV2ZW50IFxuXHQgICovXG5cdCAgLy9jYWxsZWQgd2hlbiBkcmFnIG1vdmVkIG92ZXIgcG9zc2libGUgdGFyZ2V0XG5cdCAgJGRyYWdJbjogZnVuY3Rpb24gKHMsIHQsIGUpIHtcblx0ICAgIHZhciBpZCA9IHRoaXMubG9jYXRlKGUpIHx8IG51bGw7XG5cdCAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLl9kcmFnX2NvbnRleHQ7IC8vaW4gaW5uZXIgZHJhZyBtb2RlIC0gaWdub3JlIGRuZCBmcm9tIG90aGVyIGNvbXBvbmVudHNcblxuXHQgICAgaWYgKCh0aGlzLl9pbm5lcl9kcmFnX29ubHkgfHwgY29udGV4dC5mcm9tLl9pbm5lcl9kcmFnX29ubHkpICYmIGNvbnRleHQuZnJvbSAhPT0gdGhpcykgcmV0dXJuIGZhbHNlO1xuXHQgICAgdmFyIHRvID0gRHJhZ0NvbnRyb2wuZ2V0TWFzdGVyKHQpOyAvL3ByZXZpb3VzIHRhcmdldFxuXG5cdCAgICB2YXIgaHRtbCA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQsIGUpIHx8IHRoaXMuX2RhdGFvYmo7IC8vcHJldmVudCBkb3VibGUgcHJvY2Vzc2luZyBvZiBzYW1lIHRhcmdldFxuXG5cblx0ICAgIGlmIChodG1sID09IERyYWdDb250cm9sLl9sYW5kaW5nKSByZXR1cm4gaHRtbDtcblx0ICAgIGNvbnRleHQudGFyZ2V0ID0gaWQ7XG5cdCAgICBjb250ZXh0LnRvID0gdG87XG5cdCAgICBpZiAodGhpcy5fYXV0b19zY3JvbGxfZGVsYXkpIHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5ID0gd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSk7XG5cdCAgICB0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSA9IGRlbGF5KGZ1bmN0aW9uIChwb3MkJDEsIGlkKSB7XG5cdCAgICAgIHRoaXMuX2RyYWdfcGF1c2UoaWQpO1xuXG5cdCAgICAgIHRoaXMuX2F1dG9fc2Nyb2xsKHBvcyQkMSwgaWQpO1xuXHQgICAgfSwgdGhpcywgW3BvcyhlKSwgaWRdLCAyNTApO1xuXG5cdCAgICBpZiAoIXRoaXMuJGRyb3BBbGxvdyhjb250ZXh0LCBlKSB8fCAhdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZURyYWdJblwiLCBbY29udGV4dCwgZV0pKSB7XG5cdCAgICAgIGNvbnRleHQudG8gPSBjb250ZXh0LnRhcmdldCA9IG51bGw7XG5cdCAgICAgIGlmICh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSkgdGhpcy5fYXV0b19zY3JvbGxfZGVsYXkgPSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5KTtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9IC8vbWFyayB0YXJnZXQgb25seSB3aGVuIGxhbmRpbmcgY29uZmlybWVkXG5cblxuXHQgICAgdGhpcy4kZHJhZ01hcmsoY29udGV4dCwgZSk7XG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgICRkcm9wQWxsb3c6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgX2RyYWdfcGF1c2U6IGZ1bmN0aW9uICgpIHsvL21heSBiZSByZWltcGxlbWVudGVkIGluIHNvbWUgY29tcG9uZW50c1xuXHQgICAgLy8gdHJlZSBmb3IgZXhhbXBsZVxuXHQgIH0sXG5cdCAgX3RhcmdldF90b19pZDogZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgcmV0dXJuIHRhcmdldCAmJiBfdHlwZW9mKHRhcmdldCkgPT09IFwib2JqZWN0XCIgPyB0YXJnZXQudG9TdHJpbmcoKSA6IHRhcmdldDtcblx0ICB9LFxuXHQgIC8vY2FsbGVkIHdoZW4gZHJhZyBtb3ZlZCBvdXQgZnJvbSBwb3NzaWJsZSB0YXJnZXRcblx0ICAkZHJhZ091dDogZnVuY3Rpb24gKHMsIHQsIG4sIGUpIHtcblx0ICAgIHZhciBpZCA9ICh0aGlzLl92aWV3b2JqLmNvbnRhaW5zKG4pID8gdGhpcy5sb2NhdGUoZSkgOiBudWxsKSB8fCBudWxsO1xuXHQgICAgdmFyIGNvbnRleHQgPSBEcmFnQ29udHJvbC5fZHJhZ19jb250ZXh0OyAvL3N0aWxsIG92ZXIgcHJldmlvdXMgdGFyZ2V0XG5cblx0ICAgIGlmICgoY29udGV4dC50YXJnZXQgfHwgXCJcIikudG9TdHJpbmcoKSA9PSAoaWQgfHwgXCJcIikudG9TdHJpbmcoKSkgcmV0dXJuIG51bGw7XG5cblx0ICAgIGlmICh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSkge1xuXHQgICAgICB0aGlzLl9hdXRvX3Njcm9sbF9mb3JjZSA9IG51bGw7XG5cdCAgICAgIHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5ID0gd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSk7XG5cdCAgICB9IC8vdW5tYXJrIHByZXZpb3VzIHRhcmdldFxuXG5cblx0ICAgIGNvbnRleHQudGFyZ2V0ID0gY29udGV4dC50byA9IG51bGw7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uRHJhZ091dFwiLCBbY29udGV4dCwgZV0pO1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICAvL2NhbGxlZCB3aGVuIGRyYWcgbW92ZWQgb24gdGFyZ2V0IGFuZCBidXR0b24gaXMgcmVsZWFzZWRcblx0ICAkZHJvcDogZnVuY3Rpb24gKHMsIHQsIGUpIHtcblx0ICAgIGlmICh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSkgdGhpcy5fYXV0b19zY3JvbGxfZGVsYXkgPSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5KTtcblx0ICAgIHZhciBjb250ZXh0ID0gRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dDsgLy9maW5hbGl6ZSBjb250ZXh0IGRldGFpbHNcblxuXHQgICAgY29udGV4dC50byA9IHRoaXM7XG5cblx0ICAgIHRoaXMuX2RlZmluZV9pbmRleChzLCB0LCBjb250ZXh0KTsgLy91bm1hcmsgbGFzdCB0YXJnZXRcblxuXG5cdCAgICB0aGlzLiRkcmFnTWFyayh7fSwgZSk7XG5cblx0ICAgIGlmIChjb250ZXh0LmZyb20gJiYgY29udGV4dC5mcm9tICE9IGNvbnRleHQudG8gJiYgY29udGV4dC5mcm9tLmNhbGxFdmVudCkge1xuXHQgICAgICBjb250ZXh0LmZyb20uY2FsbEV2ZW50KFwib25CZWZvcmVEcm9wT3V0XCIsIFtjb250ZXh0LCBlXSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZURyb3BcIiwgW2NvbnRleHQsIGVdKSkgcmV0dXJuOyAvL21vdmluZ1xuXG5cdCAgICB0aGlzLl9jb250ZXh0X3RvX21vdmUoY29udGV4dCwgZSk7XG5cblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckRyb3BcIiwgW2NvbnRleHQsIGVdKTtcblx0ICB9LFxuXHQgIF9kZWZpbmVfaW5kZXg6IGZ1bmN0aW9uIChzLCB0LCBjb250ZXh0KSB7XG5cdCAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0X3RvX2lkKGNvbnRleHQudGFyZ2V0KTtcblxuXHQgICAgaWYgKHRoaXMuZ2V0QnJhbmNoSW5kZXgpIHtcblx0ICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgIGNvbnRleHQucGFyZW50ID0gdGhpcy5nZXRQYXJlbnRJZCh0YXJnZXQpO1xuXHQgICAgICAgIGNvbnRleHQuaW5kZXggPSB0aGlzLmdldEJyYW5jaEluZGV4KHRhcmdldCk7XG5cdCAgICAgIH0gZWxzZSBjb250ZXh0LmluZGV4ID0gLTE7XG5cdCAgICB9IGVsc2UgY29udGV4dC5pbmRleCA9IHRhcmdldCA/IHRoaXMuZ2V0SW5kZXhCeUlkKHRhcmdldCkgOiB0aGlzLmNvdW50KCk7XG5cdCAgfSxcblx0ICBfY29udGV4dF90b19tb3ZlOiBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgYXNzZXJ0KGNvbnRleHQuZnJvbSwgXCJVbnNvcHBvcnRlZCBkLW4tZCBjb21iaW5hdGlvblwiKTtcblxuXHQgICAgaWYgKGNvbnRleHQuZnJvbSAmJiBjb250ZXh0LmZyb20ubW92ZSkge1xuXHQgICAgICAvL2Zyb20gZGlmZmVyZW50IGNvbXBvbmVudCB3aXRoIGl0ZW0gZG5kXG5cdCAgICAgIHZhciBkZXRhaWxzID0ge1xuXHQgICAgICAgIHBhcmVudDogY29udGV4dC5wYXJlbnQsXG5cdCAgICAgICAgbW9kZTogY29udGV4dC5wb3Ncblx0ICAgICAgfTtcblx0ICAgICAgY29udGV4dC5mcm9tLm1vdmUoY29udGV4dC5zb3VyY2UsIGNvbnRleHQuaW5kZXgsIGNvbnRleHQudG8sIGRldGFpbHMpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldERyYWdJdGVtUG9zOiBmdW5jdGlvbiAocG9zJCQxLCBlKSB7XG5cdCAgICBpZiAodGhpcy5nZXRJdGVtTm9kZSkge1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLmxvY2F0ZShlLCB0cnVlKTsgLy9pbiBzb21lIGNhc2UsIG5vZGUgbWF5IGJlIG91dGlzaWRlIG9mIGRvbSAoIHNwYW5zIGluIGRhdGF0YWJsZSBmb3IgZXhhbXBsZSApXG5cdCAgICAgIC8vc28gZ2V0SXRlbU5vZGUgY2FuIHJldHVybiBudWxsXG5cblx0ICAgICAgdmFyIG5vZGUgPSBpZCA/IHRoaXMuZ2V0SXRlbU5vZGUoaWQpIDogbnVsbDtcblx0ICAgICAgcmV0dXJuIG5vZGUgPyBvZmZzZXQobm9kZSkgOiBub2RlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9jYWxsZWQgd2hlbiBkcmFnIGFjdGlvbiBzdGFydGVkXG5cdCAgJGRyYWc6IGZ1bmN0aW9uIChzLCBlKSB7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmxvY2F0ZShlLCB0cnVlKTtcblxuXHQgICAgaWYgKGlkKSB7XG5cdCAgICAgIHZhciBsaXN0ID0gW2lkXTtcblxuXHQgICAgICBpZiAodGhpcy5nZXRTZWxlY3RlZElkKSB7XG5cdCAgICAgICAgLy9oYXMgc2VsZWN0aW9uIG1vZGVsXG5cdCAgICAgICAgLy9pZiBkcmFnZ2VkIGl0ZW0gaXMgb25lIG9mIHNlbGVjdGVkIC0gZHJhZyBhbGwgc2VsZWN0ZWRcblx0ICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoID4gMSAmJiBQb3dlckFycmF5LmZpbmQuY2FsbChzZWxlY3Rpb24sIGlkKSAhPSAtMSkge1xuXHQgICAgICAgICAgdmFyIGhhc2ggPSB7fTtcblx0ICAgICAgICAgIGxpc3QgPSBbXTtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaGFzaFtzZWxlY3Rpb25baV1dID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuZGF0YS5vcmRlci5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgdmFyIGhhc2hfaWQgPSB0aGlzLmRhdGEub3JkZXJbX2ldO1xuXHQgICAgICAgICAgICBpZiAoaGFzaFtoYXNoX2lkXSkgbGlzdC5wdXNoKGhhc2hfaWQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSAvL3NhdmUgaW5pdGlhbCBkbmQgcGFyYW1zXG5cblxuXHQgICAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLl9kcmFnX2NvbnRleHQgPSB7XG5cdCAgICAgICAgc291cmNlOiBsaXN0LFxuXHQgICAgICAgIHN0YXJ0OiBpZFxuXHQgICAgICB9O1xuXHQgICAgICBjb250ZXh0LmZyYWdpbGUgPSB0aGlzLmFkZFJvd0NzcyAmJiBlbnYudG91Y2ggJiYgKGVudi5pc1dlYktpdCB8fCBlbnYuaXNGRik7XG5cdCAgICAgIGNvbnRleHQuZnJvbSA9IHRoaXM7XG5cblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVEcmFnXCIsIFtjb250ZXh0LCBlXSkpIHtcblx0ICAgICAgICBpZiAoVG91Y2gpIFRvdWNoLl9zdGFydF9jb250ZXh0ID0gbnVsbDsgLy9zZXQgZHJhZyByZXByZXNlbnRhdGlvblxuXG5cdCAgICAgICAgcmV0dXJuIGNvbnRleHQuaHRtbCB8fCB0aGlzLiRkcmFnSFRNTCh0aGlzLmdldEl0ZW0oaWQpLCBlLCBjb250ZXh0KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgICRkcmFnSFRNTDogZnVuY3Rpb24gKG9iaiwgZSwgY29udGV4dCkge1xuXHQgICAgdmFyIGh0bWwgPSB0aGlzLl90b0hUTUwob2JqKTtcblxuXHQgICAgaWYgKGlzQXJyYXkoY29udGV4dC5zb3VyY2UpICYmIGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDEpIGh0bWwgPSB0aGlzLl90b011bHRpcGxlSFRNTChodG1sLCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICBfdG9NdWx0aXBsZUhUTUw6IGZ1bmN0aW9uIChodG1sLCBsZW4pIHtcblx0ICAgIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X2RyYWdfbWFpbic+XCIgKyBodG1sICsgXCI8L2Rpdj5cIjtcblx0ICAgIHZhciBtdWx0aXBsZSA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfZHJhZ19tdWx0aXBsZSc+PC9kaXY+XCI7XG5cdCAgICBpZiAobGVuID4gMikgbXVsdGlwbGUgPSBcIjxkaXYgY2xhc3M9J3dlYml4X2RyYWdfbXVsdGlwbGVfbGFzdCc+PC9kaXY+XCIgKyBtdWx0aXBsZTtcblx0ICAgIHJldHVybiBtdWx0aXBsZSArIGh0bWwgKyBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9iYWRnZSc+XCIgKyBsZW4gKyBcIjwvc3Bhbj5cIjtcblx0ICB9LFxuXHQgICRkcmFnTWFyazogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgIHZhciB0YXJnZXQgPSBudWxsO1xuXHQgICAgaWYgKGNvbnRleHQudGFyZ2V0KSB0YXJnZXQgPSB0aGlzLl90YXJnZXRfdG9faWQoY29udGV4dC50YXJnZXQpOyAvL3RvdWNoIHdlYmtpdCB3aWxsIHN0b3AgdG91Y2htb3ZlIGV2ZW50IGlmIHNvdXJjZSBub2RlIHJlbW92ZWRcblx0ICAgIC8vZGF0YXRhYmxlIGNhbid0IHJlcGFpbnQgcm93cyB3aXRob3V0IHJlcGFpbnRpbmdcblxuXHQgICAgaWYgKHRoaXMuX21hcmtlZCAmJiB0aGlzLl9tYXJrZWQgIT0gdGFyZ2V0KSB7XG5cdCAgICAgIGlmICghY29udGV4dC5mcmFnaWxlKSB0aGlzLnJlbW92ZUNzcyh0aGlzLl9tYXJrZWQsIFwid2ViaXhfZHJhZ19vdmVyXCIpO1xuXHQgICAgICB0aGlzLl9tYXJrZWQgPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuX21hcmtlZCAmJiB0YXJnZXQpIHtcblx0ICAgICAgdGhpcy5fbWFya2VkID0gdGFyZ2V0O1xuXHQgICAgICBpZiAoIWNvbnRleHQuZnJhZ2lsZSkgdGhpcy5hZGRDc3ModGFyZ2V0LCBcIndlYml4X2RyYWdfb3ZlclwiKTtcblx0ICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbnRleHQudG8pIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgLy8gbWV0aG9kcyB1c2VkIGluIG9yZGVyL21vdmUgbW9kZXNcblx0ICAkZHJvcEhUTUw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBcIlwiO1xuXHQgIH0sXG5cdCAgX3NldF9kcm9wX2FyZWE6IGZ1bmN0aW9uICh0YXJnZXQsIHQpIHtcblx0ICAgIHZhciBub2RlID0gdGhpcy5nZXRJdGVtTm9kZSh0YXJnZXQpO1xuXG5cdCAgICBpZiAobm9kZSkge1xuXHQgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKERyYWdDb250cm9sLl9kcm9wSFRNTFswXSwgbm9kZSk7XG5cdCAgICB9IGVsc2UgdC5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChEcmFnQ29udHJvbC5fZHJvcEhUTUxbMF0pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgRHJhZ09yZGVyID0ge1xuXHQgICRkcmFnOiBmdW5jdGlvbiAocywgZSkge1xuXHQgICAgdmFyIGh0bWwgPSBEcmFnSXRlbS4kZHJhZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgaWYgKCFodG1sKSByZXR1cm4gaHRtbDtcblx0ICAgIHZhciBjb250ZXh0ID0gRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dDtcblx0ICAgIGlmICh0aGlzLl9jbG9zZV9icmFuY2hlcykgdGhpcy5fY2xvc2VfYnJhbmNoZXMoY29udGV4dCk7XG5cdCAgICBpZiAodGhpcy5faW5uZXJfZHJhZ19vbmx5ICYmIHRoaXMuZ2V0QnJhbmNoSW5kZXgpIHRoaXMuX2RyYWdfb3JkZXJfc3RvcmVkX2xlZnQgPSB0aGlzLl9kcmFnX29yZGVyX2NvbXBsZXggPyAodGhpcy5nZXRJdGVtKGNvbnRleHQuc3RhcnQpLiRsZXZlbCArIDEpICogMjAgKyA4IDogMDtcblxuXHQgICAgaWYgKGlzQXJyYXkoY29udGV4dC5zb3VyY2UpICYmICFjb250ZXh0LmZyYWdpbGUpIHtcblx0ICAgICAgRHJhZ0NvbnRyb2wuX3NldERyYWdPZmZzZXQoZSk7XG5cblx0ICAgICAgdGhpcy5fYWRkX2Nzcyhjb250ZXh0LnNvdXJjZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBodG1sO1xuXHQgIH0sXG5cdCAgX2FkZF9jc3M6IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuYWRkQ3NzKHNvdXJjZVtpXSwgXCJ3ZWJpeF9pbnZpc2libGVcIik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfcmVtb3ZlX2NzczogZnVuY3Rpb24gKHNvdXJjZSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5yZW1vdmVDc3Moc291cmNlW2ldLCBcIndlYml4X2ludmlzaWJsZVwiKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRkcmFnSW46IGZ1bmN0aW9uIChzLCB0LCBlKSB7XG5cdCAgICB2YXIgaHRtbCA9IERyYWdJdGVtLiRkcmFnSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIGlmICghaHRtbCkgcmV0dXJuIGh0bWw7XG5cdCAgICBpZiAoIURyYWdDb250cm9sLl9kcm9wSFRNTCkgRHJhZ0NvbnRyb2wuX2Ryb3BIVE1MID0gdGhpcy5faW5pdF9kcm9wX2FyZWEoKTtcblx0ICAgIHZhciBjb250ZXh0ID0gRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dDtcblx0ICAgIHZhciB0YXJnZXQgPSBcIiR3ZWJpeC1sYXN0XCI7XG5cdCAgICBpZiAoY29udGV4dC50YXJnZXQpIHRhcmdldCA9IHRoaXMuX3RhcmdldF90b19pZChjb250ZXh0LnRhcmdldCk7XG5cblx0ICAgIGlmICh0YXJnZXQgIT0gXCIkd2ViaXgtbGFzdFwiICYmIHRhcmdldCAhPSBcIiR3ZWJpeC1kcm9wXCIpIHtcblx0ICAgICAgdmFyIHNldHRpbmdzID0ge1xuXHQgICAgICAgIGRpcmVjdGlvbjogdGhpcy5fc2V0dGluZ3MubGF5b3V0IHx8IHRoaXMuX2RyYWdfZGlyZWN0aW9uIHx8IFwieVwiLFxuXHQgICAgICAgIHg6IFwid2lkdGhcIixcblx0ICAgICAgICB5OiBcImhlaWdodFwiXG5cdCAgICAgIH07XG5cdCAgICAgIHZhciBvZnMgPSBvZmZzZXQoaHRtbCk7XG5cdCAgICAgIHZhciBkaXJlY3Rpb24gPSBwb3MoZSlbc2V0dGluZ3MuZGlyZWN0aW9uXSAtIG9mc1tzZXR0aW5ncy5kaXJlY3Rpb25dO1xuXHQgICAgICBpZiAoZGlyZWN0aW9uICogMiA+IG9mc1tzZXR0aW5nc1tzZXR0aW5ncy5kaXJlY3Rpb25dXSkgdGFyZ2V0ID0gdGhpcy5nZXROZXh0SWQodGFyZ2V0KSB8fCBcIiR3ZWJpeC1sYXN0XCI7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0YXJnZXQgPT0gdGhpcy5fbWFya2VkX2l0ZW1faWQgfHwgdGFyZ2V0ID09IFwiJHdlYml4LWRyb3BcIikgcmV0dXJuIGh0bWw7XG5cdCAgICB0aGlzLl9tYXJrZWRfaXRlbV9pZCA9IHRhcmdldDtcblxuXHQgICAgdGhpcy5fc2V0X2Ryb3BfYXJlYSh0YXJnZXQsIHQpO1xuXG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgICRkcmFnUG9zOiBmdW5jdGlvbiAocG9zJCQxKSB7XG5cdCAgICBpZiAoIXRoaXMuX2lubmVyX2RyYWdfb25seSkge1xuXHQgICAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLl9kcmFnX2NvbnRleHQ7XG5cdCAgICAgIHBvcyQkMS55ICs9IGNvbnRleHQueV9vZmZzZXQ7XG5cdCAgICAgIHBvcyQkMS54ICs9IGNvbnRleHQueF9vZmZzZXQ7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIGJveCA9IG9mZnNldCh0aGlzLiR2aWV3KTtcblx0ICAgIHZhciB4ZHJhZyA9IHRoaXMuX3NldHRpbmdzLmxheW91dCA9PSBcInhcIjtcblxuXHQgICAgaWYgKHhkcmFnKSB7XG5cdCAgICAgIGJveC54IC09IDEyO1xuXHQgICAgICBwb3MkJDEueSA9IGJveC55IC0gODtcblx0ICAgICAgcG9zJCQxLnggPSBwb3MkJDEueCAtIDE4O1xuXHQgICAgICBpZiAocG9zJCQxLnggPCBib3gueCkgcG9zJCQxLnggPSBib3gueDtlbHNlIHtcblx0ICAgICAgICB2YXIgbWF4ID0gYm94LnggKyBib3gud2lkdGg7XG5cdCAgICAgICAgaWYgKHBvcyQkMS54ID4gbWF4KSBwb3MkJDEueCA9IG1heDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYm94LnkgKz0gKHRoaXMuX2hlYWRlcl9oZWlnaHQgfHwgMCkgLSAxMjtcblx0ICAgICAgcG9zJCQxLnggPSAodGhpcy5fZHJhZ19vcmRlcl9zdG9yZWRfbGVmdCB8fCBib3gueCkgKyA4O1xuXHQgICAgICBwb3MkJDEueSA9IHBvcyQkMS55IC0gMTg7XG5cdCAgICAgIGlmIChwb3MkJDEueSA8IGJveC55KSBwb3MkJDEueSA9IGJveC55O2Vsc2Uge1xuXHQgICAgICAgIHZhciBfbWF4ID0gYm94LnkgKyBib3guaGVpZ2h0IC0gKHRoaXMuX2hlYWRlcl9oZWlnaHQgfHwgMCk7XG5cblx0ICAgICAgICBpZiAocG9zJCQxLnkgPiBfbWF4KSBwb3MkJDEueSA9IF9tYXg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgICRkcmFnT3V0OiBmdW5jdGlvbiAocywgb3QsIG50KSB7XG5cdCAgICBpZiAob3QgIT0gbnQpIHtcblx0ICAgICAgcmVtb3ZlKERyYWdDb250cm9sLl9kcm9wSFRNTCk7XG5cdCAgICAgIHRoaXMuX21hcmtlZF9pdGVtX2lkID0gRHJhZ0NvbnRyb2wuX2Ryb3BIVE1MID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIERyYWdJdGVtLiRkcmFnT3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfSxcblx0ICBfZGVmaW5lX2luZGV4OiBmdW5jdGlvbiAocywgdCwgY29udGV4dCkge1xuXHQgICAgdmFyIHRhcmdldCA9IHRoaXMuX21hcmtlZF9pdGVtX2lkID09IFwiJHdlYml4LWxhc3RcIiA/IG51bGwgOiB0aGlzLl9tYXJrZWRfaXRlbV9pZDtcblxuXHQgICAgaWYgKHRoaXMuZ2V0QnJhbmNoSW5kZXgpIHtcblx0ICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgIGNvbnRleHQucGFyZW50ID0gdGhpcy5nZXRQYXJlbnRJZCh0YXJnZXQpO1xuXHQgICAgICAgIGNvbnRleHQuaW5kZXggPSB0aGlzLmdldEJyYW5jaEluZGV4KHRhcmdldCk7XG5cdCAgICAgICAgaWYgKHMgPT0gdCAmJiB0aGlzLmdldFBhcmVudElkKGNvbnRleHQuc3RhcnQpID09IGNvbnRleHQucGFyZW50ICYmIHRoaXMuZ2V0QnJhbmNoSW5kZXgoY29udGV4dC5zdGFydCkgPCBjb250ZXh0LmluZGV4KSBjb250ZXh0LmluZGV4IC09IDE7XG5cdCAgICAgIH0gZWxzZSBjb250ZXh0LmluZGV4ID0gLTE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb250ZXh0LmluZGV4ID0gdGFyZ2V0ID8gdGhpcy5nZXRJbmRleEJ5SWQodGFyZ2V0KSA6IHRoaXMuY291bnQoKTtcblx0ICAgICAgY29udGV4dC5pbmRleCAtPSBzID09IHQgJiYgdGhpcy5nZXRJbmRleEJ5SWQoY29udGV4dC5zdGFydCkgPCBjb250ZXh0LmluZGV4ID8gMSA6IDA7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkZHJhZ0Rlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb250ZXh0ID0gRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dDtcblx0ICAgIGlmIChpc0FycmF5KGNvbnRleHQuc291cmNlKSAmJiAhY29udGV4dC5mcmFnaWxlKSB0aGlzLl9yZW1vdmVfY3NzKGNvbnRleHQuc291cmNlKTtcblx0ICAgIHJlbW92ZShEcmFnQ29udHJvbC5faHRtbCk7XG5cdCAgfSxcblx0ICBfaW5pdF9kcm9wX2FyZWE6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ICAgIG5vZGUuY2xhc3NOYW1lID0gXCJ3ZWJpeF9kcm9wX2FyZWFcIjtcblx0ICAgIG5vZGUuc3R5bGUud2lkdGggPSB0aGlzLnR5cGUud2lkdGggKyBcInB4XCI7XG5cdCAgICBub2RlLnN0eWxlLmhlaWdodCA9IHRoaXMudHlwZS5oZWlnaHQgKyBcInB4XCI7XG5cdCAgICBub2RlLmlubmVySFRNTCA9IHRoaXMuJGRyb3BIVE1MKCk7XG5cdCAgICBub2RlLnNldEF0dHJpYnV0ZSh0aGlzLl9pZCwgXCIkd2ViaXgtZHJvcFwiKTtcblx0ICAgIHJldHVybiBbbm9kZV07XG5cdCAgfSxcblx0ICAkZHJhZ01hcms6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH07XG5cdGRlZmluZShcIkRyYWdPcmRlclwiLCBEcmFnT3JkZXIpO1xuXG5cdHZhciBVbmRvID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl91bmRvSGlzdG9yeSA9IGV4cG9ydHMuZXh0ZW5kKFtdLCBQb3dlckFycmF5LCB0cnVlKTtcblx0ICAgIHRoaXMuX3VuZG9DdXJzb3IgPSAtMTtcblx0ICB9LFxuXHQgIHVuZG9fc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICB0aGlzLl9pbml0X3VuZG8oKTtcblxuXHQgICAgICB0aGlzLl9pbml0X3VuZG8gPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX2luaXRfdW5kbzogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZpZXcgPSB0aGlzOyAvLyBkcmFnLW4tZHJvcFxuXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEcm9wXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIGlmIChjb250ZXh0LmZyb20gPT0gY29udGV4dC50bykge1xuXHQgICAgICAgIHZhciBpdGVtID0gdmlldy5fZHJhZ2dlZEl0ZW0gPSBjb3B5KHRoaXMuZ2V0SXRlbShjb250ZXh0LnN0YXJ0KSk7XG5cblx0ICAgICAgICBpZiAodGhpcy5kYXRhLmJyYW5jaCkge1xuXHQgICAgICAgICAgaXRlbS4kaW5kZXggPSB0aGlzLmdldEJyYW5jaEluZGV4KGl0ZW0uaWQpO1xuXHQgICAgICAgIH0gZWxzZSBpdGVtLiRpbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUlkKGl0ZW0uaWQpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uRGF0YU1vdmVcIiwgZnVuY3Rpb24gKHNpZCkge1xuXHQgICAgICBpZiAodmlldy5fZHJhZ2dlZEl0ZW0gJiYgdmlldy5fZHJhZ2dlZEl0ZW0uaWQgPT0gc2lkKSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSB2aWV3Ll9kcmFnZ2VkSXRlbTtcblx0ICAgICAgICB2aWV3Ll9kcmFnZ2VkSXRlbSA9IG51bGw7XG5cblx0ICAgICAgICB2aWV3Ll9hZGRUb0hpc3Rvcnkoc2lkLCBkYXRhLCBcIm1vdmVcIik7XG5cdCAgICAgIH1cblx0ICAgIH0pOyAvLyBhZGQsIHJlbW92ZVxuXG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURlbGV0ZVwiLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgaWYgKHRoaXMuZ2V0SXRlbShpZCkpIHtcblx0ICAgICAgICB2YXIgaXRlbSA9IHZpZXcuX2RlbGV0ZWRJdGVtID0gY29weSh0aGlzLmdldEl0ZW0oaWQpKTtcblxuXHQgICAgICAgIGlmICh0aGlzLmJyYW5jaCkge1xuXHQgICAgICAgICAgaXRlbS4kaW5kZXggPSB0aGlzLmdldEJyYW5jaEluZGV4KGlkKTtcblx0ICAgICAgICAgIGlmICh0aGlzLmJyYW5jaFtpZF0pIGl0ZW0uJGJyYW5jaCA9IGNvcHkodGhpcy5zZXJpYWxpemUoaWQpKTtcblx0ICAgICAgICB9IGVsc2UgaXRlbS4kaW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChpZCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25EYXRhVXBkYXRlXCIsIGZ1bmN0aW9uIChpZCwgZGF0YSwgb2xkKSB7XG5cdCAgICAgIHZpZXcuX2FkZFRvSGlzdG9yeShpZCArIFwiXCIsIG9sZCwgXCJ1cGRhdGVcIik7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGZ1bmN0aW9uIChpZCwgaXRlbSwgbW9kZSkge1xuXHQgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cblx0ICAgICAgaWYgKGlkKSB7XG5cdCAgICAgICAgaWYgKG1vZGUgPT0gXCJhZGRcIikge1xuXHQgICAgICAgICAgZGF0YSA9IGNvcHkoaXRlbSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IFwiZGVsZXRlXCIpIHtcblx0ICAgICAgICAgIGRhdGEgPSB2aWV3Ll9kZWxldGVkSXRlbTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZGF0YSkgdmlldy5fYWRkVG9IaXN0b3J5KGlkLCBkYXRhLCBtb2RlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7IC8vIGlkIGNoYW5nZVxuXG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGZ1bmN0aW9uIChvbGRJZCwgbmV3SWQpIHtcblx0ICAgICAgaWYgKF90eXBlb2Yob2xkSWQpID09IFwib2JqZWN0XCIpIG9sZElkID0gb2xkSWQucm93O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5fdW5kb0hpc3RvcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAodmlldy5fdW5kb0hpc3RvcnlbaV0uaWQgPT0gb2xkSWQpIHtcblx0ICAgICAgICAgIHZpZXcuX3VuZG9IaXN0b3J5W2ldLmlkID0gbmV3SWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIF9hZGRUb0hpc3Rvcnk6IGZ1bmN0aW9uIChpZCwgZGF0YSwgYWN0aW9uKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NraXBIaXN0b3J5ICYmIHRoaXMuX3NldHRpbmdzLnVuZG8pIHtcblx0ICAgICAgdGhpcy5fdW5kb0hpc3RvcnkucHVzaCh7XG5cdCAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuXHQgICAgICAgIGRhdGE6IGRhdGFcblx0ICAgICAgfSk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3VuZG9IaXN0b3J5Lmxlbmd0aCA9PSAyMCkgdGhpcy5fdW5kb0hpc3Rvcnkuc3BsaWNlKDAsIDEpO1xuXHQgICAgICBpZiAoIXRoaXMuX3NraXBDdXJzb3JJbmMpIHRoaXMuX3VuZG9DdXJzb3IgPSB0aGlzLl91bmRvSGlzdG9yeS5sZW5ndGggLSAxO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgaWdub3JlVW5kbzogZnVuY3Rpb24gKGZ1bmMsIG1hc3Rlcikge1xuXHQgICAgdGhpcy5fc2tpcEhpc3RvcnkgPSB0cnVlO1xuXHQgICAgZnVuYy5jYWxsKG1hc3RlciB8fCB0aGlzKTtcblx0ICAgIHRoaXMuX3NraXBIaXN0b3J5ID0gZmFsc2U7XG5cdCAgfSxcblx0ICByZW1vdmVVbmRvOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLl91bmRvSGlzdG9yeS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICBpZiAodGhpcy5fdW5kb0hpc3RvcnlbaV0uaWQgPT0gaWQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdW5kb0hpc3RvcnlbaV0uYWN0aW9uID09IFwiaWRcIikge1xuXHQgICAgICAgICAgaWQgPSB0aGlzLl91bmRvSGlzdG9yeVtpXS5kYXRhO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX3VuZG9IaXN0b3J5LnJlbW92ZUF0KGkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3VuZG9DdXJzb3IgPSB0aGlzLl91bmRvSGlzdG9yeS5sZW5ndGggLSAxO1xuXHQgIH0sXG5cdCAgdW5kbzogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICBpZiAoaWQpIHtcblx0ICAgICAgdGhpcy5pZ25vcmVVbmRvKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZGF0YSwgaTtcblxuXHQgICAgICAgIGZvciAoaSA9IHRoaXMuX3VuZG9IaXN0b3J5Lmxlbmd0aCAtIDE7ICFkYXRhICYmIGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5fdW5kb0hpc3RvcnlbaV0uaWQgPT0gaWQpIGRhdGEgPSB0aGlzLl91bmRvSGlzdG9yeVtpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZGF0YSkge1xuXHQgICAgICAgICAgLyppZihkYXRhLmFjdGlvbiA9PSBcImlkXCIpXG5cdCAgICAgICAgICBcdGlkID0gZGF0YS5kYXRhOyovXG5cdCAgICAgICAgICB0aGlzLl91bmRvQWN0aW9uKGRhdGEpO1xuXG5cdCAgICAgICAgICB0aGlzLl91bmRvSGlzdG9yeS5yZW1vdmVBdChpICsgMSk7XG5cblx0ICAgICAgICAgIHRoaXMuX3VuZG9DdXJzb3IgPSB0aGlzLl91bmRvSGlzdG9yeS5sZW5ndGggLSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgZGF0YSA9IHRoaXMuX3VuZG9IaXN0b3J5W3RoaXMuX3VuZG9DdXJzb3JdO1xuXG5cdCAgICAgIGlmIChkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5pZ25vcmVVbmRvKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHRoaXMuX3VuZG9BY3Rpb24oZGF0YSk7XG5cblx0ICAgICAgICAgIHRoaXMuX3VuZG9IaXN0b3J5LnJlbW92ZUF0KHRoaXMuX3VuZG9DdXJzb3IpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3VuZG9DdXJzb3ItLTtcblx0ICAgICAgICAvKmlmKGRhdGEuYWN0aW9uID09IFwiaWRcIilcblx0ICAgICAgICBcdHRoaXMudW5kbygpOyovXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF91bmRvQWN0aW9uOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAob2JqLmFjdGlvbiA9PSBcImRlbGV0ZVwiKSB7XG5cdCAgICAgIHZhciBicmFuY2ggPSBudWxsLFxuXHQgICAgICAgICAgcGFyZW50SWQgPSBvYmouZGF0YS4kcGFyZW50O1xuXG5cdCAgICAgIGlmIChvYmouZGF0YS4kYnJhbmNoKSB7XG5cdCAgICAgICAgYnJhbmNoID0ge1xuXHQgICAgICAgICAgcGFyZW50OiBvYmouaWQsXG5cdCAgICAgICAgICBkYXRhOiBjb3B5KG9iai5kYXRhLiRicmFuY2gpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBkZWxldGUgb2JqLmRhdGEuJGJyYW5jaDtcblx0ICAgICAgICBpZiAocGFyZW50SWQgJiYgIXRoaXMuZGF0YS5icmFuY2hbcGFyZW50SWRdKSBwYXJlbnRJZCA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmFkZChvYmouZGF0YSwgb2JqLmRhdGEuJGluZGV4LCBwYXJlbnRJZCk7XG5cblx0ICAgICAgaWYgKGJyYW5jaCkge1xuXHQgICAgICAgIHRoaXMucGFyc2UoYnJhbmNoKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChvYmouYWN0aW9uID09IFwiYWRkXCIpIHtcblx0ICAgICAgdGhpcy5yZW1vdmUob2JqLmlkKTtcblx0ICAgIH0gZWxzZSBpZiAob2JqLmFjdGlvbiA9PSBcInVwZGF0ZVwiKSB7XG5cdCAgICAgIHRoaXMudXBkYXRlSXRlbShvYmouaWQsIG9iai5kYXRhKTtcblx0ICAgIH0gZWxzZSBpZiAob2JqLmFjdGlvbiA9PSBcIm1vdmVcIikge1xuXHQgICAgICBpZiAob2JqLmRhdGEuJHBhcmVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLmdldEl0ZW0ob2JqLmRhdGEuJHBhcmVudCkpIHRoaXMubW92ZShvYmouaWQsIG9iai5kYXRhLiRpbmRleCwgbnVsbCwge1xuXHQgICAgICAgICAgcGFyZW50OiBvYmouZGF0YS4kcGFyZW50XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB0aGlzLm1vdmUob2JqLmlkLCBvYmouZGF0YS4kaW5kZXgpO1xuXHQgICAgfVxuXHQgICAgLyplbHNlIGlmKG9iai5hY3Rpb24gPT0gXCJpZFwiKXtcblx0ICAgIFx0dGhpcy5kYXRhLmNoYW5nZUlkKG9iai5pZCwgb2JqLmRhdGEpO1xuXHQgICAgfSovXG5cblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdF9zdWdnZXN0KGVkaXRvciwgaW5wdXQpIHtcblx0ICB2YXIgc3VnZ2VzdCA9IGVkaXRvci5jb25maWcuc3VnZ2VzdDtcblxuXHQgIGlmIChzdWdnZXN0KSB7XG5cdCAgICB2YXIgYm94ID0gZWRpdG9yLmNvbmZpZy5zdWdnZXN0ID0gY3JlYXRlX3N1Z2dlc3Qoc3VnZ2VzdCk7XG5cdCAgICB2YXIgYm94b2JqID0gJCQoYm94KTtcblx0ICAgIGlmIChib3hvYmogJiYgaW5wdXQpIGJveG9iai5saW5rSW5wdXQoaW5wdXQpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9zdWdnZXN0KGNvbmZpZykge1xuXHQgIGlmICh0eXBlb2YgY29uZmlnID09IFwic3RyaW5nXCIpIHJldHVybiBjb25maWc7XG5cdCAgaWYgKGNvbmZpZy5saW5rSW5wdXQpIHJldHVybiBjb25maWcuX3NldHRpbmdzLmlkO1xuXG5cdCAgaWYgKF90eXBlb2YoY29uZmlnKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICBpZiAoaXNBcnJheShjb25maWcpKSBjb25maWcgPSB7XG5cdCAgICAgIGRhdGE6IGNvbmZpZ1xuXHQgICAgfTtcblx0ICAgIGNvbmZpZy52aWV3ID0gY29uZmlnLnZpZXcgfHwgXCJzdWdnZXN0XCI7XG5cdCAgfSBlbHNlIGlmIChjb25maWcgPT09IHRydWUpIGNvbmZpZyA9IHtcblx0ICAgIHZpZXc6IFwic3VnZ2VzdFwiXG5cdCAgfTtcblxuXHQgIHZhciBvYmogPSB1aShjb25maWcpO1xuXHQgIHJldHVybiBvYmouY29uZmlnLmlkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TGFiZWwoY29uZmlnKSB7XG5cdCAgdmFyIHRleHQgPSBjb25maWcuaGVhZGVyICYmIGNvbmZpZy5oZWFkZXJbMF0gPyBjb25maWcuaGVhZGVyWzBdLnRleHQgOiBjb25maWcuZWRpdFZhbHVlIHx8IGNvbmZpZy5sYWJlbDtcblx0ICByZXR1cm4gKHRleHQgfHwgXCJcIikudG9TdHJpbmcoKS5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpO1xuXHR9XG5cdC8qXG5cdHRoaXMubm9kZSAtIGh0bWwgbm9kZSwgYXZhaWxhYmxlIGFmdGVyIHJlbmRlciBjYWxsXG5cdHRoaXMuY29uZmlnIC0gZWRpdG9yIGNvbmZpZ1xuXHR0aGlzLnZhbHVlIC0gb3JpZ2luYWwgdmFsdWVcblx0dGhpcy5wb3B1cCAtIGlkIG9mIHBvcHVwIFxuXHQqL1xuXG5cblx0dmFyIGVkaXRvcnMgPSB7XG5cdCAgXCJ0ZXh0XCI6IHtcblx0ICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKHRoaXMubm9kZSkuZm9jdXMoKTtcblx0ICAgICAgdGhpcy5nZXRJbnB1dE5vZGUodGhpcy5ub2RlKS5zZWxlY3QoKTtcblx0ICAgIH0sXG5cdCAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRJbnB1dE5vZGUodGhpcy5ub2RlKS52YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXROb2RlKHRoaXMubm9kZSk7XG5cdCAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG5cdCAgICAgIGluaXRfc3VnZ2VzdCh0aGlzLCBpbnB1dCk7XG5cdCAgICB9LFxuXHQgICAgZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5vZGUuZmlyc3RDaGlsZDtcblx0ICAgIH0sXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X2R0X2VkaXRvclwiXG5cdCAgICAgIH0sIFwiPGlucHV0IHR5cGU9J3RleHQnIGFyaWEtbGFiZWw9J1wiICsgZ2V0TGFiZWwodGhpcy5jb25maWcpICsgXCInPlwiKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIFwiaW5saW5lLWNoZWNrYm94XCI6IHtcblx0ICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4ge307XG5cdCAgICB9LFxuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm9kZS5jaGVja2VkO1xuXHQgICAgfSxcblx0ICAgIHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7fSxcblx0ICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMubm9kZS5mb2N1cygpO1xuXHQgICAgfSxcblx0ICAgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKCkge30sXG5cdCAgICAkaW5saW5lOiB0cnVlXG5cdCAgfSxcblx0ICBcImlubGluZS10ZXh0XCI6IHtcblx0ICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4ge307XG5cdCAgICB9LFxuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm9kZS52YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKCkge30sXG5cdCAgICBmb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIC8vSUU5XG5cdCAgICAgICAgdGhpcy5ub2RlLnNlbGVjdCgpO1xuXHQgICAgICAgIHRoaXMubm9kZS5mb2N1cygpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7fSAvL2VzbGludC1kaXNhYmxlLWxpbmVcblxuXHQgICAgfSxcblx0ICAgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKCkge30sXG5cdCAgICAkaW5saW5lOiB0cnVlXG5cdCAgfSxcblx0ICBcImNoZWNrYm94XCI6IHtcblx0ICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkuZm9jdXMoKTtcblx0ICAgIH0sXG5cdCAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRJbnB1dE5vZGUoKS5jaGVja2VkO1xuXHQgICAgfSxcblx0ICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5nZXRJbnB1dE5vZGUoKS5jaGVja2VkID0gISF2YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQ7XG5cdCAgICB9LFxuXHQgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBjcmVhdGUoXCJkaXZcIiwge1xuXHQgICAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9kdF9lZGl0b3JcIlxuXHQgICAgICB9LCBcIjxkaXY+PGlucHV0IHR5cGU9J2NoZWNrYm94JyBhcmlhLWxhYmVsPSdcIiArIGdldExhYmVsKHRoaXMuY29uZmlnKSArIFwiJz48L2Rpdj5cIik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBcInNlbGVjdFwiOiB7XG5cdCAgICBmb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmdldElucHV0Tm9kZSgpLmZvY3VzKCk7XG5cdCAgICB9LFxuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXROb2RlKCkudmFsdWU7XG5cdCAgICB9LFxuXHQgICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICB0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlID0gdmFsdWU7XG5cdCAgICB9LFxuXHQgICAgZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5vZGUuZmlyc3RDaGlsZDtcblx0ICAgIH0sXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGh0bWwgPSBcIlwiO1xuXHQgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgdGhpcy5jb25maWcuY29sbGVjdGlvbjtcblx0ICAgICAgYXNzZXJ0KG9wdGlvbnMsIFwib3B0aW9ucyBub3QgZGVmaW5lZCBmb3Igc2VsZWN0IGVkaXRvclwiKTtcblx0ICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEuZWFjaCkgb3B0aW9ucy5kYXRhLmVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIGh0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG9iai5pZCArIFwiJz5cIiArIG9iai52YWx1ZSArIFwiPC9vcHRpb24+XCI7XG5cdCAgICAgIH0pO2Vsc2Uge1xuXHQgICAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMpKSB7XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHJlYyA9IG9wdGlvbnNbaV07XG5cdCAgICAgICAgICAgIHZhciBpc3BsYWluID0gaXNVbmRlZmluZWQocmVjLmlkKTtcblx0ICAgICAgICAgICAgdmFyIGlkID0gaXNwbGFpbiA/IHJlYyA6IHJlYy5pZDtcblx0ICAgICAgICAgICAgdmFyIGxhYmVsID0gaXNwbGFpbiA/IHJlYyA6IHJlYy52YWx1ZTtcblx0ICAgICAgICAgICAgaHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgaWQgKyBcIic+XCIgKyBsYWJlbCArIFwiPC9vcHRpb24+XCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG5cdCAgICAgICAgICBodG1sICs9IFwiPG9wdGlvbiB2YWx1ZT0nXCIgKyBrZXkgKyBcIic+XCIgKyBvcHRpb25zW2tleV0gKyBcIjwvb3B0aW9uPlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY3JlYXRlKFwiZGl2XCIsIHtcblx0ICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfZHRfZWRpdG9yXCJcblx0ICAgICAgfSwgXCI8c2VsZWN0IGFyaWEtbGFiZWw9J1wiICsgZ2V0TGFiZWwodGhpcy5jb25maWcpICsgXCInPlwiICsgaHRtbCArIFwiPC9zZWxlY3Q+XCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgcG9wdXA6IHtcblx0ICAgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkuZm9jdXMoKTtcblx0ICAgIH0sXG5cdCAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZ2V0UG9wdXAoKS5oaWRlKCk7XG5cdCAgICB9LFxuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXROb2RlKCkuZ2V0VmFsdWUoKSB8fCBcIlwiO1xuXHQgICAgfSxcblx0ICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5nZXRQb3B1cCgpLnNob3codGhpcy5ub2RlKTtcblx0ICAgICAgdGhpcy5nZXRJbnB1dE5vZGUoKS5zZXRWYWx1ZSh2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldFBvcHVwKCkuZ2V0Q2hpbGRWaWV3cygpWzBdO1xuXHQgICAgfSxcblx0ICAgIGdldFBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghdGhpcy5jb25maWcuJHBvcHVwKSB0aGlzLmNvbmZpZy4kcG9wdXAgPSB0aGlzLmNyZWF0ZVBvcHVwKCk7XG5cdCAgICAgIHJldHVybiAkJCh0aGlzLmNvbmZpZy4kcG9wdXApO1xuXHQgICAgfSxcblx0ICAgIGNyZWF0ZVBvcHVwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBwb3B1cCA9IHRoaXMuY29uZmlnLnBvcHVwIHx8IHRoaXMuY29uZmlnLnN1Z2dlc3Q7XG5cblx0ICAgICAgaWYgKHBvcHVwKSB7XG5cdCAgICAgICAgdmFyIHBvYmo7XG5cblx0ICAgICAgICBpZiAoX3R5cGVvZihwb3B1cCkgPT0gXCJvYmplY3RcIiAmJiAhcG9wdXAubmFtZSkge1xuXHQgICAgICAgICAgcG9wdXAudmlldyA9IHBvcHVwLnZpZXcgfHwgXCJzdWdnZXN0XCI7XG5cdCAgICAgICAgICBwb2JqID0gdWkoY29weShwb3B1cCkpO1xuXHQgICAgICAgIH0gZWxzZSBwb2JqID0gJCQocG9wdXApOyAvL2N1c3RvbSBwb3B1cCBtYXkgYmUgbGlua2VkIGFscmVhZHlcblxuXG5cdCAgICAgICAgaWYgKCFwb2JqLl9saW5rZWQpIHtcblx0ICAgICAgICAgIGlmIChwb2JqLmxpbmtJbnB1dCkgcG9iai5saW5rSW5wdXQoZG9jdW1lbnQuYm9keSk7ZWxzZSBpZiAodGhpcy5saW5rSW5wdXQpIHRoaXMubGlua0lucHV0KGRvY3VtZW50LmJvZHkpO1xuXHQgICAgICAgICAgcG9iai5fbGlua2VkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcG9iajtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciB0eXBlID0gZWRpdG9ycy4kcG9wdXBbdGhpcy5wb3B1cFR5cGVdO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgdHlwZSAhPSBcInN0cmluZ1wiICYmICF0eXBlLm5hbWUpIHtcblx0ICAgICAgICB0eXBlID0gZWRpdG9ycy4kcG9wdXBbdGhpcy5wb3B1cFR5cGVdID0gdWkodHlwZSk7XG5cdCAgICAgICAgdGhpcy5wb3B1cEluaXQodHlwZSk7XG5cdCAgICAgICAgaWYgKCF0eXBlLmxpbmtJbnB1dCkgdGhpcy5saW5rSW5wdXQoZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gdHlwZS5fc2V0dGluZ3MuaWQ7XG5cdCAgICB9LFxuXHQgICAgbGlua0lucHV0OiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICBfZXZlbnQodG9Ob2RlKG5vZGUpLCBcImtleWRvd25cIiwgYmluZChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIC8vYWJvcnQsIHdoZW4gZWRpdG9yIHdhcyBub3QgaW5pdGlhbGl6ZWQgeWV0XG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy4kcG9wdXApIHJldHVybjtcblx0ICAgICAgICB2YXIgY29kZSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlLFxuXHQgICAgICAgICAgICBsaXN0ID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblx0ICAgICAgICBpZiAoIWxpc3QuaXNWaXNpYmxlKCkpIHJldHVybjtcblxuXHQgICAgICAgIGlmIChsaXN0Lm1vdmVTZWxlY3Rpb24gJiYgY29kZSA8IDQxICYmIGNvZGUgPiAzMikge1xuXHQgICAgICAgICAgdmFyIGRpcjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDMzKSBkaXIgPSBcInBndXBcIjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDM0KSBkaXIgPSBcInBnZG93blwiO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gMzUpIGRpciA9IFwiYm90dG9tXCI7XG5cdCAgICAgICAgICBpZiAoY29kZSA9PSAzNikgZGlyID0gXCJ0b3BcIjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDM3KSBkaXIgPSBcImxlZnRcIjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDM4KSBkaXIgPSBcInVwXCI7XG5cdCAgICAgICAgICBpZiAoY29kZSA9PSAzOSkgZGlyID0gXCJyaWdodFwiO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gNDApIGRpciA9IFwiZG93blwiO1xuXHQgICAgICAgICAgbGlzdC5tb3ZlU2VsZWN0aW9uKGRpcik7XG5cdCAgICAgICAgfSAvLyBzaGlmdCtlbnRlciBzdXBwb3J0IGZvciAncG9wdXAnIGVkaXRvclxuXHQgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IDEzICYmIChlLnRhcmdldC5ub2RlTmFtZSAhPT0gXCJURVhUQVJFQVwiIHx8ICFlLnNoaWZ0S2V5KSkgY2FsbEV2ZW50KFwib25FZGl0RW5kXCIsIFtdKTtcblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgfSxcblx0ICAgIHBvcHVwSW5pdDogZnVuY3Rpb24gKCkge30sXG5cdCAgICBwb3B1cFR5cGU6IFwidGV4dFwiLFxuXHQgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB7fTtcblx0ICAgIH0sXG5cdCAgICAkaW5saW5lOiB0cnVlXG5cdCAgfVxuXHR9O1xuXHRlZGl0b3JzLmNvbG9yID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgIGZvY3VzOiBmdW5jdGlvbiAoKSB7fSxcblx0ICBwb3B1cFR5cGU6IFwiY29sb3JcIixcblx0ICBwb3B1cEluaXQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuXHQgICAgcG9wdXAuZ2V0Q2hpbGRWaWV3cygpWzBdLmF0dGFjaEV2ZW50KFwib25JdGVtQ2xpY2tcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGNhbGxFdmVudChcIm9uRWRpdEVuZFwiLCBbdmFsdWVdKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fSwgZWRpdG9ycy5wb3B1cCk7XG5cdGVkaXRvcnMuZGF0ZSA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICBmb2N1czogZnVuY3Rpb24gKCkge30sXG5cdCAgcG9wdXBUeXBlOiBcImRhdGVcIixcblx0ICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9pc19zdHJpbmcgPSB0aGlzLmNvbmZpZy5zdHJpbmdSZXN1bHQgfHwgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCI7XG5cdCAgICBlZGl0b3JzLnBvcHVwLnNldFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldElucHV0Tm9kZSgpLmdldFZhbHVlKHRoaXMuX2lzX3N0cmluZyA/IGkxOG4ucGFyc2VGb3JtYXRTdHIgOiBcIlwiKSB8fCBcIlwiO1xuXHQgIH0sXG5cdCAgcG9wdXBJbml0OiBmdW5jdGlvbiAocG9wdXApIHtcblx0ICAgIHBvcHVwLmdldENoaWxkVmlld3MoKVswXS5hdHRhY2hFdmVudChcIm9uRGF0ZVNlbGVjdFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgY2FsbEV2ZW50KFwib25FZGl0RW5kXCIsIFt2YWx1ZV0pO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9LCBlZGl0b3JzLnBvcHVwKTtcblx0ZWRpdG9ycy5jb21ibyA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICBfY3JlYXRlX3N1Z2dlc3Q6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmICh0aGlzLmNvbmZpZy5wb3B1cCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5jb25maWcucG9wdXAuY29uZmlnLmlkO1xuXHQgICAgfSBlbHNlIGlmIChjb25maWcpIHtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZV9zdWdnZXN0KGNvbmZpZyk7XG5cdCAgICB9IGVsc2UgcmV0dXJuIHRoaXMuX3NoYXJlZF9zdWdnZXN0KGNvbmZpZyk7XG5cdCAgfSxcblx0ICBfc2hhcmVkX3N1Z2dlc3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBlID0gZWRpdG9ycy5jb21ibztcblx0ICAgIHJldHVybiBlLl9zdWdnZXN0ID0gZS5fc3VnZ2VzdCB8fCB0aGlzLl9jcmVhdGVfc3VnZ2VzdCh0cnVlKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG5vZGUgPSBjcmVhdGUoXCJkaXZcIiwge1xuXHQgICAgICBcImNsYXNzXCI6IFwid2ViaXhfZHRfZWRpdG9yXCJcblx0ICAgIH0sIFwiPGlucHV0IHR5cGU9J3RleHQnIHJvbGU9J2NvbWJvYm94JyBhcmlhLWxhYmVsPSdcIiArIGdldExhYmVsKHRoaXMuY29uZmlnKSArIFwiJz5cIik7IC8vc2F2ZSBzdWdnZXN0IGlkIGZvciBmdXR1cmUgcmVmZXJlbmNlXHRcdFxuXG5cdCAgICB2YXIgc3VnZ2VzdCA9IHRoaXMuY29uZmlnLnN1Z2dlc3QgPSB0aGlzLl9jcmVhdGVfc3VnZ2VzdCh0aGlzLmNvbmZpZy5zdWdnZXN0KTtcblxuXHQgICAgaWYgKHN1Z2dlc3QpIHtcblx0ICAgICAgJCQoc3VnZ2VzdCkubGlua0lucHV0KG5vZGUuZmlyc3RDaGlsZCwgdHJ1ZSk7XG5cblx0ICAgICAgX2V2ZW50KG5vZGUuZmlyc3RDaGlsZCwgXCJjbGlja1wiLCBiaW5kKHRoaXMuc2hvd1BvcHVwLCB0aGlzKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBub2RlO1xuXHQgIH0sXG5cdCAgZ2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiAkJCh0aGlzLmNvbmZpZy5zdWdnZXN0KTtcblx0ICB9LFxuXHQgIHNob3dQb3B1cDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBvcHVwID0gdGhpcy5nZXRQb3B1cCgpO1xuXHQgICAgdmFyIGxpc3QgPSBwb3B1cC5nZXRMaXN0KCk7XG5cdCAgICB2YXIgaW5wdXQgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5faW5pdGlhbF92YWx1ZTtcblx0ICAgIHBvcHVwLnNob3coaW5wdXQpO1xuXHQgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG5cblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICBhc3NlcnQobGlzdC5leGlzdHModmFsdWUpLCBcIk9wdGlvbiB3aXRoIElEIFwiICsgdmFsdWUgKyBcIiBkb2Vzbid0IGV4aXN0XCIpO1xuXG5cdCAgICAgIGlmIChsaXN0LmV4aXN0cyh2YWx1ZSkpIHtcblx0ICAgICAgICBsaXN0LnNlbGVjdCh2YWx1ZSk7XG5cdCAgICAgICAgbGlzdC5zaG93SXRlbSh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxpc3QudW5zZWxlY3QoKTtcblx0ICAgICAgbGlzdC5zaG93SXRlbShsaXN0LmdldEZpcnN0SWQoKSk7XG5cdCAgICB9XG5cblx0ICAgIHBvcHVwLl9sYXN0X2lucHV0X3RhcmdldCA9IGlucHV0O1xuXHQgIH0sXG5cdCAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuc2hvd1BvcHVwKCk7XG5cdCAgfSxcblx0ICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9pbml0aWFsX3ZhbHVlID0gdmFsdWU7XG5cblx0ICAgIGlmICh0aGlzLmNvbmZpZy5zdWdnZXN0KSB7XG5cdCAgICAgIHZhciBzb2JqID0gJCQodGhpcy5jb25maWcuc3VnZ2VzdCk7XG5cdCAgICAgIHZhciBkYXRhID0gdGhpcy5jb25maWcuY29sbGVjdGlvbiB8fCB0aGlzLmNvbmZpZy5vcHRpb25zO1xuXHQgICAgICBpZiAoZGF0YSkgc29iai5nZXRMaXN0KCkuZGF0YS5pbXBvcnREYXRhKGRhdGEpO1xuXHQgICAgICB0aGlzLmdldElucHV0Tm9kZSh0aGlzLm5vZGUpLnZhbHVlID0gc29iai5nZXRJdGVtVGV4dCh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRJbnB1dE5vZGUoKS52YWx1ZTtcblxuXHQgICAgaWYgKHRoaXMuY29uZmlnLnN1Z2dlc3QpIHtcblx0ICAgICAgdmFyIHN1Z2dlc3QgPSAkJCh0aGlzLmNvbmZpZy5zdWdnZXN0KSxcblx0ICAgICAgICAgIGxpc3QgPSBzdWdnZXN0LmdldExpc3QoKTtcblx0ICAgICAgaWYgKHZhbHVlIHx8IGxpc3QuZ2V0U2VsZWN0ZWRJZCAmJiBsaXN0LmdldFNlbGVjdGVkSWQoKSkgdmFsdWUgPSBzdWdnZXN0LmdldFN1Z2dlc3Rpb24odmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHR9LCBlZGl0b3JzLnRleHQpO1xuXHRlZGl0b3JzLnJpY2hzZWxlY3QgPSBleHBvcnRzLmV4dGVuZCh7XG5cdCAgZm9jdXM6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRQb3B1cCgpLmdldFZhbHVlKCk7XG5cdCAgfSxcblx0ICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgc3VnZ2VzdCA9IHRoaXMuY29uZmlnLmNvbGxlY3Rpb24gfHwgdGhpcy5jb25maWcub3B0aW9ucztcblx0ICAgIHRoaXMuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICBpZiAoc3VnZ2VzdCkgdGhpcy5nZXRQb3B1cCgpLmdldExpc3QoKS5kYXRhLmltcG9ydERhdGEoc3VnZ2VzdCk7XG5cdCAgICB0aGlzLmdldFBvcHVwKCkuc2hvdyh0aGlzLm5vZGUpO1xuXHQgICAgdGhpcy5nZXRQb3B1cCgpLnNldFZhbHVlKHZhbHVlKTtcblx0ICB9LFxuXHQgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0UG9wdXAoKS5nZXRMaXN0KCk7XG5cdCAgfSxcblx0ICBwb3B1cEluaXQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuXHQgICAgcG9wdXAubGlua0lucHV0KGRvY3VtZW50LmJvZHkpO1xuXHQgIH0sXG5cdCAgcG9wdXBUeXBlOiBcInJpY2hzZWxlY3RcIlxuXHR9LCBlZGl0b3JzLnBvcHVwKTtcblx0ZWRpdG9ycy5wYXNzd29yZCA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBjcmVhdGUoXCJkaXZcIiwge1xuXHQgICAgICBcImNsYXNzXCI6IFwid2ViaXhfZHRfZWRpdG9yXCJcblx0ICAgIH0sIFwiPGlucHV0IHR5cGU9J3Bhc3N3b3JkJyBhcmlhLWxhYmVsPSdcIiArIGdldExhYmVsKHRoaXMuY29uZmlnKSArIFwiJz5cIik7XG5cdCAgfVxuXHR9LCBlZGl0b3JzLnRleHQpO1xuXHRlZGl0b3JzLiRwb3B1cCA9IHtcblx0ICB0ZXh0OiB7XG5cdCAgICB2aWV3OiBcInBvcHVwXCIsXG5cdCAgICB3aWR0aDogMjUwLFxuXHQgICAgaGVpZ2h0OiAxNTAsXG5cdCAgICBib2R5OiB7XG5cdCAgICAgIHZpZXc6IFwidGV4dGFyZWFcIlxuXHQgICAgfVxuXHQgIH0sXG5cdCAgY29sb3I6IHtcblx0ICAgIHZpZXc6IFwicG9wdXBcIixcblx0ICAgIGJvZHk6IHtcblx0ICAgICAgdmlldzogXCJjb2xvcmJvYXJkXCJcblx0ICAgIH1cblx0ICB9LFxuXHQgIGRhdGU6IHtcblx0ICAgIHZpZXc6IFwicG9wdXBcIixcblx0ICAgIHdpZHRoOiAyNTAsXG5cdCAgICBoZWlnaHQ6IDI1MCxcblx0ICAgIHBhZGRpbmc6IDAsXG5cdCAgICBib2R5OiB7XG5cdCAgICAgIHZpZXc6IFwiY2FsZW5kYXJcIixcblx0ICAgICAgaWNvbnM6IHRydWUsXG5cdCAgICAgIGJvcmRlcmxlc3M6IHRydWVcblx0ICAgIH1cblx0ICB9LFxuXHQgIHJpY2hzZWxlY3Q6IHtcblx0ICAgIHZpZXc6IFwic3VnZ2VzdFwiLFxuXHQgICAgYm9keToge1xuXHQgICAgICB2aWV3OiBcImxpc3RcIixcblx0ICAgICAgc2VsZWN0OiB0cnVlXG5cdCAgICB9XG5cdCAgfSxcblx0ICBtdWx0aXNlbGVjdDoge1xuXHQgICAgdmlldzogXCJtdWx0aXN1Z2dlc3RcIixcblx0ICAgIHN1Z2dlc3Q6IHtcblx0ICAgICAgYnV0dG9uOiB0cnVlXG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdFx0QmVoYXZpb3I6RWRpdEFiaWxpdHkgLSBlbmFibGVzIGl0ZW0gb3BlcmF0aW9uIGZvciB0aGUgaXRlbXNcblx0XHRcblx0XHRAZXhwb3J0XG5cdFx0XHRlZGl0XG5cdFx0XHRzdG9wRWRpdFxuXHQqL1xuXG5cdHZhciBFZGl0QWJpbGl0eSA9IHtcblx0ICBkZWZhdWx0czoge1xuXHQgICAgZWRpdGFjdGlvbjogXCJjbGlja1wiXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy5fZWRpdG9ycyA9IHt9O1xuXHQgICAgdGhpcy5faW5fZWRpdF9tb2RlID0gMDtcblx0ICAgIHRoaXMuX2VkaXRfb3Blbl90aW1lID0gMDtcblx0ICAgIHRoaXMuX2NvbnRlbnRvYmouc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdCAgICBpZiAoY29uZmlnKSBjb25maWcub25EYmxDbGljayA9IGNvbmZpZy5vbkRibENsaWNrIHx8IHt9O1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgdGhpcy5fcmVmb2N1c19pbmxpbmVfZWRpdG9yKTsgLy93aGVuIHdlIGNhbGwgZXh0ZW5kIHRoZSBlZGl0YWJsZSBwcm9wIGNhbiBiZSBhbHJlYWR5IHNldFxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZWRpdGFibGUpIHRoaXMuX2luaXRfZWRpdF9ldmVudHNfb25jZSgpO1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcywgVW5kbyk7XG5cdCAgfSxcblx0ICBfcmVmb2N1c190cnk6IGZ1bmN0aW9uIChuZXdub2RlKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAvL0Nocm9tZSB0aHJvd3MgYW4gZXJyb3IgaWYgc2VsZWN0aW9uU3RhcnQgaXMgbm90IGFjY2Vzc2libGVcblx0ICAgICAgaWYgKHR5cGVvZiBuZXdub2RlLnNlbGVjdGlvblN0YXJ0ID09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBuZXdub2RlLnNlbGVjdGlvblN0YXJ0ID0gbmV3bm9kZS5zZWxlY3Rpb25FbmQgPSBuZXdub2RlLnZhbHVlLmxlbmd0aDtcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3bm9kZS5jcmVhdGVUZXh0UmFuZ2UgIT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICAgIHZhciByYW5nZSA9IG5ld25vZGUuY3JlYXRlVGV4dFJhbmdlKCk7XG5cdCAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuXHQgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblx0ICB9LFxuXHQgIF9yZWZvY3VzX2lubGluZV9lZGl0b3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBlZGl0b3IgPSB0aGlzLmdldEVkaXRvcigpO1xuXG5cdCAgICBpZiAoZWRpdG9yICYmIGVkaXRvci4kaW5saW5lICYmICFlZGl0b3IuZ2V0UG9wdXApIHtcblx0ICAgICAgdmFyIG5ld25vZGUgPSB0aGlzLl9sb2NhdGVJbnB1dChlZGl0b3IpO1xuXG5cdCAgICAgIGlmIChuZXdub2RlICYmIG5ld25vZGUgIT0gZWRpdG9yLm5vZGUpIHtcblx0ICAgICAgICB2YXIgdGV4dCA9IGVkaXRvci5ub2RlLnZhbHVlO1xuXHQgICAgICAgIGVkaXRvci5ub2RlID0gbmV3bm9kZTtcblx0ICAgICAgICBuZXdub2RlLnZhbHVlID0gdGV4dDtcblx0ICAgICAgICBuZXdub2RlLmZvY3VzKCk7XG5cblx0ICAgICAgICB0aGlzLl9yZWZvY3VzX3RyeShuZXdub2RlKTtcblx0ICAgICAgfSBlbHNlIHRoaXMuZWRpdFN0b3AoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGVkaXRhYmxlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuX2luaXRfZWRpdF9ldmVudHNfb25jZSgpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX2luaXRfZWRpdF9ldmVudHNfb25jZTogZnVuY3Rpb24gKCkge1xuXHQgICAgLy93aWxsIGNsb3NlIGVkaXRvciBvbiBhbnkgY2xpY2sgb3V0c2lkZVxuXHQgICAgYXR0YWNoRXZlbnQoXCJvbkVkaXRFbmRcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9pbl9lZGl0X21vZGUpIHRoaXMuZWRpdFN0b3AoKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIGF0dGFjaEV2ZW50KFwib25DbGlja1wiLCBiaW5kKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIC8vYnV0IGlnbm9yZSBjbGljayB3aGljaCBvcGVucyBlZGl0b3Jcblx0ICAgICAgaWYgKHRoaXMuX2luX2VkaXRfbW9kZSAmJiBuZXcgRGF0ZSgpIC0gdGhpcy5fZWRpdF9vcGVuX3RpbWUgPiAyMDApIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2xhc3RfZWRpdG9yIHx8IHRoaXMuX2xhc3RfZWRpdG9yLnBvcHVwVHlwZSB8fCAhZSB8fCAhdGhpcy5fbGFzdF9lZGl0b3Iubm9kZSB8fCAhdGhpcy5fbGFzdF9lZGl0b3Iubm9kZS5jb250YWlucyhlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpKSB0aGlzLmVkaXRTdG9wKCk7XG5cdCAgICAgIH1cblx0ICAgIH0sIHRoaXMpKTsgLy9wcm9wZXJ0eSBzaGVldCBoYXMgc2ltcGxlIGRhdGEgb2JqZWN0LCB3aXRob3V0IGV2ZW50c1xuXG5cdCAgICBpZiAodGhpcy5kYXRhLmF0dGFjaEV2ZW50KSB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGJpbmQoZnVuY3Rpb24gKG9sZGlkLCBuZXdpZCkge1xuXHQgICAgICB0aGlzLl9jaGFuZ2VFZGl0b3JJZChvbGRpZCwgbmV3aWQpO1xuXHQgICAgfSwgdGhpcykpOyAvL3doZW4gY2xpY2tpbmcgb24gcm93IC0gd2lsbCBzdGFydCBlZGl0b3JcblxuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uSXRlbUNsaWNrXCIsIGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuZWRpdGFibGUgJiYgdGhpcy5fc2V0dGluZ3MuZWRpdGFjdGlvbiA9PSBcImNsaWNrXCIpIHRoaXMuZWRpdChpZCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkl0ZW1EYmxDbGlja1wiLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmVkaXRhYmxlICYmIHRoaXMuX3NldHRpbmdzLmVkaXRhY3Rpb24gPT0gXCJkYmxjbGlja1wiKSB0aGlzLmVkaXQoaWQpO1xuXHQgICAgfSk7IC8vZWFjaCB0aW1lIHdoZW4gd2UgY2xpY2tpbmcgb24gaW5wdXQsIHJlc2V0IHRpbWVyIHRvIHByZXZlbnQgc2VsZi1jbG9zaW5nXG5cblx0ICAgIHRoaXMuX3Jlc2V0X2FjdGl2ZV9lZGl0b3IgPSBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fZWRpdF9vcGVuX3RpbWUgPSBuZXcgRGF0ZSgpO1xuXHQgICAgfSwgdGhpcyk7XG5cblx0ICAgIHRoaXMuX2luaXRfZWRpdF9ldmVudHNfb25jZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG5cdCAgICBpZiAodGhpcy5fY29tcG9uZW50X3NwZWNpZmljX2VkaXRfaW5pdCkgdGhpcy5fY29tcG9uZW50X3NwZWNpZmljX2VkaXRfaW5pdCgpO1xuXHQgIH0sXG5cdCAgX2hhbmRsZV9saXZlX2VkaXRzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmdldEVkaXRvcigpO1xuXG5cdCAgICAgIGlmIChlZGl0b3IgJiYgZWRpdG9yLmNvbmZpZy5saXZlRWRpdCkge1xuXHQgICAgICAgIHZhciBzdGF0ZSQkMSA9IHtcblx0ICAgICAgICAgIHZhbHVlOiBlZGl0b3IuZ2V0VmFsdWUoKSxcblx0ICAgICAgICAgIG9sZDogZWRpdG9yLnZhbHVlXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoc3RhdGUkJDEudmFsdWUgPT0gc3RhdGUkJDEub2xkKSByZXR1cm47XG5cdCAgICAgICAgZWRpdG9yLnZhbHVlID0gc3RhdGUkJDEudmFsdWU7XG5cblx0ICAgICAgICB0aGlzLl9zZXRfbmV3X3ZhbHVlKGVkaXRvciwgc3RhdGUkJDEudmFsdWUsIGZhbHNlKTtcblxuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25MaXZlRWRpdFwiLCBbc3RhdGUkJDEsIGVkaXRvcl0pO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzKTtcblx0ICB9LFxuXHQgIF9zaG93X2VkaXRvcl9mb3JtOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBmb3JtID0gdGhpcy5fc2V0dGluZ3MuZm9ybTtcblx0ICAgIGlmICh0eXBlb2YgZm9ybSAhPSBcInN0cmluZ1wiKSB0aGlzLl9zZXR0aW5ncy5mb3JtID0gZm9ybSA9IHVpKGZvcm0pLmNvbmZpZy5pZDtcblx0ICAgIGZvcm0gPSAkJChmb3JtKTtcblx0ICAgIHZhciByZWFsZm9ybSA9IGZvcm0uc2V0VmFsdWVzID8gZm9ybSA6IGZvcm0uZ2V0Q2hpbGRWaWV3cygpWzBdO1xuXHQgICAgcmVhbGZvcm0uc2V0VmFsdWVzKHRoaXMuZ2V0SXRlbShpZC5yb3cgfHwgaWQpKTtcblx0ICAgIGZvcm0uY29uZmlnLm1hc3RlciA9IHRoaXMuY29uZmlnLmlkO1xuXHQgICAgZm9ybS5zaG93KHRoaXMuZ2V0SXRlbU5vZGUoaWQpKTtcblx0ICAgIHZhciBmaXJzdCA9IHJlYWxmb3JtLmdldENoaWxkVmlld3MoKVswXTtcblx0ICAgIGlmIChmaXJzdC5mb2N1cykgZmlyc3QuZm9jdXMoKTtcblx0ICB9LFxuXHQgIGVkaXQ6IGZ1bmN0aW9uIChpZCwgcHJlc2VydmUsIHNob3cpIHtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MuZWRpdGFibGUgfHwgIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVFZGl0U3RhcnRcIiwgW2lkXSkpIHJldHVybjtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5mb3JtKSByZXR1cm4gdGhpcy5fc2hvd19lZGl0b3JfZm9ybShpZCk7XG5cblx0ICAgIHZhciBlZGl0b3IgPSB0aGlzLl9nZXRfZWRpdG9yX3R5cGUoaWQpO1xuXG5cdCAgICBpZiAoZWRpdG9yKSB7XG5cdCAgICAgIGlmICh0aGlzLmdldEVkaXRvcihpZCkpIHJldHVybjtcblx0ICAgICAgaWYgKCFwcmVzZXJ2ZSkgdGhpcy5lZGl0U3RvcCgpOyAvL3JlbmRlciBodG1sIGlucHV0XG5cblx0ICAgICAgYXNzZXJ0KGVkaXRvcnNbZWRpdG9yXSwgXCJJbnZhbGlkIGVkaXRvciB0eXBlOiBcIiArIGVkaXRvcik7XG5cdCAgICAgIHZhciB0eXBlID0gZXhwb3J0cy5leHRlbmQoe30sIGVkaXRvcnNbZWRpdG9yXSk7XG5cblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLl9pbml0X2VkaXRvcihpZCwgdHlwZSwgc2hvdyk7XG5cblx0ICAgICAgaWYgKHR5cGUuY29uZmlnLmxpdmVFZGl0KSB0aGlzLl9saXZlX2VkaXRzX2hhbmRsZXIgPSB0aGlzLmF0dGFjaEV2ZW50KFwib25LZXlQcmVzc1wiLCB0aGlzLl9oYW5kbGVfbGl2ZV9lZGl0cyk7XG5cdCAgICAgIHZhciBhcmVhID0gdHlwZS5nZXRQb3B1cCA/IHR5cGUuZ2V0UG9wdXAobm9kZSkuX3ZpZXdvYmogOiBub2RlO1xuXHQgICAgICBpZiAoYXJlYSkgX2V2ZW50KGFyZWEsIFwiY2xpY2tcIiwgdGhpcy5fcmVzZXRfYWN0aXZlX2VkaXRvcik7XG5cdCAgICAgIGlmIChub2RlKSBfZXZlbnQobm9kZSwgXCJjaGFuZ2VcIiwgdGhpcy5fb25fZWRpdG9yX2NoYW5nZSwge1xuXHQgICAgICAgIGJpbmQ6IHtcblx0ICAgICAgICAgIHZpZXc6IHRoaXMsXG5cdCAgICAgICAgICBpZDogaWRcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHR5cGUuZm9jdXMoKTtcblx0ICAgICAgaWYgKHRoaXMuJGZpeEVkaXRvcikgdGhpcy4kZml4RWRpdG9yKHR5cGUpOyAvL3NhdmUgdGltZSBvZiBjcmVhdGlvbiB0byBwcmV2ZW50IGluc3RhbnQgY2xvc2luZyBmcm9tIHRoZSBzYW1lIGNsaWNrXG5cblx0ICAgICAgdGhpcy5fZWRpdF9vcGVuX3RpbWUgPSBzdGF0ZS5lZGl0X29wZW5fdGltZSA9IG5ldyBEYXRlKCk7XG5cdCAgICAgIFVJTWFuYWdlci5zZXRGb2N1cyh0aGlzLCB0cnVlKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRWRpdFN0YXJ0XCIsIFtpZF0pO1xuXHQgICAgICByZXR1cm4gdHlwZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICBnZXRFZGl0b3I6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKCFpZCkgcmV0dXJuIHRoaXMuX2xhc3RfZWRpdG9yO1xuXHQgICAgcmV0dXJuIHRoaXMuX2VkaXRvcnNbaWRdO1xuXHQgIH0sXG5cdCAgX2NoYW5nZUVkaXRvcklkOiBmdW5jdGlvbiAob2xkaWQsIG5ld2lkKSB7XG5cdCAgICB2YXIgZWRpdG9yID0gdGhpcy5fZWRpdG9yc1tvbGRpZF07XG5cblx0ICAgIGlmIChlZGl0b3IpIHtcblx0ICAgICAgdGhpcy5fZWRpdG9yc1tuZXdpZF0gPSBlZGl0b3I7XG5cdCAgICAgIGVkaXRvci5pZCA9IG5ld2lkO1xuXHQgICAgICBkZWxldGUgdGhpcy5fZWRpdG9yc1tvbGRpZF07XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25fZWRpdG9yX2NoYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMudmlldy5oYXNFdmVudChcIm9uRWRpdG9yQ2hhbmdlXCIpKSB0aGlzLnZpZXcuY2FsbEV2ZW50KFwib25FZGl0b3JDaGFuZ2VcIiwgW3RoaXMuaWQsIHRoaXMudmlldy5nZXRFZGl0b3JWYWx1ZSh0aGlzLmlkKV0pO1xuXHQgIH0sXG5cdCAgX2dldF9lZGl0X2NvbmZpZzogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuXHQgIH0sXG5cdCAgX2luaXRfZWRpdG9yOiBmdW5jdGlvbiAoaWQsIHR5cGUsIHNob3cpIHtcblx0ICAgIHR5cGUuY29uZmlnID0gdGhpcy5fZ2V0X2VkaXRfY29uZmlnKGlkKTtcblx0ICAgIHZhciBub2RlID0gdHlwZS5yZW5kZXIoKTtcblx0ICAgIGlmICh0eXBlLiRpbmxpbmUpIG5vZGUgPSB0aGlzLl9sb2NhdGVJbnB1dChpZCk7XG5cdCAgICB0eXBlLm5vZGUgPSBub2RlO1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpOyAvL3ZhbHVlIGNhbiBiZSBjb25maWd1cmVkIGJ5IGVkaXRWYWx1ZSBvcHRpb25cblxuXHQgICAgdmFyIHZhbHVlID0gaXRlbVt0aGlzLl9zZXR0aW5ncy5lZGl0VmFsdWUgfHwgXCJ2YWx1ZVwiXTsgLy9pZiBwcm9wZXJ0eSB3YXMgbm90IGRlZmluZWQgLSB1c2UgZW1wdHkgdmFsdWVcblxuXHQgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkgdmFsdWUgPSBcIlwiO1xuXHQgICAgdHlwZS5zZXRWYWx1ZSh2YWx1ZSwgaXRlbSk7XG5cdCAgICB0eXBlLnZhbHVlID0gdmFsdWU7XG5cblx0ICAgIHRoaXMuX2FkZEVkaXRvcihpZCwgdHlwZSk7IC8vc2hvdyBpdCBvdmVyIGNlbGxcblxuXG5cdCAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHRoaXMuc2hvd0l0ZW0oaWQpO1xuXHQgICAgaWYgKCF0eXBlLiRpbmxpbmUpIHRoaXMuX3NpemVUb0NlbGwoaWQsIG5vZGUsIHRydWUpO1xuXHQgICAgaWYgKHR5cGUuYWZ0ZXJSZW5kZXIpIHR5cGUuYWZ0ZXJSZW5kZXIoKTtcblx0ICAgIHJldHVybiBub2RlO1xuXHQgIH0sXG5cdCAgX2xvY2F0ZV9jZWxsOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldEl0ZW1Ob2RlKGlkKTtcblx0ICB9LFxuXHQgIF9sb2NhdGVJbnB1dDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgY2VsbCA9IHRoaXMuX2xvY2F0ZV9jZWxsKGlkKTtcblxuXHQgICAgaWYgKGNlbGwpIGNlbGwgPSBjZWxsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF0gfHwgY2VsbDtcblx0ICAgIHJldHVybiBjZWxsO1xuXHQgIH0sXG5cdCAgX2dldF9lZGl0b3JfdHlwZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmVkaXRvcjtcblx0ICB9LFxuXHQgIF9hZGRFZGl0b3I6IGZ1bmN0aW9uIChpZCwgdHlwZSkge1xuXHQgICAgdHlwZS5pZCA9IGlkO1xuXHQgICAgdGhpcy5fZWRpdG9yc1tpZF0gPSB0aGlzLl9sYXN0X2VkaXRvciA9IHR5cGU7XG5cdCAgICB0aGlzLl9pbl9lZGl0X21vZGUrKztcblx0ICB9LFxuXHQgIF9yZW1vdmVFZGl0b3I6IGZ1bmN0aW9uIChlZGl0b3IpIHtcblx0ICAgIGlmICh0aGlzLl9sYXN0X2VkaXRvciA9PSBlZGl0b3IpIHRoaXMuX2xhc3RfZWRpdG9yID0gMDtcblx0ICAgIGlmIChlZGl0b3IuZGVzdHJveSkgZWRpdG9yLmRlc3Ryb3koKTtcblx0ICAgIGRlbGV0ZSBlZGl0b3IucG9wdXA7XG5cdCAgICBkZWxldGUgZWRpdG9yLm5vZGU7XG5cdCAgICBkZWxldGUgdGhpcy5fZWRpdG9yc1tlZGl0b3IuaWRdO1xuXHQgICAgdGhpcy5faW5fZWRpdF9tb2RlLS07XG5cdCAgfSxcblx0ICBmb2N1c0VkaXRvcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBpZiAoZWRpdG9yICYmIGVkaXRvci5mb2N1cykgZWRpdG9yLmZvY3VzKCk7XG5cdCAgfSxcblx0ICBlZGl0Q2FuY2VsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmVkaXRTdG9wKG51bGwsIG51bGwsIHRydWUpO1xuXHQgIH0sXG5cdCAgX2FwcGx5Q2hhbmdlczogZnVuY3Rpb24gKGVsKSB7XG5cdCAgICBpZiAoZWwpIHtcblx0ICAgICAgdmFyIGVkID0gdGhpcy5nZXRFZGl0b3IoKTtcblx0ICAgICAgaWYgKGVkICYmIGVkLmdldFBvcHVwICYmIGVkLmdldFBvcHVwKCkgPT0gZWwuZ2V0VG9wUGFyZW50VmlldygpKSByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuZWRpdFN0b3AoKTtcblx0ICB9LFxuXHQgIGVkaXRTdG9wOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmICh0aGlzLl9lZGl0X3N0b3ApIHJldHVybjtcblx0ICAgIHRoaXMuX2VkaXRfc3RvcCA9IDE7XG5cdCAgICB2YXIgY2FuY2VsID0gYXJndW1lbnRzWzJdO1xuXHQgICAgdmFyIHJlc3VsdCA9IDE7XG5cblx0ICAgIGlmICghaWQpIHtcblx0ICAgICAgdGhpcy5fZm9yX2VhY2hfZWRpdG9yKGZ1bmN0aW9uIChlZGl0b3IpIHtcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHQgKiB0aGlzLl9lZGl0U3RvcChlZGl0b3IsIGNhbmNlbCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHJlc3VsdCA9IHRoaXMuX2VkaXRTdG9wKHRoaXMuX2VkaXRvcnNbaWRdLCBjYW5jZWwpO1xuXG5cdCAgICB0aGlzLl9lZGl0X3N0b3AgPSAwO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9LFxuXHQgIF9jZWxsUG9zaXRpb246IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIGh0bWwgPSB0aGlzLmdldEl0ZW1Ob2RlKGlkKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGxlZnQ6IGh0bWwub2Zmc2V0TGVmdCxcblx0ICAgICAgdG9wOiBodG1sLm9mZnNldFRvcCxcblx0ICAgICAgaGVpZ2h0OiBodG1sLm9mZnNldEhlaWdodCxcblx0ICAgICAgd2lkdGg6IGh0bWwub2Zmc2V0V2lkdGgsXG5cdCAgICAgIHBhcmVudDogdGhpcy5fY29udGVudG9ialxuXHQgICAgfTtcblx0ICB9LFxuXHQgIF9zaXplVG9DZWxsOiBmdW5jdGlvbiAoaWQsIG5vZGUsIGlubGluZSkge1xuXHQgICAgLy9mYWtlIGlucHV0c1xuXHQgICAgaWYgKCFub2RlLnN0eWxlKSByZXR1cm47XG5cblx0ICAgIHZhciBwb3MkJDEgPSB0aGlzLl9jZWxsUG9zaXRpb24oaWQpO1xuXG5cdCAgICBub2RlLnN0eWxlLnRvcCA9IHBvcyQkMS50b3AgKyBcInB4XCI7XG5cdCAgICBub2RlLnN0eWxlLmxlZnQgPSBwb3MkJDEubGVmdCArIFwicHhcIjtcblx0ICAgIG5vZGUuc3R5bGUud2lkdGggPSBwb3MkJDEud2lkdGggLSAxICsgXCJweFwiO1xuXHQgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBwb3MkJDEuaGVpZ2h0IC0gMSArIFwicHhcIjtcblx0ICAgIG5vZGUudG9wID0gcG9zJCQxLnRvcDsgLy9sYXRlciB3aWxsIGJlIHVzZWQgZHVyaW5nIHktc2Nyb2xsaW5nXG5cblx0ICAgIGlmIChpbmxpbmUpIHBvcyQkMS5wYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdCAgfSxcblx0ICBfZm9yX2VhY2hfZWRpdG9yOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuXHQgICAgZm9yICh2YXIgZWRpdG9yIGluIHRoaXMuX2VkaXRvcnMpIHtcblx0ICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIHRoaXMuX2VkaXRvcnNbZWRpdG9yXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZWRpdFN0b3A6IGZ1bmN0aW9uIChlZGl0b3IsIGlnbm9yZSkge1xuXHQgICAgaWYgKCFlZGl0b3IgfHwgc3RhdGUuX2ZpbmFsX2Rlc3RydWN0aW9uKSByZXR1cm47XG5cdCAgICB2YXIgc3RhdGUkJDEgPSB7XG5cdCAgICAgIHZhbHVlOiB0aGlzLl9nZXRfbmV3X3ZhbHVlKGVkaXRvciksXG5cdCAgICAgIG9sZDogZWRpdG9yLnZhbHVlXG5cdCAgICB9O1xuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUVkaXRTdG9wXCIsIFtzdGF0ZSQkMSwgZWRpdG9yLCBpZ25vcmVdKSkge1xuXHQgICAgICBpZiAoIWlnbm9yZSkge1xuXHQgICAgICAgIC8vc3BlY2lhbCBjYXNlLCBzdGF0ZS5vbGQgPSAwLCBzdGF0ZS52YWx1ZSA9IFwiXCJcblx0ICAgICAgICAvL3dlIG5lZWQgdG8gc3RhdGUub2xkIHRvIHN0cmluZywgdG8gZGV0ZWN0IHRoZSBjaGFuZ2Vcblx0ICAgICAgICB2YXIgb2xkID0gc3RhdGUkJDEub2xkO1xuXHQgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUkJDEudmFsdWUgPT0gXCJzdHJpbmdcIikgb2xkICs9IFwiXCI7XG5cblx0ICAgICAgICBpZiAob2xkICE9IHN0YXRlJCQxLnZhbHVlIHx8IGVkaXRvci5jb25maWcubGl2ZUVkaXQpIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fc2V0X25ld192YWx1ZShlZGl0b3IsIHN0YXRlJCQxLnZhbHVlLCB0cnVlKTtcblxuXHQgICAgICAgICAgdGhpcy51cGRhdGVJdGVtKGVkaXRvci5yb3cgfHwgZWRpdG9yLmlkLCBpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZWRpdG9yLiRpbmxpbmUpIGVkaXRvci5ub2RlID0gbnVsbDtlbHNlIHJlbW92ZShlZGl0b3Iubm9kZSk7XG5cdCAgICAgIHZhciBwb3B1cCA9IGVkaXRvci5jb25maWcuc3VnZ2VzdDtcblx0ICAgICAgaWYgKHBvcHVwICYmIHR5cGVvZiBwb3B1cCA9PSBcInN0cmluZ1wiKSAkJChwb3B1cCkuaGlkZSgpO1xuXG5cdCAgICAgIHRoaXMuX3JlbW92ZUVkaXRvcihlZGl0b3IpO1xuXG5cdCAgICAgIGlmICh0aGlzLl9saXZlX2VkaXRzX2hhbmRsZXIpIHRoaXMuZGV0YWNoRXZlbnQodGhpcy5fbGl2ZV9lZGl0c19oYW5kbGVyKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRWRpdFN0b3BcIiwgW3N0YXRlJCQxLCBlZGl0b3IsIGlnbm9yZV0pO1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSxcblx0ICB2YWxpZGF0ZUVkaXRvcjogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnJ1bGVzKSB7XG5cdCAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmdldEVkaXRvcihpZCk7XG5cdCAgICAgIHZhciBrZXkgPSBlZGl0b3IuY29sdW1uIHx8IHRoaXMuX3NldHRpbmdzLmVkaXRWYWx1ZSB8fCBcInZhbHVlXCI7XG5cdCAgICAgIHZhciBydWxlID0gdGhpcy5fc2V0dGluZ3MucnVsZXNba2V5XTtcblx0ICAgICAgdmFyIGFsbCA9IHRoaXMuX3NldHRpbmdzLnJ1bGVzLiRhbGw7XG5cblx0ICAgICAgaWYgKHJ1bGUgfHwgYWxsKSB7XG5cdCAgICAgICAgdmFyIG9iaiA9IHRoaXMuZGF0YS5nZXRJdGVtKGVkaXRvci5yb3cgfHwgZWRpdG9yLmlkKTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcblx0ICAgICAgICB2YXIgaW5wdXQgPSBlZGl0b3IuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICAgICAgaWYgKHJ1bGUpIHJlc3VsdCA9IHJ1bGUuY2FsbCh0aGlzLCB2YWx1ZSwgb2JqLCBrZXkpO1xuXHQgICAgICAgIGlmIChhbGwpIHJlc3VsdCA9IGFsbC5jYWxsKHRoaXMsIHZhbHVlLCBvYmosIGtleSkgJiYgcmVzdWx0O1xuXHQgICAgICAgIGlmIChyZXN1bHQpIHJlbW92ZUNzcyhpbnB1dCwgXCJ3ZWJpeF9pbnZhbGlkXCIpO2Vsc2UgYWRkQ3NzKGlucHV0LCBcIndlYml4X2ludmFsaWRcIik7XG5cdCAgICAgICAgY2FsbEV2ZW50KFwib25MaXZlVmFsaWRhdGlvblwiLCBbZWRpdG9yLCByZXN1bHQsIG9iaiwgdmFsdWVdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0sXG5cdCAgZ2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIGVkaXRvcjtcblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSBlZGl0b3IgPSB0aGlzLl9sYXN0X2VkaXRvcjtlbHNlIGVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yKGlkKTtcblx0ICAgIGlmIChlZGl0b3IpIHJldHVybiBlZGl0b3IuZ2V0VmFsdWUoKTtcblx0ICB9LFxuXHQgIGdldEVkaXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xhc3RfZWRpdG9yIHx8IGZhbHNlO1xuXHQgIH0sXG5cdCAgZWRpdE5leHQ6IGZ1bmN0aW9uIChuZXh0LCBmcm9tKSB7XG5cdCAgICBuZXh0ID0gbmV4dCAhPT0gZmFsc2U7IC8vdHJ1ZSBieSBkZWZhdWx0XG5cblx0ICAgIGlmICh0aGlzLl9pbl9lZGl0X21vZGUgPT0gMSB8fCBmcm9tKSB7XG5cdCAgICAgIC8vb25seSBpZiBvbmUgZWRpdG9yIGlzIGFjdGl2ZVxuXHQgICAgICB2YXIgZWRpdG9yX25leHQgPSB0aGlzLl9maW5kX2NlbGxfbmV4dCh0aGlzLl9sYXN0X2VkaXRvciB8fCBmcm9tLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fZ2V0X2VkaXRvcl90eXBlKGlkKSkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9LCBuZXh0KTtcblxuXHQgICAgICBpZiAodGhpcy5lZGl0U3RvcCgpKSB7XG5cdCAgICAgICAgLy9pZiB3ZSB3YXMgYWJsZSB0byBjbG9zZSBwcmV2aW91cyBlZGl0b3Jcblx0ICAgICAgICBpZiAoZWRpdG9yX25leHQpIHtcblx0ICAgICAgICAgIC8vYW5kIHRoZXJlIGlzIGEgbmV3IHRhcmdldFxuXHQgICAgICAgICAgdGhpcy5lZGl0KGVkaXRvcl9uZXh0KTsgLy9pbml0IG5ldyBlZGl0b3JcblxuXHQgICAgICAgICAgdGhpcy5fYWZ0ZXJfZWRpdF9uZXh0KGVkaXRvcl9uZXh0KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vc3RhYiwgdXNlZCBpbiBkYXRhdGFibGVcblx0ICBfYWZ0ZXJfZWRpdF9uZXh0OiBmdW5jdGlvbiAoKSB7fSxcblx0ICBfZmluZF9jZWxsX25leHQ6IGZ1bmN0aW9uIChzdGFydCwgY2hlY2ssIGRpcmVjdGlvbikge1xuXHQgICAgdmFyIHJvdyA9IHRoaXMuZ2V0SW5kZXhCeUlkKHN0YXJ0LmlkKTtcblx0ICAgIHZhciBvcmRlciA9IHRoaXMuZGF0YS5vcmRlcjtcblxuXHQgICAgaWYgKGRpcmVjdGlvbikge1xuXHQgICAgICBmb3IgKHZhciBpID0gcm93ICsgMTsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGNoZWNrLmNhbGwodGhpcywgb3JkZXJbaV0pKSByZXR1cm4gb3JkZXJbaV07XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAodmFyIF9pID0gcm93IC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuXHQgICAgICAgIGlmIChjaGVjay5jYWxsKHRoaXMsIG9yZGVyW19pXSkpIHJldHVybiBvcmRlcltfaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICBfZ2V0X25ld192YWx1ZTogZnVuY3Rpb24gKGVkaXRvcikge1xuXHQgICAgcmV0dXJuIGVkaXRvci5nZXRWYWx1ZSgpO1xuXHQgIH0sXG5cdCAgX3NldF9uZXdfdmFsdWU6IGZ1bmN0aW9uIChlZGl0b3IsIG5ld192YWx1ZSwgY29weSQkMSkge1xuXHQgICAgdmFyIGl0ZW0gPSBjb3B5JCQxID8ge30gOiB0aGlzLmdldEl0ZW0oZWRpdG9yLmlkKTtcblx0ICAgIGl0ZW1bdGhpcy5fc2V0dGluZ3MuZWRpdFZhbHVlIHx8IFwidmFsdWVcIl0gPSBuZXdfdmFsdWU7XG5cdCAgICByZXR1cm4gaXRlbTtcblx0ICB9XG5cdH07XG5cblx0dmFyIEZsZXhMYXlvdXQgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuJHZpZXcuY2xhc3NOYW1lICs9IFwiIHdlYml4X2ZsZXhsYXlvdXRcIjtcblx0ICB9LFxuXHQgIF9maXhfdmVydGljYWxfbGF5b3V0OiBmdW5jdGlvbiAoKSB7fSxcblx0ICBfYmVmb3JlUmVzZXRCb3JkZXJzOiBmdW5jdGlvbiAoKSB7fSxcblx0ICBfYWZ0ZXJSZXNldEJvcmRlcnM6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBkZWJ1Z19zaXplX2JveF9zdGFydCh0aGlzLCB0cnVlKTtcblx0ICAgIHZhciB3ID0gMCxcblx0ICAgICAgICBoID0gMCxcblx0ICAgICAgICBnID0gdGhpcy5fc2V0dGluZ3MuZ3Jhdml0eTtcblx0ICAgIHRoaXMuX3NpemVzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHNpemUgPSB0aGlzLl9jZWxsc1tpXS4kZ2V0U2l6ZSgwLCAwKTtcblxuXHQgICAgICB0aGlzLl9zaXplcy5wdXNoKHNpemUpO1xuXG5cdCAgICAgIHcgPSBNYXRoLm1heCh3LCBzaXplWzBdKTtcblx0ICAgICAgaCA9IE1hdGgubWF4KGgsIHNpemVbMl0pO1xuXHQgICAgfVxuXG5cdCAgICB3ICs9IHRoaXMuX3BhZGRpbmcubGVmdCArIHRoaXMuX3BhZGRpbmcucmlnaHQ7XG5cdCAgICBoICs9IHRoaXMuX3BhZGRpbmcudG9wICsgdGhpcy5fcGFkZGluZy5ib3R0b207XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3Mud2lkdGgpIHcgPSBNYXRoLm1heCh3LCB0aGlzLl9zZXR0aW5ncy53aWR0aCk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGVpZ2h0KSBoID0gTWF0aC5tYXgoaCwgdGhpcy5fc2V0dGluZ3MuaGVpZ2h0KTtcblx0ICAgIHZhciBzZWxmX3NpemUgPSBbdywgMTAwMDAwLCBoLCAxMDAwMDAsIGddO1xuXHQgICAgZGVidWdfc2l6ZV9ib3hfZW5kKHRoaXMsIHNlbGZfc2l6ZSk7XG5cdCAgICByZXR1cm4gc2VsZl9zaXplO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlc2l6ZSgpO1xuXHQgIH0sXG5cdCAgX3NldF9jaGlsZF9zaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSkgcmV0dXJuO1xuXHQgICAgdmFyIHN0ID0gdGhpcy4kdmlldy5zdHlsZTtcblx0ICAgIHZhciBtYXJnaW4gPSBNYXRoLnJvdW5kKHRoaXMuX21hcmdpbiAvIDIpO1xuXHQgICAgc3QucGFkZGluZ1RvcCA9IHRoaXMuX3BhZGRpbmcudG9wIC0gbWFyZ2luICsgXCJweFwiO1xuXHQgICAgc3QucGFkZGluZ0JvdHRvbSA9IHRoaXMuX3BhZGRpbmcuYm90dG9tIC0gbWFyZ2luICsgXCJweFwiO1xuXHQgICAgc3QucGFkZGluZ0xlZnQgPSB0aGlzLl9wYWRkaW5nLmxlZnQgLSBtYXJnaW4gKyBcInB4XCI7XG5cdCAgICBzdC5wYWRkaW5nUmlnaHQgPSB0aGlzLl9wYWRkaW5nLnJpZ2h0IC0gbWFyZ2luICsgXCJweFwiO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tpXS5fc2V0dGluZ3MuaGlkZGVuKSBjb250aW51ZTtcblx0ICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jZWxsc1tpXS4kdmlldztcblx0ICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplc1tpXTtcblx0ICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX2NlbGxzW2ldLl9zZXR0aW5ncztcblxuXHQgICAgICBpZiAodmlldykge1xuXHQgICAgICAgIHZpZXcuc3R5bGUubWluV2lkdGggPSBzaXplWzBdICsgXCJweFwiO1xuXHQgICAgICAgIGlmIChzaXplWzFdIDwgMTAwMDAwICYmIHNpemVbMV0gIT0gc2l6ZVswXSkgdmlldy5zdHlsZS5tYXhXaWR0aCA9IHNpemVbMV0gKyBcInB4XCI7XG5cdCAgICAgICAgdmlldy5zdHlsZS5mbGV4QmFzaXMgPSBjb25maWcuZmxleEJhc2lzIHx8IHNpemVbMF0gKyBcInB4XCI7XG5cdCAgICAgICAgdmlldy5zdHlsZS5mbGV4R3JvdyA9IGNvbmZpZy5mbGV4R3JvdyB8fCAoc2l6ZVsxXSAhPSBzaXplWzBdID8gc2l6ZVs0XSA6IDApO1xuXHQgICAgICAgIHZpZXcuc3R5bGUuaGVpZ2h0ID0gc2l6ZVszXSAhPSBzaXplWzJdID8gXCJhdXRvXCIgOiBzaXplWzJdICsgXCJweFwiO1xuXHQgICAgICAgIHZpZXcuc3R5bGUubWluSGVpZ2h0ID0gc2l6ZVsyXSArIFwicHhcIjtcblx0ICAgICAgICBpZiAoc2l6ZVszXSA8IDEwMDAwMCAmJiBzaXplWzNdICE9IHNpemVbMl0pIHZpZXcuc3R5bGUubWF4SGVpZ2h0ID0gc2l6ZVszXSArIFwicHhcIjtcblx0ICAgICAgICB2aWV3LnN0eWxlLm1hcmdpbiA9IG1hcmdpbiArIFwicHhcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgd2hzID0gW107XG5cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLl9jZWxscy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgaWYgKHRoaXMuX2NlbGxzW19pXS5fc2V0dGluZ3MuaGlkZGVuKSBjb250aW51ZTtcblx0ICAgICAgdmFyIF92aWV3ID0gdGhpcy5fY2VsbHNbX2ldLiR2aWV3O1xuXHQgICAgICB3aHNbX2ldID0gW192aWV3Lm9mZnNldFdpZHRoLCBfdmlldy5vZmZzZXRIZWlnaHRdO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0aGlzLl9jZWxscy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tfaTJdLl9zZXR0aW5ncy5oaWRkZW4pIGNvbnRpbnVlO1xuXHQgICAgICB2YXIgY2VsbCA9IHRoaXMuX2NlbGxzW19pMl07XG5cdCAgICAgIHZhciBfdmlldzIgPSBjZWxsLiR2aWV3O1xuXG5cdCAgICAgIGlmIChfdmlldzIpIHtcblx0ICAgICAgICBjZWxsLl9zZXR0aW5ncy5mbGV4ID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgX3NpemUgPSB0aGlzLl9zaXplc1tfaTJdO1xuXHQgICAgICAgIHZhciBoID0gX3NpemVbMl0gPT0gX3NpemVbM10gPyBfc2l6ZVsyXSA6IHdoc1tfaTJdWzFdO1xuXHQgICAgICAgIGNlbGwuJHNldFNpemUod2hzW19pMl1bMF0sIGgpO1xuXHQgICAgICAgIGNlbGwuX3NldHRpbmdzLmZsZXggPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLiRoZWlnaHQgPSB0aGlzLl9jb250ZW50X2hlaWdodCA9IHRoaXMuJHZpZXcuc2Nyb2xsSGVpZ2h0O1xuXHQgICAgdGhpcy4kdmlldy5zdHlsZS5oZWlnaHQgPSB0aGlzLl9jb250ZW50X2hlaWdodCArIFwicHhcIjtcblx0ICB9XG5cdH07XG5cblx0dmFyIEdyb3VwTWV0aG9kcyA9IHtcblx0ICBzdW06IGZ1bmN0aW9uIChwcm9wZXJ0eSwgZGF0YSkge1xuXHQgICAgZGF0YSA9IGRhdGEgfHwgdGhpcztcblx0ICAgIHZhciBzdW1tID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KHByb3BlcnR5KGRhdGFbaV0pLCAxMCk7XG5cdCAgICAgIGlmICghaXNOYU4obnVtKSkgc3VtbSArPSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzdW1tO1xuXHQgIH0sXG5cdCAgbWluOiBmdW5jdGlvbiAocHJvcGVydHksIGRhdGEpIHtcblx0ICAgIGRhdGEgPSBkYXRhIHx8IHRoaXM7XG5cdCAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbnVtID0gcGFyc2VGbG9hdChwcm9wZXJ0eShkYXRhW2ldKSwgMTApO1xuXHQgICAgICBpZiAoaXNOYU4obnVtKSkgY29udGludWU7XG5cdCAgICAgIGlmIChudW0gPCBtaW4pIG1pbiA9IG51bTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG1pbiA9PT0gSW5maW5pdHkgPyAwIDogbWluICogMTtcblx0ICB9LFxuXHQgIG1heDogZnVuY3Rpb24gKHByb3BlcnR5LCBkYXRhKSB7XG5cdCAgICBkYXRhID0gZGF0YSB8fCB0aGlzO1xuXHQgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KHByb3BlcnR5KGRhdGFbaV0pLCAxMCk7XG5cdCAgICAgIGlmIChpc05hTihudW0pKSBjb250aW51ZTtcblx0ICAgICAgaWYgKG51bSA+IG1heCkgbWF4ID0gbnVtO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbWF4ID09PSAtSW5maW5pdHkgPyAwIDogbWF4ICogMTtcblx0ICB9LFxuXHQgIGNvdW50OiBmdW5jdGlvbiAocHJvcGVydHksIGRhdGEpIHtcblx0ICAgIHZhciBjb3VudCA9IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgc29tZSA9IHByb3BlcnR5KGRhdGFbaV0pO1xuXHQgICAgICBpZiAoc29tZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc29tZSAhPT0gXCJ1bmRlZmluZWRcIikgY291bnQrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNvdW50O1xuXHQgIH0sXG5cdCAgYW55OiBmdW5jdGlvbiAocHJvcGVydHksIGRhdGEpIHtcblx0ICAgIHJldHVybiBwcm9wZXJ0eShkYXRhWzBdKTtcblx0ICB9LFxuXHQgIHN0cmluZzogZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICByZXR1cm4gcHJvcGVydHkuJG5hbWU7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBHcm91cFN0b3JlID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25DbGVhckFsbFwiLCB0aGlzLl9yZXNldF9ncm91cHMpO1xuXHQgIH0sXG5cdCAgX3Jlc2V0X2dyb3VwczogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fbm90X2dyb3VwZWRfb3JkZXIgPSB0aGlzLl9ub3RfZ3JvdXBlZF9wdWxsID0gbnVsbDtcblx0ICAgIHRoaXMuX2dyb3VwX2xldmVsX2NvdW50ID0gMDtcblx0ICB9LFxuXHQgIHVuZ3JvdXA6IGZ1bmN0aW9uIChza2lwUmVuZGVyKSB7XG5cdCAgICBpZiAodGhpcy5nZXRCcmFuY2hJbmRleCkgcmV0dXJuIHRoaXMuX3VuZ3JvdXBfdHJlZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdCAgICBpZiAodGhpcy5fbm90X2dyb3VwZWRfb3JkZXIpIHtcblx0ICAgICAgdGhpcy5vcmRlciA9IHRoaXMuX25vdF9ncm91cGVkX29yZGVyO1xuXHQgICAgICB0aGlzLnB1bGwgPSB0aGlzLl9ub3RfZ3JvdXBlZF9wdWxsO1xuXHQgICAgICB0aGlzLl9ub3RfZ3JvdXBlZF9wdWxsID0gdGhpcy5fbm90X2dyb3VwZWRfb3JkZXIgPSBudWxsO1xuXHQgICAgICBpZiAoIXNraXBSZW5kZXIpIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dyb3VwX3Byb2Nlc3Npbmc6IGZ1bmN0aW9uIChzY2hlbWUpIHtcblx0ICAgIHRoaXMuYmxvY2tFdmVudCgpO1xuXHQgICAgdGhpcy5ncm91cChzY2hlbWUpO1xuXHQgICAgdGhpcy51bmJsb2NrRXZlbnQoKTtcblx0ICB9LFxuXHQgIF9ncm91cF9wcm9wX2FjY2Vzc29yOiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2YWw7XG5cblx0ICAgIHZhciBhY2MgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHJldHVybiBvYmpbdmFsXTtcblx0ICAgIH07XG5cblx0ICAgIGFjYy4kbmFtZSA9IHZhbDtcblx0ICAgIHJldHVybiBhY2M7XG5cdCAgfSxcblx0ICBncm91cDogZnVuY3Rpb24gKHN0YXRzKSB7XG5cdCAgICBpZiAodGhpcy5nZXRCcmFuY2hJbmRleCkgcmV0dXJuIHRoaXMuX2dyb3VwX3RyZWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIGlmICh0eXBlb2Ygc3RhdHMgPT0gXCJzdHJpbmdcIikgc3RhdHMgPSB7XG5cdCAgICAgIGJ5OiBzdGF0cyxcblx0ICAgICAgbWFwOiB7fVxuXHQgICAgfTtcblx0ICAgIHZhciBpbnB1dCA9IHR5cGVvZiBzdGF0cy5ieSA9PSBcImZ1bmN0aW9uXCIgPyBcInZhbHVlXCIgOiBzdGF0cy5ieTtcblxuXHQgICAgdmFyIGtleSA9IHRoaXMuX2dyb3VwX3Byb3BfYWNjZXNzb3Ioc3RhdHMuYnkpO1xuXG5cdCAgICBpZiAoIXN0YXRzLm1hcFtpbnB1dF0pIHN0YXRzLm1hcFtpbnB1dF0gPSBbaW5wdXQsIHRoaXMuX2FueV07XG5cdCAgICB2YXIgZ3JvdXBzID0ge307XG5cdCAgICB2YXIgbGFiZWxzID0gW107XG5cdCAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgdmFyIGN1cnJlbnQgPSBrZXkoZGF0YSk7XG5cblx0ICAgICAgaWYgKCFncm91cHNbY3VycmVudF0pIHtcblx0ICAgICAgICBsYWJlbHMucHVzaCh7XG5cdCAgICAgICAgICBpZDogY3VycmVudCxcblx0ICAgICAgICAgICRncm91cDogdHJ1ZSxcblx0ICAgICAgICAgICRyb3c6IHN0YXRzLnJvd1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGdyb3Vwc1tjdXJyZW50XSA9IHRvQXJyYXkoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGdyb3Vwc1tjdXJyZW50XS5wdXNoKGRhdGEpO1xuXHQgICAgfSk7XG5cblx0ICAgIGZvciAodmFyIHByb3AgaW4gc3RhdHMubWFwKSB7XG5cdCAgICAgIHZhciBmdW5jdG9yID0gc3RhdHMubWFwW3Byb3BdWzFdIHx8IFwiYW55XCI7XG5cblx0ICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5fZ3JvdXBfcHJvcF9hY2Nlc3NvcihzdGF0cy5tYXBbcHJvcF1bMF0pO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgZnVuY3RvciAhPSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICBhc3NlcnQoR3JvdXBNZXRob2RzW2Z1bmN0b3JdLCBcInVua25vd24gZ3JvdXBpbmcgcnVsZTogXCIgKyBmdW5jdG9yKTtcblx0ICAgICAgICBmdW5jdG9yID0gR3JvdXBNZXRob2RzW2Z1bmN0b3JdO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBsYWJlbHNbaV1bcHJvcF0gPSBmdW5jdG9yLmNhbGwodGhpcywgcHJvcGVydHksIGdyb3Vwc1tsYWJlbHNbaV0uaWRdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9ub3RfZ3JvdXBlZF9vcmRlciA9IHRoaXMub3JkZXI7XG5cdCAgICB0aGlzLl9ub3RfZ3JvdXBlZF9wdWxsID0gdGhpcy5wdWxsO1xuXHQgICAgdGhpcy5vcmRlciA9IHRvQXJyYXkoKTtcblx0ICAgIHRoaXMucHVsbCA9IHt9O1xuXG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFiZWxzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLmlkKGxhYmVsc1tfaV0pO1xuXHQgICAgICB0aGlzLnB1bGxbaWRdID0gbGFiZWxzW19pXTtcblx0ICAgICAgdGhpcy5vcmRlci5wdXNoKGlkKTtcblx0ICAgICAgaWYgKHRoaXMuX3NjaGVtZV9pbml0KSB0aGlzLl9zY2hlbWVfaW5pdChsYWJlbHNbX2ldKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbXSk7XG5cdCAgfSxcblx0ICBfZ3JvdXBfdHJlZTogZnVuY3Rpb24gKGlucHV0LCBwYXJlbnQpIHtcblx0ICAgIHRoaXMuX2dyb3VwX2xldmVsX2NvdW50ID0gKHRoaXMuX2dyb3VwX2xldmVsX2NvdW50IHx8IDApICsgMTsgLy9zdXBwb3J0cyBzaW1wbGlmaWVkIGdyb3VwIGJ5IHN5bnRheFxuXG5cdCAgICB2YXIgc3RhdHM7XG5cblx0ICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICBzdGF0cyA9IHtcblx0ICAgICAgICBieTogdGhpcy5fZ3JvdXBfcHJvcF9hY2Nlc3NvcihpbnB1dCksXG5cdCAgICAgICAgbWFwOiB7fVxuXHQgICAgICB9O1xuXHQgICAgICBzdGF0cy5tYXBbaW5wdXRdID0gW2lucHV0XTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICBzdGF0cyA9IHtcblx0ICAgICAgICBieTogaW5wdXQsXG5cdCAgICAgICAgbWFwOiB7fVxuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHN0YXRzID0gaW5wdXQ7IC8vcHJlcGFyZVxuXG5cblx0ICAgIHZhciBsZXZlbDtcblx0ICAgIGlmIChwYXJlbnQpIGxldmVsID0gdGhpcy5nZXRJdGVtKHBhcmVudCkuJGxldmVsO2Vsc2Uge1xuXHQgICAgICBwYXJlbnQgPSAwO1xuXHQgICAgICBsZXZlbCA9IDA7XG5cdCAgICB9XG5cdCAgICB2YXIgb3JkZXIgPSB0aGlzLmJyYW5jaFtwYXJlbnRdO1xuXG5cdCAgICB2YXIga2V5ID0gdGhpcy5fZ3JvdXBfcHJvcF9hY2Nlc3NvcihzdGF0cy5ieSk7IC8vcnVuXG5cblxuXHQgICAgdmFyIHRvcGJyYW5jaCA9IFtdO1xuXHQgICAgdmFyIGxhYmVscyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRJdGVtKG9yZGVyW2ldKTtcblx0ICAgICAgdmFyIGN1cnJlbnQgPSBrZXkoZGF0YSk7XG5cdCAgICAgIHZhciBjdXJyZW50X2lkID0gbGV2ZWwgKyBcIiRcIiArIGN1cnJlbnQ7XG5cdCAgICAgIHZhciBhbmNlc3RvciA9IHRoaXMuYnJhbmNoW2N1cnJlbnRfaWRdO1xuXG5cdCAgICAgIGlmICghYW5jZXN0b3IpIHtcblx0ICAgICAgICB2YXIgbmV3aXRlbSA9IHRoaXMucHVsbFtjdXJyZW50X2lkXSA9IHtcblx0ICAgICAgICAgIGlkOiBjdXJyZW50X2lkLFxuXHQgICAgICAgICAgdmFsdWU6IGN1cnJlbnQsXG5cdCAgICAgICAgICAkZ3JvdXA6IHRydWUsXG5cdCAgICAgICAgICAkcm93OiBzdGF0cy5yb3dcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmICh0aGlzLl9zY2hlbWVfaW5pdCkgdGhpcy5fc2NoZW1lX2luaXQobmV3aXRlbSk7XG5cdCAgICAgICAgbGFiZWxzLnB1c2gobmV3aXRlbSk7XG5cdCAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmJyYW5jaFtjdXJyZW50X2lkXSA9IFtdO1xuXHQgICAgICAgIGFuY2VzdG9yLl9mb3JtYXRoID0gW107XG5cdCAgICAgICAgdG9wYnJhbmNoLnB1c2goY3VycmVudF9pZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBhbmNlc3Rvci5wdXNoKGRhdGEuaWQpO1xuXG5cdCAgICAgIGFuY2VzdG9yLl9mb3JtYXRoLnB1c2goZGF0YSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYnJhbmNoW3BhcmVudF0gPSB0b3BicmFuY2g7XG5cblx0ICAgIGZvciAodmFyIHByb3AgaW4gc3RhdHMubWFwKSB7XG5cdCAgICAgIHZhciBmdW5jdG9yID0gc3RhdHMubWFwW3Byb3BdWzFdIHx8IFwiYW55XCI7XG5cblx0ICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5fZ3JvdXBfcHJvcF9hY2Nlc3NvcihzdGF0cy5tYXBbcHJvcF1bMF0pO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgZnVuY3RvciAhPSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICBhc3NlcnQoR3JvdXBNZXRob2RzW2Z1bmN0b3JdLCBcInVua25vd24gZ3JvdXBpbmcgcnVsZTogXCIgKyBmdW5jdG9yKTtcblx0ICAgICAgICBmdW5jdG9yID0gR3JvdXBNZXRob2RzW2Z1bmN0b3JdO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGFiZWxzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICBsYWJlbHNbX2kyXVtwcm9wXSA9IGZ1bmN0b3IuY2FsbCh0aGlzLCBwcm9wZXJ0eSwgdGhpcy5icmFuY2hbbGFiZWxzW19pMl0uaWRdLl9mb3JtYXRoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsYWJlbHMubGVuZ3RoOyBfaTMrKykge1xuXHQgICAgICB2YXIgZ3JvdXAgPSBsYWJlbHNbX2kzXTtcblx0ICAgICAgaWYgKHRoaXMuaGFzRXZlbnQoXCJvbkdyb3VwQ3JlYXRlZFwiKSkgdGhpcy5jYWxsRXZlbnQoXCJvbkdyb3VwQ3JlYXRlZFwiLCBbZ3JvdXAuaWQsIGdyb3VwLnZhbHVlLCB0aGlzLmJyYW5jaFtncm91cC5pZF0uX2Zvcm1hdGhdKTtcblxuXHQgICAgICBpZiAoc3RhdHMuZm9vdGVyKSB7XG5cdCAgICAgICAgdmFyIGlkID0gXCJmb290ZXIkXCIgKyBncm91cC5pZDtcblx0ICAgICAgICB2YXIgZm9vdGVyID0gdGhpcy5wdWxsW2lkXSA9IHtcblx0ICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICRmb290ZXI6IHRydWUsXG5cdCAgICAgICAgICB2YWx1ZTogZ3JvdXAudmFsdWUsXG5cdCAgICAgICAgICAkbGV2ZWw6IGxldmVsLFxuXHQgICAgICAgICAgJGNvdW50OiAwLFxuXHQgICAgICAgICAgJHBhcmVudDogZ3JvdXAuaWQsXG5cdCAgICAgICAgICAkcm93OiBzdGF0cy5mb290ZXIucm93XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIGZvciAodmFyIF9wcm9wIGluIHN0YXRzLmZvb3Rlcikge1xuXHQgICAgICAgICAgdmFyIF9mdW5jdG9yID0gc3RhdHMuZm9vdGVyW19wcm9wXVsxXSB8fCBcImFueVwiO1xuXG5cdCAgICAgICAgICB2YXIgX3Byb3BlcnR5ID0gdGhpcy5fZ3JvdXBfcHJvcF9hY2Nlc3NvcihzdGF0cy5mb290ZXJbX3Byb3BdWzBdKTtcblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBfZnVuY3RvciAhPSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgICAgICAgYXNzZXJ0KEdyb3VwTWV0aG9kc1tfZnVuY3Rvcl0sIFwidW5rbm93biBncm91cGluZyBydWxlOiBcIiArIF9mdW5jdG9yKTtcblx0ICAgICAgICAgICAgX2Z1bmN0b3IgPSBHcm91cE1ldGhvZHNbX2Z1bmN0b3JdO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBmb290ZXJbX3Byb3BdID0gX2Z1bmN0b3IuY2FsbCh0aGlzLCBfcHJvcGVydHksIHRoaXMuYnJhbmNoW2xhYmVsc1tfaTNdLmlkXS5fZm9ybWF0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5icmFuY2hbZ3JvdXAuaWRdLnB1c2goZm9vdGVyLmlkKTtcblx0ICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uR3JvdXBGb290ZXJcIiwgW2Zvb3Rlci5pZCwgZm9vdGVyLnZhbHVlLCB0aGlzLmJyYW5jaFtncm91cC5pZF0uX2Zvcm1hdGhdKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGRlbGV0ZSB0aGlzLmJyYW5jaFtncm91cC5pZF0uX2Zvcm1hdGg7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2ZpeF9ncm91cF9sZXZlbHModG9wYnJhbmNoLCBwYXJlbnQsIGxldmVsICsgMSk7XG5cblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW10pO1xuXHQgIH0sXG5cdCAgX3VuZ3JvdXBfdHJlZTogZnVuY3Rpb24gKHNraXBSZW5kZXIsIHBhcmVudCwgZm9yY2UpIHtcblx0ICAgIC8vbm90IGdyb3VwZWRcblx0ICAgIGlmICghZm9yY2UgJiYgIXRoaXMuX2dyb3VwX2xldmVsX2NvdW50KSByZXR1cm47XG5cdCAgICB0aGlzLl9ncm91cF9sZXZlbF9jb3VudCA9IE1hdGgubWF4KDAsIHRoaXMuX2dyb3VwX2xldmVsX2NvdW50IC0gMSk7XG5cdCAgICBwYXJlbnQgPSBwYXJlbnQgfHwgMDtcblx0ICAgIHZhciBvcmRlciA9IFtdO1xuXHQgICAgdmFyIHRvcG9yZGVyID0gdGhpcy5icmFuY2hbcGFyZW50XTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3BvcmRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaWQgPSB0b3BvcmRlcltpXTtcblx0ICAgICAgdmFyIGJyYW5jaCA9IHRoaXMuYnJhbmNoW2lkXTtcblx0ICAgICAgaWYgKGJyYW5jaCkgb3JkZXIgPSBvcmRlci5jb25jYXQoYnJhbmNoKTtcblx0ICAgICAgZGVsZXRlIHRoaXMucHVsbFtpZF07XG5cdCAgICAgIGRlbGV0ZSB0aGlzLmJyYW5jaFtpZF07XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuYnJhbmNoW3BhcmVudF0gPSBvcmRlcjtcblxuXHQgICAgZm9yICh2YXIgX2k0ID0gb3JkZXIubGVuZ3RoIC0gMTsgX2k0ID49IDA7IF9pNC0tKSB7XG5cdCAgICAgIGlmICh0aGlzLnB1bGxbb3JkZXJbX2k0XV0uJGZvb3Rlcikgb3JkZXIuc3BsaWNlKF9pNCwgMSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2ZpeF9ncm91cF9sZXZlbHMob3JkZXIsIDAsIDEpO1xuXG5cdCAgICBpZiAoIXNraXBSZW5kZXIpIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW10pO1xuXHQgIH0sXG5cdCAgX2ZpeF9ncm91cF9sZXZlbHM6IGZ1bmN0aW9uIChicmFuY2gsIHBhcmVudCwgbGV2ZWwpIHtcblx0ICAgIGlmIChwYXJlbnQpIHRoaXMuZ2V0SXRlbShwYXJlbnQpLiRjb3VudCA9IGJyYW5jaC5sZW5ndGg7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJhbmNoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5wdWxsW2JyYW5jaFtpXV07XG5cdCAgICAgIGl0ZW0uJGxldmVsID0gbGV2ZWw7XG5cdCAgICAgIGl0ZW0uJHBhcmVudCA9IHBhcmVudDtcblx0ICAgICAgdmFyIG5leHQgPSB0aGlzLmJyYW5jaFtpdGVtLmlkXTtcblx0ICAgICAgaWYgKG5leHQpIHRoaXMuX2ZpeF9ncm91cF9sZXZlbHMobmV4dCwgaXRlbS5pZCwgbGV2ZWwgKyAxKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIEdyb3VwID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLmRhdGEsIEdyb3VwU3RvcmUpOyAvL2luIGNhc2Ugb2YgcGxhaW4gc3RvcmUgd2UgbmVlZCB0byByZW1vdmUgc3RvcmUgb3JpZ2luYWwgZGF0YXNldFxuXG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmRhdGEuX25vdF9ncm91cGVkX29yZGVyID0gdGhpcy5kYXRhLl9ub3RfZ3JvdXBlZF9wdWxsID0gbnVsbDtcblx0ICAgICAgdGhpcy5fZ3JvdXBfbGV2ZWxfY291bnQgPSAwO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgIH0sXG5cdCAgZ3JvdXA6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuZGF0YS51bmdyb3VwKHRydWUpO1xuXHQgICAgdGhpcy5kYXRhLmdyb3VwKGNvbmZpZyk7XG5cdCAgfSxcblx0ICB1bmdyb3VwOiBmdW5jdGlvbiAoc2tpcFJlbmRlcikge1xuXHQgICAgdGhpcy5kYXRhLnVuZ3JvdXAoc2tpcFJlbmRlcik7XG5cdCAgfVxuXHR9O1xuXG5cdC8qYXJpYS1zdHlsZSBoYW5kbGluZyBmb3Igb3B0aW9ucyBvZiBtdWx0aXBsZS12YWx1ZSBjb250cm9scyAocmFkaW8sIHNlZ21lbnRlZCwgdGFiYmFyKSovXG5cblx0dmFyIEhUTUxPcHRpb25zID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICBpZiAoJGFjdGl2ZS5jdXN0b21SYWRpbyB8fCB0aGlzLmFkZE9wdGlvbikgdGhpcy4kcmVhZHkucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF9ldmVudChfdGhpcy4kdmlldywgXCJrZXlkb3duXCIsIF90aGlzLl9tb3ZlU2VsZWN0aW9uLCB7XG5cdCAgICAgICAgYmluZDogX3RoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIF9mb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFVSU1hbmFnZXIuY2FuRm9jdXModGhpcykpIHJldHVybiBmYWxzZTtcblxuXHQgICAgdmFyIGlucHV0ID0gdGhpcy5fZ2V0SW5wdXROb2RlKCk7XG5cblx0ICAgIGlmIChpbnB1dCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGlucHV0W2ldLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID09IFwiMFwiKSB7XG5cdCAgICAgICAgICBpbnB1dFtpXS5mb2N1cygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2JsdXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuX2dldElucHV0Tm9kZSgpO1xuXG5cdCAgICBpZiAoaW5wdXQpIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGlucHV0W2ldLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID09IFwiMFwiKSBpbnB1dFtpXS5ibHVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfbW92ZVNlbGVjdGlvbjogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBjb2RlID0gZS53aGljaCB8fCBlLmtleUNvZGU7XG5cdCAgICB2YXIgc3RhcnRDb2RlID0gdGhpcy5hZGRPcHRpb24gPyAzNCA6IDM2O1xuXG5cdCAgICBpZiAoY29kZSA+IHN0YXJ0Q29kZSAmJiBjb2RlIDwgNDEpIHtcblx0ICAgICAgcHJldmVudEV2ZW50KGUpO1xuXHQgICAgICB2YXIgaW5kZXgkJDE7XG5cblx0ICAgICAgdmFyIGlucCA9IHRoaXMuX2dldElucHV0Tm9kZSgpO1xuXG5cdCAgICAgIGlmIChjb2RlID09IDM1KSBpbmRleCQkMSA9IGlucC5sZW5ndGggLSAxO2Vsc2UgaWYgKGNvZGUgPT09IDM2KSBpbmRleCQkMSA9IDA7ZWxzZSB7XG5cdCAgICAgICAgdmFyIGRpciA9IGNvZGUgPT09IDM3IHx8IGNvZGUgPT09IDM4ID8gLTEgOiAxO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpbnBbaV0uZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgPT0gXCIwXCIpIHtcblx0ICAgICAgICAgICAgaW5kZXgkJDEgPSBpICsgZGlyO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXgkJDEgPCAwKSBpbmRleCQkMSA9IGlucC5sZW5ndGggLSAxO2Vsc2UgaWYgKGluZGV4JCQxID49IGlucC5sZW5ndGgpIGluZGV4JCQxID0gMDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFpc1VuZGVmaW5lZChpbmRleCQkMSkpIHtcblx0ICAgICAgICB2YXIgaWQgPSBpbnBbaW5kZXgkJDFdLmdldEF0dHJpYnV0ZShcImJ1dHRvbl9pZFwiKTtcblx0ICAgICAgICB0aGlzLnNldFZhbHVlKGlkKTtcblx0ICAgICAgICBpbnBbaW5kZXgkJDFdLmZvY3VzKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9nZXRfdG9vbHRpcF9kYXRhOiBmdW5jdGlvbiAodCwgZSkge1xuXHQgICAgdmFyIG5vZGUgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cblx0ICAgIHdoaWxlIChub2RlICYmICFub2RlLndlYml4X3Rvb2x0aXApIHtcblx0ICAgICAgdmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJ3ZWJpeF90X2lkXCIpO1xuXHQgICAgICBpZiAoaWQpIHJldHVybiB0aGlzLmdldE9wdGlvbihpZCk7XG5cdCAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgZ2V0T3B0aW9uOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBvcHRpb25zID0gdGhpcy5fY2hlY2tfb3B0aW9ucyh0aGlzLl9zZXR0aW5ncy5vcHRpb25zKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChvcHRpb25zW2ldLmlkID09IGlkKSByZXR1cm4gb3B0aW9uc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBIdG1sTWFwID0gZXhwb3J0cy5wcm90byh7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgIHRoaXMuX2lkID0gXCJtYXBfXCIgKyB1aWQoKTtcblx0ICAgIHRoaXMuX2tleSA9IGtleTtcblx0ICAgIHRoaXMuX21hcCA9IFtdO1xuXHQgICAgdGhpcy5fYXJlYXMgPSBbXTtcblx0ICB9LFxuXHQgIGFkZFJlY3Q6IGZ1bmN0aW9uIChpZCwgcG9pbnRzLCB1c2VyZGF0YSkge1xuXHQgICAgdGhpcy5fY3JlYXRlTWFwQXJlYShpZCwgXCJSRUNUXCIsIHBvaW50cywgdXNlcmRhdGEpO1xuXHQgIH0sXG5cdCAgYWRkUG9seTogZnVuY3Rpb24gKGlkLCBwb2ludHMsIHVzZXJkYXRhKSB7XG5cdCAgICB0aGlzLl9jcmVhdGVNYXBBcmVhKGlkLCBcIlBPTFlcIiwgcG9pbnRzLCB1c2VyZGF0YSk7XG5cdCAgfSxcblx0ICBfY3JlYXRlTWFwQXJlYTogZnVuY3Rpb24gKGlkLCBzaGFwZSwgY29vcmRzLCB1c2VyZGF0YSkge1xuXHQgICAgdmFyIGV4dHJhX2RhdGEgPSBcIlwiO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gNCkgZXh0cmFfZGF0YSA9IFwidXNlcmRhdGE9J1wiICsgdXNlcmRhdGEgKyBcIidcIjtcblxuXHQgICAgdGhpcy5fbWFwLnB1c2goXCI8YXJlYSBcIiArIHRoaXMuX2tleSArIFwiPSdcIiArIGlkICsgXCInIHNoYXBlPSdcIiArIHNoYXBlICsgXCInIGNvb3Jkcz0nXCIgKyBjb29yZHMuam9pbigpICsgXCInIFwiICsgZXh0cmFfZGF0YSArIFwiPjwvYXJlYT5cIik7XG5cblx0ICAgIHRoaXMuX2FyZWFzLnB1c2goe1xuXHQgICAgICBpbmRleDogdXNlcmRhdGEsXG5cdCAgICAgIHBvaW50czogY29vcmRzXG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIGFkZFNlY3RvcjogZnVuY3Rpb24gKGlkLCBhbHBoYTAsIGFscGhhMSwgeCwgeSwgUiwga3ksIHVzZXJkYXRhKSB7XG5cdCAgICB2YXIgcG9pbnRzID0gW107XG5cdCAgICBwb2ludHMucHVzaCh4KTtcblx0ICAgIHBvaW50cy5wdXNoKE1hdGguZmxvb3IoeSAqIGt5KSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSBhbHBoYTA7IGkgPCBhbHBoYTE7IGkgKz0gTWF0aC5QSSAvIDE4KSB7XG5cdCAgICAgIHBvaW50cy5wdXNoKE1hdGguZmxvb3IoeCArIFIgKiBNYXRoLmNvcyhpKSkpO1xuXHQgICAgICBwb2ludHMucHVzaChNYXRoLmZsb29yKCh5ICsgUiAqIE1hdGguc2luKGkpKSAqIGt5KSk7XG5cdCAgICB9XG5cblx0ICAgIHBvaW50cy5wdXNoKE1hdGguZmxvb3IoeCArIFIgKiBNYXRoLmNvcyhhbHBoYTEpKSk7XG5cdCAgICBwb2ludHMucHVzaChNYXRoLmZsb29yKCh5ICsgUiAqIE1hdGguc2luKGFscGhhMSkpICoga3kpKTtcblx0ICAgIHBvaW50cy5wdXNoKHgpO1xuXHQgICAgcG9pbnRzLnB1c2goTWF0aC5mbG9vcih5ICoga3kpKTtcblx0ICAgIHJldHVybiB0aGlzLmFkZFBvbHkoaWQsIHBvaW50cywgdXNlcmRhdGEpO1xuXHQgIH0sXG5cdCAgaGlkZTogZnVuY3Rpb24gKG9iaiwgZGF0YSwgbW9kZSkge1xuXHQgICAgaWYgKG9iai5xdWVyeVNlbGVjdG9yQWxsKSB7XG5cdCAgICAgIHZhciBub2RlcyA9IG9iai5xdWVyeVNlbGVjdG9yQWxsKFwiYXJlYVt1c2VyZGF0YT1cXFwiXCIgKyBkYXRhICsgXCJcXFwiXVwiKTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG5vZCA9IG5vZGVzW2ldO1xuXG5cdCAgICAgICAgaWYgKG1vZGUpIHtcblx0ICAgICAgICAgIGlmIChub2QuZ2V0QXR0cmlidXRlKFwiY29vcmRzXCIpKSB7XG5cdCAgICAgICAgICAgIG5vZC5jb29yZHNkaXMgPSBub2QuZ2V0QXR0cmlidXRlKFwiY29vcmRzXCIpO1xuXHQgICAgICAgICAgICBub2Quc2V0QXR0cmlidXRlKFwiY29vcmRzXCIsIFwiXCIpO1xuXHQgICAgICAgICAgICBub2QuY29vcmRzID0gXCJcIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKCFtb2RlKSB7XG5cdCAgICAgICAgICBpZiAobm9kLmNvb3Jkc2Rpcykge1xuXHQgICAgICAgICAgICBub2Quc2V0QXR0cmlidXRlKFwiY29vcmRzXCIsIG5vZC5jb29yZHNkaXMpO1xuXHQgICAgICAgICAgICBub2QuY29vcmRzID0gbm9kLmNvb3Jkc2Rpcztcblx0ICAgICAgICAgICAgbm9kLmNvb3Jkc2RpcyA9IFwiXCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbm9kZXNbaV0uc3R5bGUuZGlzcGxheSA9IG1vZGUgPyBcIm5vbmVcIiA6IFwiXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIGQgPSBjcmVhdGUoXCJESVZcIik7XG5cdCAgICBkLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlOyB3aWR0aDoxMDAlOyBoZWlnaHQ6MTAwJTsgdG9wOjBweDsgbGVmdDowcHg7XCI7XG5cdCAgICBvYmouYXBwZW5kQ2hpbGQoZCk7XG5cdCAgICB2YXIgc3JjID0gZW52LmlzSUUgPyBcIlwiIDogXCJzcmM9J2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEVnQVNBSUFBQVAvLy8vLy8veUg1QkFVVUFBRUFMQUFBQUFBU0FCSUFBQUlQakkrcHkrMFBvNXkwMm91ejNwd1hBRHM9J1wiO1xuXHQgICAgZC5pbm5lckhUTUwgPSBcIjxtYXAgaWQ9J1wiICsgdGhpcy5faWQgKyBcIicgbmFtZT0nXCIgKyB0aGlzLl9pZCArIFwiJz5cIiArIHRoaXMuX21hcC5qb2luKFwiXFxuXCIpICsgXCI8L21hcD48aW1nIFwiICsgc3JjICsgXCIgY2xhc3M9J3dlYml4X21hcF9pbWcnIHVzZW1hcD0nI1wiICsgdGhpcy5faWQgKyBcIic+XCI7XG5cdCAgICBvYmouX2h0bWxtYXAgPSBkOyAvL2ZvciBjbGVhcmluZyByb3V0aW5lXG5cblx0ICAgIHRoaXMuX21hcCA9IFtdO1xuXHQgIH1cblx0fSk7XG5cblx0dmFyIElkU3BhY2UgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG5cdCAgICB0aGlzLl90cmFuc2xhdGVfaWRzID0ge307XG5cdCAgICB0aGlzLmdldFRvcFBhcmVudFZpZXcgPSB0aGlzLl9nZXRfc2VsZiA9IGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH0sIHRoaXMpO1xuXG5cdCAgICB0aGlzLl9ydW5faW5uZXJfaW5pdF9sb2dpYygpO1xuXG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX3J1bl9hZnRlcl9pbm5lcl9pbml0X2xvZ2ljKTtcblx0ICB9LFxuXHQgICQkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tpZF07XG5cdCAgfSxcblx0ICBpbm5lcklkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVfaWRzW2lkXTtcblx0ICB9LFxuXHQgIF9ydW5faW5uZXJfaW5pdF9sb2dpYzogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fcHJldl9nbG9iYWxfY29sID0gc3RhdGUuX2dsb2JhbF9jb2xsZWN0aW9uO1xuXHQgICAgc3RhdGUuX2dsb2JhbF9jb2xsZWN0aW9uID0gdGhpcztcblx0ICB9LFxuXHQgIF9ydW5fYWZ0ZXJfaW5uZXJfaW5pdF9sb2dpYzogZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9lbGVtZW50cykge1xuXHQgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9lbGVtZW50c1tuYW1lXTtcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50ICYmIGlucHV0Lm1hcEV2ZW50ICYmICFpbnB1dC5fZXZzX21hcC5vbml0ZW1jbGljaykgaW5wdXQubWFwRXZlbnQoe1xuXHQgICAgICAgIG9uaXRlbWNsaWNrOiB0aGlzXG5cdCAgICAgIH0pO1xuXHQgICAgICBpbnB1dC5nZXRUb3BQYXJlbnRWaWV3ID0gdGhpcy5fZ2V0X3NlbGY7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLl9nbG9iYWxfY29sbGVjdGlvbiA9IHRoaXMuX3ByZXZfZ2xvYmFsX2NvbDtcblx0ICAgIHRoaXMuX3ByZXZfZ2xvYmFsX2NvbCA9IDA7XG5cdCAgfSxcblx0ICBfZGVzdHJveV9jaGlsZDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICBkZWxldGUgdGhpcy5fZWxlbWVudHNbaWRdO1xuXHQgIH0sXG5cdCAgdWk6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3J1bl9pbm5lcl9pbml0X2xvZ2ljKCk7XG5cblx0ICAgIHZhciB0ZW1wID0gdWkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHQgICAgdGhpcy5fcnVuX2FmdGVyX2lubmVyX2luaXRfbG9naWMoKTtcblxuXHQgICAgcmV0dXJuIHRlbXA7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBLZXlzTmF2aWdhdGlvbiA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuZ2V0U2VsZWN0ZWRJZCkgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgdGhpcy5fc2V0X2ZvY3VzYWJsZV9pdGVtKTtcblx0ICAgIGlmICh0aGlzLm1vdmVTZWxlY3Rpb24pIHRoaXMuYXR0YWNoRXZlbnQoXCJvblRhYkZvY3VzXCIsIHRoaXMuX3NldF9pdGVtX2ZvY3VzKTtcblx0ICB9LFxuXHQgIF9zZXRfaXRlbV9mb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuZ2V0U2VsZWN0ZWRJZCkge1xuXHQgICAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUpO1xuXHQgICAgICBpZiAoIXNlbC5sZW5ndGggfHwgIXRoaXMuZ2V0SXRlbU5vZGUoc2VsWzBdKSkgdGhpcy5tb3ZlU2VsZWN0aW9uKFwiZG93blwiKTsgLy9zZWxlY3QgYW5kIHNob3dcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zZXRfZm9jdXNhYmxlX2l0ZW06IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGVkSWQodHJ1ZSk7XG5cblx0ICAgIGlmICghc2VsLmxlbmd0aCB8fCAhdGhpcy5nZXRJdGVtTm9kZShzZWxbMF0pKSB7XG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5fZGF0YW9iai5xdWVyeVNlbGVjdG9yKFwiW1wiICsgdGhpcy5faWQgKyBcIl1cIik7XG5cblx0ICAgICAgaWYgKG5vZGUpIG5vZGUuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX25hdmlnYXRpb25faGVscGVyOiBmdW5jdGlvbiAobW9kZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3LCBlKSB7XG5cdCAgICAgIHZhciB0YWcgPSBlLnNyY0VsZW1lbnQgfHwgZS50YXJnZXQ7IC8vaWdub3JlIGNsaXBib2FyZCBsaXN0ZW5lclxuXG5cdCAgICAgIGlmICghdGFnLmdldEF0dHJpYnV0ZShcIndlYml4aWdub3JlXCIpKSB7XG5cdCAgICAgICAgLy9pZ25vcmUgaG90a2V5cyBpZiBmb2N1cyBpbiB0aGUgY29tbW9uIGlucHV0XG5cdCAgICAgICAgLy90byBhbGxvdyBub3JtYWwgdGV4dCBlZGl0IG9wZXJhdGlvbnNcblx0ICAgICAgICB2YXIgbmFtZSA9IHRhZy50YWdOYW1lO1xuXHQgICAgICAgIGlmIChuYW1lID09IFwiSU5QVVRcIiB8fCBuYW1lID09IFwiVEVYVEFSRUFcIiB8fCBuYW1lID09IFwiU0VMRUNUXCIpIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHZpZXcgJiYgdmlldy5tb3ZlU2VsZWN0aW9uICYmIHZpZXcuY29uZmlnLm5hdmlnYXRpb24gJiYgIXZpZXcuX2luX2VkaXRfbW9kZSkge1xuXHQgICAgICAgIHByZXZlbnRFdmVudChlKTtcblx0ICAgICAgICByZXR1cm4gdmlldy5tb3ZlU2VsZWN0aW9uKG1vZGUsIHtcblx0ICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuXHQgICAgICAgICAgY3RybDogZS5jdHJsS2V5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBtb3ZlU2VsZWN0aW9uOiBmdW5jdGlvbiAobW9kZSwgZGV0YWlscywgZm9jdXMpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGlmIChjb25maWcuZGlzYWJsZWQpIHJldHVybjsgLy9nZXQgZXhpc3Rpbmcgc2VsZWN0aW9uXG5cblx0ICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKTtcblx0ICAgIHZhciB4X2xheW91dCA9IHRoaXMuY291bnQgJiYgKGNvbmZpZy5sYXlvdXQgPT0gXCJ4XCIgfHwgY29uZmlnLnhDb3VudCA+IDEpO1xuXG5cdCAgICBpZiAoKG1vZGUgPT0gXCJyaWdodFwiIHx8IG1vZGUgPT0gXCJsZWZ0XCIpICYmIHRoaXMuX3BhcmVudF9tZW51KSB7XG5cdCAgICAgIHZhciBwYXJlbnQgPSAkJCh0aGlzLl9wYXJlbnRfbWVudSk7XG5cblx0ICAgICAgcGFyZW50Ll9oaWRlX3N1Yl9tZW51KHRydWUpO1xuXG5cdCAgICAgIGlmIChwYXJlbnQuY29uZmlnLmxheW91dCA9PT0gXCJ4XCIpIHBhcmVudC5tb3ZlU2VsZWN0aW9uKG1vZGUpO2Vsc2UgVUlNYW5hZ2VyLnNldEZvY3VzKHBhcmVudCk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFzZWxlY3RlZC5sZW5ndGggJiYgdGhpcy5jb3VudCgpKSB7XG5cdCAgICAgIGlmIChtb2RlID09IFwiZG93blwiIHx8IG1vZGUgPT0gXCJyaWdodFwiICYmIHhfbGF5b3V0KSBtb2RlID0gXCJ0b3BcIjtlbHNlIGlmIChtb2RlID09IFwidXBcIiB8fCBtb2RlID09IFwibGVmdFwiICYmIHhfbGF5b3V0KSBtb2RlID0gXCJib3R0b21cIjtlbHNlIHJldHVybjtcblx0ICAgICAgc2VsZWN0ZWQgPSBbdGhpcy5nZXRGaXJzdElkKCldO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09IDEpIHtcblx0ICAgICAgLy9pZiB3ZSBoYXZlIGEgc2VsZWN0aW9uXG5cdCAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWRbMF07XG5cdCAgICAgIHZhciBwcmV2ID0gc2VsZWN0ZWQ7XG5cdCAgICAgIGlmIChtb2RlID09IFwibGVmdFwiICYmIHRoaXMuY2xvc2UpIHJldHVybiB0aGlzLmNsb3NlKHNlbGVjdGVkKTtcblx0ICAgICAgaWYgKG1vZGUgPT0gXCJyaWdodFwiICYmIHRoaXMub3BlbikgcmV0dXJuIHRoaXMub3BlbihzZWxlY3RlZCk7ZWxzZSBpZiAobW9kZSA9PSBcInRvcFwiKSB7XG5cdCAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLmdldEZpcnN0SWQoKTtcblx0ICAgICAgfSBlbHNlIGlmIChtb2RlID09IFwiYm90dG9tXCIpIHtcblx0ICAgICAgICBzZWxlY3RlZCA9IHRoaXMuZ2V0TGFzdElkKCk7XG5cdCAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBcInVwXCIgfHwgbW9kZSA9PSBcImxlZnRcIiB8fCBtb2RlID09IFwicGd1cFwiKSB7XG5cdCAgICAgICAgdmFyIGluZGV4JCQxID0gdGhpcy5nZXRJbmRleEJ5SWQoc2VsZWN0ZWQpO1xuXHQgICAgICAgIHZhciBzdGVwID0gbW9kZSA9PSBcInBndXBcIiA/IDEwIDogMTtcblx0ICAgICAgICBzZWxlY3RlZCA9IHRoaXMuZ2V0SWRCeUluZGV4KE1hdGgubWF4KDAsIGluZGV4JCQxIC0gc3RlcCkpO1xuXHQgICAgICB9IGVsc2UgaWYgKG1vZGUgPT0gXCJkb3duXCIgfHwgbW9kZSA9PSBcInJpZ2h0XCIgfHwgbW9kZSA9PSBcInBnZG93blwiKSB7XG5cdCAgICAgICAgdmFyIF9pbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUlkKHNlbGVjdGVkKTtcblxuXHQgICAgICAgIHZhciBfc3RlcCA9IG1vZGUgPT0gXCJwZ2Rvd25cIiA/IDEwIDogMTtcblxuXHQgICAgICAgIHNlbGVjdGVkID0gdGhpcy5nZXRJZEJ5SW5kZXgoTWF0aC5taW4odGhpcy5jb3VudCgpIC0gMSwgX2luZGV4ICsgX3N0ZXApKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhc3NlcnQoZmFsc2UsIFwiTm90IHN1cHBvcnRlZCBzZWxlY3Rpb24gbW92aW5nIG1vZGVcIik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9za2lwX2l0ZW0pIHNlbGVjdGVkID0gdGhpcy5fc2tpcF9pdGVtKHNlbGVjdGVkLCBwcmV2LCBtb2RlKTtcblx0ICAgICAgdGhpcy5zaG93SXRlbShzZWxlY3RlZCk7XG5cdCAgICAgIHRoaXMuc2VsZWN0KHNlbGVjdGVkKTtcblx0ICAgICAgaWYgKHRoaXMuZ2V0U3ViTWVudSAmJiB0aGlzLmdldFN1Yk1lbnUoc2VsZWN0ZWQpKSB0aGlzLl9tb3VzZV9tb3ZlX2FjdGl2YXRpb24oc2VsZWN0ZWQsIHRoaXMuZ2V0SXRlbU5vZGUoc2VsZWN0ZWQpKTtcblxuXHQgICAgICBpZiAoIXRoaXMuY29uZmlnLmNsaXBib2FyZCAmJiBmb2N1cyAhPT0gZmFsc2UpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0SXRlbU5vZGUoc2VsZWN0ZWQpO1xuXHQgICAgICAgIGlmIChub2RlKSBub2RlLmZvY3VzKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgbmF2aWdhdGlvbl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgLy91c2luZyBnbG9iYWwgZmxhZyB0byBhcHBseSBob3RrZXkgb25seSBvbmNlXG5cdCAgICBpZiAodmFsdWUgJiYgIVVJTWFuYWdlci5fZ2xvYmFsX25hdl9ncmlkX2hvdGtleXMpIHtcblx0ICAgICAgVUlNYW5hZ2VyLl9nbG9iYWxfbmF2X2dyaWRfaG90a2V5cyA9IHRydWU7IC8vaG90a2V5cyB3aWxsIHJlYWN0IG9uIGFueSBjb21wb25lbnQgYnV0IHdpbGwgbm90IHdvcmsgaW4gZWRpdCBtb2RlXG5cdCAgICAgIC8veW91IGNhbiBkZWZpbmUgbW92ZVNlbGVjdGlvbiBtZXRob2QgdG8gaGFuZGxlIG5hdmlnYXRpb24ga2V5c1xuXG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJ1cFwiLCB0aGlzLl9uYXZpZ2F0aW9uX2hlbHBlcihcInVwXCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcImRvd25cIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJkb3duXCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcInJpZ2h0XCIsIHRoaXMuX25hdmlnYXRpb25faGVscGVyKFwicmlnaHRcIikpO1xuXHQgICAgICBVSU1hbmFnZXIuYWRkSG90S2V5KFwibGVmdFwiLCB0aGlzLl9uYXZpZ2F0aW9uX2hlbHBlcihcImxlZnRcIikpO1xuXHQgICAgICBVSU1hbmFnZXIuYWRkSG90S2V5KFwic2hpZnQrdXBcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJ1cFwiKSk7XG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJzaGlmdCtkb3duXCIsIHRoaXMuX25hdmlnYXRpb25faGVscGVyKFwiZG93blwiKSk7XG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJzaGlmdCtyaWdodFwiLCB0aGlzLl9uYXZpZ2F0aW9uX2hlbHBlcihcInJpZ2h0XCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcInNoaWZ0K2xlZnRcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJsZWZ0XCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcImN0cmwrc2hpZnQrdXBcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJ1cFwiKSk7XG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJjdHJsK3NoaWZ0K2Rvd25cIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJkb3duXCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcImN0cmwrc2hpZnQrcmlnaHRcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJyaWdodFwiKSk7XG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJjdHJsK3NoaWZ0K2xlZnRcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJsZWZ0XCIpKTtcblx0ICAgICAgVUlNYW5hZ2VyLmFkZEhvdEtleShcInBhZ2V1cFwiLCB0aGlzLl9uYXZpZ2F0aW9uX2hlbHBlcihcInBndXBcIikpO1xuXHQgICAgICBVSU1hbmFnZXIuYWRkSG90S2V5KFwicGFnZWRvd25cIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJwZ2Rvd25cIikpO1xuXHQgICAgICBVSU1hbmFnZXIuYWRkSG90S2V5KFwiaG9tZVwiLCB0aGlzLl9uYXZpZ2F0aW9uX2hlbHBlcihcInRvcFwiKSk7XG5cdCAgICAgIFVJTWFuYWdlci5hZGRIb3RLZXkoXCJlbmRcIiwgdGhpcy5fbmF2aWdhdGlvbl9oZWxwZXIoXCJib3R0b21cIikpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHR9O1xuXG5cdC8qRGF0YSBjb2xsZWN0aW9uIG1hcHBpbmcgbG9naWMgKi9cblxuXHR2YXIgTWFwQ29sbGVjdGlvbiA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy4kcmVhZHkucHVzaCh0aGlzLl9jcmVhdGVfc2NoZW1lX2luaXQpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU3RydWN0dXJlVXBkYXRlXCIsIHRoaXMuX2NyZWF0ZV9zY2hlbWVfaW5pdCk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TdHJ1Y3R1cmVMb2FkXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zY2hlbWVfaW5pdF9vcmRlci5sZW5ndGgpIHRoaXMuX2NyZWF0ZV9zY2hlbWVfaW5pdCgpO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfY3JlYXRlX3NjaGVtZV9pbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgc3RhY2sgPSB0aGlzLl9zY2hlbWVfaW5pdF9vcmRlciA9IFtdO1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgaWYgKGNvbmZpZy5jb2x1bW5zKSB0aGlzLl9idWlsZF9kYXRhX21hcChjb25maWcuY29sdW1ucyk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubWFwKSB0aGlzLl9wcm9jZXNzX2ZpZWxkX21hcChjb25maWcubWFwKTtcblxuXHQgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLmRhdGEuX3NjaGVtZV9pbml0ID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHN0YWNrW2ldKG9iaik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3Byb2Nlc3NfZmllbGRfbWFwOiBmdW5jdGlvbiAobWFwKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG5cdCAgICAgIHRoaXMuX3NjaGVtZV9pbml0X29yZGVyLnB1c2godGhpcy5fcHJvY2Vzc19zaW5nbGVfbWFwKGtleSwgbWFwW2tleV0pKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9wcm9jZXNzX3NpbmdsZV9tYXA6IGZ1bmN0aW9uICh0YXJnZXQsIG1hcCwgZXh0cmEpIHtcblx0ICAgIHZhciBzb3VyY2UgPSBtYXAucmVwbGFjZSgvXihcXHN8KVxcKChkYXRlfG51bWJlcilcXCkvLCBcIlwiKTtcblx0ICAgIHZhciBnZXRTb3VyY2U7XG5cblx0ICAgIGlmIChzb3VyY2UgPT09IFwiXCIpIHtcblx0ICAgICAgZ2V0U291cmNlID0gZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgICByZXR1cm4gYVt0YXJnZXRdO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHNvdXJjZS5pbmRleE9mKFwiI1wiKSA9PT0gLTEgJiYgc291cmNlLmluZGV4T2YoXCJ7XCIpID09PSAtMSkge1xuXHQgICAgICAgIHNvdXJjZSA9IFwiI1wiICsgc291cmNlICsgXCIjXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBnZXRTb3VyY2UgPSB0ZW1wbGF0ZShzb3VyY2UpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWFwLmluZGV4T2YoXCIoZGF0ZSlcIikgPT09IDApIHtcblx0ICAgICAgaWYgKGV4dHJhICYmICFleHRyYS5mb3JtYXQpIGV4dHJhLmZvcm1hdCA9IGkxOG4uZGF0ZUZvcm1hdFN0cjtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB2YXIgZGF0ZVN0ciA9IChnZXRTb3VyY2Uob2JqKSB8fCBcIlwiKS50b1N0cmluZygpO1xuXHQgICAgICAgIG9ialt0YXJnZXRdID0gaTE4bi5wYXJzZUZvcm1hdERhdGUoZGF0ZVN0cik7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKG1hcC5pbmRleE9mKFwiKG51bWJlcilcIikgPT09IDApIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICBvYmpbdGFyZ2V0XSA9IGdldFNvdXJjZShvYmopICogMTtcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgb2JqW3RhcmdldF0gPSBnZXRTb3VyY2Uob2JqKSB8fCBcIlwiO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2J1aWxkX2RhdGFfbWFwOiBmdW5jdGlvbiAoY29sdW1ucykge1xuXHQgICAgLy9mb3IgZGF0YXRhYmxlXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG1hcCA9IGNvbHVtbnNbaV0ubWFwO1xuXHQgICAgICB2YXIgaWQgPSBjb2x1bW5zW2ldLmlkO1xuXG5cdCAgICAgIGlmICghaWQpIHtcblx0ICAgICAgICBpZCA9IGNvbHVtbnNbaV0uaWQgPSBcImlcIiArIHVpZCgpO1xuXHQgICAgICAgIGlmICghY29sdW1uc1tpXS5oZWFkZXIpIGNvbHVtbnNbaV0uaGVhZGVyID0gXCJcIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtYXApIHRoaXMuX3NjaGVtZV9pbml0X29yZGVyLnB1c2godGhpcy5fcHJvY2Vzc19zaW5nbGVfbWFwKGlkLCBtYXAsIGNvbHVtbnNbaV0pKTtcblxuXHQgICAgICB0aGlzLl9tYXBfb3B0aW9ucyhjb2x1bW5zW2ldKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9tYXBfb3B0aW9uczogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0ICAgIHZhciBvcHRpb25zID0gZWxlbWVudC5vcHRpb25zIHx8IGVsZW1lbnQuY29sbGVjdGlvbjtcblxuXHQgICAgaWYgKG9wdGlvbnMpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgLy9pZCBvZiBzb21lIG90aGVyIHZpZXdcblx0ICAgICAgICB2YXIgb3B0aW9uc192aWV3ID0gJCQob3B0aW9ucyk7IC8vb3IgdXJsXG5cblx0ICAgICAgICBpZiAoIW9wdGlvbnNfdmlldykge1xuXHQgICAgICAgICAgb3B0aW9uc192aWV3ID0gbmV3ICh1c2UoXCJEYXRhQ29sbGVjdGlvblwiKSkoe1xuXHQgICAgICAgICAgICB1cmw6IG9wdGlvbnNcblx0ICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUucHVzaChvcHRpb25zX3ZpZXcpO1xuXHQgICAgICAgIH0gLy9pZiBpdCB3YXMgYSB2aWV3LCBzcGVjaWFsIGNoZWNrIGZvciBzdWdnZXN0c1xuXG5cblx0ICAgICAgICBpZiAob3B0aW9uc192aWV3LmdldEJvZHkpIG9wdGlvbnNfdmlldyA9IG9wdGlvbnNfdmlldy5nZXRCb2R5KCk7XG5cblx0ICAgICAgICB0aGlzLl9iaW5kX2NvbGxlY3Rpb24ob3B0aW9uc192aWV3LCBlbGVtZW50KTtcblx0ICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5sb2FkTmV4dCkge1xuXHQgICAgICAgIGlmIChvcHRpb25zWzBdICYmIF90eXBlb2Yob3B0aW9uc1swXSkgPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgLy9beyBpZDoxLCB2YWx1ZTpcIm9uZVwifSwgLi4uXVxuXHQgICAgICAgICAgb3B0aW9ucyA9IG5ldyAodXNlKFwiRGF0YUNvbGxlY3Rpb25cIikpKHtcblx0ICAgICAgICAgICAgZGF0YTogb3B0aW9uc1xuXHQgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgIHRoaXMuX2JpbmRfY29sbGVjdGlvbihvcHRpb25zLCBlbGVtZW50KTtcblxuXHQgICAgICAgICAgdGhpcy5fZGVzdHJveV93aXRoX21lLnB1c2gob3B0aW9ucyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vW1wib25lXCIsIFwidHdvXCJdXG5cdCAgICAgICAgICAvL29yXG5cdCAgICAgICAgICAvL3sgMTogXCJvbmVcIiwgMjogXCJ0d29cIn1cblx0ICAgICAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMpKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0ge307XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaWogPSAwOyBpaiA8IG9wdGlvbnMubGVuZ3RoOyBpaisrKSB7XG5cdCAgICAgICAgICAgICAgZGF0YVtvcHRpb25zW2lqXV0gPSBvcHRpb25zW2lqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGVsZW1lbnQub3B0aW9ucyA9IG9wdGlvbnMgPSBkYXRhO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBlbGVtZW50LnRlbXBsYXRlID0gZWxlbWVudC50ZW1wbGF0ZSB8fCB0aGlzLl9jb2xsZWN0aW9uX2FjY2Vzc2VyKG9wdGlvbnMsIGVsZW1lbnQuaWQsIGVsZW1lbnQub3B0aW9uc2xpc3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvL2RhdGEgY29sbGVjdGlvbiBvciB2aWV3XG5cdCAgICAgICAgdGhpcy5fYmluZF9jb2xsZWN0aW9uKG9wdGlvbnMsIGVsZW1lbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfYmluZF9jb2xsZWN0aW9uOiBmdW5jdGlvbiAob3B0aW9ucywgZWxlbWVudCkge1xuXHQgICAgaWYgKGVsZW1lbnQpIHtcblx0ICAgICAgZGVsZXRlIGVsZW1lbnQub3B0aW9ucztcblx0ICAgICAgZWxlbWVudC5jb2xsZWN0aW9uID0gb3B0aW9ucztcblx0ICAgICAgZWxlbWVudC50ZW1wbGF0ZSA9IGVsZW1lbnQudGVtcGxhdGUgfHwgdGhpcy5fYmluZF9hY2Nlc3NlcihvcHRpb25zLCBlbGVtZW50LmlkLCBlbGVtZW50Lm9wdGlvbnNsaXN0KTtcblx0ICAgICAgdmFyIGlkID0gb3B0aW9ucy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICAgICAgaWYgKHRoaXMucmVmcmVzaEZpbHRlcikgdGhpcy5yZWZyZXNoRmlsdGVyKGVsZW1lbnQuaWQpO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIW9wdGlvbnMuJGRlc3RydWN0ZWQpIG9wdGlvbnMuZGF0YS5kZXRhY2hFdmVudChpZCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NvbGxlY3Rpb25fYWNjZXNzZXI6IGZ1bmN0aW9uIChvcHRpb25zLCBpZCwgbXVsdGkpIHtcblx0ICAgIGlmIChtdWx0aSkge1xuXHQgICAgICB2YXIgc2VwYXJhdG9yID0gdHlwZW9mIG11bHRpID09IFwic3RyaW5nXCIgPyBtdWx0aSA6IFwiLFwiO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG9ialtpZF0gfHwgb2JqLnZhbHVlO1xuXHQgICAgICAgIGlmICghdmFsdWUpIHJldHVybiBcIlwiO1xuXHQgICAgICAgIHZhciBpZHMgPSB2YWx1ZS5zcGxpdChzZXBhcmF0b3IpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlkc1tpXSA9IG9wdGlvbnNbaWRzW2ldXSB8fCBcIlwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBpZHMuam9pbihcIiwgXCIpO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICByZXR1cm4gb3B0aW9uc1tvYmpbaWRdXSB8fCBvYmoudmFsdWUgfHwgXCJcIjtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9iaW5kX2FjY2Vzc2VyOiBmdW5jdGlvbiAoY29sLCBpZCwgbXVsdGkpIHtcblx0ICAgIGlmIChtdWx0aSkge1xuXHQgICAgICB2YXIgc2VwYXJhdG9yID0gdHlwZW9mIG11bHRpID09IFwic3RyaW5nXCIgPyBtdWx0aSA6IFwiLFwiO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG9ialtpZF0gfHwgb2JqLnZhbHVlO1xuXHQgICAgICAgIGlmICghdmFsdWUpIHJldHVybiBcIlwiO1xuXHQgICAgICAgIHZhciBpZHMgPSB2YWx1ZS5zcGxpdChzZXBhcmF0b3IpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciBkYXRhID0gY29sLmRhdGEucHVsbFtpZHNbaV1dO1xuXHQgICAgICAgICAgaWRzW2ldID0gZGF0YSA/IGRhdGEudmFsdWUgfHwgXCJcIiA6IFwiXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGlkcy5qb2luKFwiLCBcIik7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHZhciBwcm9wID0gb2JqW2lkXSB8fCBvYmoudmFsdWUsXG5cdCAgICAgICAgICAgIGRhdGEgPSBjb2wuZGF0YS5wdWxsW3Byb3BdO1xuXHQgICAgICAgIGlmIChkYXRhICYmIChkYXRhLnZhbHVlIHx8IGRhdGEudmFsdWUgPT09IDApKSByZXR1cm4gZGF0YS52YWx1ZTtcblx0ICAgICAgICByZXR1cm4gXCJcIjtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1vdXNlRXZlbnRzID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cdCAgICB0aGlzLl9jbGlja3N0YW1wID0gMDtcblx0ICAgIHRoaXMuX2RibF9zZW5zZXRpdmUgPSAzMDA7XG5cdCAgICB0aGlzLl9pdGVtX2NsaWNrZWQgPSBudWxsO1xuXG5cdCAgICB0aGlzLl9tb3VzZV9hY3Rpb25fZXh0ZW5kKGNvbmZpZy5vbkNsaWNrLCBcIm9uX2NsaWNrXCIpO1xuXG5cdCAgICB0aGlzLl9tb3VzZV9hY3Rpb25fZXh0ZW5kKGNvbmZpZy5vbkNvbnRleHQsIFwib25fY29udGV4dFwiKTtcblxuXHQgICAgdGhpcy5fbW91c2VfYWN0aW9uX2V4dGVuZChjb25maWcub25EYmxDbGljaywgXCJvbl9kYmxjbGlja1wiKTtcblxuXHQgICAgdGhpcy5fbW91c2VfYWN0aW9uX2V4dGVuZChjb25maWcub25Nb3VzZU1vdmUsIFwib25fbW91c2VfbW92ZVwiKTsgLy9hdHRhY2ggZG9tIGV2ZW50cyBpZiByZWxhdGVkIGNvbGxlY3Rpb24gaXMgZGVmaW5lZFxuXG5cblx0ICAgIGlmICh0aGlzLm9uX2NsaWNrKSB7XG5cdCAgICAgIF9ldmVudCh0aGlzLl9jb250ZW50b2JqLCBcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2ssIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGlmIChlbnYuaXNJRTggJiYgdGhpcy5vbl9kYmxjbGljaykgX2V2ZW50KHRoaXMuX2NvbnRlbnRvYmosIFwiZGJsY2xpY2tcIiwgdGhpcy5fb25EYmxDbGljaywge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9uX2NvbnRleHQpIF9ldmVudCh0aGlzLl9jb250ZW50b2JqLCBcImNvbnRleHRtZW51XCIsIHRoaXMuX29uQ29udGV4dCwge1xuXHQgICAgICBiaW5kOiB0aGlzXG5cdCAgICB9KTtcblx0ICAgIGlmICh0aGlzLm9uX21vdXNlX21vdmUpIHRoaXMuX2VuYWJsZV9tb3VzZV9tb3ZlKCk7XG5cdCAgfSxcblx0ICBfZW5hYmxlX21vdXNlX21vdmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fbW91c2VfbW92ZV9lbmFibGVkKSB7XG5cdCAgICAgIHRoaXMub25fbW91c2VfbW92ZSA9IHRoaXMub25fbW91c2VfbW92ZSB8fCB7fTtcblxuXHQgICAgICBfZXZlbnQodGhpcy5fY29udGVudG9iaiwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25Nb3VzZSwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cblx0ICAgICAgX2V2ZW50KHRoaXMuX2NvbnRlbnRvYmosIGVudi5pc0lFID8gXCJtb3VzZWxlYXZlXCIgOiBcIm1vdXNlb3V0XCIsIHRoaXMuX29uTW91c2UsIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHRoaXMuX21vdXNlX21vdmVfZW5hYmxlZCA9IDE7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fbW91c2VfbW92ZV90aW1lcikgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9tb3VzZV9tb3ZlX3RpbWVyKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfbW91c2VfYWN0aW9uX2V4dGVuZDogZnVuY3Rpb24gKGNvbmZpZywga2V5KSB7XG5cdCAgICBpZiAoY29uZmlnKSB7XG5cdCAgICAgIHZhciBub3cgPSB0aGlzW2tleV07XG5cdCAgICAgIHZhciBzdGVwID0gbm93ID8gZXhwb3J0cy5leHRlbmQoe30sIG5vdykgOiB7fTtcblx0ICAgICAgdGhpc1trZXldID0gZXhwb3J0cy5leHRlbmQoc3RlcCwgY29uZmlnKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vaW5uZXIgb25jbGljayBvYmplY3QgaGFuZGxlclxuXHQgIF9vbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIFVJTWFuYWdlci5fZm9jdXNfYWN0aW9uKHRoaXMpO1xuXG5cdCAgICBpZiAodGhpcy5vbl9kYmxjbGljaykge1xuXHQgICAgICAvLyBlbXVsYXRlcyBkb3VibGUgY2xpY2tcblx0ICAgICAgdmFyIHN0YW1wID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG5cblx0ICAgICAgaWYgKHN0YW1wIC0gdGhpcy5fY2xpY2tzdGFtcCA8PSB0aGlzLl9kYmxfc2Vuc2V0aXZlICYmIHRoaXMubG9jYXRlKSB7XG5cdCAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmxvY2F0ZShlKTtcblxuXHQgICAgICAgIGlmIChcIlwiICsgaXRlbSA9PSBcIlwiICsgdGhpcy5faXRlbV9jbGlja2VkKSB7XG5cdCAgICAgICAgICB0aGlzLl9jbGlja3N0YW1wID0gMDtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLl9vbkRibENsaWNrKGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2NsaWNrc3RhbXAgPSBzdGFtcDtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21vdXNlRXZlbnQoZSwgdGhpcy5vbl9jbGljaywgXCJJdGVtQ2xpY2tcIik7XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICAvL2lubmVyIG9uZGJsY2xpY2sgb2JqZWN0IGhhbmRsZXJcblx0ICBfb25EYmxDbGljazogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9tb3VzZUV2ZW50KGUsIHRoaXMub25fZGJsY2xpY2ssIFwiSXRlbURibENsaWNrXCIpO1xuXHQgIH0sXG5cdCAgLy9wcm9jZXNzIG9uY29udGV4dG1lbnUgZXZlbnRzXG5cdCAgX29uQ29udGV4dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHRoaXMuX21vdXNlRXZlbnQoZSwgdGhpcy5vbl9jb250ZXh0LCBcIkJlZm9yZUNvbnRleHRNZW51XCIsIFwiQWZ0ZXJDb250ZXh0TWVudVwiKTtcblx0ICB9LFxuXG5cdCAgLypcblx0ICBcdGV2ZW50IHRocm90dGxlciAtIGlnbm9yZSBldmVudHMgd2hpY2ggb2NjdXJzIHRvbyBmYXN0XG5cdCAgXHRkdXJpbmcgbW91c2UgbW92aW5nIHRoZXJlIGFyZSBhIGxvdCBvZiBldmVudCBmaXJpbmcgLSB3ZSBuZWVkIG5vIHNvIG11Y2hcblx0ICBcdGFsc28sIG1vdXNlb3V0IGNhbiBmaXJlIHdoZW4gbW92aW5nIGluc2lkZSB0aGUgc2FtZSBodG1sIGNvbnRhaW5lciAtIHdlIG5lZWQgdG8gaWdub3JlIHN1Y2ggZmFrZSBjYWxsc1xuXHQgICovXG5cdCAgX29uTW91c2U6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAodGhpcy4kZGVzdHJ1Y3RlZCkgcmV0dXJuO1xuXHQgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KSAvL21ha2UgYSBjb3B5IG9mIGV2ZW50LCB3aWxsIGJlIHVzZWQgaW4gdGltZWQgY2FsbFxuXHQgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoZXZlbnQpO2Vsc2UgaWYgKCFpc1VuZGVmaW5lZChlLm1vdmVtZW50WSkgJiYgIWUubW92ZW1lbnRZICYmICFlLm1vdmVtZW50WCkgcmV0dXJuOyAvL2xvZ2l0ZWNoIG1vdXNlIGRyaXZlciBjYW4gc2VuZCBmYWxzZSBzaWduYWxzIGluIENocm9tZVxuXG5cdCAgICBpZiAodGhpcy5fbW91c2VfbW92ZV90aW1lcikgLy9jbGVhciBvbGQgZXZlbnQgdGltZXJcblx0ICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9tb3VzZV9tb3ZlX3RpbWVyKTsgLy90aGlzIGV2ZW50IGp1c3QgaW5mb3JtIGFib3V0IG1vdmluZyBvcGVyYXRpb24sIHdlIGRvbid0IGNhcmUgYWJvdXQgZGV0YWlsc1xuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uTW91c2VNb3ZpbmdcIiwgW2VdKTsgLy9zZXQgbmV3IGV2ZW50IHRpbWVyXG5cblx0ICAgIHRoaXMuX21vdXNlX21vdmVfdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgLy9jYWxsZWQgb25seSB3aGVuIHdlIGhhdmUgYXQgbGVhc3QgMTAwbXMgYWZ0ZXIgcHJldmlvdXMgZXZlbnRcblx0ICAgICAgaWYgKGUudHlwZSA9PSBcIm1vdXNlbW92ZVwiKSB0aGlzLl9vbk1vdXNlTW92ZShlKTtlbHNlIHRoaXMuX29uTW91c2VPdXQoZSk7XG5cdCAgICB9LCB0aGlzKSwgdGhpcy5fc2V0dGluZ3MubW91c2VFdmVudERlbGF5IHx8IDUwMCk7XG5cdCAgfSxcblx0ICAvL2lubmVyIG1vdXNlbW92ZSBvYmplY3QgaGFuZGxlclxuXHQgIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmICghdGhpcy5fbW91c2VFdmVudChlLCB0aGlzLm9uX21vdXNlX21vdmUsIFwiTW91c2VNb3ZlXCIpKSB0aGlzLmNhbGxFdmVudChcIm9uTW91c2VPdXRcIiwgW2UgfHwgZXZlbnRdKTtcblx0ICB9LFxuXHQgIC8vaW5uZXIgbW91c2VvdXQgb2JqZWN0IGhhbmRsZXJcblx0ICBfb25Nb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25Nb3VzZU91dFwiLCBbZSB8fCBldmVudF0pO1xuXHQgIH0sXG5cdCAgLy9jb21tb24gbG9naWMgZm9yIGNsaWNrIGFuZCBkYmwtY2xpY2sgcHJvY2Vzc2luZ1xuXHQgIF9tb3VzZUV2ZW50OiBmdW5jdGlvbiAoZSwgaGFzaCwgbmFtZSwgcGFpcikge1xuXHQgICAgZSA9IGUgfHwgZXZlbnQ7XG5cdCAgICBpZiAoZS5wcm9jZXNzZWQgfHwgIXRoaXMuX3ZpZXdvYmopIHJldHVybjtcblx0ICAgIGUucHJvY2Vzc2VkID0gdHJ1ZTtcblx0ICAgIHZhciB0cmcgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7IC8vSUU4IGNhbid0IG1vZGlmeSBldmVudCBvYmplY3Rcblx0ICAgIC8vc28gd2UgbmVlZCB0byBzdG9wIGV2ZW50IGJ1YmJsaW5nIHRvIHByZXZlbnQgZG91YmxlIHByb2Nlc3NpbmdcblxuXHQgICAgaWYgKGVudi5pc0lFOCkge1xuXHQgICAgICB2YXIgdmlkID0gdGhpcy5fc2V0dGluZ3MuaWQ7XG5cdCAgICAgIHZhciB3aWQgPSB0cmcud192aWV3O1xuXHQgICAgICBpZiAoIXdpZCkgdHJnLndfdmlldyA9IHZpZDtlbHNlIGlmICh3aWQgIT09IHZpZCkgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY3NzID0gXCJcIjtcblx0ICAgIHZhciBpZCA9IG51bGw7XG5cdCAgICB2YXIgZm91bmQgPSBmYWxzZTsgLy9sb29wIHRocm91Z2ggYWxsIHBhcmVudHNcblx0ICAgIC8vd2UgbmVlZCB0byBjaGVjayBmb3IgdGhpcy5fdmlld29iaiBhcyBzb21lIGhhbmRsZXIgY2FuIGRlc3Ryb3kgdGhlIHZpZXdcblxuXHQgICAgd2hpbGUgKHRyZyAmJiB0cmcucGFyZW50Tm9kZSAmJiB0aGlzLl92aWV3b2JqICYmIHRyZyAhPSB0aGlzLl92aWV3b2JqLnBhcmVudE5vZGUpIHtcblx0ICAgICAgaWYgKCFmb3VuZCAmJiB0cmcuZ2V0QXR0cmlidXRlKSB7XG5cdCAgICAgICAgLy9pZiBlbGVtZW50IHdpdGggSUQgbWFyayBpcyBub3QgZGV0ZWN0ZWQgeWV0XG5cdCAgICAgICAgaWQgPSB0cmcuZ2V0QXR0cmlidXRlKHRoaXMuX2lkKTsgLy9jaGVjayBpZCBvZiBjdXJyZW50IG9uZVxuXG5cdCAgICAgICAgaWYgKGlkKSB7XG5cdCAgICAgICAgICB0aGlzLl9pdGVtX2NsaWNrZWQgPSBpZDtcblxuXHQgICAgICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KSB7XG5cdCAgICAgICAgICAgIC8vaXQgd2lsbCBiZSB0cmlnZ2VyZWQgb25seSBmb3IgZmlyc3QgZGV0ZWN0ZWQgSUQsIGluIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvblwiICsgbmFtZSwgW2lkLCBlLCB0cmddKSkgcmV0dXJuO1xuXHQgICAgICAgICAgICBpZiAocGFpcikgdGhpcy5jYWxsRXZlbnQoXCJvblwiICsgcGFpciwgW2lkLCBlLCB0cmddKTtcblx0ICAgICAgICAgIH0gLy9zZXQgZm91bmQgZmxhZ1xuXG5cblx0ICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBjc3MgPSBfZ2V0Q2xhc3NOYW1lKHRyZyk7XG5cblx0ICAgICAgaWYgKGNzcykge1xuXHQgICAgICAgIC8vY2hlY2sgaWYgcHJlLWRlZmluZWQgcmVhY3Rpb24gZm9yIGVsZW1lbnQncyBjc3MgbmFtZSBleGlzdHNcblx0ICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKS5zcGxpdChcIiBcIik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGhhc2hbY3NzW2ldXSkge1xuXHQgICAgICAgICAgICB2YXIgZnVuY3RvciA9IHRvRnVuY3RvcihoYXNoW2Nzc1tpXV0sIHRoaXMuJHNjb3BlKTtcblx0ICAgICAgICAgICAgdmFyIHJlcyA9IGZ1bmN0b3IuY2FsbCh0aGlzLCBlLCBpZCB8fCBsb2NhdGUoZSwgdGhpcy5faWQpLCB0cmcpO1xuXHQgICAgICAgICAgICBpZiAocmVzID09PSBmYWxzZSkgcmV0dXJuIGZvdW5kO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRyZyA9IHRyZy5wYXJlbnROb2RlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZm91bmQ7IC8vcmV0dXJucyB0cnVlIGlmIGl0ZW0gd2FzIGxvY2F0ZWQgYW5kIGV2ZW50IHdhcyB0cmlnZ2VyZWRcblx0ICB9XG5cdH07XG5cblx0Lypcblx0ICAgIFVJOiBuYXZpZ2F0aW9uIGNvbnRyb2xcblx0Ki9cblxuXHR2YXIgTmF2aWdhdGlvbkJ1dHRvbnMgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2goZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25LZXlQcmVzc1wiLCB0aGlzLl9vbktleVByZXNzKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgX21vdmVBY3RpdmU6IGZ1bmN0aW9uIChjb2RlLCBlKSB7XG5cdCAgICBpZiAoY29kZSA9PT0gMzcgfHwgY29kZSA9PT0gMzkpIHtcblx0ICAgICAgcHJldmVudEV2ZW50KGUpO1xuXG5cdCAgICAgIHRoaXMuX3Nob3dOYXZJdGVtKGNvZGUgPT09IDM3ID8gLTEgOiAxKTtcblxuXHQgICAgICB2YXIgbm9kZSA9IHRoaXMuX25hdlBhbmVsLnF1ZXJ5U2VsZWN0b3IoXCJbdGFiaW5kZXg9JzAnXVwiKTtcblxuXHQgICAgICBpZiAobm9kZSkgbm9kZS5mb2N1cygpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3JlbmRlclBhbmVsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZW1vdmUodGhpcy5fbmF2UGFuZWwpO1xuXHQgICAgdGhpcy5fbmF2UGFuZWwgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICBcImNsYXNzXCI6IFwid2ViaXhfbmF2X3BhbmVsIFwiICsgXCJ3ZWJpeF9uYXZfcGFuZWxfXCIgKyB0aGlzLl9zZXR0aW5ncy5uYXZpZ2F0aW9uLnR5cGUsXG5cdCAgICAgIFwicm9sZVwiOiBcInRhYmxpc3RcIlxuXHQgICAgfSwgXCJcIik7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouYXBwZW5kQ2hpbGQodGhpcy5fbmF2UGFuZWwpO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJOYXZJdGVtcygpO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJOYXZCdXR0b25zKCk7XG5cblx0ICAgIHRoaXMuX3NldExpbmtFdmVudEhhbmRsZXIoKTtcblx0ICB9LFxuXHQgIF9zZXRMaW5rRXZlbnRIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaCA9IFtdO1xuXHQgICAgaWYgKHRoaXMuX25hdlBhbmVsKSBoWzBdID0gZXZlbnQkMSh0aGlzLl9uYXZQYW5lbCwgXCJjbGlja1wiLCBiaW5kKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBlbGVtID0gZS5zcmNFbGVtZW50IHx8IGUudGFyZ2V0O1xuXHQgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuXHQgICAgICB3aGlsZSAoZWxlbSAhPSB0aGlzLl9uYXZQYW5lbCAmJiAhZm91bmQpIHtcblx0ICAgICAgICB2YXIgYmluZElkID0gZWxlbS5nZXRBdHRyaWJ1dGUodGhpcy5fbGlua0F0dHIpO1xuXG5cdCAgICAgICAgaWYgKGJpbmRJZCkge1xuXHQgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG5cdCAgICAgICAgICB0aGlzLl9zaG93UGFuZWxCaW5kKGJpbmRJZCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgaWYgKHRoaXMuX3ByZXZOYXZCdXR0b24pIGhbMV0gPSBldmVudCQxKHRoaXMuX3ByZXZOYXZCdXR0b24sIFwiY2xpY2tcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuX3Nob3dOYXZJdGVtKC0xKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIGlmICh0aGlzLl9uZXh0TmF2QnV0dG9uKSBoWzFdID0gZXZlbnQkMSh0aGlzLl9uZXh0TmF2QnV0dG9uLCBcImNsaWNrXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLl9zaG93TmF2SXRlbSgxKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy5kZXRhY2hFdmVudChoW2ldKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGggPSBudWxsO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfc2hvd05hdkl0ZW06IGZ1bmN0aW9uIChpbmMpIHtcblx0ICAgIGlmICh0aGlzLl9jZWxscykge1xuXHQgICAgICB2YXIgaW5kZXgkJDEgPSB0aGlzLl9hY3RpdmVfY2VsbCArIGluYztcblxuXHQgICAgICBpZiAoaW5kZXgkJDEgPj0gdGhpcy5fY2VsbHMubGVuZ3RoIHx8IGluZGV4JCQxIDwgMCkge1xuXHQgICAgICAgIGluZGV4JCQxID0gaW5kZXgkJDEgPCAwID8gdGhpcy5fY2VsbHMubGVuZ3RoIC0gMSA6IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLnNldEFjdGl2ZUluZGV4KGluZGV4JCQxKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zaG93UGFuZWxCaW5kOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmICh0aGlzLl9jZWxscykgJCQoaWQpLnNob3coKTtcblx0ICB9LFxuXHQgIF9yZW5kZXJOYXZJdGVtczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGl0ZW0sIGNvbmZpZztcblx0ICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzLm5hdmlnYXRpb247XG5cblx0ICAgIGlmIChjb25maWcuaXRlbXMpIHtcblx0ICAgICAgdGhpcy5fbGlua0F0dHIgPSBjb25maWcubGlua0F0dHIgfHwgXCJiaW5kX2lkXCI7XG5cdCAgICAgIGlmICghdGhpcy5fbmF2UGFuZWwpIHRoaXMuX3JlbmRlclBhbmVsKCk7ZWxzZSB0aGlzLl9jbGVhclBhbmVsKCk7XG5cdCAgICAgIHZhciBkYXRhID0gdGhpcy5fY2VsbHMgPyB0aGlzLl9jZWxscyA6IHRoaXMuZGF0YS5vcmRlcjtcblxuXHQgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpdGVtID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X25hdl9pdGVtIHdlYml4X25hdl9cIiArIChpID09IHRoaXMuX2FjdGl2ZV9jZWxsID8gXCJhY3RpdmVcIiA6IFwiaW5hY3RpdmVcIiksXG5cdCAgICAgICAgICAgIFwicm9sZVwiOiBcInRhYlwiLFxuXHQgICAgICAgICAgICBcInRhYmluZGV4XCI6IGkgPT0gdGhpcy5fYWN0aXZlX2NlbGwgPyBcIjBcIiA6IFwiLTFcIlxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9jZWxscyA/IHRoaXMuX2NlbGxzW2ldLl9zZXR0aW5ncy5pZCA6IGRhdGFbaV07XG5cdCAgICAgICAgICBpZiAoaWQpIGl0ZW0uc2V0QXR0cmlidXRlKHRoaXMuX2xpbmtBdHRyLCBpZCk7XG5cblx0ICAgICAgICAgIHRoaXMuX25hdlBhbmVsLmFwcGVuZENoaWxkKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NsZWFyUGFuZWw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9uYXZQYW5lbCkge1xuXHQgICAgICB2YXIgY29sbCA9IHRoaXMuX25hdlBhbmVsLmNoaWxkTm9kZXM7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IGNvbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICByZW1vdmUoY29sbFtpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9yZW5kZXJOYXZCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3MubmF2aWdhdGlvbjtcblxuXHQgICAgaWYgKGNvbmZpZy5idXR0b25zKSB7XG5cdCAgICAgIGlmICh0aGlzLl9wcmV2TmF2QnV0dG9uKSByZW1vdmUodGhpcy5fcHJldk5hdkJ1dHRvbik7XG5cdCAgICAgIGlmICh0aGlzLl9wcmV2TmF2QnV0dG9uKSByZW1vdmUodGhpcy5fbmV4dE5hdkJ1dHRvbik7XG5cdCAgICAgIHRoaXMuX3ByZXZOYXZCdXR0b24gPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9uYXZfYnV0dG9uX1wiICsgY29uZmlnLnR5cGUgKyBcIiB3ZWJpeF9uYXZfYnV0dG9uX3ByZXYgXCJcblx0ICAgICAgfSwgXCI8ZGl2IHJvbGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGFyaWEtbGFiZWw9XFxcIlwiICsgaTE4bi5hcmlhLnByZXZUYWIgKyBcIlxcXCIgY2xhc3M9XFxcIndlYml4X25hdl9idXR0b25faW5uZXJcXFwiPjwvZGl2PlwiKTtcblxuXHQgICAgICB0aGlzLl92aWV3b2JqLmFwcGVuZENoaWxkKHRoaXMuX3ByZXZOYXZCdXR0b24pO1xuXG5cdCAgICAgIHRoaXMuX25leHROYXZCdXR0b24gPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9uYXZfYnV0dG9uX1wiICsgY29uZmlnLnR5cGUgKyBcIiB3ZWJpeF9uYXZfYnV0dG9uX25leHQgXCJcblx0ICAgICAgfSwgXCI8ZGl2IHJvbGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGFyaWEtbGFiZWw9XFxcIlwiICsgaTE4bi5hcmlhLnByZXZUYWIgKyBcIlxcXCIgY2xhc3M9XFxcIndlYml4X25hdl9idXR0b25faW5uZXJcXFwiPjwvZGl2PlwiKTtcblxuXHQgICAgICB0aGlzLl92aWV3b2JqLmFwcGVuZENoaWxkKHRoaXMuX25leHROYXZCdXR0b24pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgT3ZlcmxheUJveCA9IHtcblx0ICBzaG93T3ZlcmxheTogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgIGlmICghdGhpcy5fb3ZlcmxheSkge1xuXHQgICAgICB0aGlzLl9vdmVybGF5ID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfb3ZlcmxheVwiXG5cdCAgICAgIH0sIG1lc3NhZ2UgfHwgXCJcIik7XG5cdCAgICAgIGluc2VydEJlZm9yZSh0aGlzLl9vdmVybGF5LCB0aGlzLl92aWV3b2JqLmZpcnN0Q2hpbGQsIHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgICB0aGlzLl92aWV3b2JqLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHQgICAgfSBlbHNlIHRoaXMuX292ZXJsYXkuaW5uZXJIVE1MID0gbWVzc2FnZTtcblx0ICB9LFxuXHQgIGhpZGVPdmVybGF5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fb3ZlcmxheSkge1xuXHQgICAgICByZW1vdmUodGhpcy5fb3ZlcmxheSk7XG5cdCAgICAgIHRoaXMuX292ZXJsYXkgPSBudWxsO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgUGFnaW5nQWJpbGl0eSA9IHtcblx0ICBwYWdlcl9zZXR0ZXI6IGZ1bmN0aW9uIChwYWdlcikge1xuXHQgICAgaWYgKHR5cGVvZiBwYWdlciA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIHZhciB1aV9wYWdlciA9ICQkKHBhZ2VyKTtcblxuXHQgICAgICBpZiAoIXVpX3BhZ2VyKSB7XG5cdCAgICAgICAgdGhpcy4kYmxvY2tSZW5kZXIgPSB0cnVlO1xuXHQgICAgICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBvYmogPSAkJChwYWdlcik7XG5cdCAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5wYWdlciA9IHRoaXMucGFnZXJfc2V0dGVyKG9iaik7XG5cdCAgICAgICAgICB2YXIgcyA9IG9iai5fc2V0dGluZ3M7XG5cdCAgICAgICAgICBzLmNvdW50ID0gdGhpcy5kYXRhLl9jb3VudF9wYWdlcl90b3RhbChzLmxldmVsKTtcblx0ICAgICAgICAgIG9iai5yZWZyZXNoKCk7XG5cdCAgICAgICAgICB0aGlzLiRibG9ja1JlbmRlciA9IGZhbHNlO1xuXHQgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgICAgICB9LCB0aGlzKTtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHBhZ2VyID0gdWlfcGFnZXI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrX3BhZ2VyX3NpemVzKHJlcGVhdCkge1xuXHQgICAgICBpZiAocGFnZXIuY29uZmlnLmF1dG9zaXplICYmIHRoaXMuZ2V0VmlzaWJsZUNvdW50KSB7XG5cdCAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRWaXNpYmxlQ291bnQoKTtcblxuXHQgICAgICAgIGlmIChpc05hTihjb3VudCkpIHtcblx0ICAgICAgICAgIHBhZ2VyLmNvbmZpZy5zaXplID0gMTtcblx0ICAgICAgICAgIGRlbGF5KGNoZWNrX3BhZ2VyX3NpemVzLCB0aGlzLCBbdHJ1ZV0pO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY291bnQgIT0gcGFnZXIuY29uZmlnLnNpemUpIHtcblx0ICAgICAgICAgIHBhZ2VyLmNvbmZpZy5zaXplID0gY291bnQ7XG5cdCAgICAgICAgICBwYWdlci5yZWZyZXNoKCk7XG5cdCAgICAgICAgICBpZiAocmVwZWF0ID09PSB0cnVlKSB0aGlzLnJlZnJlc2goKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcyA9IHRoaXMuX3NldHRpbmdzLnBhZ2VyOyAvL2luaXRpYWwgdmFsdWUgb2YgcGFnZXIgPSAtMSwgd2FpdGluZyBmb3IgcmVhbCB2YWx1ZVxuXG5cdCAgICAgIGlmIChzLnBhZ2UgPT0gLTEpIHJldHVybiBmYWxzZTtcblx0ICAgICAgdGhpcy5kYXRhLiRtaW4gPSB0aGlzLl9jb3VudF9wYWdlcl9pbmRleCgwLCBzLnBhZ2UgKiBzLnNpemUpOyAvL2FmZmVjdCBkYXRhLmdldFJhbmdlXG5cblx0ICAgICAgdGhpcy5kYXRhLiRtYXggPSB0aGlzLl9jb3VudF9wYWdlcl9pbmRleCh0aGlzLmRhdGEuJG1pbiwgcy5zaXplKTtcblx0ICAgICAgdGhpcy5kYXRhLiRwYWdlc2l6ZSA9IHRoaXMuZGF0YS4kbWF4IC0gdGhpcy5kYXRhLiRtaW47XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVSZW5kZXJcIiwgY2hlY2tfcGFnZXJfc2l6ZXMpO1xuXG5cdCAgICBpZiAoIXBhZ2VyLiR2aWV3KSB7XG5cdCAgICAgIHBhZ2VyLnZpZXcgPSBcInBhZ2VyXCI7XG5cdCAgICAgIHBhZ2VyID0gdWkocGFnZXIpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9wYWdlciA9IHBhZ2VyO1xuXHQgICAgcGFnZXIuJG1hc3RlciA9IHRoaXM7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBzID0gcGFnZXIuX3NldHRpbmdzO1xuXHQgICAgICBzLmNvdW50ID0gdGhpcy5fY291bnRfcGFnZXJfdG90YWwocy5sZXZlbCk7XG5cdCAgICAgIHBhZ2VyLnJlZnJlc2goKTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5kYXRhLl9jb3VudF9wYWdlcl90b3RhbCA9IHRoaXMuX2NvdW50X3BhZ2VyX3RvdGFsO1xuXHQgICAgcmV0dXJuIHBhZ2VyLl9zZXR0aW5ncztcblx0ICB9LFxuXHQgIF9jb3VudF9wYWdlcl90b3RhbDogZnVuY3Rpb24gKGxldmVsKSB7XG5cdCAgICBpZiAobGV2ZWwgJiYgbGV2ZWwgIT09IDApIHtcblx0ICAgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICBpZiAob2JqLiRsZXZlbCA9PSBsZXZlbCkgY291bnQrKztcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBjb3VudDtcblx0ICAgIH0gZWxzZSByZXR1cm4gdGhpcy5jb3VudCgpO1xuXHQgIH0sXG5cdCAgX2NvdW50X3BhZ2VyX2luZGV4OiBmdW5jdGlvbiAoc3RhcnQsIGNvdW50KSB7XG5cdCAgICB2YXIgcyA9IHRoaXMuX3NldHRpbmdzLnBhZ2VyO1xuXG5cdCAgICBpZiAocy5sZXZlbCAmJiBzLmxldmVsICE9PSAwKSB7XG5cdCAgICAgIHZhciBlbmQgPSBzdGFydDtcblx0ICAgICAgdmFyIG1heCA9IHRoaXMuZGF0YS5vcmRlci5sZW5ndGg7XG5cdCAgICAgIGlmIChjb3VudCkgd2hpbGUgKGVuZCA8IG1heCkge1xuXHQgICAgICAgIGlmICh0aGlzLmRhdGEub3JkZXJbZW5kXSAmJiB0aGlzLmRhdGEuZ2V0SXRlbSh0aGlzLmRhdGEub3JkZXJbZW5kXSkuJGxldmVsID09IHMubGV2ZWwpIHtcblx0ICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkgYnJlYWs7ZWxzZSBjb3VudC0tO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGVuZCsrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBlbmQ7XG5cdCAgICB9IGVsc2UgcmV0dXJuIHN0YXJ0ICsgY291bnQ7XG5cdCAgfSxcblx0ICBzZXRQYWdlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9wYWdlcikgdGhpcy5fcGFnZXIuc2VsZWN0KHZhbHVlKTtcblx0ICB9LFxuXHQgIGdldFBhZ2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wYWdlci5fc2V0dGluZ3MucGFnZTtcblx0ICB9LFxuXHQgIGdldFBhZ2VyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcGFnZXI7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBQcm9ncmVzc0JhciA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuX3Byb2dyZXNzKSAmJiB0aGlzLmF0dGFjaEV2ZW50KSB7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZUxvYWRcIiwgdGhpcy5zaG93UHJvZ3Jlc3MpO1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlckxvYWRcIiwgdGhpcy5oaWRlUHJvZ3Jlc3MpO1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcyA9IG51bGw7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBzaG93UHJvZ3Jlc3M6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIC8vIHsgcG9zaXRpb246IDAgLSAxLCBkZWxheTogMjAwMG1zIGJ5IGRlZmF1bHQsIGNzcyA6IG5hbWUgb2YgY3NzIGNsYXNzIHRvIHVzZSB9XG5cdCAgICBpZiAoIXRoaXMuX3Byb2dyZXNzKSB7XG5cdCAgICAgIGNvbmZpZyA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICAgICAgICBwb3NpdGlvbjogMCxcblx0ICAgICAgICBkZWxheTogMjAwMCxcblx0ICAgICAgICB0eXBlOiBcImljb25cIixcblx0ICAgICAgICBpY29uOiBcInd4aS1zeW5jXCIsXG5cdCAgICAgICAgaGlkZTogZmFsc2Vcblx0ICAgICAgfSwgY29uZmlnIHx8IHt9LCB0cnVlKTtcblx0ICAgICAgdmFyIGluY3NzID0gY29uZmlnLnR5cGUgPT0gXCJpY29uXCIgPyBjb25maWcuaWNvbiArIFwiIHdlYml4X3NwaW5cIiA6IFwiXCI7XG5cdCAgICAgIHRoaXMuX3Byb2dyZXNzID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfcHJvZ3Jlc3NfXCIgKyBjb25maWcudHlwZSxcblx0ICAgICAgICBcInJvbGVcIjogXCJwcm9ncmVzc2JhclwiLFxuXHQgICAgICAgIFwiYXJpYS12YWx1ZW1pblwiOiBcIjBcIixcblx0ICAgICAgICBcImFyaWEtdmFsdWVtYXhcIjogXCIxMDBcIixcblx0ICAgICAgICBcInRhYmluZGV4XCI6IFwiMFwiXG5cdCAgICAgIH0sIFwiPGRpdiBjbGFzcz0nd2ViaXhfcHJvZ3Jlc3Nfc3RhdGUgXCIgKyBpbmNzcyArIFwiJz48L2Rpdj5cIik7XG5cdCAgICAgIGlmICghdGhpcy5zZXRQb3NpdGlvbikgdGhpcy5fdmlld29iai5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0ICAgICAgaW5zZXJ0QmVmb3JlKHRoaXMuX3Byb2dyZXNzLCB0aGlzLl92aWV3b2JqLmZpcnN0Q2hpbGQsIHRoaXMuX3ZpZXdvYmopO1xuXG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsIFwidHJ1ZVwiKTtcblxuXHQgICAgICBpZiAoIVRvdWNoLiRhY3RpdmUpIHtcblx0ICAgICAgICBpZiAodGhpcy5nZXRTY3JvbGxTdGF0ZSkge1xuXHQgICAgICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblxuXHQgICAgICAgICAgaWYgKHRoaXMuX3ZpZXdvYmouc2Nyb2xsV2lkdGggIT0gdGhpcy4kd2lkdGgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3Muc3R5bGUubGVmdCA9IHNjcm9sbC54ICsgXCJweFwiO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAodGhpcy5fdmlld29iai5zY3JvbGxIZWlnaHQgIT0gdGhpcy4kaGVpZ2h0KSB7XG5cdCAgICAgICAgICAgIGlmIChjb25maWcudHlwZSAhPSBcImJvdHRvbVwiKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3Muc3R5bGUudG9wID0gc2Nyb2xsLnkgKyBcInB4XCI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3Muc3R5bGUudG9wID0gc2Nyb2xsLnkgKyB0aGlzLiRoZWlnaHQgLSB0aGlzLl9wcm9ncmVzcy5vZmZzZXRIZWlnaHQgKyBcInB4XCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9wcm9ncmVzc19kZWxheSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb25maWcgJiYgY29uZmlnLnR5cGUgIT0gXCJpY29uXCIpIGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzKSB7XG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uIHx8IDE7IC8vY2hlY2sgZm9yIGNzcy10cmFuc2l0aW9uIHN1cHBvcnRcblxuXHQgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzcy5zdHlsZVtlbnYudHJhbnNpdGlvbkR1cmF0aW9uXSAhPT0gdW5kZWZpbmVkIHx8ICFjb25maWcuZGVsYXkpIHtcblx0ICAgICAgICAgIHRoaXMuX3Byb2dyZXNzLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBwb3NpdGlvbiAqIDEwMCArIFwiJVwiO1xuXHQgICAgICAgICAgaWYgKGNvbmZpZy5kZWxheSkgdGhpcy5fcHJvZ3Jlc3MuZmlyc3RDaGlsZC5zdHlsZVtlbnYudHJhbnNpdGlvbkR1cmF0aW9uXSA9IGNvbmZpZy5kZWxheSArIFwibXNcIjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy9pZiBhbmltYXRpb24gaXMgbm90IHN1cHBvcnRlZCBmYWxsYmFjayB0byB0aW1lb3V0cyBbSUU5XVxuXHQgICAgICAgICAgdmFyIGNvdW50ID0gMCxcblx0ICAgICAgICAgICAgICBzdGFydCA9IDAsXG5cdCAgICAgICAgICAgICAgc3RlcCA9IHBvc2l0aW9uIC8gY29uZmlnLmRlbGF5ICogMzAsXG5cdCAgICAgICAgICAgICAgdmlldyA9IHRoaXM7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl9wcm9ncmVzc1RpbWVyKSB7XG5cdCAgICAgICAgICAgIC8vcmVzZXQgdGhlIGV4aXN0aW5nIHByb2dyZXNzXG5cdCAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX3Byb2dyZXNzVGltZXIpO1xuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuX3Byb2dyZXNzLmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGggLyB0aGlzLl9wcm9ncmVzcy5vZmZzZXRXaWR0aCAqIDEwMDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChjb3VudCAqIDMwID09IGNvbmZpZy5kZWxheSkge1xuXHQgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHZpZXcuX3Byb2dyZXNzVGltZXIpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIGlmICh2aWV3Ll9wcm9ncmVzcyAmJiB2aWV3Ll9wcm9ncmVzcy5maXJzdENoaWxkKSB2aWV3Ll9wcm9ncmVzcy5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gc3RhcnQgKyBjb3VudCAqIHN0ZXAgKiBwb3NpdGlvbiAqIDEwMCArIFwiJVwiO1xuXHQgICAgICAgICAgICAgIGNvdW50Kys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0sIDMwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY29uZmlnLmhpZGUpIGRlbGF5KHRoaXMuaGlkZVByb2dyZXNzLCB0aGlzLCBbMV0sIGNvbmZpZy5kZWxheSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9wcm9ncmVzc19kZWxheSA9IDA7XG5cdCAgICB9LCB0aGlzKTtlbHNlIGlmIChjb25maWcgJiYgY29uZmlnLnR5cGUgPT0gXCJpY29uXCIgJiYgY29uZmlnLmhpZGUpIGRlbGF5KHRoaXMuaGlkZVByb2dyZXNzLCB0aGlzLCBbMV0sIGNvbmZpZy5kZWxheSk7XG5cdCAgfSxcblx0ICBoaWRlUHJvZ3Jlc3M6IGZ1bmN0aW9uIChub3cpIHtcblx0ICAgIGlmICh0aGlzLl9wcm9ncmVzc19kZWxheSkgbm93ID0gdHJ1ZTtcblxuXHQgICAgaWYgKHRoaXMuX3Byb2dyZXNzKSB7XG5cdCAgICAgIGlmIChub3cpIHtcblx0ICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NUaW1lcikgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5fcHJvZ3Jlc3NUaW1lcik7XG5cdCAgICAgICAgcmVtb3ZlKHRoaXMuX3Byb2dyZXNzKTtcblx0ICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IG51bGw7XG5cblx0ICAgICAgICB0aGlzLl92aWV3b2JqLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYnVzeVwiKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLnNob3dQcm9ncmVzcyh7XG5cdCAgICAgICAgICBwb3NpdGlvbjogMS4xLFxuXHQgICAgICAgICAgZGVsYXk6IDMwMCxcblx0ICAgICAgICAgIGhpZGU6IHRydWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgUmVuZGVyU3RhY2sgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLmRhdGEsIFwiUmVuZGVyU3RhY2sgOjogQ29tcG9uZW50IGRvZXNuJ3QgaGF2ZSBEYXRhU3RvcmVcIik7XG5cdCAgICBhc3NlcnQodGVtcGxhdGUsIFwidGVtcGxhdGUgOjogdGVtcGxhdGUgaXMgbm90IGFjY2Vzc2libGVcIik7IC8vdXNlZCBmb3IgdGVtcG9yYXJ5IEhUTUwgZWxlbWVudHNcblx0ICAgIC8vYXV0b21hdGljYWxseSBudWxpZmllZCBkdXJpbmcgZGVzdHJ1Y3Rpb25cblxuXHQgICAgdGhpcy5faHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGJpbmQodGhpcy5fcmVuZGVyX2NoYW5nZV9pZCwgdGhpcykpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uSXRlbUNsaWNrXCIsIHRoaXMuX2NhbGxfb25jbGljayk7IC8vY3JlYXRlIGNvcHkgb2YgZGVmYXVsdCB0eXBlLCBhbmQgc2V0IGl0IGFzIGFjdGl2ZSBvbmVcblxuXHQgICAgaWYgKCF0aGlzLnR5cGVzKSB7XG5cdCAgICAgIHRoaXMudHlwZXMgPSB7XG5cdCAgICAgICAgXCJkZWZhdWx0XCI6IHRoaXMudHlwZVxuXHQgICAgICB9O1xuXHQgICAgICB0aGlzLnR5cGUubmFtZSA9IFwiZGVmYXVsdFwiO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnR5cGUgPSBjbG9uZSh0aGlzLnR5cGUpO1xuXHQgIH0sXG5cdCAgY3VzdG9taXplOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB0eXBlKHRoaXMsIG9iaik7XG5cdCAgfSxcblx0ICBpdGVtX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy50eXBlX3NldHRlcih2YWx1ZSk7XG5cdCAgfSxcblx0ICB0eXBlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXRoaXMudHlwZXNbdmFsdWVdKSB0aGlzLmN1c3RvbWl6ZSh2YWx1ZSk7ZWxzZSB7XG5cdCAgICAgIHRoaXMudHlwZSA9IGNsb25lKHRoaXMudHlwZXNbdmFsdWVdKTtcblx0ICAgICAgaWYgKHRoaXMudHlwZS5jc3MpIHRoaXMuX2NvbnRlbnRvYmouY2xhc3NOYW1lICs9IFwiIFwiICsgdGhpcy50eXBlLmNzcztcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnR5cGUub25fY2xpY2spIGV4cG9ydHMuZXh0ZW5kKHRoaXMub25fY2xpY2ssIHRoaXMudHlwZS5vbl9jbGljayk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICB0ZW1wbGF0ZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy50eXBlLnRlbXBsYXRlID0gdGVtcGxhdGUodmFsdWUpO1xuXHQgIH0sXG5cdCAgLy9jb252ZXJ0IHNpbmdsZSBpdGVtIHRvIEhUTUwgdGV4dCAodGVtcGxhdGluZylcblx0ICBfdG9IVE1MOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgbWFyayA9IHRoaXMuZGF0YS5fbWFya3Nbb2JqLmlkXTsgLy9jaGVjayBpZiByZWxhdGVkIHRlbXBsYXRlIGV4aXN0XG5cblx0ICAgIGFzc2VydCghb2JqLiR0ZW1wbGF0ZSB8fCB0aGlzLnR5cGVbXCJ0ZW1wbGF0ZVwiICsgb2JqLiR0ZW1wbGF0ZV0sIFwiUmVuZGVyU3RhY2sgOjogVW5rbm93biB0ZW1wbGF0ZTogXCIgKyBvYmouJHRlbXBsYXRlKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25JdGVtUmVuZGVyXCIsIFtvYmpdKTtcblx0ICAgIHJldHVybiB0aGlzLnR5cGUudGVtcGxhdGVTdGFydChvYmosIHRoaXMudHlwZSwgbWFyaykgKyAob2JqLiR0ZW1wbGF0ZSA/IHRoaXMudHlwZVtcInRlbXBsYXRlXCIgKyBvYmouJHRlbXBsYXRlXSA6IHRoaXMudHlwZS50ZW1wbGF0ZSkob2JqLCB0aGlzLnR5cGUsIG1hcmspICsgdGhpcy50eXBlLnRlbXBsYXRlRW5kKG9iaiwgdGhpcy50eXBlLCBtYXJrKTtcblx0ICB9LFxuXHQgIC8vY29udmVydCBpdGVtIHRvIEhUTUwgb2JqZWN0ICh0ZW1wbGF0aW5nKVxuXHQgIF90b0hUTUxPYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHRoaXMuX2h0bWwuaW5uZXJIVE1MID0gdGhpcy5fdG9IVE1MKG9iaik7XG5cdCAgICByZXR1cm4gdGhpcy5faHRtbC5maXJzdENoaWxkO1xuXHQgIH0sXG5cdCAgX3JlbmRlcl9jaGFuZ2VfaWQ6IGZ1bmN0aW9uIChvbGQsIG5ld2lkKSB7XG5cdCAgICB2YXIgb2JqID0gdGhpcy5nZXRJdGVtTm9kZShvbGQpO1xuXG5cdCAgICBpZiAob2JqKSB7XG5cdCAgICAgIG9iai5zZXRBdHRyaWJ1dGUodGhpcy5faWQsIG5ld2lkKTtcblx0ICAgICAgdGhpcy5faHRtbG1hcFtuZXdpZF0gPSB0aGlzLl9odG1sbWFwW29sZF07XG5cdCAgICAgIGRlbGV0ZSB0aGlzLl9odG1sbWFwW29sZF07XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2NhbGxzIGZ1bmN0aW9uIHRoYXQgaXMgc2V0IGluIG9uY2xpY2sgcHJvcGVydHlcblx0ICBfY2FsbF9vbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2xpY2spIHtcblx0ICAgICAgdmFyIGNvZGUgPSB0b0Z1bmN0b3IodGhpcy5fc2V0dGluZ3MuY2xpY2ssIHRoaXMuJHNjb3BlKTtcblx0ICAgICAgaWYgKGNvZGUgJiYgY29kZS5jYWxsKSBjb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL3JldHVybiBodG1sIGNvbnRhaW5lciBieSBpdHMgSURcblx0ICAvL2NhbiByZXR1cm4gdW5kZWZpbmVkIGlmIGNvbnRhaW5lciBkb2Vzbid0IGV4aXN0c1xuXHQgIGdldEl0ZW1Ob2RlOiBmdW5jdGlvbiAoc2VhcmNoX2lkKSB7XG5cdCAgICBpZiAodGhpcy5faHRtbG1hcCkgcmV0dXJuIHRoaXMuX2h0bWxtYXBbc2VhcmNoX2lkXTsgLy9maWxsIG1hcCBpZiBpdCBkb2Vzbid0IGNyZWF0ZWQgeWV0XG5cblx0ICAgIHRoaXMuX2h0bWxtYXAgPSB7fTtcblx0ICAgIHZhciB0ID0gdGhpcy5fZGF0YW9iai5jaGlsZE5vZGVzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGlkID0gdFtpXS5nZXRBdHRyaWJ1dGUodGhpcy5faWQpOyAvL2dldCBpdGVtJ3NcblxuXHQgICAgICBpZiAoaWQpIHRoaXMuX2h0bWxtYXBbaWRdID0gdFtpXTtcblx0ICAgIH0gLy9jYWxsIGxvY2F0b3IgYWdhaW4sIHdoZW4gbWFwIGlzIGZpbGxlZFxuXG5cblx0ICAgIHJldHVybiB0aGlzLmdldEl0ZW1Ob2RlKHNlYXJjaF9pZCk7XG5cdCAgfSxcblx0ICAvL3JldHVybiBpZCBvZiBpdGVtIGZyb20gaHRtbCBldmVudFxuXHQgIGxvY2F0ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBsb2NhdGUoZSwgdGhpcy5faWQpO1xuXHQgIH0sXG5cblx0ICAvKmNoYW5nZSBzY3JvbGxpbmcgc3RhdGUgb2YgdG9wIGxldmVsIGNvbnRhaW5lciwgc28gcmVsYXRlZCBpdGVtIHdpbGwgYmUgaW4gdmlzaWJsZSBwYXJ0Ki9cblx0ICBzaG93SXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgaHRtbCA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXG5cdCAgICBpZiAoaHRtbCAmJiB0aGlzLnNjcm9sbFRvKSB7XG5cdCAgICAgIHZhciB0eG1pbiA9IGh0bWwub2Zmc2V0TGVmdDtcblx0ICAgICAgdmFyIHR4bWF4ID0gdHhtaW4gKyBodG1sLm9mZnNldFdpZHRoO1xuXHQgICAgICB2YXIgdHltaW4gPSBodG1sLm9mZnNldFRvcDtcblx0ICAgICAgdmFyIHR5bWF4ID0gdHltaW4gKyBodG1sLm9mZnNldEhlaWdodDtcblx0ICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpO1xuXHQgICAgICB2YXIgeCA9IHN0YXRlLng7XG5cdCAgICAgIGlmICh4ID4gdHhtaW4gfHwgeCArIHRoaXMuX2NvbnRlbnRfd2lkdGggPCB0eG1heCkgeCA9IHR4bWluO1xuXHQgICAgICB2YXIgeSA9IHN0YXRlLnk7XG5cdCAgICAgIGlmICh5ID4gdHltaW4gfHwgeSArIHRoaXMuX2NvbnRlbnRfaGVpZ2h0IDwgdHltYXgpIHkgPSB0eW1pbjtcblx0ICAgICAgdGhpcy5zY3JvbGxUbyh4LCB5KTtcblx0ICAgICAgaWYgKHRoaXMuX3NldEl0ZW1BY3RpdmUpIHRoaXMuX3NldEl0ZW1BY3RpdmUoaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy91cGRhdGUgdmlldyBhZnRlciBkYXRhIHVwZGF0ZVxuXHQgIC8vbWV0aG9kIGNhbGxzIGxvdy1sZXZlbCByZW5kZXJpbmcgZm9yIHJlbGF0ZWQgaXRlbXNcblx0ICAvL3doZW4gY2FsbGVkIHdpdGhvdXQgcGFyYW1ldGVycyAtIGFsbCB2aWV3IHJlZnJlc2hlZFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKGlkLCBkYXRhLCB0eXBlJCQxKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSB8fCB0aGlzLiRibG9ja1JlbmRlcikgcmV0dXJuO1xuXG5cdCAgICBpZiAoaWQpIHtcblx0ICAgICAgdmFyIGNvbnQgPSB0aGlzLmdldEl0ZW1Ob2RlKGlkKTsgLy9nZXQgaHRtbCBlbGVtZW50IG9mIHVwZGF0ZWQgaXRlbVxuXG5cdCAgICAgIHN3aXRjaCAodHlwZSQkMSkge1xuXHQgICAgICAgIGNhc2UgXCJwYWludFwiOlxuXHQgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcblx0ICAgICAgICAgIC8vaW4gY2FzZSBvZiB1cGRhdGUgLSByZXBsYWNlIGV4aXN0aW5nIGh0bWwgd2l0aCB1cGRhdGVkIG9uZVxuXHQgICAgICAgICAgaWYgKCFjb250KSByZXR1cm47XG5cblx0ICAgICAgICAgIHZhciB0MSA9IHRoaXMuX2h0bWxtYXBbaWRdID0gdGhpcy5fdG9IVE1MT2JqZWN0KGRhdGEpO1xuXG5cdCAgICAgICAgICBpbnNlcnRCZWZvcmUodDEsIGNvbnQpO1xuXHQgICAgICAgICAgcmVtb3ZlKGNvbnQpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG5cdCAgICAgICAgICAvL2luIGNhc2Ugb2YgZGVsZXRlIC0gcmVtb3ZlIHJlbGF0ZWQgaHRtbFxuXHQgICAgICAgICAgaWYgKCFjb250KSByZXR1cm47XG5cdCAgICAgICAgICByZW1vdmUoY29udCk7XG5cdCAgICAgICAgICBkZWxldGUgdGhpcy5faHRtbG1hcFtpZF07XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCJhZGRcIjpcblx0ICAgICAgICAgIC8vaW4gY2FzZSBvZiBhZGQgLSBwdXQgbmV3IGh0bWwgYXQgbmVjZXNzYXJ5IHBvc2l0aW9uXG5cdCAgICAgICAgICB2YXIgdDIgPSB0aGlzLl9odG1sbWFwW2lkXSA9IHRoaXMuX3RvSFRNTE9iamVjdChkYXRhKTtcblxuXHQgICAgICAgICAgaW5zZXJ0QmVmb3JlKHQyLCB0aGlzLmdldEl0ZW1Ob2RlKHRoaXMuZGF0YS5nZXROZXh0SWQoaWQpKSwgdGhpcy5fZGF0YW9iaik7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCJtb3ZlXCI6XG5cdCAgICAgICAgICAvL21vdmluZyB3aXRob3V0IHJlcGFpbnRpbmcgdGhlIGl0ZW1cblx0ICAgICAgICAgIGluc2VydEJlZm9yZSh0aGlzLmdldEl0ZW1Ob2RlKGlkKSwgdGhpcy5nZXRJdGVtTm9kZSh0aGlzLmRhdGEuZ2V0TmV4dElkKGlkKSksIHRoaXMuX2RhdGFvYmopO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgYXNzZXJ0KDAsIFwiVW5rbm93biByZW5kZXIgY29tbWFuZDogXCIgKyB0eXBlJCQxKTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvL2Z1bGwgcmVzZXRcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVSZW5kZXJcIiwgW3RoaXMuZGF0YV0pKSB7XG5cdCAgICAgICAgLy9nZXRSYW5nZSAtIHJldHVybnMgYWxsIGVsZW1lbnRzXG5cdCAgICAgICAgKHRoaXMuX3JlbmRlcm9iaiB8fCB0aGlzLl9kYXRhb2JqKS5pbm5lckhUTUwgPSB0aGlzLmRhdGEuZ2V0UmFuZ2UoKS5tYXAodGhpcy5fdG9IVE1MLCB0aGlzKS5qb2luKFwiXCIpO1xuXHQgICAgICAgIHRoaXMuX2h0bWxtYXAgPSBudWxsOyAvL2NsZWFyIG1hcCwgaXQgd2lsbCBiZSBmaWxsZWQgYXQgZmlyc3QgZ2V0SXRlbU5vZGVcblxuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclJlbmRlclwiLCBbXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIFNjcm9sbGFibGUgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIC8vZG8gbm90IHNwYW0gdW53YW50ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgZm9yIHRlbXBsYXRlcyBcblx0ICAgIGlmIChjb25maWcgJiYgIWNvbmZpZy5zY3JvbGwgJiYgdGhpcy5fb25lX3RpbWVfc2Nyb2xsKSByZXR1cm4gdGhpcy5fZGF0YW9iaiA9IHRoaXMuX2RhdGFvYmogfHwgdGhpcy5fY29udGVudG9iajtcblxuXHQgICAgKHRoaXMuX2RhdGFvYmogfHwgdGhpcy5fY29udGVudG9iaikuYXBwZW5kQ2hpbGQoY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Njcm9sbF9jb250XCJcblx0ICAgIH0sIFwiXCIpKTtcblxuXHQgICAgdGhpcy5fZGF0YW9iaiA9ICh0aGlzLl9kYXRhb2JqIHx8IHRoaXMuX2NvbnRlbnRvYmopLmZpcnN0Q2hpbGQ7XG5cdCAgICBpZiAoIWVudi50b3VjaCB8fCBlbnYudG91Y2ggPT09IFwibmF0aXZlXCIpIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcInNjcm9sbFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KSBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU2Nyb2xsXCIsIFtdKTtcblx0ICAgICAgfSwgdGhpcyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgfSxcblxuXHQgIC8qZGVmYXVsdHM6e1xuXHQgIFx0c2Nyb2xsOnRydWVcblx0ICB9LCovXG5cdCAgc2Nyb2xsX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdCAgICB2YXIgYXV0byA9IHZhbHVlID09PSBcImF1dG9cIjtcblx0ICAgIHZhciBtYXJrZXIgPSB2YWx1ZSA9PSBcInhcIiA/IFwieFwiIDogdmFsdWUgPT0gXCJ4eVwiID8gXCJ4eVwiIDogYXV0byA/IFwieHlcIiA6IFwieVwiO1xuXG5cdCAgICBpZiAoVG91Y2guJGFjdGl2ZSAmJiBlbnYudG91Y2ggIT0gXCJuYXRpdmVcIikge1xuXHQgICAgICB0aGlzLl9kYXRhb2JqLnNldEF0dHJpYnV0ZShcInRvdWNoX3Njcm9sbFwiLCBtYXJrZXIpO1xuXG5cdCAgICAgIGlmICh0aGlzLmF0dGFjaEV2ZW50KSB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlclJlbmRlclwiLCBiaW5kKHRoaXMuX3JlZnJlc2hfc2Nyb2xsLCB0aGlzKSk7XG5cdCAgICAgIHRoaXMuX3RvdWNoX3Njcm9sbCA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoZW52LiRjdXN0b21TY3JvbGwpIHtcblx0ICAgICAgICB0ZW1wJDEuZW5hYmxlKHRoaXMsIG1hcmtlcik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9kYXRhb2JqLnBhcmVudE5vZGUuc3R5bGU7XG5cblx0ICAgICAgICBpZiAoYXV0bykge1xuXHQgICAgICAgICAgbm9kZS5vdmVyZmxvd1ggPSBub2RlLm92ZXJmbG93WSA9IFwiYXV0b1wiO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAobWFya2VyLmluZGV4T2YoXCJ4XCIpICE9IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Njcm9sbF94ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgbm9kZS5vdmVyZmxvd1ggPSBcInNjcm9sbFwiO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAobWFya2VyLmluZGV4T2YoXCJ5XCIpICE9IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Njcm9sbF95ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgbm9kZS5vdmVyZmxvd1kgPSBcInNjcm9sbFwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbWFya2VyO1xuXHQgIH0sXG5cdCAgX29ub2ZmX3Njcm9sbDogZnVuY3Rpb24gKG1vZGUsIGRpcikge1xuXHQgICAgaWYgKCEhdGhpcy5fc2V0dGluZ3Muc2Nyb2xsID09ICEhbW9kZSkgcmV0dXJuO1xuXG5cdCAgICBpZiAoIWVudi4kY3VzdG9tU2Nyb2xsKSB7XG5cdCAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2RhdGFvYmoucGFyZW50Tm9kZS5zdHlsZTtcblx0ICAgICAgc3R5bGVbZGlyID09PSBcInhcIiA/IFwib3ZlcmZsb3dYXCIgOiBcIm92ZXJmbG93WVwiXSA9IG1vZGUgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkaXIgPT09IFwieFwiKSB7XG5cdCAgICAgIHRoaXMuX3Njcm9sbF94ID0gbW9kZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3Njcm9sbF95ID0gbW9kZTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2V0dGluZ3Muc2Nyb2xsID0gbW9kZSA/IGRpciA6IGZhbHNlO1xuXHQgIH0sXG5cdCAgZ2V0U2Nyb2xsU3RhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChUb3VjaC4kYWN0aXZlKSB7XG5cdCAgICAgIHZhciB0ZW1wID0gVG91Y2guX2dldF9tYXRyaXgodGhpcy5fZGF0YW9iaik7XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB4OiAtdGVtcC5lLFxuXHQgICAgICAgIHk6IC10ZW1wLmZcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSByZXR1cm4ge1xuXHQgICAgICB4OiB0aGlzLl9kYXRhb2JqLnBhcmVudE5vZGUuc2Nyb2xsTGVmdCxcblx0ICAgICAgeTogdGhpcy5fZGF0YW9iai5wYXJlbnROb2RlLnNjcm9sbFRvcFxuXHQgICAgfTtcblx0ICB9LFxuXHQgIHNjcm9sbFRvOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgaWYgKFRvdWNoLiRhY3RpdmUgJiYgZW52LnRvdWNoICE9IFwibmF0aXZlXCIpIHtcblx0ICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHksIHRoaXMuX2RhdGFvYmoub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fY29udGVudF9oZWlnaHQpKTtcblx0ICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHgsIHRoaXMuX2RhdGFvYmoub2Zmc2V0V2lkdGggLSB0aGlzLl9jb250ZW50X3dpZHRoKSk7XG5cblx0ICAgICAgVG91Y2guX3NldF9tYXRyaXgodGhpcy5fZGF0YW9iaiwgLXgsIC15LCB0aGlzLl9zZXR0aW5ncy5zY3JvbGxTcGVlZCB8fCBcIjEwMG1zXCIpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fZGF0YW9iai5wYXJlbnROb2RlLnNjcm9sbExlZnQgPSB4O1xuXHQgICAgICB0aGlzLl9kYXRhb2JqLnBhcmVudE5vZGUuc2Nyb2xsVG9wID0geTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9yZWZyZXNoX3Njcm9sbDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNjcm9sbC50b1N0cmluZygpLmluZGV4T2YoXCJ4XCIpICE9IC0xKSB7XG5cdCAgICAgIHZhciB4ID0gdGhpcy5fZGF0YW9iai5zY3JvbGxXaWR0aDtcblxuXHQgICAgICBpZiAoeCkge1xuXHQgICAgICAgIC8vaW4gaGlkZGVuIHN0YXRlIHdlIHdpbGwgaGF2ZSBhIFplcm8gc2Nyb2xsV2lkdGhcblx0ICAgICAgICB0aGlzLl9kYXRhb2JqLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cdCAgICAgICAgdGhpcy5fZGF0YW9iai5zdHlsZS53aWR0aCA9IHRoaXMuX2RhdGFvYmouc2Nyb2xsV2lkdGggKyBcInB4XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKFRvdWNoLiRhY3RpdmUgJiYgdGhpcy5fdG91Y2hfc2Nyb2xsKSB7XG5cdCAgICAgIFRvdWNoLl9jbGVhcl9hcnRlZmFjdHMoKTtcblxuXHQgICAgICBUb3VjaC5fc2Nyb2xsX2VuZCgpO1xuXG5cdCAgICAgIHZhciBzID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpO1xuXHQgICAgICB2YXIgZHggPSB0aGlzLl9kYXRhb2JqLm9mZnNldFdpZHRoIC0gdGhpcy4kd2lkdGggLSBzLng7XG5cdCAgICAgIHZhciBkeSA9IHRoaXMuX2RhdGFvYmoub2Zmc2V0SGVpZ2h0IC0gdGhpcy4kaGVpZ2h0IC0gcy55OyAvL2lmIGN1cnJlbnQgc2Nyb2xsIGlzIG91dHNpZGUgb2YgZGF0YSBhcmVhXG5cblx0ICAgICAgaWYgKGR4IDwgMCB8fCBkeSA8IDApIHtcblx0ICAgICAgICAvL3Njcm9sbCB0byB0aGUgZW5kIG9mIGRhdGEgYXJlYVxuXHQgICAgICAgIHZhciBfeCA9IGR4IDwgMCA/IE1hdGgubWluKC1keCAtIHMueCwgMCkgOiAtcy54O1xuXG5cdCAgICAgICAgdmFyIHkgPSBkeSA8IDAgPyBNYXRoLm1pbigtZHkgLSBzLnksIDApIDogLXMueTtcblxuXHQgICAgICAgIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2RhdGFvYmosIF94LCB5LCAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHQvKlxuXHRcdEJlaGF2aW9yOlNlbGVjdGlvbk1vZGVsIC0gbWFuYWdlIHNlbGVjdGlvbiBzdGF0ZXNcblx0XHRAZXhwb3J0XG5cdFx0XHRzZWxlY3Rcblx0XHRcdHVuc2VsZWN0XG5cdFx0XHRzZWxlY3RBbGxcblx0XHRcdHVuc2VsZWN0QWxsXG5cdFx0XHRpc1NlbGVjdGVkXG5cdFx0XHRnZXRTZWxlY3RlZElkXG5cdCovXG5cblx0dmFyIFNlbGVjdGlvbk1vZGVsID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAvL2NvbGxlY3Rpb24gb2Ygc2VsZWN0ZWQgSURzXG5cdCAgICB0aGlzLl9zZWxlY3RlZCA9IHRvQXJyYXkoKTtcblx0ICAgIGFzc2VydCh0aGlzLmRhdGEsIFwiU2VsZWN0aW9uTW9kZWwgOjogQ29tcG9uZW50IGRvZXNuJ3QgaGF2ZSBEYXRhU3RvcmVcIik7IC8vcmVtb3ZlIHNlbGVjdGlvbiBmcm9tIGRlbGV0ZWQgaXRlbXNcblxuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgYmluZCh0aGlzLl9kYXRhX3VwZGF0ZWQsIHRoaXMpKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVMb2FkXCIsIGJpbmQodGhpcy5fZGF0YV9sb2FkZWQsIHRoaXMpKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJGaWx0ZXJcIiwgYmluZCh0aGlzLl9kYXRhX2ZpbHRlcmVkLCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN5bmNBcHBseVwiLCBiaW5kKHRoaXMuX3NlbGVjdF9jaGVjaywgdGhpcykpO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25JZENoYW5nZVwiLCBiaW5kKHRoaXMuX2lkX2NoYW5nZWQsIHRoaXMpKTtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fc2V0X25vc2VsZWN0KTtcblx0ICB9LFxuXHQgIF9zZXRfbm9zZWxlY3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zZWxlY3QgPT0gXCJtdWx0aXNlbGVjdFwiIHx8IHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0IHx8IHRoaXMuX3NldHRpbmdzLnNlbGVjdCA9PSBcImFyZWFcIikgX2V2ZW50KHRoaXMuJHZpZXcsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBzaGlmdEtleSA9IChlIHx8IGV2ZW50JDEpLnNoaWZ0S2V5O1xuXG5cdCAgICAgIGlmIChzaGlmdEtleSkge1xuXHQgICAgICAgIHN0YXRlLl9ub3NlbGVjdF9lbGVtZW50ID0gdGhpcztcblx0ICAgICAgICBhZGRDc3ModGhpcywgXCJ3ZWJpeF9ub3NlbGVjdFwiLCAxKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfaWRfY2hhbmdlZDogZnVuY3Rpb24gKG9sZGlkLCBuZXdpZCkge1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMuX3NlbGVjdGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFtpXSA9PSBvbGRpZCkgdGhpcy5fc2VsZWN0ZWRbaV0gPSBuZXdpZDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9kYXRhX2ZpbHRlcmVkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgaWYgKHRoaXMuZGF0YS5nZXRJbmRleEJ5SWQodGhpcy5fc2VsZWN0ZWRbaV0pIDwgMCkge1xuXHQgICAgICAgIHZhciBpZCA9IHRoaXMuX3NlbGVjdGVkW2ldO1xuXHQgICAgICAgIHRoaXMucmVtb3ZlQ3NzKGlkLCBcIndlYml4X3NlbGVjdGVkXCIsIHRydWUpO1xuXG5cdCAgICAgICAgdGhpcy5fc2VsZWN0ZWQuc3BsaWNlKGksIDEpO1xuXG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNlbGVjdENoYW5nZVwiLCBbaWRdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9oZWxwZXIgLSBsaW5rZWQgdG8gb25TdG9yZVVwZGF0ZWRcblx0ICBfZGF0YV91cGRhdGVkOiBmdW5jdGlvbiAoaWQsIG9iaiwgdHlwZSkge1xuXHQgICAgaWYgKHR5cGUgPT0gXCJkZWxldGVcIikge1xuXHQgICAgICAvL3JlbW92ZSBzZWxlY3Rpb24gZnJvbSBkZWxldGVkIGl0ZW1zXG5cdCAgICAgIGlmICh0aGlzLmxvYWRCcmFuY2gpIHtcblx0ICAgICAgICAvL2hpZXJhcmNoeSwgbmVlZCB0byBjaGVjayBhbGxcblx0ICAgICAgICB0aGlzLl9zZWxlY3RfY2hlY2soKTtcblx0ICAgICAgfSBlbHNlIHRoaXMuX3NlbGVjdGVkLnJlbW92ZShpZCk7XG5cdCAgICB9IGVsc2UgaWYgKCFpZCAmJiAhdGhpcy5kYXRhLmNvdW50KCkgJiYgIXRoaXMuZGF0YS5fZmlsdGVyX29yZGVyKSB7XG5cdCAgICAgIC8vcmVtb3ZlIHNlbGVjdGlvbiBmb3IgY2xlYXJBbGxcblx0ICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0b0FycmF5KCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZGF0YV9sb2FkZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zZWxlY3QpIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgaWYgKG9iaiAmJiBvYmouJHNlbGVjdGVkKSB0aGlzLnNlbGVjdChvYmouaWQpO1xuXHQgICAgfSwgdGhpcyk7XG5cdCAgfSxcblx0ICBfc2VsZWN0X2NoZWNrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgaWYgKCF0aGlzLmV4aXN0cyh0aGlzLl9zZWxlY3RlZFtpXSkpIHRoaXMuX3NlbGVjdGVkLnNwbGljZShpLCAxKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vaGVscGVyIC0gY2hhbmdlcyBzdGF0ZSBvZiBzZWxlY3Rpb24gZm9yIHNvbWUgaXRlbVxuXHQgIF9zZWxlY3RfbWFyazogZnVuY3Rpb24gKGlkLCBzdGF0ZSQkMSwgcmVmcmVzaCwgbmVlZF91bnNlbGVjdCkge1xuXHQgICAgdmFyIHNuYW1lID0gc3RhdGUkJDEgPyBcIm9uQmVmb3JlU2VsZWN0XCIgOiBcIm9uQmVmb3JlVW5TZWxlY3RcIjtcblx0ICAgIGlmICghdGhpcy5jYWxsRXZlbnQoc25hbWUsIFtpZCwgc3RhdGUkJDFdKSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICBpZiAobmVlZF91bnNlbGVjdCkge1xuXHQgICAgICB0aGlzLl9zaWxlbnRfc2VsZWN0aW9uID0gdHJ1ZTtcblx0ICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuXHQgICAgICB0aGlzLl9zaWxlbnRfc2VsZWN0aW9uID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGF0ZSQkMSkgdGhpcy5hZGRDc3MoaWQsIFwid2ViaXhfc2VsZWN0ZWRcIiwgdHJ1ZSk7ZWxzZSB0aGlzLnJlbW92ZUNzcyhpZCwgXCJ3ZWJpeF9zZWxlY3RlZFwiLCB0cnVlKTtcblx0ICAgIGlmIChyZWZyZXNoKSByZWZyZXNoLnB1c2goaWQpOyAvL2lmIHdlIGluIHRoZSBtYXNzLXNlbGVjdCBtb2RlIC0gY29sbGVjdCBhbGwgY2hhbmdlZCBJRHNcblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIGlmIChzdGF0ZSQkMSkgdGhpcy5fc2VsZWN0ZWQucHVzaChpZCk7IC8vdGhlbiBhZGQgdG8gbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuXHQgICAgICAgIGVsc2UgdGhpcy5fc2VsZWN0ZWQucmVtb3ZlKGlkKTtcblxuXHQgICAgICAgIHRoaXMuX3JlZnJlc2hfc2VsZWN0aW9uKGlkKTsgLy9vdGhlcnZpc2UgdHJpZ2dlciByZXBhaW50aW5nXG5cblx0ICAgICAgfVxuXHQgICAgdmFyIGVuYW1lID0gc3RhdGUkJDEgPyBcIm9uQWZ0ZXJTZWxlY3RcIiA6IFwib25BZnRlclVuU2VsZWN0XCI7XG5cdCAgICB0aGlzLmNhbGxFdmVudChlbmFtZSwgW2lkXSk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIC8vc2VsZWN0IHNvbWUgaXRlbVxuXHQgIHNlbGVjdDogZnVuY3Rpb24gKGlkLCBwcmVzZXJ2ZSkge1xuXHQgICAgdmFyIGN0cmxLZXkgPSBhcmd1bWVudHNbMl07XG5cdCAgICB2YXIgc2hpZnRLZXkgPSBhcmd1bWVudHNbM107IC8vaWYgaWQgbm90IHByb3ZpZGUgLSB3b3JrcyBhcyBzZWxlY3RBbGxcblxuXHQgICAgaWYgKCFpZCkgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKCk7IC8vYWxsb3cgYW4gYXJyYXkgb2YgaWRzIGFzIHBhcmFtZXRlclxuXG5cdCAgICBpZiAoaXNBcnJheShpZCkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMuc2VsZWN0KGlkW2ldLCBpID8gMSA6IHByZXNlcnZlLCBjdHJsS2V5LCBzaGlmdEtleSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydCh0aGlzLmRhdGEuZXhpc3RzKGlkKSwgXCJJbmNvcnJlY3QgaWQgaW4gc2VsZWN0IGNvbW1hbmQ6IFwiICsgaWQpOyAvL2Jsb2NrIHNlbGVjdGlvbiBtb2RlXG5cblx0ICAgIGlmIChzaGlmdEtleSAmJiB0aGlzLl9zZWxlY3RlZC5sZW5ndGgpIHJldHVybiB0aGlzLnNlbGVjdEFsbCh0aGlzLl9zZWxlY3RlZFt0aGlzLl9zZWxlY3RlZC5sZW5ndGggLSAxXSwgaWQpOyAvL3NpbmdsZSBzZWxlY3Rpb24gbW9kZVxuXG5cdCAgICB2YXIgbmVlZF91bnNlbGVjdCA9IGZhbHNlO1xuXHQgICAgaWYgKCFjdHJsS2V5ICYmICFwcmVzZXJ2ZSAmJiAodGhpcy5fc2VsZWN0ZWQubGVuZ3RoICE9IDEgfHwgdGhpcy5fc2VsZWN0ZWRbMF0gIT0gaWQpKSBuZWVkX3Vuc2VsZWN0ID0gdHJ1ZTtcblxuXHQgICAgaWYgKCFuZWVkX3Vuc2VsZWN0ICYmIHRoaXMuaXNTZWxlY3RlZChpZCkpIHtcblx0ICAgICAgaWYgKGN0cmxLZXkpIHRoaXMudW5zZWxlY3QoaWQpOyAvL2N0cmwtc2VsZWN0aW9uIG9mIGFscmVhZHkgc2VsZWN0ZWQgaXRlbVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2VsZWN0X21hcmsoaWQsIHRydWUsIG51bGwsIG5lZWRfdW5zZWxlY3QpO1xuXHQgIH0sXG5cdCAgLy91bnNlbGVjdCBzb21lIGl0ZW1cblx0ICB1bnNlbGVjdDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAvL2lmIGlkIGlzIG5vdCBwcm92aWRlZCAgLSB1bnNlbGVjdCBhbGwgaXRlbXNcblx0ICAgIGlmICghaWQpIHJldHVybiB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cdCAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpZCkpIHJldHVybjtcblxuXHQgICAgdGhpcy5fc2VsZWN0X21hcmsoaWQsIGZhbHNlKTtcblx0ICB9LFxuXHQgIC8vc2VsZWN0IGFsbCBpdGVtcywgb3IgYWxsIGluIGRlZmluZWQgcmFuZ2Vcblx0ICBzZWxlY3RBbGw6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuXHQgICAgdmFyIHJhbmdlO1xuXHQgICAgdmFyIHJlZnJlc2ggPSBbXTtcblx0ICAgIGlmIChmcm9tIHx8IHRvKSByYW5nZSA9IHRoaXMuZGF0YS5nZXRSYW5nZShmcm9tIHx8IG51bGwsIHRvIHx8IG51bGwpOyAvL2dldCBsaW1pdGVkIHNldCBpZiBib3VuZHMgZGVmaW5lZFxuXHQgICAgZWxzZSByYW5nZSA9IHRoaXMuZGF0YS5nZXRSYW5nZSgpOyAvL2dldCBhbGwgaXRlbXMgaW4gb3RoZXIgY2FzZVxuXHQgICAgLy9pbiBjYXNlIG9mIHBhZ2luZyAtIGl0IHdpbGwgYmUgY3VycmVudCBwYWdlIG9ubHlcblxuXHQgICAgcmFuZ2UuZWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIGlmICghdGhpcy5kYXRhLmdldE1hcmsob2JqLmlkLCBcIndlYml4X3NlbGVjdGVkXCIpKSB7XG5cdCAgICAgICAgdGhpcy5fc2VsZWN0ZWQucHVzaChvYmouaWQpO1xuXG5cdCAgICAgICAgdGhpcy5fc2VsZWN0X21hcmsob2JqLmlkLCB0cnVlLCByZWZyZXNoKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcyk7IC8vcmVwYWludCBzZWxmXG5cblx0ICAgIHRoaXMuX3JlZnJlc2hfc2VsZWN0aW9uKHJlZnJlc2gpO1xuXHQgIH0sXG5cdCAgLy9yZW1vdmUgc2VsZWN0aW9uIGZyb20gYWxsIGl0ZW1zXG5cdCAgdW5zZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByZWZyZXNoID0gW107XG5cblx0ICAgIHRoaXMuX3NlbGVjdGVkLmVhY2goZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgIHRoaXMuX3NlbGVjdF9tYXJrKGlkLCBmYWxzZSwgcmVmcmVzaCk7IC8vdW5tYXJrIHNlbGVjdGVkIG9ubHlcblxuXHQgICAgfSwgdGhpcyk7XG5cblx0ICAgIHRoaXMuX3NlbGVjdGVkID0gdG9BcnJheSgpO1xuXG5cdCAgICB0aGlzLl9yZWZyZXNoX3NlbGVjdGlvbihyZWZyZXNoKTsgLy9yZXBhaW50IHNlbGZcblxuXHQgIH0sXG5cdCAgLy9yZXR1cm5zIHRydWUgaWYgaXRlbSBpcyBzZWxlY3RlZFxuXHQgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkLmZpbmQoaWQpICE9IC0xO1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0cmV0dXJucyBJRCBvZiBzZWxlY3RlZCBpdGVtcyBvciBhcnJheSBvZiBJRHNcblx0ICBcdHRvIG1ha2UgcmVzdWx0IHByZWRpY3RhYmxlIC0gYXNfYXJyYXkgY2FuIGJlIHVzZWQsIFxuXHQgIFx0XHR3aXRoIHN1Y2ggZmxhZyBjb21tYW5kIHdpbGwgYWx3YXlzIHJldHVybiBhbiBhcnJheSBcblx0ICBcdFx0ZW1wdHkgYXJyYXkgaW4gY2FzZSB3aGVuIG5vIGl0ZW0gd2FzIHNlbGVjdGVkXG5cdCAgKi9cblx0ICBnZXRTZWxlY3RlZElkOiBmdW5jdGlvbiAoYXNfYXJyYXkpIHtcblx0ICAgIHN3aXRjaCAodGhpcy5fc2VsZWN0ZWQubGVuZ3RoKSB7XG5cdCAgICAgIGNhc2UgMDpcblx0ICAgICAgICByZXR1cm4gYXNfYXJyYXkgPyBbXSA6IFwiXCI7XG5cblx0ICAgICAgY2FzZSAxOlxuXHQgICAgICAgIHJldHVybiBhc19hcnJheSA/IFt0aGlzLl9zZWxlY3RlZFswXV0gOiB0aGlzLl9zZWxlY3RlZFswXTtcblxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHJldHVybiBbXS5jb25jYXQodGhpcy5fc2VsZWN0ZWQpO1xuXHQgICAgICAvL2lzb2xhdGlvblxuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0U2VsZWN0ZWRJdGVtOiBmdW5jdGlvbiAoYXNfYXJyYXkpIHtcblx0ICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGVkSWQodHJ1ZSk7XG5cblx0ICAgIGlmIChzZWwubGVuZ3RoID4gMSB8fCBhc19hcnJheSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gc2VsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgc2VsW2ldID0gdGhpcy5nZXRJdGVtKHNlbFtpXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gc2VsO1xuXHQgICAgfSBlbHNlIGlmIChzZWwubGVuZ3RoKSByZXR1cm4gdGhpcy5nZXRJdGVtKHNlbFswXSk7XG5cdCAgfSxcblx0ICAvL2RldGVjdHMgd2hpY2ggcmVwYWludGluZyBtb2RlIG5lZWQgdG8gYmUgdXNlZFxuXHQgIF9pc19tYXNzX3NlbGVjdGlvbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgLy8gY3JhcHB5IGhldXJpc3RpYywgYnV0IHdpbGwgZG8gdGhlIGpvYlxuXHQgICAgcmV0dXJuIG9iai5sZW5ndGggPiAxMDAgfHwgb2JqLmxlbmd0aCA+IHRoaXMuZGF0YS5jb3VudCAvIDI7XG5cdCAgfSxcblx0ICBfcmVmcmVzaF9zZWxlY3Rpb246IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG5cdCAgICBpZiAoX3R5cGVvZihyZWZyZXNoKSAhPSBcIm9iamVjdFwiKSByZWZyZXNoID0gW3JlZnJlc2hdO1xuXHQgICAgaWYgKCFyZWZyZXNoLmxlbmd0aCkgcmV0dXJuOyAvL25vdGhpbmcgdG8gcmVwYWludFxuXG5cdCAgICBpZiAodGhpcy5faXNfbWFzc19zZWxlY3Rpb24ocmVmcmVzaCkpIHRoaXMuZGF0YS5yZWZyZXNoKCk7IC8vbWFueSBpdGVtcyB3YXMgc2VsZWN0ZWQgLSByZXBhaW50IHdob2xlIHZpZXdcblx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZyZXNoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy9yZXBhaW50IG9ubHkgc2VsZWN0ZWRcblx0ICAgICAgICB0aGlzLnJlbmRlcihyZWZyZXNoW2ldLCB0aGlzLmRhdGEuZ2V0SXRlbShyZWZyZXNoW2ldKSwgXCJ1cGRhdGVcIik7XG5cdCAgICAgIH1cblx0ICAgIGlmICghdGhpcy5fc2lsZW50X3NlbGVjdGlvbikgdGhpcy5jYWxsRXZlbnQoXCJvblNlbGVjdENoYW5nZVwiLCBbcmVmcmVzaF0pO1xuXHQgIH1cblx0fTtcblx0cmVhZHkoZnVuY3Rpb24gKCkge1xuXHQgIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChzdGF0ZS5fbm9zZWxlY3RfZWxlbWVudCkge1xuXHQgICAgICByZW1vdmVDc3Moc3RhdGUuX25vc2VsZWN0X2VsZW1lbnQsIFwid2ViaXhfbm9zZWxlY3RcIik7XG5cdCAgICAgIHN0YXRlLl9ub3NlbGVjdF9lbGVtZW50ID0gbnVsbDtcblx0ICAgIH1cblx0ICB9KTtcblx0fSk7XG5cblx0dmFyIGNvbG9yID0ge1xuXHQgIF90b0hleDogW1wiMFwiLCBcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiLCBcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiXSxcblx0ICB0b0hleDogZnVuY3Rpb24gKG51bWJlciwgbGVuZ3RoKSB7XG5cdCAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIsIDEwKTtcblx0ICAgIHZhciBzdHIgPSBcIlwiO1xuXG5cdCAgICB3aGlsZSAobnVtYmVyID4gMCkge1xuXHQgICAgICBzdHIgPSB0aGlzLl90b0hleFtudW1iZXIgJSAxNl0gKyBzdHI7XG5cdCAgICAgIG51bWJlciA9IE1hdGguZmxvb3IobnVtYmVyIC8gMTYpO1xuXHQgICAgfVxuXG5cdCAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuXHQgICAgICBzdHIgPSBcIjBcIiArIHN0cjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN0cjtcblx0ICB9LFxuXHQgIHJnYlRvSGV4OiBmdW5jdGlvbiAocmdiKSB7XG5cdCAgICB2YXIgYXJyID0gW107XG5cdCAgICBpZiAodHlwZW9mIHJnYiA9PT0gXCJzdHJpbmdcIikgcmdiLnJlcGxhY2UoL1tcXGQrLl0rL2csIGZ1bmN0aW9uICh2KSB7XG5cdCAgICAgIGFyci5wdXNoKHBhcnNlRmxvYXQodikpO1xuXHQgICAgfSk7ZWxzZSBpZiAoaXNBcnJheShyZ2IpKSBhcnIgPSByZ2I7IC8vdHJhbnNwYXJlbnRcblxuXHQgICAgaWYgKGFyclszXSA9PT0gMCkgcmV0dXJuIFwiXCI7XG5cdCAgICByZXR1cm4gYXJyLnNsaWNlKDAsIDMpLm1hcChmdW5jdGlvbiAobikge1xuXHQgICAgICByZXR1cm4gY29sb3IudG9IZXgoTWF0aC5mbG9vcihuKSwgMik7XG5cdCAgICB9KS5qb2luKFwiXCIpO1xuXHQgIH0sXG5cdCAgaGV4VG9EZWM6IGZ1bmN0aW9uIChoZXgpIHtcblx0ICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcblx0ICB9LFxuXHQgIHRvUmdiOiBmdW5jdGlvbiAocmdiKSB7XG5cdCAgICB2YXIgciwgZywgYiwgcmdiQXJyO1xuXG5cdCAgICBpZiAodHlwZW9mIHJnYiAhPSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIHIgPSByZ2JbMF07XG5cdCAgICAgIGcgPSByZ2JbMV07XG5cdCAgICAgIGIgPSByZ2JbMl07XG5cdCAgICB9IGVsc2UgaWYgKHJnYi5pbmRleE9mKFwicmdiXCIpICE9IC0xKSB7XG5cdCAgICAgIHJnYkFyciA9IHJnYi5zdWJzdHIocmdiLmluZGV4T2YoXCIoXCIpICsgMSwgcmdiLmxhc3RJbmRleE9mKFwiKVwiKSAtIHJnYi5pbmRleE9mKFwiKFwiKSAtIDEpLnNwbGl0KFwiLFwiKTtcblx0ICAgICAgciA9IHJnYkFyclswXTtcblx0ICAgICAgZyA9IHJnYkFyclsxXTtcblx0ICAgICAgYiA9IHJnYkFyclsyXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChyZ2Iuc3Vic3RyKDAsIDEpID09IFwiI1wiKSB7XG5cdCAgICAgICAgcmdiID0gcmdiLnN1YnN0cigxKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHIgPSB0aGlzLmhleFRvRGVjKHJnYi5zdWJzdHIoMCwgMikpO1xuXHQgICAgICBnID0gdGhpcy5oZXhUb0RlYyhyZ2Iuc3Vic3RyKDIsIDIpKTtcblx0ICAgICAgYiA9IHRoaXMuaGV4VG9EZWMocmdiLnN1YnN0cig0LCAyKSk7XG5cdCAgICB9XG5cblx0ICAgIHIgPSBwYXJzZUludChyLCAxMCkgfHwgMDtcblx0ICAgIGcgPSBwYXJzZUludChnLCAxMCkgfHwgMDtcblx0ICAgIGIgPSBwYXJzZUludChiLCAxMCkgfHwgMDtcblx0ICAgIGlmIChyIDwgMCB8fCByID4gMjU1KSByID0gMDtcblx0ICAgIGlmIChnIDwgMCB8fCBnID4gMjU1KSBnID0gMDtcblx0ICAgIGlmIChiIDwgMCB8fCBiID4gMjU1KSBiID0gMDtcblx0ICAgIHJldHVybiBbciwgZywgYl07XG5cdCAgfSxcblx0ICBoc3ZUb1JnYjogZnVuY3Rpb24gKGgsIHMsIHYpIHtcblx0ICAgIHZhciBoaSwgZiwgcCwgcSwgdCwgciwgZywgYjtcblx0ICAgIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblx0ICAgIGYgPSBoIC8gNjAgLSBoaTtcblx0ICAgIHAgPSB2ICogKDEgLSBzKTtcblx0ICAgIHEgPSB2ICogKDEgLSBmICogcyk7XG5cdCAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXHQgICAgciA9IDA7XG5cdCAgICBnID0gMDtcblx0ICAgIGIgPSAwO1xuXG5cdCAgICBzd2l0Y2ggKGhpKSB7XG5cdCAgICAgIGNhc2UgMDpcblx0ICAgICAgICByID0gdjtcblx0ICAgICAgICBnID0gdDtcblx0ICAgICAgICBiID0gcDtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIDE6XG5cdCAgICAgICAgciA9IHE7XG5cdCAgICAgICAgZyA9IHY7XG5cdCAgICAgICAgYiA9IHA7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSAyOlxuXHQgICAgICAgIHIgPSBwO1xuXHQgICAgICAgIGcgPSB2O1xuXHQgICAgICAgIGIgPSB0O1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgMzpcblx0ICAgICAgICByID0gcDtcblx0ICAgICAgICBnID0gcTtcblx0ICAgICAgICBiID0gdjtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgciA9IHQ7XG5cdCAgICAgICAgZyA9IHA7XG5cdCAgICAgICAgYiA9IHY7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSA1OlxuXHQgICAgICAgIHIgPSB2O1xuXHQgICAgICAgIGcgPSBwO1xuXHQgICAgICAgIGIgPSBxO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuXHQgICAgZyA9IE1hdGguZmxvb3IoZyAqIDI1NSk7XG5cdCAgICBiID0gTWF0aC5mbG9vcihiICogMjU1KTtcblx0ICAgIHJldHVybiBbciwgZywgYl07XG5cdCAgfSxcblx0ICByZ2JUb0hzdjogZnVuY3Rpb24gKHIsIGcsIGIpIHtcblx0ICAgIHZhciByMCwgZzAsIGIwLCBtaW4wLCBtYXgwLCBzLCBoLCB2O1xuXHQgICAgcjAgPSByIC8gMjU1O1xuXHQgICAgZzAgPSBnIC8gMjU1O1xuXHQgICAgYjAgPSBiIC8gMjU1O1xuXHQgICAgbWluMCA9IE1hdGgubWluKHIwLCBnMCwgYjApO1xuXHQgICAgbWF4MCA9IE1hdGgubWF4KHIwLCBnMCwgYjApO1xuXHQgICAgaCA9IDA7XG5cdCAgICBzID0gbWF4MCA9PT0gMCA/IDAgOiAxIC0gbWluMCAvIG1heDA7XG5cdCAgICB2ID0gbWF4MDtcblxuXHQgICAgaWYgKG1heDAgPT0gbWluMCkge1xuXHQgICAgICBoID0gMDtcblx0ICAgIH0gZWxzZSBpZiAobWF4MCA9PSByMCAmJiBnMCA+PSBiMCkge1xuXHQgICAgICBoID0gNjAgKiAoZzAgLSBiMCkgLyAobWF4MCAtIG1pbjApICsgMDtcblx0ICAgIH0gZWxzZSBpZiAobWF4MCA9PSByMCAmJiBnMCA8IGIwKSB7XG5cdCAgICAgIGggPSA2MCAqIChnMCAtIGIwKSAvIChtYXgwIC0gbWluMCkgKyAzNjA7XG5cdCAgICB9IGVsc2UgaWYgKG1heDAgPT0gZzApIHtcblx0ICAgICAgaCA9IDYwICogKGIwIC0gcjApIC8gKG1heDAgLSBtaW4wKSArIDEyMDtcblx0ICAgIH0gZWxzZSBpZiAobWF4MCA9PSBiMCkge1xuXHQgICAgICBoID0gNjAgKiAocjAgLSBnMCkgLyAobWF4MCAtIG1pbjApICsgMjQwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gW2gsIHMsIHZdO1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBqb2luQXR0cmlidXRlcyhhdHRycykge1xuXHQgIHZhciByZXN1bHQgPSBcIiBcIjtcblx0ICBpZiAoYXR0cnMpIGZvciAodmFyIGEgaW4gYXR0cnMpIHtcblx0ICAgIHJlc3VsdCArPSBhICsgXCI9XFxcIlwiICsgYXR0cnNbYV0gKyBcIlxcXCIgXCI7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH0gLy8gU1ZHXG5cblxuXHR2YXIgU1ZHID0ge307XG5cblx0U1ZHLmRyYXcgPSBmdW5jdGlvbiAoY29udGVudCwgd2lkdGgsIGhlaWdodCwgY3NzKSB7XG5cdCAgdmFyIGF0dHJzID0ge1xuXHQgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0ICAgIHZlcnNpb246IFwiMS4xXCIsXG5cdCAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuXHQgICAgd2lkdGg6IFwiMTAwJVwiLFxuXHQgICAgdmlld0JveDogXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0LFxuXHQgICAgXCJjbGFzc1wiOiBjc3MgfHwgXCJcIlxuXHQgIH07XG5cdCAgcmV0dXJuIFwiPHN2ZyBcIiArIGpvaW5BdHRyaWJ1dGVzKGF0dHJzKSArIFwiPlwiICsgY29udGVudCArIFwiPC9zdmc+XCI7XG5cdH07XG5cblx0U1ZHLnN0eWxlTWFwID0ge1xuXHQgIFwibGluZUNvbG9yXCI6IFwic3Ryb2tlXCIsXG5cdCAgXCJjb2xvclwiOiBcImZpbGxcIlxuXHR9O1xuXG5cdFNWRy5ncm91cCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cdCAgcmV0dXJuIFwiPGc+XCIgKyBwYXRoICsgXCI8L2c+XCI7XG5cdH07XG5cblx0U1ZHLl9oYW5kbGVycyA9IHtcblx0ICAvLyBNb3ZlVG86IHt4OnB4LHk6cHl9XG5cdCAgXCJNXCI6IGZ1bmN0aW9uIChwKSB7XG5cdCAgICByZXR1cm4gXCIgTSBcIiArIHAueCArIFwiIFwiICsgcC55O1xuXHQgIH0sXG5cdCAgLy8gTGluZVRvOiB7eDpweCx5OnB5fVxuXHQgIFwiTFwiOiBmdW5jdGlvbiAocCkge1xuXHQgICAgcmV0dXJuIFwiIEwgXCIgKyBwLnggKyBcIiBcIiArIHAueTtcblx0ICB9LFxuXHQgIC8vIEN1cnZlOiAzIHBvaW50cyB7eDpweCx5OnB5fTogdHdvIGNvbnRyb2wgcG9pbnRzIGFuZCBhbiBlbmQgcG9pbnRcblx0ICBcIkNcIjogZnVuY3Rpb24gKGNwMCwgY3AxLCBwKSB7XG5cdCAgICByZXR1cm4gXCIgQyBcIiArIGNwMC54ICsgXCIgXCIgKyBjcDAueSArIFwiIFwiICsgY3AxLnggKyBcIiBcIiArIGNwMS55ICsgXCIgXCIgKyBwLnggKyBcIiBcIiArIHAueTtcblx0ICB9LFxuXHQgIC8vIEFyYzogY2VudGVyIHBvaW50IHt4OnB4LHk6cHl9LCByYWRpdXMsIGFuZ2xlMCwgYW5nbGUxXG5cdCAgXCJBXCI6IGZ1bmN0aW9uIChwLCByYWRpdXMsIGFuZ2xlMCwgYW5nbGUxKSB7XG5cdCAgICB2YXIgeCA9IHAueCArIE1hdGguY29zKGFuZ2xlMSkgKiByYWRpdXM7XG5cdCAgICB2YXIgeSA9IHAueSArIE1hdGguc2luKGFuZ2xlMSkgKiByYWRpdXM7XG5cdCAgICB2YXIgYmlnQ2lyY2xlID0gYW5nbGUxIC0gYW5nbGUwID49IE1hdGguUEk7XG5cdCAgICByZXR1cm4gXCIgQSBcIiArIHJhZGl1cyArIFwiIFwiICsgcmFkaXVzICsgXCIgMCBcIiArIChiaWdDaXJjbGUgPyAxIDogMCkgKyBcIiAxIFwiICsgeCArIFwiIFwiICsgeTtcblx0ICB9XG5cdH07IC8vIHBvaW50cyBpcyBhbiBhcnJheSBvZiBhbiBhcnJheSB3aXRoIHR3byBlbGVtZW50czoge3N0cmluZ30gbGluZSB0eXBlLCB7YXJyYXl9XG5cblx0U1ZHLmRlZmluZVBhdGggPSBmdW5jdGlvbiAocG9pbnRzLCBjbG9zZSkge1xuXHQgIHZhciBwYXRoID0gXCJcIjtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBhc3NlcnQocG9pbnRzW2ldWzBdICYmIHR5cGVvZiBwb2ludHNbaV1bMF0gPT0gXCJzdHJpbmdcIiwgXCJQYXRoIHR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblx0ICAgIHZhciB0eXBlID0gcG9pbnRzW2ldWzBdLnRvVXBwZXJDYXNlKCk7XG5cdCAgICBhc3NlcnQodGhpcy5faGFuZGxlcnNbdHlwZV0sIFwiSW5jb3JyZWN0IHBhdGggdHlwZVwiKTtcblx0ICAgIHBhdGggKz0gdGhpcy5faGFuZGxlcnNbdHlwZV0uYXBwbHkodGhpcywgcG9pbnRzW2ldLnNsaWNlKDEpKTtcblx0ICB9XG5cblx0ICBpZiAoY2xvc2UpIHBhdGggKz0gXCIgWlwiO1xuXHQgIHJldHVybiBwYXRoO1xuXHR9O1xuXG5cdFNWRy5fbGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgcmVzdWx0LnB1c2goW2kgPyBcIkxcIiA6IFwiTVwiLCBwb2ludHNbaV1dKTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFNWRy5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gKHJhd0NvbG9yLCBvcGFjaXR5KSB7XG5cdCAgdmFyIHJnYkNvbG9yID0gY29sb3IudG9SZ2IocmF3Q29sb3IpO1xuXHQgIHJnYkNvbG9yLnB1c2gob3BhY2l0eSk7XG5cdCAgcmV0dXJuIFwicmdiYShcIiArIHJnYkNvbG9yLmpvaW4oXCIsXCIpICsgXCIpXCI7XG5cdH07XG5cblx0U1ZHLl9jdXJ2ZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cblx0ICAgIGlmICghaSkge1xuXHQgICAgICByZXN1bHQucHVzaChbXCJNXCIsIHBbMF1dKTtcblx0ICAgIH1cblxuXHQgICAgcmVzdWx0LnB1c2goW1wiQ1wiLCBwWzFdLCBwWzJdLCBwWzNdXSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRTVkcuZ2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBjc3MsIGF0dHJzKSB7XG5cdCAgYXR0cnMgPSBqb2luQXR0cmlidXRlcyhhdHRycyk7XG5cdCAgcmV0dXJuIFwiPHBhdGggY2xhc3M9XFxcIlwiICsgY3NzICsgXCJcXFwiIHZlY3Rvci1lZmZlY3Q9XFxcIm5vbi1zY2FsaW5nLXN0cm9rZVxcXCIgZD1cXFwiXCIgKyBwYXRoICsgXCJcXFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG5cdH07XG5cblx0U1ZHLmdldFNlY3RvciA9IGZ1bmN0aW9uIChwLCByYWRpdXMsIGFuZ2xlMCwgYW5nbGUxLCBjc3MsIGF0dHJzKSB7XG5cdCAgYXR0cnMgPSBqb2luQXR0cmlidXRlcyhhdHRycyk7XG5cdCAgdmFyIHgwID0gcC54ICsgTWF0aC5jb3MoYW5nbGUwKSAqIHJhZGl1cztcblx0ICB2YXIgeTAgPSBwLnkgKyBNYXRoLnNpbihhbmdsZTApICogcmFkaXVzO1xuXHQgIHZhciBsaW5lcyA9IFtbXCJNXCIsIHBdLCBbXCJMXCIsIHtcblx0ICAgIHg6IHgwLFxuXHQgICAgeTogeTBcblx0ICB9XSwgW1wiQVwiLCBwLCByYWRpdXMsIGFuZ2xlMCwgYW5nbGUxXSwgW1wiTFwiLCBwXV07XG5cdCAgcmV0dXJuIFwiPHBhdGggY2xhc3M9XFxcIlwiICsgY3NzICsgXCJcXFwiIHZlY3Rvci1lZmZlY3Q9XFxcIm5vbi1zY2FsaW5nLXN0cm9rZVxcXCIgZD1cXFwiXCIgKyBTVkcuZGVmaW5lUGF0aChsaW5lcywgdHJ1ZSkgKyBcIlxcXCIgXCIgKyBhdHRycyArIFwiLz5cIjtcblx0fTtcblxuXHRTVkcuZ2V0Q3VydmUgPSBmdW5jdGlvbiAocG9pbnRzLCBjc3MsIGF0dHJzKSB7XG5cdCAgYXR0cnMgPSBqb2luQXR0cmlidXRlcyhhdHRycyk7XG5cdCAgdmFyIHBhdGggPSB0aGlzLmRlZmluZVBhdGgodGhpcy5fY3VydmVQb2ludHMocG9pbnRzKSk7XG5cdCAgcmV0dXJuIFwiPHBhdGggZmlsbD1cXFwibm9uZVxcXCIgY2xhc3M9XFxcIlwiICsgY3NzICsgXCJcXFwiIHZlY3Rvci1lZmZlY3Q9XFxcIm5vbi1zY2FsaW5nLXN0cm9rZVxcXCIgZD1cXFwiXCIgKyBwYXRoICsgXCJcXFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG5cdH07XG5cblx0U1ZHLmdldExpbmUgPSBmdW5jdGlvbiAocDAsIHAxLCBjc3MsIGF0dHJzKSB7XG5cdCAgcmV0dXJuIHRoaXMuZ2V0UGF0aCh0aGlzLmRlZmluZVBhdGgodGhpcy5fbGluZVBvaW50cyhbcDAsIHAxXSksIHRydWUpLCBjc3MsIGF0dHJzKTtcblx0fTtcblxuXHRTVkcuZ2V0Q2lyY2xlID0gZnVuY3Rpb24gKHAsIHJhZGl1cywgY3NzLCBhdHRycykge1xuXHQgIGF0dHJzID0gam9pbkF0dHJpYnV0ZXMoYXR0cnMpO1xuXHQgIHJldHVybiBcIjxjaXJjbGUgY2xhc3M9XFxcIlwiICsgY3NzICsgXCJcXFwiIGN4PVxcXCJcIiArIHAueCArIFwiXFxcIiBjeT1cXFwiXCIgKyBwLnkgKyBcIlxcXCIgcj1cXFwiXCIgKyByYWRpdXMgKyBcIlxcXCIgXCIgKyBhdHRycyArIFwiLz5cIjtcblx0fTtcblxuXHRTVkcuZ2V0UmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjc3MsIGF0dHJzKSB7XG5cdCAgYXR0cnMgPSBqb2luQXR0cmlidXRlcyhhdHRycyk7XG5cdCAgcmV0dXJuIFwiPHJlY3QgY2xhc3M9XFxcIlwiICsgY3NzICsgXCJcXFwiIHJ4PVxcXCIwXFxcIiByeT1cXFwiMFxcXCIgeD1cXFwiXCIgKyB4ICsgXCJcXFwiIHk9XFxcIlwiICsgeSArIFwiXFxcIiB3aWR0aD1cXFwiXCIgKyB3aWR0aCArIFwiXFxcIiBoZWlnaHQ9XFxcIlwiICsgaGVpZ2h0ICsgXCJcXFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzID0ge1xuXHQgIHBhZGRpbmdYOiA2LFxuXHQgIHBhZGRpbmdZOiA2LFxuXHQgIHJhZGl1czogMixcblx0ICBtaW5IZWlnaHQ6IDQsXG5cdCAgZXZlbnRSYWRpdXM6IDhcblx0fTtcblxuXHRmdW5jdGlvbiBMaW5lKGNvbmZpZykge1xuXHQgIHRoaXMuY29uZmlnID0gZXhwb3J0cy5leHRlbmQoY29weShkZWZhdWx0cyksIGNvbmZpZyB8fCB7fSwgdHJ1ZSk7XG5cdH1cblxuXHRMaW5lLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoZGF0YSwgd2lkdGgsIGhlaWdodCk7XG5cdCAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHQgIHZhciByZW5kZXJlciA9IFNWRztcblx0ICB2YXIgc3R5bGVzID0gY29uZmlnLmNvbG9yID8gdGhpcy5fYXBwbHlDb2xvcihyZW5kZXJlciwgY29uZmlnLmNvbG9yKSA6IG51bGw7IC8vIGRyYXcgbGluZVxuXG5cdCAgdmFyIHBhdGggPSByZW5kZXJlci5kZWZpbmVQYXRoKHRoaXMuX2dldExpbmVQb2ludHMocG9pbnRzKSk7XG5cdCAgdmFyIGdyYXBoID0gcmVuZGVyZXIuZ3JvdXAocmVuZGVyZXIuZ2V0UGF0aChwYXRoLCBcIndlYml4X3NwYXJrbGluZXNfbGluZVwiICsgKHN0eWxlcyA/IFwiIFwiICsgc3R5bGVzLmxpbmUgOiBcIlwiKSkpOyAvLyBkcmF3IGl0ZW1zXG5cblx0ICBncmFwaCArPSB0aGlzLl9kcmF3SXRlbXMocmVuZGVyZXIsIHBvaW50cywgY29uZmlnLnJhZGl1cywgXCJ3ZWJpeF9zcGFya2xpbmVzX2l0ZW1cIiArIChzdHlsZXMgPyBcIiBcIiArIHN0eWxlcy5pdGVtIDogXCJcIikpOyAvLyBkcmF3IGV2ZW50IGl0ZW1zXG5cblx0ICB2YXIgZXZlbnRSYWRpdXMgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCA/ICh3aWR0aCAtIDIgKiAoY29uZmlnLnBhZGRpbmdYIHx8IDApKSAvIGRhdGEubGVuZ3RoIDogMCwgY29uZmlnLmV2ZW50UmFkaXVzKTtcblx0ICBncmFwaCArPSB0aGlzLl9kcmF3RXZlbnRJdGVtcyhyZW5kZXJlciwgcG9pbnRzLCBldmVudFJhZGl1cyk7XG5cdCAgcmV0dXJuIHJlbmRlcmVyLmRyYXcoZ3JhcGgsIHdpZHRoLCBoZWlnaHQsIFwid2ViaXhfc3BhcmtsaW5lc19saW5lX2NoYXJ0XCIgKyAoY29uZmlnLmNzcyA/IFwiIFwiICsgY29uZmlnLmNzcyA6IFwiXCIpKTtcblx0fTtcblxuXHRMaW5lLnByb3RvdHlwZS5fYXBwbHlDb2xvciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgY29sb3IpIHtcblx0ICB2YXIgY29uZmlnID0ge1xuXHQgICAgXCJsaW5lXCI6IHt9LFxuXHQgICAgXCJpdGVtXCI6IHt9XG5cdCAgfSxcblx0ICAgICAgbWFwID0gcmVuZGVyZXIuc3R5bGVNYXA7XG5cblx0ICBpZiAoY29sb3IpIHtcblx0ICAgIGNvbmZpZy5saW5lW21hcC5saW5lQ29sb3JdID0gY29sb3I7XG5cdCAgICBjb25maWcuaXRlbVttYXAuY29sb3JdID0gY29sb3I7XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnKSB7XG5cdCAgICAgIGNvbmZpZ1tuYW1lXSA9IGNyZWF0ZUNzcyhjb25maWdbbmFtZV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBjb25maWc7XG5cdH07XG5cblx0TGluZS5wcm90b3R5cGUuX2RyYXdJdGVtcyA9IGZ1bmN0aW9uIChyZW5kZXJlciwgcG9pbnRzLCByYWRpdXMsIGNzcywgYXR0cnMpIHtcblx0ICB2YXIgaXRlbXMgPSBbXTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpdGVtcy5wdXNoKHJlbmRlcmVyLmdldENpcmNsZShwb2ludHNbaV0sIHJhZGl1cywgY3NzLCBhdHRycykpO1xuXHQgIH1cblxuXHQgIHJldHVybiByZW5kZXJlci5ncm91cChpdGVtcy5qb2luKFwiXCIpKTtcblx0fTtcblxuXHRMaW5lLnByb3RvdHlwZS5fZHJhd0V2ZW50SXRlbXMgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHBvaW50cywgcmFkaXVzKSB7XG5cdCAgdmFyIGl0ZW1zID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgaXRlbXMucHVzaChyZW5kZXJlci5nZXRDaXJjbGUocG9pbnRzW2ldLCByYWRpdXMsIFwid2ViaXhfc3BhcmtsaW5lc19ldmVudF9hcmVhXCIsIHtcblx0ICAgICAgd2ViaXhfYXJlYTogaVxuXHQgICAgfSkpO1xuXHQgIH1cblxuXHQgIHJldHVybiByZW5kZXJlci5ncm91cChpdGVtcy5qb2luKFwiXCIpKTtcblx0fTtcblxuXHRMaW5lLnByb3RvdHlwZS5fZ2V0TGluZVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcblx0ICB2YXIgaSxcblx0ICAgICAgdHlwZSxcblx0ICAgICAgcmVzdWx0ID0gW107XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0eXBlID0gaSA/IFwiTFwiIDogXCJNXCI7XG5cdCAgICByZXN1bHQucHVzaChbdHlwZSwgcG9pbnRzW2ldXSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRMaW5lLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0ICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbi5hcHBseShudWxsLCBkYXRhKTtcblx0ICBpZiAodHlwZW9mIGNvbmZpZy5vcmlnaW4gIT09IFwidW5kZWZpbmVkXCIpIG1pblZhbHVlID0gTWF0aC5taW4oY29uZmlnLm9yaWdpbiwgbWluVmFsdWUpO1xuXHQgIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGRhdGEpO1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICB2YXIgeCA9IGNvbmZpZy5wYWRkaW5nWCB8fCAwO1xuXHQgIHZhciB5ID0gY29uZmlnLnBhZGRpbmdZIHx8IDA7XG5cdCAgd2lkdGggPSAod2lkdGggfHwgMTAwKSAtIHggKiAyO1xuXHQgIHZhciBtaW5IZWlnaHQgPSBjb25maWcubWluSGVpZ2h0IHx8IDA7XG5cdCAgaGVpZ2h0ID0gKGhlaWdodCB8fCAxMDApIC0geSAqIDI7XG5cblx0ICBpZiAoZGF0YS5sZW5ndGgpIHtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PSAxKSByZXN1bHQucHVzaCh7XG5cdCAgICAgIHg6IHdpZHRoIC8gMiArIHgsXG5cdCAgICAgIHk6IGhlaWdodCAvIDIgKyB4XG5cdCAgICB9KTtlbHNlIHtcblx0ICAgICAgdmFyIHVuaXRYID0gd2lkdGggLyAoZGF0YS5sZW5ndGggLSAxKTtcblx0ICAgICAgdmFyIHlOdW0gPSBjb25maWcuc2NhbGUgfHwgbWF4VmFsdWUgLSBtaW5WYWx1ZTtcblx0ICAgICAgdmFyIHVuaXRZID0gKGhlaWdodCAtIG1pbkhlaWdodCkgLyAoeU51bSA/IHlOdW0gOiAxKTtcblx0ICAgICAgaWYgKCF5TnVtKSBoZWlnaHQgLz0gMjtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHQucHVzaCh7XG5cdCAgICAgICAgICB4OiBNYXRoLmNlaWwodW5pdFggKiBpKSArIHgsXG5cdCAgICAgICAgICB5OiBoZWlnaHQgLSBNYXRoLmNlaWwodW5pdFkgKiAoZGF0YVtpXSAtIG1pblZhbHVlKSkgKyB5IC0gbWluSGVpZ2h0XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdHZhciBkZWZhdWx0cyQxID0ge1xuXHQgIHBhZGRpbmdYOiAzLFxuXHQgIHBhZGRpbmdZOiA0LFxuXHQgIHJhZGl1czogMSxcblx0ICBtaW5IZWlnaHQ6IDQsXG5cdCAgZXZlbnRSYWRpdXM6IDhcblx0fTtcblxuXHRmdW5jdGlvbiBBcmVhKGNvbmZpZykge1xuXHQgIHRoaXMuY29uZmlnID0gZXhwb3J0cy5leHRlbmQoY29weShkZWZhdWx0cyQxKSwgY29uZmlnIHx8IHt9LCB0cnVlKTtcblx0fVxuXG5cdEFyZWEucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBldmVudFJhZGl1cyxcblx0ICAgICAgZ3JhcGgsXG5cdCAgICAgIHBhdGgsXG5cdCAgICAgIHBvaW50cyxcblx0ICAgICAgc3R5bGVzLFxuXHQgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcblx0ICAgICAgTGluZSQkMSA9IExpbmUucHJvdG90eXBlLFxuXHQgICAgICByZW5kZXJlciA9IFNWRzsgLy8gZHJhdyBhcmVhXG5cblx0ICBwb2ludHMgPSB0aGlzLmdldFBvaW50cyhkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblx0ICBwYXRoID0gcmVuZGVyZXIuZGVmaW5lUGF0aChMaW5lJCQxLl9nZXRMaW5lUG9pbnRzKHBvaW50cyksIHRydWUpO1xuXHQgIGlmIChjb25maWcuY29sb3IpIHN0eWxlcyA9IHRoaXMuX2FwcGx5Q29sb3IocmVuZGVyZXIsIGNvbmZpZy5jb2xvcik7XG5cdCAgZ3JhcGggPSByZW5kZXJlci5ncm91cChyZW5kZXJlci5nZXRQYXRoKHBhdGgsIFwid2ViaXhfc3BhcmtsaW5lc19hcmVhXCIgKyAoc3R5bGVzID8gXCIgXCIgKyBzdHlsZXMuYXJlYSA6IFwiXCIpKSk7IC8vIGRyYXcgbGluZVxuXG5cdCAgcG9pbnRzLnNwbGljZShwb2ludHMubGVuZ3RoIC0gMywgMyk7XG5cdCAgcGF0aCA9IHJlbmRlcmVyLmRlZmluZVBhdGgoTGluZSQkMS5fZ2V0TGluZVBvaW50cyhwb2ludHMpKTtcblx0ICBncmFwaCArPSByZW5kZXJlci5ncm91cChyZW5kZXJlci5nZXRQYXRoKHBhdGgsIFwid2ViaXhfc3BhcmtsaW5lc19saW5lXCIgKyAoc3R5bGVzID8gXCIgXCIgKyBzdHlsZXMubGluZSA6IFwiXCIpKSk7IC8vIGRyYXcgaXRlbXNcblxuXHQgIGdyYXBoICs9IExpbmUkJDEuX2RyYXdJdGVtcyhyZW5kZXJlciwgcG9pbnRzLCBjb25maWcucmFkaXVzLCBcIndlYml4X3NwYXJrbGluZXNfaXRlbVwiICsgKHN0eWxlcyA/IFwiIFwiICsgc3R5bGVzLml0ZW0gOiBcIlwiKSk7IC8vIGRyYXcgZXZlbnQgYXJlYXNcblxuXHQgIGV2ZW50UmFkaXVzID0gTWF0aC5taW4oZGF0YS5sZW5ndGggPyAod2lkdGggLSAyICogKGNvbmZpZy5wYWRkaW5nWCB8fCAwKSkgLyBkYXRhLmxlbmd0aCA6IDAsIGNvbmZpZy5ldmVudFJhZGl1cyk7XG5cdCAgZ3JhcGggKz0gTGluZSQkMS5fZHJhd0V2ZW50SXRlbXMocmVuZGVyZXIsIHBvaW50cywgZXZlbnRSYWRpdXMpO1xuXHQgIHJldHVybiByZW5kZXJlci5kcmF3KGdyYXBoLCB3aWR0aCwgaGVpZ2h0LCBcIndlYml4X3NwYXJrbGluZXNfYXJlYV9jaGFydFwiICsgKGNvbmZpZy5jc3MgPyBcIiBcIiArIGNvbmZpZy5jc3MgOiBcIlwiKSk7XG5cdH07XG5cblx0QXJlYS5wcm90b3R5cGUuX2FwcGx5Q29sb3IgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGNvbG9yKSB7XG5cdCAgdmFyIGNvbmZpZyA9IHtcblx0ICAgIFwiYXJlYVwiOiB7fSxcblx0ICAgIFwibGluZVwiOiB7fSxcblx0ICAgIFwiaXRlbVwiOiB7fVxuXHQgIH0sXG5cdCAgICAgIG1hcCA9IHJlbmRlcmVyLnN0eWxlTWFwO1xuXG5cdCAgaWYgKGNvbG9yKSB7XG5cdCAgICBjb25maWcuYXJlYVttYXAuY29sb3JdID0gcmVuZGVyZXIuc2V0T3BhY2l0eShjb2xvciwgMC4yKTtcblx0ICAgIGNvbmZpZy5saW5lW21hcC5saW5lQ29sb3JdID0gY29sb3I7XG5cdCAgICBjb25maWcuaXRlbVttYXAuY29sb3JdID0gY29sb3I7XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnKSB7XG5cdCAgICAgIGNvbmZpZ1tuYW1lXSA9IGNyZWF0ZUNzcyhjb25maWdbbmFtZV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBjb25maWc7XG5cdH07XG5cblx0QXJlYS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICB2YXIgTGluZSQkMSA9IExpbmUucHJvdG90eXBlO1xuXHQgIHZhciBwb2ludHMgPSBMaW5lJCQxLmdldFBvaW50cy5jYWxsKHRoaXMsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXHQgIHZhciB4ID0gdGhpcy5jb25maWcucGFkZGluZ1ggfHwgMDtcblx0ICB2YXIgeSA9IHRoaXMuY29uZmlnLnBhZGRpbmdZIHx8IDA7XG5cdCAgcG9pbnRzLnB1c2goe1xuXHQgICAgeDogd2lkdGggLSB4LFxuXHQgICAgeTogaGVpZ2h0IC0geVxuXHQgIH0sIHtcblx0ICAgIHg6IHgsXG5cdCAgICB5OiBoZWlnaHQgLSB5XG5cdCAgfSwge1xuXHQgICAgeDogeCxcblx0ICAgIHk6IHBvaW50c1swXS55XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHBvaW50cztcblx0fTtcblxuXHR2YXIgZGVmYXVsdHMkMiA9IHtcblx0ICBwYWRkaW5nWDogMyxcblx0ICBwYWRkaW5nWTogNCxcblx0ICB3aWR0aDogMjAsXG5cdCAgbWFyZ2luOiA0LFxuXHQgIG1pbkhlaWdodDogNCxcblx0ICBldmVudFJhZGl1czogOCxcblx0ICBvcmlnaW46IDAsXG5cdCAgaXRlbUNzczogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUgPCAodGhpcy5jb25maWcub3JpZ2luIHx8IDApID8gXCIgd2ViaXhfc3BhcmtsaW5lc19iYXJfbmVnYXRpdmVcIiA6IFwiXCI7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIEJhcihjb25maWcpIHtcblx0ICB0aGlzLmNvbmZpZyA9IGV4cG9ydHMuZXh0ZW5kKGNvcHkoZGVmYXVsdHMkMiksIGNvbmZpZyB8fCB7fSwgdHJ1ZSk7XG5cdH1cblxuXHRCYXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBpLFxuXHQgICAgICBjc3MsXG5cdCAgICAgIHAsXG5cdCAgICAgIHksXG5cdCAgICAgIHBhZGRpbmcsXG5cdCAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuXHQgICAgICBncmFwaCA9IFwiXCIsXG5cdCAgICAgIGl0ZW1zID0gW10sXG5cdCAgICAgIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKGRhdGEsIHdpZHRoLCBoZWlnaHQpLFxuXHQgICAgICByZW5kZXJlciA9IFNWRzsgLy8gZHJhdyBiYXJzXG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBjc3MgPSB0eXBlb2YgY29uZmlnLml0ZW1Dc3MgPT0gXCJmdW5jdGlvblwiID8gY29uZmlnLml0ZW1Dc3MuY2FsbCh0aGlzLCBkYXRhW2ldKSA6IGNvbmZpZy5pdGVtQ3NzIHx8IFwiXCI7XG5cdCAgICBpZiAoY29uZmlnLm5lZ2F0aXZlQ29sb3IgJiYgZGF0YVtpXSA8IGNvbmZpZy5vcmlnaW4pIGNzcyArPSBcIiBcIiArIHRoaXMuX2FwcGx5Q29sb3IocmVuZGVyZXIsIGNvbmZpZy5uZWdhdGl2ZUNvbG9yKTtlbHNlIGlmIChjb25maWcuY29sb3IpIGNzcyArPSBcIiBcIiArIHRoaXMuX2FwcGx5Q29sb3IocmVuZGVyZXIsIGNvbmZpZy5jb2xvcik7XG5cdCAgICBwID0gcG9pbnRzW2ldO1xuXHQgICAgaXRlbXMucHVzaChyZW5kZXJlci5nZXRSZWN0KHAueCwgcC55LCBwLndpZHRoLCBwLmhlaWdodCwgXCJ3ZWJpeF9zcGFya2xpbmVzX2JhciBcIiArIGNzcykpO1xuXHQgIH1cblxuXHQgIGdyYXBoICs9IHJlbmRlcmVyLmdyb3VwKGl0ZW1zLmpvaW4oXCJcIikpOyAvLyBvcmlnaW4pXG5cblx0ICB5ID0gcGFyc2VJbnQodGhpcy5fZ2V0T3JpZ2luKGRhdGEsIHdpZHRoLCBoZWlnaHQpLCAxMCkgKyAwLjU7XG5cdCAgcGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nWCB8fCAwO1xuXHQgIGdyYXBoICs9IHJlbmRlcmVyLmdyb3VwKHJlbmRlcmVyLmdldExpbmUoe1xuXHQgICAgeDogcGFkZGluZyxcblx0ICAgIHk6IHlcblx0ICB9LCB7XG5cdCAgICB4OiB3aWR0aCAtIHBhZGRpbmcsXG5cdCAgICB5OiB5XG5cdCAgfSwgXCJ3ZWJpeF9zcGFya2xpbmVzX29yaWdpblwiKSk7IC8vIGV2ZW50IGFyZWFzXG5cblx0ICB2YXIgZXZQb2ludHMgPSB0aGlzLl9nZXRFdmVudFBvaW50cyhkYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblxuXHQgIHZhciBldkl0ZW1zID0gW107XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgZXZQb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHAgPSBldlBvaW50c1tpXTtcblx0ICAgIGV2SXRlbXMucHVzaChyZW5kZXJlci5nZXRSZWN0KHAueCwgcC55LCBwLndpZHRoLCBwLmhlaWdodCwgXCJ3ZWJpeF9zcGFya2xpbmVzX2V2ZW50X2FyZWEgXCIsIHtcblx0ICAgICAgXCJ3ZWJpeF9hcmVhXCI6IGlcblx0ICAgIH0pKTtcblx0ICB9XG5cblx0ICBncmFwaCArPSByZW5kZXJlci5ncm91cChldkl0ZW1zLmpvaW4oXCJcIikpO1xuXHQgIHJldHVybiByZW5kZXJlci5kcmF3KGdyYXBoLCB3aWR0aCwgaGVpZ2h0LCBcIndlYml4X3NwYXJrbGluZXNfYmFyX2NoYXJ0XCIgKyAoY29uZmlnLmNzcyA/IFwiIFwiICsgY29uZmlnLmNzcyA6IFwiXCIpKTtcblx0fTtcblxuXHRCYXIucHJvdG90eXBlLl9hcHBseUNvbG9yID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBjb2xvcikge1xuXHQgIHZhciBjb25maWcgPSB7fSxcblx0ICAgICAgbWFwID0gcmVuZGVyZXIuc3R5bGVNYXA7XG5cdCAgaWYgKGNvbG9yKSBjb25maWdbbWFwLmNvbG9yXSA9IGNvbG9yO1xuXHQgIHJldHVybiBjcmVhdGVDc3MoY29uZmlnKTtcblx0fTtcblxuXHRCYXIucHJvdG90eXBlLl9nZXRPcmlnaW4gPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0ICB2YXIgeSA9IGNvbmZpZy5wYWRkaW5nWSB8fCAwO1xuXHQgIGhlaWdodCA9IChoZWlnaHQgfHwgMTAwKSAtIHkgKiAyO1xuXHQgIHZhciBwb3MkJDEgPSB5ICsgaGVpZ2h0O1xuXG5cdCAgaWYgKGNvbmZpZy5vcmlnaW4gIT09IGZhbHNlKSB7XG5cdCAgICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbi5hcHBseShudWxsLCBkYXRhKTtcblx0ICAgIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGRhdGEpO1xuXHQgICAgdmFyIG9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gfHwgLTAuMDAwMDAxO1xuXG5cdCAgICBpZiAob3JpZ2luID49IG1heFZhbHVlKSB7XG5cdCAgICAgIHBvcyQkMSA9IHk7XG5cdCAgICB9IGVsc2UgaWYgKG9yaWdpbiA+IG1pblZhbHVlKSB7XG5cdCAgICAgIHZhciB1bml0WSA9IGhlaWdodCAvIChtYXhWYWx1ZSAtIG1pblZhbHVlKTtcblx0ICAgICAgcG9zJCQxIC09IHVuaXRZICogKG9yaWdpbiAtIG1pblZhbHVlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gcG9zJCQxO1xuXHR9O1xuXG5cdEJhci5wcm90b3R5cGUuX2dldEV2ZW50UG9pbnRzID0gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgdmFyIHggPSB0aGlzLmNvbmZpZy5wYWRkaW5nWCB8fCAwO1xuXHQgIHZhciB5ID0gdGhpcy5jb25maWcucGFkZGluZ1kgfHwgMDtcblx0ICB3aWR0aCA9ICh3aWR0aCB8fCAxMDApIC0geCAqIDI7XG5cdCAgaGVpZ2h0ID0gKGhlaWdodCB8fCAxMDApIC0geSAqIDI7XG5cblx0ICBpZiAoZGF0YS5sZW5ndGgpIHtcblx0ICAgIHZhciB1bml0WCA9IHdpZHRoIC8gZGF0YS5sZW5ndGg7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByZXN1bHQucHVzaCh7XG5cdCAgICAgICAgeDogTWF0aC5jZWlsKHVuaXRYICogaSkgKyB4LFxuXHQgICAgICAgIHk6IHksXG5cdCAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG5cdCAgICAgICAgd2lkdGg6IHVuaXRYXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0QmFyLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0ICB2YXIgbWluVmFsdWUgPSBNYXRoLm1pbi5hcHBseShudWxsLCBkYXRhKTtcblx0ICBpZiAoY29uZmlnLm9yaWdpbiA8IG1pblZhbHVlKSBtaW5WYWx1ZSA9IGNvbmZpZy5vcmlnaW47XG5cdCAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgZGF0YSk7XG5cdCAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgIHZhciB4ID0gY29uZmlnLnBhZGRpbmdYO1xuXHQgIHZhciB5ID0gY29uZmlnLnBhZGRpbmdZO1xuXHQgIHZhciBtYXJnaW4gPSBjb25maWcubWFyZ2luO1xuXHQgIHZhciBiYXJXaWR0aCA9IGNvbmZpZy53aWR0aCB8fCAyMDtcblxuXHQgIHZhciBvcmlnaW5ZID0gdGhpcy5fZ2V0T3JpZ2luKGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXG5cdCAgd2lkdGggPSAod2lkdGggfHwgMTAwKSAtIHggKiAyO1xuXHQgIGhlaWdodCA9IChoZWlnaHQgfHwgMTAwKSAtIHkgKiAyO1xuXG5cdCAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cdCAgICB2YXIgdW5pdFggPSB3aWR0aCAvIGRhdGEubGVuZ3RoO1xuXHQgICAgdmFyIHlOdW0gPSBjb25maWcuc2NhbGUgfHwgbWF4VmFsdWUgLSBtaW5WYWx1ZTtcblx0ICAgIGJhcldpZHRoID0gTWF0aC5taW4odW5pdFggLSBtYXJnaW4sIGJhcldpZHRoKTtcblx0ICAgIG1hcmdpbiA9IHVuaXRYIC0gYmFyV2lkdGg7XG5cdCAgICB2YXIgbWluSGVpZ2h0ID0gMDtcblx0ICAgIHZhciBvcmlnaW4gPSBtaW5WYWx1ZTtcblx0ICAgIGlmIChjb25maWcub3JpZ2luICE9PSBmYWxzZSAmJiBjb25maWcub3JpZ2luID4gbWluVmFsdWUpIG9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gfHwgMDtlbHNlIG1pbkhlaWdodCA9IGNvbmZpZy5taW5IZWlnaHQ7XG5cdCAgICB2YXIgdW5pdFkgPSAoaGVpZ2h0IC0gbWluSGVpZ2h0KSAvICh5TnVtID8geU51bSA6IDEpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGggPSBNYXRoLmNlaWwodW5pdFkgKiAoZGF0YVtpXSAtIG9yaWdpbikpO1xuXHQgICAgICByZXN1bHQucHVzaCh7XG5cdCAgICAgICAgeDogTWF0aC5jZWlsKHVuaXRYICogaSkgKyB4ICsgbWFyZ2luIC8gMixcblx0ICAgICAgICB5OiBvcmlnaW5ZIC0gKGRhdGFbaV0gPj0gb3JpZ2luID8gaCA6IDApIC0gbWluSGVpZ2h0LFxuXHQgICAgICAgIGhlaWdodDogTWF0aC5hYnMoaCkgKyBtaW5IZWlnaHQsXG5cdCAgICAgICAgd2lkdGg6IGJhcldpZHRoXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzJDMgPSB7XG5cdCAgcGFkZGluZ1k6IDJcblx0fTtcblxuXHRmdW5jdGlvbiBQaWUoY29uZmlnKSB7XG5cdCAgdGhpcy5jb25maWcgPSBleHBvcnRzLmV4dGVuZChkZWZhdWx0cyQzLCBjb25maWcgfHwge30sIHRydWUpO1xuXHR9XG5cblx0UGllLnByb3RvdHlwZS5fZGVmQ29sb3JzQ3Vyc29yID0gMDtcblx0UGllLnByb3RvdHlwZS5fZGVmQ29sb3JzID0gW1wiI2Y1NWI1MFwiLCBcIiNmZjZkM2ZcIiwgXCIjZmZhNTIxXCIsIFwiI2ZmYzkyN1wiLCBcIiNmZmVlNTRcIiwgXCIjZDNlMTUzXCIsIFwiIzlhY2I2MVwiLCBcIiM2M2I5NjdcIiwgXCIjMjFhNDk3XCIsIFwiIzIxYzVkYVwiLCBcIiMzZWE0ZjVcIiwgXCIjNTg2OGJmXCIsIFwiIzdiNTNjMFwiLCBcIiNhOTQzYmFcIiwgXCIjZWMzYjc3XCIsIFwiIzllYjBiOFwiXTtcblxuXHRQaWUucHJvdG90eXBlLl9nZXRDb2xvciA9IGZ1bmN0aW9uIChpLCBkYXRhKSB7XG5cdCAgdmFyIGNvdW50ID0gZGF0YS5sZW5ndGg7XG5cdCAgdmFyIGNvbG9yc0NvdW50ID0gdGhpcy5fZGVmQ29sb3JzLmxlbmd0aDtcblxuXHQgIGlmIChjb2xvcnNDb3VudCA+IGNvdW50KSB7XG5cdCAgICBpZiAoaSkge1xuXHQgICAgICBpZiAoaSA8IGNvbG9yc0NvdW50IC0gY291bnQpIGkgPSB0aGlzLl9kZWZDb2xvcnNDdXJzb3IgKyAyO2Vsc2UgaSA9IHRoaXMuX2RlZkNvbG9yc0N1cnNvciArIDE7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2RlZkNvbG9yc0N1cnNvciA9IGk7XG5cdCAgfSBlbHNlIGkgPSBpICUgY29sb3JzQ291bnQ7XG5cblx0ICByZXR1cm4gdGhpcy5fZGVmQ29sb3JzW2ldO1xuXHR9O1xuXG5cdFBpZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XG5cdCAgdmFyIGF0dHJzLFxuXHQgICAgICBncmFwaCxcblx0ICAgICAgaSxcblx0ICAgICAgc2VjdG9ycyxcblx0ICAgICAgY29uZmlnID0gdGhpcy5jb25maWcsXG5cdCAgICAgIGNvbG9yID0gY29uZmlnLmNvbG9yIHx8IHRoaXMuX2dldENvbG9yLFxuXHQgICAgICBwb2ludHMgPSB0aGlzLmdldEFuZ2xlcyhkYXRhKSxcblx0ICAgICAgcmVuZGVyZXIgPSBTVkcsXG5cdCAgICAgIHkgPSBjb25maWcucGFkZGluZ1kgfHwgMCxcblx0ICAgICAgLy8gcmFkaXVzXG5cdCAgciA9IGhlaWdodCAvIDIgLSB5LFxuXHQgICAgICAvLyBjZW50ZXJcblx0ICB4MCA9IHdpZHRoIC8gMixcblx0ICAgICAgeTAgPSBoZWlnaHQgLyAyOyAvLyBkcmF3IHNlY3RvcnNcblxuXHQgIGlmICh0eXBlb2YgY29sb3IgIT0gXCJmdW5jdGlvblwiKSBjb2xvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBjb2xvcjtcblx0ICB9O1xuXHQgIHNlY3RvcnMgPSBcIlwiO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgYXR0cnMgPSB7fTtcblx0ICAgIGF0dHJzW3JlbmRlcmVyLnN0eWxlTWFwW1wiY29sb3JcIl1dID0gY29sb3IuY2FsbCh0aGlzLCBpLCBkYXRhLCB0aGlzLl9jb250ZXh0KTtcblx0ICAgIHNlY3RvcnMgKz0gcmVuZGVyZXIuZ2V0U2VjdG9yKHtcblx0ICAgICAgeDogeDAsXG5cdCAgICAgIHk6IHkwXG5cdCAgICB9LCByLCBwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSwgXCJ3ZWJpeF9zcGFya2xpbmVzX3NlY3RvclwiLCBhdHRycyk7XG5cdCAgfVxuXG5cdCAgZ3JhcGggPSByZW5kZXJlci5ncm91cChzZWN0b3JzKTsgLy8gZHJhdyBldmVudCBhcmVhc1xuXG5cdCAgc2VjdG9ycyA9IFwiXCI7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBzZWN0b3JzICs9IHJlbmRlcmVyLmdldFNlY3Rvcih7XG5cdCAgICAgIHg6IHgwLFxuXHQgICAgICB5OiB5MFxuXHQgICAgfSwgciwgcG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0sIFwid2ViaXhfc3BhcmtsaW5lc19ldmVudF9hcmVhXCIsIHtcblx0ICAgICAgXCJ3ZWJpeF9hcmVhXCI6IGlcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGdyYXBoICs9IHJlbmRlcmVyLmdyb3VwKHNlY3RvcnMpO1xuXHQgIHJldHVybiByZW5kZXJlci5kcmF3KGdyYXBoLCB3aWR0aCwgaGVpZ2h0LCBcIndlYml4X3NwYXJrbGluZXNfcGllX2NoYXJ0XCIgKyAoY29uZmlnLmNzcyA/IFwiIFwiICsgY29uZmlnLmNzcyA6IFwiXCIpKTtcblx0fTtcblxuXHRQaWUucHJvdG90eXBlLmdldEFuZ2xlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdmFyIGEwID0gLU1hdGguUEkgLyAyLFxuXHQgICAgICBhMSxcblx0ICAgICAgaSxcblx0ICAgICAgcmVzdWx0ID0gW107XG5cblx0ICB2YXIgcmF0aW9zID0gdGhpcy5fZ2V0UmF0aW9zKGRhdGEpO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgIGExID0gLU1hdGguUEkgLyAyICsgcmF0aW9zW2ldIC0gMC4wMDAxO1xuXHQgICAgcmVzdWx0LnB1c2goW2EwLCBhMV0pO1xuXHQgICAgYTAgPSBhMTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFBpZS5wcm90b3R5cGUuX2dldFRvdGFsVmFsdWUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciB0ID0gMDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgdCArPSBkYXRhW2ldICogMTtcblx0ICB9XG5cblx0ICByZXR1cm4gdDtcblx0fTtcblxuXHRQaWUucHJvdG90eXBlLl9nZXRSYXRpb3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciBpLFxuXHQgICAgICB2YWx1ZSxcblx0ICAgICAgcmF0aW9zID0gW10sXG5cdCAgICAgIHByZXZTdW0gPSAwLFxuXHQgICAgICB0b3RhbFZhbHVlID0gdGhpcy5fZ2V0VG90YWxWYWx1ZShkYXRhKTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YWx1ZSA9IGRhdGFbaV0gKiAxO1xuXHQgICAgcmF0aW9zW2ldID0gTWF0aC5QSSAqIDIgKiAodG90YWxWYWx1ZSA/ICh2YWx1ZSArIHByZXZTdW0pIC8gdG90YWxWYWx1ZSA6IDEgLyBkYXRhLmxlbmd0aCk7XG5cdCAgICBwcmV2U3VtICs9IHZhbHVlO1xuXHQgIH1cblxuXHQgIHJldHVybiByYXRpb3M7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzJDQgPSB7XG5cdCAgcGFkZGluZ1g6IDMsXG5cdCAgcGFkZGluZ1k6IDYsXG5cdCAgcmFkaXVzOiAyLFxuXHQgIG1pbkhlaWdodDogNCxcblx0ICBldmVudFJhZGl1czogOFxuXHR9O1xuXG5cdGZ1bmN0aW9uIFNwbGluZShjb25maWcpIHtcblx0ICB0aGlzLmNvbmZpZyA9IGV4cG9ydHMuZXh0ZW5kKGNvcHkoZGVmYXVsdHMkNCksIGNvbmZpZyB8fCB7fSwgdHJ1ZSk7XG5cdH1cblxuXHRTcGxpbmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZyxcblx0ICAgICAgZ3JhcGggPSBcIlwiLFxuXHQgICAgICBMaW5lJCQxID0gTGluZS5wcm90b3R5cGUsXG5cdCAgICAgIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKGRhdGEsIHdpZHRoLCBoZWlnaHQpLFxuXHQgICAgICByZW5kZXJlciA9IFNWRyxcblx0ICAgICAgc3R5bGVzID0gY29uZmlnLmNvbG9yID8gdGhpcy5fYXBwbHlDb2xvcihyZW5kZXJlciwgY29uZmlnLmNvbG9yKSA6IG51bGw7IC8vIGRyYXcgc3BsaW5lXG5cblx0ICBncmFwaCArPSByZW5kZXJlci5ncm91cChyZW5kZXJlci5nZXRDdXJ2ZShwb2ludHMsIFwid2ViaXhfc3BhcmtsaW5lc19saW5lXCIgKyAoc3R5bGVzID8gXCIgXCIgKyBzdHlsZXMubGluZSA6IFwiXCIpKSk7XG5cdCAgdmFyIGxpbmVQb2ludHMgPSBMaW5lJCQxLmdldFBvaW50cy5jYWxsKHRoaXMsIGRhdGEsIHdpZHRoLCBoZWlnaHQpOyAvLyBkcmF3IGl0ZW1zXG5cblx0ICBncmFwaCArPSBMaW5lJCQxLl9kcmF3SXRlbXMocmVuZGVyZXIsIGxpbmVQb2ludHMsIGNvbmZpZy5yYWRpdXMsIFwid2ViaXhfc3BhcmtsaW5lc19pdGVtXCIgKyAoc3R5bGVzID8gXCIgXCIgKyBzdHlsZXMuaXRlbSA6IFwiXCIpKTsgLy8gZHJhdyBldmVudCBpdGVtc1xuXG5cdCAgdmFyIGV2ZW50UmFkaXVzID0gTWF0aC5taW4oZGF0YS5sZW5ndGggPyAod2lkdGggLSAyICogKGNvbmZpZy5wYWRkaW5nWCB8fCAwKSkgLyBkYXRhLmxlbmd0aCA6IDAsIGNvbmZpZy5ldmVudFJhZGl1cyk7XG5cdCAgZ3JhcGggKz0gTGluZSQkMS5fZHJhd0V2ZW50SXRlbXMocmVuZGVyZXIsIGxpbmVQb2ludHMsIGV2ZW50UmFkaXVzKTtcblx0ICByZXR1cm4gcmVuZGVyZXIuZHJhdyhncmFwaCwgd2lkdGgsIGhlaWdodCwgXCJ3ZWJpeF9zcGFya2xpbmVzX2xpbmVfY2hhcnRcIiArIChjb25maWcuY3NzID8gXCIgXCIgKyBjb25maWcuY3NzIDogXCJcIikpO1xuXHR9O1xuXG5cdFNwbGluZS5wcm90b3R5cGUuX2FwcGx5Q29sb3IgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGNvbG9yKSB7XG5cdCAgdmFyIGNvbmZpZyA9IHtcblx0ICAgIFwibGluZVwiOiB7fSxcblx0ICAgIFwiaXRlbVwiOiB7fVxuXHQgIH0sXG5cdCAgICAgIG1hcCA9IHJlbmRlcmVyLnN0eWxlTWFwO1xuXG5cdCAgaWYgKGNvbG9yKSB7XG5cdCAgICBjb25maWcubGluZVttYXAubGluZUNvbG9yXSA9IGNvbG9yO1xuXHQgICAgY29uZmlnLml0ZW1bbWFwLmNvbG9yXSA9IGNvbG9yO1xuXG5cdCAgICBmb3IgKHZhciBuYW1lIGluIGNvbmZpZykge1xuXHQgICAgICBjb25maWdbbmFtZV0gPSBjcmVhdGVDc3MoY29uZmlnW25hbWVdKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gY29uZmlnO1xuXHR9O1xuXG5cdFNwbGluZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICB2YXIgaSxcblx0ICAgICAgcG9pbnRzLFxuXHQgICAgICBweCxcblx0ICAgICAgcHksXG5cdCAgICAgIHJlc3VsdCA9IFtdLFxuXHQgICAgICB4ID0gW10sXG5cdCAgICAgIHkgPSBbXSxcblx0ICAgICAgTGluZSQkMSA9IExpbmUucHJvdG90eXBlO1xuXHQgIHBvaW50cyA9IExpbmUkJDEuZ2V0UG9pbnRzLmNhbGwodGhpcywgZGF0YSwgd2lkdGgsIGhlaWdodCk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB4LnB1c2gocG9pbnRzW2ldLngpO1xuXHQgICAgeS5wdXNoKHBvaW50c1tpXS55KTtcblx0ICB9XG5cblx0ICBweCA9IHRoaXMuX2dldENvbnRyb2xQb2ludHMoeCk7XG5cdCAgcHkgPSB0aGlzLl9nZXRDb250cm9sUG9pbnRzKHkpO1xuXHQgIC8qdXBkYXRlcyBwYXRoIHNldHRpbmdzLCB0aGUgYnJvd3NlciB3aWxsIGRyYXcgdGhlIG5ldyBzcGxpbmUqL1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcblx0ICAgIHJlc3VsdC5wdXNoKFtwb2ludHNbaV0sIHtcblx0ICAgICAgeDogcHhbMF1baV0sXG5cdCAgICAgIHk6IHB5WzBdW2ldXG5cdCAgICB9LCB7XG5cdCAgICAgIHg6IHB4WzFdW2ldLFxuXHQgICAgICB5OiBweVsxXVtpXVxuXHQgICAgfSwgcG9pbnRzW2kgKyAxXV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdC8qIGNvZGUgZnJvbSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gKi9cblxuXG5cdFNwbGluZS5wcm90b3R5cGUuX2dldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG5cdCAgdmFyIGEgPSBbXSxcblx0ICAgICAgYiA9IFtdLFxuXHQgICAgICBjID0gW10sXG5cdCAgICAgIHIgPSBbXSxcblx0ICAgICAgcDEgPSBbXSxcblx0ICAgICAgcDIgPSBbXSxcblx0ICAgICAgaSxcblx0ICAgICAgbSxcblx0ICAgICAgbiA9IHBvaW50cy5sZW5ndGggLSAxO1xuXHQgIGFbMF0gPSAwO1xuXHQgIGJbMF0gPSAyO1xuXHQgIGNbMF0gPSAxO1xuXHQgIHJbMF0gPSBwb2ludHNbMF0gKyAyICogcG9pbnRzWzFdO1xuXG5cdCAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcblx0ICAgIGFbaV0gPSAxO1xuXHQgICAgYltpXSA9IDQ7XG5cdCAgICBjW2ldID0gMTtcblx0ICAgIHJbaV0gPSA0ICogcG9pbnRzW2ldICsgMiAqIHBvaW50c1tpICsgMV07XG5cdCAgfVxuXG5cdCAgYVtuIC0gMV0gPSAyO1xuXHQgIGJbbiAtIDFdID0gNztcblx0ICBjW24gLSAxXSA9IDA7XG5cdCAgcltuIC0gMV0gPSA4ICogcG9pbnRzW24gLSAxXSArIHBvaW50c1tuXTtcblxuXHQgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0ICAgIG0gPSBhW2ldIC8gYltpIC0gMV07XG5cdCAgICBiW2ldID0gYltpXSAtIG0gKiBjW2kgLSAxXTtcblx0ICAgIHJbaV0gPSByW2ldIC0gbSAqIHJbaSAtIDFdO1xuXHQgIH1cblxuXHQgIHAxW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG5cblx0ICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcblx0ICAgIHAxW2ldID0gKHJbaV0gLSBjW2ldICogcDFbaSArIDFdKSAvIGJbaV07XG5cdCAgfVxuXG5cdCAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0ICAgIHAyW2ldID0gMiAqIHBvaW50c1tpICsgMV0gLSBwMVtpICsgMV07XG5cdCAgfVxuXG5cdCAgcDJbbiAtIDFdID0gMC41ICogKHBvaW50c1tuXSArIHAxW24gLSAxXSk7XG5cdCAgcmV0dXJuIFtwMSwgcDJdO1xuXHR9O1xuXG5cdHZhciBkZWZhdWx0c0FyZWEgPSB7XG5cdCAgcGFkZGluZ1g6IDMsXG5cdCAgcGFkZGluZ1k6IDYsXG5cdCAgcmFkaXVzOiAxLFxuXHQgIG1pbkhlaWdodDogNCxcblx0ICBldmVudFJhZGl1czogOFxuXHR9OyAvLyBzcGxpbmUgYXJlYVxuXG5cdGZ1bmN0aW9uIFNwbGluZUFyZWEoY29uZmlnKSB7XG5cdCAgdGhpcy5jb25maWcgPSBleHBvcnRzLmV4dGVuZChjb3B5KGRlZmF1bHRzQXJlYSksIGNvbmZpZyB8fCB7fSwgdHJ1ZSk7XG5cdH1cblxuXHRTcGxpbmVBcmVhLnByb3RvdHlwZSA9IGNvcHkoU3BsaW5lLnByb3RvdHlwZSk7XG5cblx0U3BsaW5lQXJlYS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChkYXRhLCB3aWR0aCwgaGVpZ2h0KSB7XG5cdCAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnLFxuXHQgICAgICBMaW5lJCQxID0gTGluZS5wcm90b3R5cGUsXG5cdCAgICAgIHJlbmRlcmVyID0gU1ZHLFxuXHQgICAgICBzdHlsZXMgPSBjb25maWcuY29sb3IgPyB0aGlzLl9hcHBseUNvbG9yKHJlbmRlcmVyLCBjb25maWcuY29sb3IpIDogbnVsbDtcblx0ICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoZGF0YSwgd2lkdGgsIGhlaWdodCk7IC8vIGRyYXcgYXJlYVxuXG5cdCAgdmFyIGxpbmVQb2ludHMgPSBwb2ludHMuc3BsaWNlKHBvaW50cy5sZW5ndGggLSAzLCAzKTtcblxuXHQgIHZhciBsaW5lUGF0aCA9IHJlbmRlcmVyLl9saW5lUG9pbnRzKGxpbmVQb2ludHMpO1xuXG5cdCAgbGluZVBhdGhbMF1bMF0gPSBcIkxcIjtcblxuXHQgIHZhciBhcmVhUG9pbnRzID0gcmVuZGVyZXIuX2N1cnZlUG9pbnRzKHBvaW50cykuY29uY2F0KGxpbmVQYXRoKTtcblxuXHQgIHZhciBncmFwaCA9IHJlbmRlcmVyLmdyb3VwKHJlbmRlcmVyLmdldFBhdGgocmVuZGVyZXIuZGVmaW5lUGF0aChhcmVhUG9pbnRzKSwgXCJ3ZWJpeF9zcGFya2xpbmVzX2FyZWFcIiArIChzdHlsZXMgPyBcIiBcIiArIHN0eWxlcy5hcmVhIDogXCJcIiksIHRydWUpKTsgLy8gZHJhdyBsaW5lXG5cblx0ICBncmFwaCArPSByZW5kZXJlci5ncm91cChyZW5kZXJlci5nZXRQYXRoKHJlbmRlcmVyLmRlZmluZVBhdGgocmVuZGVyZXIuX2N1cnZlUG9pbnRzKHBvaW50cykpLCBcIndlYml4X3NwYXJrbGluZXNfbGluZVwiICsgKHN0eWxlcyA/IFwiIFwiICsgc3R5bGVzLmxpbmUgOiBcIlwiKSkpO1xuXHQgIHZhciBpdGVtUG9pbnRzID0gTGluZSQkMS5nZXRQb2ludHMuY2FsbCh0aGlzLCBkYXRhLCB3aWR0aCwgaGVpZ2h0KTsgLy8gZHJhdyBpdGVtc1xuXG5cdCAgZ3JhcGggKz0gTGluZSQkMS5fZHJhd0l0ZW1zKHJlbmRlcmVyLCBpdGVtUG9pbnRzLCBjb25maWcucmFkaXVzLCBcIndlYml4X3NwYXJrbGluZXNfaXRlbVwiICsgKHN0eWxlcyA/IFwiIFwiICsgc3R5bGVzLml0ZW0gOiBcIlwiKSk7IC8vIGRyYXcgZXZlbnQgaXRlbXNcblxuXHQgIHZhciBldmVudFJhZGl1cyA9IE1hdGgubWluKGRhdGEubGVuZ3RoID8gKHdpZHRoIC0gMiAqIChjb25maWcucGFkZGluZ1ggfHwgMCkpIC8gZGF0YS5sZW5ndGggOiAwLCBjb25maWcuZXZlbnRSYWRpdXMpO1xuXHQgIGdyYXBoICs9IExpbmUkJDEuX2RyYXdFdmVudEl0ZW1zKHJlbmRlcmVyLCBpdGVtUG9pbnRzLCBldmVudFJhZGl1cyk7XG5cdCAgcmV0dXJuIHJlbmRlcmVyLmRyYXcoZ3JhcGgsIHdpZHRoLCBoZWlnaHQsIFwid2ViaXhfc3BhcmtsaW5lc19zcGxpbmVhcmVhX2NoYXJ0XCIgKyAoY29uZmlnLmNzcyA/IFwiIFwiICsgY29uZmlnLmNzcyA6IFwiXCIpKTtcblx0fTtcblxuXHRTcGxpbmVBcmVhLnByb3RvdHlwZS5fYXBwbHlDb2xvciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgY29sb3IpIHtcblx0ICB2YXIgY29uZmlnID0ge1xuXHQgICAgXCJhcmVhXCI6IHt9LFxuXHQgICAgXCJsaW5lXCI6IHt9LFxuXHQgICAgXCJpdGVtXCI6IHt9XG5cdCAgfSxcblx0ICAgICAgbWFwID0gcmVuZGVyZXIuc3R5bGVNYXA7XG5cblx0ICBpZiAoY29sb3IpIHtcblx0ICAgIGNvbmZpZy5hcmVhW21hcC5jb2xvcl0gPSByZW5kZXJlci5zZXRPcGFjaXR5KGNvbG9yLCAwLjIpO1xuXHQgICAgY29uZmlnLmxpbmVbbWFwLmxpbmVDb2xvcl0gPSBjb2xvcjtcblx0ICAgIGNvbmZpZy5pdGVtW21hcC5jb2xvcl0gPSBjb2xvcjtcblxuXHQgICAgZm9yICh2YXIgbmFtZSBpbiBjb25maWcpIHtcblx0ICAgICAgY29uZmlnW25hbWVdID0gY3JlYXRlQ3NzKGNvbmZpZ1tuYW1lXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNvbmZpZztcblx0fTtcblxuXHRTcGxpbmVBcmVhLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuXHQgIHZhciBwb2ludHMgPSBTcGxpbmUucHJvdG90eXBlLmdldFBvaW50cy5jYWxsKHRoaXMsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuXHQgIHZhciB4ID0gdGhpcy5jb25maWcucGFkZGluZ1ggfHwgMDtcblx0ICB2YXIgeSA9IHRoaXMuY29uZmlnLnBhZGRpbmdZIHx8IDA7XG5cdCAgcG9pbnRzLnB1c2goe1xuXHQgICAgeDogd2lkdGggLSB4LFxuXHQgICAgeTogaGVpZ2h0IC0geVxuXHQgIH0sIHtcblx0ICAgIHg6IHgsXG5cdCAgICB5OiBoZWlnaHQgLSB5XG5cdCAgfSwge1xuXHQgICAgeDogeCxcblx0ICAgIHk6IHBvaW50c1swXVswXS55XG5cdCAgfSk7XG5cdCAgcmV0dXJuIHBvaW50cztcblx0fTtcblxuXHRmdW5jdGlvbiBTcGFya2xpbmVzKCkge31cblxuXHRmdW5jdGlvbiBnZXREYXRhKGRhdGEpIHtcblx0ICB2YXIgdmFsdWVzID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgdmFyIHZhbHVlID0gZGF0YVtpXTtcblx0ICAgIHZhbHVlc1tpXSA9IF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiID8gdmFsdWUudmFsdWUgOiB2YWx1ZTtcblx0ICB9XG5cblx0ICByZXR1cm4gdmFsdWVzO1xuXHR9XG5cblx0U3BhcmtsaW5lcy50eXBlcyA9IHt9O1xuXG5cdFNwYXJrbGluZXMuZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoY3VzdG9tQ29uZmlnKSB7XG5cdCAgdmFyIGNvbmZpZyA9IGN1c3RvbUNvbmZpZyB8fCB7fTtcblx0ICBpZiAodHlwZW9mIGN1c3RvbUNvbmZpZyA9PSBcInN0cmluZ1wiKSBjb25maWcgPSB7XG5cdCAgICB0eXBlOiBjdXN0b21Db25maWdcblx0ICB9O1xuXHQgIGV4cG9ydHMuZXh0ZW5kKGNvbmZpZywge1xuXHQgICAgdHlwZTogXCJsaW5lXCJcblx0ICB9KTtcblx0ICB2YXIgc2xDb25zdHJ1Y3RvciA9IHRoaXMudHlwZXNbY29uZmlnLnR5cGVdO1xuXHQgIGFzc2VydChzbENvbnN0cnVjdG9yLCBcIlVua25vd24gc3BhcmtsaW5lIHR5cGVcIik7XG5cdCAgcmV0dXJuIGJpbmQodGhpcy5fdGVtcGxhdGUsIG5ldyBzbENvbnN0cnVjdG9yKGNvbmZpZykpO1xuXHR9O1xuXG5cdFNwYXJrbGluZXMuX3RlbXBsYXRlID0gZnVuY3Rpb24gKGl0ZW0sIGNvbW1vbiwgZGF0YSwgY29sdW1uKSB7XG5cdCAgaWYgKGNvbHVtbikgcmV0dXJuIHRoaXMuZHJhdyhnZXREYXRhKGRhdGEpLCBjb2x1bW4ud2lkdGgsIDMzKTtlbHNlIHJldHVybiB0aGlzLmRyYXcoaXRlbS5kYXRhIHx8IGl0ZW0sIGNvbW1vbi53aWR0aCwgY29tbW9uLmhlaWdodCk7XG5cdH07IC8vIGFkZCBcInNwYXJrbGluZXNcIiB0eXBlXG5cblxuXHRhdHRhY2hFdmVudChcIm9uRGF0YVRhYmxlXCIsIGZ1bmN0aW9uICh0YWJsZSkge1xuXHQgIHRhYmxlLnR5cGUuc3BhcmtsaW5lcyA9IFNwYXJrbGluZXMuZ2V0VGVtcGxhdGUoKTtcblx0fSk7XG5cdFNwYXJrbGluZXMudHlwZXNbXCJhcmVhXCJdID0gQXJlYTtcblx0U3BhcmtsaW5lcy50eXBlc1tcImJhclwiXSA9IEJhcjtcblx0U3BhcmtsaW5lcy50eXBlc1tcImxpbmVcIl0gPSBMaW5lO1xuXHRTcGFya2xpbmVzLnR5cGVzW1wicGllXCJdID0gUGllO1xuXHRTcGFya2xpbmVzLnR5cGVzW1wic3BsaW5lXCJdID0gU3BsaW5lO1xuXHRTcGFya2xpbmVzLnR5cGVzW1wic3BsaW5lQXJlYVwiXSA9IFNwbGluZUFyZWE7XG5cblx0dmFyIGNzdiQxID0ge1xuXHQgIGVzY2FwZTogdHJ1ZSxcblx0ICBkZWxpbWl0ZXI6IHtcblx0ICAgIHJvd3M6IFwiXFxuXCIsXG5cdCAgICBjb2xzOiBcIlxcdFwiXG5cdCAgfSxcblx0ICBwYXJzZTogZnVuY3Rpb24gKHRleHQsIHNlcCkge1xuXHQgICAgc2VwID0gc2VwIHx8IHRoaXMuZGVsaW1pdGVyO1xuXHQgICAgaWYgKCF0aGlzLmVzY2FwZSkgcmV0dXJuIHRoaXMuX3NwbGl0X2NsaXBfZGF0YSh0ZXh0LCBzZXApO1xuXHQgICAgdmFyIGxpbmVzID0gdGV4dC5yZXBsYWNlKC9cXG4kLywgXCJcIikuc3BsaXQoc2VwLnJvd3MpO1xuXHQgICAgdmFyIGkgPSAwO1xuXG5cdCAgICB3aGlsZSAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgaWYgKHRoaXMuX3N1YnN0cl9jb3VudChsaW5lc1tpXSwgXCJcXFwiXCIpICUgMiA9PT0gMSkge1xuXHQgICAgICAgIGxpbmVzW2ldICs9IHNlcC5yb3dzICsgbGluZXNbaSArIDFdO1xuXHQgICAgICAgIGRlbGV0ZSBsaW5lc1tpICsgMV07XG5cdCAgICAgICAgaSsrO1xuXHQgICAgICB9XG5cblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY3N2ID0gW107XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodHlwZW9mIGxpbmVzW2ldICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgdmFyIHRsaW5lID0gbGluZXNbaV07XG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gMDtcblx0ICAgICAgICB2YXIgbGluZSA9IFtdO1xuXHQgICAgICAgIHZhciBxdW90ZWQgPSBmYWxzZTtcblxuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IHRsaW5lLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICBpZiAoIXF1b3RlZCAmJiB0bGluZVtqXSA9PT0gc2VwLmNvbHMgfHwgaiA9PT0gdGxpbmUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciBjaHVuayA9IHRsaW5lLnN1YnN0cihzdGFydCwgaiAtIHN0YXJ0KTtcblxuXHQgICAgICAgICAgICBpZiAoY2h1bmtbMF0gPT09IGNodW5rW2NodW5rLmxlbmd0aCAtIDFdICYmIGNodW5rWzBdID09PSBcIlxcXCJcIikge1xuXHQgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3Vic3RyKDEsIGNodW5rLmxlbmd0aCAtIDIpLnJlcGxhY2UoXCJcXFwiXFxcIlwiLCBcIlxcXCJcIik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBsaW5lLnB1c2goY2h1bmspO1xuXHQgICAgICAgICAgICBzdGFydCA9IGogKyAxO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAodGxpbmVbal0gPT09IFwiXFxcIlwiKSB7XG5cdCAgICAgICAgICAgIHF1b3RlZCA9ICFxdW90ZWQ7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNzdi5wdXNoKGxpbmUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjc3Y7XG5cdCAgfSxcblx0ICBfc3BsaXRfY2xpcF9kYXRhOiBmdW5jdGlvbiAodGV4dCwgc2VwKSB7XG5cdCAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KHNlcC5yb3dzKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnNwbGl0KHNlcC5jb2xzKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGxpbmVzO1xuXHQgIH0sXG5cblx0ICAvKiEgY291bnRzIGhvdyBtYW55IG9jY3VyYW5jZXMgc3Vic3RyaW5nIGluIHN0cmluZyAqKi9cblx0ICBfc3Vic3RyX2NvdW50OiBmdW5jdGlvbiAoc3RyaW5nLCBzdWJzdHJpbmcpIHtcblx0ICAgIHZhciBhcnIgPSBzdHJpbmcuc3BsaXQoc3Vic3RyaW5nKTtcblx0ICAgIHJldHVybiBhcnIubGVuZ3RoIC0gMTtcblx0ICB9LFxuXHQgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGRhdGEsIHNlcCkge1xuXHQgICAgc2VwID0gc2VwIHx8IHRoaXMuZGVsaW1pdGVyO1xuXG5cdCAgICBpZiAoIXRoaXMuZXNjYXBlKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldLmpvaW4oc2VwLmNvbHMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGRhdGEuam9pbihzZXAucm93cyk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZWcgPSAvXFxufFwifDt8LC87XG5cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2krKykge1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbX2ldLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgdmFyIGNodW5rID0gZGF0YVtfaV1bal07XG5cdCAgICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgRGF0ZSkgZGF0YVtfaV1bal0gPSBpMThuLnBhcnNlRm9ybWF0U3RyKGNodW5rKTtlbHNlIGlmIChyZWcudGVzdChjaHVuaykpIGRhdGFbX2ldW2pdID0gXCJcXFwiXCIgKyBjaHVuay50b1N0cmluZygpLnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGRhdGFbX2ldID0gZGF0YVtfaV0uam9pbihzZXAuY29scyk7XG5cdCAgICB9XG5cblx0ICAgIGRhdGEgPSBkYXRhLmpvaW4oc2VwLnJvd3MpO1xuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBUYWJsZVBhc3RlID0ge1xuXHQgIGNsaXBib2FyZF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSAxKSB2YWx1ZSA9IFwiYmxvY2tcIjtcblx0ICAgIGNsaXBidWZmZXIuaW5pdCgpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU2VsZWN0Q2hhbmdlXCIsIHRoaXMuX3NlbF90b19jbGlwKTsgLy8gc29sdXRpb24gZm9yIGNsaWNrcyBvbiBzZWxlY3RlZCBpdGVtc1xuXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25JdGVtQ2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB0aGlzLiR2aWV3LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG5cdCAgICAgICAgY2xpcGJ1ZmZlci5mb2N1cygpO1xuXHQgICAgICAgIFVJTWFuYWdlci5zZXRGb2N1cyh0aGlzKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25QYXN0ZVwiLCB0aGlzLl9jbGlwX3RvX3NlbCk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICB0ZW1wbGF0ZUNvcHlfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBfc2VsX3RvX2NsaXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5fZ2V0X3NlbF90ZXh0KCk7XG5cblx0ICAgIGNsaXBidWZmZXIuc2V0KGRhdGEpO1xuXHQgICAgVUlNYW5hZ2VyLnNldEZvY3VzKHRoaXMpO1xuXHQgIH0sXG5cdCAgX2dldF9zZWxfdGV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRhdGEgPSBbXTtcblx0ICAgIHZhciBmaWx0ZXIgPSB0aGlzLl9zZXR0aW5ncy50ZW1wbGF0ZUNvcHk7XG5cdCAgICB0aGlzLm1hcFNlbGVjdGlvbihmdW5jdGlvbiAodmFsdWUsIHJvdywgY29sLCByb3dfaW5kKSB7XG5cdCAgICAgIGlmICghZGF0YVtyb3dfaW5kXSkgZGF0YVtyb3dfaW5kXSA9IFtdO1xuXHQgICAgICB2YXIgbmV3dmFsdWUgPSBmaWx0ZXIgPyBmaWx0ZXIodmFsdWUsIHJvdywgY29sKSA6IHZhbHVlO1xuXHQgICAgICBkYXRhW3Jvd19pbmRdLnB1c2gobmV3dmFsdWUpO1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9KTtcblx0ICAgIHZhciB2YWx1ZSA9IGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0ubGVuZ3RoID09PSAxID8gZGF0YVswXVswXSA6IGNzdiQxLnN0cmluZ2lmeShkYXRhLCB0aGlzLl9zZXR0aW5ncy5kZWxpbWl0ZXIpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX2NsaXBfdG9fc2VsOiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9wYXN0ZVt0aGlzLl9zZXR0aW5ncy5jbGlwYm9hcmRdKSkge1xuXHQgICAgICB2YXIgZGF0YSA9IGNzdiQxLnBhcnNlKHRleHQsIHRoaXMuX3NldHRpbmdzLmRlbGltaXRlcik7XG5cblx0ICAgICAgdGhpcy5fcGFzdGVbdGhpcy5fc2V0dGluZ3MuY2xpcGJvYXJkXS5jYWxsKHRoaXMsIGRhdGEpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3Bhc3RlOiB7XG5cdCAgICBibG9jazogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgdmFyIGxlZnRUb3AgPSB0aGlzLm1hcFNlbGVjdGlvbihudWxsKTtcblx0ICAgICAgaWYgKCFsZWZ0VG9wKSByZXR1cm47IC8vIGZpbGxpbmcgY2VsbHMgd2l0aCBkYXRhXG5cblx0ICAgICAgdGhpcy5tYXBDZWxscyhsZWZ0VG9wLnJvdywgbGVmdFRvcC5jb2x1bW4sIGRhdGEubGVuZ3RoLCBudWxsLCBmdW5jdGlvbiAodmFsdWUsIHJvdywgY29sLCByb3dfaW5kLCBjb2xfaW5kKSB7XG5cdCAgICAgICAgaWYgKGRhdGFbcm93X2luZF0gJiYgZGF0YVtyb3dfaW5kXS5sZW5ndGggPiBjb2xfaW5kKSB7XG5cdCAgICAgICAgICByZXR1cm4gZGF0YVtyb3dfaW5kXVtjb2xfaW5kXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgfSxcblx0ICAgIHNlbGVjdGlvbjogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgdGhpcy5tYXBTZWxlY3Rpb24oZnVuY3Rpb24gKHZhbHVlLCByb3csIGNvbCwgcm93X2luZCwgY29sX2luZCkge1xuXHQgICAgICAgIGlmIChkYXRhW3Jvd19pbmRdICYmIGRhdGFbcm93X2luZF0ubGVuZ3RoID4gY29sX2luZCkgcmV0dXJuIGRhdGFbcm93X2luZF1bY29sX2luZF07XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIH0sXG5cdCAgICByZXBlYXQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgIHRoaXMubWFwU2VsZWN0aW9uKGZ1bmN0aW9uICh2YWx1ZSwgcm93LCBjb2wsIHJvd19pbmQsIGNvbF9pbmQpIHtcblx0ICAgICAgICByb3cgPSBkYXRhW3Jvd19pbmQgJSBkYXRhLmxlbmd0aF07XG5cdCAgICAgICAgdmFsdWUgPSByb3dbY29sX2luZCAlIHJvdy5sZW5ndGhdO1xuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9LFxuXHQgICAgY3VzdG9tOiBmdW5jdGlvbiAoKSB7fVxuXHQgIH1cblx0fTtcblxuXHR2YXIgVHJlZUFQSSA9IHtcblx0ICBvcGVuOiBmdW5jdGlvbiAoaWQsIHNob3cpIHtcblx0ICAgIGlmICghaWQpIHJldHVybjsgLy9pZ25vcmUgb3BlbiBmb3IgbGVhZiBpdGVtc1xuXG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICBhc3NlcnQoaXRlbSwgXCJJbmNvcnJlY3QgSUQgdG8gb3BlbjogXCIgKyBpZCk7XG5cdCAgICBpZiAoIWl0ZW0uJGNvdW50IHx8IGl0ZW0ub3BlbikgcmV0dXJuO1xuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZU9wZW5cIiwgW2lkXSkpIHtcblx0ICAgICAgaXRlbS5vcGVuID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5kYXRhLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFtpZCwgMCwgXCJicmFuY2hcIl0pO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJPcGVuXCIsIFtpZF0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2hvdyAmJiBpZCAhPSBcIjBcIikgdGhpcy5vcGVuKHRoaXMuZ2V0UGFyZW50SWQoaWQpLCBzaG93KTtcblx0ICB9LFxuXHQgIGNsb3NlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmICghaWQpIHJldHVybjtcblx0ICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgIGlmICghaXRlbS5vcGVuKSByZXR1cm47XG5cblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQ2xvc2VcIiwgW2lkXSkpIHtcblx0ICAgICAgaXRlbS5vcGVuID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuZGF0YS5jYWxsRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBbaWQsIDAsIFwiYnJhbmNoXCJdKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyQ2xvc2VcIiwgW2lkXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBvcGVuQWxsOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMuZGF0YS5lYWNoU3ViSXRlbShpZCB8fCAwLCBmdW5jdGlvbiAob2JqLCBicmFuY2gpIHtcblx0ICAgICAgaWYgKGJyYW5jaCkgb2JqLm9wZW4gPSB0cnVlO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmRhdGEucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgY2xvc2VBbGw6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5kYXRhLmVhY2hTdWJJdGVtKGlkIHx8IDAsIGZ1bmN0aW9uIChvYmosIGJyYW5jaCkge1xuXHQgICAgICBpZiAoYnJhbmNoKSBvYmoub3BlbiA9IGZhbHNlO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmRhdGEucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgX3RyZWVfY2hlY2tfdW5jaGVjazogZnVuY3Rpb24gKGlkLCBtb2RlLCBlKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudGhyZWVTdGF0ZSkgcmV0dXJuIHRoaXMuX3RyZWVfY2hlY2tfdW5jaGVja18zKGlkLCBtb2RlICE9PSBudWxsID8gbW9kZSA6IFwiXCIpO1xuXHQgICAgdmFyIHZhbHVlLFxuXHQgICAgICAgIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpLFxuXHQgICAgICAgIHRyZyA9IGUgPyBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQgOiBudWxsOyAvL3JlYWQgYWN0dWFsIHZhbHVlIGZyb20gSFRNTCB0YWcgd2hlbiBwb3NzaWJsZVxuXHQgICAgLy9hcyBpdCBjYW4gYmUgYWZmZWN0ZWQgYnkgZGJsLWNsaWNrc1xuXG5cdCAgICBpZiAodHJnICYmIHRyZy50eXBlID09IFwiY2hlY2tib3hcIikgdmFsdWUgPSB0cmcuY2hlY2tlZCA/IHRydWUgOiBmYWxzZTtlbHNlIHZhbHVlID0gbW9kZSAhPT0gbnVsbCA/IG1vZGUgOiAhaXRlbS5jaGVja2VkO1xuXHQgICAgaXRlbS5jaGVja2VkID0gdmFsdWU7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uSXRlbUNoZWNrXCIsIFtpZCwgaXRlbS5jaGVja2VkLCBlXSk7XG5cdCAgfSxcblx0ICBpc0JyYW5jaE9wZW46IGZ1bmN0aW9uIChzZWFyY2hfaWQpIHtcblx0ICAgIGlmIChzZWFyY2hfaWQgPT0gXCIwXCIpIHJldHVybiB0cnVlO1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oc2VhcmNoX2lkKTtcblx0ICAgIGlmIChpdGVtLm9wZW4pIHJldHVybiB0aGlzLmlzQnJhbmNoT3BlbihpdGVtLiRwYXJlbnQpO1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgZ2V0T3Blbkl0ZW1zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgb3BlbiA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmRhdGEuYnJhbmNoKSB7XG5cdCAgICAgIGlmICh0aGlzLmV4aXN0cyhpZCkgJiYgdGhpcy5nZXRJdGVtKGlkKS5vcGVuKSBvcGVuLnB1c2goaWQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3Blbjtcblx0ICB9LFxuXHQgIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBvcGVuOiB0aGlzLmdldE9wZW5JdGVtcygpLFxuXHQgICAgICBzZWxlY3Q6IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKVxuXHQgICAgfTtcblx0ICB9LFxuXHQgIF9yZXBlYXRfc2V0X3N0YXRlOiBmdW5jdGlvbiAodHJlZSwgb3Blbikge1xuXHQgICAgdmFyIGV2ZW50ID0gdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZUxvYWRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB0cmVlLnNldFN0YXRlLmNhbGwodHJlZSwgb3Blbik7XG5cdCAgICAgIHRyZWUuZGF0YS5kZXRhY2hFdmVudChldmVudCk7XG5cdCAgICAgIHRyZWUgPSBudWxsO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBzZXRTdGF0ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG5cdCAgICBpZiAoc3RhdGUub3Blbikge1xuXHQgICAgICB0aGlzLmNsb3NlQWxsKCk7XG5cdCAgICAgIHZhciBvcGVuID0gc3RhdGUub3BlbjtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShvcGVuW2ldKTtcblxuXHQgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uJGNvdW50KSB7XG5cdCAgICAgICAgICBpdGVtLm9wZW4gPSB0cnVlOyAvL2R5bmFtaWMgbG9hZGluZ1xuXG5cdCAgICAgICAgICBpZiAoaXRlbS4kY291bnQgPT0gLTEpIHtcblx0ICAgICAgICAgICAgLy9jYWxsIHRoZSBzYW1lIG1ldGhvZCBhZnRlciBkYXRhIGxvYWRpbmdcblx0ICAgICAgICAgICAgdGhpcy5fcmVwZWF0X3NldF9zdGF0ZSh0aGlzLCBzdGF0ZSk7XG5cblx0ICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICAgICAgICAgIHJldHVybiAwOyAvL2VuZCBwcm9jZXNzaW5nXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGF0ZS5zZWxlY3QgJiYgdGhpcy5zZWxlY3QpIHtcblx0ICAgICAgdmFyIHNlbGVjdCA9IHN0YXRlLnNlbGVjdDtcblx0ICAgICAgdGhpcy51bnNlbGVjdCgpO1xuXG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZWxlY3QubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZXhpc3RzKHNlbGVjdFtfaV0pKSB0aGlzLnNlbGVjdChzZWxlY3RbX2ldLCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdH07XG5cblx0dmFyIFRyZWVDbGljayA9IHtcblx0ICB3ZWJpeF90cmVlX29wZW46IGZ1bmN0aW9uIChlLCBpZCkge1xuXHQgICAgdGhpcy5jbG9zZShpZCk7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICB3ZWJpeF90cmVlX2Nsb3NlOiBmdW5jdGlvbiAoZSwgaWQpIHtcblx0ICAgIHRoaXMub3BlbihpZCk7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICB3ZWJpeF90cmVlX2NoZWNrYm94OiBmdW5jdGlvbiAoZSwgaWQpIHtcblx0ICAgIHRoaXMuX3RyZWVfY2hlY2tfdW5jaGVjayhpZCwgbnVsbCwgZSk7XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH07XG5cblx0dmFyIFRyZWVEYXRhTG9hZGVyID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKHRoaXMuX3N5bmNfaGllcmFyY2h5LCB0aGlzKSwgbnVsbCwgdHJ1ZSk7IC8vcmVkZWZpbmUgbWV0aG9kc1xuXG5cdCAgICB0aGlzLl9mZWVkX2NvbW1vbiA9IHRoaXMuX2ZlZWRfY29tbW9uQTtcblx0ICB9LFxuXHQgIF9mZWVkX2NvbW1vbkE6IGZ1bmN0aW9uIChpZCwgY291bnQsIGNhbGxiYWNrLCB1cmwpIHtcblx0ICAgIC8vIGJyYW5jaCBsb2FkaW5nXG5cdCAgICB2YXIgZGV0YWlscyA9IGNvdW50ID09PSAwID8ge1xuXHQgICAgICBwYXJlbnQ6IGVuY29kZVVSSUNvbXBvbmVudChpZClcblx0ICAgIH0gOiBudWxsO1xuXG5cdCAgICBEYXRhTG9hZGVyLnByb3RvdHlwZS5fZmVlZF9jb21tb24uY2FsbCh0aGlzLCBpZCwgY291bnQsIGNhbGxiYWNrLCB1cmwsIGRldGFpbHMpO1xuXHQgIH0sXG5cdCAgLy9sb2FkIG5leHQgc2V0IG9mIGRhdGEgcm93c1xuXHQgIGxvYWRCcmFuY2g6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2ssIHVybCkge1xuXHQgICAgaWQgPSBpZCB8fCAwO1xuXHQgICAgdGhpcy5kYXRhLnVybCA9IHVybCB8fCB0aGlzLmRhdGEudXJsO1xuXHQgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25EYXRhUmVxdWVzdFwiLCBbaWQsIGNhbGxiYWNrLCB0aGlzLmRhdGEudXJsXSkgJiYgdGhpcy5kYXRhLnVybCkgdGhpcy5kYXRhLmZlZWQuY2FsbCh0aGlzLCBpZCwgMCwgY2FsbGJhY2ssIHVybCk7XG5cdCAgfSxcblx0ICBfc3luY19oaWVyYXJjaHk6IGZ1bmN0aW9uIChpZCwgZGF0YSwgbW9kZSkge1xuXHQgICAgaWYgKCFtb2RlIHx8IG1vZGUgPT0gXCJhZGRcIiB8fCBtb2RlID09IFwiZGVsZXRlXCIgfHwgbW9kZSA9PSBcImJyYW5jaFwiKSB7XG5cdCAgICAgIHRoaXMuZGF0YS5fc3luY190b19vcmRlcih0aGlzKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0Lypcblx0XHRCZWhhdmlvcjpEYXRhTW92ZSAtIGFsbG93cyB0byBtb3ZlIGFuZCBjb3B5IGVsZW1lbnRzLCBoZWF2aWx5IHJlbGF5cyBvbiBEYXRhU3RvcmUubW92ZVxuXHRcdEBleHBvcnRcblx0XHRcdGNvcHlcblx0XHRcdG1vdmVcblx0Ki9cblxuXHR2YXIgVHJlZURhdGFNb3ZlID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5kYXRhLCBcIkRhdGFNb3ZlIDo6IENvbXBvbmVudCBkb2Vzbid0IGhhdmUgRGF0YVN0b3JlXCIpO1xuXHQgIH0sXG5cdCAgLy9jcmVhdGVzIGEgY29weSBvZiB0aGUgaXRlbVxuXHQgIGNvcHk6IGZ1bmN0aW9uIChzaWQsIHRpbmRleCwgdG9iaiwgZGV0YWlscykge1xuXHQgICAgZGV0YWlscyA9IGRldGFpbHMgfHwge307XG5cdCAgICBkZXRhaWxzLmNvcHkgPSB0cnVlO1xuXHQgICAgcmV0dXJuIHRoaXMubW92ZShzaWQsIHRpbmRleCwgdG9iaiwgZGV0YWlscyk7XG5cdCAgfSxcblx0ICBfbmV4dF9tb3ZlX2luZGV4OiBmdW5jdGlvbiAobmlkLCBuZXh0LCBzb3VyY2UpIHtcblx0ICAgIGlmIChuZXh0ICYmIG5pZCkge1xuXHQgICAgICB2YXIgbmV3X2luZGV4ID0gdGhpcy5nZXRCcmFuY2hJbmRleChuaWQpO1xuXHQgICAgICByZXR1cm4gbmV3X2luZGV4ICsgKHNvdXJjZSA9PSB0aGlzICYmIHNvdXJjZS5nZXRCcmFuY2hJbmRleChuZXh0KSA8IG5ld19pbmRleCA/IDAgOiAxKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jaGVja19icmFuY2hfY2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICB2YXIgdCA9IHRoaXMuZGF0YS5icmFuY2hbcGFyZW50XTtcblxuXHQgICAgaWYgKHQgJiYgdC5sZW5ndGgpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHRbaV0gPT0gY2hpbGQpIHJldHVybiB0cnVlO1xuXHQgICAgICAgIGlmICh0aGlzLl9jaGVja19icmFuY2hfY2hpbGQodFtpXSwgY2hpbGQpKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICAvL21vdmUgaXRlbSB0byB0aGUgbmV3IHBvc2l0aW9uXG5cdCAgbW92ZTogZnVuY3Rpb24gKHNpZCwgdGluZGV4LCB0b2JqLCBkZXRhaWxzKSB7XG5cdCAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTtcblx0ICAgIHRpbmRleCA9IHRpbmRleCB8fCAwO1xuXHQgICAgdmFyIG5ld19pZCA9IGRldGFpbHMubmV3SWQgfHwgc2lkO1xuXHQgICAgdmFyIHRhcmdldF9wYXJlbnQgPSBkZXRhaWxzLnBhcmVudCB8fCAwO1xuXHQgICAgdG9iaiA9IHRvYmogfHwgdGhpcztcblx0ICAgIGFzc2VydCh0b2JqLmRhdGEsIFwibW92aW5nIGF0dGVtcHQgdG8gY29tcG9uZW50IHdpdGhvdXQgZGF0YXN0b3JlXCIpO1xuXHQgICAgaWYgKCF0b2JqLmRhdGEpIHJldHVybjtcblxuXHQgICAgaWYgKGlzQXJyYXkoc2lkKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIC8vaW5jcmVhc2UgaW5kZXggZm9yIGVhY2ggbmV4dCBpdGVtIGluIHRoZSBzZXQsIHNvIG9yZGVyIG9mIGluc2VydGlvbiB3aWxsIGJlIGVxdWFsIHRvIG9yZGVyIGluIHRoZSBhcnJheVxuXHQgICAgICAgIHZhciBuaWQgPSB0aGlzLm1vdmUoc2lkW2ldLCB0aW5kZXgsIHRvYmosIGRldGFpbHMpO1xuXHQgICAgICAgIHRpbmRleCA9IHRvYmouX25leHRfbW92ZV9pbmRleChuaWQsIHNpZFtpICsgMV0sIHRoaXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcyAhPSB0b2JqIHx8IGRldGFpbHMuY29weSkge1xuXHQgICAgICBuZXdfaWQgPSB0b2JqLmRhdGEuYWRkKHRvYmouX2V4dGVybmFsRGF0YSh0aGlzLmdldEl0ZW0oc2lkKSwgbmV3X2lkKSwgdGluZGV4LCB0YXJnZXRfcGFyZW50IHx8IDApO1xuXG5cdCAgICAgIGlmICh0aGlzLmRhdGEuYnJhbmNoW3NpZF0gJiYgdG9iai5nZXRCcmFuY2hJbmRleCkge1xuXHQgICAgICAgIHZhciB0ZW1wID0gdGhpcy5kYXRhLl9zY2hlbWVfc2VyaWFsaXplO1xuXG5cdCAgICAgICAgdGhpcy5kYXRhLl9zY2hlbWVfc2VyaWFsaXplID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgdmFyIGNvcHkkJDEgPSBjb3B5KG9iaik7XG5cdCAgICAgICAgICBkZWxldGUgY29weSQkMS4kcGFyZW50O1xuXHQgICAgICAgICAgZGVsZXRlIGNvcHkkJDEuJGxldmVsO1xuXHQgICAgICAgICAgZGVsZXRlIGNvcHkkJDEuJGNoaWxkO1xuXHQgICAgICAgICAgaWYgKHRvYmouZGF0YS5wdWxsW2NvcHkkJDEuaWRdKSBjb3B5JCQxLmlkID0gdWlkKCk7XG5cdCAgICAgICAgICByZXR1cm4gY29weSQkMTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdmFyIGNvcHlfZGF0YSA9IHtcblx0ICAgICAgICAgIGRhdGE6IHRoaXMuc2VyaWFsaXplKHNpZCwgdHJ1ZSksXG5cdCAgICAgICAgICBwYXJlbnQ6IG5ld19pZFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5kYXRhLl9zY2hlbWVfc2VyaWFsaXplID0gdGVtcDtcblx0ICAgICAgICB0b2JqLnBhcnNlKGNvcHlfZGF0YSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWRldGFpbHMuY29weSkgdGhpcy5kYXRhLnJlbW92ZShzaWQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy9tb3ZlIGluIHNlbGZcblx0ICAgICAgaWYgKHNpZCA9PSB0YXJnZXRfcGFyZW50IHx8IHRoaXMuX2NoZWNrX2JyYW5jaF9jaGlsZChzaWQsIHRhcmdldF9wYXJlbnQpKSByZXR1cm47XG5cdCAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEl0ZW0oc2lkKTtcblx0ICAgICAgdmFyIHRicmFuY2ggPSB0aGlzLmRhdGEuYnJhbmNoW3RhcmdldF9wYXJlbnRdO1xuXHQgICAgICBpZiAoIXRicmFuY2gpIHRicmFuY2ggPSB0aGlzLmRhdGEuYnJhbmNoW3RhcmdldF9wYXJlbnRdID0gW107XG5cdCAgICAgIHZhciBzYnJhbmNoID0gdGhpcy5kYXRhLmJyYW5jaFtzb3VyY2UuJHBhcmVudF07XG5cdCAgICAgIHZhciBzaW5kZXggPSBQb3dlckFycmF5LmZpbmQuY2FsbChzYnJhbmNoLCBzaWQpO1xuXHQgICAgICBpZiAodGluZGV4IDwgMCkgdGluZGV4ID0gdGJyYW5jaC5sZW5ndGg7IC8vaW4gdGhlIHNhbWUgYnJhbmNoXG5cblx0ICAgICAgaWYgKHNicmFuY2ggPT09IHRicmFuY2ggJiYgdGluZGV4ID09PSBzaW5kZXgpIHJldHVybjsgLy9zYW1lIHBvc2l0aW9uXG5cblx0ICAgICAgUG93ZXJBcnJheS5yZW1vdmVBdC5jYWxsKHNicmFuY2gsIHNpbmRleCk7XG5cdCAgICAgIFBvd2VyQXJyYXkuaW5zZXJ0QXQuY2FsbCh0YnJhbmNoLCBzaWQsIE1hdGgubWluKHRicmFuY2gubGVuZ3RoLCB0aW5kZXgpKTtcblx0ICAgICAgaWYgKCFzYnJhbmNoLmxlbmd0aCkgZGVsZXRlIHRoaXMuZGF0YS5icmFuY2hbc291cmNlLiRwYXJlbnRdO1xuXHQgICAgICBpZiAoc291cmNlLiRwYXJlbnQgJiYgc291cmNlLiRwYXJlbnQgIT0gXCIwXCIpIHRoaXMuZ2V0SXRlbShzb3VyY2UuJHBhcmVudCkuJGNvdW50LS07XG5cblx0ICAgICAgaWYgKHRhcmdldF9wYXJlbnQgJiYgdGFyZ2V0X3BhcmVudCAhPSBcIjBcIikge1xuXHQgICAgICAgIHZhciB0YXJnZXQgPSB0b2JqLmdldEl0ZW0odGFyZ2V0X3BhcmVudCk7XG5cdCAgICAgICAgdGFyZ2V0LiRjb3VudCsrO1xuXG5cdCAgICAgICAgdGhpcy5fc2V0X2xldmVsX3JlYyhzb3VyY2UsIHRhcmdldC4kbGV2ZWwgKyAxKTtcblx0ICAgICAgfSBlbHNlIHRoaXMuX3NldF9sZXZlbF9yZWMoc291cmNlLCAxKTtcblxuXHQgICAgICBzb3VyY2UuJHBhcmVudCA9IHRhcmdldF9wYXJlbnQ7XG5cdCAgICAgIHRvYmouZGF0YS5jYWxsRXZlbnQoXCJvbkRhdGFNb3ZlXCIsIFtzaWQsIHRpbmRleCwgdGFyZ2V0X3BhcmVudCwgdGJyYW5jaFt0aW5kZXggKyAxXV0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgIHJldHVybiBuZXdfaWQ7IC8vcmV0dXJuIElEIG9mIGl0ZW0gYWZ0ZXIgbW92aW5nXG5cdCAgfSxcblx0ICBfc2V0X2xldmVsX3JlYzogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG5cdCAgICBpdGVtLiRsZXZlbCA9IHZhbHVlO1xuXHQgICAgdmFyIGJyYW5jaCA9IHRoaXMuZGF0YS5icmFuY2hbaXRlbS5pZF07XG5cdCAgICBpZiAoYnJhbmNoKSBmb3IgKHZhciBpID0gMDsgaSA8IGJyYW5jaC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9zZXRfbGV2ZWxfcmVjKHRoaXMuZ2V0SXRlbShicmFuY2hbaV0pLCB2YWx1ZSArIDEpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9yZWFjdGlvbiBvbiBwYXVzZSBkdXJpbmcgZG5kXG5cdCAgX2RyYWdfcGF1c2U6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKGlkICYmICFpZC5oZWFkZXIgJiYgdGhpcy5leGlzdHMoaWQpICYmIHRoaXMuX3RhcmdldF90b19pZChpZCkgIT0gRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dC5zdGFydCkgLy9pZ25vcmUgZHJhZyBvdGhlciBoZWFkZXJcblx0ICAgICAgdGhpcy5vcGVuKGlkKTtcblx0ICB9LFxuXHQgICRkcm9wQWxsb3c6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICBpZiAoY29udGV4dC5mcm9tICE9IGNvbnRleHQudG8pIHJldHVybiB0cnVlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHQuc291cmNlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jaGVja19icmFuY2hfY2hpbGQoY29udGV4dC5zb3VyY2UsIGNvbnRleHQudGFyZ2V0KSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXG5cdCAgLypcblx0ICBcdHRoaXMgaXMgYSBzdHViIGZvciBmdXR1cmUgZnVuY3Rpb25hbGl0eVxuXHQgIFx0Y3VycmVudGx5IGl0IGp1c3QgbWFrZXMgYSBjb3B5IG9mIGRhdGEgb2JqZWN0LCB3aGljaCBpcyBlbm91Z2ggZm9yIGN1cnJlbnQgc2l0dWF0aW9uXG5cdCAgKi9cblx0ICBfZXh0ZXJuYWxEYXRhOiBmdW5jdGlvbiAoZGF0YSwgaWQpIHtcblx0ICAgIHZhciBuZXdfZGF0YSA9IERhdGFNb3ZlLl9leHRlcm5hbERhdGEuY2FsbCh0aGlzLCBkYXRhLCBpZCk7XG5cblx0ICAgIGRlbGV0ZSBuZXdfZGF0YS5vcGVuO1xuXHQgICAgcmV0dXJuIG5ld19kYXRhO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgVHJlZVJlbmRlclN0YWNrID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZW5kZXIsIFwiVHJlZVJlbmRlclN0YWNrIDo6IE9iamVjdCBtdXN0IHVzZSBSZW5kZXJTdGFjayBmaXJzdFwiKTtcblx0ICB9LFxuXHQgIF90b0hUTUxJdGVtOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgbWFyayA9IHRoaXMuZGF0YS5fbWFya3Nbb2JqLmlkXTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25JdGVtUmVuZGVyXCIsIFtvYmpdKTtcblx0ICAgIHJldHVybiB0aGlzLnR5cGUudGVtcGxhdGVTdGFydChvYmosIHRoaXMudHlwZSwgbWFyaykgKyAob2JqLiR0ZW1wbGF0ZSA/IHRoaXMudHlwZVtcInRlbXBsYXRlXCIgKyBvYmouJHRlbXBsYXRlXShvYmosIHRoaXMudHlwZSwgbWFyaykgOiB0aGlzLnR5cGUudGVtcGxhdGUob2JqLCB0aGlzLnR5cGUsIG1hcmspKSArIHRoaXMudHlwZS50ZW1wbGF0ZUVuZCgpO1xuXHQgIH0sXG5cdCAgX3RvSFRNTEl0ZW1PYmplY3Q6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHRoaXMuX2h0bWwuaW5uZXJIVE1MID0gdGhpcy5fdG9IVE1MSXRlbShvYmopO1xuXHQgICAgcmV0dXJuIHRoaXMuX2h0bWwuZmlyc3RDaGlsZDtcblx0ICB9LFxuXHQgIC8vY29udmVydCBzaW5nbGUgaXRlbSB0byBIVE1MIHRleHQgKHRlbXBsYXRpbmcpXG5cdCAgX3RvSFRNTDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgLy9jaGVjayBpZiByZWxhdGVkIHRlbXBsYXRlIGV4aXN0XG5cdCAgICBhc3NlcnQoIW9iai4kdGVtcGxhdGUgfHwgdGhpcy50eXBlW1widGVtcGxhdGVcIiArIG9iai4kdGVtcGxhdGVdLCBcIlJlbmRlclN0YWNrIDo6IFVua25vd24gdGVtcGxhdGU6IFwiICsgb2JqLiR0ZW1wbGF0ZSk7XG5cblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IHJvbGU9J3ByZXNlbnRhdGlvbicgY2xhc3M9J3dlYml4X3RyZWVfYnJhbmNoX1wiICsgb2JqLiRsZXZlbCArIFwiJz5cIiArIHRoaXMuX3RvSFRNTEl0ZW0ob2JqKTtcblxuXHQgICAgaWYgKG9iai5vcGVuKSBodG1sICs9IHRoaXMuX3RvSFRNTExldmVsKG9iai5pZCk7XG5cdCAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgIF90b0hUTUxMZXZlbDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgaHRtbCA9IFwiXCI7XG5cdCAgICB2YXIgbGVhdmVzID0gdGhpcy5kYXRhLmJyYW5jaFtpZF07XG5cblx0ICAgIGlmIChsZWF2ZXMpIHtcblx0ICAgICAgaHRtbCArPSBcIjxkaXYgcm9sZT0ncHJlc2VudGF0aW9uJyBjbGFzcz0nd2ViaXhfdHJlZV9sZWF2ZXMnPlwiO1xuXHQgICAgICB2YXIgbGFzdCA9IGxlYXZlcy5sZW5ndGggLSAxO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxhc3Q7IGkrKykge1xuXHQgICAgICAgIHZhciBvYmogPSB0aGlzLmdldEl0ZW0obGVhdmVzW2ldKTtcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnR5cGUuX3RyZWVfYnJhbmNoX3JlbmRlcl9zdGF0ZTtcblx0ICAgICAgICBpZiAoc3RhdGUgIT09IDApIHN0YXRlW29iai4kbGV2ZWxdID0gaSA9PSBsYXN0O1xuXHQgICAgICAgIGh0bWwgKz0gdGhpcy5fdG9IVE1MKG9iaik7XG5cdCAgICAgIH1cblxuXHQgICAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBodG1sO1xuXHQgIH0sXG5cdCAgLy9yZXR1cm4gdHJ1ZSB3aGVuIHNvbWUgYWN0dWFsIHJlbmRlcmluZyBkb25lXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoaWQsIGRhdGEsIHR5cGUpIHtcblx0ICAgIFRyZWVSZW5kZXJTdGFjay5fb2JqID0gdGhpczsgLy9jYW4gYmUgdXNlZCBmcm9tIGNvbXBsZXggcmVuZGVyXG5cblx0ICAgIGlmICghdGhpcy5pc1Zpc2libGUodGhpcy5fc2V0dGluZ3MuaWQpIHx8IHRoaXMuJGJsb2NrUmVuZGVyKSByZXR1cm47XG5cblx0ICAgIGlmIChpZCkge1xuXHQgICAgICB2YXIgY29udCwgbm9kZTtcblx0ICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuXG5cdCAgICAgIGlmICh0eXBlICE9IFwiYWRkXCIpIHtcblx0ICAgICAgICBjb250ID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7XG5cdCAgICAgICAgaWYgKCFjb250KSByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICBjYXNlIFwiYnJhbmNoXCI6XG5cdCAgICAgICAgICB2YXIgYnJhbmNoID0gY29udC5wYXJlbnROb2RlO1xuXHQgICAgICAgICAgbm9kZSA9IHRoaXMuX3RvSFRNTE9iamVjdChpdGVtKTtcblx0ICAgICAgICAgIGluc2VydEJlZm9yZShub2RlLCBicmFuY2gpO1xuXHQgICAgICAgICAgcmVtb3ZlKGJyYW5jaCk7XG5cdCAgICAgICAgICB0aGlzLl9odG1sbWFwID0gbnVsbDtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBcInBhaW50XCI6XG5cdCAgICAgICAgY2FzZSBcInVwZGF0ZVwiOlxuXHQgICAgICAgICAgbm9kZSA9IHRoaXMuX2h0bWxtYXBbaWRdID0gdGhpcy5fdG9IVE1MSXRlbU9iamVjdChpdGVtKTtcblx0ICAgICAgICAgIGluc2VydEJlZm9yZShub2RlLCBjb250KTtcblx0ICAgICAgICAgIHJlbW92ZShjb250KTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuXHQgICAgICAgICAgLy9kZWxldGluZyBub3QgaXRlbSAsIGJ1dCBmdWxsIGJyYW5jaFxuXHQgICAgICAgICAgcmVtb3ZlKGNvbnQucGFyZW50Tm9kZSk7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCJhZGRcIjpcblx0ICAgICAgICAgIHZhciBwYXJlbnQ7IC8vd2Ugd2FudCBwcm9jZXNzIGJvdGggZW1wdHkgdmFsdWUgYW5kIDAgYXMgc3RyaW5nXG5cdCAgICAgICAgICAvL2pzaGludCAtVzA0MTp0cnVlXG5cblx0ICAgICAgICAgIGlmIChpdGVtLiRwYXJlbnQgPT0gMCkge1xuXHQgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9kYXRhb2JqLmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0SXRlbShpdGVtLiRwYXJlbnQpLm9wZW4pIHtcblx0ICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5nZXRJdGVtTm9kZShpdGVtLiRwYXJlbnQpO1xuXG5cdCAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgICAgICAgICAvL3doZW4gaXRlbSBjcmVhdGVkIGJ5IHRoZSBzY3JpcHQsIGl0IHdpbGwgbWlzcyB0aGUgY29udGFpbmVyIGZvciBjaGlsZCBub3Rlc1xuXHQgICAgICAgICAgICAgIC8vY3JlYXRlIGl0IG9uIGRlbWFuZFxuXHQgICAgICAgICAgICAgIGlmICghcGFyZW50Lm5leHRTaWJsaW5nKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGVhZnMgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwid2ViaXhfdHJlZV9sZWF2ZXNcIlxuXHQgICAgICAgICAgICAgICAgfSwgXCJcIik7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChsZWFmcyk7XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmRhdGEuZ2V0TmV4dFNpYmxpbmdJZChpZCk7XG5cdCAgICAgICAgICAgIG5leHQgPSB0aGlzLmdldEl0ZW1Ob2RlKG5leHQpO1xuXHQgICAgICAgICAgICBpZiAobmV4dCkgbmV4dCA9IG5leHQucGFyZW50Tm9kZTtcblx0ICAgICAgICAgICAgbm9kZSA9IHRoaXMuX3RvSFRNTE9iamVjdChpdGVtKTtcblx0ICAgICAgICAgICAgdGhpcy5faHRtbG1hcFtpZF0gPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgICAgIGluc2VydEJlZm9yZShub2RlLCBuZXh0LCBwYXJlbnQpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uUGFydGlhbFJlbmRlclwiLCBbaWQsIGRhdGEsIHR5cGVdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vZnVsbCByZXNldFxuXHQgICAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGhpcy5kYXRhXSkpIHtcblx0ICAgICAgICAvL3dpbGwgYmUgdXNlZCBmb3IgbGluZXMgbWFuYWdlbWVudFxuXHQgICAgICAgIHRoaXMudHlwZS5fdHJlZV9icmFuY2hfcmVuZGVyX3N0YXRlID0gW107IC8vZ2V0VG9wUmFuZ2UgLSByZXR1cm5zIGFsbCBlbGVtZW50cyBvbiB0b3AgbGV2ZWxcblxuXHQgICAgICAgIHRoaXMuX2RhdGFvYmouaW5uZXJIVE1MID0gdGhpcy5fdG9IVE1MTGV2ZWwoMCk7XG5cdCAgICAgICAgdGhpcy5faHRtbG1hcCA9IG51bGw7IC8vY2xlYXIgbWFwLCBpdCB3aWxsIGJlIGZpbGxlZCBhdCBmaXJzdCBnZXRJdGVtTm9kZVxuXG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFtdKTtcblx0ICAgICAgfVxuXHQgICAgfSAvL2NsZWFyIGFmdGVyIHVzYWdlXG5cblxuXHQgICAgdGhpcy50eXBlLl90cmVlX2JyYW5jaF9yZW5kZXJfc3RhdGUgPSAwO1xuXHQgICAgVHJlZVJlbmRlclN0YWNrLl9vYmogPSBudWxsO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBnZXRJdGVtTm9kZTogZnVuY3Rpb24gKHNlYXJjaF9pZCkge1xuXHQgICAgaWYgKHRoaXMuX2h0bWxtYXApIHJldHVybiB0aGlzLl9odG1sbWFwW3NlYXJjaF9pZF07IC8vZmlsbCBtYXAgaWYgaXQgZG9lc24ndCBjcmVhdGVkIHlldFxuXG5cdCAgICB0aGlzLl9odG1sbWFwID0ge307XG5cblx0ICAgIHZhciB0ID0gdGhpcy5fZGF0YW9iai5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkRJVlwiKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpZCA9IHRbaV0uZ2V0QXR0cmlidXRlKHRoaXMuX2lkKTsgLy9nZXQgaXRlbSdzXG5cblx0ICAgICAgaWYgKGlkKSB0aGlzLl9odG1sbWFwW2lkXSA9IHRbaV07XG5cdCAgICB9IC8vY2FsbCBsb2NhdG9yIGFnYWluLCB3aGVuIG1hcCBpcyBmaWxsZWRcblxuXG5cdCAgICByZXR1cm4gdGhpcy5nZXRJdGVtTm9kZShzZWFyY2hfaWQpO1xuXHQgIH0sXG5cdCAgX2JyYW5jaF9yZW5kZXJfc3VwcG9ydGVkOiAxXG5cdH07XG5cblx0dmFyIFRyZWVTdGF0ZUNoZWNrYm94ID0ge1xuXHQgIF9pbml0X3JlbmRlcl90cmVlX3N0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fYnJhbmNoX3JlbmRlcl9zdXBwb3J0ZWQpIHtcblx0ICAgICAgdmFyIG9sZF9yZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuXHQgICAgICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChpZCwgZGF0YSkge1xuXHQgICAgICAgIHZhciB1cGRhdGVkID0gb2xkX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50aHJlZVN0YXRlICYmIHVwZGF0ZWQgJiYgZGF0YSAhPSBcImNoZWNrYm94XCIpIHRoaXMuX3NldFRoaXJkU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgfTtcblxuXHQgICAgICB0aGlzLl9pbml0X3JlbmRlcl90cmVlX3N0YXRlID0gZnVuY3Rpb24gKCkge307XG5cdCAgICB9XG5cdCAgfSxcblx0ICB0aHJlZVN0YXRlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuX2luaXRfcmVuZGVyX3RyZWVfc3RhdGUoKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9zZXRUaGlyZFN0YXRlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBpLCBsZWF2ZXMsIHBhcmVudHMsIGNoZWNrZWRQYXJlbnRzLCB0cmVlO1xuXHQgICAgcGFyZW50cyA9IFtdO1xuXHQgICAgdHJlZSA9IHRoaXM7XG5cdCAgICAvKmlmIGl0ZW0gd2FzIHJlbW92ZWQqL1xuXG5cdCAgICBpZiAoaWQgJiYgIXRyZWUuZGF0YS5wdWxsW2lkXSkge1xuXHQgICAgICBpZCA9IDA7XG5cdCAgICB9XG5cdCAgICAvKnNldHMgY2hlY2tib3ggc3RhdGVzKi9cblxuXHQgICAgLyppZiBicmFuY2ggb3IgZnVsbCByZWxvYWRpbmcqL1xuXG5cblx0ICAgIGlmICghaWQgfHwgdHJlZS5kYXRhLnB1bGxbaWRdLiRjb3VudCkge1xuXHQgICAgICBsZWF2ZXMgPSB0aGlzLl9nZXRBbGxMZWF2ZXMoaWQpO1xuXHQgICAgICBsZWF2ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiB0cmVlLmRhdGEucHVsbFtiXS4kbGV2ZWwgLSB0cmVlLmRhdGEucHVsbFthXS4kbGV2ZWw7XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoIWkgfHwgdHJlZS5kYXRhLnB1bGxbbGVhdmVzW2ldXS4kcGFyZW50ICE9IHRyZWUuZGF0YS5wdWxsW2xlYXZlc1tpIC0gMV1dLiRwYXJlbnQpIHBhcmVudHMgPSBwYXJlbnRzLmNvbmNhdCh0cmVlLl9zZXRQYXJlbnRUaGlyZFN0YXRlKGxlYXZlc1tpXSkpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvKmFuIGl0ZW0gaXMgYSBsZWFmICovXG5cdCAgICAgIHBhcmVudHMgPSBwYXJlbnRzLmNvbmNhdCh0cmVlLl9zZXRQYXJlbnRUaGlyZFN0YXRlKGlkKSk7XG5cdCAgICB9XG5cblx0ICAgIGNoZWNrZWRQYXJlbnRzID0ge307XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICghY2hlY2tlZFBhcmVudHNbcGFyZW50c1tpXV0pIHtcblx0ICAgICAgICBjaGVja2VkUGFyZW50c1twYXJlbnRzW2ldXSA9IDE7XG5cblx0ICAgICAgICB0aGlzLl9zZXRDaGVja2JveEluZGV0ZXJtaW5hdGUocGFyZW50c1tpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdHJlZSA9IG51bGw7XG5cdCAgfSxcblx0ICBfc2V0Q2hlY2tib3hJbmRldGVybWluYXRlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBjaEVsZW0sIGVsZW07XG5cdCAgICBlbGVtID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7XG5cblx0ICAgIGlmIChlbGVtKSB7XG5cdCAgICAgIHRoaXMucmVuZGVyKGlkLCBcImNoZWNrYm94XCIsIFwidXBkYXRlXCIpO1xuXHQgICAgICAvKm5lZWRlZCB0byBnZXQgdGhlIG5ldyBpbnB1dCBvYmogYW5kIHRvIHNldCBpbmRldGVybWluYXRlIHN0YXRlKi9cblxuXHQgICAgICBpZiAodGhpcy5nZXRJdGVtKGlkKS5pbmRldGVybWluYXRlKSB7XG5cdCAgICAgICAgZWxlbSA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXHQgICAgICAgIGNoRWxlbSA9IGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcblx0ICAgICAgICBpZiAoY2hFbGVtKSBjaEVsZW0uaW5kZXRlcm1pbmF0ZSA9IHRoaXMuZ2V0SXRlbShpZCkuaW5kZXRlcm1pbmF0ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NldFBhcmVudFRoaXJkU3RhdGU6IGZ1bmN0aW9uIChpdGVtSWQpIHtcblx0ICAgIC8vd2UgbmVlZCB0byB1c2UgZHluYW1pYyBmdW5jdGlvbiBjcmVhdGluZ1xuXHQgICAgLy9qc2hpbnQgLVcwODM6dHJ1ZVxuXHQgICAgdmFyIGNoZWNrZWQsIGNoZWNrZWRDb3VudCwgaW5kZXRlcm1pbmF0ZSwgcGFyZW50SWQsIHJlc3VsdCwgdW5zdXJlQ291bnQsIG5lZWRyZW5kZXI7XG5cdCAgICBwYXJlbnRJZCA9IHRoaXMuZ2V0UGFyZW50SWQoaXRlbUlkKTtcblx0ICAgIHJlc3VsdCA9IFtdO1xuXG5cdCAgICB3aGlsZSAocGFyZW50SWQgJiYgcGFyZW50SWQgIT0gXCIwXCIpIHtcblx0ICAgICAgdW5zdXJlQ291bnQgPSAwO1xuXHQgICAgICBjaGVja2VkQ291bnQgPSAwO1xuXHQgICAgICB0aGlzLmRhdGEuZWFjaENoaWxkKHBhcmVudElkLCBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgaWYgKG9iai5pbmRldGVybWluYXRlKSB7XG5cdCAgICAgICAgICB1bnN1cmVDb3VudCsrO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob2JqLmNoZWNrZWQpIHtcblx0ICAgICAgICAgIGNoZWNrZWRDb3VudCsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIGNoZWNrZWQgPSBpbmRldGVybWluYXRlID0gbmVlZHJlbmRlciA9IGZhbHNlO1xuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShwYXJlbnRJZCk7XG5cblx0ICAgICAgaWYgKGNoZWNrZWRDb3VudCA9PSBpdGVtLiRjb3VudCkge1xuXHQgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKGNoZWNrZWRDb3VudCA+IDAgfHwgdW5zdXJlQ291bnQgPiAwKSB7XG5cdCAgICAgICAgaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG5cdCAgICAgIH0gLy93ZSBuZWVkIHRvIHJlc2V0IGluZGV0ZXJtaW5hdGUgaW4gYW55IGNhc2UgOihcblxuXG5cdCAgICAgIGlmIChpbmRldGVybWluYXRlIHx8IGluZGV0ZXJtaW5hdGUgIT0gaXRlbS5pbmRldGVybWluYXRlKSBuZWVkcmVuZGVyID0gdHJ1ZTtcblx0ICAgICAgaXRlbS5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcblx0ICAgICAgaWYgKGNoZWNrZWQgfHwgaXRlbS5jaGVja2VkICE9IGNoZWNrZWQpIG5lZWRyZW5kZXIgPSB0cnVlO1xuXHQgICAgICBpdGVtLmNoZWNrZWQgPSBjaGVja2VkO1xuXG5cdCAgICAgIGlmIChuZWVkcmVuZGVyKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2gocGFyZW50SWQpO1xuXHQgICAgICAgIHBhcmVudElkID0gdGhpcy5nZXRQYXJlbnRJZChwYXJlbnRJZCk7XG5cdCAgICAgIH0gZWxzZSBwYXJlbnRJZCA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblxuXHQgIC8qZ2V0IGFsbCBjaGVja2VkIGl0ZW1zIGluIHRyZWUqL1xuXHQgIGdldENoZWNrZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHZhciB0cmVlID0gdGhpcztcblx0ICAgIHRoaXMuZGF0YS5lYWNoU3ViSXRlbSgwLCBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIGlmICh0cmVlLmlzQ2hlY2tlZChvYmouaWQpKSByZXN1bHQucHVzaChvYmouaWQpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0sXG5cdCAgX3RyZWVfY2hlY2tfdW5jaGVja18zOiBmdW5jdGlvbiAoaWQsIG1vZGUpIHtcblx0ICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcblxuXHQgICAgaWYgKGl0ZW0pIHtcblx0ICAgICAgaWYgKG1vZGUgPT09IFwiXCIpIG1vZGUgPSAhaXRlbS5jaGVja2VkO1xuXG5cdCAgICAgIGlmIChpdGVtLmNoZWNrZWQgIT0gbW9kZSB8fCBpdGVtLmluZGV0ZXJtaW5hdGUpIHtcblx0ICAgICAgICBpdGVtLmNoZWNrZWQgPSBtb2RlO1xuXG5cdCAgICAgICAgdGhpcy5fY29ycmVjdFRocmVlU3RhdGUoaWQpO1xuXG5cdCAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLl9zZXRQYXJlbnRUaGlyZFN0YXRlKGlkKTtcblxuXHQgICAgICAgIGlmICh0aGlzLl9icmFuY2hfcmVuZGVyX3N1cHBvcnRlZCAmJiBwYXJlbnRzLmxlbmd0aCA8IDUpIHtcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRDaGVja2JveEluZGV0ZXJtaW5hdGUocGFyZW50c1tpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHRoaXMucmVmcmVzaCgpO1xuXG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkl0ZW1DaGVja1wiLCBbaWQsIG1vZGVdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKnNldCBjaGVja2VkIHN0YXRlIGZvciBpdGVtIGNoZWNrYm94Ki9cblx0ICBjaGVja0l0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5fdHJlZV9jaGVja191bmNoZWNrKGlkLCB0cnVlKTtcblxuXHQgICAgdGhpcy51cGRhdGVJdGVtKGlkKTtcblx0ICB9LFxuXG5cdCAgLyp1bmNoZWNrZXMgYW4gaXRlbSBjaGVja2JveCovXG5cdCAgdW5jaGVja0l0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5fdHJlZV9jaGVja191bmNoZWNrKGlkLCBmYWxzZSk7XG5cblx0ICAgIHRoaXMudXBkYXRlSXRlbShpZCk7XG5cdCAgfSxcblx0ICBfY2hlY2tVbmNoZWNrQWxsOiBmdW5jdGlvbiAoaWQsIG1vZGUsIGFsbCkge1xuXHQgICAgdmFyIG1ldGhvZCA9IG1vZGUgPyBcImNoZWNrSXRlbVwiIDogXCJ1bmNoZWNrSXRlbVwiO1xuXHQgICAgaWYgKCFpZCkgaWQgPSAwO2Vsc2UgdGhpc1ttZXRob2RdKGlkKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRocmVlU3RhdGUpIHtcblx0ICAgICAgaWYgKCFpZCkgdGhpcy5kYXRhLmVhY2hDaGlsZCgwLCBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHRoaXNbbWV0aG9kXShpdGVtLmlkKTtcblx0ICAgICAgfSwgdGhpcywgYWxsKTtcblx0ICAgIH0gZWxzZSB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICB0aGlzW21ldGhvZF0oaXRlbS5pZCk7XG5cdCAgICB9LCB0aGlzLCBhbGwsIGlkKTtcblx0ICB9LFxuXG5cdCAgLypjaGVja2VzIGNoZWNrYm94ZXMgb2YgYWxsIGl0ZW1zIGluIGEgYnJhbmNoL3RyZWUqL1xuXHQgIGNoZWNrQWxsOiBmdW5jdGlvbiAoaWQsIGFsbCkge1xuXHQgICAgdGhpcy5fY2hlY2tVbmNoZWNrQWxsKGlkLCB0cnVlLCBhbGwpO1xuXHQgIH0sXG5cblx0ICAvKnVuY2hlY2tlcyBjaGVja2JveGVzIG9mIGFsbCBpdGVtcyBpbiBhIGJyYW5jaC90cmVlKi9cblx0ICB1bmNoZWNrQWxsOiBmdW5jdGlvbiAoaWQsIGFsbCkge1xuXHQgICAgdGhpcy5fY2hlY2tVbmNoZWNrQWxsKGlkLCBmYWxzZSwgYWxsKTtcblx0ICB9LFxuXHQgIF9jb3JyZWN0VGhyZWVTdGF0ZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgc3RhdGU7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICBpdGVtLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblx0ICAgIHN0YXRlID0gaXRlbS5jaGVja2VkO1xuXHQgICAgdGhpcy5kYXRhLmVhY2hTdWJJdGVtKGlkLCBmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgY2hpbGQuaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXHQgICAgICBjaGlsZC5jaGVja2VkID0gc3RhdGU7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKHRoaXMuX2JyYW5jaF9yZW5kZXJfc3VwcG9ydGVkICYmIHRoaXMuaXNCcmFuY2hPcGVuKGl0ZW0uJHBhcmVudCkpIHtcblx0ICAgICAgLy9mb3IgdHJlZS1yZW5kZXIgb25seVxuXHQgICAgICB0aGlzLnJlbmRlcihpZCwgMCwgXCJicmFuY2hcIik7XG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIC8qcmV0dXJucyBjaGVja2VkIHN0YXRlIG9mIGl0ZW0gY2hlY2tib3gqL1xuXHQgIGlzQ2hlY2tlZDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRJdGVtKGlkKS5jaGVja2VkO1xuXHQgIH0sXG5cblx0ICAvKmdldHMgYWxsIGxlYXZlcyBpbiBhIGNlcnRhaW4gYnJhbmNoIChpbiB0aGUgd2hvbGUgdHJlZSBpZiBpZCBpcyBub3Qgc2V0KSovXG5cdCAgX2dldEFsbExlYXZlczogZnVuY3Rpb24gKHBhcmVudElkKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB0aGlzLmRhdGEuZWFjaFN1Ykl0ZW0ocGFyZW50SWQsIGZ1bmN0aW9uIChvYmosIGJyYW5jaCkge1xuXHQgICAgICBpZiAoIWJyYW5jaCkgcmVzdWx0LnB1c2gob2JqLmlkKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdH07XG5cblx0Ly8gI2luY2x1ZGUgY29yZS9iaW5kLmpzXG5cdC8vICNpbmNsdWRlIGNvcmUvdHJlZW1vdmUuanNcblxuXHR2YXIgVHJlZVN0b3JlID0ge1xuXHQgIG5hbWU6IFwiVHJlZVN0b3JlXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2ZpbHRlck1vZGUgPSB7XG5cdCAgICAgIC8vbGV2ZWw6MSxcblx0ICAgICAgc2hvd1N1Ykl0ZW1zOiB0cnVlXG5cdCAgICB9O1xuXHQgICAgdGhpcy5icmFuY2ggPSB7XG5cdCAgICAgIDA6IFtdXG5cdCAgICB9O1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uUGFyc2VcIiwgZnVuY3Rpb24gKGRyaXZlcikge1xuXHQgICAgICB0aGlzLl9zZXRfY2hpbGRfc2NoZW1lKGRyaXZlci5jaGlsZCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLl9maWx0ZXJfYnJhbmNoID0gbnVsbDtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICB9LFxuXHQgIGZpbHRlck1vZGVfc2V0dGVyOiBmdW5jdGlvbiAobW9kZSkge1xuXHQgICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKHRoaXMuX2ZpbHRlck1vZGUsIG1vZGUsIHRydWUpO1xuXHQgIH0sXG5cdCAgX2ZpbHRlcl9yZXNldDogZnVuY3Rpb24gKHByZXNlcnZlKSB7XG5cdCAgICAvL3JlbW92ZSBwcmV2aW91cyBmaWx0ZXJpbmcgLCBpZiBhbnlcblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfYnJhbmNoICYmICFwcmVzZXJ2ZSkge1xuXHQgICAgICB0aGlzLmJyYW5jaCA9IHRoaXMuX2ZpbHRlcl9icmFuY2g7XG5cdCAgICAgIHRoaXMub3JkZXIgPSB0b0FycmF5KGNvcHkodGhpcy5icmFuY2hbMF0pKTtcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5icmFuY2gpIHtcblx0ICAgICAgICBpZiAoa2V5ICE9IFwiMFwiKSAvL2V4Y2x1ZGUgMCAtIHZpcnR1YWwgcm9vdFxuXHQgICAgICAgICAgdGhpcy5nZXRJdGVtKGtleSkuJGNvdW50ID0gdGhpcy5icmFuY2hba2V5XS5sZW5ndGg7XG5cdCAgICAgIH1cblxuXHQgICAgICBkZWxldGUgdGhpcy5fZmlsdGVyX2JyYW5jaDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9maWx0ZXJfY29yZTogZnVuY3Rpb24gKGZpbHRlciwgdmFsdWUsIHByZXNlcnZlLCBmaWx0ZXJNb2RlKSB7XG5cdCAgICAvL2ZvciB0cmVlIHdlIGhhdmUgZmV3IGZpbHRlcmluZyBvcHRpb25zXG5cdCAgICAvLy0gZmlsdGVyIGxlYWZzIG9ubHlcblx0ICAgIC8vLSBmaWx0ZXIgZGF0YSBvbiBzcGVjaWZpYyBsZXZlbFxuXHQgICAgLy8tIGZpbHRlciBkYXRhIG9uIGFsbCBsZXZlbHNcblx0ICAgIC8vLSBpbiBhbGwgY2FzZXMgd2UgY2FuIHNob3cgb3IgaGlkZSBlbXB0eSBmb2xkZXJcblx0ICAgIC8vLSBpbiBhbGwgY2FzZXMgd2UgY2FuIHNob3cgb3IgaGlkZSBjaGlsZHMgZm9yIG1hdGNoZWQgaXRlbVxuXHQgICAgLy9zZXQgbmV3IG9yZGVyIG9mIGl0ZW1zLCBzdG9yZSBvcmlnaW5hbFxuXHQgICAgaWYgKCFwcmVzZXJ2ZSB8fCAhdGhpcy5fZmlsdGVyX2JyYW5jaCkge1xuXHQgICAgICB0aGlzLl9maWx0ZXJfYnJhbmNoID0gdGhpcy5icmFuY2g7XG5cdCAgICAgIHRoaXMuYnJhbmNoID0gY2xvbmUodGhpcy5icmFuY2gpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmJyYW5jaFswXSA9IHRoaXMuX2ZpbHRlcl9icmFuY2hfcmVjKGZpbHRlciwgdmFsdWUsIHRoaXMuYnJhbmNoWzBdLCAxLCBmaWx0ZXJNb2RlIHx8IHt9KTtcblx0ICB9LFxuXHQgIF9maWx0ZXJfYnJhbmNoX3JlYzogZnVuY3Rpb24gKGZpbHRlciwgdmFsdWUsIGJyYW5jaCwgbGV2ZWwsIGNvbmZpZykge1xuXHQgICAgLy9qc2hpbnQgLVcwNDFcblx0ICAgIHZhciBuZXdvcmRlciA9IFtdO1xuXHQgICAgdmFyIGFsbG93ID0gY29uZmlnLmxldmVsICYmIGNvbmZpZy5sZXZlbCAhPSBsZXZlbDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmFuY2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGlkID0gYnJhbmNoW2ldO1xuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICAgIHZhciBjaGlsZF9ydW4gPSBmYWxzZTtcblx0ICAgICAgdmFyIHN1YiA9IHRoaXMuYnJhbmNoW2lkXTtcblxuXHQgICAgICBpZiAoYWxsb3cpIHtcblx0ICAgICAgICBjaGlsZF9ydW4gPSB0cnVlO1xuXHQgICAgICB9IGVsc2UgaWYgKGZpbHRlcih0aGlzLmdldEl0ZW0oaWQpLCB2YWx1ZSkpIHtcblx0ICAgICAgICBuZXdvcmRlci5wdXNoKGlkKTsgLy8gb3BlbiBhbGwgcGFyZW50cyBvZiB0aGUgZm91bmQgaXRlbVxuXG5cdCAgICAgICAgaWYgKGNvbmZpZy5vcGVuUGFyZW50cyAhPT0gZmFsc2UpIHtcblx0ICAgICAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMuZ2V0UGFyZW50SWQoaWQpO1xuXG5cdCAgICAgICAgICB3aGlsZSAocGFyZW50SWQgJiYgcGFyZW50SWQgIT0gXCIwXCIpIHtcblx0ICAgICAgICAgICAgdGhpcy5nZXRJdGVtKHBhcmVudElkKS5vcGVuID0gMTtcblx0ICAgICAgICAgICAgcGFyZW50SWQgPSB0aGlzLmdldFBhcmVudElkKHBhcmVudElkKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IC8vaW4gY2FzZSBvZiBvZiBmaXhlZCBsZXZlbCBmaWx0ZXJpbmcgLSBkbyBub3QgY2hhbmdlIGNoaWxkLWl0ZW1zXG5cblxuXHQgICAgICAgIGlmIChjb25maWcubGV2ZWwgfHwgY29uZmlnLnNob3dTdWJJdGVtcykgY29udGludWU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy9maWx0ZXJpbmcgbGV2ZWwsIG5vdCBtYXRjaFxuXHQgICAgICAgIGNoaWxkX3J1biA9IHRydWU7XG5cdCAgICAgIH0gLy9pZiBcImZpbHRlciBieSBhbGwgbGV2ZWxzXCIgLSBmaWx0ZXIgY2hpbGRzXG5cblxuXHQgICAgICBpZiAoYWxsb3cgfHwgIWNvbmZpZy5sZXZlbCkge1xuXHQgICAgICAgIGlmIChzdWIpIHtcblx0ICAgICAgICAgIHZhciBuZXdzdWIgPSB0aGlzLmJyYW5jaFtpZF0gPSB0aGlzLl9maWx0ZXJfYnJhbmNoX3JlYyhmaWx0ZXIsIHZhbHVlLCBzdWIsIGxldmVsICsgMSwgY29uZmlnKTtcblxuXHQgICAgICAgICAgaXRlbS4kY291bnQgPSBuZXdzdWIubGVuZ3RoO1xuXHQgICAgICAgICAgaWYgKGNoaWxkX3J1biAmJiBuZXdzdWIubGVuZ3RoKSBuZXdvcmRlci5wdXNoKGlkKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ld29yZGVyO1xuXHQgIH0sXG5cdCAgY291bnQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLm9yZGVyLmxlbmd0aCkgcmV0dXJuIHRoaXMub3JkZXIubGVuZ3RoOyAvL3dlIG11c3QgcmV0dXJuIHNvbWUgbm9uLXplcm8gdmFsdWUsIG9yIGxvZ2ljIG9mIHNlbGVjdGlvbiB3aWxsIHRoaW5rIHRoYXQgd2UgaGF2ZSBub3QgZGF0YSBhdCBhbGxcblxuXHQgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgIHRoaXMuZWFjaE9wZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICBjb3VudCsrO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gY291bnQ7XG5cdCAgfSxcblx0ICBfY2hhbmdlX2JyYW5jaF9pZDogZnVuY3Rpb24gKGJyYW5jaGVzLCBwYXJlbnQsIG9sZCwgbmV3aWQpIHtcblx0ICAgIGlmIChicmFuY2hlc1tvbGRdKSB7XG5cdCAgICAgIHZhciBicmFuY2ggPSBicmFuY2hlc1tuZXdpZF0gPSBicmFuY2hlc1tvbGRdO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJhbmNoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy5nZXRJdGVtKGJyYW5jaFtpXSkuJHBhcmVudCA9IG5ld2lkO1xuXHQgICAgICB9XG5cblx0ICAgICAgZGVsZXRlIGJyYW5jaGVzW29sZF07XG5cdCAgICB9XG5cblx0ICAgIGlmIChicmFuY2hlc1twYXJlbnRdKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IFBvd2VyQXJyYXkuZmluZC5jYWxsKGJyYW5jaGVzW3BhcmVudF0sIG9sZCk7XG5cdCAgICAgIGlmIChpbmRleCA+PSAwKSBicmFuY2hlc1twYXJlbnRdW2luZGV4XSA9IG5ld2lkO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgY2hhbmdlSWQ6IGZ1bmN0aW9uIChvbGQsIG5ld2lkKSB7XG5cdCAgICBpZiAob2xkID09IG5ld2lkKSByZXR1cm47XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRJdGVtKG9sZCkuJHBhcmVudDtcblxuXHQgICAgdGhpcy5fY2hhbmdlX2JyYW5jaF9pZCh0aGlzLmJyYW5jaCwgcGFyZW50LCBvbGQsIG5ld2lkKTsgLy9pbiBjYXNlIG9mIGZpbHRlciBhcHBsaWVkLCB1cGRhdGUgaWQgaW4gZmlsdGVyZWQgc3RhdGUgYXMgd2VsbFxuXG5cblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfYnJhbmNoKSB0aGlzLl9jaGFuZ2VfYnJhbmNoX2lkKHRoaXMuX2ZpbHRlcl9icmFuY2gsIHBhcmVudCwgb2xkLCBuZXdpZCk7XG5cdCAgICByZXR1cm4gRGF0YVN0b3JlLnByb3RvdHlwZS5jaGFuZ2VJZC5jYWxsKHRoaXMsIG9sZCwgbmV3aWQpO1xuXHQgIH0sXG5cdCAgY2xlYXJBbGw6IGZ1bmN0aW9uIChzb2Z0KSB7XG5cdCAgICB0aGlzLmJyYW5jaCA9IHtcblx0ICAgICAgMDogW11cblx0ICAgIH07XG5cdCAgICBEYXRhU3RvcmUucHJvdG90eXBlLmNsZWFyQWxsLmNhbGwodGhpcywgc29mdCk7XG5cdCAgfSxcblx0ICBnZXRQcmV2U2libGluZ0lkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBvcmRlciA9IHRoaXMuYnJhbmNoW3RoaXMuZ2V0SXRlbShpZCkuJHBhcmVudF07XG5cdCAgICB2YXIgcG9zID0gUG93ZXJBcnJheS5maW5kLmNhbGwob3JkZXIsIGlkKSAtIDE7XG5cdCAgICBpZiAocG9zID49IDApIHJldHVybiBvcmRlcltwb3NdO1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICBnZXROZXh0U2libGluZ0lkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBvcmRlciA9IHRoaXMuYnJhbmNoW3RoaXMuZ2V0SXRlbShpZCkuJHBhcmVudF07XG5cdCAgICB2YXIgcG9zID0gUG93ZXJBcnJheS5maW5kLmNhbGwob3JkZXIsIGlkKSArIDE7XG5cdCAgICBpZiAocG9zIDwgb3JkZXIubGVuZ3RoKSByZXR1cm4gb3JkZXJbcG9zXTtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgZ2V0UGFyZW50SWQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShpZCkuJHBhcmVudDtcblx0ICB9LFxuXHQgIGdldEZpcnN0Q2hpbGRJZDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgb3JkZXIgPSB0aGlzLmJyYW5jaFtpZF07XG5cdCAgICBpZiAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSByZXR1cm4gb3JkZXJbMF07XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIGlzQnJhbmNoOiBmdW5jdGlvbiAocGFyZW50KSB7XG5cdCAgICByZXR1cm4gISF0aGlzLmJyYW5jaFtwYXJlbnRdO1xuXHQgIH0sXG5cdCAgZ2V0QnJhbmNoSW5kZXg6IGZ1bmN0aW9uIChjaGlsZCkge1xuXHQgICAgdmFyIHQgPSB0aGlzLmJyYW5jaFt0aGlzLnB1bGxbY2hpbGRdLiRwYXJlbnRdO1xuXHQgICAgcmV0dXJuIFBvd2VyQXJyYXkuZmluZC5jYWxsKHQsIGNoaWxkKTtcblx0ICB9LFxuXHQgIF9zZXRfY2hpbGRfc2NoZW1lOiBmdW5jdGlvbiAocGFyc2VfbmFtZSkge1xuXHQgICAgaWYgKHR5cGVvZiBwYXJzZV9uYW1lID09IFwic3RyaW5nXCIpIHRoaXMuX2RhdGFkcml2ZXJfY2hpbGQgPSBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB0ID0gb2JqW3BhcnNlX25hbWVdO1xuXHQgICAgICBpZiAodCkgZGVsZXRlIG9ialtwYXJzZV9uYW1lXTtcblx0ICAgICAgcmV0dXJuIHQ7XG5cdCAgICB9O2Vsc2UgdGhpcy5fZGF0YWRyaXZlcl9jaGlsZCA9IHBhcnNlX25hbWU7XG5cdCAgfSxcblx0ICBfaW5uZXJfcGFyc2U6IGZ1bmN0aW9uIChpbmZvLCByZWNzKSB7XG5cdCAgICB2YXIgcGFyZW50ID0gaW5mby5wYXJlbnQgfHwgMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vZ2V0IGhhc2ggb2YgZGV0YWlscyBmb3IgZWFjaCByZWNvcmRcblx0ICAgICAgdmFyIHRlbXAgPSB0aGlzLmRyaXZlci5nZXREZXRhaWxzKHJlY3NbaV0pO1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLmlkKHRlbXApOyAvL2dlbmVyYXRlIElEIGZvciB0aGUgcmVjb3JkXG5cblx0ICAgICAgdmFyIHVwZGF0ZSA9ICEhdGhpcy5wdWxsW2lkXTsgLy91cGRhdGUgbW9kZVxuXG5cdCAgICAgIGlmICh1cGRhdGUpIHtcblx0ICAgICAgICB0ZW1wID0gZXhwb3J0cy5leHRlbmQodGhpcy5wdWxsW2lkXSwgdGVtcCwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVtZV91cGRhdGUpIHRoaXMuX3NjaGVtZV91cGRhdGUodGVtcCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVtZV9pbml0KSB0aGlzLl9zY2hlbWVfaW5pdCh0ZW1wKTtcblx0ICAgICAgICB0aGlzLnB1bGxbaWRdID0gdGVtcDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2V4dHJhUGFyc2VyKHRlbXAsIHBhcmVudCwgMCwgdXBkYXRlLCBpbmZvLmZyb20gPyBpbmZvLmZyb20gKiAxICsgaSA6IDApO1xuXHQgICAgfSAvL2ZpeCBzdGF0ZSBvZiB0b3AgaXRlbSBhZnRlciBkYXRhIGxvYWRpbmdcblxuXG5cdCAgICB2YXIgcEl0ZW0gPSB0aGlzLnB1bGxbcGFyZW50XSB8fCB7fTtcblx0ICAgIHZhciBwQnJhbmNoID0gdGhpcy5icmFuY2hbcGFyZW50XSB8fCBbXTtcblx0ICAgIHBJdGVtLiRjb3VudCA9IHBCcmFuY2gubGVuZ3RoO1xuXHQgICAgZGVsZXRlIHBJdGVtLndlYml4X2tpZHM7XG5cdCAgICBpZiAoaW5mby5zaXplICYmIGluZm8uc2l6ZSAhPSBwQnJhbmNoLmxlbmd0aCkgcEJyYW5jaFtpbmZvLnNpemUgLSAxXSA9IHVuZGVmaW5lZDtcblx0ICB9LFxuXHQgIF9leHRyYVBhcnNlcjogZnVuY3Rpb24gKG9iaiwgcGFyZW50LCBsZXZlbCwgdXBkYXRlLCBmcm9tKSB7XG5cdCAgICAvL3Byb2Nlc3NpbmcgdG9wIGl0ZW1cblx0ICAgIG9iai4kY291bnQgPSAwOyAvL3VzaW5nIHNvZnQgY2hlY2ssIGFzIHBhcmVudCBjYW4gYmUgYSBib3RoIDAgYW5kIFwiMFwiICggc2Vjb25kIG9uZSBpbiBjYXNlIG9mIGxvYWRpbmcgZnJvbSBzZXJ2ZXIgc2lkZSApIFxuXG5cdCAgICBvYmouJHBhcmVudCA9IHBhcmVudCAhPSBcIjBcIiA/IHBhcmVudCA6IDA7XG5cdCAgICBvYmouJGxldmVsID0gbGV2ZWwgfHwgKHBhcmVudCAhPSBcIjBcIiA/IHRoaXMucHVsbFtwYXJlbnRdLiRsZXZlbCArIDEgOiAxKTtcblx0ICAgIHZhciBwYXJlbnRfYnJhbmNoID0gdGhpcy5icmFuY2hbb2JqLiRwYXJlbnRdO1xuXHQgICAgaWYgKCFwYXJlbnRfYnJhbmNoKSBwYXJlbnRfYnJhbmNoID0gdGhpcy5icmFuY2hbb2JqLiRwYXJlbnRdID0gW107XG5cdCAgICBpZiAodGhpcy5fZmlsdGVyX2JyYW5jaCkgdGhpcy5fZmlsdGVyX2JyYW5jaFtvYmouJHBhcmVudF0gPSBwYXJlbnRfYnJhbmNoO1xuXG5cdCAgICBpZiAoIXVwZGF0ZSkge1xuXHQgICAgICB2YXIgcG9zID0gZnJvbSB8fCBwYXJlbnRfYnJhbmNoLmxlbmd0aDtcblx0ICAgICAgcGFyZW50X2JyYW5jaFtwb3NdID0gb2JqLmlkO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2hpbGQgPSB0aGlzLl9kYXRhZHJpdmVyX2NoaWxkKG9iaik7XG5cblx0ICAgIGlmIChvYmoud2ViaXhfa2lkcykge1xuXHQgICAgICByZXR1cm4gb2JqLiRjb3VudCA9IC0xO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNoaWxkKSAvL2lnbm9yZSBjaGlsZGxlc3Ncblx0ICAgICAgcmV0dXJuIG9iai4kY291bnQgPSAwOyAvL3doZW4gbG9hZGluZyBmcm9tIHhtbCB3ZSBjYW4gaGF2ZSBhIHNpbmdsZSBpdGVtIGluc3RlYWQgb2YgYW4gYXJyYXlcblxuXHQgICAgaWYgKCFpc0FycmF5KGNoaWxkKSkgY2hpbGQgPSBbY2hpbGRdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vZXh0cmEgcHJvY2Vzc2luZyB0byBjb252ZXJ0IHN0cmluZ3MgdG8gb2JqZWN0c1xuXHQgICAgICB2YXIgaXRlbSA9IERhdGFEcml2ZXIuanNvbi5nZXREZXRhaWxzKGNoaWxkW2ldKTtcblx0ICAgICAgdmFyIGl0ZW1pZCA9IHRoaXMuaWQoaXRlbSk7XG5cdCAgICAgIHVwZGF0ZSA9ICEhdGhpcy5wdWxsW2l0ZW1pZF07XG5cblx0ICAgICAgaWYgKHVwZGF0ZSkge1xuXHQgICAgICAgIGl0ZW0gPSBleHBvcnRzLmV4dGVuZCh0aGlzLnB1bGxbaXRlbWlkXSwgaXRlbSwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVtZV91cGRhdGUpIHRoaXMuX3NjaGVtZV91cGRhdGUoaXRlbSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVtZV9pbml0KSB0aGlzLl9zY2hlbWVfaW5pdChpdGVtKTtcblx0ICAgICAgICB0aGlzLnB1bGxbaXRlbWlkXSA9IGl0ZW07XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9leHRyYVBhcnNlcihpdGVtLCBvYmouaWQsIG9iai4kbGV2ZWwgKyAxLCB1cGRhdGUpO1xuXHQgICAgfSAvL3Byb2Nlc3NpbmcgY2hpbGRyZW5zXG5cblxuXHQgICAgdmFyIGJyYW5jaCA9IHRoaXMuYnJhbmNoW29iai5pZF07XG5cdCAgICBpZiAoYnJhbmNoKSBvYmouJGNvdW50ID0gYnJhbmNoLmxlbmd0aDtcblx0ICB9LFxuXHQgIF9zeW5jX3RvX29yZGVyOiBmdW5jdGlvbiAobWFzdGVyKSB7XG5cdCAgICB0aGlzLm9yZGVyID0gdG9BcnJheSgpO1xuXG5cdCAgICB0aGlzLl9zeW5jX2VhY2hfY2hpbGQoMCwgbWFzdGVyKTtcblx0ICB9LFxuXHQgIF9zeW5jX2VhY2hfY2hpbGQ6IGZ1bmN0aW9uIChzdGFydCwgbWFzdGVyKSB7XG5cdCAgICB2YXIgYnJhbmNoID0gdGhpcy5icmFuY2hbc3RhcnRdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyYW5jaC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaWQgPSBicmFuY2hbaV07XG5cdCAgICAgIHRoaXMub3JkZXIucHVzaChpZCk7XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5wdWxsW2lkXTtcblxuXHQgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgIGlmIChpdGVtLm9wZW4pIHtcblx0ICAgICAgICAgIGlmIChpdGVtLiRjb3VudCA9PSAtMSkgbWFzdGVyLmxvYWRCcmFuY2goaWQpO2Vsc2UgaWYgKGl0ZW0uJGNvdW50KSB0aGlzLl9zeW5jX2VhY2hfY2hpbGQoaWQsIG1hc3Rlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBwcm92aWRlQXBpOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudGFibGUpIHtcblx0ICAgIHZhciBsaXN0ID0gW1wiZ2V0UHJldlNpYmxpbmdJZFwiLCBcImdldE5leHRTaWJsaW5nSWRcIiwgXCJnZXRQYXJlbnRJZFwiLCBcImdldEZpcnN0Q2hpbGRJZFwiLCBcImlzQnJhbmNoXCIsIFwiZ2V0QnJhbmNoSW5kZXhcIiwgXCJmaWx0ZXJNb2RlX3NldHRlclwiXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRhcmdldFtsaXN0W2ldXSA9IHRoaXMuX21ldGhvZFB1c2godGhpcywgbGlzdFtpXSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGFyZ2V0LmdldEluZGV4QnlJZCkgRGF0YVN0b3JlLnByb3RvdHlwZS5wcm92aWRlQXBpLmNhbGwodGhpcywgdGFyZ2V0LCBldmVudGFibGUpO1xuXHQgIH0sXG5cdCAgZ2V0VG9wUmFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0b0FycmF5KFtdLmNvbmNhdCh0aGlzLmJyYW5jaFswXSkpLm1hcChmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICB9LCB0aGlzKTtcblx0ICB9LFxuXHQgIGVhY2hDaGlsZDogZnVuY3Rpb24gKGlkLCBmdW5jdG9yLCBtYXN0ZXIsIGFsbCkge1xuXHQgICAgdmFyIGJyYW5jaCA9IHRoaXMuYnJhbmNoO1xuXHQgICAgaWYgKGFsbCAmJiB0aGlzLl9maWx0ZXJfYnJhbmNoKSBicmFuY2ggPSB0aGlzLl9maWx0ZXJfYnJhbmNoO1xuXHQgICAgdmFyIHN0YWNrID0gYnJhbmNoW2lkXTtcblx0ICAgIGlmIChzdGFjaykgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoc3RhY2tbaV0pIGZ1bmN0b3IuY2FsbChtYXN0ZXIgfHwgdGhpcywgdGhpcy5nZXRJdGVtKHN0YWNrW2ldKSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBlYWNoOiBmdW5jdGlvbiAobWV0aG9kLCBtYXN0ZXIsIGFsbCwgaWQpIHtcblx0ICAgIHRoaXMuZWFjaENoaWxkKGlkIHx8IDAsIGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHZhciBicmFuY2ggPSB0aGlzLmJyYW5jaDtcblx0ICAgICAgbWV0aG9kLmNhbGwobWFzdGVyIHx8IHRoaXMsIGl0ZW0pO1xuXHQgICAgICBpZiAoYWxsICYmIHRoaXMuX2ZpbHRlcl9icmFuY2gpIGJyYW5jaCA9IHRoaXMuX2ZpbHRlcl9icmFuY2g7XG5cdCAgICAgIGlmIChpdGVtICYmIGJyYW5jaFtpdGVtLmlkXSkgdGhpcy5lYWNoKG1ldGhvZCwgbWFzdGVyLCBhbGwsIGl0ZW0uaWQpO1xuXHQgICAgfSwgdGhpcywgYWxsKTtcblx0ICB9LFxuXHQgIGVhY2hPcGVuOiBmdW5jdGlvbiAobWV0aG9kLCBtYXN0ZXIsIGlkKSB7XG5cdCAgICB0aGlzLmVhY2hDaGlsZChpZCB8fCAwLCBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICBtZXRob2QuY2FsbChtYXN0ZXIgfHwgdGhpcywgaXRlbSk7XG5cdCAgICAgIGlmICh0aGlzLmJyYW5jaFtpdGVtLmlkXSAmJiBpdGVtLm9wZW4pIHRoaXMuZWFjaE9wZW4obWV0aG9kLCBtYXN0ZXIsIGl0ZW0uaWQpO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBlYWNoU3ViSXRlbTogZnVuY3Rpb24gKGlkLCBmdW5jdG9yKSB7XG5cdCAgICB2YXIgdG9wID0gdGhpcy5icmFuY2hbaWQgfHwgMF07XG5cdCAgICBpZiAodG9wKSBmb3IgKHZhciBpID0gMDsgaSA8IHRvcC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0gdG9wW2ldO1xuXG5cdCAgICAgIGlmICh0aGlzLmJyYW5jaFtrZXldKSB7XG5cdCAgICAgICAgZnVuY3Rvci5jYWxsKHRoaXMsIHRoaXMuZ2V0SXRlbShrZXkpLCB0cnVlKTtcblx0ICAgICAgICB0aGlzLmVhY2hTdWJJdGVtKGtleSwgZnVuY3Rvcik7XG5cdCAgICAgIH0gZWxzZSBmdW5jdG9yLmNhbGwodGhpcywgdGhpcy5nZXRJdGVtKGtleSksIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGVhY2hMZWFmOiBmdW5jdGlvbiAoaWQsIGZ1bmN0b3IpIHtcblx0ICAgIHZhciB0b3AgPSB0aGlzLmJyYW5jaFtpZCB8fCAwXTtcblx0ICAgIGlmICh0b3ApIGZvciAodmFyIGkgPSAwOyBpIDwgdG9wLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSB0b3BbaV07XG5cblx0ICAgICAgaWYgKHRoaXMuYnJhbmNoW2tleV0pIHtcblx0ICAgICAgICB0aGlzLmVhY2hMZWFmKGtleSwgZnVuY3Rvcik7XG5cdCAgICAgIH0gZWxzZSBmdW5jdG9yLmNhbGwodGhpcywgdGhpcy5nZXRJdGVtKGtleSksIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zb3J0X2NvcmU6IGZ1bmN0aW9uIChzb3J0LCBvcmRlcikge1xuXHQgICAgdmFyIHNvcnRlciA9IHRoaXMuc29ydGluZy5jcmVhdGUoc29ydCk7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmJyYW5jaCkge1xuXHQgICAgICB2YXIgYnNldCA9IHRoaXMuYnJhbmNoW2tleV07XG5cdCAgICAgIHZhciBkYXRhID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBic2V0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZGF0YS5wdXNoKHRoaXMucHVsbFtic2V0W2ldXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBkYXRhLnNvcnQoc29ydGVyKTtcblxuXHQgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYnNldC5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICBkYXRhW19pXSA9IGRhdGFbX2ldLmlkO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5icmFuY2hba2V5XSA9IGRhdGE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvcmRlcjtcblx0ICB9LFxuXHQgIGFkZDogZnVuY3Rpb24gKG9iaiwgaW5kZXgsIHBpZCkge1xuXHQgICAgdmFyIHJlZnJlc2hfcGFyZW50ID0gZmFsc2U7XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRJdGVtKHBpZCB8fCAwKTtcblxuXHQgICAgaWYgKHBhcmVudCkge1xuXHQgICAgICAvL3doZW4gYWRkaW5nIGl0ZW1zIHRvIGxlYWYgaXRlbSAtIGl0IG5lZWQgdG8gYmUgcmVwYWludGVkXG5cdCAgICAgIGlmICghdGhpcy5icmFuY2hbcGFyZW50LmlkXSkgcmVmcmVzaF9wYXJlbnQgPSB0cnVlO1xuXHQgICAgICBwYXJlbnQuJGNvdW50Kys7IC8vZml4IGZvciB0aGUgYWRkaW5nIGludG8gZHluYW1pYyBsb2FkaW5nIGJyYW5jaFxuXHQgICAgICAvL2R5bmFtaWMgYnJhbmNoIGhhcyAkY291bnQgYXMgLTFcblxuXHQgICAgICBpZiAoIXBhcmVudC4kY291bnQpIHBhcmVudC4kY291bnQgPSAxO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmJyYW5jaFtwaWQgfHwgMF0gPSB0aGlzLm9yZGVyID0gdG9BcnJheSh0aGlzLmJyYW5jaFtwaWQgfHwgMF0pO1xuXHQgICAgb2JqLiRjb3VudCA9IG9iai53ZWJpeF9raWRzID8gLTEgOiAwO1xuXHQgICAgb2JqLiRsZXZlbCA9IHBhcmVudCA/IHBhcmVudC4kbGV2ZWwgKyAxIDogMTtcblx0ICAgIG9iai4kcGFyZW50ID0gcGFyZW50ID8gcGFyZW50LmlkIDogMDtcblxuXHQgICAgaWYgKHRoaXMuX2ZpbHRlcl9icmFuY2gpIHtcblx0ICAgICAgLy9hZGRpbmcgZHVyaW5nIGZpbHRlcmluZ1xuXHQgICAgICB2YXIgb3JpZ2luID0gdGhpcy5fZmlsdGVyX2JyYW5jaFtwaWQgfHwgMF07IC8vbmV3bHkgY3JlYXRlZCBicmFuY2hcblxuXHQgICAgICBpZiAoIW9yaWdpbikgb3JpZ2luID0gdGhpcy5fZmlsdGVyX2JyYW5jaFtwaWRdID0gdGhpcy5vcmRlcjsgLy9icmFuY2ggY2FuIGJlIHNoYXJlZCBiZXR0d2VuIGNvbGxlY3Rpb25zLCBpZ25vcmUgc3VjaCBjYXNlc1xuXG5cdCAgICAgIGlmICh0aGlzLm9yZGVyICE9PSBvcmlnaW4pIHtcblx0ICAgICAgICAvL3dlIGNhbid0IGtub3cgdGhlIGxvY2F0aW9uIG9mIG5ldyBpdGVtIGluIGZ1bGwgZGF0YXNldCwgbWFraW5nIHN1Z2dlc3Rpb25cblx0ICAgICAgICAvL3B1dCBhdCBlbmQgYnkgZGVmYXVsdFxuXHQgICAgICAgIHZhciBvcmlnaW5hbF9pbmRleCA9IG9yaWdpbi5sZW5ndGg7IC8vcHV0IGF0IHN0YXJ0IG9ubHkgaWYgYWRkaW5nIHRvIHRoZSBzdGFydCBhbmQgc29tZSBkYXRhIGV4aXN0c1xuXG5cdCAgICAgICAgaWYgKCFpbmRleCAmJiB0aGlzLmJyYW5jaFtwaWQgfHwgMF0ubGVuZ3RoKSBvcmlnaW5hbF9pbmRleCA9IDA7XG5cdCAgICAgICAgb3JpZ2luID0gdG9BcnJheShvcmlnaW4pO1xuXHQgICAgICAgIG9iai5pZCA9IG9iai5pZCB8fCB1aWQoKTtcblx0ICAgICAgICBvcmlnaW4uaW5zZXJ0QXQob2JqLmlkLCBvcmlnaW5hbF9pbmRleCk7XG5cdCAgICAgIH1cblx0ICAgIH0gLy9jYWxsIG9yaWdpbmFsIGFkZGluZyBsb2dpY1xuXG5cblx0ICAgIHZhciByZXN1bHQgPSBEYXRhU3RvcmUucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iaiwgaW5kZXgpO1xuXHQgICAgaWYgKHJlZnJlc2hfcGFyZW50KSB0aGlzLnJlZnJlc2gocGlkKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBfcmVjX3JlbW92ZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgb2JqID0gdGhpcy5wdWxsW2lkXTtcblxuXHQgICAgaWYgKHRoaXMuYnJhbmNoW29iai5pZF0gJiYgdGhpcy5icmFuY2hbb2JqLmlkXS5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHZhciBicmFuY2ggPSB0aGlzLmJyYW5jaFtpZF07XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmFuY2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLl9yZWNfcmVtb3ZlKGJyYW5jaFtpXSwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZGVsZXRlIHRoaXMuYnJhbmNoW2lkXTtcblx0ICAgIGlmICh0aGlzLl9maWx0ZXJfYnJhbmNoKSBkZWxldGUgdGhpcy5fZmlsdGVyX2JyYW5jaFtpZF07XG5cdCAgICBkZWxldGUgdGhpcy5wdWxsW2lkXTtcblx0ICAgIGlmICh0aGlzLl9tYXJrc1tpZF0pIGRlbGV0ZSB0aGlzLl9tYXJrc1tpZF07XG5cdCAgfSxcblx0ICBfZmlsdGVyX3JlbW92ZWQ6IGZ1bmN0aW9uIChwdWxsLCBwYXJlbnRJZCwgaWQpIHtcblx0ICAgIHZhciBicmFuY2ggPSBwdWxsW3BhcmVudElkXTtcblxuXHQgICAgaWYgKGJyYW5jaC5sZW5ndGggPT0gMSAmJiBicmFuY2hbMF0gPT0gaWQgJiYgcGFyZW50SWQpIHtcblx0ICAgICAgZGVsZXRlIHB1bGxbcGFyZW50SWRdO1xuXHQgICAgfSBlbHNlIHRvQXJyYXkoYnJhbmNoKS5yZW1vdmUoaWQpO1xuXHQgIH0sXG5cdCAgcmVtb3ZlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIC8vaWQgY2FuIGJlIGFuIGFycmF5IG9mIElEcyAtIHJlc3VsdCBvZiBnZXRTZWxlY3QsIGZvciBleGFtcGxlXG5cdCAgICBpZiAoaXNBcnJheShpZCkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlKGlkW2ldKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0KHRoaXMuZXhpc3RzKGlkKSwgXCJOb3QgZXhpc3RpbmcgSUQgaW4gcmVtb3ZlIGNvbW1hbmRcIiArIGlkKTtcblx0ICAgIHZhciBvYmogPSB0aGlzLnB1bGxbaWRdO1xuXHQgICAgdmFyIHBhcmVudElkID0gb2JqLiRwYXJlbnQgfHwgMDtcblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlRGVsZXRlXCIsIFtpZF0pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICB0aGlzLl9yZWNfcmVtb3ZlKGlkKTtcblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRGVsZXRlXCIsIFtpZF0pO1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMucHVsbFtwYXJlbnRJZF07XG5cblx0ICAgIHRoaXMuX2ZpbHRlcl9yZW1vdmVkKHRoaXMuYnJhbmNoLCBwYXJlbnRJZCwgaWQpO1xuXG5cdCAgICBpZiAodGhpcy5fZmlsdGVyX2JyYW5jaCkgdGhpcy5fZmlsdGVyX3JlbW92ZWQodGhpcy5fZmlsdGVyX2JyYW5jaCwgcGFyZW50SWQsIGlkKTtcblx0ICAgIHZhciByZWZyZXNoX3BhcmVudCA9IDA7XG5cblx0ICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgcGFyZW50LiRjb3VudC0tO1xuXG5cdCAgICAgIGlmIChwYXJlbnQuJGNvdW50IDw9IDApIHtcblx0ICAgICAgICBwYXJlbnQuJGNvdW50ID0gMDtcblx0ICAgICAgICBwYXJlbnQub3BlbiA9IDA7XG5cdCAgICAgICAgcmVmcmVzaF9wYXJlbnQgPSAxO1xuXHQgICAgICB9XG5cdCAgICB9IC8vcmVwYWludCBzaWduYWxcblxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIFtpZCwgb2JqLCBcImRlbGV0ZVwiXSk7XG5cdCAgICBpZiAocmVmcmVzaF9wYXJlbnQpIHRoaXMucmVmcmVzaChwYXJlbnQuaWQpO1xuXHQgIH0sXG5cblx0ICAvKlxuXHQgIFx0c2VyaWFsaXplcyBkYXRhIHRvIGEganNvbiBvYmplY3Rcblx0ICAqL1xuXHQgIGdldEJyYW5jaDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgb3V0ID0gW107XG5cdCAgICB2YXIgaXRlbXMgPSAodGhpcy5fZmlsdGVyX2JyYW5jaCB8fCB0aGlzLmJyYW5jaClbaWRdO1xuXHQgICAgaWYgKGl0ZW1zKSBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG91dFtpXSA9IHRoaXMucHVsbFtpdGVtc1tpXV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3V0O1xuXHQgIH0sXG5cdCAgc2VyaWFsaXplOiBmdW5jdGlvbiAoaWQsIGFsbCkge1xuXHQgICAgdmFyIGNvbGwgPSB0aGlzLmJyYW5jaDsgLy91c2Ugb3JpZ2luYWwgY29sbGVjdGlvbiBvZiBicmFuY2hlc1xuXG5cdCAgICBpZiAoYWxsICYmIHRoaXMuX2ZpbHRlcl9icmFuY2gpIGNvbGwgPSB0aGlzLl9maWx0ZXJfYnJhbmNoO1xuXHQgICAgdmFyIGlkcyA9IGNvbGxbaWQgfHwgMF07XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBvYmogPSB0aGlzLnB1bGxbaWRzW2ldXTtcblx0ICAgICAgdmFyIHJlbDtcblxuXHQgICAgICBpZiAodGhpcy5fc2NoZW1lX3NlcmlhbGl6ZSkge1xuXHQgICAgICAgIHJlbCA9IHRoaXMuX3NjaGVtZV9zZXJpYWxpemUob2JqKTtcblx0ICAgICAgICBpZiAocmVsID09PSBmYWxzZSkgY29udGludWU7XG5cdCAgICAgIH0gZWxzZSByZWwgPSBjb3B5KG9iaik7XG5cblx0ICAgICAgaWYgKGNvbGxbb2JqLmlkXSkgcmVsLmRhdGEgPSB0aGlzLnNlcmlhbGl6ZShvYmouaWQsIGFsbCk7XG5cdCAgICAgIHJlc3VsdC5wdXNoKHJlbCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBUcmVlVGFibGVQYXN0ZSA9IHtcblx0ICBpbnNlcnQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUsIHRydWUpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGl0ZW0gPSB7fTtcblxuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NldHRpbmdzLmNvbHVtbnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICBpdGVtW3RoaXMuX3NldHRpbmdzLmNvbHVtbnNbal0uaWRdID0gZGF0YVtpXVtqXSB8fCBcIlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFpc1VuZGVmaW5lZChpdGVtLmlkKSAmJiB0aGlzLmV4aXN0cyhpdGVtLmlkKSkgaXRlbS5pZCA9IHVpZCgpO1xuXHQgICAgICB0aGlzLmFkZChpdGVtLCBudWxsLCBwYXJlbnRbMF0pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgVHJlZVR5cGUgPSB7XG5cdCAgc3BhY2U6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHZhciBodG1sID0gXCJcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvYmouJGxldmVsOyBpKyspIHtcblx0ICAgICAgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X3RyZWVfbm9uZSc+PC9kaXY+XCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBodG1sO1xuXHQgIH0sXG5cdCAgaWNvbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgaWYgKG9iai4kY291bnQpIHtcblx0ICAgICAgaWYgKG9iai5vcGVuKSByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90cmVlX29wZW4nPjwvZGl2PlwiO2Vsc2UgcmV0dXJuIFwiPGRpdiBjbGFzcz0nd2ViaXhfdHJlZV9jbG9zZSc+PC9kaXY+XCI7XG5cdCAgICB9IGVsc2UgcmV0dXJuIFwiPGRpdiBjbGFzcz0nd2ViaXhfdHJlZV9ub25lJz48L2Rpdj5cIjtcblx0ICB9LFxuXHQgIGNoZWNrYm94OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAob2JqLm5vY2hlY2tib3gpIHJldHVybiBcIlwiO1xuXHQgICAgcmV0dXJuIFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBjbGFzcz0nd2ViaXhfdHJlZV9jaGVja2JveCcgXCIgKyAob2JqLmNoZWNrZWQgPyBcImNoZWNrZWRcIiA6IFwiXCIpICsgKG9iai5kaXNhYmxlZCA/IFwiIGRpc2FibGVkXCIgOiBcIlwiKSArIFwiPlwiO1xuXHQgIH0sXG5cdCAgZm9sZGVyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAob2JqLmljb24pIHJldHVybiBcIjxkaXYgY2xhc3M9J3dlYml4X3RyZWVfZmlsZSB3ZWJpeF90cmVlX1wiICsgb2JqLmljb24gKyBcIic+PC9kaXY+XCI7XG5cblx0ICAgIGlmIChvYmouJGNvdW50KSB7XG5cdCAgICAgIGlmIChvYmoub3BlbikgcmV0dXJuIFwiPGRpdiBjbGFzcz0nd2ViaXhfdHJlZV9mb2xkZXJfb3Blbic+PC9kaXY+XCI7ZWxzZSByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90cmVlX2ZvbGRlcic+PC9kaXY+XCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBcIjxkaXYgY2xhc3M9J3dlYml4X3RyZWVfZmlsZSc+PC9kaXY+XCI7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBVcGxvYWREcml2ZXIgPSB7XG5cdCAgZmxhc2g6IHtcblx0ICAgICRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCF3aW5kb3cuc3dmb2JqZWN0KSByZXF1aXJlKFwibGVnYWN5L3N3Zm9iamVjdC5qc1wiLCB0cnVlKTsgLy8gc3luYyBsb2FkaW5nXG5cblx0ICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgICBjb25maWcuc3dmSWQgPSBjb25maWcuc3dmSWQgfHwgXCJ3ZWJpeF9zd2ZfXCIgKyB1aWQoKTtcblx0ICAgICAgdGhpcy5fZ2V0Qm94KCkuaW5uZXJIVE1MICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfdXBsb2FkX2ZsYXNoJz48ZGl2IGlkPSdcIiArIGNvbmZpZy5zd2ZJZCArIFwiJz48L2Rpdj48L2Rpdj5cIjtcblx0ICAgICAgdGhpcy5fdXBsb2FkX2FyZWEgPSB0aGlzLl9nZXRCb3goKS5sYXN0Q2hpbGQ7IC8vIGFkZCBzd2Ygb2JqZWN0XG5cblx0ICAgICAgLyogZ2xvYmFsIHN3Zm9iamVjdCAqL1xuXG5cdCAgICAgIHN3Zm9iamVjdC5lbWJlZFNXRihlbnYuY29kZWJhc2UgKyBcIi9sZWdhY3kvdXBsb2FkZXIuc3dmXCIsIGNvbmZpZy5zd2ZJZCwgXCIxMDAlXCIsIFwiMTAwJVwiLCBcIjlcIiwgbnVsbCwge1xuXHQgICAgICAgIHVwbG9hZGVySWQ6IGNvbmZpZy5pZCxcblx0ICAgICAgICBJRDogY29uZmlnLnN3ZklkLFxuXHQgICAgICAgIGVuYWJsZUxvZ3M6IGNvbmZpZy5lbmFibGVMb2dzID8gXCIxXCIgOiBcIlwiLFxuXHQgICAgICAgIHBhcmFtTmFtZTogY29uZmlnLmlucHV0TmFtZSxcblx0ICAgICAgICBtdWx0aXBsZTogY29uZmlnLm11bHRpcGxlID8gXCJZXCIgOiBcIlwiXG5cdCAgICAgIH0sIHtcblx0ICAgICAgICB3bW9kZTogXCJ0cmFuc3BhcmVudFwiXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcImNsaWNrXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub3dfZGF0ZSA9IG5ldyBEYXRlKCk7XG5cblx0ICAgICAgICBpZiAobm93X2RhdGUgLSAodGhpcy5fdXBsb2FkX3RpbWVyX2NsaWNrIHx8IDApID4gMjUwKSB7XG5cdCAgICAgICAgICB0aGlzLmZpbGVEaWFsb2coKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHRoaXMpKTtcblxuXHQgICAgICB0aGlzLmZpbGVzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEZWxldGVcIiwgYmluZCh0aGlzLl9zdG9wX2ZpbGUsIHRoaXMpKTtcblx0ICAgIH0sXG5cdCAgICAkYXBwbHlGbGFzaDogZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xuXHQgICAgICByZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBwYXJhbXMpO1xuXHQgICAgfSxcblx0ICAgIGdldFN3Zk9iamVjdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAvKiBnbG9iYWwgc3dmb2JqZWN0ICovXG5cdCAgICAgIHJldHVybiBzd2ZvYmplY3QuZ2V0T2JqZWN0QnlJZCh0aGlzLl9zZXR0aW5ncy5zd2ZJZCk7XG5cdCAgICB9LFxuXHQgICAgZmlsZURpYWxvZzogZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAodGhpcy5nZXRTd2ZPYmplY3QoKSkgdGhpcy5nZXRTd2ZPYmplY3QoKS5zaG93RGlhbG9nKCk7XG5cdCAgICB9LFxuXHQgICAgc2VuZDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgaWQgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdF9hc3NpZ25lZF91cGxvYWRfY2FsbGJhY2sgPSBpZDtcblx0ICAgICAgICBpZCA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWlkKSB7XG5cdCAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5maWxlcy5kYXRhLm9yZGVyO1xuXHQgICAgICAgIHZhciBjb21wbGV0ZSA9IHRydWU7XG5cdCAgICAgICAgaWYgKG9yZGVyLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgY29tcGxldGUgPSB0aGlzLnNlbmQob3JkZXJbaV0pICYmIGNvbXBsZXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29tcGxldGUpIHRoaXMuX3VwbG9hZF9jb21wbGV0ZSgpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5maWxlcy5nZXRJdGVtKGlkKTtcblx0ICAgICAgaWYgKGl0ZW0uc3RhdHVzICE9PSBcImNsaWVudFwiKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgIGl0ZW0uc3RhdHVzID0gXCJ0cmFuc2ZlclwiO1xuXG5cdCAgICAgIGlmICh0aGlzLmdldFN3Zk9iamVjdCgpKSB7XG5cdCAgICAgICAgdmFyIHVybCA9IHRoaXMuX2dldF9hY3RpdmVfdXJsKGl0ZW0pO1xuXG5cdCAgICAgICAgdmFyIGdsb2JhbERhdGEgPSB0aGlzLl9zZXR0aW5ncy5mb3JtRGF0YSB8fCB7fTtcblx0ICAgICAgICBpZiAodHlwZW9mIGdsb2JhbERhdGEgPT09IFwiZnVuY3Rpb25cIikgZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGEuY2FsbCh0aGlzKTtcblx0ICAgICAgICB2YXIgZGV0YWlscyA9IGV4cG9ydHMuZXh0ZW5kKGl0ZW0uZm9ybURhdGEgfHwge30sIGdsb2JhbERhdGEpO1xuXHQgICAgICAgIHRoaXMuZ2V0U3dmT2JqZWN0KCkudXBsb2FkKGlkLCB1cmwsIGRldGFpbHMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9LFxuXHQgICAgJGJlZm9yZUFkZEZpbGVUb1F1ZXVlOiBmdW5jdGlvbiAoaWQsIG5hbWUsIHNpemUpIHtcblx0ICAgICAgdmFyIHR5cGUgPSBuYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcblxuXHQgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fZm9ybWF0X3NpemUoc2l6ZSk7XG5cblx0ICAgICAgcmV0dXJuIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVGaWxlQWRkXCIsIFt7XG5cdCAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgc2l6ZTogc2l6ZSxcblx0ICAgICAgICBzaXpldGV4dDogZm9ybWF0LFxuXHQgICAgICAgIHR5cGU6IHR5cGVcblx0ICAgICAgfV0pO1xuXHQgICAgfSxcblx0ICAgICRhZGRGaWxlVG9RdWV1ZTogZnVuY3Rpb24gKGlkLCBuYW1lLCBzaXplKSB7XG5cdCAgICAgIGlmICh0aGlzLmZpbGVzLmV4aXN0cyhpZCkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5tdWx0aXBsZSkgdGhpcy5maWxlcy5jbGVhckFsbCgpO1xuXHQgICAgICB2YXIgdHlwZSA9IG5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuXG5cdCAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9mb3JtYXRfc2l6ZShzaXplKTtcblxuXHQgICAgICB2YXIgZmlsZV9zdHJ1Y3QgPSB7XG5cdCAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgc2l6ZTogc2l6ZSxcblx0ICAgICAgICBzaXpldGV4dDogZm9ybWF0LFxuXHQgICAgICAgIHR5cGU6IHR5cGUsXG5cdCAgICAgICAgc3RhdHVzOiBcImNsaWVudFwiXG5cdCAgICAgIH07XG5cdCAgICAgIHRoaXMuZmlsZXMuYWRkKGZpbGVfc3RydWN0KTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRmlsZUFkZFwiLCBbZmlsZV9zdHJ1Y3RdKTtcblx0ICAgICAgaWYgKGlkICYmIHRoaXMuX3NldHRpbmdzLmF1dG9zZW5kKSB0aGlzLnNlbmQoaWQpO1xuXHQgICAgfSxcblx0ICAgIHN0b3BVcGxvYWQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICB0aGlzLl9zdG9wX2ZpbGUoaWQpO1xuXHQgICAgfSxcblx0ICAgIF9zdG9wX2ZpbGU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZmlsZXMuZ2V0SXRlbShpZCk7XG5cblx0ICAgICAgaWYgKGl0ZW0uc3RhdHVzID09IFwidHJhbnNmZXJcIikge1xuXHQgICAgICAgIHRoaXMuZ2V0U3dmT2JqZWN0KCkudXBsb2FkU3RvcChpZCk7XG5cdCAgICAgICAgaXRlbS5zdGF0dXMgPSBcImNsaWVudFwiO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgX2Ryb3A6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgLy9kcm9wIG9mIGZpbGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUU5LVxuXHQgICAgJG9uVXBsb2FkQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG9zZW5kKSB7XG5cdCAgICAgICAgdGhpcy5fdXBsb2FkX2NvbXBsZXRlKCk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICAkb25VcGxvYWRTdWNjZXNzOiBmdW5jdGlvbiAoaWQsIG5hbWUsIHJlc3BvbnNlKSB7XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5maWxlcy5nZXRJdGVtKGlkKTtcblxuXHQgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgIGl0ZW0uc3RhdHVzID0gXCJzZXJ2ZXJcIjtcblx0ICAgICAgICBpdGVtLnByb2dyZXNzID0gMTAwO1xuXG5cdCAgICAgICAgaWYgKHJlc3BvbnNlLnRleHQgJiYgdHlwZW9mIHJlc3BvbnNlLnRleHQgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgRGF0YURyaXZlci5qc29uLnRvT2JqZWN0KHJlc3BvbnNlLnRleHQpO1xuXHQgICAgICAgICAgZXhwb3J0cy5leHRlbmQoaXRlbSwgcmVzcG9uc2UsIHRydWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25GaWxlVXBsb2FkXCIsIFtpdGVtLCByZXNwb25zZV0pO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25DaGFuZ2VcIiwgW10pO1xuXHQgICAgICAgIHRoaXMuZmlsZXMudXBkYXRlSXRlbShpZCk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICAkb25VcGxvYWRGYWlsOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbGVzLmdldEl0ZW0oaWQpO1xuXHQgICAgICBpdGVtLnN0YXR1cyA9IFwiZXJyb3JcIjtcblx0ICAgICAgZGVsZXRlIGl0ZW0ucGVyY2VudDtcblx0ICAgICAgdGhpcy5maWxlcy51cGRhdGVJdGVtKGlkKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkZpbGVVcGxvYWRFcnJvclwiLCBbaXRlbSwgXCJcIl0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgaHRtbDU6IHtcblx0ICAgICRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX3VwbG9hZF9hcmVhKSB7XG5cdCAgICAgICAgLy9maXJzdENoaWxkIGlzIHdlYml4X2VsX2JveCBjb250YWluZXIsIHdoaWNoIGhhdmUgcmVsYXRpdmUgcG9zaXRpb25cblx0ICAgICAgICAvL2FzIHJlc3VsdCwgZmlsZSBjb250cm9sIGlzIHBsYWNlZCB1bmRlciB0aGUgYnV0dG9uIGFuZCBub3QgaW4gdGhlIHRvcCBjb3JuZXJcblx0ICAgICAgICB0aGlzLl9jb250ZW50b2JqLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5fdXBsb2FkX2FyZWEpO1xuXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5maWxlcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlRGVsZXRlXCIsIHRoaXMuX3N0b3BfZmlsZSk7XG5cdCAgICAgIHZhciBpbnB1dF9jb25maWcgPSB7XG5cdCAgICAgICAgXCJ0eXBlXCI6IFwiZmlsZVwiLFxuXHQgICAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9oaWRkZW5fdXBsb2FkXCIsXG5cdCAgICAgICAgdGFiaW5kZXg6IC0xXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hY2NlcHQpIGlucHV0X2NvbmZpZy5hY2NlcHQgPSB0aGlzLl9zZXR0aW5ncy5hY2NlcHQ7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aXBsZSkgaW5wdXRfY29uZmlnLm11bHRpcGxlID0gXCJ0cnVlXCI7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmRpcmVjdG9yeSkge1xuXHQgICAgICAgIGlucHV0X2NvbmZpZy53ZWJraXRkaXJlY3RvcnkgPSBcInRydWVcIjtcblx0ICAgICAgICBpbnB1dF9jb25maWcubW96ZGlyZWN0b3J5ID0gXCJ0cnVlXCI7XG5cdCAgICAgICAgaW5wdXRfY29uZmlnLmRpcmVjdG9yeSA9IFwidHJ1ZVwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGYgPSBjcmVhdGUoXCJpbnB1dFwiLCBpbnB1dF9jb25maWcpO1xuXHQgICAgICB0aGlzLl91cGxvYWRfYXJlYSA9IHRoaXMuX2NvbnRlbnRvYmouZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChmKTtcblxuXHQgICAgICBfZXZlbnQodGhpcy5fdmlld29iaiwgXCJkcm9wXCIsIGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB0aGlzLl9kcm9wKGUpO1xuXG5cdCAgICAgICAgcHJldmVudEV2ZW50KGUpO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cblx0ICAgICAgX2V2ZW50KGYsIFwiY2hhbmdlXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2FkZF9maWxlcyhmLmZpbGVzKTtcblxuXHQgICAgICAgIGlmIChlbnYuaXNJRSkge1xuXHQgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcblx0ICAgICAgICAgIHQuYXBwZW5kQ2hpbGQodGhpcy5fdXBsb2FkX2FyZWEpO1xuXHQgICAgICAgICAgdC5yZXNldCgpO1xuXG5cdCAgICAgICAgICB0aGlzLl9jb250ZW50b2JqLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQoZik7XG5cdCAgICAgICAgfSBlbHNlIGYudmFsdWUgPSBcIlwiO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cblx0ICAgICAgX2V2ZW50KHRoaXMuX3ZpZXdvYmosIFwiY2xpY2tcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vd19kYXRlID0gbmV3IERhdGUoKTtcblxuXHQgICAgICAgIGlmIChub3dfZGF0ZSAtICh0aGlzLl91cGxvYWRfdGltZXJfY2xpY2sgfHwgMCkgPiAyNTApIHtcblx0ICAgICAgICAgIHRoaXMuZmlsZURpYWxvZygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgdGhpcykpO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcImRyYWdlbnRlclwiLCBwcmV2ZW50RXZlbnQpO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcImRyYWdleGl0XCIsIHByZXZlbnRFdmVudCk7XG5cblx0ICAgICAgX2V2ZW50KHRoaXMuX3ZpZXdvYmosIFwiZHJhZ292ZXJcIiwgcHJldmVudEV2ZW50KTtcblx0ICAgIH0sXG5cdCAgICBfZGlyZWN0b3J5RW50cnk6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdmFsdWUuaXNEaXJlY3Rvcnk7XG5cdCAgICB9LFxuXHQgICAgX2RpcmVjdG9yeURyb3A6IGZ1bmN0aW9uIChpdGVtLCBzdGF0ZSwgcGF0aCkge1xuXHQgICAgICBpZiAoaXRlbS5pc0ZpbGUpIHtcblx0ICAgICAgICBpdGVtLmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcblx0ICAgICAgICAgIHN0YXRlLmFkZEZpbGUoZmlsZSwgbnVsbCwgbnVsbCwge1xuXHQgICAgICAgICAgICBuYW1lOiBwYXRoICsgXCIvXCIgKyBmaWxlLm5hbWVcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2UgaWYgKGl0ZW0uaXNEaXJlY3RvcnkpIHtcblx0ICAgICAgICAvLyBHZXQgZm9sZGVyIGNvbnRlbnRzXG5cdCAgICAgICAgdmFyIGRpclJlYWRlciA9IGl0ZW0uY3JlYXRlUmVhZGVyKCk7XG5cdCAgICAgICAgZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgc3RhdGUuX2RpcmVjdG9yeURyb3AoZW50cmllc1tpXSwgc3RhdGUsIChwYXRoID8gcGF0aCArIFwiL1wiIDogXCJcIikgKyBpdGVtLm5hbWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgLy8gYWRkaW5nIGZpbGVzIGJ5IGRyYWctbi1kcm9wXG5cdCAgICBfZHJvcDogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGZpbGVzID0gZS5kYXRhVHJhbnNmZXIuZmlsZXM7XG5cdCAgICAgIHZhciBpdGVtcyA9IGUuZGF0YVRyYW5zZmVyLml0ZW1zO1xuXG5cdCAgICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlRmlsZURyb3BcIiwgW2ZpbGVzLCBlXSkpIHtcblx0ICAgICAgICBpdGVtcyA9IGl0ZW1zIHx8IGZpbGVzOyAvL0lFMTArXG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAvL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EYXRhVHJhbnNmZXJJdGVtL3dlYmtpdEdldEFzRW50cnlcblx0ICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG5cblx0ICAgICAgICAgIGlmIChpdGVtLndlYmtpdEdldEFzRW50cnkpIHtcblx0ICAgICAgICAgICAgaXRlbSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpO1xuXG5cdCAgICAgICAgICAgIGlmIChpdGVtLmlzRGlyZWN0b3J5KSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0b3J5RHJvcChpdGVtLCB0aGlzLCBcIlwiKTtcblxuXHQgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRoaXMuYWRkRmlsZShmaWxlc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRmlsZURyb3BcIiwgW2ZpbGVzLCBlXSk7XG5cdCAgICB9LFxuXHQgICAgZmlsZURpYWxvZzogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgdGhpcy5fdXBsb2FkX3RpbWVyX2NsaWNrID0gbmV3IERhdGUoKTtcblx0ICAgICAgdGhpcy5fbGFzdF9maWxlX2NvbnRleHQgPSBjb250ZXh0O1xuXG5cdCAgICAgIHZhciBpbnB1dHMgPSB0aGlzLl92aWV3b2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiSU5QVVRcIik7XG5cblx0ICAgICAgaW5wdXRzW2lucHV0cy5sZW5ndGggLSAxXS5jbGljaygpO1xuXHQgICAgfSxcblx0ICAgIHNlbmQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAvL2FsdGVybmF0aXZlIHN5bnR4IHNlbmQoY2FsbGJhY2spXG5cdCAgICAgIGlmICh0eXBlb2YgaWQgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdF9hc3NpZ25lZF91cGxvYWRfY2FsbGJhY2sgPSBpZDtcblx0ICAgICAgICBpZCA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWlkKSB7XG5cdCAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5maWxlcy5kYXRhLm9yZGVyO1xuXHQgICAgICAgIHZhciBjb21wbGV0ZSA9IHRydWU7XG5cdCAgICAgICAgaWYgKG9yZGVyLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgY29tcGxldGUgPSAhdGhpcy5zZW5kKG9yZGVyW2ldKSAmJiBjb21wbGV0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvbXBsZXRlKSB0aGlzLl91cGxvYWRfY29tcGxldGUoKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZmlsZXMuZ2V0SXRlbShpZCk7XG5cdCAgICAgIGlmIChpdGVtLnN0YXR1cyAhPT0gXCJjbGllbnRcIikgcmV0dXJuIGZhbHNlO1xuXHQgICAgICBhc3NlcnQodGhpcy5fc2V0dGluZ3MudXBsb2FkLCBcIllvdSBuZWVkIHRvIGRlZmluZSB1cGxvYWQgdXJsIGZvciB1cGxvYWRlciBjb21wb25lbnRcIik7XG5cdCAgICAgIGl0ZW0uc3RhdHVzID0gXCJ0cmFuc2ZlclwiO1xuXHQgICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblx0ICAgICAgZm9ybURhdGEuYXBwZW5kKHRoaXMuY29uZmlnLmlucHV0TmFtZSwgaXRlbS5maWxlLCBpdGVtLm5hbWUpO1xuXHQgICAgICBmb3JtRGF0YS5hcHBlbmQodGhpcy5jb25maWcuaW5wdXROYW1lICsgXCJfZnVsbHBhdGhcIiwgaXRlbS5uYW1lKTtcblx0ICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcblx0ICAgICAgdmFyIGdsb2JhbERhdGEgPSB0aGlzLl9zZXR0aW5ncy5mb3JtRGF0YSB8fCB7fTtcblx0ICAgICAgaWYgKHR5cGVvZiBnbG9iYWxEYXRhID09PSBcImZ1bmN0aW9uXCIpIGdsb2JhbERhdGEgPSBnbG9iYWxEYXRhLmNhbGwodGhpcyk7XG5cdCAgICAgIHZhciBkZXRhaWxzID0gZXhwb3J0cy5leHRlbmQoaXRlbS5mb3JtRGF0YSB8fCB7fSwgZ2xvYmFsRGF0YSk7XG5cdCAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHQgICAgICB2YXIgdXJsID0gdGhpcy5fZ2V0X2FjdGl2ZV91cmwoaXRlbSk7XG5cblx0ICAgICAgaWYgKGNhbGxFdmVudChcIm9uQmVmb3JlQWpheFwiLCBbXCJQT1NUXCIsIHVybCwgZGV0YWlscywgeGhyLCBoZWFkZXJzLCBmb3JtRGF0YV0pKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGRldGFpbHMpIHtcblx0ICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIGRldGFpbHNba2V5XSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaXRlbS54aHIgPSB4aHI7XG5cdCAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgYmluZChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgdGhpcy4kdXBkYXRlUHJvZ3Jlc3MoaWQsIGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMCk7XG5cdCAgICAgICAgfSwgdGhpcyksIGZhbHNlKTtcblx0ICAgICAgICB4aHIub25sb2FkID0gYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAoIXhoci5hYm9ydGVkKSB0aGlzLl9maWxlX2NvbXBsZXRlKGlkKTtcblx0ICAgICAgICB9LCB0aGlzKTtcblx0ICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJsLCB0cnVlKTtcblxuXHQgICAgICAgIGZvciAodmFyIF9rZXkgaW4gaGVhZGVycykge1xuXHQgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoX2tleSwgaGVhZGVyc1tfa2V5XSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy4kdXBkYXRlUHJvZ3Jlc3MoaWQsIDApO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0sXG5cdCAgICBfZmlsZV9jb21wbGV0ZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5maWxlcy5nZXRJdGVtKGlkKTtcblxuXHQgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgIHZhciByZXNwb25zZSA9IG51bGw7XG5cblx0ICAgICAgICBpZiAoaXRlbS54aHIuc3RhdHVzIDwgNDAwKSB7XG5cdCAgICAgICAgICB2YXIgZHJpdmVyID0gRGF0YURyaXZlclt0aGlzLl9zZXR0aW5ncy5kYXRhdHlwZSB8fCBcImpzb25cIl07XG5cdCAgICAgICAgICByZXNwb25zZSA9IGRyaXZlci50b09iamVjdChpdGVtLnhoci5yZXNwb25zZVRleHQpO1xuXHQgICAgICAgICAgaWYgKHJlc3BvbnNlKSByZXNwb25zZSA9IGRyaXZlci5nZXREZXRhaWxzKHJlc3BvbnNlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyA9PSBcImVycm9yXCIpIHtcblx0ICAgICAgICAgIC8vIGZpbGUgdXBsb2FkIGVycm9yXG5cdCAgICAgICAgICBpdGVtLnN0YXR1cyA9IFwiZXJyb3JcIjtcblx0ICAgICAgICAgIGRlbGV0ZSBpdGVtLnBlcmNlbnQ7XG5cdCAgICAgICAgICB0aGlzLmZpbGVzLnVwZGF0ZUl0ZW0oaWQpO1xuXHQgICAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkZpbGVVcGxvYWRFcnJvclwiLCBbaXRlbSwgcmVzcG9uc2VdKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gZmlsZSB1cGxvYWQgY29tcGxldGVcblx0ICAgICAgICAgIGFzc2VydCghcmVzcG9uc2Uuc3RhdHVzIHx8IHJlc3BvbnNlLnN0YXR1cyA9PSBcInNlcnZlclwiLCBcIk5vdCBzdXBwb3J0ZWQgc3RhdHVzIHZhbHVlLCB1c2UgJ2Vycm9yJyBvciAnc2VydmVyJ1wiKTtcblxuXHQgICAgICAgICAgdGhpcy5fY29tcGxldGUoaWQsIHJlc3BvbnNlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkZWxldGUgaXRlbS54aHI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzdG9wVXBsb2FkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgYmluZCh0aGlzLl9zdG9wX2ZpbGUsIHRoaXMuZmlsZXMpKGlkKTtcblx0ICAgIH0sXG5cdCAgICBfc3RvcF9maWxlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgaXRlbS54aHIgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgICBpdGVtLnhoci5hYm9ydGVkID0gdHJ1ZTtcblx0ICAgICAgICBpdGVtLnhoci5hYm9ydCgpO1xuXHQgICAgICAgIGRlbGV0ZSBpdGVtLnhocjtcblx0ICAgICAgICBpdGVtLnN0YXR1cyA9IFwiY2xpZW50XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIFZhbGlkYXRlQ29sbGVjdGlvbiA9IHtcblx0ICBfdmFsaWRhdGVfaW5pdF9vbmNlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uIChpZCwgZGF0YSwgbW9kZSkge1xuXHQgICAgICBpZiAoaWQgJiYgKG1vZGUgPT0gXCJhZGRcIiB8fCBtb2RlID09IFwidXBkYXRlXCIpKSB0aGlzLnZhbGlkYXRlKGlkKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uQ2xlYXJBbGxcIiwgYmluZCh0aGlzLmNsZWFyVmFsaWRhdGlvbiwgdGhpcykpO1xuXG5cdCAgICB0aGlzLl92YWxpZGF0ZV9pbml0X29uY2UgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICB9LFxuXHQgIHJ1bGVzX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5fdmFsaWRhdGVfaW5pdF9vbmNlKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGNsZWFyVmFsaWRhdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kYXRhLmNsZWFyTWFyayhcIndlYml4X2ludmFsaWRcIiwgdHJ1ZSk7XG5cdCAgfSxcblx0ICB2YWxpZGF0ZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblx0ICAgIGlmICghaWQpIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEucHVsbCkge1xuXHQgICAgICByZXN1bHQgPSB0aGlzLnZhbGlkYXRlKGtleSkgJiYgcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fdmFsaWRhdGVfZGV0YWlscyA9IHt9O1xuXHQgICAgICB2YXIgb2JqID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgICAgcmVzdWx0ID0gVmFsaWRhdGVEYXRhLnZhbGlkYXRlLmNhbGwodGhpcywgbnVsbCwgb2JqKTtcblxuXHQgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25WYWxpZGF0aW9uU3VjY2Vzc1wiLCBbaWQsIG9ial0pKSB0aGlzLl9jbGVhcl9pbnZhbGlkKGlkKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvblZhbGlkYXRpb25FcnJvclwiLCBbaWQsIG9iaiwgdGhpcy5fdmFsaWRhdGVfZGV0YWlsc10pKSB0aGlzLl9tYXJrX2ludmFsaWQoaWQsIHRoaXMuX3ZhbGlkYXRlX2RldGFpbHMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0sXG5cdCAgX3ZhbGlkYXRlOiBmdW5jdGlvbiAocnVsZSwgZGF0YSwgb2JqLCBrZXkpIHtcblx0ICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcInN0cmluZ1wiKSBydWxlID0gcnVsZXNbcnVsZV07XG5cdCAgICB2YXIgcmVzID0gcnVsZS5jYWxsKHRoaXMsIGRhdGEsIG9iaiwga2V5KTtcblxuXHQgICAgaWYgKCFyZXMpIHtcblx0ICAgICAgdGhpcy5fdmFsaWRhdGVfZGV0YWlsc1trZXldID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9LFxuXHQgIF9jbGVhcl9pbnZhbGlkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMuZGF0YS5yZW1vdmVNYXJrKGlkLCBcIndlYml4X2ludmFsaWRcIiwgdHJ1ZSk7XG5cdCAgfSxcblx0ICBfbWFya19pbnZhbGlkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMuZGF0YS5hZGRNYXJrKGlkLCBcIndlYml4X2ludmFsaWRcIiwgdHJ1ZSk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBWYWx1ZXMgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcblx0ICB9LFxuXHQgIGZvY3VzOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgaWYgKG5hbWUpIHtcblx0ICAgICAgYXNzZXJ0KHRoaXMuZWxlbWVudHNbbmFtZV0sIFwidW5rbm93biBpbnB1dCBuYW1lOiBcIiArIG5hbWUpO1xuXG5cdCAgICAgIHRoaXMuX2ZvY3VzKHRoaXMuZWxlbWVudHNbbmFtZV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmVsZW1lbnRzKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2ZvY3VzKHRoaXMuZWxlbWVudHNbbl0pICE9PSBmYWxzZSkgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgX2ZvY3VzOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5mb2N1cykge1xuXHQgICAgICByZXR1cm4gdGFyZ2V0LmZvY3VzKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9LFxuXHQgIHNldFZhbHVlczogZnVuY3Rpb24gKGRhdGEsIHVwZGF0ZSkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNvbXBsZXhEYXRhKSBkYXRhID0gQ29kZVBhcnNlci5jb2xsYXBzZU5hbWVzKGRhdGEpO1xuXG5cdCAgICB0aGlzLl9pbm5lcl9zZXRWYWx1ZXMoZGF0YSwgdXBkYXRlKTtcblx0ICB9LFxuXHQgIF9pbm5lcl9zZXRWYWx1ZXM6IGZ1bmN0aW9uIChkYXRhLCB1cGRhdGUpIHtcblx0ICAgIHRoaXMuX2lzX2Zvcm1fZGlydHkgPSB1cGRhdGU7IC8vcHJldmVudCBvbkNoYW5nZSBjYWxscyBmcm9tIHNlcGFyYXRlIGNvbnRyb2xzXG5cblx0ICAgIHRoaXMuYmxvY2tFdmVudCgpO1xuXHQgICAgaWYgKCF1cGRhdGUgfHwgIXRoaXMuX3ZhbHVlcykgdGhpcy5fdmFsdWVzID0ge307XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gZGF0YSkge1xuXHQgICAgICBpZiAoIXRoaXMuZWxlbWVudHNbbmFtZV0pIHRoaXMuX3ZhbHVlc1tuYW1lXSA9IGRhdGFbbmFtZV07XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIF9uYW1lIGluIHRoaXMuZWxlbWVudHMpIHtcblx0ICAgICAgdmFyIGlucHV0ID0gdGhpcy5lbGVtZW50c1tfbmFtZV07XG5cblx0ICAgICAgaWYgKGlucHV0KSB7XG5cdCAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkYXRhW19uYW1lXSkpIGlucHV0LnNldFZhbHVlKGRhdGFbX25hbWVdKTtlbHNlIGlmICghdXBkYXRlICYmIGlucHV0LiRhbGxvd3NDbGVhcikgaW5wdXQuc2V0VmFsdWUoXCJcIik7XG5cdCAgICAgICAgdGhpcy5fdmFsdWVzW19uYW1lXSA9IGlucHV0LmdldFZhbHVlKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy51bmJsb2NrRXZlbnQoKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25WYWx1ZXNcIiwgW10pO1xuXHQgIH0sXG5cdCAgaXNEaXJ0eTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX2lzX2Zvcm1fZGlydHkpIHJldHVybiB0cnVlO1xuXHQgICAgaWYgKHRoaXMuZ2V0RGlydHlWYWx1ZXMoMSkgPT09IDEpIHJldHVybiB0cnVlO1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgc2V0RGlydHk6IGZ1bmN0aW9uIChmbGFnKSB7XG5cdCAgICB0aGlzLl9pc19mb3JtX2RpcnR5ID0gZmxhZztcblx0ICAgIGlmICghZmxhZykgdGhpcy5fdmFsdWVzID0gdGhpcy5faW5uZXJfZ2V0VmFsdWVzKCk7XG5cdCAgfSxcblx0ICBnZXREaXJ0eVZhbHVlczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG5cdCAgICBpZiAodGhpcy5fdmFsdWVzKSB7XG5cdCAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5lbGVtZW50cykge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZWxlbWVudHNbbmFtZV0uZ2V0VmFsdWUoKTtcblxuXHQgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbbmFtZV0gIT0gdmFsdWUpIHtcblx0ICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlOyAvL0ZJWE1FIC0gdXNlZCBieSBpc0RpcnR5XG5cblx0ICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0pIHJldHVybiAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0sXG5cdCAgZ2V0Q2xlYW5WYWx1ZXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZXM6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5faW5uZXJfZ2V0VmFsdWVzKGZpbHRlcik7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jb21wbGV4RGF0YSkgZGF0YSA9IENvZGVQYXJzZXIuZXhwYW5kTmFtZXMoZGF0YSk7XG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIF9pbm5lcl9nZXRWYWx1ZXM6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcblx0ICAgIC8vZ2V0IG9yaWdpbmFsIGRhdGFcdFx0XG5cdCAgICB2YXIgc3VjY2Vzcyxcblx0ICAgICAgICBlbGVtID0gbnVsbCxcblx0ICAgICAgICBkYXRhID0gdGhpcy5fdmFsdWVzID8gY29weSh0aGlzLl92YWx1ZXMpIDoge307IC8vdXBkYXRlIHByb3BlcnRpZXMgZnJvbSBsaW5rZWQgY29udHJvbHNcblxuXHQgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmVsZW1lbnRzKSB7XG5cdCAgICAgIGVsZW0gPSB0aGlzLmVsZW1lbnRzW25hbWVdO1xuXHQgICAgICBzdWNjZXNzID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoZmlsdGVyKSB7XG5cdCAgICAgICAgaWYgKF90eXBlb2YoZmlsdGVyKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICBpZiAoZmlsdGVyLmhpZGRlbiA9PT0gZmFsc2UpIHN1Y2Nlc3MgPSBlbGVtLmlzVmlzaWJsZSgpO1xuXHQgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgZmlsdGVyLmRpc2FibGVkID09PSBmYWxzZSkgc3VjY2VzcyA9IGVsZW0uaXNFbmFibGVkKCk7XG5cdCAgICAgICAgfSBlbHNlIHN1Y2Nlc3MgPSBmaWx0ZXIuY2FsbCh0aGlzLCBlbGVtKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzdWNjZXNzKSBkYXRhW25hbWVdID0gZWxlbS5nZXRWYWx1ZSgpO2Vsc2UgZGVsZXRlIGRhdGFbbmFtZV07IC8vaW4gY2FzZSBvZiB0aGlzLl92YWx1ZXNbbmFtZV1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfSxcblx0ICBjbGVhcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5faXNfZm9ybV9kaXJ0eSA9IGZhbHNlO1xuXHQgICAgdmFyIGRhdGEgPSB7fTtcblxuXHQgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmVsZW1lbnRzKSB7XG5cdCAgICAgIGlmICh0aGlzLmVsZW1lbnRzW25hbWVdLiRhbGxvd3NDbGVhcikgZGF0YVtuYW1lXSA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lubmVyX3NldFZhbHVlcyhkYXRhKTtcblx0ICB9LFxuXHQgIG1hcmtJbnZhbGlkOiBmdW5jdGlvbiAobmFtZSwgc3RhdGUpIHtcblx0ICAgIC8vIHJlbW92ZSAnaW52YWxpZCcgbWFya1xuXHQgICAgaWYgKHN0YXRlID09PSBmYWxzZSkge1xuXHQgICAgICB0aGlzLl9jbGVhcl9pbnZhbGlkKG5hbWUpO1xuXHQgICAgfSAvLyBhZGQgJ2ludmFsaWQnIG1hcmtcblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIC8vIHNldCBpbnZhbGlkTWVzc2FnZVxuXHQgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5lbGVtZW50c1tuYW1lXTtcblx0ICAgICAgICAgIGlmIChpbnB1dCkgaW5wdXQuX3NldHRpbmdzLmludmFsaWRNZXNzYWdlID0gc3RhdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbWFya19pbnZhbGlkKG5hbWUpO1xuXHQgICAgICB9XG5cdCAgfSxcblx0ICBfbWFya19pbnZhbGlkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuXG5cdCAgICBpZiAoaWQgJiYgaW5wdXQpIHtcblx0ICAgICAgdGhpcy5fY2xlYXJfaW52YWxpZChpZCwgdHJ1ZSk7XG5cblx0ICAgICAgYWRkQ3NzKGlucHV0Ll92aWV3b2JqLCBcIndlYml4X2ludmFsaWRcIik7XG5cdCAgICAgIGlucHV0Ll9zZXR0aW5ncy5pbnZhbGlkID0gdHJ1ZTtcblx0ICAgICAgdmFyIG1lc3NhZ2UgPSBpbnB1dC5fc2V0dGluZ3MuaW52YWxpZE1lc3NhZ2U7XG5cdCAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJiBpbnB1dC5zZXRCb3R0b21UZXh0KSBpbnB1dC5zZXRCb3R0b21UZXh0KCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2xlYXJfaW52YWxpZDogZnVuY3Rpb24gKGlkLCBzaWxlbnQpIHtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuXG5cdCAgICBpZiAoaWQgJiYgaW5wdXQgJiYgaW5wdXQuJHZpZXcgJiYgaW5wdXQuX3NldHRpbmdzLmludmFsaWQpIHtcblx0ICAgICAgcmVtb3ZlQ3NzKGlucHV0Ll92aWV3b2JqLCBcIndlYml4X2ludmFsaWRcIik7XG5cdCAgICAgIGlucHV0Ll9zZXR0aW5ncy5pbnZhbGlkID0gZmFsc2U7XG5cdCAgICAgIHZhciBtZXNzYWdlID0gaW5wdXQuX3NldHRpbmdzLmludmFsaWRNZXNzYWdlO1xuXHQgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgIXNpbGVudCAmJiBpbnB1dC5zZXRCb3R0b21UZXh0KSBpbnB1dC5zZXRCb3R0b21UZXh0KCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdFx0UmVuZGVycyBjb2xsZWN0aW9uIG9mIGl0ZW1zXG5cdFx0QWx3YXlzIHNob3dzIHktc2Nyb2xsXG5cdFx0Q2FuIGJlIHVzZWQgd2l0aCBodWdlIGRhdGFzZXRzXG5cdFx0XG5cdFx0QGV4cG9ydFxuXHRcdFx0c2hvd1xuXHRcdFx0cmVuZGVyXG5cdCovXG5cblx0dmFyIFZpcnR1YWxSZW5kZXJTdGFjayA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVuZGVyLCBcIlZpcnR1YWxSZW5kZXJTdGFjayA6OiBPYmplY3QgbXVzdCB1c2UgUmVuZGVyU3RhY2sgZmlyc3RcIik7XG5cdCAgICB0aGlzLl9odG1sbWFwID0ge307IC8vaW5pdCBtYXAgb2YgcmVuZGVyZWQgZWxlbWVudHNcblx0ICAgIC8vd2UgbmVlZCB0byByZXBhaW50IGFyZWEgZWFjaCB0aW1lIHdoZW4gdmlldyByZXNpemVkIG9yIHNjcm9sbGluZyBzdGF0ZSBpcyBjaGFuZ2VkXG5cblx0ICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcInNjcm9sbFwiLCBiaW5kKHRoaXMuX3JlbmRlcl92aXNpYmxlX3Jvd3MsIHRoaXMpKTtcblxuXHQgICAgaWYgKGVudi50b3VjaCkge1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlclNjcm9sbFwiLCBiaW5kKHRoaXMuX3JlbmRlcl92aXNpYmxlX3Jvd3MsIHRoaXMpKTtcblx0ICAgIH0gLy9oZXJlIHdlIHN0b3JlIElEcyBvZiBlbGVtZW5zdCB3aGljaCBkb2Vzbid0IGxvYWRlZGUgeWV0LCBidXQgbmVlZCB0byBiZSByZW5kZXJlZFxuXG5cblx0ICAgIHRoaXMuX3VucmVuZGVyZWRfYXJlYSA9IFtdO1xuXHQgIH0sXG5cdCAgLy9yZXR1cm4gaHRtbCBvYmplY3QgYnkgaXRlbSdzIElELiBDYW4gcmV0dXJuIG51bGwgZm9yIG5vdC1yZW5kZXJpbmcgZWxlbWVudFxuXHQgIGdldEl0ZW1Ob2RlOiBmdW5jdGlvbiAoc2VhcmNoX2lkKSB7XG5cdCAgICAvL2NvbGxlY3Rpb24gd2FzIGZpbGxlZCBpbiBfcmVuZGVyX3Zpc2libGVfcm93c1xuXHQgICAgcmV0dXJuIHRoaXMuX2h0bWxtYXBbc2VhcmNoX2lkXTtcblx0ICB9LFxuXHQgIC8vYWRqdXN0IHNjcm9sbHMgdG8gbWFrZSBpdGVtIHZpc2libGVcblx0ICBzaG93SXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgcmFuZ2UgPSB0aGlzLl9nZXRWaXNpYmxlUmFuZ2UoKTtcblxuXHQgICAgdmFyIGluZCA9IHRoaXMuZGF0YS5nZXRJbmRleEJ5SWQoaWQpOyAvL3dlIGNhbid0IHVzZSBET00gbWV0aG9kIGZvciBub3QtcmVuZGVyZWQteWV0IGl0ZW1zLCBzbyBmYWxsYmFjayB0byBwdXJlIG1hdGhcblxuXHQgICAgdmFyIGR5ID0gTWF0aC5mbG9vcihpbmQgLyByYW5nZS5fZHgpICogcmFuZ2UuX3k7XG5cblx0ICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblx0ICAgIGlmIChkeSA8IHN0YXRlLnkgfHwgZHkgKyB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgPj0gc3RhdGUueSArIHRoaXMuX2NvbnRlbnRfaGVpZ2h0KSB0aGlzLnNjcm9sbFRvKDAsIGR5KTtcblx0ICB9LFxuXHQgIC8vcmVwYWluIHNlbGYgYWZ0ZXIgY2hhbmdlcyBpbiBET01cblx0ICAvL2ZvciBhZGQsIGRlbGV0ZSwgbW92ZSBvcGVyYXRpb25zIC0gcmVuZGVyIGlzIGRlbGF5ZWQsIHRvIG1pbmlmeSBwZXJmb3JtYW5jZSBpbXBhY3Rcblx0ICByZW5kZXI6IGZ1bmN0aW9uIChpZCwgZGF0YSwgdHlwZSkge1xuXHQgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSh0aGlzLl9zZXR0aW5ncy5pZCkgfHwgdGhpcy4kYmxvY2tSZW5kZXIpIHJldHVybjtcblxuXHQgICAgaWYgKGlkKSB7XG5cdCAgICAgIHZhciBjb250ID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7IC8vb2xkIGh0bWwgZWxlbWVudFxuXG5cdCAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcblx0ICAgICAgICAgIGlmICghY29udCkgcmV0dXJuOyAvL3JlcGxhY2Ugb2xkIHdpdGggbmV3XG5cblx0ICAgICAgICAgIHZhciB0ID0gdGhpcy5faHRtbG1hcFtpZF0gPSB0aGlzLl90b0hUTUxPYmplY3QoZGF0YSk7XG5cblx0ICAgICAgICAgIGluc2VydEJlZm9yZSh0LCBjb250KTtcblx0ICAgICAgICAgIHJlbW92ZShjb250KTtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIC8vIFwibW92ZVwiLCBcImFkZFwiLCBcImRlbGV0ZVwiXG5cblx0ICAgICAgICAgIC8qXG5cdCAgICAgICAgICBcdGZvciBhbGwgYWJvdmUgb3BlcmF0aW9ucywgZnVsbCByZXBhaW50aW5nIGlzIG5lY2Vzc2FyeVxuXHQgICAgICAgICAgXHRidXQgZnJvbSBwcmFjdGljYWwgcG9pbnQgb2Ygdmlldywgd2UgbmVlZCBvbmx5IG9uZSByZXBhaW50aW5nIHBlciB0aHJlYWRcblx0ICAgICAgICAgIFx0Y29kZSBiZWxvdyBpbml0aWF0ZXMgZG91YmxlLXRocmVhZC1yZW5kZXJpbmcgdHJpY2tcblx0ICAgICAgICAgICovXG5cdCAgICAgICAgICB0aGlzLl9yZW5kZXJfZGVsYXllZCgpO1xuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy9mdWxsIHJlcGFpbnRpbmdcblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVSZW5kZXJcIiwgW3RoaXMuZGF0YV0pKSB7XG5cdCAgICAgICAgdGhpcy5faHRtbG1hcCA9IHt9OyAvL251bGlmeSBsaW5rcyB0byBhbHJlYWR5IHJlbmRlcmVkIGVsZW1lbnRzXG5cblx0ICAgICAgICB0aGlzLl9yZW5kZXJfdmlzaWJsZV9yb3dzKG51bGwsIHRydWUpOyAvLyBjbGVhciBkZWxheWVkLXJlbmRlcmluZywgYmVjYXVzZSB3ZSBhbHJlYWR5IGhhdmUgcmVwYWludCB2aWV3XG5cblxuXHQgICAgICAgIHRoaXMuX3dhaXRfZm9yX3JlbmRlciA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclJlbmRlclwiLCBbXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vaW1wbGVtZW50IGRvdWJsZS10aHJlYWQtcmVuZGVyaW5nIHBhdHRlcm5cblx0ICBfcmVuZGVyX2RlbGF5ZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vdGhpcyBmbGFnIGNhbiBiZSByZXNldCBmcm9tIG91dHNpZGUsIHRvIHByZXZlbnQgYWN0dWFsIHJlbmRlcmluZyBcblx0ICAgIGlmICh0aGlzLl93YWl0X2Zvcl9yZW5kZXIpIHJldHVybjtcblx0ICAgIHRoaXMuX3dhaXRfZm9yX3JlbmRlciA9IHRydWU7XG5cdCAgICB3aW5kb3cuc2V0VGltZW91dChiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIH0sIHRoaXMpLCAxKTtcblx0ICB9LFxuXHQgIC8vY3JlYXRlIGVtcHR5IHBsYWNlaG9sZGVycywgd2hpY2ggd2lsbCB0YWtlIHNwYWNlIGJlZm9yZSByZW5kZXJpbmdcblx0ICBfY3JlYXRlX3BsYWNlaG9sZGVyOiBmdW5jdGlvbiAoaGVpZ2h0KSB7XG5cdCAgICBpZiAoZW52Lm1heEhUTUxFbGVtZW50U2l6ZSkgaGVpZ2h0ID0gTWF0aC5taW4oZW52Lm1heEhUTUxFbGVtZW50U2l6ZSwgaGVpZ2h0KTtcblx0ICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcblx0ICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IFwiaGVpZ2h0OlwiICsgaGVpZ2h0ICsgXCJweDsgd2lkdGg6MTAwJTsgb3ZlcmZsb3c6aGlkZGVuO1wiO1xuXHQgICAgcmV0dXJuIG5vZGU7XG5cdCAgfSxcblxuXHQgIC8qXG5cdCAgXHRNZXRob2RzIGdldCBjb29yZGluYXRlc3Qgb2YgdmlzaWJsZSBhcmVhIGFuZCBjaGVja3MgdGhhdCBhbGwgcmVsYXRlZCBpdGVtcyBhcmUgcmVuZGVyZWRcblx0ICBcdElmLCBkdXJpbmcgcmVuZGVyaW5nLCBzb21lIG5vdC1sb2FkZWQgaXRlbXMgd2FzIGRldGVjdGVkIC0gZXh0cmEgZGF0YSBsb2FkaW5nIGlzIGluaXRpYXRlZC5cblx0ICBcdHJlc2V0IC0gZmxhZywgd2hpY2ggZm9yY2VzIGNsZWFyaW5nIG9mIHByZXZpb3VzbHkgcmVuZGVyZWQgZWxlbWVudHNcblx0ICAqL1xuXHQgIF9yZW5kZXJfdmlzaWJsZV9yb3dzOiBmdW5jdGlvbiAoZSwgcmVzZXQpIHtcblx0ICAgIHRoaXMuX3VucmVuZGVyZWRfYXJlYSA9IFtdOyAvL2NsZWFyIHJlc3VsdHMgb2YgcHJldmlvdXMgY2FsbHNcblxuXHQgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fZ2V0VmlzaWJsZVJhbmdlKCk7IC8vZGV0YWlscyBvZiB2aXNpYmxlIHZpZXdcblxuXG5cdCAgICBpZiAoIXRoaXMuX2RhdGFvYmouZmlyc3RDaGlsZCB8fCByZXNldCkge1xuXHQgICAgICAvL2NyZWF0ZSBpbml0aWFsIHBsYWNlaG9sZGVyIC0gZm9yIGFsbCB2aWV3IHNwYWNlXG5cdCAgICAgIHRoaXMuX2RhdGFvYmouaW5uZXJIVE1MID0gXCJcIjtcblxuXHQgICAgICB0aGlzLl9kYXRhb2JqLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZV9wbGFjZWhvbGRlcih2aWV3cG9ydC5fbWF4KSk7IC8vcmVnaXN0ZXIgcGxhY2Vob2xkZXIgaW4gY29sbGVjdGlvblxuXG5cblx0ICAgICAgdGhpcy5faHRtbHJvd3MgPSBbdGhpcy5fZGF0YW9iai5maXJzdENoaWxkXTtcblx0ICAgIH1cblx0ICAgIC8qXG5cdCAgICBcdHZpcnR1YWwgcmVuZGVyaW5nIGJyZWFrcyBhbGwgdmlldyBvbiByb3dzLCBiZWNhdXNlIHdlIGtub3cgd2lkaHQgb2YgaXRlbVxuXHQgICAgXHR3ZSBjYW4gY2FsY3VsYXRlIGhvdyBtdWNoIGl0ZW1zIGNhbiBiZSBwbGFjZWQgb24gc2luZ2xlIHJvdywgYW5kIGtub3dsZWRnZSBcblx0ICAgIFx0b2YgdGhhdCwgYWxsb3dzIHRvIGNhbGN1bGF0ZSBjb3VudCBvZiBzdWNoIHJvd3Ncblx0ICAgIFx0XG5cdCAgICBcdGVhY2ggdGltZSBhZnRlciBzY3JvbGxpbmcsIGNvZGUgaXRlcmF0ZSB0aHJvdWdoIHZpc2libGUgcm93cyBhbmQgcmVuZGVyIGl0ZW1zIFxuXHQgICAgXHRpbiB0aGVtLCBpZiB0aGV5IGFyZSBub3QgcmVuZGVyZWQgeWV0XG5cdCAgICBcdFxuXHQgICAgXHRib3RoIHJlbmRlcmVkIHJvd3MgYW5kIHBsYWNlaG9sZGVycyBhcmUgcmVnaXN0ZXJlZCBpbiBfaHRtbHJvd3MgY29sbGVjdGlvblxuXHQgICAgKi9cblx0ICAgIC8vcG9zaXRpb24gb2YgZmlyc3QgdmlzaWJsZSByb3dcblxuXG5cdCAgICB2YXIgdCA9IHZpZXdwb3J0Ll9mcm9tO1xuXG5cdCAgICB3aGlsZSAodCA8PSB2aWV3cG9ydC5faGVpZ2h0KSB7XG5cdCAgICAgIC8vbG9vcCBmb3IgYWxsIHZpc2libGUgcm93c1xuXHQgICAgICAvL3NraXAgYWxyZWFkeSByZW5kZXJlZCByb3dzXG5cdCAgICAgIHdoaWxlICh0aGlzLl9odG1scm93c1t0XSAmJiB0aGlzLl9odG1scm93c1t0XS5fZmlsbGVkICYmIHQgPD0gdmlld3BvcnQuX2hlaWdodCkge1xuXHQgICAgICAgIHQrKztcblx0ICAgICAgfSAvL2dvIG91dCBpZiBhbGwgaXMgcmVuZGVyZWRcblxuXG5cdCAgICAgIGlmICh0ID4gdmlld3BvcnQuX2hlaWdodCkgYnJlYWs7IC8vbG9jYXRlIG5lYXJlc3QgcGxhY2Vob2xkZXJcblxuXHQgICAgICB2YXIgaG9sZGVyID0gdDtcblxuXHQgICAgICB3aGlsZSAoIXRoaXMuX2h0bWxyb3dzW2hvbGRlcl0pIHtcblx0ICAgICAgICBob2xkZXItLTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBob2xkZXJfcm93ID0gdGhpcy5faHRtbHJvd3NbaG9sZGVyXTsgLy9yZW5kZXIgZWxlbWVudHMgaW4gdGhlIHJvd1x0XHRcdFxuXG5cdCAgICAgIHZhciBiYXNlID0gdCAqIHZpZXdwb3J0Ll9keCArICh0aGlzLmRhdGEuJG1pbiB8fCAwKTsgLy9pbmRleCBvZiByZW5kZXJlZCBpdGVtXG5cblx0ICAgICAgaWYgKGJhc2UgPiAodGhpcy5kYXRhLiRtYXggfHwgSW5maW5pdHkpKSBicmVhazsgLy9jaGVjayB0aGF0IHJvdyBpcyBpbiB2aXJ0dWFsIGJvdW5kcywgZGVmaW5lZCBieSBwYWdpbmdcblxuXHQgICAgICB2YXIgbmV4dHBvaW50ID0gTWF0aC5taW4oYmFzZSArIHZpZXdwb3J0Ll9keCAtIDEsIHRoaXMuZGF0YS4kbWF4ID8gdGhpcy5kYXRhLiRtYXggLSAxIDogSW5maW5pdHkpO1xuXG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5fY3JlYXRlX3BsYWNlaG9sZGVyKHZpZXdwb3J0Ll95KTsgLy9hbGwgaXRlbXMgaW4gcmVuZGVyZWQgcm93XG5cblxuXHQgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmRhdGEuZ2V0SW5kZXhSYW5nZShiYXNlLCBuZXh0cG9pbnQpO1xuXHQgICAgICBpZiAoIXJhbmdlLmxlbmd0aCkgYnJlYWs7XG5cdCAgICAgIHZhciBsb2FkaW5nID0ge1xuXHQgICAgICAgICR0ZW1wbGF0ZTogXCJMb2FkaW5nXCJcblx0ICAgICAgfTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKCFyYW5nZVtpXSkgdGhpcy5fdW5yZW5kZXJlZF9hcmVhLnB1c2goYmFzZSArIGkpO1xuXHQgICAgICAgIHJhbmdlW2ldID0gdGhpcy5fdG9IVE1MKHJhbmdlW2ldIHx8IGxvYWRpbmcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZS5pbm5lckhUTUwgPSByYW5nZS5qb2luKFwiXCIpOyAvL2FjdHVhbCByZW5kZXJpbmdcblxuXHQgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmFuZ2UubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgLy9yZWdpc3RlciBhbGwgbmV3IGVsZW1lbnRzIGZvciBsYXRlciB1c2FnZSBpbiBnZXRJdGVtTm9kZVxuXHQgICAgICAgIHRoaXMuX2h0bWxtYXBbdGhpcy5kYXRhLmdldElkQnlJbmRleChiYXNlICsgX2kpXSA9IG5vZGUuY2hpbGROb2Rlc1tfaV07XG5cdCAgICAgIH0gLy9jb3JyZWN0IHBsYWNlaG9sZGVyc1xuXG5cblx0ICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KGhvbGRlcl9yb3cuc3R5bGUuaGVpZ2h0LCAxMCk7XG5cdCAgICAgIHZhciBkZWx0YSA9ICh0IC0gaG9sZGVyKSAqIHZpZXdwb3J0Ll95O1xuXHQgICAgICB2YXIgZGVsdGEyID0gaCAtIGRlbHRhIC0gdmlld3BvcnQuX3k7IC8vYWRkIG5ldyByb3cgdG8gdGhlIERPT01cblxuXHQgICAgICBpbnNlcnRCZWZvcmUobm9kZSwgZGVsdGEgPyBob2xkZXJfcm93Lm5leHRTaWJsaW5nIDogaG9sZGVyX3JvdywgdGhpcy5fZGF0YW9iaik7XG5cdCAgICAgIHRoaXMuX2h0bWxyb3dzW3RdID0gbm9kZTtcblx0ICAgICAgbm9kZS5fZmlsbGVkID0gdHJ1ZTtcblx0ICAgICAgLypcblx0ICAgICAgXHRpZiBuZXcgcm93IGlzIGF0IHN0YXJ0IG9mIHBsYWNlaG9sZGVyIC0gZGVjcmVhc2UgcGxhY2Vob2xkZXIncyBoZWlnaHRcblx0ICAgICAgXHRlbHNlIGlmIG5ldyByb3cgdGFrZXMgd2hvbGUgcGxhY2Vob2xkZXIgLSByZW1vdmUgcGxhY2Vob2xkZXIgZnJvbSBET01cblx0ICAgICAgXHRlbHNlIFxuXHQgICAgICBcdFx0d2UgYXJlIGluc2VydGluZyByb3cgaW4gdGhlIG1pZGRsZSBvZiBleGlzdGluZyBwbGFjZWhvbGRlclxuXHQgICAgICBcdFx0ZGVjcmVhc2UgaGVpZ2h0IG9mIGV4aXN0aW5nIG9uZSwgYW5kIGFkZCBvbmUgbW9yZSwgXG5cdCAgICAgIFx0XHRiZWZvcmUgdGhlIG5ld2x5IGFkZGVkIHJvd1xuXHQgICAgICAqL1xuXG5cdCAgICAgIGlmIChkZWx0YSA8PSAwICYmIGRlbHRhMiA+IDApIHtcblx0ICAgICAgICBob2xkZXJfcm93LnN0eWxlLmhlaWdodCA9IGRlbHRhMiArIFwicHhcIjtcblx0ICAgICAgICB0aGlzLl9odG1scm93c1t0ICsgMV0gPSBob2xkZXJfcm93O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChkZWx0YSA8IDApIHJlbW92ZShob2xkZXJfcm93KTtlbHNlIGhvbGRlcl9yb3cuc3R5bGUuaGVpZ2h0ID0gZGVsdGEgKyBcInB4XCI7XG5cblx0ICAgICAgICBpZiAoZGVsdGEyID4gMCkge1xuXHQgICAgICAgICAgdmFyIG5ld19zcGFjZSA9IHRoaXMuX2h0bWxyb3dzW3QgKyAxXSA9IHRoaXMuX2NyZWF0ZV9wbGFjZWhvbGRlcihkZWx0YTIpO1xuXG5cdCAgICAgICAgICBpbnNlcnRCZWZvcmUobmV3X3NwYWNlLCBub2RlLm5leHRTaWJsaW5nLCB0aGlzLl9kYXRhb2JqKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0Kys7XG5cdCAgICB9IC8vd2hlbiBhbGwgZG9uZSwgY2hlY2sgZm9yIG5vbi1sb2FkZWQgaXRlbXNcblxuXG5cdCAgICBpZiAodGhpcy5fdW5yZW5kZXJlZF9hcmVhLmxlbmd0aCkge1xuXHQgICAgICAvL3dlIGhhdmUgc29tZSBkYXRhIHRvIGxvYWRcblx0ICAgICAgLy9kZXRlY3QgYm9yZGVyc1xuXHQgICAgICB2YXIgZnJvbSA9IHRoaXMuX3VucmVuZGVyZWRfYXJlYVswXTtcblx0ICAgICAgdmFyIHRvID0gdGhpcy5fdW5yZW5kZXJlZF9hcmVhLnBvcCgpICsgMTtcblxuXHQgICAgICBpZiAodG8gPiBmcm9tKSB7XG5cdCAgICAgICAgLy9pbml0aWF0ZSBkYXRhIGxvYWRpbmdcblx0ICAgICAgICB2YXIgY291bnQgPSB0byAtIGZyb207XG5cdCAgICAgICAgaWYgKHRoaXMuX21heWJlX2xvYWRpbmdfYWxyZWFkeShjb3VudCwgZnJvbSkpIHJldHVybjtcblx0ICAgICAgICBjb3VudCA9IE1hdGgubWF4KGNvdW50LCB0aGlzLl9zZXR0aW5ncy5kYXRhZmV0Y2ggfHwgdGhpcy5fc2V0dGluZ3MubG9hZGFoZWFkIHx8IDApO1xuXHQgICAgICAgIHRoaXMubG9hZE5leHQoY291bnQsIGZyb20pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2NhbGN1bGF0ZXMgdmlzaWJsZSB2aWV3XG5cdCAgX2dldFZpc2libGVSYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpO1xuXHQgICAgdmFyIHRvcCA9IE1hdGgubWF4KDAsIHN0YXRlLnkpO1xuXHQgICAgdmFyIHdpZHRoID0gdGhpcy5fY29udGVudF93aWR0aDtcblx0ICAgIHZhciBoZWlnaHQgPSB0aGlzLl9jb250ZW50X2hlaWdodDsgLy9zaXplIG9mIHNpbmdsZSBpdGVtXG5cblx0ICAgIHZhciB0ID0gdGhpcy50eXBlO1xuXHQgICAgdmFyIGR4ID0gTWF0aC5mbG9vcih3aWR0aCAvIHQud2lkdGgpIHx8IDE7IC8vYXQgbGVhc3Qgc2luZ2xlIGl0ZW0gcGVyIHJvd1xuXG5cdCAgICB2YXIgbWluID0gTWF0aC5mbG9vcih0b3AgLyB0LmhlaWdodCk7IC8vaW5kZXggb2YgZmlyc3QgdmlzaWJsZSByb3dcblxuXHQgICAgdmFyIGR5ID0gTWF0aC5jZWlsKChoZWlnaHQgKyB0b3ApIC8gdC5oZWlnaHQpIC0gMTsgLy9pbmRleCBvZiBsYXN0IHZpc2libGUgcm93XG5cdCAgICAvL3RvdGFsIGNvdW50IG9mIGl0ZW1zLCBwYWdpbmcgY2FuIGFmZmVjdCB0aGlzIG1hdGhcblxuXHQgICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhLiRtYXggPyB0aGlzLmRhdGEuJG1heCAtIHRoaXMuZGF0YS4kbWluIDogdGhpcy5kYXRhLmNvdW50KCk7XG5cdCAgICB2YXIgbWF4ID0gTWF0aC5jZWlsKGNvdW50IC8gZHgpICogdC5oZWlnaHQ7IC8vc2l6ZSBvZiB2aWV3IGluIHJvd3NcblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgX2Zyb206IG1pbixcblx0ICAgICAgX2hlaWdodDogZHksXG5cdCAgICAgIF90b3A6IHRvcCxcblx0ICAgICAgX21heDogbWF4LFxuXHQgICAgICBfeTogdC5oZWlnaHQsXG5cdCAgICAgIF9keDogZHhcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfY2VsbFBvc2l0aW9uOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBodG1sID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7XG5cblx0ICAgIGlmICghaHRtbCkge1xuXHQgICAgICB0aGlzLnNob3dJdGVtKGlkKTtcblxuXHQgICAgICB0aGlzLl9yZW5kZXJfdmlzaWJsZV9yb3dzKCk7XG5cblx0ICAgICAgaHRtbCA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBsZWZ0OiBodG1sLm9mZnNldExlZnQsXG5cdCAgICAgIHRvcDogaHRtbC5vZmZzZXRUb3AsXG5cdCAgICAgIGhlaWdodDogaHRtbC5vZmZzZXRIZWlnaHQsXG5cdCAgICAgIHdpZHRoOiBodG1sLm9mZnNldFdpZHRoLFxuXHQgICAgICBwYXJlbnQ6IHRoaXMuX2NvbnRlbnRvYmpcblx0ICAgIH07XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdFx0UmVuZGVycyBjb2xsZWN0aW9uIG9mIGl0ZW1zIG9uIGRlbWFuZFxuXHQqL1xuXG5cdHZhciBWUmVuZGVyU3RhY2sgPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2h0bWxtYXAgPSB7fTtcblxuXHQgICAgaWYgKFRvdWNoLiRhY3RpdmUpIHtcblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9pbl90b3VjaF9zY3JvbGwgPSB0cnVlO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucmVuZGVyKG51bGwsIG51bGwsIFwicGFpbnRcIik7XG5cdCAgICAgICAgdGhpcy5faW5fdG91Y2hfc2Nyb2xsID0gZmFsc2U7XG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25Ub3VjaE1vdmVcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9pbl90b3VjaF9zY3JvbGwpIHtcblx0ICAgICAgICAgIHRoaXMuYmxvY2tFdmVudCgpO1xuXHQgICAgICAgICAgdGhpcy5yZW5kZXIobnVsbCwgbnVsbCwgXCJwYWludFwiKTtcblx0ICAgICAgICAgIHRoaXMudW5ibG9ja0V2ZW50KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcInNjcm9sbFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnJlbmRlcihudWxsLCBudWxsLCBcInBhaW50XCIpO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfc3luY19zY3JvbGw6IGZ1bmN0aW9uICh4LCB5LCB0KSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZm9vdGVyKSBUb3VjaC5fc2V0X21hdHJpeCh0aGlzLl9mb290ZXIuY2hpbGROb2Rlc1sxXS5maXJzdENoaWxkLCB4LCAwLCB0KTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25TeW5jU2Nyb2xsXCIsIFt4LCB5LCB0XSk7XG5cdCAgfSxcblx0ICAvL3JldHVybiBodG1sIGNvbnRhaW5lciBieSBpdHMgSURcblx0ICAvL2NhbiByZXR1cm4gdW5kZWZpbmVkIGlmIGNvbnRhaW5lciBkb2Vzbid0IGV4aXN0c1xuXHQgIGdldEl0ZW1Ob2RlOiBmdW5jdGlvbiAoc2VhcmNoX2lkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5faHRtbG1hcCAmJiB0aGlzLl9odG1sbWFwW3NlYXJjaF9pZF07XG5cdCAgfSxcblxuXHQgIC8qY2hhbmdlIHNjcm9sbGluZyBzdGF0ZSBvZiB0b3AgbGV2ZWwgY29udGFpbmVyLCBzbyByZWxhdGVkIGl0ZW0gd2lsbCBiZSBpbiB2aXNpYmxlIHBhcnQqL1xuXHQgIHNob3dJdGVtOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBpbmRleCQkMSA9IHRoaXMuZGF0YS5nZXRJbmRleEJ5SWQoaWQpO1xuXG5cdCAgICBpZiAoaW5kZXgkJDEgPiAtMSkge1xuXHQgICAgICB2YXIgdG9wID0gaW5kZXgkJDEgKiB0aGlzLnR5cGUuaGVpZ2h0O1xuXHQgICAgICB2YXIgYm90dG9tID0gdG9wICsgdGhpcy50eXBlLmhlaWdodDtcblx0ICAgICAgdmFyIHNjcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblx0ICAgICAgdmFyIGJveCA9IG9mZnNldCh0aGlzLiR2aWV3KTtcblx0ICAgICAgaWYgKHRvcCA8IHNjcm9sbC55KSB0aGlzLnNjcm9sbFRvKDAsIHRvcCk7ZWxzZSBpZiAoYm90dG9tID4gc2Nyb2xsLnkgKyBib3guaGVpZ2h0KSB0aGlzLnNjcm9sbFRvKDAsIGJvdHRvbSAtIGJveC5oZWlnaHQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy91cGRhdGUgdmlldyBhZnRlciBkYXRhIHVwZGF0ZVxuXHQgIC8vd2hlbiBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXJzIC0gYWxsIHZpZXcgcmVmcmVzaGVkXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoaWQsIGRhdGEsIHR5cGUpIHtcblx0ICAgIGlmICghdGhpcy5pc1Zpc2libGUodGhpcy5fc2V0dGluZ3MuaWQpIHx8IHRoaXMuJGJsb2NrUmVuZGVyKSByZXR1cm47XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5fcmVuZGVyb2JqIHx8IHRoaXMuX2RhdGFvYmo7XG5cblx0ICAgIGlmIChpZCkge1xuXHQgICAgICBpZiAodHlwZSA9PSBcInBhaW50XCIgfHwgdHlwZSA9PSBcInVwZGF0ZVwiKSB7XG5cdCAgICAgICAgdmFyIGNvbnQgPSB0aGlzLmdldEl0ZW1Ob2RlKGlkKTsgLy9nZXQgaHRtbCBlbGVtZW50IG9mIHVwZGF0ZWQgaXRlbVxuXG5cdCAgICAgICAgaWYgKGNvbnQpIHtcblx0ICAgICAgICAgIHZhciB0ID0gdGhpcy5faHRtbG1hcFtpZF0gPSB0aGlzLl90b0hUTUxPYmplY3QoZGF0YSk7XG5cblx0ICAgICAgICAgIHQuc3R5bGUudG9wID0gY29udC5zdHlsZS50b3A7XG5cdCAgICAgICAgICB0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHQgICAgICAgICAgdC5zdHlsZS5sZWZ0ID0gMDtcblx0ICAgICAgICAgIHQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcblx0ICAgICAgICAgIGluc2VydEJlZm9yZSh0LCBjb250KTtcblx0ICAgICAgICAgIHJlbW92ZShjb250KTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9IC8vdXBkYXRpbmcgbm90IHJlbmRlcmVkIHlldCBpdGVtXG5cblxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZSAhPSBcInBhaW50XCIpIHtcblx0ICAgICAgLy9yZXBhaW50IGFsbFxuXHQgICAgICB0aGlzLl9odG1sbWFwID0ge307XG5cdCAgICAgIHBhcmVudC5pbm5lckhUTUwgPSBcIlwiO1xuXHQgICAgfSAvL2Z1bGwgcmVzZXRcblxuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGhpcy5kYXRhXSkpIHtcblx0ICAgICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhLmNvdW50KCk7XG5cdCAgICAgIHZhciBzY3JvbGwgPSB0aGlzLmdldFNjcm9sbFN0YXRlKCk7XG5cdCAgICAgIHZhciBib3ggPSBvZmZzZXQodGhpcy5fdmlld29iaik7XG5cdCAgICAgIHZhciB0b3AgPSBNYXRoLmZsb29yKHNjcm9sbC55IC8gdGhpcy50eXBlLmhlaWdodCkgLSAyO1xuXHQgICAgICB2YXIgYm90dG9tID0gTWF0aC5jZWlsKChzY3JvbGwueSArIGJveC5oZWlnaHQpIC8gdGhpcy50eXBlLmhlaWdodCkgKyAyO1xuXHQgICAgICB0b3AgPSBNYXRoLm1heCgwLCB0b3ApO1xuXHQgICAgICBib3R0b20gPSBNYXRoLm1pbih0aGlzLmRhdGEuY291bnQoKSAtIDEsIGJvdHRvbSk7XG5cdCAgICAgIHZhciBodG1sID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IHRvcDsgaSA8PSBib3R0b207IGkrKykge1xuXHQgICAgICAgIHZhciBzaWQgPSB0aGlzLmRhdGEub3JkZXJbaV07XG5cblx0ICAgICAgICBpZiAoIXRoaXMuX2h0bWxtYXBbc2lkXSkge1xuXHQgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGEuZ2V0SXRlbShzaWQpO1xuXG5cdCAgICAgICAgICBpZiAoIWl0ZW0pIHtcblx0ICAgICAgICAgICAgdGhpcy5fcnVuX2xvYWRfbmV4dCh7XG5cdCAgICAgICAgICAgICAgY291bnQ6IGJvdHRvbSAtIGkgKyAodGhpcy5fc2V0dGluZ3MubG9hZGFoZWFkIHx8IDApLFxuXHQgICAgICAgICAgICAgIHN0YXJ0OiBpXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBodG1sLnB1c2godGhpcy5fdG9IVE1MKGl0ZW0pKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaHRtbC5wdXNoKFwiPGRpdj48L2Rpdj5cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5faHRtbC5pbm5lckhUTUwgPSBodG1sLmpvaW4oXCJcIik7XG5cdCAgICAgIHBhcmVudC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0ICAgICAgcGFyZW50LnN0eWxlLmhlaWdodCA9IGNvdW50ICogdGhpcy50eXBlLmhlaWdodCArIFwicHhcIjtcblx0ICAgICAgdmFyIGtpZHMgPSB0aGlzLl9odG1sLmNoaWxkTm9kZXM7XG5cblx0ICAgICAgZm9yICh2YXIgX2kgPSBraWRzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcblx0ICAgICAgICB2YXIgY2hpbGQgPSBraWRzW19pXTtcblx0ICAgICAgICB2YXIgY2lkID0gY2hpbGQuZ2V0QXR0cmlidXRlKHRoaXMuX2lkKTtcblxuXHQgICAgICAgIGlmIChjaWQpIHtcblx0ICAgICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHQgICAgICAgICAgY2hpbGQuc3R5bGUudG9wID0gKHRvcCArIF9pKSAqIHRoaXMudHlwZS5oZWlnaHQgKyBcInB4XCI7XG5cdCAgICAgICAgICBjaGlsZC5zdHlsZS5sZWZ0ID0gMDtcblx0ICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cdCAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHQgICAgICAgICAgdGhpcy5faHRtbG1hcFtjaWRdID0gY2hpbGQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFtdKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuXHQgICAgICB0aGlzLnJlbmRlcihudWxsLCBudWxsLCBcInBhaW50XCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3J1bl9sb2FkX25leHQ6IGZ1bmN0aW9uIChjb25mKSB7XG5cdCAgICB2YXIgY291bnQgPSBNYXRoLm1heChjb25mLmNvdW50LCB0aGlzLl9zZXR0aW5ncy5kYXRhZmV0Y2ggfHwgdGhpcy5fc2V0dGluZ3MubG9hZGFoZWFkIHx8IDApO1xuXHQgICAgaWYgKHRoaXMuX21heWJlX2xvYWRpbmdfYWxyZWFkeShjb25mLmNvdW50LCBjb25mLnN0YXJ0KSkgcmV0dXJuO1xuXHQgICAgdGhpcy5sb2FkTmV4dChjb3VudCwgY29uZi5zdGFydCk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciB2ZXJzaW9uJDEgPSBcIjYuMi4wXCI7XG5cdHZhciBuYW1lJDEgPSBcImNvcmVcIjtcblxuXHR2YXIgZXJyb3JNZXNzYWdlID0gXCJub24tZXhpc3RpbmcgdmlldyBmb3IgZXhwb3J0XCI7XG5cblx0ZnVuY3Rpb24gZ2V0RGF0YUhlbHBlcihrZXksIGNvbHVtbiwgcmF3KSB7XG5cdCAgaWYgKCFyYXcgJiYgY29sdW1uLmZvcm1hdCkgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHJldHVybiBjb2x1bW4uZm9ybWF0KG9ialtrZXldKTtcblx0ICB9O1xuXHQgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICByZXR1cm4gb2JqW2tleV07XG5cdCAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEV4cG9ydFNjaGVtZSh2aWV3LCBvcHRpb25zKSB7XG5cdCAgdmFyIHNjaGVtZSA9IFtdO1xuXHQgIHZhciBoX2NvdW50ID0gMCxcblx0ICAgICAgZl9jb3VudCA9IDA7XG5cdCAgdmFyIGlzVGFibGUgPSB2aWV3LmdldENvbHVtbkNvbmZpZztcblx0ICB2YXIgY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucztcblx0ICB2YXIgcmF3ID0gISFvcHRpb25zLnJhd1ZhbHVlcztcblx0ICBzY2hlbWUuaGVpZ2h0cyA9IHt9O1xuXG5cdCAgaWYgKCFjb2x1bW5zKSB7XG5cdCAgICBpZiAoaXNUYWJsZSkgY29sdW1ucyA9IFtdLmNvbmNhdCh2aWV3Ll9jb2x1bW5zKTtlbHNlIHtcblx0ICAgICAgY29sdW1ucyA9IFtdO1xuXHQgICAgICB2YXIgb2JqID0gdmlldy5kYXRhLnB1bGxbdmlldy5kYXRhLm9yZGVyWzBdXTtcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgaWYgKGtleSAhPT0gXCJpZFwiICYmIGtleVswXSAhPSBcIiRcIikgY29sdW1ucy5wdXNoKHtcblx0ICAgICAgICAgIGlkOiBrZXlcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAoIWNvbHVtbnMubGVuZ3RoKSB7XG5cdCAgICAvL2V4cG9ydCBvcHRpb25zIGFyZSBzZXQgYXMgLSBjb2x1bW5zOnsgcmFuazp0cnVlLCB0aXRsZTp7IGhlYWRlcjpcImN1c3RvbVwifX1cblx0ICAgIHZhciBhcnIgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgX2tleSBpbiBjb2x1bW5zKSB7XG5cdCAgICAgIGFyci5wdXNoKGV4cG9ydHMuZXh0ZW5kKHtcblx0ICAgICAgICBpZDogX2tleVxuXHQgICAgICB9LCBleHBvcnRzLmV4dGVuZCh7fSwgY29sdW1uc1tfa2V5XSkpKTtcblx0ICAgIH1cblxuXHQgICAgY29sdW1ucyA9IGFycjtcblx0ICB9XG5cblx0ICBpZiAob3B0aW9ucy5pZ25vcmUpIGZvciAodmFyIGkgPSBjb2x1bW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICBpZiAob3B0aW9ucy5pZ25vcmVbY29sdW1uc1tpXS5pZF0pIGNvbHVtbnMuc3BsaWNlKGksIDEpO1xuXHQgIH1cblx0ICBpZiAob3B0aW9ucy5pZCkgc2NoZW1lLnB1c2goe1xuXHQgICAgaWQ6IFwiaWRcIixcblx0ICAgIHdpZHRoOiA1MCxcblx0ICAgIGhlYWRlcjogXCIgXCIsXG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqLmlkO1xuXHQgICAgfVxuXHQgIH0pO1xuXG5cdCAgaWYgKG9wdGlvbnMuZmxhdFRyZWUpIHtcblx0ICAgIHZhciBmbGF0S2V5ID0gb3B0aW9ucy5mbGF0VHJlZS5pZDtcblx0ICAgIHZhciBjb3B5JCQxID0gW10uY29uY2F0KG9wdGlvbnMuZmxhdFRyZWUuY29sdW1ucyk7XG5cdCAgICB2YXIgZmlsbCA9IFtdO1xuXHQgICAgdmFyIGZpbGxNb2RlID0gISFvcHRpb25zLmZsYXRUcmVlLmZpbGw7XG5cblx0ICAgIGZvciAodmFyIF9pID0gMTsgX2kgPD0gY29weSQkMS5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgY29weSQkMVtfaSAtIDFdLnRlbXBsYXRlID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgcmV0dXJuIG9iai4kbGV2ZWwgPT0gaSA/IGZpbGxbaV0gPSBvYmpbZmxhdEtleV0gOiBmaWxsTW9kZSAmJiBpIDwgb2JqLiRsZXZlbCA/IGZpbGxbaV0gOiBcIlwiO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0oX2kpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaW5kZXggPSAwO1xuXG5cdCAgICBmb3IgKHZhciBfaTIgPSBjb2x1bW5zLmxlbmd0aCAtIDE7IF9pMiA+PSAwOyBfaTItLSkge1xuXHQgICAgICBpZiAoY29sdW1uc1tfaTJdLmlkID09PSBmbGF0S2V5KSBpbmRleCA9IF9pMjtcblx0ICAgIH1cblxuXHQgICAgY29sdW1ucyA9IFtdLmNvbmNhdChjb2x1bW5zLnNsaWNlKDAsIGluZGV4KSkuY29uY2F0KGNvcHkkJDEpLmNvbmNhdChjb2x1bW5zLnNsaWNlKGluZGV4ICsgMSkpO1xuXHQgIH1cblxuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgY29sdW1ucy5sZW5ndGg7IGorKykge1xuXHQgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbal07XG5cdCAgICB2YXIgX2tleTIgPSBjb2x1bW4uaWQ7XG5cdCAgICBpZiAoY29sdW1uLm5vRXhwb3J0KSBjb250aW51ZTsgLy8gcmF3IG1vZGUgaGFzIHNlbnNlIG9ubHkgZm9yIGRhdGF0YWJsZVxuXHQgICAgLy8gaW4gb3RoZXIgY2FzZXMgd2UgZG9uJ3QgaGF2ZSBidWlsdC1pbiBkYXRhIHRlbXBsYXRlc1xuXG5cdCAgICB2YXIgcmF3Q29sdW1uID0gcmF3ICYmIGlzVGFibGU7XG5cblx0ICAgIGlmIChpc1RhYmxlKSB7XG5cdCAgICAgIHZhciBzb3VyY2VDb2x1bW4gPSB2aWV3Ll9jb2x1bW5zX3B1bGxbX2tleTJdOyAvLyB3aGVuIHRoZXNlJ3Mgbm8gY29sdW1uIHRvIHRha2UgcmF3IGRhdGEgZnJvbSwgb3IgY3VzdG9tIHRlbXBsYXRlIGRlZmluZWQgLSBpZ25vcmUgcmF3IG1vZGVcblxuXHQgICAgICBpZiAoY29sdW1uLnRlbXBsYXRlICYmICghc291cmNlQ29sdW1uIHx8IHNvdXJjZUNvbHVtbi50ZW1wbGF0ZSAhPSBjb2x1bW4udGVtcGxhdGUpKSByYXdDb2x1bW4gPSBmYWxzZTtcblx0ICAgICAgaWYgKHNvdXJjZUNvbHVtbikgY29sdW1uID0gZXhwb3J0cy5leHRlbmQoZXhwb3J0cy5leHRlbmQoe30sIGNvbHVtbiksIHNvdXJjZUNvbHVtbik7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZWNvcmQgPSB7XG5cdCAgICAgIGlkOiBjb2x1bW4uaWQsXG5cdCAgICAgIHRlbXBsYXRlOiByYXdDb2x1bW4gfHwgIWNvbHVtbi50ZW1wbGF0ZSA/IGdldERhdGFIZWxwZXIoX2tleTIsIGNvbHVtbiwgcmF3KSA6IGNvbHVtbi50ZW1wbGF0ZSxcblx0ICAgICAgd2lkdGg6IChjb2x1bW4ud2lkdGggfHwgMjAwKSAqIChvcHRpb25zLmV4cG9ydF9tb2RlID09PSBcImV4Y2VsXCIgPyA4LjQzIC8gNzAgOiAxKSxcblx0ICAgICAgaGVhZGVyOiBjb2x1bW4uaGVhZGVyICE9PSBmYWxzZSA/IGNvbHVtbi5oZWFkZXIgfHwgX2tleTIgOiBcIlwiXG5cdCAgICB9O1xuXG5cdCAgICBpZiAob3B0aW9ucy5leHBvcnRfbW9kZSA9PT0gXCJleGNlbFwiKSB7XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHJlY29yZCwge1xuXHQgICAgICAgIHR5cGU6IGNvbHVtbi5leHBvcnRUeXBlIHx8IFwiXCIsXG5cdCAgICAgICAgZm9ybWF0OiBjb2x1bW4uZXhwb3J0Rm9ybWF0IHx8IFwiXCJcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgcmVjb3JkLmhlYWRlciA9PT0gXCJzdHJpbmdcIikgcmVjb3JkLmhlYWRlciA9IFt7XG5cdCAgICAgIHRleHQ6IHJlY29yZC5oZWFkZXJcblx0ICAgIH1dO2Vsc2UgcmVjb3JkLmhlYWRlciA9IGNvcHkocmVjb3JkLmhlYWRlcik7XG5cblx0ICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJlY29yZC5oZWFkZXIubGVuZ3RoOyBfaTMrKykge1xuXHQgICAgICB2YXIgaGNlbGwgPSByZWNvcmQuaGVhZGVyW19pM10gfHwge307XG5cdCAgICAgIHZhciB0ZXh0ID0gaGNlbGwuY29udGVudElkID8gdmlldy5nZXRIZWFkZXJDb250ZW50KGhjZWxsLmNvbnRlbnRJZCkuZ2V0VmFsdWUodHJ1ZSkgOiBoY2VsbC50ZXh0O1xuXHQgICAgICByZWNvcmQuaGVhZGVyW19pM10gPSAodGV4dCB8fCBcIlwiKS50b1N0cmluZygpLnJlcGxhY2UoLzxbXj5dKj4vZ2ksIFwiXCIpO1xuXHQgICAgfVxuXG5cdCAgICBoX2NvdW50ID0gTWF0aC5tYXgoaF9jb3VudCwgcmVjb3JkLmhlYWRlci5sZW5ndGgpO1xuXG5cdCAgICBpZiAodmlldy5fc2V0dGluZ3MuZm9vdGVyKSB7XG5cdCAgICAgIHZhciBmb290ZXIgPSBjb2x1bW4uZm9vdGVyIHx8IFwiXCI7XG5cdCAgICAgIGlmICh0eXBlb2YgZm9vdGVyID09IFwic3RyaW5nXCIpIGZvb3RlciA9IFt7XG5cdCAgICAgICAgdGV4dDogZm9vdGVyXG5cdCAgICAgIH1dO2Vsc2UgZm9vdGVyID0gY29weShmb290ZXIpO1xuXG5cdCAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGZvb3Rlci5sZW5ndGg7IF9pNCsrKSB7XG5cdCAgICAgICAgaWYgKGZvb3RlcltfaTRdKSBmb290ZXJbX2k0XSA9IGZvb3RlcltfaTRdLmNvbnRlbnRJZCA/IHZpZXcuZ2V0SGVhZGVyQ29udGVudChmb290ZXJbX2k0XS5jb250ZW50SWQpLmdldFZhbHVlKCkgOiBmb290ZXJbX2k0XS50ZXh0O2Vsc2UgZm9vdGVyW19pNF0gPSBcIlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmVjb3JkLmZvb3RlciA9IGZvb3Rlcjtcblx0ICAgICAgZl9jb3VudCA9IE1hdGgubWF4KGZfY291bnQsIHJlY29yZC5mb290ZXIubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgc2NoZW1lLnB1c2gocmVjb3JkKTtcblx0ICB9XG5cblx0ICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzY2hlbWUubGVuZ3RoOyBfaTUrKykge1xuXHQgICAgdmFyIGRpZmYgPSBoX2NvdW50IC0gc2NoZW1lW19pNV0uaGVhZGVyLmxlbmd0aDtcblxuXHQgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaWZmOyBkKyspIHtcblx0ICAgICAgc2NoZW1lW19pNV0uaGVhZGVyLnB1c2goXCJcIik7XG5cdCAgICB9XG5cblx0ICAgIGlmICh2aWV3Ll9zZXR0aW5ncy5mb290ZXIpIHtcblx0ICAgICAgZGlmZiA9IGZfY291bnQgLSBzY2hlbWVbX2k1XS5mb290ZXIubGVuZ3RoO1xuXG5cdCAgICAgIGZvciAodmFyIF9kID0gMDsgX2QgPCBkaWZmOyBfZCsrKSB7XG5cdCAgICAgICAgc2NoZW1lW19pNV0uZm9vdGVyLnB1c2goXCJcIik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc2NoZW1lO1xuXHR9XG5cdGZ1bmN0aW9uIGdldEV4cG9ydERhdGEodmlldywgb3B0aW9ucywgc2NoZW1lKSB7XG5cdCAgdmFyIGZpbHRlckhUTUwgPSAhIW9wdGlvbnMuZmlsdGVySFRNTDtcblx0ICB2YXIgaHRtbEZpbHRlciA9IC88W14+XSo+L2dpO1xuXHQgIHZhciBkYXRhID0gW107XG5cdCAgdmFyIGhlYWRlciwgaGVhZGVycztcblx0ICB2YXIgbW9kZSA9IG9wdGlvbnMuZXhwb3J0X21vZGU7XG5cblx0ICBpZiAoKG1vZGUgPT09IFwiZXhjZWxcIiB8fCBtb2RlID09IFwiY3N2XCIpICYmIG9wdGlvbnMuZG9jSGVhZGVyKSB7XG5cdCAgICBkYXRhID0gW1sob3B0aW9ucy5kb2NIZWFkZXIudGV4dCB8fCBvcHRpb25zLmRvY0hlYWRlcikudG9TdHJpbmcoKV0sIFtcIlwiXV07XG5cdCAgICBpZiAobW9kZSA9PT0gXCJleGNlbFwiICYmIG9wdGlvbnMuZG9jSGVhZGVyLmhlaWdodCkgc2NoZW1lLmhlaWdodHNbMF0gPSBvcHRpb25zLmRvY0hlYWRlci5oZWlnaHQ7XG5cdCAgfVxuXG5cdCAgaWYgKG9wdGlvbnMuaGVhZGVyICE9PSBmYWxzZSAmJiBzY2hlbWUubGVuZ3RoKSB7XG5cdCAgICBmb3IgKHZhciBoID0gMDsgaCA8IHNjaGVtZVswXS5oZWFkZXIubGVuZ3RoOyBoKyspIHtcblx0ICAgICAgaGVhZGVycyA9IFtdO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1lLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaGVhZGVyID0gXCJcIjtcblxuXHQgICAgICAgIGlmIChzY2hlbWVbaV0uaGVhZGVyW2hdKSB7XG5cdCAgICAgICAgICBoZWFkZXIgPSBzY2hlbWVbaV0uaGVhZGVyW2hdO1xuXHQgICAgICAgICAgaWYgKGZpbHRlckhUTUwpIGhlYWRlciA9IHNjaGVtZVtpXS5oZWFkZXJbaF0gPSBoZWFkZXIucmVwbGFjZShodG1sRmlsdGVyLCBcIlwiKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBoZWFkZXJzLnB1c2goaGVhZGVyKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtb2RlID09IFwiZXhjZWxcIiAmJiB2aWV3Ll9jb2x1bW5zICYmIG9wdGlvbnMuaGVpZ2h0cyAhPT0gZmFsc2UgJiYgKHZpZXcuX2hlYWRlcnNbaF0gIT09ICRhY3RpdmUuYmFySGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0cyA9PSBcImFsbFwiKSkgc2NoZW1lLmhlaWdodHNbZGF0YS5sZW5ndGhdID0gdmlldy5faGVhZGVyc1toXTtcblx0ICAgICAgaWYgKG1vZGUgIT09IFwicGRmXCIpIGRhdGFbZGF0YS5sZW5ndGhdID0gaGVhZGVycztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBvcHRpb25zLnlDb3JyZWN0aW9uID0gKG9wdGlvbnMueUNvcnJlY3Rpb24gfHwgMCkgLSBkYXRhLmxlbmd0aDtcblx0ICB2YXIgaXNUcmVlID0gdmlldy5kYXRhLm5hbWUgPT0gXCJUcmVlU3RvcmVcIjtcblx0ICB2YXIgdHJlZWxpbmUgPSBvcHRpb25zLmZsYXRUcmVlIHx8IG9wdGlvbnMucGxhaW5PdXRwdXQgPyBcIlwiIDogXCIgLSBcIjtcblx0ICB2aWV3LmRhdGEuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgaWYgKCFvcHRpb25zLmZpbHRlciB8fCBvcHRpb25zLmZpbHRlcihpdGVtKSkge1xuXHQgICAgICBpZiAodGhpcy5kYXRhLl9zY2hlbWVfZXhwb3J0KSB7XG5cdCAgICAgICAgaXRlbSA9IHZpZXcuZGF0YS5fc2NoZW1lX2V4cG9ydChpdGVtKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBsaW5lID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgc2NoZW1lLmxlbmd0aDsgX2k2KyspIHtcblx0ICAgICAgICB2YXIgY29sdW1uID0gc2NoZW1lW19pNl0sXG5cdCAgICAgICAgICAgIGNlbGwgPSBudWxsOyAvL3NwcmVhZHNoZWV0IGNhbiBvdXRwdXQgbWF0aFxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubWF0aCAmJiBpdGVtW1wiJFwiICsgY29sdW1uLmlkXSAmJiBpdGVtW1wiJFwiICsgY29sdW1uLmlkXS5jaGFyQXQoMCkgPT0gXCI9XCIgJiYgIWl0ZW1bXCIkXCIgKyBjb2x1bW4uaWRdLm1hdGNoKC9ePShpbWFnZXxsaW5rfHNwYXJrbGluZSlcXCgvaSkpIGNlbGwgPSBpdGVtW1wiJFwiICsgY29sdW1uLmlkXTtcblxuXHQgICAgICAgIGlmICh0aGlzLl9zcGFuc19wdWxsKSB7XG5cdCAgICAgICAgICB2YXIgc3BhbiA9IHRoaXMuZ2V0U3BhbihpdGVtLmlkLCBjb2x1bW4uaWQpO1xuXG5cdCAgICAgICAgICBpZiAoc3BhbiAmJiBzcGFuWzRdICYmIHNwYW5bMF0gPT0gaXRlbS5pZCAmJiBzcGFuWzFdID09IGNvbHVtbi5pZCkge1xuXHQgICAgICAgICAgICBjZWxsID0gc3Bhbls0XTtcblx0ICAgICAgICAgICAgaWYgKGZpbHRlckhUTUwgJiYgdHlwZW9mIGNlbGwgPT09IFwic3RyaW5nXCIpIGNlbGwgPSBjZWxsLnJlcGxhY2UoaHRtbEZpbHRlciwgXCJcIik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFjZWxsKSB7XG5cdCAgICAgICAgICBjZWxsID0gY29sdW1uLnRlbXBsYXRlKGl0ZW0sIHZpZXcudHlwZSwgaXRlbVtjb2x1bW4uaWRdLCBjb2x1bW4sIF9pNik7XG5cdCAgICAgICAgICBpZiAoIWNlbGwgJiYgY2VsbCAhPT0gMCkgY2VsbCA9IFwiXCI7XG5cblx0ICAgICAgICAgIGlmIChmaWx0ZXJIVE1MICYmIHR5cGVvZiBjZWxsID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGlmIChpc1RyZWUpIGNlbGwgPSBjZWxsLnJlcGxhY2UoLzxkaXYgY2xhc3M9LndlYml4X3RyZWVfbm9uZS4+PFxcL2Rpdj4vLCB0cmVlbGluZSk7XG5cdCAgICAgICAgICAgIGNlbGwgPSBjZWxsLnJlcGxhY2UoaHRtbEZpbHRlciwgXCJcIik7XG5cdCAgICAgICAgICB9IC8vcmVtb3ZlIGVuZC9zdGFydCBzcGFjZXMoZXguaGllcmFyY2h5IGRhdGEpXG5cblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsID09PSBcInN0cmluZ1wiICYmIG1vZGUgPT09IFwiY3N2XCIpIGNlbGwgPSBjZWxsLnRyaW0oKTsgLy9mb3IgbXVsdGlsaW5lIGRhdGFcblxuXHQgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsID09PSBcInN0cmluZ1wiICYmIChtb2RlID09PSBcImV4Y2VsXCIgfHwgbW9kZSA9PT0gXCJjc3ZcIikpIHtcblx0ICAgICAgICAgICAgY2VsbCA9IGNlbGwucmVwbGFjZSgvPGJyXFxzKlxcLz8+L21nLCBcIlxcblwiKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsaW5lLnB1c2goY2VsbCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobW9kZSA9PSBcImV4Y2VsXCIgJiYgdmlldy5fY29sdW1ucyAmJiBvcHRpb25zLmhlaWdodHMgIT09IGZhbHNlICYmIChpdGVtLiRoZWlnaHQgJiYgaXRlbS4kaGVpZ2h0ICE9PSAkYWN0aXZlLnJvd0hlaWdodCB8fCBvcHRpb25zLmhlaWdodHMgPT0gXCJhbGxcIikpIHNjaGVtZS5oZWlnaHRzW2RhdGEubGVuZ3RoXSA9IGl0ZW0uJGhlaWdodCB8fCB0aGlzLmNvbmZpZy5yb3dIZWlnaHQ7XG5cdCAgICAgIGRhdGEucHVzaChsaW5lKTtcblx0ICAgIH1cblx0ICB9LCB2aWV3KTtcblxuXHQgIGlmIChvcHRpb25zLmZvb3RlciAhPT0gZmFsc2UpIHtcblx0ICAgIHZhciBmX2NvdW50ID0gc2NoZW1lWzBdLmZvb3RlciA/IHNjaGVtZVswXS5mb290ZXIubGVuZ3RoIDogMDtcblxuXHQgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBmX2NvdW50OyBmKyspIHtcblx0ICAgICAgdmFyIGZvb3RlcnMgPSBbXTtcblxuXHQgICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzY2hlbWUubGVuZ3RoOyBfaTcrKykge1xuXHQgICAgICAgIHZhciBmb290ZXIgPSBzY2hlbWVbX2k3XS5mb290ZXJbZl07XG5cdCAgICAgICAgaWYgKGZpbHRlckhUTUwpIGZvb3RlciA9IHNjaGVtZVtfaTddLmZvb3RlcltmXSA9IGZvb3Rlci50b1N0cmluZygpLnJlcGxhY2UoaHRtbEZpbHRlciwgXCJcIik7XG5cdCAgICAgICAgZm9vdGVycy5wdXNoKGZvb3Rlcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobW9kZSA9PSBcImV4Y2VsXCIgJiYgdmlldy5fY29sdW1ucyAmJiBvcHRpb25zLmhlaWdodHMgIT09IGZhbHNlICYmICh2aWV3Ll9mb290ZXJzW2ZdICE9PSAkYWN0aXZlLmJhckhlaWdodCB8fCBvcHRpb25zLmhlaWdodHMgPT0gXCJhbGxcIikpIHNjaGVtZS5oZWlnaHRzW2RhdGEubGVuZ3RoXSA9IHZpZXcuX2Zvb3RlcnNbZl07XG5cdCAgICAgIGlmIChtb2RlICE9PSBcInBkZlwiKSBkYXRhLnB1c2goZm9vdGVycyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKG1vZGUgPT09IFwiZXhjZWxcIiAmJiBvcHRpb25zLmRvY0Zvb3Rlcikge1xuXHQgICAgZGF0YSA9IGRhdGEuY29uY2F0KFtbXSwgWyhvcHRpb25zLmRvY0Zvb3Rlci50ZXh0IHx8IG9wdGlvbnMuZG9jRm9vdGVyKS50b1N0cmluZygpXV0pO1xuXHQgICAgaWYgKG9wdGlvbnMuZG9jRm9vdGVyLmhlaWdodCkgc2NoZW1lLmhlaWdodHNbZGF0YS5sZW5ndGggLSAxXSA9IG9wdGlvbnMuZG9jRm9vdGVyLmhlaWdodDtcblx0ICB9XG5cblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXG5cdHZhciB0b1BORyA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXHQgIHZhciBkZWZlciA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgcmV0dXJuIHJlcXVpcmUoZW52LmNkbiArIFwiL2V4dHJhcy9odG1sMmNhbnZhcy0xLjAubWluLmpzXCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgLy9iYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdCAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIG9wdGlvbnMgPSB7XG5cdCAgICAgIGZpbGVuYW1lOiBvcHRpb25zXG5cdCAgICB9O1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICB2YXIgdmlldyA9ICQkKGlkKTtcblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuJGV4cG9ydFZpZXcpIHZpZXcgPSB2aWV3LiRleHBvcnRWaWV3KG9wdGlvbnMpO1xuXHQgICAgYXNzZXJ0KHZpZXcsIGVycm9yTWVzc2FnZSk7XG5cdCAgICBpZiAoIXZpZXcpIHJldHVybiBkZWZlci5yZWplY3QoZXJyb3JNZXNzYWdlKTtcblx0ICAgIHZhciBub2RlID0gdmlldyA/IHZpZXcuJHZpZXcgOiB0b05vZGUoaWQpO1xuXHQgICAgdmFyIGZpbGVuYW1lID0gKG9wdGlvbnMuZmlsZW5hbWUgfHwgXCJEYXRhXCIpICsgXCIucG5nXCI7XG5cdCAgICB3aW5kb3cuaHRtbDJjYW52YXMobm9kZSwge1xuXHQgICAgICBiYWNrZ3JvdW5kOiBcIiNmZmZcIixcblx0ICAgICAgbG9nZ2luZzogZmFsc2Vcblx0ICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNhbnZhcykge1xuXHQgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIGlmIChvcHRpb25zLmRvd25sb2FkICE9PSBmYWxzZSkgZG93bmxvYWQoZGF0YSwgZmlsZW5hbWUpO1xuXHQgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcblx0ICAgICAgICBkZWZlci5yZXNvbHZlKGRhdGEpO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmIChjYW52YXMubXNUb0Jsb2IpIGNhbGxiYWNrKGNhbnZhcy5tc1RvQmxvYigpKTtlbHNlIGNhbnZhcy50b0Jsb2IoY2FsbGJhY2ssIFwiaW1hZ2UvcG5nXCIpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZGVmZXI7XG5cdCAgfSk7XG5cdH07XG5cblx0dmFyIHRvQ1NWID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgdmFyIHZpZXcgPSAkJChpZCk7XG5cdCAgaWYgKHZpZXcgJiYgdmlldy4kZXhwb3J0VmlldykgdmlldyA9IHZpZXcuJGV4cG9ydFZpZXcob3B0aW9ucyk7XG5cdCAgYXNzZXJ0KHZpZXcsIGVycm9yTWVzc2FnZSk7XG5cdCAgaWYgKCF2aWV3KSByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGVycm9yTWVzc2FnZSk7XG5cdCAgb3B0aW9ucy5leHBvcnRfbW9kZSA9IFwiY3N2XCI7XG5cdCAgb3B0aW9ucy5maWx0ZXJIVE1MID0gdHJ1ZTtcblx0ICB2YXIgc2NoZW1lID0gZ2V0RXhwb3J0U2NoZW1lKHZpZXcsIG9wdGlvbnMpO1xuXHQgIHZhciByZXN1bHQgPSBnZXRFeHBvcnREYXRhKHZpZXcsIG9wdGlvbnMsIHNjaGVtZSk7XG5cdCAgdmFyIGRhdGEgPSBnZXRDc3ZEYXRhKHJlc3VsdCwgc2NoZW1lKTtcblx0ICB2YXIgZmlsZW5hbWUgPSAob3B0aW9ucy5maWxlbmFtZSB8fCBcIkRhdGFcIikgKyBcIi5jc3ZcIjtcblx0ICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtcIlxcdUZFRkZcIiArIGRhdGFdLCB7XG5cdCAgICB0eXBlOiBcInRleHQvY3N2XCJcblx0ICB9KTtcblx0ICBpZiAob3B0aW9ucy5kb3dubG9hZCAhPT0gZmFsc2UpIGRvd25sb2FkKGJsb2IsIGZpbGVuYW1lKTtcblx0ICByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZShibG9iKTtcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRDc3ZEYXRhKGRhdGEpIHtcblx0ICByZXR1cm4gY3N2JDEuc3RyaW5naWZ5KGRhdGEpO1xuXHR9XG5cblx0dmFyIGZvbnQgPSB7fTtcblx0dmFyIHRvUERGID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIHJlcXVpcmUoW2Vudi5jZG4gKyBcIi9leHRyYXMvcGRmanMuanNcIiwgZW52LmNkbiArIFwiL2V4dHJhcy9odG1sMmNhbnZhcy0xLjAubWluLmpzXCJdKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgb3B0aW9ucy5leHBvcnRfbW9kZSA9IFwicGRmXCI7XG5cdCAgICBvcHRpb25zLl9leHBvcnRfZm9udCA9IGZvbnQ7XG5cdCAgICBvcHRpb25zLmZvbnROYW1lID0gb3B0aW9ucy5mb250TmFtZSB8fCBcInB0LXNhbnMucmVndWxhclwiO1xuXHQgICAgb3B0aW9ucy5kaXNwbGF5ID0gb3B0aW9ucy5kaXNwbGF5IHx8IFwidGFibGVcIjtcblx0ICAgIGlkID0gaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG5cdCAgICB2YXIgdmlld3MgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoIWlkW2ldLmlkKSBpZFtpXSA9IHtcblx0ICAgICAgICBpZDogaWRbaV1cblx0ICAgICAgfTtcblx0ICAgICAgdmFyIHZpZXcgPSAkJChpZFtpXS5pZCk7XG5cdCAgICAgIHZhciB2aWV3T3B0aW9ucyA9IGV4cG9ydHMuZXh0ZW5kKGlkW2ldLm9wdGlvbnMgfHwge30sIG9wdGlvbnMpO1xuXHQgICAgICBpZiAodmlldyAmJiB2aWV3LiRleHBvcnRWaWV3KSB2aWV3ID0gdmlldy4kZXhwb3J0Vmlldyh2aWV3T3B0aW9ucyk7XG5cblx0ICAgICAgaWYgKHZpZXcpIHtcblx0ICAgICAgICBpZiAodmlld09wdGlvbnMuZGlzcGxheSAhPT0gXCJ0YWJsZVwiKSB7XG5cdCAgICAgICAgICB2aWV3cy5wdXNoKHtcblx0ICAgICAgICAgICAgbm9kZTogdmlldy4kdmlldyxcblx0ICAgICAgICAgICAgdmlld09wdGlvbnM6IHZpZXdPcHRpb25zXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIGlmIChvcHRpb25zLmF1dG93aWR0aCkgb3B0aW9ucy53aWR0aCA9IE1hdGgubWF4KG9wdGlvbnMud2lkdGggfHwgMCwgdmlldy4kdmlldy4kd2lkdGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2aWV3T3B0aW9ucy5kaXNwbGF5ICE9PSBcImltYWdlXCIgJiYgdmlldy5kYXRhICYmIHZpZXcuZGF0YS5wdWxsKSB7XG5cdCAgICAgICAgICB2YXIgc2NoZW1lID0gZ2V0RXhwb3J0U2NoZW1lKHZpZXcsIHZpZXdPcHRpb25zKTtcblx0ICAgICAgICAgIHZpZXdzLnB1c2goe1xuXHQgICAgICAgICAgICBzY2hlbWU6IHNjaGVtZSxcblx0ICAgICAgICAgICAgZGF0YTogZ2V0RXhwb3J0RGF0YSh2aWV3LCB2aWV3T3B0aW9ucywgc2NoZW1lKSxcblx0ICAgICAgICAgICAgdmlld09wdGlvbnM6IHZpZXdPcHRpb25zXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIGlmIChvcHRpb25zLmF1dG93aWR0aCkgb3B0aW9ucy53aWR0aCA9IE1hdGgubWF4KG9wdGlvbnMud2lkdGggfHwgMCwgZ2V0QXV0b3dpZHRoKHNjaGVtZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGFzc2VydCh2aWV3LCBlcnJvck1lc3NhZ2UpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodmlld3MubGVuZ3RoID09IDApIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZXJyb3JNZXNzYWdlKTtcblxuXHQgICAgaWYgKGZvbnRbb3B0aW9ucy5mb250TmFtZV0pIHtcblx0ICAgICAgb3B0aW9ucy5fZXhwb3J0X2ZvbnQgPSBmb250W29wdGlvbnMuZm9udE5hbWVdO1xuXHQgICAgICByZXR1cm4gZ2V0UGRmRGF0YSh2aWV3cywgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocGRmKSB7XG5cdCAgICAgICAgcmV0dXJuIGdldEJsb2IocGRmLCBvcHRpb25zKTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgZGVmZXIgPSBEZWZlcnJlZC5kZWZlcigpO1xuXHQgICAgICAvKiBnbG9iYWwgcGRmanMgKi9cblxuXHQgICAgICBwZGZqcy5sb2FkKGVudi5jZG4gKyBcIi9leHRyYXMvXCIgKyBvcHRpb25zLmZvbnROYW1lICsgXCIudHRmXCIsIGZ1bmN0aW9uIChlcnIsIGJ1Zikge1xuXHQgICAgICAgIGlmIChlcnIpIHRocm93IGVycjtcblx0ICAgICAgICBvcHRpb25zLl9leHBvcnRfZm9udCA9IGZvbnRbb3B0aW9ucy5mb250TmFtZV0gPSBuZXcgcGRmanMuVFRGRm9udChidWYpO1xuXHQgICAgICAgIGRlZmVyLnJlc29sdmUoZ2V0UGRmRGF0YSh2aWV3cywgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocGRmKSB7XG5cdCAgICAgICAgICByZXR1cm4gZ2V0QmxvYihwZGYsIG9wdGlvbnMpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBkZWZlcjtcblx0ICAgIH1cblx0ICB9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRCbG9iKHBkZiwgb3B0aW9ucykge1xuXHQgIHZhciBmaWxlbmFtZSA9IChvcHRpb25zLmZpbGVuYW1lIHx8IFwiRGF0YVwiKSArIFwiLnBkZlwiO1xuXHQgIHZhciBibG9iID0gbmV3IEJsb2IoW3BkZi50b1N0cmluZygpXSwge1xuXHQgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuXHQgIH0pO1xuXHQgIGlmIChvcHRpb25zLmRvd25sb2FkICE9PSBmYWxzZSkgZG93bmxvYWQoYmxvYiwgZmlsZW5hbWUpO1xuXHQgIHJldHVybiBibG9iO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UGRmRGF0YSh2aWV3cywgb3B0aW9ucykge1xuXHQgIHZhciBkb2MgPSBhZGRQREZEb2Mob3B0aW9ucyk7XG5cdCAgdmFyIHByb21pc2VzID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAodmlld3NbaV0ubm9kZSkgcHJvbWlzZXMucHVzaChnZXRQREZJbWFnZSh2aWV3c1tpXS5ub2RlKSk7ZWxzZSBwcm9taXNlcy5wdXNoKERlZmVycmVkLnJlc29sdmUoKSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIERlZmVycmVkLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoaW1hZ2VzKSB7XG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvbWlzZXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIHZhciB2aWV3T3B0aW9ucyA9IHZpZXdzW19pXS52aWV3T3B0aW9ucztcblx0ICAgICAgaWYgKHZpZXdPcHRpb25zLnRleHRCZWZvcmUpIGFkZFRleHQoZG9jLCBcImJlZm9yZVwiLCB2aWV3T3B0aW9ucy50ZXh0QmVmb3JlKTtcblx0ICAgICAgaWYgKGltYWdlc1tfaV0pIGRvYy5pbWFnZShpbWFnZXNbX2ldLCB7XG5cdCAgICAgICAgYWxpZ246IFwiY2VudGVyXCJcblx0ICAgICAgfSk7ZWxzZSBhZGRQREZUYWJsZSh2aWV3c1tfaV0uc2NoZW1lLCB2aWV3c1tfaV0uZGF0YSwgdmlld09wdGlvbnMsIGRvYyk7XG5cdCAgICAgIGlmICh2aWV3T3B0aW9ucy50ZXh0QWZ0ZXIpIGFkZFRleHQoZG9jLCBcImFmdGVyXCIsIHZpZXdPcHRpb25zLnRleHRBZnRlcik7XG5cdCAgICAgIGlmIChfaSAhPSB2aWV3cy5sZW5ndGggLSAxKSBkb2MucGFnZUJyZWFrKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBhZGRQREZIZWFkZXIoZG9jLCBvcHRpb25zKTtcblx0ICB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFRleHQoZG9jLCB0eXBlLCB0ZXh0KSB7XG5cdCAgaWYgKHR5cGUgPT0gXCJhZnRlclwiKSBkb2MudGV4dCgpLmJyKCk7XG5cdCAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpIHRleHQgPSB7XG5cdCAgICB0ZXh0OiB0ZXh0XG5cdCAgfTtcblx0ICBkb2MudGV4dCh0ZXh0LnRleHQsIHRleHQub3B0aW9ucyB8fCB7fSk7XG5cdCAgaWYgKHR5cGUgPT0gXCJiZWZvcmVcIikgZG9jLnRleHQoKS5icigpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UERGSW1hZ2Uobm9kZSkge1xuXHQgIHJldHVybiB3aW5kb3cuaHRtbDJjYW52YXMobm9kZSwge1xuXHQgICAgYmFja2dyb3VuZDogXCIjZmZmXCIsXG5cdCAgICBsb2dnaW5nOiBmYWxzZVxuXHQgIH0pLnRoZW4oZnVuY3Rpb24gKGNhbnZhcykge1xuXHQgICAgdmFyIGRlZmVyID0gRGVmZXJyZWQuZGVmZXIoKTtcblx0ICAgIHZhciBpbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9qcGVnXCIpO1xuXHQgICAgcGRmanMubG9hZChpbWFnZSwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG5cdCAgICAgIGRlZmVyLnJlc29sdmUobmV3IHBkZmpzLkltYWdlKGJ1ZmZlcikpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZGVmZXI7XG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRBdXRvd2lkdGgoc2NoZW1lKSB7XG5cdCAgdmFyIHdpZHRoID0gODA7IC8vcGFkZGluZ3NcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1lLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB3aWR0aCArPSBzY2hlbWVbaV0ud2lkdGg7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHdpZHRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUERGRG9jKG9wdGlvbnMpIHtcblx0ICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDU5NS4yOTYsXG5cdCAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDg0MS44OTY7IC8vIGRlZmF1bHQgQTQgc2l6ZVxuXG5cdCAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24gJiYgb3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXCJsYW5kc2NhcGVcIikgaGVpZ2h0ID0gW3dpZHRoLCB3aWR0aCA9IGhlaWdodF1bMF07XG5cdCAgcmV0dXJuIG5ldyBwZGZqcy5Eb2N1bWVudCh7XG5cdCAgICBwYWRkaW5nOiA0MCxcblx0ICAgIGZvbnQ6IG9wdGlvbnMuX2V4cG9ydF9mb250LFxuXHQgICAgdGhyZXNob2xkOiAyNTYsXG5cdCAgICB3aWR0aDogd2lkdGgsXG5cdCAgICBoZWlnaHQ6IGhlaWdodFxuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUERGVGFibGUoc2NoZW1lLCBkYXRhLCBvcHRpb25zLCBkb2MpIHtcblx0ICBvcHRpb25zLmhlYWRlciA9IGlzVW5kZWZpbmVkKG9wdGlvbnMuaGVhZGVyKSB8fCBvcHRpb25zLmhlYWRlciA9PT0gdHJ1ZSA/IHt9IDogb3B0aW9ucy5oZWFkZXI7XG5cdCAgb3B0aW9ucy5mb290ZXIgPSBpc1VuZGVmaW5lZChvcHRpb25zLmZvb3RlcikgfHwgb3B0aW9ucy5mb290ZXIgPT09IHRydWUgPyB7fSA6IG9wdGlvbnMuZm9vdGVyO1xuXHQgIG9wdGlvbnMudGFibGUgPSBvcHRpb25zLnRhYmxlIHx8IHt9OyAvL3JlbmRlciB0YWJsZVxuXG5cdCAgdmFyIGhfY291bnQgPSBvcHRpb25zLmhlYWRlciA9PT0gZmFsc2UgPyAwIDogc2NoZW1lWzBdLmhlYWRlci5sZW5ndGg7XG5cdCAgdmFyIGZfY291bnQgPSBvcHRpb25zLmZvb3RlciA9PT0gZmFsc2UgfHwgIXNjaGVtZVswXS5mb290ZXIgPyAwIDogc2NoZW1lWzBdLmZvb3Rlci5sZW5ndGg7XG5cdCAgdmFyIGNvbFdpZHRocyA9IFtdO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2hlbWUubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNvbFdpZHRoc1tpXSA9IHNjaGVtZVtpXS53aWR0aDtcblx0ICB9XG5cblx0ICB2YXIgdGFibGVPcHMgPSBleHBvcnRzLmV4dGVuZChvcHRpb25zLnRhYmxlLCB7XG5cdCAgICBib3JkZXJXaWR0aDogMSxcblx0ICAgIGhlaWdodDogMjAsXG5cdCAgICBsaW5lSGVpZ2h0OiAxLjEsXG5cdCAgICBib3JkZXJDb2xvcjogMHhFRUVFRUUsXG5cdCAgICBiYWNrZ3JvdW5kQ29sb3I6IDB4RkZGRkZGLFxuXHQgICAgY29sb3I6IDB4NjY2NjY2LFxuXHQgICAgdGV4dEFsaWduOiBcImxlZnRcIixcblx0ICAgIHBhZGRpbmdSaWdodDogMTAsXG5cdCAgICBwYWRkaW5nTGVmdDogMTAsXG5cdCAgICBoZWFkZXJSb3dzOiBoX2NvdW50LFxuXHQgICAgd2lkdGhzOiBjb2xXaWR0aHMubGVuZ3RoID8gY29sV2lkdGhzIDogW1wiMTAwJVwiXVxuXHQgIH0pO1xuXHQgIHZhciB0YWJsZSA9IGRvYy50YWJsZSh0YWJsZU9wcyk7IC8vcmVuZGVyIHRhYmxlIGhlYWRlclxuXG5cdCAgaWYgKGhfY291bnQpIHtcblx0ICAgIHZhciBoZWFkZXJPcHMgPSBleHBvcnRzLmV4dGVuZChvcHRpb25zLmhlYWRlciwge1xuXHQgICAgICBib3JkZXJSaWdodENvbG9yOiAweEIwQ0VFMyxcblx0ICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IDB4QjBDRUUzLFxuXHQgICAgICBjb2xvcjogMHg0QTRBNEEsXG5cdCAgICAgIGJhY2tncm91bmRDb2xvcjogMHhEMkUzRUYsXG5cdCAgICAgIGhlaWdodDogMjcsXG5cdCAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuXHQgICAgfSk7XG5cblx0ICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGhfY291bnQ7IF9pMisrKSB7XG5cdCAgICAgIHZhciBoZWFkZXIgPSB0YWJsZS50cihoZWFkZXJPcHMpO1xuXG5cdCAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2NoZW1lLmxlbmd0aDsgcysrKSB7XG5cdCAgICAgICAgaGVhZGVyLnRkKHNjaGVtZVtzXS5oZWFkZXJbX2kyXS50b1N0cmluZygpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy9yZW5kZXIgdGFibGUgZGF0YVxuXG5cblx0ICBmb3IgKHZhciByID0gMDsgciA8IGRhdGEubGVuZ3RoOyByKyspIHtcblx0ICAgIHZhciByb3cgPSB0YWJsZS50cih7fSk7XG5cblx0ICAgIGZvciAodmFyIGMgPSAwOyBjIDwgZGF0YVtyXS5sZW5ndGg7IGMrKykge1xuXHQgICAgICByb3cudGQoZGF0YVtyXVtjXSk7XG5cdCAgICB9XG5cdCAgfSAvL3JlbmRlciB0YWJsZSBmb290ZXJcblxuXG5cdCAgaWYgKGZfY291bnQpIHtcblx0ICAgIHZhciBmb290ZXJPcHMgPSBleHBvcnRzLmV4dGVuZChvcHRpb25zLmZvb3Rlciwge1xuXHQgICAgICBib3JkZXJSaWdodENvbG9yOiAweEVFRUVFRSxcblx0ICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IDB4RUVFRUVFLFxuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6IDB4RkFGQUZBLFxuXHQgICAgICBjb2xvcjogMHg2NjY2NjYsXG5cdCAgICAgIGhlaWdodDogMjcsXG5cdCAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuXHQgICAgfSk7XG5cblx0ICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGZfY291bnQ7IF9pMysrKSB7XG5cdCAgICAgIHZhciBmb290ZXIgPSB0YWJsZS50cihmb290ZXJPcHMpO1xuXG5cdCAgICAgIGZvciAodmFyIF9zID0gMDsgX3MgPCBzY2hlbWUubGVuZ3RoOyBfcysrKSB7XG5cdCAgICAgICAgZm9vdGVyLnRkKHNjaGVtZVtfc10uZm9vdGVyW19pM10udG9TdHJpbmcoKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRQREZIZWFkZXIoZG9jLCBvcHRpb25zKSB7XG5cdCAgLy9kb2MgZm9vdGVyXG5cdCAgaWYgKG9wdGlvbnMuZG9jRm9vdGVyICE9PSBmYWxzZSkge1xuXHQgICAgdmFyIGZ0ID0gZG9jLmZvb3RlcigpO1xuXHQgICAgZnQudGV4dCh7XG5cdCAgICAgIGNvbG9yOiAweDY2NjY2Nixcblx0ICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG5cdCAgICB9KS5hcHBlbmQoaTE4bi5kYXRhRXhwb3J0LnBhZ2UgfHwgXCJQYWdlXCIpLnBhZ2VOdW1iZXIoKS5hcHBlbmQoXCIgIFwiICsgKGkxOG4uZGF0YUV4cG9ydC5vZiB8fCBcIm9mXCIpICsgXCIgIFwiKS5wYWdlQ291bnQoKTtcblx0ICB9XG5cblx0ICB2YXIgaG9yZGVyID0ge1xuXHQgICAgdGV4dDogMCxcblx0ICAgIGltYWdlOiAxXG5cdCAgfTsgLy9kb2MgaGVhZGVyLCBjb25maWd1cmFibGVcblxuXHQgIGlmIChvcHRpb25zLmRvY0hlYWRlcikge1xuXHQgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRvY0hlYWRlciA9PSBcInN0cmluZ1wiKSBvcHRpb25zLmRvY0hlYWRlciA9IHtcblx0ICAgICAgdGV4dDogb3B0aW9ucy5kb2NIZWFkZXJcblx0ICAgIH07XG5cdCAgICBleHBvcnRzLmV4dGVuZChvcHRpb25zLmRvY0hlYWRlciwge1xuXHQgICAgICBjb2xvcjogMHg2NjY2NjYsXG5cdCAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuXHQgICAgICBvcmRlcjogMFxuXHQgICAgfSk7XG5cdCAgICBob3JkZXIudGV4dCA9IG9wdGlvbnMuZG9jSGVhZGVyLm9yZGVyO1xuXHQgIH1cblxuXHQgIGlmIChvcHRpb25zLmRvY0hlYWRlckltYWdlKSB7XG5cdCAgICBpZiAodHlwZW9mIG9wdGlvbnMuZG9jSGVhZGVySW1hZ2UgPT0gXCJzdHJpbmdcIikgb3B0aW9ucy5kb2NIZWFkZXJJbWFnZSA9IHtcblx0ICAgICAgdXJsOiBvcHRpb25zLmRvY0hlYWRlckltYWdlXG5cdCAgICB9O1xuXHQgICAgZXhwb3J0cy5leHRlbmQob3B0aW9ucy5kb2NIZWFkZXJJbWFnZSwge1xuXHQgICAgICBhbGlnbjogXCJyaWdodFwiLFxuXHQgICAgICBvcmRlcjogMVxuXHQgICAgfSk7XG5cdCAgICBob3JkZXIuaW1hZ2UgPSBvcHRpb25zLmRvY0hlYWRlckltYWdlLm9yZGVyO1xuXHQgIH1cblxuXHQgIGlmIChvcHRpb25zLmRvY0hlYWRlciAmJiBob3JkZXIuaW1hZ2UgPiBob3JkZXIudGV4dCkgZG9jLmhlYWRlcih7XG5cdCAgICBwYWRkaW5nQm90dG9tOiAxMFxuXHQgIH0pLnRleHQob3B0aW9ucy5kb2NIZWFkZXIudGV4dCwgb3B0aW9ucy5kb2NIZWFkZXIpO1xuXG5cdCAgaWYgKG9wdGlvbnMuZG9jSGVhZGVySW1hZ2UpIHtcblx0ICAgIHZhciBkZWZlciA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgICBwZGZqcy5sb2FkKG9wdGlvbnMuZG9jSGVhZGVySW1hZ2UudXJsLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcblx0ICAgICAgaWYgKCFlcnIpIHtcblx0ICAgICAgICB2YXIgaW1nID0gbmV3IHBkZmpzLkltYWdlKGJ1ZmZlcik7XG5cdCAgICAgICAgZG9jLmhlYWRlcih7XG5cdCAgICAgICAgICBwYWRkaW5nQm90dG9tOiAxMFxuXHQgICAgICAgIH0pLmltYWdlKGltZywgb3B0aW9ucy5kb2NIZWFkZXJJbWFnZSk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZG9jSGVhZGVyICYmIGhvcmRlci5pbWFnZSA8IGhvcmRlci50ZXh0KSBkb2MuaGVhZGVyKHtcblx0ICAgICAgICAgIHBhZGRpbmdCb3R0b206IDEwXG5cdCAgICAgICAgfSkudGV4dChvcHRpb25zLmRvY0hlYWRlci50ZXh0LCBvcHRpb25zLmRvY0hlYWRlcik7XG5cdCAgICAgIH0gLy9yZW5kZXIgcGRmIGFuZCBzaG93IGluIGJyb3dzZXJcblxuXG5cdCAgICAgIGRlZmVyLnJlc29sdmUoZG9jLnJlbmRlcigpKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGRlZmVyO1xuXHQgIH0gZWxzZSByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZShkb2MucmVuZGVyKCkpO1xuXHR9XG5cblx0dmFyIHRvRXhjZWwgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICBvcHRpb25zLmV4cG9ydF9tb2RlID0gXCJleGNlbFwiO1xuXHQgIGlkID0gaXNBcnJheShpZCkgPyBpZCA6IFtpZF07XG5cdCAgdmFyIHZpZXdzID0gW107XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgdmlldyA9ICQkKGlkW2ldKTtcblx0ICAgIGlmICh2aWV3ICYmIHZpZXcuJGV4cG9ydFZpZXcpIHZpZXcgPSB2aWV3LiRleHBvcnRWaWV3KG9wdGlvbnMpO1xuXHQgICAgaWYgKHZpZXcpIHZpZXdzID0gdmlld3MuY29uY2F0KHZpZXcpO1xuXHQgICAgYXNzZXJ0KHZpZXcsIGVycm9yTWVzc2FnZSk7IC8vc3ByZWFkc2hlZXQgYW5kIGV4Y2Vsdmlld2VyIHJlcXVpcmUgcGxhaW4gZGF0YSBvdXRwdXQgZmlyc3RcblxuXHQgICAgaWYgKG9wdGlvbnMuZGF0YU9ubHkpIHtcblx0ICAgICAgdmFyIHNjaGVtZSA9IGdldEV4cG9ydFNjaGVtZSh2aWV3LCBvcHRpb25zKTtcblx0ICAgICAgdmlld3NbaV0gPSB7XG5cdCAgICAgICAgc2NoZW1lOiBzY2hlbWUsXG5cdCAgICAgICAgZXhwb3J0RGF0YTogZ2V0RXhwb3J0RGF0YSh2aWV3LCBvcHRpb25zLCBzY2hlbWUpLFxuXHQgICAgICAgIHNwYW5zOiBvcHRpb25zLnNwYW5zID8gZ2V0U3BhbnModmlldywgb3B0aW9ucykgOiBbXVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChvcHRpb25zLmRhdGFPbmx5KSByZXR1cm4gdmlld3M7XG5cdCAgdmFyIGRlZmVyID0gRGVmZXJyZWQuZGVmZXIoKTtcblx0ICByZXR1cm4gcmVxdWlyZShlbnYuY2RuICsgXCIvZXh0cmFzL3hsc3guY29yZS5zdHlsZXMubWluLmpzXCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF2aWV3cy5sZW5ndGgpIHJldHVybiBkZWZlci5yZWplY3QoZXJyb3JNZXNzYWdlKTtcblx0ICAgIHZhciB3YiA9IHtcblx0ICAgICAgU2hlZXROYW1lczogW10sXG5cdCAgICAgIFNoZWV0czoge30sXG5cdCAgICAgIFdvcmtib29rOiB7XG5cdCAgICAgICAgV0JQcm9wczoge30sXG5cdCAgICAgICAgTmFtZXM6IFtdXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICB2YXIgbmFtZSA9IGlzQXJyYXkob3B0aW9ucy5zaGVldHMpID8gb3B0aW9ucy5zaGVldHMgOiBbb3B0aW9ucy5uYW1lIHx8IFwiRGF0YVwiXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgc2NoZW1lID0gdmlld3NbaV0uc2NoZW1lIHx8IGdldEV4cG9ydFNjaGVtZSh2aWV3c1tpXSwgb3B0aW9ucyk7XG5cdCAgICAgIHZhciByZXN1bHQgPSB2aWV3c1tpXS5leHBvcnREYXRhIHx8IGdldEV4cG9ydERhdGEodmlld3NbaV0sIG9wdGlvbnMsIHNjaGVtZSk7XG5cdCAgICAgIHZhciBzcGFucyA9IHZpZXdzW2ldLnNwYW5zID8gdmlld3NbaV0uc3BhbnMgOiBvcHRpb25zLnNwYW5zID8gZ2V0U3BhbnModmlld3NbaV0sIG9wdGlvbnMpIDogW107XG5cdCAgICAgIHZhciByYW5nZXMgPSB2aWV3c1tpXS5yYW5nZXMgfHwgW107XG5cdCAgICAgIHZhciBzdHlsZXMgPSB2aWV3c1tpXS5zdHlsZXMgfHwgW107XG5cdCAgICAgIHZhciBkYXRhID0gZ2V0RXhjZWxEYXRhKHJlc3VsdCwgc2NoZW1lLCBzcGFucywgc3R5bGVzLCBvcHRpb25zKTtcblx0ICAgICAgdmFyIHNuYW1lID0gKG5hbWVbaV0gfHwgXCJEYXRhXCIgKyBpKS5yZXBsYWNlKC9bKj86W1xcXVxcXFwvXS9nLCBcIlwiKS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikuc3Vic3RyaW5nKDAsIDMxKTtcblx0ICAgICAgd2IuU2hlZXROYW1lcy5wdXNoKHNuYW1lKTtcblx0ICAgICAgd2IuU2hlZXRzW3NuYW1lXSA9IGRhdGE7XG5cdCAgICAgIHdiLldvcmtib29rLk5hbWVzID0gd2IuV29ya2Jvb2suTmFtZXMuY29uY2F0KHJhbmdlcyk7XG5cdCAgICB9XG5cdCAgICAvKiBnbG9iYWwgWExTWCAqL1xuXG5cblx0ICAgIHZhciB4bHMgPSBYTFNYLndyaXRlKHdiLCB7XG5cdCAgICAgIGJvb2tUeXBlOiBcInhsc3hcIixcblx0ICAgICAgYm9va1NTVDogZmFsc2UsXG5cdCAgICAgIHR5cGU6IFwiYmluYXJ5XCJcblx0ICAgIH0pO1xuXHQgICAgdmFyIGZpbGVuYW1lID0gKG9wdGlvbnMuZmlsZW5hbWUgfHwgbmFtZS5qb2luKFwiLFwiKSkgKyBcIi54bHN4XCI7XG5cdCAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzdHIyYXJyYXkoeGxzKV0sIHtcblx0ICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi94bHN4XCJcblx0ICAgIH0pO1xuXHQgICAgaWYgKG9wdGlvbnMuZG93bmxvYWQgIT09IGZhbHNlKSBkb3dubG9hZChibG9iLCBmaWxlbmFtZSk7XG5cdCAgICBkZWZlci5yZXNvbHZlKGJsb2IpO1xuXHQgICAgcmV0dXJuIGRlZmVyO1xuXHQgIH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHN0cjJhcnJheShzKSB7XG5cdCAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzLmxlbmd0aCk7XG5cdCAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgIT0gcy5sZW5ndGg7ICsraSkge1xuXHQgICAgdmlld1tpXSA9IHMuY2hhckNvZGVBdChpKSAmIDB4RkY7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGJ1Zjtcblx0fVxuXG5cdHZhciB0eXBlcyA9IHtcblx0ICBudW1iZXI6IFwiblwiLFxuXHQgIGRhdGU6IFwiblwiLFxuXHQgIHN0cmluZzogXCJzXCIsXG5cdCAgYm9vbGVhbjogXCJiXCJcblx0fTtcblx0dmFyIHRhYmxlID0gXCJfdGFibGVcIjtcblxuXHRmdW5jdGlvbiBnZXRFeGNlbERhdGEoZGF0YSwgc2NoZW1lLCBzcGFucywgc3R5bGVzLCBvcHRpb25zKSB7XG5cdCAgdmFyIHdzID0ge307XG5cdCAgdmFyIHJhbmdlID0ge1xuXHQgICAgczoge1xuXHQgICAgICBjOiAxMDAwMDAwMCxcblx0ICAgICAgcjogMTAwMDAwMDBcblx0ICAgIH0sXG5cdCAgICBlOiB7XG5cdCAgICAgIGM6IDAsXG5cdCAgICAgIHI6IDBcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgZm9yICh2YXIgUiA9IDA7IFIgIT0gZGF0YS5sZW5ndGg7ICsrUikge1xuXHQgICAgZm9yICh2YXIgQyA9IDA7IEMgIT0gZGF0YVtSXS5sZW5ndGg7ICsrQykge1xuXHQgICAgICBpZiAocmFuZ2Uucy5yID4gUikgcmFuZ2Uucy5yID0gUjtcblx0ICAgICAgaWYgKHJhbmdlLnMuYyA+IEMpIHJhbmdlLnMuYyA9IEM7XG5cdCAgICAgIGlmIChyYW5nZS5lLnIgPCBSKSByYW5nZS5lLnIgPSBSO1xuXHQgICAgICBpZiAocmFuZ2UuZS5jIDwgQykgcmFuZ2UuZS5jID0gQztcblx0ICAgICAgdmFyIGNlbGwgPSB7XG5cdCAgICAgICAgdjogZGF0YVtSXVtDXVxuXHQgICAgICB9O1xuXHQgICAgICBpZiAoY2VsbC52ID09PSBudWxsKSBjb250aW51ZTtcblx0ICAgICAgdmFyIGNlbGxfcmVmID0gWExTWC51dGlscy5lbmNvZGVfY2VsbCh7XG5cdCAgICAgICAgYzogQyxcblx0ICAgICAgICByOiBSXG5cdCAgICAgIH0pO1xuXHQgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBjZWxsLnYudG9TdHJpbmcoKTtcblx0ICAgICAgdmFyIGlzRm9ybXVsYSA9IHN0cmluZ1ZhbHVlLmNoYXJBdCgwKSA9PT0gXCI9XCI7IC8vIHNldCB0eXBlIGJhc2VkIG9uIGNvbHVtbidzIGNvbmZpZ1xuXHQgICAgICAvLyBza2lwIGhlYWRlcnMgYW5kIGZvcm11bGEgYmFzZWQgY2VsbHNcblxuXHQgICAgICB2YXIgaGVhZGVyID0gKG9wdGlvbnMuZG9jSGVhZGVyID8gMiA6IDApICsgc2NoZW1lWzBdLmhlYWRlci5sZW5ndGg7XG5cblx0ICAgICAgaWYgKFIgPj0gaGVhZGVyICYmICFpc0Zvcm11bGEpIHtcblx0ICAgICAgICB2YXIgY29sdW1uID0gc2NoZW1lW0NdO1xuXHQgICAgICAgIGlmIChjb2x1bW4udHlwZSkgY2VsbC50ID0gdHlwZXNbY29sdW1uLnR5cGVdIHx8IFwiXCI7XG5cdCAgICAgICAgaWYgKGNvbHVtbi5mb3JtYXQpIGNlbGwueiA9IGNvbHVtbi5mb3JtYXQ7XG5cdCAgICAgIH0gLy8gc2V0IHR5cGUgYmFzZWQgb24gY2VsbCdzIHZhbHVlXG5cblxuXHQgICAgICBpZiAoY2VsbC52IGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICAgIGNlbGwudCA9IGNlbGwudCB8fCBcIm5cIjtcblx0ICAgICAgICBjZWxsLnogPSBjZWxsLnogfHwgWExTWC5TU0ZbdGFibGVdWzE0XTtcblx0ICAgICAgICBjZWxsLnYgPSBleGNlbERhdGUoY2VsbC52KTtcblx0ICAgICAgfSBlbHNlIGlmICghY2VsbC50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjZWxsLnYgPT09IFwiYm9vbGVhblwiKSBjZWxsLnQgPSBcImJcIjtlbHNlIGlmICh0eXBlb2YgY2VsbC52ID09PSBcIm51bWJlclwiIHx8IHBhcnNlRmxvYXQoY2VsbC52KSA9PSBjZWxsLnYpIHtcblx0ICAgICAgICAgIGNlbGwudiA9IGNlbGwudiAqIDE7XG5cdCAgICAgICAgICBjZWxsLnQgPSBcIm5cIjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gY29udmVydCBhbnkgb3RoZXIgb2JqZWN0IHRvIGEgc3RyaW5nXG5cdCAgICAgICAgICBjZWxsLnYgPSBzdHJpbmdWYWx1ZTtcblxuXHQgICAgICAgICAgaWYgKGlzRm9ybXVsYSkge1xuXHQgICAgICAgICAgICBjZWxsLnQgPSBcIm5cIjtcblx0ICAgICAgICAgICAgY2VsbC5mID0gY2VsbC52O1xuXHQgICAgICAgICAgICBkZWxldGUgY2VsbC52O1xuXHQgICAgICAgICAgfSBlbHNlIGNlbGwudCA9IFwic1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzdHlsZXMpIHtcblx0ICAgICAgICB2YXIgY2VsbFN0eWxlID0gZ2V0U3R5bGVzKFIsIEMsIHN0eWxlcyk7XG5cblx0ICAgICAgICBpZiAoY2VsbFN0eWxlLmZvcm1hdCkge1xuXHQgICAgICAgICAgY2VsbC56ID0gY2VsbFN0eWxlLmZvcm1hdDtcblx0ICAgICAgICAgIGRlbGV0ZSBjZWxsU3R5bGUuZm9ybWF0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNlbGwucyA9IGNlbGxTdHlsZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdzW2NlbGxfcmVmXSA9IGNlbGw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHJhbmdlLnMuYyA8IDEwMDAwMDAwKSB3c1tcIiFyZWZcIl0gPSBYTFNYLnV0aWxzLmVuY29kZV9yYW5nZShyYW5nZSk7XG5cdCAgd3NbXCIhcm93c1wiXSA9IGdldFJvd0hlaWdodHMoc2NoZW1lLmhlaWdodHMpO1xuXHQgIHdzW1wiIWNvbHNcIl0gPSBnZXRDb2x1bW5zV2lkdGhzKHNjaGVtZSk7XG5cdCAgaWYgKHNwYW5zLmxlbmd0aCkgd3NbXCIhbWVyZ2VzXCJdID0gc3BhbnM7XG5cdCAgcmV0dXJuIHdzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Um93SGVpZ2h0cyhoZWlnaHRzKSB7XG5cdCAgZm9yICh2YXIgaSBpbiBoZWlnaHRzKSB7XG5cdCAgICBoZWlnaHRzW2ldID0ge1xuXHQgICAgICBocHg6IGhlaWdodHNbaV0sXG5cdCAgICAgIGhwdDogaGVpZ2h0c1tpXSAqIDAuNzVcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGhlaWdodHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTdHlsZXMociwgYywgc3R5bGVzKSB7XG5cdCAgLy9yb3cgaW5kZXgsIGNvbHVtbiBpbmRleCwgc3R5bGVzIGFycmF5XG5cdCAgaWYgKHN0eWxlc1tyXSAmJiBzdHlsZXNbcl1bY10pIHJldHVybiBzdHlsZXNbcl1bY107XG5cdCAgcmV0dXJuIFwiXCI7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTcGFucyh2aWV3LCBvcHRpb25zKSB7XG5cdCAgdmFyIGlzVGFibGUgPSB2aWV3LmdldENvbHVtbkNvbmZpZztcblx0ICB2YXIgcHVsbCA9IHZpZXcuX3NwYW5zX3B1bGw7XG5cdCAgdmFyIHNwYW5zID0gW107XG5cblx0ICBpZiAoaXNUYWJsZSkge1xuXHQgICAgaWYgKG9wdGlvbnMuaGVhZGVyICE9PSBmYWxzZSkgc3BhbnMgPSBnZXRIZWFkZXJTcGFucyh2aWV3LCBvcHRpb25zLCBcImhlYWRlclwiLCBzcGFucyk7XG5cblx0ICAgIGlmIChwdWxsKSB7XG5cdCAgICAgIHZhciB4YyA9IG9wdGlvbnMueENvcnJlY3Rpb24gfHwgMDtcblx0ICAgICAgdmFyIHljID0gb3B0aW9ucy55Q29ycmVjdGlvbiB8fCAwO1xuXG5cdCAgICAgIGZvciAodmFyIHJvdyBpbiBwdWxsKSB7XG5cdCAgICAgICAgLy97IHM6e2M6MSwgcjowfSwgZTp7YzozLCByOjB9IH1cblx0ICAgICAgICB2YXIgY29scyA9IHB1bGxbcm93XTtcblxuXHQgICAgICAgIGZvciAodmFyIGNvbCBpbiBjb2xzKSB7XG5cdCAgICAgICAgICB2YXIgc2MgPSB2aWV3LmdldENvbHVtbkluZGV4KGNvbCkgLSB4Yztcblx0ICAgICAgICAgIHZhciBzciA9IHZpZXcuZ2V0SW5kZXhCeUlkKHJvdykgLSB5Yztcblx0ICAgICAgICAgIGlmIChzYyA8IDAgfHwgc3IgPCAwKSAvL2hpZGRlbiBjb2xzL3Jvd3Ncblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB2YXIgZWMgPSBzYyArIGNvbHNbY29sXVswXSAtIDE7XG5cdCAgICAgICAgICB2YXIgZXIgPSBzciArIChjb2xzW2NvbF1bMV0gLSAxKTtcblx0ICAgICAgICAgIHNwYW5zLnB1c2goe1xuXHQgICAgICAgICAgICBzOiB7XG5cdCAgICAgICAgICAgICAgYzogc2MsXG5cdCAgICAgICAgICAgICAgcjogc3Jcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZToge1xuXHQgICAgICAgICAgICAgIGM6IGVjLFxuXHQgICAgICAgICAgICAgIHI6IGVyXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0aW9ucy5mb290ZXIgIT09IGZhbHNlKSBzcGFucyA9IGdldEhlYWRlclNwYW5zKHZpZXcsIG9wdGlvbnMsIFwiZm9vdGVyXCIsIHNwYW5zKTtcblx0ICB9XG5cblx0ICByZXR1cm4gc3BhbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIZWFkZXJTcGFucyh2aWV3LCBvcHRpb25zLCBncm91cCwgc3BhbnMpIHtcblx0ICB2YXIgY29sdW1ucyA9IHZpZXcuY29uZmlnLmNvbHVtbnM7XG5cdCAgdmFyIGRlbHRhID0gKG9wdGlvbnMuZG9jSGVhZGVyID8gMiA6IDApICsgKGdyb3VwID09IFwiaGVhZGVyXCIgPyAwIDogKG9wdGlvbnMuaGVhZGVyICE9PSBmYWxzZSA/IHZpZXcuX2hlYWRlcnMubGVuZ3RoIDogMCkgKyB2aWV3LmNvdW50KCkpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgaGVhZGVyID0gY29sdW1uc1tpXVtncm91cF07XG5cblx0ICAgIGZvciAodmFyIGggPSAwOyBoIDwgaGVhZGVyLmxlbmd0aDsgaCsrKSB7XG5cdCAgICAgIGlmIChoZWFkZXJbaF0gJiYgKGhlYWRlcltoXS5jb2xzcGFuIHx8IGhlYWRlcltoXS5yb3dzcGFuKSkge1xuXHQgICAgICAgIHNwYW5zLnB1c2goe1xuXHQgICAgICAgICAgczoge1xuXHQgICAgICAgICAgICBjOiBpLFxuXHQgICAgICAgICAgICByOiBoICsgZGVsdGFcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBlOiB7XG5cdCAgICAgICAgICAgIGM6IGkgKyAoaGVhZGVyW2hdLmNvbHNwYW4gfHwgMSkgLSAxLFxuXHQgICAgICAgICAgICByOiBoICsgKGhlYWRlcltoXS5yb3dzcGFuIHx8IDEpIC0gMSArIGRlbHRhXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3BhbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleGNlbERhdGUoZGF0ZSkge1xuXHQgIHJldHVybiBNYXRoLnJvdW5kKDI1NTY5ICsgZGF0ZSAvICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb2x1bW5zV2lkdGhzKHNjaGVtZSkge1xuXHQgIHZhciB3c2NvbHMgPSBbXTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1lLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB3c2NvbHMucHVzaCh7XG5cdCAgICAgIHdjaDogc2NoZW1lW2ldLndpZHRoXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICByZXR1cm4gd3Njb2xzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsbGJhY2soY29uZmlnLCByZXN1bHQpIHtcblx0ICBjb25maWcudHlwZS5pbmRleE9mKFwiY29uZmlybVwiKSAhPSAtMSAmJiByZXN1bHQgPT09IGZhbHNlID8gY29uZmlnLl9wcm9taXNlLnJlamVjdCgpIDogY29uZmlnLl9wcm9taXNlLnJlc29sdmUocmVzdWx0KTtcblx0ICB2YXIgdXNlcmNhbGwgPSBjb25maWcuY2FsbGJhY2s7XG5cdCAgaWYgKHVzZXJjYWxsKSB1c2VyY2FsbChyZXN1bHQsIGNvbmZpZy5kZXRhaWxzKTtcblx0ICBtb2RhbGJveC5oaWRlKGNvbmZpZy5pZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBtb2RhbF9rZXkoZSkge1xuXHQgIHZhciBjb3VudCA9IG1vZGFsYm94Lm9yZGVyLmxlbmd0aDtcblxuXHQgIGlmIChjb3VudCA+IDAgJiYgbWVzc2FnZS5rZXlib2FyZCkge1xuXHQgICAgZSA9IGUgfHwgZXZlbnQkMTtcblx0ICAgIHZhciBjb2RlID0gZS53aGljaCB8fCBldmVudCQxLmtleUNvZGU7XG5cdCAgICB2YXIgbGFzdE1vZGFsYm94ID0gbW9kYWxib3gucHVsbFttb2RhbGJveC5vcmRlcltjb3VudCAtIDFdXTtcblx0ICAgIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMzIpIGNhbGxiYWNrKGxhc3RNb2RhbGJveCwgdHJ1ZSk7XG5cdCAgICBpZiAoY29kZSA9PSAyNykgY2FsbGJhY2sobGFzdE1vZGFsYm94LCBmYWxzZSk7XG5cdCAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgcmV0dXJuICEoZS5jYW5jZWxCdWJibGUgPSB0cnVlKTtcblx0ICB9XG5cdH1cblxuXHRldmVudCQxKGRvY3VtZW50LCBcImtleWRvd25cIiwgbW9kYWxfa2V5LCB7XG5cdCAgY2FwdHVyZTogdHJ1ZVxuXHR9KTtcblxuXHRmdW5jdGlvbiBtb2RhbGl0eShtb2RlLCBjb250YWluZXIpIHtcblx0ICB2YXIgbm9kZSA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuXHQgIHZhciBjb3ZlcjtcblxuXHQgIGlmIChpc1VuZGVmaW5lZChub2RlLm1vZGFsaXR5KSkge1xuXHQgICAgY292ZXIgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICBjbGFzczogXCJ3ZWJpeF9tb2RhbF9jb3ZlclwiLFxuXHQgICAgICBzdHlsZTogXCJwb3NpdGlvbjpcIiArIChjb250YWluZXIgPyBcImFic29sdXRlXCIgOiBcImZpeGVkXCIpICsgXCI7XCJcblx0ICAgIH0pO1xuXHQgICAgY292ZXIub25rZXlkb3duID0gbW9kYWxfa2V5O1xuXG5cdCAgICBpZiAoY29udGFpbmVyKSB7XG5cdCAgICAgIHZhciBwb3NpdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikucG9zaXRpb247XG5cdCAgICAgIGlmIChwb3NpdGlvbiAhPSBcImZpeGVkXCIgJiYgcG9zaXRpb24gIT0gXCJhYnNvbHV0ZVwiICYmIHBvc2l0aW9uICE9IFwic3RpY2t5XCIgJiYgcG9zaXRpb24gIT0gXCJyZWxhdGl2ZVwiKSBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHQgICAgfVxuXG5cdCAgICBub2RlLmFwcGVuZENoaWxkKGNvdmVyKTtcblx0ICAgIG5vZGUubW9kYWxpdHkgPSAxO1xuXHQgIH0gZWxzZSBtb2RlID8gbm9kZS5tb2RhbGl0eSsrIDogbm9kZS5tb2RhbGl0eS0tOyAvL3RyaWdnZXIgdmlzaWJpbGl0eSBvbmx5IGlmIG5lY2Vzc2FyeVxuXG5cblx0ICBpZiAobW9kZSAmJiBub2RlLm1vZGFsaXR5ID09PSAxIHx8IG5vZGUubW9kYWxpdHkgPT09IDApIHtcblx0ICAgIGlmIChjb3ZlcikgY292ZXIuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7ZWxzZSB7XG5cdCAgICAgIGNvdmVyID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiLndlYml4X21vZGFsX2NvdmVyXCIpO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY292ZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoY292ZXJbaV0ucGFyZW50Tm9kZSA9PSBub2RlKSB7XG5cdCAgICAgICAgICBjb3ZlcltpXS5zdHlsZS5kaXNwbGF5ID0gbm9kZS5tb2RhbGl0eSA9PSAxID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwibm9uZVwiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gYnV0dG9uKHRleHQsIHJlc3VsdCwgY2xhc3NOYW1lKSB7XG5cdCAgcmV0dXJuIFwiPGRpdiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBhcmlhLWxhYmVsPSdcIiArIHRleHQgKyBcIicgY2xhc3M9J3dlYml4X3BvcHVwX2J1dHRvblwiICsgKGNsYXNzTmFtZSA/IFwiIFwiICsgY2xhc3NOYW1lIDogXCJcIikgKyBcIicgcmVzdWx0PSdcIiArIHJlc3VsdCArIFwiJyA+PGRpdj5cIiArIHRleHQgKyBcIjwvZGl2PjwvZGl2PlwiO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5mbyh0ZXh0KSB7XG5cdCAgaWYgKCF0LmFyZWEpIHtcblx0ICAgIHQuYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG5cdCAgICB0LmFyZWEuY2xhc3NOYW1lID0gXCJ3ZWJpeF9tZXNzYWdlX2FyZWFcIjtcblx0ICAgIHQuYXJlYS5zdHlsZVt0LnBvc2l0aW9uXSA9IFwiNXB4XCI7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQuYXJlYSk7XG5cdCAgfVxuXG5cdCAgdC5hcmVhLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhbGVydFwiKTtcblx0ICB0LmFyZWEuc2V0QXR0cmlidXRlKFwiYXJpYS1hdG9taWNcIiwgdHJ1ZSk7XG5cdCAgdC5oaWRlKHRleHQuaWQpO1xuXHQgIHZhciBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcblx0ICBtZXNzYWdlLmlubmVySFRNTCA9IFwiPGRpdj5cIiArIHRleHQudGV4dCArIFwiPC9kaXY+XCI7XG5cdCAgbWVzc2FnZS5jbGFzc05hbWUgPSBcIndlYml4X21lc3NhZ2Ugd2ViaXhfXCIgKyB0ZXh0LnR5cGU7XG5cblx0ICBtZXNzYWdlLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB0LmhpZGUodGV4dC5pZCk7XG5cdCAgICB0ZXh0ID0gbnVsbDtcblx0ICB9O1xuXHQgIGlmICh0LnBvc2l0aW9uID09IFwiYm90dG9tXCIgJiYgdC5hcmVhLmZpcnN0Q2hpbGQpIHQuYXJlYS5pbnNlcnRCZWZvcmUobWVzc2FnZSwgdC5hcmVhLmZpcnN0Q2hpbGQpO2Vsc2UgdC5hcmVhLmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xuXHQgIGlmICh0ZXh0LmV4cGlyZSA+IDApIHQudGltZXJzW3RleHQuaWRdID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgdC5oaWRlKHRleHQuaWQpO1xuXHQgIH0sIHRleHQuZXhwaXJlKTsgLy9zdHlsaW5nIGZvciBhbmltYXRpb25cblxuXHQgIG1lc3NhZ2Uuc3R5bGUuaGVpZ2h0ID0gbWVzc2FnZS5vZmZzZXRIZWlnaHQgLSAyICsgXCJweFwiO1xuXHQgIHQucHVsbFt0ZXh0LmlkXSA9IG1lc3NhZ2U7XG5cdCAgbWVzc2FnZSA9IG51bGw7XG5cdCAgcmV0dXJuIHRleHQuaWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBfYm94U3RydWN0dXJlKGNvbmZpZywgb2ssIGNhbmNlbCkge1xuXHQgIHZhciBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuXHQgIGJveC5jbGFzc05hbWUgPSBcIiB3ZWJpeF9tb2RhbF9ib3ggd2ViaXhfXCIgKyBjb25maWcudHlwZTtcblx0ICBib3guc2V0QXR0cmlidXRlKFwid2ViaXhib3hcIiwgMSk7XG5cdCAgYm94LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhbGVydGRpYWxvZ1wiKTtcblx0ICBib3guc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBjb25maWcudGl0bGUgfHwgXCJcIik7XG5cdCAgYm94LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcblx0ICB2YXIgaW5uZXIgPSBcIlwiO1xuXHQgIGlmIChjb25maWcud2lkdGgpIGJveC5zdHlsZS53aWR0aCA9IGNvbmZpZy53aWR0aCArIChydWxlcy5pc051bWJlcihjb25maWcud2lkdGgpID8gXCJweFwiIDogXCJcIik7XG5cdCAgaWYgKGNvbmZpZy5oZWlnaHQpIGJveC5zdHlsZS5oZWlnaHQgPSBjb25maWcuaGVpZ2h0ICsgKHJ1bGVzLmlzTnVtYmVyKGNvbmZpZy5oZWlnaHQpID8gXCJweFwiIDogXCJcIik7XG5cdCAgaWYgKGNvbmZpZy50aXRsZSkgaW5uZXIgKz0gXCI8ZGl2IGNsYXNzPVxcXCJ3ZWJpeF9wb3B1cF90aXRsZVxcXCI+XCIgKyBjb25maWcudGl0bGUgKyBcIjwvZGl2PlwiO1xuXHQgIGlubmVyICs9IFwiPGRpdiBjbGFzcz1cXFwid2ViaXhfcG9wdXBfdGV4dFxcXCI+PHNwYW4+XCIgKyAoY29uZmlnLmNvbnRlbnQgPyBcIlwiIDogY29uZmlnLnRleHQpICsgXCI8L3NwYW4+PC9kaXY+PGRpdiAgY2xhc3M9XFxcIndlYml4X3BvcHVwX2NvbnRyb2xzXFxcIj5cIjtcblx0ICBpZiAoY2FuY2VsKSBpbm5lciArPSBidXR0b24oY29uZmlnLmNhbmNlbCB8fCBpMThuLm1lc3NhZ2UuY2FuY2VsLCBmYWxzZSk7XG5cdCAgaWYgKG9rKSBpbm5lciArPSBidXR0b24oY29uZmlnLm9rIHx8IGkxOG4ubWVzc2FnZS5vaywgdHJ1ZSwgXCJjb25maXJtXCIpO1xuXG5cdCAgaWYgKGNvbmZpZy5idXR0b25zICYmICFvayAmJiAhY2FuY2VsKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5idXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlubmVyICs9IGJ1dHRvbihjb25maWcuYnV0dG9uc1tpXSwgaSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaW5uZXIgKz0gXCI8L2Rpdj5cIjtcblx0ICBib3guaW5uZXJIVE1MID0gaW5uZXI7XG5cblx0ICBpZiAoY29uZmlnLmNvbnRlbnQpIHtcblx0ICAgIHZhciBub2RlID0gY29uZmlnLmNvbnRlbnQ7XG5cdCAgICBpZiAodHlwZW9mIG5vZGUgPT0gXCJzdHJpbmdcIikgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpO1xuXHQgICAgaWYgKG5vZGUuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIikgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0ICAgIGJveC5jaGlsZE5vZGVzW2NvbmZpZy50aXRsZSA/IDEgOiAwXS5hcHBlbmRDaGlsZChub2RlKTtcblx0ICB9XG5cblx0ICBib3gub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBlID0gZSB8fCBldmVudCQxO1xuXHQgICAgdmFyIHNvdXJjZSA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0ICAgIGlmICghc291cmNlLmNsYXNzTmFtZSkgc291cmNlID0gc291cmNlLnBhcmVudE5vZGU7XG5cblx0ICAgIGlmIChzb3VyY2UuY2xhc3NOYW1lLmluZGV4T2YoXCJ3ZWJpeF9wb3B1cF9idXR0b25cIikgIT0gLTEpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJyZXN1bHRcIik7XG5cdCAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PSBcInRydWVcIiB8fCAocmVzdWx0ID09IFwiZmFsc2VcIiA/IGZhbHNlIDogcmVzdWx0KTtcblx0ICAgICAgY2FsbGJhY2soY29uZmlnLCByZXN1bHQpO1xuXHQgICAgfVxuXG5cdCAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG5cdCAgfTtcblxuXHQgIGNvbmZpZy5fYm94ID0gYm94O1xuXHQgIHJldHVybiBib3g7XG5cdH1cblxuXHRtb2RhbGJveC5wdWxsID0ge307XG5cdG1vZGFsYm94Lm9yZGVyID0gW107XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUJveChjb25maWcsIG9rLCBjYW5jZWwpIHtcblx0ICB2YXIgYm94ID0gY29uZmlnLnRhZ05hbWUgPyBjb25maWcgOiBfYm94U3RydWN0dXJlKGNvbmZpZywgb2ssIGNhbmNlbCk7XG5cdCAgdmFyIGNvbnRhaW5lcldpZHRoID0gY29uZmlnLmNvbnRhaW5lciA/IGNvbmZpZy5jb250YWluZXIub2Zmc2V0V2lkdGggOiB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cdCAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbmZpZy5jb250YWluZXIgPyBjb25maWcuY29udGFpbmVyLm9mZnNldEhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXHQgIGlmIChjb25maWcuY29udGFpbmVyKSBib3guc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdCAgdG9Ob2RlKChjb25maWcuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKGJveCkpO1xuXHQgIG1vZGFsaXR5KHRydWUsIGNvbmZpZy5jb250YWluZXIpO1xuXHQgIHZhciB4ID0gY29uZmlnLmxlZnQgfHwgTWF0aC5hYnMoTWF0aC5mbG9vcigoY29udGFpbmVyV2lkdGggLSBib3gub2Zmc2V0V2lkdGgpIC8gMikpO1xuXHQgIHZhciB5ID0gY29uZmlnLnRvcCB8fCBNYXRoLmFicyhNYXRoLmZsb29yKChjb250YWluZXJIZWlnaHQgLSBib3gub2Zmc2V0SGVpZ2h0KSAvIDIpKTtcblx0ICBpZiAoY29uZmlnLnBvc2l0aW9uID09IFwidG9wXCIpIGJveC5zdHlsZS50b3AgPSBcIi0zcHhcIjtlbHNlIGJveC5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuXHQgIGJveC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjsgLy9uZWNlc3NhcnkgZm9yIElFIG9ubHlcblxuXHQgIGJveC5vbmtleWRvd24gPSBtb2RhbF9rZXk7XG5cdCAgYm94LmZvY3VzKCk7XG5cdCAgaWYgKCFjb25maWcuaWQpIGNvbmZpZy5pZCA9IF91aWQoXCJtb2RhbGJveFwiKTtlbHNlIGlmIChtb2RhbGJveC5wdWxsW2NvbmZpZy5pZF0pIHtcblx0ICAgIG1vZGFsYm94LmhpZGUoY29uZmlnLmlkKTtcblx0ICB9XG5cdCAgbW9kYWxib3gub3JkZXIucHVzaChjb25maWcuaWQpO1xuXHQgIG1vZGFsYm94LnB1bGxbY29uZmlnLmlkXSA9IGNvbmZpZztcblx0ICBjb25maWcuX3Byb21pc2UgPSBEZWZlcnJlZC5kZWZlcigpO1xuXHQgIHJldHVybiBjb25maWcuX3Byb21pc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBhbGVydFBvcHVwKGNvbmZpZykge1xuXHQgIHJldHVybiBfY3JlYXRlQm94KGNvbmZpZywgdHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb25maXJtUG9wdXAoY29uZmlnKSB7XG5cdCAgcmV0dXJuIF9jcmVhdGVCb3goY29uZmlnLCB0cnVlLCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJveFBvcHVwKGNvbmZpZykge1xuXHQgIHJldHVybiBfY3JlYXRlQm94KGNvbmZpZyk7XG5cdH1cblxuXHRmdW5jdGlvbiBib3hfcGFyYW1zKHRleHQsIHR5cGUsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKF90eXBlb2YodGV4dCkgIT0gXCJvYmplY3RcIikge1xuXHQgICAgaWYgKHR5cGVvZiB0eXBlID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICBjYWxsYmFjayA9IHR5cGU7XG5cdCAgICAgIHR5cGUgPSBcIlwiO1xuXHQgICAgfVxuXG5cdCAgICB0ZXh0ID0ge1xuXHQgICAgICB0ZXh0OiB0ZXh0LFxuXHQgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICBjYWxsYmFjazogY2FsbGJhY2tcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRleHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJhbXModGV4dCwgdHlwZSwgZXhwaXJlLCBpZCkge1xuXHQgIGlmIChfdHlwZW9mKHRleHQpICE9IFwib2JqZWN0XCIpIHRleHQgPSB7XG5cdCAgICB0ZXh0OiB0ZXh0LFxuXHQgICAgdHlwZTogdHlwZSxcblx0ICAgIGV4cGlyZTogZXhwaXJlLFxuXHQgICAgaWQ6IGlkXG5cdCAgfTtcblx0ICB0ZXh0LmlkID0gdGV4dC5pZCB8fCBfdWlkKFwibWVzc2FnZVwiKTtcblx0ICB0ZXh0LmV4cGlyZSA9IHRleHQuZXhwaXJlIHx8IHQuZXhwaXJlO1xuXHQgIHJldHVybiB0ZXh0O1xuXHR9XG5cblx0ZnVuY3Rpb24gYWxlcnQoKSB7XG5cdCAgdmFyIHRleHQgPSBib3hfcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgdGV4dC50eXBlID0gdGV4dC50eXBlIHx8IFwiYWxlcnRcIjtcblx0ICByZXR1cm4gYWxlcnRQb3B1cCh0ZXh0KTtcblx0fVxuXHRmdW5jdGlvbiBjb25maXJtKCkge1xuXHQgIHZhciB0ZXh0ID0gYm94X3BhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHRleHQudHlwZSA9IHRleHQudHlwZSB8fCBcImNvbmZpcm1cIjtcblx0ICByZXR1cm4gY29uZmlybVBvcHVwKHRleHQpO1xuXHR9XG5cdGZ1bmN0aW9uIG1vZGFsYm94KCkge1xuXHQgIHZhciB0ZXh0ID0gYm94X3BhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHRleHQudHlwZSA9IHRleHQudHlwZSB8fCBcImFsZXJ0XCI7XG5cdCAgcmV0dXJuIGJveFBvcHVwKHRleHQpO1xuXHR9XG5cblx0bW9kYWxib3guaGlkZSA9IGZ1bmN0aW9uIChpZCkge1xuXHQgIGlmIChpZCAmJiBtb2RhbGJveC5wdWxsW2lkXSkge1xuXHQgICAgdmFyIG5vZGUgPSBtb2RhbGJveC5wdWxsW2lkXS5fYm94O1xuXG5cdCAgICBpZiAobm9kZSkge1xuXHQgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdCAgICAgIG1vZGFsYm94Lm9yZGVyLnNwbGljZShtb2RhbGJveC5vcmRlci5pbmRleE9mKGlkKSwgMSk7XG5cdCAgICAgIG1vZGFsaXR5KGZhbHNlLCBtb2RhbGJveC5wdWxsW2lkXS5jb250YWluZXIpO1xuXHQgICAgICBkZWxldGUgbW9kYWxib3gucHVsbFtpZF07XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdG1vZGFsYm94LmhpZGVBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZm9yICh2YXIgaWQgaW4gbW9kYWxib3gucHVsbCkge1xuXHQgICAgdGhpcy5oaWRlKGlkKTtcblx0ICB9XG5cdH07XG5cblx0ZnVuY3Rpb24gbWVzc2FnZSh0ZXh0LCB0eXBlLCBleHBpcmUsIGlkKSB7XG5cdCAgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG5cdCAgdGV4dCA9IHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIHRleHQudHlwZSA9IHRleHQudHlwZSB8fCBcImluZm9cIjtcblx0ICB2YXIgc3VidHlwZSA9IHRleHQudHlwZS5zcGxpdChcIi1cIilbMF07XG5cblx0ICBzd2l0Y2ggKHN1YnR5cGUpIHtcblx0ICAgIGNhc2UgXCJhbGVydFwiOlxuXHQgICAgICByZXR1cm4gYWxlcnRQb3B1cCh0ZXh0KTtcblxuXHQgICAgY2FzZSBcImNvbmZpcm1cIjpcblx0ICAgICAgcmV0dXJuIGNvbmZpcm1Qb3B1cCh0ZXh0KTtcblxuXHQgICAgY2FzZSBcIm1vZGFsYm94XCI6XG5cdCAgICAgIHJldHVybiBib3hQb3B1cCh0ZXh0KTtcblxuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIGluZm8odGV4dCk7XG5cdCAgfVxuXHR9XG5cdHZhciB0ID0gbWVzc2FnZTtcblx0dC5leHBpcmUgPSA0MDAwO1xuXHR0LmtleWJvYXJkID0gdHJ1ZTtcblx0dC5wb3NpdGlvbiA9IFwidG9wXCI7XG5cdHQucHVsbCA9IHt9O1xuXHR0LnRpbWVycyA9IHt9O1xuXG5cdHQuaGlkZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBrZXkgaW4gdC5wdWxsKSB7XG5cdCAgICB0LmhpZGUoa2V5KTtcblx0ICB9XG5cdH07XG5cblx0dC5oaWRlID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgdmFyIG9iaiA9IHQucHVsbFtpZF07XG5cblx0ICBpZiAob2JqICYmIG9iai5wYXJlbnROb2RlKSB7XG5cdCAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIG9iai5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9iaik7XG5cdCAgICAgIG9iaiA9IG51bGw7XG5cdCAgICB9LCAyMDAwKTsgLy9zdHlsaW5nIGZvciBhbmltYXRpb25cblxuXHQgICAgb2JqLnN0eWxlLmhlaWdodCA9IDA7XG5cdCAgICBvYmouY2xhc3NOYW1lICs9IFwiIGhpZGRlblwiO1xuXHQgICAgdC5hcmVhLnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIik7XG5cdCAgICBpZiAodC50aW1lcnNbaWRdKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHQudGltZXJzW2lkXSk7XG5cdCAgICBkZWxldGUgdC5wdWxsW2lkXTtcblx0ICB9XG5cdH07IC8vb3ZlcnJpZGUgY2lyY3VhbHIgZGVwZW5kZW5jaWVzXG5cblxuXHRkZWZpbmUoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuXG5cdGZ1bmN0aW9uIGVkaXRTdG9wKCkge1xuXHQgIGNhbGxFdmVudChcIm9uRWRpdEVuZFwiLCBbXSk7XG5cdH1cblxuXHRpZiAoZW52LmlzSUU4KSB7XG5cdCAgLy8gTm90IHJlYWxseSBhIHBvbHlmaWxsLCBzaWxlbmNlIHRoZSBlc01vZHVsZSBmbGFnXG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCBkYXRhKSB7XG5cdCAgICBvYmpba2V5XSA9IGRhdGEudmFsdWU7XG5cdCAgfTtcblx0fVxuXG5cdHZhciBlbiA9IHtcblx0ICBncm91cERlbGltaXRlcjogXCIsXCIsXG5cdCAgZ3JvdXBTaXplOiAzLFxuXHQgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgIGRlY2ltYWxTaXplOiAyLFxuXHQgIGRhdGVGb3JtYXQ6IFwiJW0vJWQvJVlcIixcblx0ICB0aW1lRm9ybWF0OiBcIiVoOiVpICVBXCIsXG5cdCAgbG9uZ0RhdGVGb3JtYXQ6IFwiJWQgJUYgJVlcIixcblx0ICBmdWxsRGF0ZUZvcm1hdDogXCIlbS8lZC8lWSAlaDolaSAlQVwiLFxuXHQgIGFtOiBbXCJhbVwiLCBcIkFNXCJdLFxuXHQgIHBtOiBbXCJwbVwiLCBcIlBNXCJdLFxuXHQgIHByaWNlOiBcIiR7b2JqfVwiLFxuXHQgIHByaWNlU2V0dGluZ3M6IHtcblx0ICAgIGdyb3VwRGVsaW1pdGVyOiBcIixcIixcblx0ICAgIGdyb3VwU2l6ZTogMyxcblx0ICAgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgICAgZGVjaW1hbFNpemU6IDJcblx0ICB9LFxuXHQgIGZpbGVTaXplOiBbXCJiXCIsIFwiS2JcIiwgXCJNYlwiLCBcIkdiXCIsIFwiVGJcIiwgXCJQYlwiLCBcIkViXCJdLFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICBtb250aEZ1bGw6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuXHQgICAgbW9udGhTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxuXHQgICAgZGF5RnVsbDogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG5cdCAgICBkYXlTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuXHQgICAgaG91cnM6IFwiSG91cnNcIixcblx0ICAgIG1pbnV0ZXM6IFwiTWludXRlc1wiLFxuXHQgICAgZG9uZTogXCJEb25lXCIsXG5cdCAgICBjbGVhcjogXCJDbGVhclwiLFxuXHQgICAgdG9kYXk6IFwiVG9kYXlcIlxuXHQgIH0sXG5cdCAgZGF0YUV4cG9ydDoge1xuXHQgICAgcGFnZTogXCJQYWdlXCIsXG5cdCAgICBvZjogXCJvZlwiXG5cdCAgfSxcblx0ICBQREZ2aWV3ZXI6IHtcblx0ICAgIG9mOiBcIm9mXCIsXG5cdCAgICBhdXRvbWF0aWNab29tOiBcIkF1dG9tYXRpYyBab29tXCIsXG5cdCAgICBhY3R1YWxTaXplOiBcIkFjdHVhbCBTaXplXCIsXG5cdCAgICBwYWdlRml0OiBcIlBhZ2UgRml0XCIsXG5cdCAgICBwYWdlV2lkdGg6IFwiUGFnZSBXaWR0aFwiLFxuXHQgICAgcGFnZUhlaWdodDogXCJQYWdlIEhlaWdodFwiLFxuXHQgICAgZW50ZXJQYXNzd29yZDogXCJFbnRlciBwYXNzd29yZFwiLFxuXHQgICAgcGFzc3dvcmRFcnJvcjogXCJXcm9uZyBwYXNzd29yZFwiXG5cdCAgfSxcblx0ICBhcmlhOiB7XG5cdCAgICBjYWxlbmRhcjogXCJDYWxlbmRhclwiLFxuXHQgICAgaW5jcmVhc2VWYWx1ZTogXCJJbmNyZWFzZSB2YWx1ZVwiLFxuXHQgICAgZGVjcmVhc2VWYWx1ZTogXCJEZWNyZWFzZSB2YWx1ZVwiLFxuXHQgICAgbmF2TW9udGg6IFtcIlByZXZpb3VzIG1vbnRoXCIsIFwiTmV4dCBtb250aFwiXSxcblx0ICAgIG5hdlllYXI6IFtcIlByZXZpb3VzIHllYXJcIiwgXCJOZXh0IHllYXJcIl0sXG5cdCAgICBuYXZEZWNhZGU6IFtcIlByZXZpb3VzIGRlY2FkZVwiLCBcIk5leHQgZGVjYWRlXCJdLFxuXHQgICAgZGF0ZUZvcm1hdDogXCIlZCAlRiAlWVwiLFxuXHQgICAgbW9udGhGb3JtYXQ6IFwiJUYgJVlcIixcblx0ICAgIHllYXJGb3JtYXQ6IFwiJVlcIixcblx0ICAgIGhvdXJGb3JtYXQ6IFwiSG91cnM6ICVoICVBXCIsXG5cdCAgICBtaW51dGVGb3JtYXQ6IFwiTWludXRlczogJWlcIixcblx0ICAgIHJlbW92ZUl0ZW06IFwiUmVtb3ZlIGl0ZW1cIixcblx0ICAgIHBhZ2VzOiBbXCJGaXJzdCBwYWdlXCIsIFwiUHJldmlvdXMgcGFnZVwiLCBcIk5leHQgcGFnZVwiLCBcIkxhc3QgcGFnZVwiXSxcblx0ICAgIHBhZ2U6IFwiUGFnZVwiLFxuXHQgICAgaGVhZGVybWVudTogXCJIZWFkZXIgbWVudVwiLFxuXHQgICAgb3Blbkdyb3VwOiBcIk9wZW4gY29sdW1uIGdyb3VwXCIsXG5cdCAgICBjbG9zZUdyb3VwOiBcIkNsb3NlIGNvbHVtbiBncm91cFwiLFxuXHQgICAgY2xvc2VUYWI6IFwiQ2xvc2UgdGFiXCIsXG5cdCAgICBzaG93VGFiczogXCJTaG93IG1vcmUgdGFic1wiLFxuXHQgICAgcmVzZXRUcmVlTWFwOiBcIlJlc2V0IHRyZWUgbWFwXCIsXG5cdCAgICBuYXZUcmVlTWFwOiBcIkxldmVsIHVwXCIsXG5cdCAgICBuZXh0VGFiOiBcIk5leHQgdGFiXCIsXG5cdCAgICBwcmV2VGFiOiBcIlByZXZpb3VzIHRhYlwiLFxuXHQgICAgbXVsdGl0ZXh0U2VjdGlvbjogXCJBZGQgc2VjdGlvblwiLFxuXHQgICAgbXVsdGl0ZXh0ZXh0cmFTZWN0aW9uOiBcIlJlbW92ZSBzZWN0aW9uXCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwiU2hvdyBjaGFydFwiLFxuXHQgICAgaGlkZUNoYXJ0OiBcIkhpZGUgY2hhcnRcIixcblx0ICAgIHJlc2l6ZUNoYXJ0OiBcIlJlc2l6ZSBjaGFydFwiXG5cdCAgfSxcblx0ICByaWNodGV4dDoge1xuXHQgICAgdW5kZXJsaW5lOiBcIlVuZGVybGluZVwiLFxuXHQgICAgYm9sZDogXCJCb2xkXCIsXG5cdCAgICBpdGFsaWM6IFwiSXRhbGljXCJcblx0ICB9LFxuXHQgIGNvbWJvOiB7XG5cdCAgICBzZWxlY3Q6IFwiU2VsZWN0XCIsXG5cdCAgICBzZWxlY3RBbGw6IFwiU2VsZWN0IGFsbFwiLFxuXHQgICAgdW5zZWxlY3RBbGw6IFwiVW5zZWxlY3QgYWxsXCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcIk9LXCIsXG5cdCAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcIlNlbmRcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcIlRoZSBjb21tZW50IHdpbGwgYmUgcmVtb3ZlZC4gQXJlIHlvdSBzdXJlP1wiLFxuXHQgICAgZWRpdDogXCJFZGl0XCIsXG5cdCAgICByZW1vdmU6IFwiUmVtb3ZlXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJUeXBlIGhlcmUuLlwiLFxuXHQgICAgbW9yZUNvbW1lbnRzOiBcIk1vcmUgY29tbWVudHNcIlxuXHQgIH1cblx0fTtcblxuXHR2YXIgd0RhdGUgPSB7XG5cdCAgc3RhcnRPbk1vbmRheTogZmFsc2UsXG5cdCAgdG9GaXhlZDogZnVuY3Rpb24gKG51bSwgbXMpIHtcblx0ICAgIGlmIChudW0gPCAxMCkgbnVtID0gXCIwXCIgKyBudW07XG5cdCAgICBpZiAobXMgJiYgbnVtIDwgMTAwKSBudW0gPSBcIjBcIiArIG51bTtcblx0ICAgIHJldHVybiBudW07XG5cdCAgfSxcblx0ICB3ZWVrU3RhcnQ6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICBkYXRlID0gdGhpcy5jb3B5KGRhdGUpO1xuXHQgICAgdmFyIHNoaWZ0ID0gZGF0ZS5nZXREYXkoKTtcblxuXHQgICAgaWYgKHRoaXMuc3RhcnRPbk1vbmRheSkge1xuXHQgICAgICBpZiAoc2hpZnQgPT09IDApIHNoaWZ0ID0gNjtlbHNlIHNoaWZ0LS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLmRhdGVQYXJ0KHRoaXMuYWRkKGRhdGUsIC0xICogc2hpZnQsIFwiZGF5XCIpKTtcblx0ICB9LFxuXHQgIG1vbnRoU3RhcnQ6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICBkYXRlID0gdGhpcy5jb3B5KGRhdGUpO1xuXHQgICAgZGF0ZS5zZXREYXRlKDEpO1xuXHQgICAgcmV0dXJuIHRoaXMuZGF0ZVBhcnQoZGF0ZSk7XG5cdCAgfSxcblx0ICB5ZWFyU3RhcnQ6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICBkYXRlID0gdGhpcy5jb3B5KGRhdGUpO1xuXHQgICAgZGF0ZS5zZXRNb250aCgwKTtcblx0ICAgIHJldHVybiB0aGlzLm1vbnRoU3RhcnQoZGF0ZSk7XG5cdCAgfSxcblx0ICBkYXlTdGFydDogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIHJldHVybiB0aGlzLmRhdGVQYXJ0KGRhdGUsIHRydWUpO1xuXHQgIH0sXG5cdCAgZGF0ZVRvU3RyOiBmdW5jdGlvbiAoZm9ybWF0LCB1dGMpIHtcblx0ICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZvcm1hdDtcblxuXHQgICAgaWYgKGVudi5zdHJpY3QpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG5cdCAgICAgICAgdmFyIGxhc3RQb3MgPSAwO1xuXHQgICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lW2EtekEtWl0vZywgZnVuY3Rpb24gKHMsIHBvcykge1xuXHQgICAgICAgICAgc3RyICs9IGZvcm1hdC5zbGljZShsYXN0UG9zLCBwb3MpO1xuXG5cdCAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVkXCIpIHJldHVybiB3RGF0ZS50b0ZpeGVkKGRhdGUuZ2V0RGF0ZSgpKTtcblx0ICAgICAgICAgICAgaWYgKHMgPT0gXCIlbVwiKSByZXR1cm4gd0RhdGUudG9GaXhlZChkYXRlLmdldE1vbnRoKCkgKyAxKTtcblx0ICAgICAgICAgICAgaWYgKHMgPT0gXCIlalwiKSByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJW5cIikgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJXlcIikgcmV0dXJuIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXRGdWxsWWVhcigpICUgMTAwKTtcblx0ICAgICAgICAgICAgaWYgKHMgPT0gXCIlWVwiKSByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVEXCIpIHJldHVybiBpMThuLmNhbGVuZGFyLmRheVNob3J0W2RhdGUuZ2V0RGF5KCldO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVsXCIpIHJldHVybiBpMThuLmNhbGVuZGFyLmRheUZ1bGxbZGF0ZS5nZXREYXkoKV07XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJU1cIikgcmV0dXJuIGkxOG4uY2FsZW5kYXIubW9udGhTaG9ydFtkYXRlLmdldE1vbnRoKCldO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVGXCIpIHJldHVybiBpMThuLmNhbGVuZGFyLm1vbnRoRnVsbFtkYXRlLmdldE1vbnRoKCldO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVoXCIpIHJldHVybiB3RGF0ZS50b0ZpeGVkKChkYXRlLmdldEhvdXJzKCkgKyAxMSkgJSAxMiArIDEpO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVnXCIpIHJldHVybiAoZGF0ZS5nZXRIb3VycygpICsgMTEpICUgMTIgKyAxO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVHXCIpIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJUhcIikgcmV0dXJuIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXRIb3VycygpKTtcblx0ICAgICAgICAgICAgaWYgKHMgPT0gXCIlaVwiKSByZXR1cm4gd0RhdGUudG9GaXhlZChkYXRlLmdldE1pbnV0ZXMoKSk7XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJWFcIikgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA+IDExID8gaTE4bi5wbVswXSA6IGkxOG4uYW1bMF07XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJUFcIikgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA+IDExID8gaTE4bi5wbVsxXSA6IGkxOG4uYW1bMV07XG5cdCAgICAgICAgICAgIGlmIChzID09IFwiJXNcIikgcmV0dXJuIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXRTZWNvbmRzKCkpO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVTXCIpIHJldHVybiB3RGF0ZS50b0ZpeGVkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIHRydWUpO1xuXHQgICAgICAgICAgICBpZiAocyA9PSBcIiVXXCIpIHJldHVybiB3RGF0ZS50b0ZpeGVkKERhdGUuZ2V0SVNPV2VlayhkYXRlKSk7XG5cblx0ICAgICAgICAgICAgaWYgKHMgPT0gXCIlY1wiKSB7XG5cdCAgICAgICAgICAgICAgdmFyIHN0ciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0ICAgICAgICAgICAgICBzdHIgKz0gXCItXCIgKyB3RGF0ZS50b0ZpeGVkKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuXHQgICAgICAgICAgICAgIHN0ciArPSBcIi1cIiArIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXREYXRlKCkpO1xuXHQgICAgICAgICAgICAgIHN0ciArPSBcIlRcIjtcblx0ICAgICAgICAgICAgICBzdHIgKz0gd0RhdGUudG9GaXhlZChkYXRlLmdldEhvdXJzKCkpO1xuXHQgICAgICAgICAgICAgIHN0ciArPSBcIjpcIiArIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXRNaW51dGVzKCkpO1xuXHQgICAgICAgICAgICAgIHN0ciArPSBcIjpcIiArIHdEYXRlLnRvRml4ZWQoZGF0ZS5nZXRTZWNvbmRzKCkpO1xuXHQgICAgICAgICAgICAgIHJldHVybiBzdHI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcztcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgICAgIHN0ciArPSBmbihkYXRlKTtcblx0ICAgICAgICAgIGxhc3RQb3MgPSBwb3MgKyAyO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHN0ciArPSBmb3JtYXQuc2xpY2UobGFzdFBvcywgZm9ybWF0Lmxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIHN0cjtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyVbYS16QS1aXS9nLCBmdW5jdGlvbiAoYSkge1xuXHQgICAgICBzd2l0Y2ggKGEpIHtcblx0ICAgICAgICBjYXNlIFwiJWRcIjpcblx0ICAgICAgICAgIHJldHVybiBcIlxcXCIrd0RhdGUudG9GaXhlZChkYXRlLmdldERhdGUoKSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVtXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK3dEYXRlLnRvRml4ZWQoKGRhdGUuZ2V0TW9udGgoKSsxKSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVqXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK2RhdGUuZ2V0RGF0ZSgpK1xcXCJcIjtcblxuXHQgICAgICAgIGNhc2UgXCIlblwiOlxuXHQgICAgICAgICAgcmV0dXJuIFwiXFxcIisoZGF0ZS5nZXRNb250aCgpKzEpK1xcXCJcIjtcblxuXHQgICAgICAgIGNhc2UgXCIleVwiOlxuXHQgICAgICAgICAgcmV0dXJuIFwiXFxcIit3RGF0ZS50b0ZpeGVkKGRhdGUuZ2V0RnVsbFllYXIoKSUxMDApK1xcXCJcIjtcblxuXHQgICAgICAgIGNhc2UgXCIlWVwiOlxuXHQgICAgICAgICAgcmV0dXJuIFwiXFxcIitkYXRlLmdldEZ1bGxZZWFyKCkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVEXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK2kxOG4uY2FsZW5kYXIuZGF5U2hvcnRbZGF0ZS5nZXREYXkoKV0rXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVsXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK2kxOG4uY2FsZW5kYXIuZGF5RnVsbFtkYXRlLmdldERheSgpXStcXFwiXCI7XG5cblx0ICAgICAgICBjYXNlIFwiJU1cIjpcblx0ICAgICAgICAgIHJldHVybiBcIlxcXCIraTE4bi5jYWxlbmRhci5tb250aFNob3J0W2RhdGUuZ2V0TW9udGgoKV0rXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVGXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK2kxOG4uY2FsZW5kYXIubW9udGhGdWxsW2RhdGUuZ2V0TW9udGgoKV0rXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVoXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK3dEYXRlLnRvRml4ZWQoKGRhdGUuZ2V0SG91cnMoKSsxMSklMTIrMSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVnXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiKygoZGF0ZS5nZXRIb3VycygpKzExKSUxMisxKStcXFwiXCI7XG5cblx0ICAgICAgICBjYXNlIFwiJUdcIjpcblx0ICAgICAgICAgIHJldHVybiBcIlxcXCIrZGF0ZS5nZXRIb3VycygpK1xcXCJcIjtcblxuXHQgICAgICAgIGNhc2UgXCIlSFwiOlxuXHQgICAgICAgICAgcmV0dXJuIFwiXFxcIit3RGF0ZS50b0ZpeGVkKGRhdGUuZ2V0SG91cnMoKSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVpXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK3dEYXRlLnRvRml4ZWQoZGF0ZS5nZXRNaW51dGVzKCkpK1xcXCJcIjtcblxuXHQgICAgICAgIGNhc2UgXCIlYVwiOlxuXHQgICAgICAgICAgcmV0dXJuIFwiXFxcIisoZGF0ZS5nZXRIb3VycygpPjExP2kxOG4ucG1bMF06aTE4bi5hbVswXSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVBXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiKyhkYXRlLmdldEhvdXJzKCk+MTE/aTE4bi5wbVsxXTppMThuLmFtWzFdKStcXFwiXCI7XG5cblx0ICAgICAgICBjYXNlIFwiJXNcIjpcblx0ICAgICAgICAgIHJldHVybiBcIlxcXCIrd0RhdGUudG9GaXhlZChkYXRlLmdldFNlY29uZHMoKSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVTXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK3dEYXRlLnRvRml4ZWQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgdHJ1ZSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVXXCI6XG5cdCAgICAgICAgICByZXR1cm4gXCJcXFwiK3dEYXRlLnRvRml4ZWQod0RhdGUuZ2V0SVNPV2VlayhkYXRlKSkrXFxcIlwiO1xuXG5cdCAgICAgICAgY2FzZSBcIiVjXCI6XG5cdCAgICAgICAgICB2YXIgc3RyID0gXCJcXFwiK2RhdGUuZ2V0RnVsbFllYXIoKStcXFwiXCI7XG5cdCAgICAgICAgICBzdHIgKz0gXCItXFxcIit3RGF0ZS50b0ZpeGVkKChkYXRlLmdldE1vbnRoKCkrMSkpK1xcXCJcIjtcblx0ICAgICAgICAgIHN0ciArPSBcIi1cXFwiK3dEYXRlLnRvRml4ZWQoZGF0ZS5nZXREYXRlKCkpK1xcXCJcIjtcblx0ICAgICAgICAgIHN0ciArPSBcIlRcIjtcblx0ICAgICAgICAgIHN0ciArPSBcIlxcXCIrd0RhdGUudG9GaXhlZChkYXRlLmdldEhvdXJzKCkpK1xcXCJcIjtcblx0ICAgICAgICAgIHN0ciArPSBcIjpcXFwiK3dEYXRlLnRvRml4ZWQoZGF0ZS5nZXRNaW51dGVzKCkpK1xcXCJcIjtcblx0ICAgICAgICAgIHN0ciArPSBcIjpcXFwiK3dEYXRlLnRvRml4ZWQoZGF0ZS5nZXRTZWNvbmRzKCkpK1xcXCJcIjtcblx0ICAgICAgICAgIGlmICh1dGMgPT09IHRydWUpIHN0ciArPSBcIlpcIjtcblx0ICAgICAgICAgIHJldHVybiBzdHI7XG5cblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgcmV0dXJuIGE7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgaWYgKHV0YyA9PT0gdHJ1ZSkgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL2RhdGVcXC5nZXQvZywgXCJkYXRlLmdldFVUQ1wiKTtcblx0ICAgIHZhciB0ZW1wID0gbmV3IEZ1bmN0aW9uKFwiZGF0ZVwiLCBcImkxOG5cIiwgXCJ3RGF0ZVwiLCBcImlmICghZGF0ZSkgcmV0dXJuICcnOyBpZiAoIWRhdGUuZ2V0TW9udGgpIGRhdGU9aTE4bi5wYXJzZUZvcm1hdERhdGUoZGF0ZSk7ICByZXR1cm4gXFxcIlwiICsgZm9ybWF0ICsgXCJcXFwiO1wiKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuXHQgICAgICByZXR1cm4gdGVtcCh2LCBpMThuLCB3RGF0ZSk7XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgc3RyVG9EYXRlOiBmdW5jdGlvbiAoZm9ybWF0LCB1dGMpIHtcblx0ICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZvcm1hdDtcblx0ICAgIHZhciBtYXNrID0gZm9ybWF0Lm1hdGNoKC8lW2EtekEtWl0vZyk7XG5cdCAgICB2YXIgc3BsdCA9IFwidmFyIHRlbXA9ZGF0ZS5zcGxpdCgvW14wLTlhLXpBLVpdKy9nKTtcIjtcblx0ICAgIHZhciBpLCB0LCBzO1xuXG5cdCAgICBpZiAoIWkxOG4uY2FsZW5kYXIubW9udGhTaG9ydF9oYXNoKSB7XG5cdCAgICAgIHMgPSBpMThuLmNhbGVuZGFyLm1vbnRoU2hvcnQ7XG5cdCAgICAgIHQgPSBpMThuLmNhbGVuZGFyLm1vbnRoU2hvcnRfaGFzaCA9IHt9O1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdFtzW2ldXSA9IGk7XG5cdCAgICAgIH1cblxuXHQgICAgICBzID0gaTE4bi5jYWxlbmRhci5tb250aEZ1bGw7XG5cdCAgICAgIHQgPSBpMThuLmNhbGVuZGFyLm1vbnRoRnVsbF9oYXNoID0ge307XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0W3NbaV1dID0gaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZW52LnN0cmljdCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgICAgICBpZiAoIWRhdGUpIHJldHVybiBcIlwiO1xuXHQgICAgICAgIGlmIChfdHlwZW9mKGRhdGUpID09IFwib2JqZWN0XCIpIHJldHVybiBkYXRlO1xuXHQgICAgICAgIHZhciB0ZW1wID0gZGF0ZS5zcGxpdCgvW14wLTlhLXpBLVpdKy9nKTtcblx0ICAgICAgICB2YXIgc2V0ID0gWzAsIDAsIDEsIDAsIDAsIDAsIDBdO1xuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hc2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciBhID0gbWFza1tpXTtcblx0ICAgICAgICAgIGlmIChhID09IFwiJXlcIikgc2V0WzBdID0gdGVtcFtpXSAqIDEgKyAodGVtcFtpXSA+IDMwID8gMTkwMCA6IDIwMDApO2Vsc2UgaWYgKGEgPT0gXCIlWVwiKSB7XG5cdCAgICAgICAgICAgIHNldFswXSA9ICh0ZW1wW2ldIHx8IDApICogMTtcblx0ICAgICAgICAgICAgaWYgKHNldFswXSA8IDMwKSBzZXRbMF0gKz0gMjAwMDtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PSBcIiVuXCIgfHwgYSA9PSBcIiVtXCIpIHNldFsxXSA9ICh0ZW1wW2ldIHx8IDEpIC0gMTtlbHNlIGlmIChhID09IFwiJU1cIikgc2V0WzFdID0gaTE4bi5jYWxlbmRhci5tb250aFNob3J0X2hhc2hbdGVtcFtpXV0gfHwgMDtlbHNlIGlmIChhID09IFwiJUZcIikgc2V0WzFdID0gaTE4bi5jYWxlbmRhci5tb250aEZ1bGxfaGFzaFt0ZW1wW2ldXSB8fCAwO2Vsc2UgaWYgKGEgPT0gXCIlalwiIHx8IGEgPT0gXCIlZFwiKSBzZXRbMl0gPSB0ZW1wW2ldIHx8IDE7ZWxzZSBpZiAoYSA9PSBcIiVnXCIgfHwgYSA9PSBcIiVHXCIgfHwgYSA9PSBcIiVoXCIgfHwgYSA9PSBcIiVIXCIpIHNldFszXSA9IHRlbXBbaV0gfHwgMDtlbHNlIGlmIChhID09IFwiJWFcIikgc2V0WzNdID0gc2V0WzNdICUgMTIgKyAoKHRlbXBbaV0gfHwgXCJcIikgPT0gaTE4bi5hbVswXSA/IDAgOiAxMik7ZWxzZSBpZiAoYSA9PSBcIiVBXCIpIHNldFszXSA9IHNldFszXSAlIDEyICsgKCh0ZW1wW2ldIHx8IFwiXCIpID09IGkxOG4uYW1bMV0gPyAwIDogMTIpO2Vsc2UgaWYgKGEgPT0gXCIlaVwiKSBzZXRbNF0gPSB0ZW1wW2ldIHx8IDA7ZWxzZSBpZiAoYSA9PSBcIiVzXCIpIHNldFs1XSA9IHRlbXBbaV0gfHwgMDtlbHNlIGlmIChhID09IFwiJVNcIikgc2V0WzZdID0gdGVtcFtpXSB8fCAwO2Vsc2UgaWYgKGEgPT0gXCIlY1wiKSB7XG5cdCAgICAgICAgICAgIHZhciByZWcgPSAvKFxcZCspLShcXGQrKS0oXFxkKylUKFxcZCspOihcXGQrKTooXFxkKykoXFwrLip8KS9nO1xuXHQgICAgICAgICAgICB2YXIgcmVzID0gcmVnLmV4ZWMoZGF0ZSk7XG5cdCAgICAgICAgICAgIHNldFswXSA9IChyZXNbMV0gfHwgMCkgKiAxO1xuXHQgICAgICAgICAgICBpZiAoc2V0WzBdIDwgMzApIHNldFswXSArPSAyMDAwO1xuXHQgICAgICAgICAgICBzZXRbMV0gPSAocmVzWzJdIHx8IDEpIC0gMTtcblx0ICAgICAgICAgICAgc2V0WzJdID0gcmVzWzNdIHx8IDE7XG5cdCAgICAgICAgICAgIHNldFszXSA9IHJlc1s0XSB8fCAwO1xuXHQgICAgICAgICAgICBzZXRbNF0gPSByZXNbNV0gfHwgMDtcblx0ICAgICAgICAgICAgc2V0WzVdID0gcmVzWzZdIHx8IDA7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHV0YykgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHNldFswXSwgc2V0WzFdLCBzZXRbMl0sIHNldFszXSwgc2V0WzRdLCBzZXRbNV0sIHNldFs2XSkpO1xuXHQgICAgICAgIHJldHVybiBuZXcgRGF0ZShzZXRbMF0sIHNldFsxXSwgc2V0WzJdLCBzZXRbM10sIHNldFs0XSwgc2V0WzVdLCBzZXRbNl0pO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzd2l0Y2ggKG1hc2tbaV0pIHtcblx0ICAgICAgICBjYXNlIFwiJWpcIjpcblx0ICAgICAgICBjYXNlIFwiJWRcIjpcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbMl09dGVtcFtcIiArIGkgKyBcIl18fDE7XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCIlblwiOlxuXHQgICAgICAgIGNhc2UgXCIlbVwiOlxuXHQgICAgICAgICAgc3BsdCArPSBcInNldFsxXT0odGVtcFtcIiArIGkgKyBcIl18fDEpLTE7XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCIleVwiOlxuXHQgICAgICAgICAgc3BsdCArPSBcInNldFswXT10ZW1wW1wiICsgaSArIFwiXSoxKyh0ZW1wW1wiICsgaSArIFwiXT4zMD8xOTAwOjIwMDApO1wiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwiJWdcIjpcblx0ICAgICAgICBjYXNlIFwiJUdcIjpcblx0ICAgICAgICBjYXNlIFwiJWhcIjpcblx0ICAgICAgICBjYXNlIFwiJUhcIjpcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbM109dGVtcFtcIiArIGkgKyBcIl18fDA7XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCIlaVwiOlxuXHQgICAgICAgICAgc3BsdCArPSBcInNldFs0XT10ZW1wW1wiICsgaSArIFwiXXx8MDtcIjtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBcIiVZXCI6XG5cdCAgICAgICAgICBzcGx0ICs9IFwic2V0WzBdPSh0ZW1wW1wiICsgaSArIFwiXXx8MCkqMTsgaWYgKHNldFswXTwzMCkgc2V0WzBdKz0yMDAwO1wiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwiJWFcIjpcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbM109c2V0WzNdJTEyKyh0ZW1wW1wiICsgaSArIFwiXT09aTE4bi5hbVswXT8wOjEyKTtcIjtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBcIiVBXCI6XG5cdCAgICAgICAgICBzcGx0ICs9IFwic2V0WzNdPXNldFszXSUxMisodGVtcFtcIiArIGkgKyBcIl09PWkxOG4uYW1bMV0/MDoxMik7XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCIlc1wiOlxuXHQgICAgICAgICAgc3BsdCArPSBcInNldFs1XT10ZW1wW1wiICsgaSArIFwiXXx8MDtcIjtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgY2FzZSBcIiVTXCI6XG5cdCAgICAgICAgICBzcGx0ICs9IFwic2V0WzZdPXRlbXBbXCIgKyBpICsgXCJdfHwwO1wiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwiJU1cIjpcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbMV09aTE4bi5jYWxlbmRhci5tb250aFNob3J0X2hhc2hbdGVtcFtcIiArIGkgKyBcIl1dfHwwO1wiO1xuXHQgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICBjYXNlIFwiJUZcIjpcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbMV09aTE4bi5jYWxlbmRhci5tb250aEZ1bGxfaGFzaFt0ZW1wW1wiICsgaSArIFwiXV18fDA7XCI7XG5cdCAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgXCIlY1wiOlxuXHQgICAgICAgICAgc3BsdCArPSBcInZhciByZXMgPSBkYXRlLnNwbGl0KCdUJyk7XCI7XG5cdCAgICAgICAgICBzcGx0ICs9IFwiaWYocmVzWzBdKXsgdmFyIGQgPSByZXNbMF0uc3BsaXQoJy0nKTtcIjtcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbMF09IChkWzBdfHwwKSoxOyBpZiAoc2V0WzBdPDMwKSBzZXRbMF0rPTIwMDA7XCI7XG5cdCAgICAgICAgICBzcGx0ICs9IFwic2V0WzFdPSAoZFsxXXx8MSktMTtcIjtcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbMl09IGRbMl18fDE7fVwiO1xuXHQgICAgICAgICAgc3BsdCArPSBcImlmKHJlc1sxXSl7IHZhciB0ID0gcmVzWzFdLnNwbGl0KCc6Jyk7XCI7XG5cdCAgICAgICAgICBzcGx0ICs9IFwic2V0WzNdPSB0WzBdfHwwO1wiO1xuXHQgICAgICAgICAgc3BsdCArPSBcInNldFs0XT0gdFsxXXx8MDtcIjtcblx0ICAgICAgICAgIHNwbHQgKz0gXCJzZXRbNV09IHBhcnNlSW50KHRbMl0pfHwwO31cIjtcblx0ICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb2RlID0gXCJzZXRbMF0sc2V0WzFdLHNldFsyXSxzZXRbM10sc2V0WzRdLHNldFs1XSwgc2V0WzZdXCI7XG5cdCAgICBpZiAodXRjKSBjb2RlID0gXCIgRGF0ZS5VVEMoXCIgKyBjb2RlICsgXCIpXCI7XG5cdCAgICB2YXIgdGVtcCA9IG5ldyBGdW5jdGlvbihcImRhdGVcIiwgXCJpMThuXCIsIFwiaWYgKCFkYXRlKSByZXR1cm4gJyc7IGlmICh0eXBlb2YgZGF0ZSA9PSAnb2JqZWN0JykgcmV0dXJuIGRhdGU7IHZhciBzZXQ9WzAsMCwxLDAsMCwwLDBdOyBcIiArIHNwbHQgKyBcIiByZXR1cm4gbmV3IERhdGUoXCIgKyBjb2RlICsgXCIpO1wiKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuXHQgICAgICByZXR1cm4gdGVtcCh2LCBpMThuKTtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBnZXRJU09XZWVrOiBmdW5jdGlvbiAobmRhdGUpIHtcblx0ICAgIGlmICghbmRhdGUpIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciBuZGF5ID0gbmRhdGUuZ2V0RGF5KCk7XG5cblx0ICAgIGlmIChuZGF5ID09PSAwKSB7XG5cdCAgICAgIG5kYXkgPSA3O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZmlyc3RfdGh1cnNkYXkgPSBuZXcgRGF0ZShuZGF0ZS52YWx1ZU9mKCkpO1xuXHQgICAgZmlyc3RfdGh1cnNkYXkuc2V0RGF0ZShuZGF0ZS5nZXREYXRlKCkgKyAoNCAtIG5kYXkpKTtcblx0ICAgIHZhciB5ZWFyX251bWJlciA9IGZpcnN0X3RodXJzZGF5LmdldEZ1bGxZZWFyKCk7IC8vIHllYXIgb2YgdGhlIGZpcnN0IFRodXJzZGF5XG5cblx0ICAgIHZhciBvcmRpbmFsX2RhdGUgPSBNYXRoLmZsb29yKChmaXJzdF90aHVyc2RheS5nZXRUaW1lKCkgLSBuZXcgRGF0ZSh5ZWFyX251bWJlciwgMCwgMSkuZ2V0VGltZSgpKSAvIDg2NDAwMDAwKTsgLy9vcmRpbmFsIGRhdGUgb2YgdGhlIGZpcnN0IFRodXJzZGF5IC0gMSAoc28gbm90IHJlYWxseSBvcmRpbmFsIGRhdGUpXG5cblx0ICAgIHZhciB3ZWVrTnVtYmVyID0gMSArIE1hdGguZmxvb3Iob3JkaW5hbF9kYXRlIC8gNyk7XG5cdCAgICByZXR1cm4gd2Vla051bWJlcjtcblx0ICB9LFxuXHQgIGdldFVUQ0lTT1dlZWs6IGZ1bmN0aW9uIChuZGF0ZSkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0SVNPV2VlayhuZGF0ZSk7XG5cdCAgfSxcblx0ICBfY29ycmVjdERhdGU6IGZ1bmN0aW9uIChkLCBkMCwgaW5jLCBjaGVja0Z1bmMpIHtcblx0ICAgIGlmICghaW5jKSByZXR1cm47XG5cdCAgICB2YXIgaW5jb3JyZWN0ID0gY2hlY2tGdW5jKGQsIGQwKTtcblxuXHQgICAgaWYgKGluY29ycmVjdCkge1xuXHQgICAgICB2YXIgaSA9IGluYyA+IDAgPyAxIDogLTE7XG5cblx0ICAgICAgd2hpbGUgKGluY29ycmVjdCkge1xuXHQgICAgICAgIGQuc2V0SG91cnMoZC5nZXRIb3VycygpICsgaSk7XG5cdCAgICAgICAgaW5jb3JyZWN0ID0gY2hlY2tGdW5jKGQsIGQwKTtcblx0ICAgICAgICBpICs9IGluYyA+IDAgPyAxIDogLTE7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIGFkZDogZnVuY3Rpb24gKGRhdGUsIGluYywgbW9kZSwgY29weSkge1xuXHQgICAgaWYgKGNvcHkpIGRhdGUgPSB0aGlzLmNvcHkoZGF0ZSk7XG5cdCAgICB2YXIgZCA9IHdEYXRlLmNvcHkoZGF0ZSk7XG5cblx0ICAgIHN3aXRjaCAobW9kZSkge1xuXHQgICAgICBjYXNlIFwiZGF5XCI6XG5cdCAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgaW5jKTtcblxuXHQgICAgICAgIHRoaXMuX2NvcnJlY3REYXRlKGRhdGUsIGQsIGluYywgZnVuY3Rpb24gKGQsIGQwKSB7XG5cdCAgICAgICAgICByZXR1cm4gd0RhdGUuZGF0ZVBhcnQoZDAsIHRydWUpLnZhbHVlT2YoKSA9PSB3RGF0ZS5kYXRlUGFydChkLCB0cnVlKS52YWx1ZU9mKCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIFwid2Vla1wiOlxuXHQgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDcgKiBpbmMpO1xuXG5cdCAgICAgICAgdGhpcy5fY29ycmVjdERhdGUoZGF0ZSwgZCwgNyAqIGluYywgZnVuY3Rpb24gKGQsIGQwKSB7XG5cdCAgICAgICAgICByZXR1cm4gd0RhdGUuZGF0ZVBhcnQoZDAsIHRydWUpLnZhbHVlT2YoKSA9PSB3RGF0ZS5kYXRlUGFydChkLCB0cnVlKS52YWx1ZU9mKCk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIFwibW9udGhcIjpcblx0ICAgICAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIGluYyk7XG5cblx0ICAgICAgICB0aGlzLl9jb3JyZWN0RGF0ZShkYXRlLCBkLCBpbmMsIGZ1bmN0aW9uIChkLCBkMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGQwLmdldE1vbnRoKCkgPT0gZC5nZXRNb250aCgpICYmIGQwLmdldFllYXIoKSA9PSBkLmdldFllYXIoKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgXCJ5ZWFyXCI6XG5cdCAgICAgICAgZGF0ZS5zZXRZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIGluYyk7XG5cblx0ICAgICAgICB0aGlzLl9jb3JyZWN0RGF0ZShkYXRlLCBkLCBpbmMsIGZ1bmN0aW9uIChkLCBkMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGQwLmdldEZ1bGxZZWFyKCkgPT0gZC5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBcImhvdXJcIjpcblx0ICAgICAgICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIGluYyk7XG5cblx0ICAgICAgICB0aGlzLl9jb3JyZWN0RGF0ZShkYXRlLCBkLCBpbmMsIGZ1bmN0aW9uIChkLCBkMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGQwLmdldEhvdXJzKCkgPT0gZC5nZXRIb3VycygpICYmIERhdGUuZGF0ZVBhcnQoZDAsIHRydWUpID09IERhdGUuZGF0ZVBhcnQoZCwgdHJ1ZSk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIFwibWludXRlXCI6XG5cdCAgICAgICAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgaW5jKTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIHdEYXRlLmFkZFttb2RlXShkYXRlLCBpbmMsIG1vZGUpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9LFxuXHQgIGRhdGVQYXJ0OiBmdW5jdGlvbiAoZGF0ZSwgY29weSkge1xuXHQgICAgaWYgKGNvcHkpIGRhdGUgPSB0aGlzLmNvcHkoZGF0ZSk7IC8vIHdvcmthcm91bmQgZm9yIG5vbi1leGlzdGVudCBob3Vyc1xuXG5cdCAgICB2YXIgZCA9IHRoaXMuY29weShkYXRlKTtcblx0ICAgIGQuc2V0SG91cnMoMCk7XG5cblx0ICAgIGlmIChkLmdldERhdGUoKSAhPSBkYXRlLmdldERhdGUoKSkge1xuXHQgICAgICBkYXRlLnNldEhvdXJzKDEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0ZS5zZXRIb3VycygwKTtcblx0ICAgIH1cblxuXHQgICAgZGF0ZS5zZXRNaW51dGVzKDApO1xuXHQgICAgZGF0ZS5zZXRTZWNvbmRzKDApO1xuXHQgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9LFxuXHQgIHRpbWVQYXJ0OiBmdW5jdGlvbiAoZGF0ZSwgY29weSkge1xuXHQgICAgaWYgKGNvcHkpIGRhdGUgPSB0aGlzLmNvcHkoZGF0ZSk7XG5cdCAgICByZXR1cm4gKGRhdGUudmFsdWVPZigpIC8gMTAwMCAtIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwKSAlIDg2NDAwO1xuXHQgIH0sXG5cdCAgY29weTogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLnZhbHVlT2YoKSk7XG5cdCAgfSxcblx0ICBlcXVhbDogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuXHQgICAgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcblx0ICB9LFxuXHQgIGlzSG9saWRheTogZnVuY3Rpb24gKGRheSkge1xuXHQgICAgZGF5ID0gZGF5LmdldERheSgpO1xuXHQgICAgaWYgKGRheSA9PT0gMCB8fCBkYXkgPT0gNikgcmV0dXJuIFwid2ViaXhfY2FsX2V2ZW50XCI7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBOdW1iZXIkMSA9IHtcblx0ICBnZXRDb25maWc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHtcblx0ICAgICAgZGVjaW1hbFNpemU6IDAsXG5cdCAgICAgIGdyb3VwU2l6ZTogOTk5LFxuXHQgICAgICBwcmVmaXg6IFwiXCIsXG5cdCAgICAgIHN1Zml4OiBcIlwiXG5cdCAgICB9O1xuXHQgICAgdmFyIHBhcnRzID0gdmFsdWUuc3BsaXQoL1swLTldLipbMC05XS9nKTtcblx0ICAgIGlmIChwYXJ0c1swXS5sZW5ndGgpIGNvbmZpZy5wcmVmaXggPSBwYXJ0c1swXTtcblx0ICAgIGlmIChwYXJ0c1sxXS5sZW5ndGgpIGNvbmZpZy5zdWZpeCA9IHBhcnRzWzFdO1xuXG5cdCAgICBpZiAoY29uZmlnLnByZWZpeCB8fCBjb25maWcuc3VmaXgpIHtcblx0ICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoY29uZmlnLnByZWZpeC5sZW5ndGgsIHZhbHVlLmxlbmd0aCAtIGNvbmZpZy5wcmVmaXgubGVuZ3RoIC0gY29uZmlnLnN1Zml4Lmxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBudW0gPSB2YWx1ZS5pbmRleE9mKFwiMVwiKTtcblxuXHQgICAgaWYgKG51bSA+IDApIHtcblx0ICAgICAgY29uZmlnLnByZWZpeCA9IHZhbHVlLnN1YnN0cigwLCBudW0pO1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cihudW0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZG90ID0gdmFsdWUuaW5kZXhPZihcIjBcIik7XG5cblx0ICAgIGlmIChkb3QgPiAwKSB7XG5cdCAgICAgIGNvbmZpZy5kZWNpbWFsU2l6ZSA9IHZhbHVlLmxlbmd0aCAtIGRvdDtcblx0ICAgICAgY29uZmlnLmRlY2ltYWxEZWxpbWl0ZXIgPSB2YWx1ZVtkb3QgLSAxXTtcblx0ICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZG90IC0gMSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZXAgPSB2YWx1ZS5tYXRjaCgvW14wLTldLyk7XG5cblx0ICAgIGlmIChzZXApIHtcblx0ICAgICAgY29uZmlnLmdyb3VwU2l6ZSA9IHZhbHVlLmxlbmd0aCAtIHNlcC5pbmRleCAtIDE7XG5cdCAgICAgIGNvbmZpZy5ncm91cERlbGltaXRlciA9IHZhbHVlW3NlcC5pbmRleF07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICBwYXJzZTogZnVuY3Rpb24gKHZhbHVlLCBjb25maWcpIHtcblx0ICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gdmFsdWU7XG5cdCAgICBpZiAoY29uZmlnLnByZWZpeCkgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoY29uZmlnLnByZWZpeC50b0xvd2VyQ2FzZSgpIHx8IFwiXCIsIFwiXCIpO1xuXHQgICAgaWYgKGNvbmZpZy5zdWZpeCkgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoY29uZmlnLnN1Zml4LnRvTG93ZXJDYXNlKCkgfHwgXCJcIiwgXCJcIik7XG5cdCAgICB2YXIgZGVjaW1hbCA9IFwiXCI7XG5cblx0ICAgIGlmIChjb25maWcuZGVjaW1hbERlbGltaXRlcikge1xuXHQgICAgICB2YXIgaW5kID0gdmFsdWUuaW5kZXhPZihjb25maWcuZGVjaW1hbERlbGltaXRlcik7XG5cblx0ICAgICAgaWYgKGluZCA+IC0xKSB7XG5cdCAgICAgICAgZGVjaW1hbCA9IHZhbHVlLnN1YnN0cihpbmQgKyAxKS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIik7XG5cdCAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyKDAsIE1hdGgubWluKGRlY2ltYWwubGVuZ3RoLCBjb25maWcuZGVjaW1hbFNpemUpKTtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBpbmQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaWduID0gdmFsdWVbMF0gPT09IFwiLVwiID8gLTEgOiAxO1xuXHQgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIik7XG5cdCAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IFwiMFwiO1xuXHQgICAgaWYgKGRlY2ltYWwpIHZhbHVlICs9IFwiLlwiICsgZGVjaW1hbDtcblx0ICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpZ247XG5cdCAgfSxcblx0ICBmb3JtYXQ6IGZ1bmN0aW9uICh2YWx1ZSwgY29uZmlnKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdmFsdWU7XG5cdCAgICBjb25maWcgPSBjb25maWcgfHwgaTE4bjtcblx0ICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdCAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIjtcblx0ICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXHQgICAgaWYgKCFjb25maWcuZGVjaW1hbE9wdGlvbmFsKSB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQoY29uZmlnLmRlY2ltYWxTaXplKTtcblx0ICAgIHZhciBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgc3RyID0gc3RyLnNwbGl0KFwiLlwiKTtcblx0ICAgIHZhciBpbnRfdmFsdWUgPSBcIlwiO1xuXG5cdCAgICBpZiAoY29uZmlnLmdyb3VwU2l6ZSkge1xuXHQgICAgICB2YXIgc3RlcCA9IGNvbmZpZy5ncm91cFNpemU7XG5cdCAgICAgIHZhciBpID0gc3RyWzBdLmxlbmd0aDtcblxuXHQgICAgICBkbyB7XG5cdCAgICAgICAgaSAtPSBzdGVwO1xuXHQgICAgICAgIHZhciBjaHVuayA9IGkgPiAwID8gc3RyWzBdLnN1YnN0cihpLCBzdGVwKSA6IHN0clswXS5zdWJzdHIoMCwgc3RlcCArIGkpO1xuXHQgICAgICAgIGludF92YWx1ZSA9IGNodW5rICsgKGludF92YWx1ZSA/IGNvbmZpZy5ncm91cERlbGltaXRlciArIGludF92YWx1ZSA6IFwiXCIpO1xuXHQgICAgICB9IHdoaWxlIChpID4gMCk7XG5cdCAgICB9IGVsc2UgaW50X3ZhbHVlID0gc3RyWzBdO1xuXG5cdCAgICBpZiAoY29uZmlnLmRlY2ltYWxTaXplKSBzdHIgPSBzaWduICsgaW50X3ZhbHVlICsgKHN0clsxXSA/IGNvbmZpZy5kZWNpbWFsRGVsaW1pdGVyICsgc3RyWzFdIDogXCJcIik7ZWxzZSBzdHIgPSBzaWduICsgaW50X3ZhbHVlO1xuXG5cdCAgICBpZiAoY29uZmlnLnByZWZpeCB8fCBjb25maWcuc3VmaXgpIHtcblx0ICAgICAgcmV0dXJuIGNvbmZpZy5wcmVmaXggKyBzdHIgKyBjb25maWcuc3VmaXg7XG5cdCAgICB9IGVsc2UgcmV0dXJuIHN0cjtcblx0ICB9LFxuXHQgIG51bVRvU3RyOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBOdW1iZXIkMS5mb3JtYXQodmFsdWUsIGNvbmZpZyk7XG5cdCAgICB9O1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBleHRlbmQoYmFzZSwgc291cmNlKSB7XG5cdCAgZm9yICh2YXIgbWV0aG9kIGluIHNvdXJjZSkge1xuXHQgICAgaWYgKF90eXBlb2Yoc291cmNlW21ldGhvZF0pID09IFwib2JqZWN0XCIgJiYgIWlzQXJyYXkoc291cmNlW21ldGhvZF0pKSB7XG5cdCAgICAgIGlmICghYmFzZVttZXRob2RdKSB7XG5cdCAgICAgICAgYmFzZVttZXRob2RdID0ge307XG5cdCAgICAgIH1cblxuXHQgICAgICBleHRlbmQoYmFzZVttZXRob2RdLCBzb3VyY2VbbWV0aG9kXSk7XG5cdCAgICB9IGVsc2UgYmFzZVttZXRob2RdID0gc291cmNlW21ldGhvZF07XG5cdCAgfVxuXHR9XG5cblx0dmFyIGhlbHBlcnMgPSBbXCJmdWxsRGF0ZUZvcm1hdFwiLCBcInRpbWVGb3JtYXRcIiwgXCJkYXRlRm9ybWF0XCIsIFwibG9uZ0RhdGVGb3JtYXRcIiwgXCJwYXJzZUZvcm1hdFwiLCBcInBhcnNlVGltZUZvcm1hdFwiXTtcblxuXHRpMThuLnNldExvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcblx0ICBpZiAodHlwZW9mIGxvY2FsZSA9PSBcInN0cmluZ1wiKSBsb2NhbGUgPSBpMThuLmxvY2FsZXNbbG9jYWxlXTtcblxuXHQgIGlmIChsb2NhbGUpIHtcblx0ICAgIGxvY2FsZS5wcmljZVNldHRpbmdzID0gY29weShsb2NhbGUucHJpY2VTZXR0aW5ncyB8fCBsb2NhbGUpO1xuXHQgICAgZXh0ZW5kKGkxOG4sIGxvY2FsZSk7XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWxwZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIga2V5ID0gaGVscGVyc1tpXTtcblx0ICAgIHZhciB1dGMgPSBpMThuW2tleSArIFwiVVRDXCJdO1xuXHQgICAgaTE4bltrZXkgKyBcIlN0clwiXSA9IHdEYXRlLmRhdGVUb1N0cihpMThuW2tleV0sIHV0Yyk7XG5cdCAgICBpMThuW2tleSArIFwiRGF0ZVwiXSA9IHdEYXRlLnN0clRvRGF0ZShpMThuW2tleV0sIHV0Yyk7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcmljZV9mb3JtYXQgPSB0ZW1wbGF0ZShpMThuLnByaWNlKTtcblxuXHQgIHZhciBfcHJpY2Vfc2V0dGluZ3MgPSBpMThuLnByaWNlU2V0dGluZ3MgfHwgaTE4bjtcblxuXHQgIGkxOG4uaW50Rm9ybWF0ID0gTnVtYmVyJDEubnVtVG9TdHIoe1xuXHQgICAgZ3JvdXBTaXplOiBpMThuLmdyb3VwU2l6ZSxcblx0ICAgIGdyb3VwRGVsaW1pdGVyOiBpMThuLmdyb3VwRGVsaW1pdGVyLFxuXHQgICAgZGVjaW1hbFNpemU6IDBcblx0ICB9KTtcblxuXHQgIGkxOG4ucHJpY2VGb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiBfcHJpY2VfZm9ybWF0KE51bWJlciQxLmZvcm1hdCh2YWx1ZSwgX3ByaWNlX3NldHRpbmdzKSk7XG5cdCAgfTtcblxuXHQgIGkxOG4ubnVtYmVyRm9ybWF0ID0gTnVtYmVyJDEuZm9ybWF0O1xuXHR9O1xuXG5cdGkxOG4ubG9jYWxlcyA9IHtcblx0ICBcImVuLVVTXCI6IGVuXG5cdH07XG5cdGkxOG4uc2V0TG9jYWxlKFwiZW4tVVNcIik7XG5cblx0Lypcblx0XHRCZWhhdmlvcjpIaXN0b3J5IC0gY2hhbmdlIG11bHRpdmlldyBzdGF0ZSBvbiAnYmFjaycgYnV0dG9uXG5cblx0ICovXG5cblx0dmFyIGhpc3RvcnkgPSB7XG5cdCAgdHJhY2s6IGZ1bmN0aW9uIChpZCwgdXJsKSB7XG5cdCAgICB0aGlzLl9pbml0X3N0YXRlKGlkLCB1cmwpO1xuXG5cdCAgICBpZiAodGhpcy5fYUhhbmRsZXIpICQkKHRoaXMuX2FWaWV3SWQpLmRldGFjaEV2ZW50KHRoaXMuX2FIYW5kbGVyKTtcblxuXHQgICAgaWYgKGlkKSB7XG5cdCAgICAgIHRoaXMuX2FWaWV3SWQgPSBpZDtcblx0ICAgICAgdmFyIHZpZXcgPSAkJChpZCk7XG5cblx0ICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKGhpc3RvcnkuX2lnbm9yZWQpIHJldHVybjtcblx0ICAgICAgICBpZiAodmlldy5nZXRWYWx1ZSkgaGlzdG9yeS5wdXNoKGlkLCB2aWV3LmdldFZhbHVlKCkpO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmICh2aWV3LmdldEFjdGl2ZUlkKSB0aGlzLl9hSGFuZGxlciA9IHZpZXcuYXR0YWNoRXZlbnQoXCJvblZpZXdDaGFuZ2VcIiwgaGFuZGxlcik7ZWxzZSB0aGlzLl9hSGFuZGxlciA9IHZpZXcuYXR0YWNoRXZlbnQoXCJvbkNoYW5nZVwiLCBoYW5kbGVyKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zZXRfc3RhdGU6IGZ1bmN0aW9uICh2aWV3LCBzdGF0ZSQkMSkge1xuXHQgICAgaGlzdG9yeS5faWdub3JlZCA9IDE7XG5cdCAgICB2aWV3ID0gJCQodmlldyk7XG5cdCAgICBpZiAodmlldy5jYWxsRXZlbnQoXCJvbkJlZm9yZUhpc3RvcnlOYXZcIiwgW3N0YXRlJCQxXSkpIGlmICh2aWV3LnNldFZhbHVlKSB2aWV3LnNldFZhbHVlKHN0YXRlJCQxKTtcblx0ICAgIGhpc3RvcnkuX2lnbm9yZWQgPSAwO1xuXHQgIH0sXG5cdCAgcHVzaDogZnVuY3Rpb24gKHZpZXcsIHVybCwgdmFsdWUpIHtcblx0ICAgIHZpZXcgPSAkJCh2aWV3KTtcblx0ICAgIHZhciBuZXdfdXJsID0gXCJcIjtcblx0ICAgIGlmICh1cmwpIG5ld191cmwgPSBcIiMhL1wiICsgdXJsO1xuXG5cdCAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG5cdCAgICAgIGlmICh2aWV3LmdldFZhbHVlKSB2YWx1ZSA9IHZpZXcuZ2V0VmFsdWUoKTtlbHNlIHZhbHVlID0gdXJsO1xuXHQgICAgfVxuXG5cdCAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe1xuXHQgICAgICB3ZWJpeDogdHJ1ZSxcblx0ICAgICAgaWQ6IHZpZXcuX3NldHRpbmdzLmlkLFxuXHQgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgIH0sIFwiXCIsIG5ld191cmwpO1xuXHQgIH0sXG5cdCAgX2luaXRfc3RhdGU6IGZ1bmN0aW9uICh2aWV3LCB1cmwpIHtcblx0ICAgIGV2ZW50JDEod2luZG93LCBcInBvcHN0YXRlXCIsIGZ1bmN0aW9uIChldikge1xuXHQgICAgICBpZiAoZXYuc3RhdGUgJiYgZXYuc3RhdGUud2ViaXgpIHtcblx0ICAgICAgICBoaXN0b3J5Ll9zZXRfc3RhdGUoZXYuc3RhdGUuaWQsIGV2LnN0YXRlLnZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHQgICAgc3RhdGUubm9hbmltYXRlID0gdHJ1ZTtcblx0ICAgIGlmIChoYXNoICYmIGhhc2guaW5kZXhPZihcIiMhL1wiKSA9PT0gMCkgaGlzdG9yeS5fc2V0X3N0YXRlKHZpZXcsIGhhc2gucmVwbGFjZShcIiMhL1wiLCBcIlwiKSk7ZWxzZSBpZiAodXJsKSB7XG5cdCAgICAgIGhpc3RvcnkucHVzaCh2aWV3LCB1cmwpO1xuXG5cdCAgICAgIGhpc3RvcnkuX3NldF9zdGF0ZSh2aWV3LCB1cmwpO1xuXHQgICAgfVxuXHQgICAgc3RhdGUubm9hbmltYXRlID0gZmFsc2U7XG5cblx0ICAgIHRoaXMuX2luaXRfc3RhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICB9XG5cdH07XG5cblx0dmFyIG1hcmt1cCA9IHtcblx0ICBuYW1lc3BhY2U6IFwieFwiLFxuXHQgIGF0dHJpYnV0ZTogXCJkYXRhLVwiLFxuXHQgIGRhdGFUYWc6IFwibGlcIixcblx0ICBfZGFzaDogLy0oW2Etel0pL2csXG5cdCAgX2FmdGVyX2Rhc2g6IGZ1bmN0aW9uIChtYXRjaCkge1xuXHQgICAgcmV0dXJuIG1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XG5cdCAgfSxcblx0ICBfcGFyc2VfaW50OiB7XG5cdCAgICB3aWR0aDogdHJ1ZSxcblx0ICAgIGhlaWdodDogdHJ1ZSxcblx0ICAgIGdyYXZpdHk6IHRydWUsXG5cdCAgICBtYXJnaW46IHRydWUsXG5cdCAgICBwYWRkaW5nOiB0cnVlLFxuXHQgICAgcGFkZGluZ1g6IHRydWUsXG5cdCAgICBwYWRkaW5nWTogdHJ1ZSxcblx0ICAgIG1pbldpZHRoOiB0cnVlLFxuXHQgICAgbWF4V2lkdGg6IHRydWUsXG5cdCAgICBtaW5IZWlnaHQ6IHRydWUsXG5cdCAgICBtYXhIZWlnaHQ6IHRydWUsXG5cdCAgICBoZWFkZXJSb3dIZWlnaHQ6IHRydWVcblx0ICB9LFxuXHQgIF9wYXJzZV9ib29sOiB7XG5cdCAgICBkaXNhYmxlZDogdHJ1ZSxcblx0ICAgIGhpZGRlbjogdHJ1ZVxuXHQgIH0sXG5cdCAgX3ZpZXdfaGFzX21ldGhvZDogZnVuY3Rpb24gKHZpZXcsIG5hbWUpIHtcblx0ICAgIHJldHVybiBoYXNNZXRob2QodmlldywgbmFtZSk7XG5cdCAgfSxcblx0ICBpbml0OiBmdW5jdGlvbiAobm9kZSwgdGFyZ2V0LCBzY29wZSkge1xuXHQgICAgbm9kZSA9IG5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblx0ICAgIHZhciBlbHMgPSBbXTtcblxuXHQgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXRfY29yZV9lbHMobm9kZSk7XG5cblx0ICAgIHZhciBodG1sID0gdGVtcC5odG1sO1xuXHQgICAgdmFyIHVpJCQxID0gbnVsbDsgLy9tYWtlIGNvcHkgdG8gcHJldmVudCBub2RlIHJlbW92aW5nIGVmZmVjdHNcblxuXHQgICAgZm9yICh2YXIgaSA9IHRlbXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgZWxzW2ldID0gdGVtcFtpXTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVscy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgdmFyIGNvbmZpZzsgLy9jb2xsZWN0IGNvbmZpZ3VyYXRpb25cblxuXHQgICAgICBjb25maWcgPSB0aGlzLl9zdWJfbWFya3VwKGVsc1tfaV0sIGh0bWwpO1xuXHQgICAgICBjb25maWcuJHNjb3BlID0gc2NvcGU7XG5cdCAgICAgIHVpJCQxID0gdGhpcy5faW5pdENvbXBvbmVudChjb25maWcsIGVsc1tfaV0sIGh0bWwsIHRhcmdldCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1aSQkMTtcblx0ICB9LFxuXHQgIHBhcnNlOiBmdW5jdGlvbiAoc291cmNlLCBtb2RlKSB7XG5cdCAgICAvL2NvbnZlcnQgZnJvbSBzdHJpbmcgdG8gb2JqZWN0XG5cdCAgICBpZiAodHlwZW9mIHNvdXJjZSA9PSBcInN0cmluZ1wiKSBzb3VyY2UgPSBEYXRhRHJpdmVyW21vZGUgfHwgXCJ4bWxcIl0udG9PYmplY3Qoc291cmNlLCBzb3VyY2UpO1xuXG5cdCAgICB2YXIgZWxzID0gdGhpcy5fZ2V0X2NvcmVfZWxzKHNvdXJjZSwgbW9kZSk7XG5cblx0ICAgIHJldHVybiB0aGlzLl9zdWJfbWFya3VwKGVsc1swXSwgZWxzLmh0bWwpO1xuXHQgIH0sXG5cdCAgX2luaXRDb21wb25lbnQ6IGZ1bmN0aW9uIChjb25maWcsIG5vZGUsIGh0bWwsIHRhcmdldCkge1xuXHQgICAgaWYgKCF0YXJnZXQpIHtcblx0ICAgICAgY29uZmlnLmNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcblx0ICAgICAgcmVtb3ZlKG5vZGUpO1xuXHQgICAgfSBlbHNlIGNvbmZpZy5jb250YWluZXIgPSB0YXJnZXQ7XG5cblx0ICAgIGlmICh0aGlzLl92aWV3X2hhc19tZXRob2QoY29uZmlnLnZpZXcsIFwic2V0UG9zaXRpb25cIikpIGRlbGV0ZSBjb25maWcuY29udGFpbmVyOyAvL2luaXQgdWlcblxuXHQgICAgcmV0dXJuIHVpKGNvbmZpZyk7XG5cdCAgfSxcblx0ICBfZ2V0X2NvcmVfZWxzOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgdGhpcy5fZnVsbF9wcmVmaXggPSB0aGlzLm5hbWVzcGFjZSA/IHRoaXMubmFtZXNwYWNlICsgXCI6XCIgOiBcIlwiO1xuXHQgICAgdGhpcy5fZnVsbF9wcmVmaXhfdG9wID0gdGhpcy5fZnVsbF9wcmVmaXggKyBcInVpXCI7IC8veGh0bWwgbW9kZVxuXG5cdCAgICB2YXIgZWxzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0aGlzLl9mdWxsX3ByZWZpeF90b3ApO1xuXHQgICAgaWYgKCFlbHMubGVuZ3RoICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50ICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50LnRhZ05hbWUgPT0gdGhpcy5fZnVsbF9wcmVmaXhfdG9wKSBlbHMgPSBbbm9kZS5kb2N1bWVudEVsZW1lbnRdOyAvL2xvYWRpbmcgZnJvbSB4bWwgZmlsZSB3aXRoIHZhbGlkIG5hbWVzcGFjZVxuXG5cdCAgICBpZiAoIWVscy5sZW5ndGggJiYgdGhpcy5uYW1lc3BhY2UpIHtcblx0ICAgICAgZWxzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInVpXCIpO1xuXHQgICAgICBpZiAoIWVscy5sZW5ndGggJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudGFnTmFtZSA9PSBcInVpXCIpIGVscyA9IFtub2RlLmRvY3VtZW50RWxlbWVudF07XG5cdCAgICB9XG5cblx0ICAgIGlmICghZWxzLmxlbmd0aCkge1xuXHQgICAgICAvL2h0bWwgbW9kZVxuXHQgICAgICBlbHMgPSB0aGlzLl9nZXRfaHRtbF90b3BzKG5vZGUpO1xuXHQgICAgICBlbHMuaHRtbCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBlbHM7XG5cdCAgfSxcblx0ICAvL2h0bWwgY29udmVyc2lvblxuXHQgIF9nZXRfaHRtbF90b3BzOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlICsgXCJ2aWV3XCIpKSByZXR1cm4gW25vZGVdO1xuXHQgICAgdmFyIGVscyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChcIltcIiArIHRoaXMuYXR0cmlidXRlICsgXCJ2aWV3XVwiKTtcblx0ICAgIHZhciB0YWdzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICghZWxzW2ldLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlICsgXCJ2aWV3XCIpKSB0YWdzLnB1c2goZWxzW2ldKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRhZ3M7XG5cdCAgfSxcblx0ICBfc3ViX21hcmt1cDogZnVuY3Rpb24gKGVsLCBodG1sLCBqc29uKSB7XG5cdCAgICB2YXIgaHRtbHRhYmxlID0gZmFsc2U7IC8vaWdub3JlIHRvcCB4OnVpIGZvciB4aHRtbCBhbmQgeG1sIFxuXG5cdCAgICBpZiAoIWpzb24pIHtcblx0ICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZXRfbmFtZShlbCwgaHRtbCk7XG5cblx0ICAgICAgaWYgKG5hbWUgPT0gXCJ1aVwiKSB7XG5cdCAgICAgICAgdmFyIGNoaWxkcyA9IGVsLmNoaWxkTm9kZXM7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGNoaWxkc1tpXS5ub2RlVHlwZSA9PSAxKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJfbWFya3VwKGNoaWxkc1tpXSwgaHRtbCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAganNvbiA9IHtcblx0ICAgICAgICB2aWV3OiBuYW1lXG5cdCAgICAgIH07XG5cblx0ICAgICAgaWYgKGh0bWwgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwidGFibGVcIikge1xuXHQgICAgICAgIGpzb24uZGF0YSA9IGVsO1xuXHQgICAgICAgIGpzb24uZGF0YXR5cGUgPSBcImh0bWx0YWJsZVwiO1xuXHQgICAgICAgIGh0bWx0YWJsZSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGlzX2xheW91dCA9IGpzb24udmlldyA9PSBcImNvbHNcIiB8fCBqc29uLnZpZXcgPT0gXCJyb3dzXCIgfHwgdGhpcy5fdmlld19oYXNfbWV0aG9kKGpzb24udmlldywgXCJhZGRWaWV3XCIpO1xuXG5cdCAgICB2YXIgc3VicyA9IFtdO1xuXHQgICAgdmFyIGhhc190YWdzID0gMDtcblx0ICAgIHZhciBhbGxvd19zdWJfdGFncyA9ICEoaHRtbCB8fCBlbC5zdHlsZSk7IC8vb25seSBmb3IgeG1sIGRvY3VtZW50c1xuXG5cdCAgICB2YXIgZmlyc3QgPSBlbC5maXJzdENoaWxkO1xuXG5cdCAgICB3aGlsZSAoZmlyc3QpIHtcblx0ICAgICAgLy90YWcgbm9kZVxuXHQgICAgICBpZiAoZmlyc3Qubm9kZVR5cGUgPT0gMSkge1xuXHQgICAgICAgIHZhciBfbmFtZSA9IHRoaXMuX2dldF9uYW1lKGZpcnN0LCBodG1sKTtcblxuXHQgICAgICAgIGlmIChfbmFtZSA9PSBcImRhdGFcIikge1xuXHQgICAgICAgICAgaGFzX3RhZ3MgPSAxO1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSBmaXJzdDtcblx0ICAgICAgICAgIGZpcnN0ID0gZmlyc3QubmV4dFNpYmxpbmc7XG5cdCAgICAgICAgICBqc29uLmRhdGEgPSB0aGlzLl9oYW5kbGVfZGF0YShkYXRhLCBodG1sKTtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoX25hbWUgPT0gXCJjb25maWdcIikge1xuXHQgICAgICAgICAgdGhpcy5fZ2V0X2NvbmZpZ19odG1sKGZpcnN0LCBqc29uLCBodG1sKTtcblxuXHQgICAgICAgICAgdmFyIGNvbmZpZ25vZGUgPSBmaXJzdDtcblx0ICAgICAgICAgIGZpcnN0ID0gZmlyc3QubmV4dFNpYmxpbmc7XG5cdCAgICAgICAgICByZW1vdmUoY29uZmlnbm9kZSk7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKF9uYW1lID09IFwiY29sdW1uXCIpIHtcblx0ICAgICAgICAgIGhhc190YWdzID0gMTtcblxuXHQgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuX3RhZ190b19qc29uKGZpcnN0LCBodG1sKTtcblxuXHQgICAgICAgICAgY29sdW1uLmhlYWRlciA9IGNvbHVtbi5oZWFkZXIgfHwgY29sdW1uLnZhbHVlO1xuXHQgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sdW1uLndpZHRoICogMSB8fCBcIlwiO1xuXHQgICAgICAgICAganNvbi5jb2x1bW5zID0ganNvbi5jb2x1bW5zIHx8IFtdO1xuXHQgICAgICAgICAganNvbi5jb2x1bW5zLnB1c2goY29sdW1uKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKF9uYW1lIHx8IGlzX2xheW91dCAmJiBodG1sKSB7XG5cdCAgICAgICAgICB2YXIgb2JqID0gdGhpcy5fc3ViX21hcmt1cChmaXJzdCwgaHRtbCwge1xuXHQgICAgICAgICAgICB2aWV3OiBfbmFtZVxuXHQgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgIGlmIChvYmoudmlldyA9PSBcImhlYWRcIikganNvbi5oZWFkID0gb2JqLnJvd3MgPyBvYmoucm93c1swXSA6IG9iai50ZW1wbGF0ZTtlbHNlIGlmIChvYmoudmlldyA9PSBcImJvZHlcIikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fdmlld19oYXNfbWV0aG9kKGpzb24udmlldywgXCJhZGRWaWV3XCIpKSB7XG5cdCAgICAgICAgICAgICAgLy9tdWx0aXZpZXcsIGFjY29yZGlvblxuXHQgICAgICAgICAgICAgIC8vc3VidGFnIG9yIHBsYWluIHZhbHVlXG5cdCAgICAgICAgICAgICAgLy9pbiBjYXNlIG9mIG11bHRpcGxlIHN1YiB0YWdzLCBvbmx5IGZpcnN0IHdpbGwgYmUgdXNlZFxuXHQgICAgICAgICAgICAgIC8vICNkaXJ0eVxuXHQgICAgICAgICAgICAgIHN1YnMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICBib2R5OiBvYmoucm93cyA/IG9iai5yb3dzWzBdIDogb2JqLnZhbHVlLFxuXHQgICAgICAgICAgICAgICAgaGVhZGVyOiBvYmouaGVhZGVyIHx8IFwiXCJcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAvL3dpbmRvdywgZmllbGRzZXRcblx0ICAgICAgICAgICAgICAvL29uZSBzdWIgdGFnIC0gdXNlIGl0XG5cdCAgICAgICAgICAgICAgLy9tdWx0aXBsZSBzdWIgdGFncyAtIGNyZWF0ZSBzdWIgbGF5b3V0XG5cdCAgICAgICAgICAgICAgLy9vciB1c2UgcGxhaW4gdGV4dCB2YWx1ZVxuXHQgICAgICAgICAgICAgIGpzb24uYm9keSA9IG9iai5yb3dzID8gb2JqLnJvd3MubGVuZ3RoID09IDEgPyBvYmoucm93c1swXSA6IHtcblx0ICAgICAgICAgICAgICAgIHJvd3M6IG9iai5yb3dzXG5cdCAgICAgICAgICAgICAgfSA6IG9iai52YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHN1YnMucHVzaChvYmopO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWxsb3dfc3ViX3RhZ3MpIHtcblx0ICAgICAgICAgIGhhc190YWdzID0gMTtcblx0ICAgICAgICAgIHZhciB0YWdOYW1lID0gZmlyc3QudGFnTmFtZTtcblx0ICAgICAgICAgIGlmIChodG1sKSB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UodGhpcy5fZGFzaCwgdGhpcy5fYWZ0ZXJfZGFzaCk7XG5cdCAgICAgICAgICBqc29uW3RhZ05hbWVdID0gRGF0YURyaXZlci54bWwudGFnVG9PYmplY3QoZmlyc3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGZpcnN0ID0gZmlyc3QubmV4dFNpYmxpbmc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2F0dHJzX3RvX2pzb24oZWwsIGpzb24sIGh0bWwpO1xuXG5cdCAgICBpZiAoc3Vicy5sZW5ndGgpIHtcblx0ICAgICAgaWYgKGpzb24uc3RhY2spIHtcblx0ICAgICAgICBqc29uW2pzb24uc3RhY2tdID0gc3Vicztcblx0ICAgICAgfSBlbHNlIGlmIChqc29uLnN1YnVpKSB7XG5cdCAgICAgICAganNvbltqc29uLnN1YnVpXSA9IHN1YnNbMF07XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlld19oYXNfbWV0aG9kKGpzb24udmlldywgXCJzZXRWYWx1ZXNcIikpIHtcblx0ICAgICAgICBqc29uW1wiZWxlbWVudHNcIl0gPSBzdWJzO1xuXHQgICAgICB9IGVsc2UgaWYgKGpzb24udmlldyA9PSBcInJvd3NcIikge1xuXHQgICAgICAgIGpzb24udmlldyA9IFwibGF5b3V0XCI7XG5cdCAgICAgICAganNvbi5yb3dzID0gc3Vicztcblx0ICAgICAgfSBlbHNlIGlmIChqc29uLnZpZXcgPT0gXCJjb2xzXCIpIHtcblx0ICAgICAgICBqc29uLnZpZXcgPSBcImxheW91dFwiO1xuXHQgICAgICAgIGpzb24uY29scyA9IHN1YnM7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlld19oYXNfbWV0aG9kKGpzb24udmlldywgXCJzZXRWYWx1ZVwiKSkge1xuXHQgICAgICAgIGpzb25bXCJjZWxsc1wiXSA9IHN1YnM7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5fdmlld19oYXNfbWV0aG9kKGpzb24udmlldywgXCJnZXRCb2R5XCIpKSB7XG5cdCAgICAgICAganNvbi5ib2R5ID0gc3Vicy5sZW5ndGggPT0gMSA/IHN1YnNbMF0gOiB7XG5cdCAgICAgICAgICByb3dzOiBzdWJzXG5cdCAgICAgICAgfTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBqc29uW1wicm93c1wiXSA9IHN1YnM7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoIWh0bWx0YWJsZSAmJiAhaGFzX3RhZ3MpIHtcblx0ICAgICAgaWYgKGh0bWwgJiYgIWpzb24udGVtcGxhdGUgJiYgKCFqc29uLnZpZXcgfHwganNvbi52aWV3ID09IFwidGVtcGxhdGVcIikpIHtcblx0ICAgICAgICBqc29uLnZpZXcgPSBcInRlbXBsYXRlXCI7XG5cdCAgICAgICAganNvbi5jb250ZW50ID0gZWw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50KGVsLCBodG1sKTtcblxuXHQgICAgICAgIGlmIChjb250ZW50KSB7XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0ID0gXCJ0ZW1wbGF0ZVwiO1xuXHQgICAgICAgICAgaWYgKHRoaXMuX3ZpZXdfaGFzX21ldGhvZChqc29uLnZpZXcsIFwic2V0VmFsdWVcIikpIHRhcmdldCA9IFwidmFsdWVcIjtcblx0ICAgICAgICAgIGpzb25bdGFyZ2V0XSA9IGpzb25bdGFyZ2V0XSB8fCBjb250ZW50O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ganNvbjtcblx0ICB9LFxuXHQgIF9lbXB0eTogZnVuY3Rpb24gKHN0cikge1xuXHQgICAgdmFyIGNsZWFuID0gc3RyLnJlcGxhY2UoL1xccysvZ20sIFwiXCIpO1xuXHQgICAgcmV0dXJuIGNsZWFuLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRydWU7XG5cdCAgfSxcblx0ICBfbWFya3VwX25hbWVzOiB7XG5cdCAgICBib2R5OiAxLFxuXHQgICAgaGVhZDogMSxcblx0ICAgIGRhdGE6IDEsXG5cdCAgICByb3dzOiAxLFxuXHQgICAgY29sczogMSxcblx0ICAgIGNlbGxzOiAxLFxuXHQgICAgZWxlbWVudHM6IDEsXG5cdCAgICB1aTogMSxcblx0ICAgIGNvbHVtbjogMSxcblx0ICAgIGNvbmZpZzogMVxuXHQgIH0sXG5cdCAgX2dldF9jb25maWdfaHRtbDogZnVuY3Rpb24gKHRhZywganNvbiwgaHRtbCkge1xuXHQgICAgdmFyIG1hc3RlciA9IHRoaXMuX2F0dHJzX3RvX2pzb24odGFnLCB7fSk7XG5cblx0ICAgIGlmIChtYXN0ZXIubmFtZSkge1xuXHQgICAgICBqc29uW21hc3Rlci5uYW1lXSA9IG1hc3Rlcjtcblx0ICAgICAgZGVsZXRlIG1hc3Rlci5uYW1lO1xuXHQgICAgfSBlbHNlIGlmIChtYXN0ZXIuc3RhY2spIGpzb25bbWFzdGVyLnN0YWNrXSA9IFtdO2Vsc2UganNvbiA9IG1hc3RlcjtcblxuXHQgICAgdmFyIGNoaWxkcyA9IHRhZy5jaGlsZE5vZGVzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgc3ViID0gbnVsbDtcblx0ICAgICAgaWYgKGNoaWxkc1tpXS5ub2RlVHlwZSA9PSAxICYmIGNoaWxkc1tpXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJjb25maWdcIiAmJiBjaGlsZHNbaV0uYXR0cmlidXRlcy5sZW5ndGgpIHN1YiA9IHRoaXMuX2dldF9jb25maWdfaHRtbChjaGlsZHNbaV0sIG1hc3RlciwgaHRtbCk7ZWxzZSBpZiAoY2hpbGRzW2ldLm5vZGVUeXBlID09IDEgJiYgY2hpbGRzW2ldLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImRhdGFcIikge1xuXHQgICAgICAgIHN1YiA9IHRoaXMuX2hhbmRsZV9kYXRhKGNoaWxkc1tpXSwgaHRtbCk7XG5cdCAgICAgICAgaWYgKCFtYXN0ZXIuc3RhY2spIG1hc3Rlci5kYXRhID0gc3ViO1xuXHQgICAgICB9IGVsc2Ugc3ViID0gY2hpbGRzW2ldLmlubmVySFRNTDtcblx0ICAgICAgaWYgKG1hc3Rlci5zdGFjayAmJiBzdWIpIGpzb25bbWFzdGVyLnN0YWNrXS5wdXNoKHN1Yik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBqc29uO1xuXHQgIH0sXG5cdCAgX2dldF9uYW1lOiBmdW5jdGlvbiAodGFnLCBodG1sKSB7XG5cdCAgICAvL3ZhbHVlIG9mIHZpZXcgYXR0cmlidXRlIG9yIGNvbmZpZyB0YWdcblx0ICAgIGlmIChodG1sKSByZXR1cm4gdGFnLmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZSArIFwidmlld1wiKSB8fCAodGFnLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImNvbmZpZ1wiID8gXCJjb25maWdcIiA6IG51bGwpO1xuXHQgICAgdmFyIG5hbWUgPSB0YWcudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdCAgICBpZiAodGhpcy5uYW1lc3BhY2UpIHtcblx0ICAgICAgaWYgKG5hbWUuaW5kZXhPZih0aGlzLl9mdWxsX3ByZWZpeCkgPT09IDAgfHwgdGFnLnNjb3BlTmFtZSA9PSB0aGlzLm5hbWVzcGFjZSkgcmV0dXJuIG5hbWUucmVwbGFjZSh0aGlzLl9mdWxsX3ByZWZpeCwgXCJcIik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodWlbbmFtZV0gfHwgdGhpcy5fbWFya3VwX25hbWVzW25hbWVdKSByZXR1cm4gbmFtZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSxcblx0ICBfaGFuZGxlX2RhdGE6IGZ1bmN0aW9uIChlbCwgaHRtbCkge1xuXHQgICAgdmFyIGRhdGEgPSBbXTtcblx0ICAgIHZhciByZWNvcmRzID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUobWFya3VwLmRhdGFUYWcpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHJlYyA9IHJlY29yZHNbaV07XG5cblx0ICAgICAgaWYgKHJlYy5wYXJlbnROb2RlLnBhcmVudE5vZGUudGFnTmFtZSAhPSBtYXJrdXAuZGF0YVRhZykge1xuXHQgICAgICAgIHZhciBqc29uID0gdGhpcy5fdGFnX3RvX2pzb24ocmVjLCBodG1sKTsgLy9yZXVzZSBjc3MgY2xhc3MgXG5cblxuXHQgICAgICAgIGlmIChyZWMuY2xhc3NOYW1lKSBqc29uLiRjc3MgPSByZWMuY2xhc3NOYW1lO1xuXHQgICAgICAgIGRhdGEucHVzaChqc29uKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZW1vdmUoZWwpO1xuXHQgICAgcmV0dXJuIGRhdGE7XG5cdCAgfSxcblx0ICBfY29udGVudDogZnVuY3Rpb24gKGVsKSB7XG5cdCAgICBpZiAoZWwuc3R5bGUpIHJldHVybiBlbC5pbm5lckhUTUw7XG5cdCAgICBpZiAoZWwuZmlyc3RDaGlsZCkgcmV0dXJuIGVsLmZpcnN0Q2hpbGQud2hvbGVUZXh0IHx8IGVsLmZpcnN0Q2hpbGQuZGF0YSB8fCBcIlwiO1xuXHQgICAgcmV0dXJuIFwiXCI7XG5cdCAgfSxcblx0ICBfdGFnX3RvX2pzb246IGZ1bmN0aW9uIChlbCwgaHRtbCkge1xuXHQgICAgaWYgKCFodG1sKSByZXR1cm4gRGF0YURyaXZlci54bWwudGFnVG9PYmplY3QoZWwpO1xuXG5cdCAgICB2YXIganNvbiA9IHRoaXMuX2F0dHJzX3RvX2pzb24oZWwsIHt9LCBodG1sKTtcblxuXHQgICAgaWYgKCFqc29uLnZhbHVlICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSBqc29uLnZhbHVlID0gdGhpcy5fY29udGVudChlbCwgaHRtbCk7XG5cdCAgICByZXR1cm4ganNvbjtcblx0ICB9LFxuXHQgIF9hdHRyc190b19qc29uOiBmdW5jdGlvbiAoZWwsIGpzb24sIGh0bWwpIHtcblx0ICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuXG5cdCAgICAgIGlmIChodG1sKSB7XG5cdCAgICAgICAgaWYgKG5hbWUuaW5kZXhPZih0aGlzLmF0dHJpYnV0ZSkgIT09IDApIGNvbnRpbnVlO1xuXHQgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UodGhpcy5hdHRyaWJ1dGUsIFwiXCIpLnJlcGxhY2UodGhpcy5fZGFzaCwgdGhpcy5fYWZ0ZXJfZGFzaCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcblx0ICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCJqc29uOi8vXCIpICE9IC0xKSB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUucmVwbGFjZShcImpzb246Ly9cIiwgXCJcIikpO1xuXHQgICAgICBpZiAodGhpcy5fcGFyc2VfaW50W25hbWVdKSB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7ZWxzZSBpZiAodGhpcy5fcGFyc2VfYm9vbFtuYW1lXSkgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZSAhPT0gXCJmYWxzZVwiICYmIHZhbHVlICE9IFwiMFwiO1xuXHQgICAgICBqc29uW25hbWVdID0gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBqc29uO1xuXHQgIH1cblx0fTtcblxuXHRlbnYucHJpbnRQUEkgPSA5Njtcblx0ZW52LnByaW50TWFyZ2luID0gMC43NSAqIGVudi5wcmludFBQSTtcblx0dmFyIG1hcmdpbiA9IGVudi5wcmludE1hcmdpbjtcblx0dmFyIHBhcGVycyA9IHtcblx0ICBcImE0XCI6IFwiQTRcIixcblx0ICBcImEzXCI6IFwiQTNcIixcblx0ICBcImxldHRlclwiOiBcImxldHRlclwiXG5cdH07XG5cdHZhciBmaXRzID0ge1xuXHQgIHBhZ2U6IHRydWUsXG5cdCAgZGF0YTogdHJ1ZVxuXHR9O1xuXHR2YXIgbW9kZXMgPSB7XG5cdCAgcG9ydHJhaXQ6IHRydWUsXG5cdCAgbGFuZHNjYXBlOiB0cnVlXG5cdH07XG5cdHZhciBzaXplcyA9IHtcblx0ICAvL2luY2hlcywgcmVhbCBzaXplIGlzIHZhbHVlKnBwaVxuXHQgIFwiQTNcIjoge1xuXHQgICAgd2lkdGg6IDExLjcsXG5cdCAgICBoZWlnaHQ6IDE2LjVcblx0ICB9LFxuXHQgIFwiQTRcIjoge1xuXHQgICAgd2lkdGg6IDguMjcsXG5cdCAgICBoZWlnaHQ6IDExLjdcblx0ICB9LFxuXHQgIFwibGV0dGVyXCI6IHtcblx0ICAgIHdpZHRoOiA4LjUsXG5cdCAgICBoZWlnaHQ6IDExXG5cdCAgfVxuXHR9O1xuXG5cdHZhciBwcmludCA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXHQgIHZhciB2aWV3ID0gJCQoaWQpO1xuXHQgIGlmICh2aWV3ICYmIHZpZXcuJHByaW50VmlldykgdmlldyA9IHZpZXcuJHByaW50VmlldygpO1xuXHQgIGFzc2VydCh2aWV3LCBcIm5vbi1leGlzdGluZyB2aWV3IGZvciBwcmludGluZ1wiKTtcblx0ICBpZiAoIXZpZXcpIHJldHVybjtcblx0ICBpZiAodmlldy5jYWxsRXZlbnQpIHZpZXcuY2FsbEV2ZW50KFwib25CZWZvcmVQcmludFwiLCBbb3B0aW9uc10pO1xuXHQgIG9wdGlvbnMgPSBfY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG5cdCAgX2JlZm9yZVByaW50KG9wdGlvbnMpOyAvL3RyeSB3aWRnZXQncyBjdXN0b20gbG9naWMgZmlyc3QsIHNvbWV0aW1lcyBpdCBtYXkgZGVueSBcblxuXG5cdCAgaWYgKCF2aWV3LiRjdXN0b21QcmludCB8fCB2aWV3LiRjdXN0b21QcmludChvcHRpb25zKSA9PT0gdHJ1ZSkgX3ByaW50KHZpZXcsIG9wdGlvbnMpO1xuXG5cdCAgX2FmdGVyUHJpbnQob3B0aW9ucyk7XG5cdH07XG5cdC8qcHJvY2Vzc2luZyBwcmludCBvcHRpb25zKi9cblxuXG5cdGZ1bmN0aW9uIF9jaGVja09wdGlvbnMob3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIG9wdGlvbnMucGFwZXIgPSBwYXBlcnNbKG9wdGlvbnMucGFwZXIgfHwgXCJcIikudG9Mb3dlckNhc2UoKV0gfHwgXCJBNFwiO1xuXHQgIG9wdGlvbnMubW9kZSA9IG1vZGVzW29wdGlvbnMubW9kZV0gPyBvcHRpb25zLm1vZGUgOiBcInBvcnRyYWl0XCI7XG5cdCAgb3B0aW9ucy5maXQgPSBmaXRzW29wdGlvbnMuZml0XSA/IG9wdGlvbnMuZml0IDogXCJwYWdlXCI7XG5cdCAgb3B0aW9ucy5zY3JvbGwgPSBvcHRpb25zLnNjcm9sbCB8fCBmYWxzZTtcblx0ICBvcHRpb25zLnNpemUgPSBzaXplc1tvcHRpb25zLnBhcGVyXTtcblx0ICBvcHRpb25zLm1hcmdpbiA9IG9wdGlvbnMubWFyZ2luIHx8IG9wdGlvbnMubWFyZ2luID09PSAwID8gb3B0aW9ucy5tYXJnaW4gOiB7fTtcblx0ICBtYXJnaW4gPSBpc05hTihvcHRpb25zLm1hcmdpbiAqIDEpID8gbWFyZ2luIDogb3B0aW9ucy5tYXJnaW47XG5cdCAgb3B0aW9ucy5tYXJnaW4gPSB7XG5cdCAgICB0b3A6IG9wdGlvbnMubWFyZ2luLnRvcCB8fCBvcHRpb25zLm1hcmdpbi50b3AgPT09IDAgPyBvcHRpb25zLm1hcmdpbi50b3AgOiBtYXJnaW4sXG5cdCAgICBib3R0b206IG9wdGlvbnMubWFyZ2luLmJvdHRvbSB8fCBvcHRpb25zLm1hcmdpbi5ib3R0b20gPT09IDAgPyBvcHRpb25zLm1hcmdpbi5ib3R0b20gOiBtYXJnaW4sXG5cdCAgICByaWdodDogb3B0aW9ucy5tYXJnaW4ucmlnaHQgfHwgb3B0aW9ucy5tYXJnaW4ucmlnaHQgPT09IDAgPyBvcHRpb25zLm1hcmdpbi5yaWdodCA6IG1hcmdpbixcblx0ICAgIGxlZnQ6IG9wdGlvbnMubWFyZ2luLmxlZnQgfHwgb3B0aW9ucy5tYXJnaW4ubGVmdCA9PT0gMCA/IG9wdGlvbnMubWFyZ2luLmxlZnQgOiBtYXJnaW5cblx0ICB9O1xuXHQgIHJldHVybiBvcHRpb25zO1xuXHR9XG5cdC8qcHJlcGFyaW5nIHByaW50aW5nIGVudmlyb25tZW50Ki9cblxuXG5cdGZ1bmN0aW9uIF9iZWZvcmVQcmludChvcHRpb25zKSB7XG5cdCAgYWRkQ3NzKGRvY3VtZW50LmJvZHksIFwid2ViaXhfcHJpbnRcIik7XG5cdCAgaWYgKG9wdGlvbnMuZG9jSGVhZGVyKSBfZ2V0SGVhZGVyRm9vdGVyKFwiSGVhZGVyXCIsIG9wdGlvbnMpO1xuXHQgIGlmIChvcHRpb25zLmRvY0Zvb3RlcikgX2dldEhlYWRlckZvb3RlcihcIkZvb3RlclwiLCBvcHRpb25zKTtcblx0ICAvKiBzdGF0aWMgcHJpbnQgc3R5bGVzIGFyZSBsb2NhdGVkIGF0ICdjc3MvcHJpbnQubGVzcycqL1xuXG5cdCAgdmFyIGNzc1N0cmluZyA9IFwiQG1lZGlhIHByaW50IHsgXCIgKyBcIkBwYWdleyBzaXplOlwiICsgb3B0aW9ucy5wYXBlciArIFwiIFwiICsgb3B0aW9ucy5tb2RlICsgXCI7XCIgKyBcIm1hcmdpbi10b3A6XCIgKyBvcHRpb25zLm1hcmdpbi50b3AgKyBcInB4O21hcmdpbi1ib3R0b206XCIgKyBvcHRpb25zLm1hcmdpbi5ib3R0b20gKyBcInB4O21hcmdpbi1yaWdodDpcIiArIG9wdGlvbnMubWFyZ2luLnJpZ2h0ICsgXCJweDttYXJnaW4tbGVmdDpcIiArIG9wdGlvbnMubWFyZ2luLmxlZnQgKyBcInB4O31cIiArIFwifVwiO1xuXHQgIGFkZFN0eWxlKGNzc1N0cmluZywgXCJwcmludFwiKTtcblx0fVxuXHQvKmNsZWFuaW5nIGVudmlyb25tZW50Ki9cblxuXG5cdGZ1bmN0aW9uIF9hZnRlclByaW50KG9wdGlvbnMpIHtcblx0ICByZW1vdmVDc3MoZG9jdW1lbnQuYm9keSwgXCJ3ZWJpeF9wcmludFwiKTtcblx0ICByZW1vdmVTdHlsZShcInByaW50XCIpO1xuXHQgIGlmIChvcHRpb25zLmRvY0hlYWRlcikgcmVtb3ZlKG9wdGlvbnMuZG9jSGVhZGVyKTtcblx0ICBpZiAob3B0aW9ucy5kb2NGb290ZXIpIHJlbW92ZShvcHRpb25zLmRvY0Zvb3Rlcik7XG5cdH1cblx0Lypjb21tb24gcHJpbnQgYWN0aW9ucyAqL1xuXG5cblx0ZnVuY3Rpb24gX3ByaW50KHZpZXcsIG9wdGlvbnMpIHtcblx0ICB2YXIgZG9jID0gdmlldy4kdmlldy5jbG9uZU5vZGUodHJ1ZSk7IC8vY29weSBkYXRhIGZyb20gYWxsIGNhbnZhc2VzXG5cblx0ICB2YXIgY2FudmFzZXMgPSB2aWV3LiR2aWV3LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FudmFzXCIpO1xuXHQgIGlmIChjYW52YXNlcy5sZW5ndGgpIGZvciAodmFyIGkgPSBjYW52YXNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgdmFyIGRlc3RDdHggPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYW52YXNcIilbaV0uZ2V0Q29udGV4dChcIjJkXCIpO1xuXHQgICAgZGVzdEN0eC5kcmF3SW1hZ2UoY2FudmFzZXNbaV0sIDAsIDApO1xuXHQgIH1cblx0ICBpbnNlcnRCZWZvcmUoZG9jLCBvcHRpb25zLmRvY0Zvb3RlciwgZG9jdW1lbnQuYm9keSk7XG5cdCAgYWRkQ3NzKGRvYywgXCJ3ZWJpeF91aV9wcmludFwiKTtcblx0ICBpZiAoIW9wdGlvbnMuc2Nyb2xsICYmICh2aWV3Ll9kYXRhb2JqICYmIHZpZXcuZGF0YSAmJiB2aWV3LmRhdGEucHVsbCB8fCB2aWV3LmdldEJvZHkpKSBhZGRDc3MoZG9jLCBcIndlYml4X3ByaW50X25vc2Nyb2xsXCIpO1xuXHQgIHdpbmRvdy5wcmludCgpO1xuXHQgIHJlbW92ZShkb2MpO1xuXHR9XG5cdC8qY3VzdG9tIGhlYWRlciBuYWQgZm9vdGVyKi9cblxuXG5cdGZ1bmN0aW9uIF9nZXRIZWFkZXJGb290ZXIoZ3JvdXAsIG9wdGlvbnMpIHtcblx0ICB2YXIgaGVhZGVyID0gY3JlYXRlKFwiZGl2XCIsIHtcblx0ICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF92aWV3IHdlYml4X3ByaW50X1wiICsgZ3JvdXAudG9Mb3dlckNhc2UoKSxcblx0ICAgIFwic3R5bGVcIjogXCJoZWlnaHQ6MHB4O3Zpc2liaWxpdHk6aGlkZGVuO1wiXG5cdCAgfSwgb3B0aW9uc1tcImRvY1wiICsgZ3JvdXBdKTtcblx0ICBpZiAoZ3JvdXAgPT09IFwiSGVhZGVyXCIpIGluc2VydEJlZm9yZShoZWFkZXIsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7ZWxzZSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhlYWRlcik7XG5cdCAgb3B0aW9uc1tcImRvY1wiICsgZ3JvdXBdID0gaGVhZGVyO1xuXHR9XG5cblx0dmFyIHBhdHRlcm5zID0ge1xuXHQgIHBob25lOiB7XG5cdCAgICBtYXNrOiBcIisjICgjIyMpICMjIy0jIyMjXCIsXG5cdCAgICBhbGxvdzogL1swLTldL2dcblx0ICB9LFxuXHQgIGNhcmQ6IHtcblx0ICAgIG1hc2s6IFwiIyMjIyAjIyMjICMjIyMgIyMjI1wiLFxuXHQgICAgYWxsb3c6IC9bMC05XS9nXG5cdCAgfSxcblx0ICBkYXRlOiB7XG5cdCAgICBtYXNrOiBcIiMjIyMtIyMtIyMgIyM6IyNcIixcblx0ICAgIGFsbG93OiAvWzAtOV0vZ1xuXHQgIH1cblx0fTtcblxuXHQvKlxuXHRcdENvbW1vbiBoZWxwZXJzXG5cdCovXG5cdHZhciBodG1sJDEgPSB7XG5cdCAgZGVueVNlbGVjdDogZGVueVNlbGVjdCxcblx0ICBhbGxvd1NlbGVjdDogYWxsb3dTZWxlY3QsXG5cdCAgaW5kZXg6IGluZGV4LFxuXHQgIGNyZWF0ZUNzczogY3JlYXRlQ3NzLFxuXHQgIGFkZFN0eWxlOiBhZGRTdHlsZSxcblx0ICByZW1vdmVTdHlsZTogcmVtb3ZlU3R5bGUsXG5cdCAgY3JlYXRlOiBjcmVhdGUsXG5cdCAgZ2V0VmFsdWU6IGdldFZhbHVlLFxuXHQgIHJlbW92ZTogcmVtb3ZlLFxuXHQgIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHQgIGxvY2F0ZTogbG9jYXRlLFxuXHQgIG9mZnNldDogb2Zmc2V0LFxuXHQgIHBvc1JlbGF0aXZlOiBwb3NSZWxhdGl2ZSxcblx0ICBwb3M6IHBvcyxcblx0ICBwcmV2ZW50RXZlbnQ6IHByZXZlbnRFdmVudCxcblx0ICBzdG9wRXZlbnQ6IHN0b3BFdmVudCxcblx0ICB0cmlnZ2VyRXZlbnQ6IHRyaWdnZXJFdmVudCxcblx0ICBhZGRDc3M6IGFkZENzcyxcblx0ICByZW1vdmVDc3M6IHJlbW92ZUNzcyxcblx0ICBnZXRUZXh0U2l6ZTogZ2V0VGV4dFNpemUsXG5cdCAgZG93bmxvYWQ6IGRvd25sb2FkLFxuXHQgIF9nZXRDbGFzc05hbWU6IF9nZXRDbGFzc05hbWUsXG5cdCAgc2V0U2VsZWN0aW9uUmFuZ2U6IHNldFNlbGVjdGlvblJhbmdlLFxuXHQgIGdldFNlbGVjdGlvblJhbmdlOiBnZXRTZWxlY3Rpb25SYW5nZSxcblx0ICBhZGRNZXRhOiBhZGRNZXRhXG5cdH07XG5cblx0dmFyIHRpbWVycyA9IHt9O1xuXHRmdW5jdGlvbiBqc29ucCh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIG1hc3Rlcikge1xuXHQgIHZhciBkZWZlciA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgdmFyIGlkID0gXCJ3ZWJpeF9qc29ucF9cIiArIHVpZCgpO1xuXHQgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHQgIHNjcmlwdC5pZCA9IGlkO1xuXHQgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0ICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblxuXHQgIGlmICh0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgbWFzdGVyID0gY2FsbGJhY2s7XG5cdCAgICBjYWxsYmFjayA9IHBhcmFtcztcblx0ICAgIHBhcmFtcyA9IHt9O1xuXHQgIH1cblxuXHQgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblx0ICBwYXJhbXMuanNvbnAgPSBpZDtcblxuXHQgIHdpbmRvd1tpZF0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KG1hc3RlciB8fCB3aW5kb3csIGFyZ3VtZW50cyk7XG5cdCAgICBkZWZlci5yZXNvbHZlKGFyZ3VtZW50c1swXSk7XG5cdCAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyc1tpZF0pO1xuXHQgICAgZGVsZXRlIHRpbWVyc1tpZF07XG5cdCAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHQgICAgY2FsbGJhY2sgPSBoZWFkID0gbWFzdGVyID0gc2NyaXB0ID0gbnVsbDtcblx0ICAgIGRlbGV0ZSB3aW5kb3dbaWRdO1xuXHQgIH07IC8vdGltZW91dCB0aW1lclxuXG5cblx0ICB0aW1lcnNbaWRdID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgZGVmZXIucmVqZWN0KCk7XG5cdCAgICBkZWxldGUgd2luZG93W2lkXTtcblx0ICB9LCBqc29ucC50aW1lcik7XG5cdCAgdmFyIHZhbHMgPSBbXTtcblxuXHQgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcblx0ICAgIHZhbHMucHVzaChrZXkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuXHQgIH1cblxuXHQgIHVybCArPSAodXJsLmluZGV4T2YoXCI/XCIpID09IC0xID8gXCI/XCIgOiBcIiZcIikgKyB2YWxzLmpvaW4oXCImXCIpO1xuXHQgIHNjcmlwdC5zcmMgPSB1cmw7XG5cdCAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHQgIHJldHVybiBkZWZlcjtcblx0fVxuXHRqc29ucC50aW1lciA9IDMwMDA7XG5cblx0dmFyIGVycm9yX2tleSA9IFwiX193ZWJpeF9yZW1vdGVfZXJyb3JcIjtcblxuXHRmdW5jdGlvbiBSZW1vdGVDb250ZXh0KHVybCwgY29uZmlnKSB7XG5cdCAgdGhpcy5fcHJveHkgPSB7fTtcblx0ICB0aGlzLl9xdWV1ZSA9IFtdO1xuXHQgIHRoaXMuX3VybCA9IHVybDtcblx0ICB0aGlzLl9rZXkgPSBcIlwiO1xuXHQgIGlmIChjb25maWcpIHRoaXMuX3Byb2Nlc3MoY29uZmlnKTtlbHNlIHRoaXMuX3JlYWR5ID0gYWpheCh1cmwpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHJldHVybiBkYXRhLnRleHQoKTtcblx0ICB9KS50aGVuKGJpbmQoZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgIHRleHQgPSB0ZXh0LnNwbGl0KFwiLyphcGkqL1wiKVsxXTtcblxuXHQgICAgdGhpcy5fcHJvY2VzcyhKU09OLnBhcnNlKHRleHQpKTtcblxuXHQgICAgcmV0dXJuIHRoaXMuX3Byb3h5O1xuXHQgIH0sIHRoaXMpKTtcblx0fVxuXG5cdFJlbW90ZUNvbnRleHQucHJvdG90eXBlID0ge1xuXHQgIF9wcm9jZXNzOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBpZiAoY29uZmlnLiRrZXkpIHRoaXMuX2tleSA9IGNvbmZpZy4ka2V5O1xuXHQgICAgaWYgKGNvbmZpZy4kdmFycykgZm9yICh2YXIga2V5IGluIGNvbmZpZy4kdmFycykge1xuXHQgICAgICB0aGlzLl9wcm94eVtrZXldID0gY29uZmlnLiR2YXJzW2tleV07XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3BhcnNlKGNvbmZpZywgdGhpcy5fcHJveHksIFwiXCIpO1xuXHQgIH0sXG5cdCAgX3BhcnNlOiBmdW5jdGlvbiAoYXBpLCBvYmosIHByZWZpeCkge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGFwaSkge1xuXHQgICAgICBpZiAoa2V5ID09PSBcIiRrZXlcIiB8fCBrZXkgPT09IFwiJHZhcnNcIikgY29udGludWU7XG5cdCAgICAgIHZhciB2YWwgPSBhcGlba2V5XTtcblxuXHQgICAgICBpZiAoX3R5cGVvZih2YWwpID09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIgc3ViID0gb2JqW2tleV0gPSB7fTtcblxuXHQgICAgICAgIHRoaXMuX3BhcnNlKHZhbCwgc3ViLCBwcmVmaXggKyBrZXkgKyBcIi5cIik7XG5cdCAgICAgIH0gZWxzZSBvYmpba2V5XSA9IHRoaXMuX3Byb3h5X2NhbGwodGhpcywgcHJlZml4ICsga2V5KTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jYWxsOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuXHQgICAgdmFyIGRlZiA9IHRoaXMuX2RlZmZlcih0aGlzLCBuYW1lLCBhcmdzKTtcblxuXHQgICAgdGhpcy5fcXVldWUucHVzaChkZWYpO1xuXG5cdCAgICB0aGlzLl9zdGFydF9xdWV1ZSgpO1xuXG5cdCAgICByZXR1cm4gZGVmO1xuXHQgIH0sXG5cdCAgX3N0YXJ0X3F1ZXVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX3RpbWVyKSB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoYmluZCh0aGlzLl9ydW5fcXVldWUsIHRoaXMpLCAxKTtcblx0ICB9LFxuXHQgIF9ydW5fcXVldWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBkYXRhID0gW10sXG5cdCAgICAgICAgZGVmcyA9IHRoaXMuX3F1ZXVlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBkZWYgPSB0aGlzLl9xdWV1ZVtpXTtcblxuXHQgICAgICBpZiAoZGVmLiRzeW5jKSB7XG5cdCAgICAgICAgZGVmcy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgaS0tO1xuXHQgICAgICB9IGVsc2UgZGF0YS5wdXNoKHtcblx0ICAgICAgICBuYW1lOiBkZWYuJG5hbWUsXG5cdCAgICAgICAgYXJnczogZGVmLiRhcmdzXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZGVmcy5sZW5ndGgpIHtcblx0ICAgICAgdmFyIHJlcXVlc3QgPSBhamF4KCk7XG5cblx0ICAgICAgdmFyIHBhY2sgPSB0aGlzLl9wYWNrKGRhdGEpO1xuXG5cdCAgICAgIGNhbGxFdmVudChcIm9uQmVmb3JlUmVtb3RlQ2FsbFwiLCBbcmVxdWVzdCwgcGFjaywge31dKTtcblx0ICAgICAgdmFyIHByb21pc2UgPSByZXF1ZXN0LnBvc3QodGhpcy5fdXJsLCBwYWNrKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHQgICAgICAgIHZhciBkYXRhID0gcmVzcG9uc2UuanNvbigpO1xuXHQgICAgICAgIHZhciByZXN1bHRzID0gZGF0YS5kYXRhO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgcmVzID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgIHZhciBlcnJvciA9IHJlc3VsdHNbaV0gJiYgcmVzdWx0c1tpXVtlcnJvcl9rZXldO1xuXG5cdCAgICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgY2FsbEV2ZW50KFwib25SZW1vdGVFcnJvclwiLCBbZXJyb3JdKTtcblx0ICAgICAgICAgICAgZGVmc1tpXS5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZGVmc1tpXS5yZXNvbHZlKHJlcyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBkZWZzW2ldLnJlamVjdChyZXMpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRocm93IHJlcztcblx0ICAgICAgfSk7XG5cdCAgICAgIGNhbGxFdmVudChcIm9uQWZ0ZXJSZW1vdGVDYWxsXCIsIFtwcm9taXNlXSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3F1ZXVlID0gW107XG5cdCAgICB0aGlzLl90aW1lciA9IG51bGw7XG5cdCAgfSxcblx0ICBfc3luYzogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZhbHVlID0gbnVsbDtcblx0ICAgIHRoaXMuJHN5bmMgPSB0cnVlO1xuXHQgICAgdmFyIGRhdGEgPSBbe1xuXHQgICAgICBuYW1lOiB0aGlzLiRuYW1lLFxuXHQgICAgICBhcmdzOiB0aGlzLiRhcmdzXG5cdCAgICB9XTtcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgdmFyIHJlcXVlc3QgPSBhamF4KCk7XG5cblx0ICAgICAgdmFyIHBhY2sgPSB0aGlzLiRjb250ZXh0Ll9wYWNrKGRhdGEpO1xuXG5cdCAgICAgIGNhbGxFdmVudChcIm9uQmVmb3JlUmVtb3RlQ2FsbFwiLCBbcmVxdWVzdCwgcGFjaywge1xuXHQgICAgICAgIHN5bmM6IHRydWVcblx0ICAgICAgfV0pO1xuXHQgICAgICB2YXIgeGhyID0gcmVxdWVzdC5zeW5jKCkucG9zdCh0aGlzLiRjb250ZXh0Ll91cmwsIHBhY2spO1xuXHQgICAgICBjYWxsRXZlbnQoXCJvbkFmdGVyUmVtb3RlQ2FsbFwiLCBbbnVsbF0pO1xuXHQgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkuZGF0YVswXTtcblx0ICAgICAgaWYgKHZhbHVlW2Vycm9yX2tleV0pIHZhbHVlID0gbnVsbDtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9kZWZmZXI6IGZ1bmN0aW9uIChtYXN0ZXIsIG5hbWUsIGFyZ3MpIHtcblx0ICAgIHZhciBwciA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgICBwci5zeW5jID0gbWFzdGVyLl9zeW5jO1xuXHQgICAgcHIuJG5hbWUgPSBuYW1lO1xuXHQgICAgcHIuJGFyZ3MgPSBhcmdzO1xuXHQgICAgcHIuJGNvbnRleHQgPSB0aGlzO1xuXHQgICAgcmV0dXJuIHByO1xuXHQgIH0sXG5cdCAgX3Byb3h5X2NhbGw6IGZ1bmN0aW9uIChtYXN0ZXIsIG5hbWUpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBtYXN0ZXIuX2NhbGwobmFtZSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfZ2V0UHJveHk6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9yZWFkeSB8fCB0aGlzLl9wcm94eTtcblx0ICB9LFxuXHQgIF9wYWNrOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBrZXk6IHRoaXMuX2tleSxcblx0ICAgICAgcGF5bG9hZDogb2JqXG5cdCAgICB9O1xuXHQgIH1cblx0fTtcblxuXHRmdW5jdGlvbiBnZXRBcGkodXJsLCBjb25maWcpIHtcblx0ICB2YXIgY3R4ID0gbmV3IFJlbW90ZUNvbnRleHQodXJsLCBjb25maWcpO1xuXG5cdCAgdmFyIHByb3h5ID0gY3R4Ll9nZXRQcm94eSgpO1xuXG5cdCAgZm9yICh2YXIga2V5IGluIHByb3h5KSB7XG5cdCAgICByZW1vdGVba2V5XSA9IHByb3h5W2tleV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHByb3h5O1xuXHR9XG5cblx0dmFyIHJlbW90ZSA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuXHQgIGlmIChfdHlwZW9mKHVybCkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdCAgICBjb25maWcgPSB1cmw7XG5cdCAgICB1cmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjO1xuXHQgICAgcmV0dXJuIGdldEFwaSh1cmwsIGNvbmZpZyk7XG5cdCAgfSBlbHNlIHJldHVybiBnZXRBcGkodXJsLCBjb25maWcpO1xuXHR9O1xuXG5cdC8qc3VibWl0cyB2YWx1ZXMqL1xuXG5cdGZ1bmN0aW9uIHNlbmQodXJsLCB2YWx1ZXMsIG1ldGhvZCwgdGFyZ2V0KSB7XG5cdCAgdmFyIGZvcm0gPSBjcmVhdGUoXCJGT1JNXCIsIHtcblx0ICAgIFwidGFyZ2V0XCI6IHRhcmdldCB8fCBcIl9zZWxmXCIsXG5cdCAgICBcImFjdGlvblwiOiB1cmwsXG5cdCAgICBcIm1ldGhvZFwiOiBtZXRob2QgfHwgXCJQT1NUXCJcblx0ICB9LCBcIlwiKTtcblxuXHQgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG5cdCAgICB2YXIgZmllbGQgPSBjcmVhdGUoXCJJTlBVVFwiLCB7XG5cdCAgICAgIFwidHlwZVwiOiBcImhpZGRlblwiLFxuXHQgICAgICBcIm5hbWVcIjogayxcblx0ICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZXNba11cblx0ICAgIH0sIFwiXCIpO1xuXHQgICAgZm9ybS5hcHBlbmRDaGlsZChmaWVsZCk7XG5cdCAgfVxuXG5cdCAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblx0ICBmb3JtLnN1Ym1pdCgpO1xuXHQgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZm9ybSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhbmltYXRlJDEob2JqLCBwYXJlbnQsIGNvbmZpZykge1xuXHQgIHZhciBwb2JqID0gJCQocGFyZW50KTtcblxuXHQgIGlmIChwb2JqKSB7XG5cdCAgICB2YXIgYW5pc2V0ID0gY29uZmlnIHx8IHtcblx0ICAgICAgdHlwZTogXCJzbGlkZVwiLFxuXHQgICAgICBkaXJlY3Rpb246IFwibGVmdFwiXG5cdCAgICB9O1xuXG5cdCAgICB2YXIgZCA9IHBvYmouX3ZpZXdvYmouY2xvbmVOb2RlKHRydWUpO1xuXG5cdCAgICB2YXIgdmlldyA9IHVpKG9iaiwgcGFyZW50KTtcblxuXHQgICAgdmlldy5fdmlld29iai5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGQpO1xuXG5cdCAgICB2YXIgbGluZSA9IGFuaW1hdGUuZm9ybUxpbmUodmlldy5fdmlld29iaiwgZCwgYW5pc2V0KTtcblxuXHQgICAgYW5pc2V0LmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICBhbmltYXRlLmJyZWFrTGluZShsaW5lKTtcblx0ICAgIH07XG5cblx0ICAgIGFuaW1hdGUobGluZSwgYW5pc2V0KTtcblx0ICAgIHJldHVybiB2aWV3O1xuXHQgIH1cblx0fVxuXHRmdW5jdGlvbiBhbmltYXRlVmlldyh2aWV3LCBzdGF0ZUhhbmRsZXIsIGNvbmZpZykge1xuXHQgIHZpZXcgPSAkJCh2aWV3KTtcblxuXHQgIGlmICh2aWV3KSB7XG5cdCAgICBjb25maWcgPSBjb25maWcgfHwge1xuXHQgICAgICB0eXBlOiBcInNsaWRlXCIsXG5cdCAgICAgIGRpcmVjdGlvbjogXCJsZWZ0XCJcblx0ICAgIH07XG5cblx0ICAgIHZhciBnZXRIVE1MID0gZnVuY3Rpb24gKHZpZXcpIHtcblx0ICAgICAgdmFyIGVsID0gdmlldy5fdmlld29iajtcblx0ICAgICAgdmFyIGNzcyA9IGVsLmNsYXNzTmFtZTtcblx0ICAgICAgdmFyIGNvbnRlbnQgPSBlbC5pbm5lckhUTUw7XG5cdCAgICAgIHJldHVybiBcIjxkaXYgY2xhc3M9J1wiICsgY3NzICsgXCInIHN0eWxlPSd3aWR0aDpcIiArIGVsLm9mZnNldFdpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyBlbC5vZmZzZXRIZWlnaHQgKyBcInB4Oyc+XCIgKyBjb250ZW50ICsgXCI8L2Rpdj5cIjtcblx0ICAgIH07IC8vIGdldCAnZGlzcGxheScgc3RhdGUgb2YgY2hpbGQgbm9kZXNcblxuXG5cdCAgICB2YXIgZGlzcGxheSA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcuX3ZpZXdvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbm9kZSA9IHZpZXcuX3ZpZXdvYmouY2hpbGROb2Rlc1tpXTtcblx0ICAgICAgdmFyIHZhbHVlID0gbm9kZS5jdXJyZW50U3R5bGUgPyBub2RlLmN1cnJlbnRTdHlsZS5kaXNwbGF5IDogZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5kaXNwbGF5O1xuXHQgICAgICBkaXNwbGF5LnB1c2godmFsdWUgfHwgXCJcIik7XG5cdCAgICB9IC8vIGdldCBjdXJyZW50IGh0bWwgY29udGVudFxuXG5cblx0ICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRIVE1MKHZpZXcpOyAvLyBhcHBseSBuZXcgc3RhdGVcblxuXHQgICAgaWYgKHR5cGVvZiBzdGF0ZUhhbmRsZXIgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgIHN0YXRlSGFuZGxlci5jYWxsKHRoaXMpO1xuXHQgICAgfSAvLyBnZXQgbmV3IGh0bWwgY29udGVudFxuXG5cblx0ICAgIHZhciBuZXdTdGF0ZSA9IGdldEhUTUwodmlldyk7IC8vIGluc2VydCBlbGVtZW50cyBpbnRvIHRoZSB2aWV3XG5cblx0ICAgIHZhciB0ZW1wUGFyZW50ID0gdmlldy5fdmlld29iai5pbnNlcnRCZWZvcmUoY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3ZpZXdfYW5pbWF0ZVwiLFxuXHQgICAgICBcInN0eWxlXCI6IFwid2lkdGg6XCIgKyB2aWV3Ll92aWV3b2JqLm9mZnNldFdpZHRoICsgXCJweDtoZWlnaHQ6XCIgKyB2aWV3Ll92aWV3b2JqLm9mZnNldEhlaWdodCArIFwicHg7XCJcblx0ICAgIH0sIG5ld1N0YXRlICsgY3VycmVudFN0YXRlKSwgdmlldy5fdmlld29iai5maXJzdENoaWxkKTsgLy8gaGlkZSBjaGlsZCBub2Rlc1xuXG5cblx0ICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCB2aWV3Ll92aWV3b2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIHZpZXcuX3ZpZXdvYmouY2hpbGROb2Rlc1tfaV0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgfSAvLyBhbmltYXRlIGluc2VydGVkIGVsZW1lbnRzXG5cblxuXHQgICAgdmFyIGxpbmUgPSBhbmltYXRlLmZvcm1MaW5lKHRlbXBQYXJlbnQuY2hpbGROb2Rlc1swXSwgdGVtcFBhcmVudC5jaGlsZE5vZGVzWzFdLCBjb25maWcpO1xuXG5cdCAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0ZW1wUGFyZW50KSB7XG5cdCAgICAgICAgdmlldy5fdmlld29iai5yZW1vdmVDaGlsZCh0ZW1wUGFyZW50KTtcblxuXHQgICAgICAgIHRlbXBQYXJlbnQgPSBudWxsOyAvLyByZXN0b3JlICdkaXNwbGF5JyBzdGF0ZSBvZiBjaGlsZCBub2Rlc1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Ll92aWV3b2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZpZXcuX3ZpZXdvYmouY2hpbGROb2Rlc1tpXS5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheVtpXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGFuaW1hdGUobGluZSwgY29uZmlnKTtcblx0ICAgIHJldHVybiB2aWV3O1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9yaWVudGF0aW9uKCkge1xuXHQgIHZhciBuZXdfb3JpZW50YXRpb24gPSAhISh3aW5kb3cub3JpZW50YXRpb24gJSAxODApO1xuXHQgIGlmIChzdGF0ZS5vcmllbnRhdGlvbiA9PT0gbmV3X29yaWVudGF0aW9uKSByZXR1cm47XG5cdCAgc3RhdGUub3JpZW50YXRpb24gPSBuZXdfb3JpZW50YXRpb247XG5cdCAgY2FsbEV2ZW50KFwib25Sb3RhdGVcIiwgW25ld19vcmllbnRhdGlvbl0pO1xuXHR9XG5cblx0aWYgKGVudi50b3VjaCkge1xuXHQgIHN0YXRlLm9yaWVudGF0aW9uID0gISEoKGlzVW5kZWZpbmVkKHdpbmRvdy5vcmllbnRhdGlvbikgPyA5MCA6IHdpbmRvdy5vcmllbnRhdGlvbikgJSAxODApO1xuXHQgIGV2ZW50JDEod2luZG93LCBcIm9ub3JpZW50YXRpb25jaGFuZ2VcIiBpbiB3aW5kb3cgPyBcIm9yaWVudGF0aW9uY2hhbmdlXCIgOiBcInJlc2l6ZVwiLCBvcmllbnRhdGlvbik7XG5cdH1cblxuXHRmdW5jdGlvbiBmdWxsU2NyZWVuKCkge1xuXHQgIGlmICghZW52LnRvdWNoKSByZXR1cm47XG5cdCAgYWRkTWV0YShcImFwcGxlLW1vYmlsZS13ZWItYXBwLWNhcGFibGVcIiwgXCJ5ZXNcIik7XG5cdCAgYWRkTWV0YShcInZpZXdwb3J0XCIsIFwiaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEsIHVzZXItc2NhbGFibGU9bm8sIHNocmluay10by1maXQ9bm9cIik7XG5cblx0ICB2YXIgZml4ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblx0ICAgIHZhciB5ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdCAgICBpZiAoeSkge1xuXHQgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9IHkgKyBcInB4XCI7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUud2lkdGggPSB4ICsgXCJweFwiO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5fZnJlZXplX3Jlc2l6ZSA9IGZhbHNlO1xuXHQgICAgcmVzaXplKCk7XG5cdCAgfTtcblxuXHQgIHZhciBvbnJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHN0YXRlLl9mcmVlemVfcmVzaXplID0gdHJ1ZTtcblx0ICAgIGRlbGF5KGZpeCwgbnVsbCwgW10sIDUwMCk7XG5cdCAgfTtcblxuXHQgIGF0dGFjaEV2ZW50KFwib25Sb3RhdGVcIiwgb25yb3RhdGUpO1xuXHQgIG9yaWVudGF0aW9uKCk7XG5cdCAgZGVsYXkob25yb3RhdGUpO1xuXHR9XG5cblx0dmFyIGRhdGFmaWx0ZXIgPSB7XG5cdCAgdGV4dFdhaXREZWxheTogNTAwLFxuXHQgIFwic3VtbUNvbHVtblwiOiB7XG5cdCAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIG5vZGUuZmlyc3RDaGlsZC5pbm5lckhUTUw7XG5cdCAgICB9LFxuXHQgICAgc2V0VmFsdWU6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgcmVmcmVzaDogZnVuY3Rpb24gKG1hc3Rlciwgbm9kZSwgdmFsdWUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICAgIG1hc3Rlci5tYXBDZWxscyhudWxsLCB2YWx1ZS5jb2x1bW5JZCwgbnVsbCwgMSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE7XG5cdCAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHJlc3VsdCArPSB2YWx1ZTtcblx0ICAgICAgfSwgdHJ1ZSk7XG5cdCAgICAgIGlmICh2YWx1ZS5mb3JtYXQpIHJlc3VsdCA9IHZhbHVlLmZvcm1hdChyZXN1bHQpO1xuXHQgICAgICBpZiAodmFsdWUudGVtcGxhdGUpIHJlc3VsdCA9IHZhbHVlLnRlbXBsYXRlKHtcblx0ICAgICAgICB2YWx1ZTogcmVzdWx0XG5cdCAgICAgIH0pO1xuXHQgICAgICBub2RlLmZpcnN0Q2hpbGQuaW5uZXJIVE1MID0gcmVzdWx0O1xuXHQgICAgfSxcblx0ICAgIHRyYWNrQ2VsbHM6IHRydWUsXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uIChtYXN0ZXIsIGNvbmZpZykge1xuXHQgICAgICBpZiAoY29uZmlnLnRlbXBsYXRlKSBjb25maWcudGVtcGxhdGUgPSB0ZW1wbGF0ZShjb25maWcudGVtcGxhdGUpO1xuXHQgICAgICByZXR1cm4gXCJcIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIFwibWFzdGVyQ2hlY2tib3hcIjoge1xuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgc2V0VmFsdWU6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgZ2V0SGVscGVyOiBmdW5jdGlvbiAobm9kZSwgY29uZmlnKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgY2hlY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNvbmZpZy5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgICBub2RlLm9uY2xpY2soKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHVuY2hlY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGNvbmZpZy5jaGVja2VkID0gdHJ1ZTtcblx0ICAgICAgICAgIG5vZGUub25jbGljaygpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaXNDaGVja2VkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICByZXR1cm4gY29uZmlnLmNoZWNrZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfSxcblx0ICAgIHJlZnJlc2g6IGZ1bmN0aW9uIChtYXN0ZXIsIG5vZGUsIGNvbmZpZykge1xuXHQgICAgICBub2RlLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdLmNoZWNrZWQgPSBjb25maWcuY2hlY2tlZCA9ICFjb25maWcuY2hlY2tlZDtcblx0ICAgICAgICB2YXIgY29sdW1uID0gbWFzdGVyLmdldENvbHVtbkNvbmZpZyhjb25maWcuY29sdW1uSWQpO1xuXHQgICAgICAgIHZhciBjaGVja2VkID0gY29uZmlnLmNoZWNrZWQgPyBjb2x1bW4uY2hlY2tWYWx1ZSA6IGNvbHVtbi51bmNoZWNrVmFsdWU7XG5cdCAgICAgICAgbWFzdGVyLmRhdGEuZWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICBvYmpbY29uZmlnLmNvbHVtbklkXSA9IGNoZWNrZWQ7XG5cdCAgICAgICAgICBtYXN0ZXIuY2FsbEV2ZW50KFwib25DaGVja1wiLCBbb2JqLmlkLCBjb25maWcuY29sdW1uSWQsIGNoZWNrZWRdKTtcblx0ICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgW29iai5pZCwgb2JqLCBcInNhdmVcIl0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIG1hc3Rlci5yZWZyZXNoKCk7XG5cdCAgICAgIH07XG5cdCAgICB9LFxuXHQgICAgcmVuZGVyOiBmdW5jdGlvbiAobWFzdGVyLCBjb25maWcpIHtcblx0ICAgICAgcmV0dXJuIFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBcIiArIChjb25maWcuY2hlY2tlZCA/IFwiY2hlY2tlZD0nMSdcIiA6IFwiXCIpICsgXCI+XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBcInRleHRGaWx0ZXJcIjoge1xuXHQgICAgZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkID8gbm9kZS5maXJzdENoaWxkLmZpcnN0Q2hpbGQgOiB7XG5cdCAgICAgICAgdmFsdWU6IG51bGxcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXROb2RlKG5vZGUpLnZhbHVlO1xuXHQgICAgfSxcblx0ICAgIHNldFZhbHVlOiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcblx0ICAgICAgdGhpcy5nZXRJbnB1dE5vZGUobm9kZSkudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH0sXG5cdCAgICByZWZyZXNoOiBmdW5jdGlvbiAobWFzdGVyLCBub2RlLCB2YWx1ZSkge1xuXHQgICAgICBub2RlLmNvbXBvbmVudCA9IG1hc3Rlci5fc2V0dGluZ3MuaWQ7XG5cdCAgICAgIG1hc3Rlci5yZWdpc3RlckZpbHRlcihub2RlLCB2YWx1ZSwgdGhpcyk7XG5cdCAgICAgIG5vZGUuX2NvbXBfaWQgPSBtYXN0ZXIuX3NldHRpbmdzLmlkO1xuXHQgICAgICBpZiAodmFsdWUudmFsdWUgJiYgdGhpcy5nZXRWYWx1ZShub2RlKSAhPSB2YWx1ZS52YWx1ZSkgdGhpcy5zZXRWYWx1ZShub2RlLCB2YWx1ZS52YWx1ZSk7XG5cdCAgICAgIG5vZGUub25jbGljayA9IHByZXZlbnRFdmVudDtcblxuXHQgICAgICBfZXZlbnQobm9kZSwgXCJrZXlkb3duXCIsIHRoaXMuX29uX2tleV9kb3duKTtcblx0ICAgIH0sXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uIChtYXN0ZXIsIGNvbmZpZykge1xuXHQgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoY29uZmlnKTtcblx0ICAgICAgY29uZmlnLmNzcyA9IFwid2ViaXhfc3NfZmlsdGVyXCI7XG5cdCAgICAgIHJldHVybiBcIjxpbnB1dCBcIiArIChjb25maWcucGxhY2Vob2xkZXIgPyBcInBsYWNlaG9sZGVyPVxcXCJcIiArIGNvbmZpZy5wbGFjZWhvbGRlciArIFwiXFxcIiBcIiA6IFwiXCIpICsgXCJ0eXBlPSd0ZXh0Jz5cIjtcblx0ICAgIH0sXG5cdCAgICBfb25fa2V5X2Rvd246IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBpZCA9IHRoaXMuX2NvbXBfaWQ7IC8vdGFiYmluZyB0aHJvdWdoIGZpbHRlcnMgbXVzdCBub3QgdHJpZ2dlciBmaWx0ZXJpbmdcblx0ICAgICAgLy93ZSBjYW4gaW1wcm92ZSB0aGlzIGZ1bmN0aW9uYWxpdHkgYnkgcHJlc2VydmluZyBpbml0aWFsIGZpbHRlciB2YWx1ZVxuXHQgICAgICAvL2FuZCBjb21wYXJpbmcgbmV3IG9uZSB3aXRoIGl0XG5cblx0ICAgICAgaWYgKChlLndoaWNoIHx8IGUua2V5Q29kZSkgPT0gOSkgcmV0dXJuO1xuXHQgICAgICBpZiAodGhpcy5fZmlsdGVyX3RpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2ZpbHRlcl90aW1lcik7XG5cdCAgICAgIHRoaXMuX2ZpbHRlcl90aW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdWkkJDEgPSAkJChpZCk7IC8vZW5zdXJlIHRoYXQgdWkgaXMgbm90IGRlc3Ryb3llZCB5ZXRcblxuXHQgICAgICAgIGlmICh1aSQkMSkgdWkkJDEuZmlsdGVyQnlBbGwoKTtcblx0ICAgICAgfSwgZGF0YWZpbHRlci50ZXh0V2FpdERlbGF5KTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIFwic2VsZWN0RmlsdGVyXCI6IHtcblx0ICAgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgcmV0dXJuIG5vZGUuZmlyc3RDaGlsZCA/IG5vZGUuZmlyc3RDaGlsZC5maXJzdENoaWxkIDoge1xuXHQgICAgICAgIHZhbHVlOiBudWxsXG5cdCAgICAgIH07XG5cdCAgICB9LFxuXHQgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmdldElucHV0Tm9kZShub2RlKS52YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKG5vZGUpLnZhbHVlID0gdmFsdWU7XG5cdCAgICB9LFxuXHQgICAgcmVmcmVzaDogZnVuY3Rpb24gKG1hc3Rlciwgbm9kZSwgdmFsdWUpIHtcblx0ICAgICAgLy92YWx1ZSAtIGNvbmZpZyBmcm9tIGhlYWRlciB7IGNvbnRldDogfVxuXHQgICAgICB2YWx1ZS5jb21wYXJlID0gdmFsdWUuY29tcGFyZSB8fCBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhID09IGI7XG5cdCAgICAgIH07XG5cblx0ICAgICAgbm9kZS5jb21wb25lbnQgPSBtYXN0ZXIuX3NldHRpbmdzLmlkO1xuXHQgICAgICBtYXN0ZXIucmVnaXN0ZXJGaWx0ZXIobm9kZSwgdmFsdWUsIHRoaXMpO1xuXHQgICAgICB2YXIgZGF0YTtcblx0ICAgICAgdmFyIG9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuXG5cdCAgICAgIGlmIChvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgIGRhdGEgPSB2YWx1ZS5vcHRpb25zID0gW107XG5cdCAgICAgICAgICBhamF4KG9wdGlvbnMpLnRoZW4oYmluZChmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICB2YWx1ZS5vcHRpb25zID0gZGF0YS5qc29uKCk7XG5cdCAgICAgICAgICAgIHRoaXMucmVmcmVzaChtYXN0ZXIsIG5vZGUsIHZhbHVlKTtcblx0ICAgICAgICAgIH0sIHRoaXMpKTtcblx0ICAgICAgICB9IGVsc2UgZGF0YSA9IG9wdGlvbnM7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGF0YSA9IG1hc3Rlci5jb2xsZWN0VmFsdWVzKHZhbHVlLmNvbHVtbklkLCB2YWx1ZS5jb2xsZWN0KTtcblx0ICAgICAgICBkYXRhLnVuc2hpZnQoe1xuXHQgICAgICAgICAgaWQ6IFwiXCIsXG5cdCAgICAgICAgICB2YWx1ZTogXCJcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIG9wdHZpZXcgPSAkJChvcHRpb25zKTtcblxuXHQgICAgICBpZiAob3B0dmlldyAmJiBvcHR2aWV3LmRhdGEgJiYgb3B0dmlldy5kYXRhLmdldFJhbmdlKSB7XG5cdCAgICAgICAgZGF0YSA9IG9wdHZpZXcuZGF0YS5nZXRSYW5nZSgpO1xuXHQgICAgICB9IC8vc2xvdyBpbiBJRVxuXHQgICAgICAvL2h0dHA6Ly9qc3BlcmYuY29tL3NlbGVjdC1vcHRpb25zLXZzLWlubmVyaHRtbFxuXG5cblx0ICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG5cdCAgICAgICAgb3B0aW9uLnZhbHVlID0gZGF0YVtpXS5pZDtcblx0ICAgICAgICBvcHRpb24udGV4dCA9IGRhdGFbaV0udmFsdWU7XG5cdCAgICAgICAgc2VsZWN0LmFkZChvcHRpb24pO1xuXHQgICAgICB9XG5cblx0ICAgICAgbm9kZS5maXJzdENoaWxkLmlubmVySFRNTCA9IFwiXCI7XG5cdCAgICAgIG5vZGUuZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChzZWxlY3QpO1xuXHQgICAgICBpZiAodmFsdWUudmFsdWUpIHRoaXMuc2V0VmFsdWUobm9kZSwgdmFsdWUudmFsdWUpO1xuXHQgICAgICBub2RlLm9uY2xpY2sgPSBwcmV2ZW50RXZlbnQ7XG5cdCAgICAgIHNlbGVjdC5fY29tcF9pZCA9IG1hc3Rlci5fc2V0dGluZ3MuaWQ7XG5cblx0ICAgICAgX2V2ZW50KHNlbGVjdCwgXCJjaGFuZ2VcIiwgdGhpcy5fb25fY2hhbmdlKTtcblx0ICAgIH0sXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uIChtYXN0ZXIsIGNvbmZpZykge1xuXHQgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoY29uZmlnKTtcblx0ICAgICAgY29uZmlnLmNzcyA9IFwid2ViaXhfc3NfZmlsdGVyXCI7XG5cdCAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgfSxcblx0ICAgIF9vbl9jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgJCQodGhpcy5fY29tcF9pZCkuZmlsdGVyQnlBbGwoKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdGRhdGFmaWx0ZXIuc2VydmVyRmlsdGVyID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgICRzZXJ2ZXI6IHRydWUsXG5cdCAgX29uX2tleV9kb3duOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIGlkID0gdGhpcy5fY29tcF9pZCxcblx0ICAgICAgICBjb2RlID0gZS53aGljaCB8fCBlLmtleUNvZGU7IC8vaWdub3JlIHRhYiBhbmQgbmF2aWdhdGlvbiBrZXlzXG5cblx0ICAgIGlmIChjb2RlID09IDkgfHwgY29kZSA+PSAzMyAmJiBjb2RlIDw9IDQwKSByZXR1cm47XG5cdCAgICBpZiAodGhpcy5fZmlsdGVyX3RpbWVyKSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2ZpbHRlcl90aW1lcik7XG5cdCAgICB0aGlzLl9maWx0ZXJfdGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICQkKGlkKS5maWx0ZXJCeUFsbCgpO1xuXHQgICAgfSwgZGF0YWZpbHRlci50ZXh0V2FpdERlbGF5KTtcblx0ICB9XG5cdH0sIGRhdGFmaWx0ZXIudGV4dEZpbHRlcik7XG5cdGRhdGFmaWx0ZXIuc2VydmVyU2VsZWN0RmlsdGVyID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgICRzZXJ2ZXI6IHRydWUsXG5cdCAgX29uX2NoYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGlkID0gdGhpcy5fY29tcF9pZDtcblx0ICAgICQkKGlkKS5maWx0ZXJCeUFsbCgpO1xuXHQgIH1cblx0fSwgZGF0YWZpbHRlci5zZWxlY3RGaWx0ZXIpO1xuXHRkYXRhZmlsdGVyLm51bWJlckZpbHRlciA9IGV4cG9ydHMuZXh0ZW5kKHtcblx0ICBpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBjb25maWcucHJlcGFyZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICAgIHZhciBlcXVhbGl0eSA9IHZhbHVlLmluZGV4T2YoXCI9XCIpICE9IC0xO1xuXHQgICAgICB2YXIgaW50dmFsdWUgPSB0aGlzLmZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgIGlmIChpbnR2YWx1ZSA9PT0gXCJcIikgcmV0dXJuIFwiXCI7XG5cdCAgICAgIHZhciBjb21wYXJlO1xuXG5cdCAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiPlwiKSAhPSAtMSkge1xuXHQgICAgICAgIGNvbXBhcmUgPSB0aGlzLl9ncmVhdGVyO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoXCI8XCIpICE9IC0xKSB7XG5cdCAgICAgICAgY29tcGFyZSA9IHRoaXMuX2xlc3Nlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjb21wYXJlICYmIGVxdWFsaXR5KSB7XG5cdCAgICAgICAgY29uZmlnLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgICAgcmV0dXJuIF90aGlzLl9lcXVhbChhLCBiKSB8fCBjb21wYXJlKGEsIGIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29uZmlnLmNvbXBhcmUgPSBjb21wYXJlIHx8IHRoaXMuX2VxdWFsO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGludHZhbHVlO1xuXHQgICAgfTtcblx0ICB9LFxuXHQgIGZvcm1hdDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvW15cXC0uMC05XS9nLCBcIlwiKTtcblx0ICB9LFxuXHQgIF9ncmVhdGVyOiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgcmV0dXJuIGEgKiAxID4gYjtcblx0ICB9LFxuXHQgIF9sZXNzZXI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAhPT0gXCJcIiAmJiBhICogMSA8IGI7XG5cdCAgfSxcblx0ICBfZXF1YWw6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAhPT0gXCJcIiAmJiBhICogMSA9PSBiO1xuXHQgIH1cblx0fSwgZGF0YWZpbHRlci50ZXh0RmlsdGVyKTtcblx0ZGF0YWZpbHRlci5kYXRlRmlsdGVyID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgIGZvcm1hdDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiXCIpIHJldHVybiBcIlwiO1xuXHQgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG5cdCAgICBpZiAodmFsdWUuaW5kZXhPZihcInRvZGF5XCIpICE9IC0xKSB7XG5cdCAgICAgIGRhdGUgPSB3RGF0ZS5kYXlTdGFydChkYXRlKTtcblx0ICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZihcIm5vd1wiKSA9PSAtMSkge1xuXHQgICAgICB2YXIgcGFydHMgPSB2YWx1ZS5tYXRjaCgvWzAtOV0rL2cpO1xuXHQgICAgICBpZiAoIXBhcnRzIHx8ICFwYXJ0cy5sZW5ndGgpIHJldHVybiBcIlwiO1xuXG5cdCAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAzKSB7XG5cdCAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuXHQgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShwYXJ0c1swXSwgKHBhcnRzWzFdIHx8IDEpIC0gMSwgMSk7XG5cdCAgICAgIH0gZWxzZSBkYXRlID0gaTE4bi5kYXRlRm9ybWF0RGF0ZSh2YWx1ZS5yZXBsYWNlKC9eWz48ID1dKy8sIFwiXCIpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGRhdGUudmFsdWVPZigpO1xuXHQgIH1cblx0fSwgZGF0YWZpbHRlci5udW1iZXJGaWx0ZXIpO1xuXG5cdGVudi5zY3JvbGxTaXplID0gZW52LnRvdWNoIHx8IGVudi4kY3VzdG9tU2Nyb2xsID8gMCA6IDE3O1xuXHRyZWFkeShmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNpemUgPSBfZGV0ZWN0U2Nyb2xsU2l6ZSgpO1xuXG5cdCAgZW52LnNjcm9sbFNpemUgPSBlbnYudG91Y2ggPyAwIDogc2l6ZTtcblx0fSk7XG5cblx0ZnVuY3Rpb24gX2RldGVjdFNjcm9sbFNpemUoKSB7XG5cdCAgdmFyIGRpdiA9IGNyZWF0ZShcImRpdlwiKTtcblx0ICBkaXYuY2xhc3NOYW1lID0gXCJ3ZWJpeF9za2luX21hcmtcIjtcblx0ICBkaXYuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwMHB4O3dpZHRoOjEwMHB4O3BhZGRpbmc6MHB4O21hcmdpbjowcHg7bWluLWhlaWdodDoxMDBweDtvdmVyZmxvdy15OnNjcm9sbDtcIjtcblx0ICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cdCAgdmFyIHdpZHRoID0gZGl2Lm9mZnNldFdpZHRoIC0gZGl2LmNsaWVudFdpZHRoO1xuXHQgIHZhciBuYW1lID0ge1xuXHQgICAgMjAwOiBcImZsYXRcIixcblx0ICAgIDIxMDogXCJjb21wYWN0XCIsXG5cdCAgICAyMzA6IFwiY29udHJhc3RcIixcblx0ICAgIDI0MDogXCJtYXRlcmlhbFwiLFxuXHQgICAgMjUwOiBcIm1pbmlcIlxuXHQgIH1bTWF0aC5mbG9vcihkaXYub2Zmc2V0SGVpZ2h0IC8gMTApICogMTBdO1xuXHQgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblx0ICBpZiAobmFtZSkgc2V0JDEobmFtZSk7XG5cdCAgaWYgKGVudi4kY3VzdG9tU2Nyb2xsKSByZXR1cm4gMDtcblx0ICByZXR1cm4gd2lkdGg7XG5cdH1cblxuXHR2YXIgZml4ZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBfZml4SGVpZ2h0KCkge1xuXHQgIGlmIChmaXhlZCkgcmV0dXJuO1xuXHQgIGFkZFN0eWxlKFwiaHRtbCwgYm9keXsgaGVpZ2h0OjEwMCU7IH1cIik7XG5cdCAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUgKz0gXCIgd2ViaXhfZnVsbF9zY3JlZW5cIjtcblx0ICBUb3VjaC5saW1pdChmYWxzZSk7XG5cdCAgZml4ZWQgPSB0cnVlO1xuXHR9XG5cblx0ZGVmaW5lKFwiX2ZpeEhlaWdodFwiLCBfZml4SGVpZ2h0KTtcblxuXHR1aS5hbmltYXRlID0gYW5pbWF0ZSQxO1xuXHR1aS5hbmltYXRlVmlldyA9IGFuaW1hdGVWaWV3O1xuXHR1aS5mcmVlemUgPSBmcmVlemU7XG5cdHVpLnJlc2l6ZSA9IHJlc2l6ZTtcblx0dWkuZWFjaCA9IGVhY2g7XG5cdHVpLmhhc01ldGhvZCA9IGhhc01ldGhvZDtcblx0dWkuZGF0YWZpbHRlciA9IGRhdGFmaWx0ZXI7XG5cdHVpLmZ1bGxTY3JlZW4gPSBmdWxsU2NyZWVuO1xuXG5cdC8qR2VybWFuIChHZXJtYW55KSBsb2NhbGUqL1xuXHR2YXIgZGUgPSB7XG5cdCAgZ3JvdXBEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgIGdyb3VwU2l6ZTogMyxcblx0ICBkZWNpbWFsRGVsaW1pdGVyOiBcIixcIixcblx0ICBkZWNpbWFsU2l6ZTogMixcblx0ICBkYXRlRm9ybWF0OiBcIiVkLiVuLiVZXCIsXG5cdCAgdGltZUZvcm1hdDogXCIlSDolaVwiLFxuXHQgIGxvbmdEYXRlRm9ybWF0OiBcIiVqLiAlRiAlWVwiLFxuXHQgIGZ1bGxEYXRlRm9ybWF0OiBcIiVqLiAlRiAlWSAlSDolaVwiLFxuXHQgIGFtOiBudWxsLFxuXHQgIHBtOiBudWxsLFxuXHQgIHByaWNlOiBcIntvYmp9IOKCrFwiLFxuXHQgIHByaWNlU2V0dGluZ3M6IHtcblx0ICAgIGdyb3VwRGVsaW1pdGVyOiBcIi5cIixcblx0ICAgIGdyb3VwU2l6ZTogMyxcblx0ICAgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLFwiLFxuXHQgICAgZGVjaW1hbFNpemU6IDJcblx0ICB9LFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICBtb250aEZ1bGw6IFtcIkphbnVhclwiLCBcIkZlYnJ1YXJcIiwgXCJNw6RyelwiLCBcIkFwcmlsXCIsIFwiTWFpXCIsIFwiSnVuaVwiLCBcIkp1bGlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZXplbWJlclwiXSxcblx0ICAgIG1vbnRoU2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1yelwiLCBcIkFwclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9rdFwiLCBcIk5vdlwiLCBcIkRlelwiXSxcblx0ICAgIGRheUZ1bGw6IFtcIlNvbm50YWdcIiwgXCJNb250YWdcIiwgXCJEaWVuc3RhZ1wiLCBcIk1pdHR3b2NoXCIsIFwiRG9ubmVyc3RhZ1wiLCBcIkZyZWl0YWdcIiwgXCJTYW1zdGFnXCJdLFxuXHQgICAgZGF5U2hvcnQ6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuXHQgICAgaG91cnM6IFwiU3R1bmRlblwiLFxuXHQgICAgbWludXRlczogXCJNaW51dGVuXCIsXG5cdCAgICBkb25lOiBcIkZlcnRpZ1wiLFxuXHQgICAgY2xlYXI6IFwiRW50ZmVybmVuXCIsXG5cdCAgICB0b2RheTogXCJIZXV0ZVwiXG5cdCAgfSxcblx0ICBkYXRhRXhwb3J0OiB7XG5cdCAgICBwYWdlOiBcIlNlaXRlXCIsXG5cdCAgICBvZjogXCJhdXNcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCJhdXNcIixcblx0ICAgIGF1dG9tYXRpY1pvb206IFwiQXV0b21hdGlzY2ggWm9vbVwiLFxuXHQgICAgYWN0dWFsU2l6ZTogXCJBa3R1ZWxsZXMgQXVzbWHDn1wiLFxuXHQgICAgcGFnZUZpdDogXCJTZWl0ZSBBdXNtYcOfXCIsXG5cdCAgICBwYWdlV2lkdGg6IFwiU2VpdGUgQnJlaXRlXCIsXG5cdCAgICBwYWdlSGVpZ2h0OiBcIlNlaXRlIEjDtmhlXCIsXG5cdCAgICBlbnRlclBhc3N3b3JkOiBcIlBhc3N3b3J0IGVpbmdlYmVuXCIsXG5cdCAgICBwYXNzd29yZEVycm9yOiBcIkZhbHNjaGVzIHBhc3N3b3J0XCJcblx0ICB9LFxuXHQgIGFyaWE6IHtcblx0ICAgIGNhbGVuZGFyOiBcIkthbGVuZGVyXCIsXG5cdCAgICBpbmNyZWFzZVZhbHVlOiBcIldlcnQgZXJow7ZoZW5cIixcblx0ICAgIGRlY3JlYXNlVmFsdWU6IFwiV2VydCB2ZXJyaW5nZXJuXCIsXG5cdCAgICBuYXZNb250aDogW1wiVm9yaGVyaWdlciBNb25hdFwiLCBcIk7DpGNoc3RlbiBNb25hdFwiXSxcblx0ICAgIG5hdlllYXI6IFtcIlZvcmhlcmlnZXMgSmFoclwiLCBcIk7DpGNoc3RlcyBKYWhyXCJdLFxuXHQgICAgbmF2RGVjYWRlOiBbXCJadXLDvGNrIEphaHJ6ZWhudFwiLCBcIkFscyBuw6RjaHN0ZXMgSmFocnplaG50XCJdLFxuXHQgICAgZGF0ZUZvcm1hdDogXCIlai4gJUYgJVlcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVGICVZXCIsXG5cdCAgICB5ZWFyRm9ybWF0OiBcIiVZXCIsXG5cdCAgICBob3VyRm9ybWF0OiBcIlN0dW5kZW46ICVIXCIsXG5cdCAgICBtaW51dGVGb3JtYXQ6IFwiTWludXRlbjogJWlcIixcblx0ICAgIHJlbW92ZUl0ZW06IFwiRWxlbWVudCBlbnRmZXJuZW5cIixcblx0ICAgIHBhZ2VzOiBbXCJFcnN0ZSBTZWl0ZVwiLCBcIlZvcmhlcmlnZSBTZWl0ZVwiLCBcIkZvbGdlc2VpdGVcIiwgXCJMZXR6dGUgU2VpdGVcIl0sXG5cdCAgICBwYWdlOiBcIlNlaXRlXCIsXG5cdCAgICBoZWFkZXJtZW51OiBcIlRpdGVsbWVuw7xcIixcblx0ICAgIG9wZW5Hcm91cDogXCLDlmZmbmVuIFNwYWx0ZW5ncnVwcGUgXCIsXG5cdCAgICBjbG9zZUdyb3VwOiBcIlNjaGxpZcOfZW4gU3BhbHRlbmdydXBwZSBcIixcblx0ICAgIGNsb3NlVGFiOiBcIlRhYiBzY2hsaWXDn2VuXCIsXG5cdCAgICBzaG93VGFiczogXCJXZWl0ZXJlIFRhYnNcIixcblx0ICAgIHJlc2V0VHJlZU1hcDogXCJadXLDvGNrIHp1ciB1cnNwcsO8bmdsaWNoZW4gQW5zaWNodFwiLFxuXHQgICAgbmF2VHJlZU1hcDogXCJBdWZsZXZlbG5cIixcblx0ICAgIG5leHRUYWI6IFwiV2VpdGVyIHRhYlwiLFxuXHQgICAgcHJldlRhYjogXCJadXLDvGNrIHRhYlwiLFxuXHQgICAgbXVsdGl0ZXh0U2VjdGlvbjogXCJFbGVtZW50IGhpbnp1ZsO8Z2VuXCIsXG5cdCAgICBtdWx0aXRleHRleHRyYVNlY3Rpb246IFwiRWxlbWVudCBlbnRmZXJuZW5cIixcblx0ICAgIHNob3dDaGFydDogXCJDaGFydCBhbnplaWdlblwiLFxuXHQgICAgaGlkZUNoYXJ0OiBcIkNoYXJ0IHZlcnN0ZWNrZW5cIixcblx0ICAgIHJlc2l6ZUNoYXJ0OiBcIkNoYXJ0IEdyw7bDn2Ugw6RuZGVyblwiXG5cdCAgfSxcblx0ICByaWNodGV4dDoge1xuXHQgICAgdW5kZXJsaW5lOiBcIlVudGVyc3RyZWljaGVuXCIsXG5cdCAgICBib2xkOiBcIkZldHRnZWRydWNrdFwiLFxuXHQgICAgaXRhbGljOiBcIkt1cnNpdlwiXG5cdCAgfSxcblx0ICBjb21ibzoge1xuXHQgICAgc2VsZWN0OiBcIkF1c3fDpGhsZW5cIixcblx0ICAgIHNlbGVjdEFsbDogXCJBbGxlcyBhdXN3w6RobGVuXCIsXG5cdCAgICB1bnNlbGVjdEFsbDogXCJBbGxlcyB3aWRlcnJ1ZmVuXCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcIk9LXCIsXG5cdCAgICBjYW5jZWw6IFwiQWJicmVjaGVuXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcIkFic2VuZGVuXCIsXG5cdCAgICBjb25maXJtTWVzc2FnZTogXCJEZXIgS29tbWVudGFyIHdpcmQgZW50ZmVybnQuIFNpbmQgU2llIHNpY2hlcj9cIixcblx0ICAgIGVkaXQ6IFwiUmVkaWdpZXJlblwiLFxuXHQgICAgcmVtb3ZlOiBcIkzDtnNjaGVuXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJHZWJlbiBTaWUgaGllciBlaW4uLlwiLFxuXHQgICAgbW9yZUNvbW1lbnRzOiBcIk1laHIgS29tbWVudGFyZVwiXG5cdCAgfVxuXHR9O1xuXG5cdC8qU3BhbmlzaCAoU3BhaW4sIEludGVybmF0aW9uYWwgU29ydCkgbG9jYWxlKi9cblx0dmFyIGVzID0ge1xuXHQgIGdyb3VwRGVsaW1pdGVyOiBcIi5cIixcblx0ICBncm91cFNpemU6IDMsXG5cdCAgZGVjaW1hbERlbGltaXRlcjogXCIsXCIsXG5cdCAgZGVjaW1hbFNpemU6IDIsXG5cdCAgZGF0ZUZvcm1hdDogXCIlZC8lbi8lWVwiLFxuXHQgIHRpbWVGb3JtYXQ6IFwiJUc6JWlcIixcblx0ICBsb25nRGF0ZUZvcm1hdDogXCIlZCAlRiAlWVwiLFxuXHQgIGZ1bGxEYXRlRm9ybWF0OiBcIiVkICVGICVZICVHOiVpXCIsXG5cdCAgYW06IG51bGwsXG5cdCAgcG06IG51bGwsXG5cdCAgcHJpY2U6IFwie29ian0g4oKsXCIsXG5cdCAgcHJpY2VTZXR0aW5nczoge1xuXHQgICAgZ3JvdXBEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgICAgZ3JvdXBTaXplOiAzLFxuXHQgICAgZGVjaW1hbERlbGltaXRlcjogXCIsXCIsXG5cdCAgICBkZWNpbWFsU2l6ZTogMlxuXHQgIH0sXG5cdCAgY2FsZW5kYXI6IHtcblx0ICAgIG1vbnRoRnVsbDogW1wiZW5lcm9cIiwgXCJmZWJyZXJvXCIsIFwibWFyem9cIiwgXCJhYnJpbFwiLCBcIm1heW9cIiwgXCJqdW5pb1wiLCBcImp1bGlvXCIsIFwiYWdvc3RvXCIsIFwic2VwdGllbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZpZW1icmVcIiwgXCJkaWNpZW1icmVcIl0sXG5cdCAgICBtb250aFNob3J0OiBbXCJlbmVcIiwgXCJmZWJcIiwgXCJtYXJcIiwgXCJhYnJcIiwgXCJtYXlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhZ29cIiwgXCJzZXBcIiwgXCJvY3RcIiwgXCJub3ZcIiwgXCJkaWNcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCJkb21pbmdvXCIsIFwibHVuZXNcIiwgXCJtYXJ0ZXNcIiwgXCJtacOpcmNvbGVzXCIsIFwianVldmVzXCIsIFwidmllcm5lc1wiLCBcInPDoWJhZG9cIl0sXG5cdCAgICBkYXlTaG9ydDogW1wiZG9tXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWnDqVwiLCBcImp1ZVwiLCBcInZpZVwiLCBcInPDoWJcIl0sXG5cdCAgICBob3VyczogXCJIb3Jhc1wiLFxuXHQgICAgbWludXRlczogXCJNaW51dG9zXCIsXG5cdCAgICBkb25lOiBcIkxpc3RvXCIsXG5cdCAgICBjbGVhcjogXCJSZWluaWNpb1wiLFxuXHQgICAgdG9kYXk6IFwiSG95XCJcblx0ICB9LFxuXHQgIGRhdGFFeHBvcnQ6IHtcblx0ICAgIHBhZ2U6IFwiUMOhZ2luYVwiLFxuXHQgICAgb2Y6IFwiZGVcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCJkZVwiLFxuXHQgICAgYXV0b21hdGljWm9vbTogXCJab29tIGF1dG9tw6F0aWNvXCIsXG5cdCAgICBhY3R1YWxTaXplOiBcIlRhbWHDsW8gcmVhbFwiLFxuXHQgICAgcGFnZUZpdDogXCJUYW1hw7FvIGRlIHDDoWdpbmFcIixcblx0ICAgIHBhZ2VXaWR0aDogXCJBbmNobyBkZSBww6FnaW5hXCIsXG5cdCAgICBwYWdlSGVpZ2h0OiBcIkFsdHVyYSBkZSBsYSBww6FnaW5hXCIsXG5cdCAgICBlbnRlclBhc3N3b3JkOiBcIkludHJvZHV6Y2EgbGEgY29udHJhc2XDsWFcIixcblx0ICAgIHBhc3N3b3JkRXJyb3I6IFwiQ29udHJhc2XDsWEgaW5jb3JyZWN0YVwiXG5cdCAgfSxcblx0ICBhcmlhOiB7XG5cdCAgICBjYWxlbmRhcjogXCLQoWFsZW5kYXJpb1wiLFxuXHQgICAgaW5jcmVhc2VWYWx1ZTogXCJBdW1lbnRhciBlbCB2YWxvclwiLFxuXHQgICAgZGVjcmVhc2VWYWx1ZTogXCJEaXNtaW51eWUgZWwgdmFsb3JcIixcblx0ICAgIG5hdk1vbnRoOiBbXCJNZXMgYW50ZXJpb3JcIiwgXCJQcsOzeGltbyBtZXNcIl0sXG5cdCAgICBuYXZZZWFyOiBbXCJBw7FvIGFudGVyaW9yXCIsIFwiUHLDs3hpbW8gYcOxb1wiXSxcblx0ICAgIG5hdkRlY2FkZTogW1wiRMOpY2FkYSBhbnRlcmlvclwiLCBcIlByw7N4aW1hIGTDqWNhZGFcIl0sXG5cdCAgICBkYXRlRm9ybWF0OiBcIiVkICVGICVZXCIsXG5cdCAgICBtb250aEZvcm1hdDogXCIlRiAlWVwiLFxuXHQgICAgeWVhckZvcm1hdDogXCIlWVwiLFxuXHQgICAgaG91ckZvcm1hdDogXCJIb3JhczogJUdcIixcblx0ICAgIG1pbnV0ZUZvcm1hdDogXCJNaW51dG9zOiAlaVwiLFxuXHQgICAgcmVtb3ZlSXRlbTogXCJSZXRpcmUgZWwgZWxlbWVudG9cIixcblx0ICAgIHBhZ2VzOiBbXCJQcmltZXJhIHDDoWdpbmFcIiwgXCJQYWdpbmEgYW50ZXJpb3JcIiwgXCJTaWd1aWVudGUgcMOhZ2luYVwiLCBcIsOabHRpbWEgcMOhZ2luYVwiXSxcblx0ICAgIHBhZ2U6IFwiUMOhZ2luYVwiLFxuXHQgICAgaGVhZGVybWVudTogXCJNZW7DuiBkZSB0w610dWxvc1wiLFxuXHQgICAgb3Blbkdyb3VwOiBcIkdydXBvIGRlIGNvbHVtbmFzIGFiaWVydGFzXCIsXG5cdCAgICBjbG9zZUdyb3VwOiBcIlByaW1lciBncnVwbyBkZSBjb2x1bW5hc1wiLFxuXHQgICAgY2xvc2VUYWI6IFwiQ2VycmFyIHRhYlwiLFxuXHQgICAgc2hvd1RhYnM6IFwiTW9zdHJhciBtw6FzIHRhYnNcIixcblx0ICAgIHJlc2V0VHJlZU1hcDogXCJWb2x2ZXIgYSBsYSB2aXN0YSBvcmlnaW5hbFwiLFxuXHQgICAgbmF2VHJlZU1hcDogXCJFbGV2YXIgYSBtaXNtbyBuaXZlbFwiLFxuXHQgICAgbmV4dFRhYjogXCJTaWd1aWVudGUgdGFiXCIsXG5cdCAgICBwcmV2VGFiOiBcIlRhYiBhbnRlcmlvclwiLFxuXHQgICAgbXVsdGl0ZXh0U2VjdGlvbjogXCJBw7FhZGlyIGVsZW1lbnRvXCIsXG5cdCAgICBtdWx0aXRleHRleHRyYVNlY3Rpb246IFwiUmV0aXJlIGVsIGVsZW1lbnRvXCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwiRXNwZWN0w6FjdWxvIGNoYXJ0XCIsXG5cdCAgICBoaWRlQ2hhcnQ6IFwiRXNjb25kZXIgY2hhcnRcIixcblx0ICAgIHJlc2l6ZUNoYXJ0OiBcIkNhbWJpYXIgZWwgdGFtYcOxbyBlbCBjaGFydFwiXG5cdCAgfSxcblx0ICByaWNodGV4dDoge1xuXHQgICAgdW5kZXJsaW5lOiBcIlN1YnJheWFyXCIsXG5cdCAgICBib2xkOiBcIk5lZ3JpdGFcIixcblx0ICAgIGl0YWxpYzogXCJJdMOhbGljb1wiXG5cdCAgfSxcblx0ICBjb21ibzoge1xuXHQgICAgc2VsZWN0OiBcIlNlbGVjY2lvbmFyXCIsXG5cdCAgICBzZWxlY3RBbGw6IFwiU2VsZWNjaW9uYXIgdG9kb1wiLFxuXHQgICAgdW5zZWxlY3RBbGw6IFwiRGVzZWxlY2Npb25hIHRvZG9cIlxuXHQgIH0sXG5cdCAgbWVzc2FnZToge1xuXHQgICAgb2s6IFwiT0tcIixcblx0ICAgIGNhbmNlbDogXCJDYW5jZWxhclwiXG5cdCAgfSxcblx0ICBjb21tZW50czoge1xuXHQgICAgc2VuZDogXCJFbnZpYXJcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcIkVsIGNvbWVudGFyaW8gc2Vyw6EgZWxpbWluYWRvLiBFc3TDoXMgc2VndXJvP1wiLFxuXHQgICAgZWRpdDogXCJDb3JyZWdpclwiLFxuXHQgICAgcmVtb3ZlOiBcIlN1cHJpbWlyXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJFc2NyaWJhIGFxdcOtLi5cIixcblx0ICAgIG1vcmVDb21tZW50czogXCJNw6FzIGNvbWVudGFyaW9zXCJcblx0ICB9XG5cdH07XG5cblx0dmFyIGZyID0ge1xuXHQgIGdyb3VwRGVsaW1pdGVyOiBcIiBcIixcblx0ICBncm91cFNpemU6IDMsXG5cdCAgZGVjaW1hbERlbGltaXRlcjogXCIsXCIsXG5cdCAgZGVjaW1hbFNpemU6IDIsXG5cdCAgZGF0ZUZvcm1hdDogXCIlZC8lbS8lWVwiLFxuXHQgIHRpbWVGb3JtYXQ6IFwiJUg6JWlcIixcblx0ICBsb25nRGF0ZUZvcm1hdDogXCIlZCAlRiAlWVwiLFxuXHQgIGZ1bGxEYXRlRm9ybWF0OiBcIiVkLiVtLiVZICVIOiVpXCIsXG5cdCAgcHJpY2U6IFwie29ian0g4oKsXCIsXG5cdCAgcHJpY2VTZXR0aW5nczogbnVsbCxcblx0ICAvL3VzZSBudW1iZXIgZGVmYXVsdHNcblx0ICBjYWxlbmRhcjoge1xuXHQgICAgbW9udGhGdWxsOiBbXCJKYW52aWVyXCIsIFwiRsOpdnJpZXJcIiwgXCJNYXJzXCIsIFwiQXZyaWxcIiwgXCJNYWlcIiwgXCJKdWluXCIsIFwiSnVpbGxldFwiLCBcIkFvw7t0XCIsIFwiU2VwdGVtYnJlXCIsIFwiT2N0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRMOpY2VtYnJlXCJdLFxuXHQgICAgbW9udGhTaG9ydDogW1wiSmFuXCIsIFwiRsOpdlwiLCBcIk1hclwiLCBcIkF2clwiLCBcIk1haVwiLCBcIkp1aW5cIiwgXCJKdWlsXCIsIFwiQcO0dVwiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkTDqWNcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCJEaW1hbmNoZVwiLCBcIkx1bmRpXCIsIFwiTWFyZGlcIiwgXCJNZXJjcmVkaVwiLCBcIkpldWRpXCIsIFwiVmVuZHJlZGlcIiwgXCJTYW1lZGlcIl0sXG5cdCAgICBkYXlTaG9ydDogW1wiRGltXCIsIFwiTHVuXCIsIFwiTWFyXCIsIFwiTWVyXCIsIFwiSmV1XCIsIFwiVmVuXCIsIFwiU2FtXCJdLFxuXHQgICAgaG91cnM6IFwiSGV1cmVzXCIsXG5cdCAgICBtaW51dGVzOiBcIk1pbnV0ZXNcIixcblx0ICAgIGRvbmU6IFwiRmluaVwiLFxuXHQgICAgY2xlYXI6IFwiRWZmYWNlclwiLFxuXHQgICAgdG9kYXk6IFwiQXVqb3VyZCdodWlcIlxuXHQgIH0sXG5cdCAgZGF0YUV4cG9ydDoge1xuXHQgICAgcGFnZTogXCJQYWdlXCIsXG5cdCAgICBvZjogXCJzdXJcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCJzdXJcIixcblx0ICAgIGF1dG9tYXRpY1pvb206IFwiWm9vbSBhdXRvbWF0aXF1ZVwiLFxuXHQgICAgYWN0dWFsU2l6ZTogXCJUYWlsbGUgYWN0dWVsbGVcIixcblx0ICAgIHBhZ2VGaXQ6IFwiVGFpbGxlIGRlIGxhIHBhZ2VcIixcblx0ICAgIHBhZ2VXaWR0aDogXCJMYXJnZXVyIGRlIGxhIHBhZ2VcIixcblx0ICAgIHBhZ2VIZWlnaHQ6IFwiSGF1dGV1ciBkZSBwYWdlXCIsXG5cdCAgICBlbnRlclBhc3N3b3JkOiBcIkVudHJleiBsZSBtb3QgZGUgcGFzc2VcIixcblx0ICAgIHBhc3N3b3JkRXJyb3I6IFwiTWF1dmFpcyBtb3QgZGUgcGFzc2VcIlxuXHQgIH0sXG5cdCAgYXJpYToge1xuXHQgICAgY2FsZW5kYXI6IFwi0KFhbGVuZHJpZXJcIixcblx0ICAgIGluY3JlYXNlVmFsdWU6IFwiQXVnbWVudGVyIGxhIHZhbGV1clwiLFxuXHQgICAgZGVjcmVhc2VWYWx1ZTogXCJEaW1pbnV0aW9uIGRlIGxhIHZhbGV1clwiLFxuXHQgICAgbmF2TW9udGg6IFtcIkxlIG1vaXMgcHLDqWPDqWRlbnRcIiwgXCJMZSBtb2lzIHByb2NoYWluXCJdLFxuXHQgICAgbmF2WWVhcjogW1wiQW5uw6llIHByw6ljw6lkZW50ZVwiLCBcIkwnYW5uw6llIHByb2NoYWluZVwiXSxcblx0ICAgIG5hdkRlY2FkZTogW1wiRMOpY2VubmllIHByw6ljw6lkZW50ZVwiLCBcIlN1aXZhbnQgZMOpY2VubmllXCJdLFxuXHQgICAgZGF0ZUZvcm1hdDogXCIlZCAlRiAlWVwiLFxuXHQgICAgbW9udGhGb3JtYXQ6IFwiJUYgJVlcIixcblx0ICAgIHllYXJGb3JtYXQ6IFwiJVlcIixcblx0ICAgIGhvdXJGb3JtYXQ6IFwiSGV1cmVzOiAlSFwiLFxuXHQgICAgbWludXRlRm9ybWF0OiBcIk1pbnV0ZXM6ICVpXCIsXG5cdCAgICByZW1vdmVJdGVtOiBcIlJldGlyZXIgbCfDqWzDqW1lbnRcIixcblx0ICAgIHBhZ2VzOiBbXCJQcmVtacOocmUgcGFnZVwiLCBcIlBhZ2UgcHLDqWPDqWRlbnRlXCIsIFwiUGFnZSBzdWl2YW50ZVwiLCBcIkRlcm5pw6hyZSBwYWdlXCJdLFxuXHQgICAgcGFnZTogXCJQYWdlXCIsXG5cdCAgICBoZWFkZXJtZW51OiBcIk1lbnUgZGUgdGl0cmVcIixcblx0ICAgIG9wZW5Hcm91cDogXCJPdXZyaXIgZ3JvdXBlIGRlIGNvbG9ubmVzIFwiLFxuXHQgICAgY2xvc2VHcm91cDogXCJGZXJtZXIgZ3JvdXBlIGRlIGNvbG9ubmVzXCIsXG5cdCAgICBjbG9zZVRhYjogXCJGZXJtZXIgdGFiXCIsXG5cdCAgICBzaG93VGFiczogXCJNb250cmVyIHBsdXMgdGFic1wiLFxuXHQgICAgcmVzZXRUcmVlTWFwOiBcIlJldmVuaXIgw6AgbGEgdnVlIG9yaWdpbmFsZVwiLFxuXHQgICAgbmF2VHJlZU1hcDogXCJOaXZlYXUgc3Vww6lyaWV1clwiLFxuXHQgICAgbmV4dFRhYjogXCJQcm9jaGFpbiB0YWJcIixcblx0ICAgIHByZXZUYWI6IFwiUHLDqWPDqWRlbnQgdGFiXCIsXG5cdCAgICBtdWx0aXRleHRTZWN0aW9uOiBcIkFqb3V0ZXIgbCfDqWzDqW1lbnRcIixcblx0ICAgIG11bHRpdGV4dGV4dHJhU2VjdGlvbjogXCJSZXRpcmVyIGwnw6lsw6ltZW50XCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwiTW9udHJlciBjaGFydFwiLFxuXHQgICAgaGlkZUNoYXJ0OiBcIkNhY2hlciBjaGFydFwiLFxuXHQgICAgcmVzaXplQ2hhcnQ6IFwiUmVkaW1lbnNpb25uZXIgY2hhcnRcIlxuXHQgIH0sXG5cdCAgcmljaHRleHQ6IHtcblx0ICAgIHVuZGVybGluZTogXCJTb3VsaWduZXJcIixcblx0ICAgIGJvbGQ6IFwiR3Jhc1wiLFxuXHQgICAgaXRhbGljOiBcIkl0YWxpcXVlXCJcblx0ICB9LFxuXHQgIGNvbWJvOiB7XG5cdCAgICBzZWxlY3Q6IFwiU8OpbGVjdGlvbm5lclwiLFxuXHQgICAgc2VsZWN0QWxsOiBcIlRvdXQgc8OpbGVjdGlvbm5lclwiLFxuXHQgICAgdW5zZWxlY3RBbGw6IFwiVG91dCBkw6lzZWxlY3Rpb25uZXJcIlxuXHQgIH0sXG5cdCAgbWVzc2FnZToge1xuXHQgICAgb2s6IFwiT0tcIixcblx0ICAgIGNhbmNlbDogXCJBbm51bGVyXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcIkVudm95ZXJcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcIkxlIGNvbW1lbnRhaXJlIHNlcmEgc3VwcHJpbcOpLiDDinRlcy12b3VzIHPDu3I/XCIsXG5cdCAgICBlZGl0OiBcIk1vZGlmaWVyXCIsXG5cdCAgICByZW1vdmU6IFwiRWZmYWNlclwiLFxuXHQgICAgcGxhY2Vob2xkZXI6IFwiw4ljcml2ZXogaWNpLi5cIixcblx0ICAgIG1vcmVDb21tZW50czogXCJQbHVzIGRlIGNvbW1lbnRhaXJlc1wiXG5cdCAgfVxuXHR9O1xuXG5cdC8qSXRhbGlhbiAoSXRhbHkpIGxvY2FsZSovXG5cdHZhciBpdCA9IHtcblx0ICBncm91cERlbGltaXRlcjogXCIuXCIsXG5cdCAgZ3JvdXBTaXplOiAzLFxuXHQgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLFwiLFxuXHQgIGRlY2ltYWxTaXplOiAyLFxuXHQgIGRhdGVGb3JtYXQ6IFwiJWQvJW0vJVlcIixcblx0ICB0aW1lRm9ybWF0OiBcIiVIOiVpXCIsXG5cdCAgbG9uZ0RhdGVGb3JtYXQ6IFwiJWogJUYgJVlcIixcblx0ICBmdWxsRGF0ZUZvcm1hdDogXCIlaiAlRiAlWSAlSDolaVwiLFxuXHQgIGFtOiBudWxsLFxuXHQgIHBtOiBudWxsLFxuXHQgIHByaWNlOiBcIuKCrCB7b2JqfVwiLFxuXHQgIHByaWNlU2V0dGluZ3M6IHtcblx0ICAgIGdyb3VwRGVsaW1pdGVyOiBcIi5cIixcblx0ICAgIGdyb3VwU2l6ZTogMyxcblx0ICAgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLFwiLFxuXHQgICAgZGVjaW1hbFNpemU6IDJcblx0ICB9LFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICBtb250aEZ1bGw6IFtcImdlbm5haW9cIiwgXCJmZWJicmFpb1wiLCBcIm1hcnpvXCIsIFwiYXByaWxlXCIsIFwibWFnZ2lvXCIsIFwiZ2l1Z25vXCIsIFwibHVnbGlvXCIsIFwiYWdvc3RvXCIsIFwic2V0dGVtYnJlXCIsIFwib3R0b2JyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZGljZW1icmVcIl0sXG5cdCAgICBtb250aFNob3J0OiBbXCJnZW5cIiwgXCJmZWJcIiwgXCJtYXJcIiwgXCJhcHJcIiwgXCJtYWdcIiwgXCJnaXVcIiwgXCJsdWdcIiwgXCJhZ29cIiwgXCJzZXRcIiwgXCJvdHRcIiwgXCJub3ZcIiwgXCJkaWNcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCJkb21lbmljYVwiLCBcImx1bmVkw6xcIiwgXCJtYXJ0ZWTDrFwiLCBcIm1lcmNvbGVkw6xcIiwgXCJnaW92ZWTDrFwiLCBcInZlbmVyZMOsXCIsIFwic2FiYXRvXCJdLFxuXHQgICAgZGF5U2hvcnQ6IFtcImRvbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1lclwiLCBcImdpb1wiLCBcInZlblwiLCBcInNhYlwiXSxcblx0ICAgIGhvdXJzOiBcIk9yYXJpb1wiLFxuXHQgICAgbWludXRlczogXCJNaW51dGlcIixcblx0ICAgIGRvbmU6IFwiUHJvbnRvXCIsXG5cdCAgICBjbGVhcjogXCJQdWxpc2NpXCIsXG5cdCAgICB0b2RheTogXCJPZ2dpXCJcblx0ICB9LFxuXHQgIGRhdGFFeHBvcnQ6IHtcblx0ICAgIHBhZ2U6IFwiUGFnaW5hXCIsXG5cdCAgICBvZjogXCJkaVwiXG5cdCAgfSxcblx0ICBQREZ2aWV3ZXI6IHtcblx0ICAgIG9mOiBcImRpXCIsXG5cdCAgICBhdXRvbWF0aWNab29tOiBcIlpvb20gYXV0b21hdGljb1wiLFxuXHQgICAgYWN0dWFsU2l6ZTogXCJEaW1lbnNpb25lIHJlYWxlXCIsXG5cdCAgICBwYWdlRml0OiBcIkRpbWVuc2lvbmkgZGVsbGEgcGFnaW5hXCIsXG5cdCAgICBwYWdlV2lkdGg6IFwiTGFyZ2hlenphIGRlbGxhIHBhZ2luYVwiLFxuXHQgICAgcGFnZUhlaWdodDogXCJBbHRlenphIGRlbGxhIHBhZ2luYVwiLFxuXHQgICAgZW50ZXJQYXNzd29yZDogXCJJbnNlcmlzY2kgbGEgcGFzc3dvcmRcIixcblx0ICAgIHBhc3N3b3JkRXJyb3I6IFwiUGFzc3dvcmQgZXJyYXRhXCJcblx0ICB9LFxuXHQgIGFyaWE6IHtcblx0ICAgIGNhbGVuZGFyOiBcIkNhbGVuZGFyaW9cIixcblx0ICAgIGluY3JlYXNlVmFsdWU6IFwiQXVtZW50YSBpbCB2YWxvcmVcIixcblx0ICAgIGRlY3JlYXNlVmFsdWU6IFwiUmlkdWNpIGlsIHZhbG9yZVwiLFxuXHQgICAgbmF2TW9udGg6IFtcIklsIG1lc2Ugc2NvcnNvXCIsIFwiSWwgcHJvc3NpbW8gbWVzZVwiXSxcblx0ICAgIG5hdlllYXI6IFtcIkwnYW5ubyBzY29yc29cIiwgXCJMJ2Fubm8gcHJvc3NpbW9cIl0sXG5cdCAgICBuYXZEZWNhZGU6IFtcIkRlY2VubmlvIHByZWNlZGVudGVcIiwgXCJQcm9zc2ltbyBkZWNlbm5pb1wiXSxcblx0ICAgIGRhdGVGb3JtYXQ6IFwiJWogJUYgJVlcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVGICVZXCIsXG5cdCAgICB5ZWFyRm9ybWF0OiBcIiVZXCIsXG5cdCAgICBob3VyRm9ybWF0OiBcIk9yYXJpbzogJUhcIixcblx0ICAgIG1pbnV0ZUZvcm1hdDogXCJNaW51dGk6ICVpXCIsXG5cdCAgICByZW1vdmVJdGVtOiBcIlJpbXVvdmVyZSBsJ2VsZW1lbnRvXCIsXG5cdCAgICBwYWdlczogW1wiUHJpbWEgcGFnaW5hXCIsIFwiUGFnaW5hIHByZWNlZGVudGVcIiwgXCJQYWdpbmEgc3VjY2Vzc2l2YVwiLCBcIlVsdGltYSBwYWdpbmFcIl0sXG5cdCAgICBwYWdlOiBcIlBhZ2luYVwiLFxuXHQgICAgaGVhZGVybWVudTogXCJNZW51IGRlbCB0aXRvbG9cIixcblx0ICAgIG9wZW5Hcm91cDogXCJBcGVydG8gZ3J1cHBvIGRpIGNvbG9ubmVcIixcblx0ICAgIGNsb3NlR3JvdXA6IFwiQ2hpdWRpIGdydXBwbyBkaSBjb2xvbm5lXCIsXG5cdCAgICBjbG9zZVRhYjogXCJDaGl1ZGkgdGFiXCIsXG5cdCAgICBzaG93VGFiczogXCJNb3N0cmEgcGnDuSB0YWJzXCIsXG5cdCAgICByZXNldFRyZWVNYXA6IFwiVG9ybmFyZSBhbGxhIHZpc3RhIG9yaWdpbmFsZVwiLFxuXHQgICAgbmF2VHJlZU1hcDogXCJMaXZlbGxvIHN1cGVyaW9yZVwiLFxuXHQgICAgbmV4dFRhYjogXCJUYWIgc3VjY2Vzc2l2b1wiLFxuXHQgICAgcHJldlRhYjogXCJUYWIgcHJlY2VkZW50ZVwiLFxuXHQgICAgbXVsdGl0ZXh0U2VjdGlvbjogXCJBZ2dpdW5naSBlbGVtZW50b1wiLFxuXHQgICAgbXVsdGl0ZXh0ZXh0cmFTZWN0aW9uOiBcIlJpbXVvdmVyZSBsJ2VsZW1lbnRvXCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwiTW9zdHJhcmUgZ3JhZmljb1wiLFxuXHQgICAgaGlkZUNoYXJ0OiBcIk5hc2NvbmRlcmUgZ3JhZmljb1wiLFxuXHQgICAgcmVzaXplQ2hhcnQ6IFwiUmlkaW1lbnNpb25hcmUgZ3JhZmljb1wiXG5cdCAgfSxcblx0ICByaWNodGV4dDoge1xuXHQgICAgdW5kZXJsaW5lOiBcIlNvdHRvbGluZWFyZVwiLFxuXHQgICAgYm9sZDogXCJHcmFzc2V0dG9cIixcblx0ICAgIGl0YWxpYzogXCJDb3JzaXZvXCJcblx0ICB9LFxuXHQgIGNvbWJvOiB7XG5cdCAgICBzZWxlY3Q6IFwiU2VsZXppb25hcmVcIixcblx0ICAgIHNlbGVjdEFsbDogXCJTZWxlemlvbmEgdHV0dG9cIixcblx0ICAgIHVuc2VsZWN0QWxsOiBcIkRlc2VsZXppb25hIHR1dHRvXCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcIk9LXCIsXG5cdCAgICBjYW5jZWw6IFwiQW5udWxsYXJlXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcIkludmlhcmVcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcIklsIGNvbW1lbnRvIHZlcnLDoCByaW1vc3NvLiBTZWkgc2ljdXJvP1wiLFxuXHQgICAgZWRpdDogXCJDb3JyZWdnZXJlXCIsXG5cdCAgICByZW1vdmU6IFwiRWxpbWluYVwiLFxuXHQgICAgcGxhY2Vob2xkZXI6IFwiRGlnaXRhcmUgcXVpLi5cIixcblx0ICAgIG1vcmVDb21tZW50czogXCJBbHRyaSBjb21tZW50aVwiXG5cdCAgfVxuXHR9O1xuXG5cdHZhciBqYSA9IHtcblx0ICBncm91cERlbGltaXRlcjogXCIsXCIsXG5cdCAgZ3JvdXBTaXplOiAzLFxuXHQgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgIGRlY2ltYWxTaXplOiAyLFxuXHQgIGRhdGVGb3JtYXQ6IFwiJVkuJW0uJWRcIixcblx0ICB0aW1lRm9ybWF0OiBcIiVIOiVpXCIsXG5cdCAgbG9uZ0RhdGVGb3JtYXQ6IFwiJVnlubQlbeaciCVk5pelXCIsXG5cdCAgZnVsbERhdGVGb3JtYXQ6IFwiJVkuJW0uJWQgJUg6JWlcIixcblx0ICBwcmljZTogXCLCpXtvYmp9XCIsXG5cdCAgcHJpY2VTZXR0aW5nczoge1xuXHQgICAgZ3JvdXBTaXplOiAzLFxuXHQgICAgZ3JvdXBEZWxpbWl0ZXI6IFwiLFwiLFxuXHQgICAgZGVjaW1hbERlbGltaXRlcjogXCJcIixcblx0ICAgIGRlY2ltYWxTaXplOiAwXG5cdCAgfSxcblx0ICBjYWxlbmRhcjoge1xuXHQgICAgbW9udGhGdWxsOiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl0sXG5cdCAgICBtb250aFNob3J0OiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCLml6Xmm5zml6VcIiwgXCLmnIjmm5zml6VcIiwgXCLngavmm5zml6VcIiwgXCLmsLTmm5zml6VcIiwgXCLmnKjmm5zml6VcIiwgXCLph5Hmm5zml6VcIiwgXCLlnJ/mm5zml6VcIl0sXG5cdCAgICBkYXlTaG9ydDogW1wi5pelXCIsIFwi5pyIXCIsIFwi54GrXCIsIFwi5rC0XCIsIFwi5pyoXCIsIFwi6YeRXCIsIFwi5ZyfXCJdLFxuXHQgICAgaG91cnM6IFwi5Za25qWt5pmC6ZaTXCIsXG5cdCAgICBtaW51dGVzOiBcIuWIhlwiLFxuXHQgICAgZG9uZTogXCLjg6zjg4fjgqPjg7xcIixcblx0ICAgIGNsZWFyOiBcIuWJiumZpOOBmeOCi1wiLFxuXHQgICAgdG9kYXk6IFwi5LuK5pelXCJcblx0ICB9LFxuXHQgIGRhdGFFeHBvcnQ6IHtcblx0ICAgIHBhZ2U6IFwi44Oa44O844K4XCIsXG5cdCAgICBvZjogXCLjgYvjgolcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCLjgYvjgolcIixcblx0ICAgIGF1dG9tYXRpY1pvb206IFwi6Ieq5YuV44K644O844OgXCIsXG5cdCAgICBhY3R1YWxTaXplOiBcIuWun+OCteOCpOOCulwiLFxuXHQgICAgcGFnZUZpdDogXCLjg5rjg7zjgrjjgrXjgqTjgrpcIixcblx0ICAgIHBhZ2VXaWR0aDogXCLjg5rjg7zjgrjluYVcIixcblx0ICAgIHBhZ2VIZWlnaHQ6IFwi44Oa44O844K444Gu6auY44GVXCIsXG5cdCAgICBlbnRlclBhc3N3b3JkOiBcIuODkeOCueODr+ODvOODieOCkuWFpeWKm+OBmeOCi1wiLFxuXHQgICAgcGFzc3dvcmRFcnJvcjogXCLplpPpgZXjgaPjgZ/jg5Hjgrnjg6/jg7zjg4lcIlxuXHQgIH0sXG5cdCAgYXJpYToge1xuXHQgICAgY2FsZW5kYXI6IFwi44Kr44Os44Oz44OA44O8XCIsXG5cdCAgICBpbmNyZWFzZVZhbHVlOiBcIuWil+WKoOWApFwiLFxuXHQgICAgZGVjcmVhc2VWYWx1ZTogXCLmlbDlrZfjgpLlsI/jgZXjgY9cIixcblx0ICAgIG5hdk1vbnRoOiBbXCLliY3jga7mnIhcIiwgXCLmnaXmnIhcIl0sXG5cdCAgICBuYXZZZWFyOiBbXCLliY3lubRcIiwgXCLmnaXlubRcIl0sXG5cdCAgICBuYXZEZWNhZGU6IFtcIuWJjeOBruWNgeW5tFwiLCBcIuasoeOBrjEw5bm0XCJdLFxuXHQgICAgZGF0ZUZvcm1hdDogXCIlWeW5tCVt5pyIJWTml6VcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVZ5bm0JW3mnIhcIixcblx0ICAgIHllYXJGb3JtYXQ6IFwiJVnlubRcIixcblx0ICAgIGhvdXJGb3JtYXQ6IFwi5Za25qWt5pmC6ZaTOiAlSFwiLFxuXHQgICAgbWludXRlRm9ybWF0OiBcIuWIhjogJWlcIixcblx0ICAgIHJlbW92ZUl0ZW06IFwi6KaB57Sg44KS5YmK6Zmk44GX44G+44GZXCIsXG5cdCAgICBwYWdlczogW1wi5LiA44Oa44O844K455uuXCIsIFwi5YmN44Gu44Oa44O844K4XCIsIFwi5qyh44Gu44Oa44O844K4XCIsIFwi5pyA5b6M44Gu44Oa44O844K4XCJdLFxuXHQgICAgcGFnZTogXCLjg5rjg7zjgrhcIixcblx0ICAgIGhlYWRlcm1lbnU6IFwi44OY44OD44OA44Oh44OL44Ol44O8XCIsXG5cdCAgICBvcGVuR3JvdXA6IFwi44Kq44O844OX44Oz5YiX44Kw44Or44O844OXXCIsXG5cdCAgICBjbG9zZUdyb3VwOiBcIumWieOBmOOCi+WIl+OCsOODq+ODvOODl1wiLFxuXHQgICAgY2xvc2VUYWI6IFwi44K/44OW44KS6ZaJ44GY44G+44GZXCIsXG5cdCAgICBzaG93VGFiczogXCLopIfmlbDjga7jgr/jg5bjgpLooajnpLrjgZfjgb7jgZlcIixcblx0ICAgIHJlc2V0VHJlZU1hcDogXCLlhYPjga7ooajnpLrjgavmiLvjgorjgb7jgZlcIixcblx0ICAgIG5hdlRyZWVNYXA6IFwi44Os44OZ44Or44OR44OD44KvXCIsXG5cdCAgICBuZXh0VGFiOiBcIuasoeOBruOCv+ODllwiLFxuXHQgICAgcHJldlRhYjogXCLliY3jga7jgr/jg5ZcIixcblx0ICAgIG11bHRpdGV4dFNlY3Rpb246IFwi6KaB57Sg44KS6L+95Yqg44GX44G+44GZ44CCXCIsXG5cdCAgICBtdWx0aXRleHRleHRyYVNlY3Rpb246IFwi6KaB57Sg44KS5YmK6Zmk44GX44G+44GZXCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwi6Z2044OB44Oj44O844OIXCIsXG5cdCAgICBoaWRlQ2hhcnQ6IFwi6Zqg44GZ44OB44Oj44O844OIXCIsXG5cdCAgICByZXNpemVDaGFydDogXCLjgrDjg6njg5Xjga7jgrXjgqTjgrrjgpLlpInmm7RcIlxuXHQgIH0sXG5cdCAgcmljaHRleHQ6IHtcblx0ICAgIHVuZGVybGluZTogXCLjgqLjg7Pjg4Djg7zjg6njgqTjg7NcIixcblx0ICAgIGJvbGQ6IFwi5aSn6IOG44GqXCIsXG5cdCAgICBpdGFsaWM6IFwi44Kk44K/44Oq44OD44KvXCJcblx0ICB9LFxuXHQgIGNvbWJvOiB7XG5cdCAgICBzZWxlY3Q6IFwi6YG45oqe44GZ44KLXCIsXG5cdCAgICBzZWxlY3RBbGw6IFwi44GZ44G544Gm6YG45oqeXCIsXG5cdCAgICB1bnNlbGVjdEFsbDogXCLjgZnjgbnjgabjga7pgbjmip7jgpLop6PpmaTjgZnjgotcIlxuXHQgIH0sXG5cdCAgbWVzc2FnZToge1xuXHQgICAgb2s6IFwiT0tcIixcblx0ICAgIGNhbmNlbDogXCLlj5bjgormtojjgZlcIlxuXHQgIH0sXG5cdCAgY29tbWVudHM6IHtcblx0ICAgIHNlbmQ6IFwi6YCB5L+hXCIsXG5cdCAgICBjb25maXJtTWVzc2FnZTogXCLjgrPjg6Hjg7Pjg4jjga/liYrpmaTjgZXjgozjgb7jgZkuIOacrOawl+OBp+OBmeOBi++8n1wiLFxuXHQgICAgZWRpdDogXCLnt6jpm4ZcIixcblx0ICAgIHJlbW92ZTogXCLliYrpmaRcIixcblx0ICAgIHBsYWNlaG9sZGVyOiBcIuOBk+OBk+OBq+WFpeWKmy4uXCIsXG5cdCAgICBtb3JlQ29tbWVudHM6IFwi44Gd44Gu5LuW44Gu44Kz44Oh44Oz44OIXCJcblx0ICB9XG5cdH07XG5cblx0dmFyIHB0ID0ge1xuXHQgIGdyb3VwRGVsaW1pdGVyOiBcIi5cIixcblx0ICBncm91cFNpemU6IDMsXG5cdCAgZGVjaW1hbERlbGltaXRlcjogXCIsXCIsXG5cdCAgZGVjaW1hbFNpemU6IDIsXG5cdCAgZGF0ZUZvcm1hdDogXCIlZC8lbS8lWVwiLFxuXHQgIHRpbWVGb3JtYXQ6IFwiJUc6JWlcIixcblx0ICBsb25nRGF0ZUZvcm1hdDogXCIlZCBkZSAlRiBkZSAlWVwiLFxuXHQgIGZ1bGxEYXRlRm9ybWF0OiBcIiVkIGRlICVGIGRlICVZICVHOiVpXCIsXG5cdCAgYW06IG51bGwsXG5cdCAgcG06IG51bGwsXG5cdCAgcHJpY2U6IFwiUiQge29ian1cIixcblx0ICBwcmljZVNldHRpbmdzOiB7XG5cdCAgICBncm91cERlbGltaXRlcjogXCIuXCIsXG5cdCAgICBncm91cFNpemU6IDMsXG5cdCAgICBkZWNpbWFsRGVsaW1pdGVyOiBcIixcIixcblx0ICAgIGRlY2ltYWxTaXplOiAyXG5cdCAgfSxcblx0ICBmaWxlU2l6ZTogW1wiYlwiLCBcIktiXCIsIFwiTWJcIiwgXCJHYlwiLCBcIlRiXCIsIFwiUGJcIiwgXCJFYlwiXSxcblx0ICBjYWxlbmRhcjoge1xuXHQgICAgbW9udGhGdWxsOiBbXCJKYW5laXJvXCIsIFwiRmV2ZXJlaXJvXCIsIFwiTWFyw6dvXCIsIFwiQWJyaWxcIiwgXCJNYWlvXCIsIFwiSnVuaG9cIiwgXCJKdWxob1wiLCBcIkFnb3N0b1wiLCBcIlNldGVtYnJvXCIsIFwiT3V0dWJyb1wiLCBcIk5vdmVtYnJvXCIsIFwiRGV6ZW1icm9cIl0sXG5cdCAgICBtb250aFNob3J0OiBbXCJKYW5cIiwgXCJGZXZcIiwgXCJNYXJcIiwgXCJBYnJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdXRcIiwgXCJOb3ZcIiwgXCJEZXpcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCJEb21pbmdvXCIsIFwiU2VndW5kYS1GZWlyYVwiLCBcIlRlcsOnYS1GZWlyYVwiLCBcIlF1YXJ0YS1GZWlyYVwiLCBcIlF1aW50YS1GZWlyYVwiLCBcIlNleHRhLUZlaXJhXCIsIFwiU8OhYmFkb1wiXSxcblx0ICAgIGRheVNob3J0OiBbXCJEb21cIiwgXCJTZWdcIiwgXCJUZXJcIiwgXCJRdWFcIiwgXCJRdWlcIiwgXCJTZXhcIiwgXCJTw6FiXCJdLFxuXHQgICAgaG91cnM6IFwiSG9yYXNcIixcblx0ICAgIG1pbnV0ZXM6IFwiTWludXRvc1wiLFxuXHQgICAgZG9uZTogXCJGZWl0b1wiLFxuXHQgICAgY2xlYXI6IFwiTGltcGFyXCIsXG5cdCAgICB0b2RheTogXCJIb2plXCJcblx0ICB9LFxuXHQgIGRhdGFFeHBvcnQ6IHtcblx0ICAgIHBhZ2U6IFwiUMOhZ2luYVwiLFxuXHQgICAgb2Y6IFwiZGVcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCJkZVwiLFxuXHQgICAgYXV0b21hdGljWm9vbTogXCJab29tIGF1dG9tw6F0aWNvXCIsXG5cdCAgICBhY3R1YWxTaXplOiBcIlRhbWFuaG8gYXR1YWxcIixcblx0ICAgIHBhZ2VGaXQ6IFwiVGFtYW5obyBkYSBww6FnaW5hXCIsXG5cdCAgICBwYWdlV2lkdGg6IFwiTGFyZ3VyYSBkYSBww6FnaW5hXCIsXG5cdCAgICBwYWdlSGVpZ2h0OiBcIkFsdHVyYSBkYSBww6FnaW5hXCIsXG5cdCAgICBlbnRlclBhc3N3b3JkOiBcIkRpZ2l0ZSBhIHNlbmhhXCIsXG5cdCAgICBwYXNzd29yZEVycm9yOiBcIlNlbmhhIGluY29ycmV0YVwiXG5cdCAgfSxcblx0ICBhcmlhOiB7XG5cdCAgICBjYWxlbmRhcjogXCJDYWxlbmTDoXJpb1wiLFxuXHQgICAgaW5jcmVhc2VWYWx1ZTogXCJBdW1lbnRhciBvIHZhbG9yXCIsXG5cdCAgICBkZWNyZWFzZVZhbHVlOiBcIkRpbWludWlyIG8gdmFsb3JcIixcblx0ICAgIG5hdk1vbnRoOiBbXCJNw6pzIGFudGVyaW9yXCIsIFwiUHLDs3hpbW8gbcOqc1wiXSxcblx0ICAgIG5hdlllYXI6IFtcIkFubyBhbnRlcmlvclwiLCBcIlByw7N4aW1vIGFub1wiXSxcblx0ICAgIG5hdkRlY2FkZTogW1wiRMOpY2FkYSBhbnRlcmlvclwiLCBcIlByw7N4aW1hIGTDqWNhZGFcIl0sXG5cdCAgICBkYXRlRm9ybWF0OiBcIiVkIGRlICVGIGRlICVZXCIsXG5cdCAgICBtb250aEZvcm1hdDogXCIlRiBkZSAlWVwiLFxuXHQgICAgeWVhckZvcm1hdDogXCIlWVwiLFxuXHQgICAgaG91ckZvcm1hdDogXCJIb3JhczogJUdcIixcblx0ICAgIG1pbnV0ZUZvcm1hdDogXCJNaW51dG9zOiAlaVwiLFxuXHQgICAgcmVtb3ZlSXRlbTogXCJSZW1vdmVyIGVsZW1lbnRvXCIsXG5cdCAgICBwYWdlczogW1wiUHJpbWVpcmEgcMOhZ2luYVwiLCBcIlDDoWdpbmEgYW50ZXJpb3JcIiwgXCJQcsOzeGltYSBww6FnaW5hXCIsIFwiw5psdGltYSBww6FnaW5hXCJdLFxuXHQgICAgcGFnZTogXCJQw6FnaW5hXCIsXG5cdCAgICBoZWFkZXJtZW51OiBcIk1lbnUgZGUgdMOtdHVsb3NcIixcblx0ICAgIG9wZW5Hcm91cDogXCJHcnVwbyBjb2x1bmEgYWJlcnRhXCIsXG5cdCAgICBjbG9zZUdyb3VwOiBcIkZlY2hhciBncnVwbyBkZSBjb2x1bmFzXCIsXG5cdCAgICBjbG9zZVRhYjogXCJGZWNoYXIgdGFiXCIsXG5cdCAgICBzaG93VGFiczogXCJNb3N0cmUgbWFpcyB0YWJzXCIsXG5cdCAgICByZXNldFRyZWVNYXA6IFwi0JxvbHRhciDDoCB2aXN0YSBvcmlnaW5hbFwiLFxuXHQgICAgbmF2VHJlZU1hcDogXCJVcGFyXCIsXG5cdCAgICBuZXh0VGFiOiBcIlByw7N4aW1vIHRhYlwiLFxuXHQgICAgcHJldlRhYjogXCJBbnRlcmlvciB0YWJcIixcblx0ICAgIG11bHRpdGV4dFNlY3Rpb246IFwiQWRpY2lvbmFyIGVsZW1lbnRvXCIsXG5cdCAgICBtdWx0aXRleHRleHRyYVNlY3Rpb246IFwiUmVtb3ZlciBlbGVtZW50b1wiLFxuXHQgICAgc2hvd0NoYXJ0OiBcIkV4cG9zacOnw6NvIGNoYXJ0XCIsXG5cdCAgICBoaWRlQ2hhcnQ6IFwiRXNjb25kZXIgY2hhcnRcIixcblx0ICAgIHJlc2l6ZUNoYXJ0OiBcIlJlZGltZW5zaW9uYXIgY2hhcnRcIlxuXHQgIH0sXG5cdCAgcmljaHRleHQ6IHtcblx0ICAgIHVuZGVybGluZTogXCJTdWJsaW5oYWRvXCIsXG5cdCAgICBib2xkOiBcIk5lZ3JpdG9cIixcblx0ICAgIGl0YWxpYzogXCJpdMOhbGljb1wiXG5cdCAgfSxcblx0ICBjb21ibzoge1xuXHQgICAgc2VsZWN0OiBcIlNlbGVjaW9uYXJcIixcblx0ICAgIHNlbGVjdEFsbDogXCJTZWxlY2lvbmFyIHR1ZG9cIixcblx0ICAgIHVuc2VsZWN0QWxsOiBcIkRlc21hcnF1ZSB0b2Rvc1wiXG5cdCAgfSxcblx0ICBtZXNzYWdlOiB7XG5cdCAgICBvazogXCJPS1wiLFxuXHQgICAgY2FuY2VsOiBcIkNhbmNlbGFyXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcIkVudmlhclwiLFxuXHQgICAgY29uZmlybU1lc3NhZ2U6IFwiQ29tZW50w6FyaW8gc2Vyw6EgcmVtb3ZpZG8uIFZvY8OqIHRlbSBjZXJ0ZXphP1wiLFxuXHQgICAgZWRpdDogXCJFZGl0YXJcIixcblx0ICAgIHJlbW92ZTogXCJFeGNsdWlyXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJEaWdpdGUgYXF1aS4uXCIsXG5cdCAgICBtb3JlQ29tbWVudHM6IFwiTWFpcyBjb21lbnTDoXJpb3NcIlxuXHQgIH1cblx0fTtcblxuXHQvKkNoaW5lc2UgKFNpbXBsaWZpZWQsIFBSQykgbG9jYWxlKi9cblx0dmFyIHpoID0ge1xuXHQgIGdyb3VwRGVsaW1pdGVyOiBcIixcIixcblx0ICBncm91cFNpemU6IDMsXG5cdCAgZGVjaW1hbERlbGltaXRlcjogXCIuXCIsXG5cdCAgZGVjaW1hbFNpemU6IDIsXG5cdCAgZGF0ZUZvcm1hdDogXCIlWS8lbS8lalwiLFxuXHQgIHRpbWVGb3JtYXQ6IFwiJUc6JWlcIixcblx0ICBsb25nRGF0ZUZvcm1hdDogXCIlWSflubQnJW0n5pyIJyVqJ+aXpSdcIixcblx0ICBmdWxsRGF0ZUZvcm1hdDogXCIlWSflubQnJW0n5pyIJyVqJ+aXpScgJUc6JWlcIixcblx0ICBhbTogW1wi5LiK5Y2IXCIsIFwi5LiK5Y2IXCJdLFxuXHQgIHBtOiBbXCLkuIvljYhcIiwgXCLkuIvljYhcIl0sXG5cdCAgcHJpY2U6IFwiwqV7b2JqfVwiLFxuXHQgIHByaWNlU2V0dGluZ3M6IHtcblx0ICAgIGdyb3VwRGVsaW1pdGVyOiBcIixcIixcblx0ICAgIGdyb3VwU2l6ZTogMyxcblx0ICAgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLlwiLFxuXHQgICAgZGVjaW1hbFNpemU6IDJcblx0ICB9LFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICBtb250aEZ1bGw6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXSxcblx0ICAgIG1vbnRoU2hvcnQ6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXSxcblx0ICAgIGRheUZ1bGw6IFtcIuaYn+acn+aXpVwiLCBcIuaYn+acn+S4gFwiLCBcIuaYn+acn+S6jFwiLCBcIuaYn+acn+S4iVwiLCBcIuaYn+acn+Wbm1wiLCBcIuaYn+acn+S6lFwiLCBcIuaYn+acn+WFrVwiXSxcblx0ICAgIGRheVNob3J0OiBbXCLlkajml6VcIiwgXCLlkajkuIBcIiwgXCLlkajkuoxcIiwgXCLlkajkuIlcIiwgXCLlkajlm5tcIiwgXCLlkajkupRcIiwgXCLlkajlha1cIl0sXG5cdCAgICBob3VyczogXCLlsI/ml7ZcIixcblx0ICAgIG1pbnV0ZXM6IFwi5YiG6ZKfXCIsXG5cdCAgICBkb25lOiBcIuWujOaIkFwiLFxuXHQgICAgY2xlYXI6IFwi5riF6ZmkXCIsXG5cdCAgICB0b2RheTogXCLku4rlpKlcIlxuXHQgIH0sXG5cdCAgZGF0YUV4cG9ydDoge1xuXHQgICAgcGFnZTogXCLpobVcIixcblx0ICAgIG9mOiBcIuS7jlwiXG5cdCAgfSxcblx0ICBQREZ2aWV3ZXI6IHtcblx0ICAgIG9mOiBcIuS7jlwiLFxuXHQgICAgYXV0b21hdGljWm9vbTogXCLoh6rliqjorr7nva7pobXpnaLlpKflsI9cIixcblx0ICAgIGFjdHVhbFNpemU6IFwi5a6e6ZmF5bC65a+4XCIsXG5cdCAgICBwYWdlRml0OiBcIumhtemdouWkp+Wwj1wiLFxuXHQgICAgcGFnZVdpZHRoOiBcIumhtemdouWuveW6plwiLFxuXHQgICAgcGFnZUhlaWdodDogXCLpobXpnaLpq5jluqZcIixcblx0ICAgIGVudGVyUGFzc3dvcmQ6IFwi6L6T5YWl5a+G56CBXCIsXG5cdCAgICBwYXNzd29yZEVycm9yOiBcIuWvhueggemUmeivr1wiXG5cdCAgfSxcblx0ICBhcmlhOiB7XG5cdCAgICBjYWxlbmRhcjogXCLml6XljoZcIixcblx0ICAgIGluY3JlYXNlVmFsdWU6IFwi5aKe5Yqg5YC8XCIsXG5cdCAgICBkZWNyZWFzZVZhbHVlOiBcIuWHj+WwkeWAvFwiLFxuXHQgICAgbmF2TW9udGg6IFtcIuS4iuS4quaciFwiLCBcIuS4i+S4quaciFwiXSxcblx0ICAgIG5hdlllYXI6IFtcIuS4iuW5tFwiLCBcIuaYjuW5tFwiXSxcblx0ICAgIG5hdkRlY2FkZTogW1wi6L+H5Y675Y2B5bm0XCIsIFwi5LiL5Liq5Y2B5bm0XCJdLFxuXHQgICAgZGF0ZUZvcm1hdDogXCIlWSflubQnJW0n5pyIJyVqJ+aXpSdcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVZJ+W5tCclbSfmnIhcIixcblx0ICAgIHllYXJGb3JtYXQ6IFwiJVkn5bm0XCIsXG5cdCAgICBob3VyRm9ybWF0OiBcIuWwj+aXtjogJUdcIixcblx0ICAgIG1pbnV0ZUZvcm1hdDogXCLliIbpkp86ICVpXCIsXG5cdCAgICByZW1vdmVJdGVtOiBcIuWIoOmZpOWFg+e0oFwiLFxuXHQgICAgcGFnZXM6IFtcIuesrOS4gOmhtVwiLCBcIuS4iuS4gOmhtVwiLCBcIuS4i+S4gOmhtVwiLCBcIuacgOWQjuS4gOmhtVwiXSxcblx0ICAgIHBhZ2U6IFwi6aG1XCIsXG5cdCAgICBoZWFkZXJtZW51OiBcIuagh+mimOiPnOWNlVwiLFxuXHQgICAgb3Blbkdyb3VwOiBcIuaJk+W8gOagj+ebrue7hFwiLFxuXHQgICAgY2xvc2VHcm91cDogXCLlhbPpl63moI/nm67nu4RcIixcblx0ICAgIGNsb3NlVGFiOiBcIuWFs+mXreagh+etvlwiLFxuXHQgICAgc2hvd1RhYnM6IFwi5pi+56S65pu05aSa6YCJ6aG55Y2hXCIsXG5cdCAgICByZXNldFRyZWVNYXA6IFwi5Zue5Yiw5Y6f5p2l55qE6KeG5Zu+XCIsXG5cdCAgICBuYXZUcmVlTWFwOiBcIuWNh+e6p1wiLFxuXHQgICAgbmV4dFRhYjogXCLkuIvkuIDkuKrmoIfnrb5cIixcblx0ICAgIHByZXZUYWI6IFwi5YmN5LiA5Liq5qCH562+XCIsXG5cdCAgICBtdWx0aXRleHRTZWN0aW9uOiBcIuWKoOWFg1wiLFxuXHQgICAgbXVsdGl0ZXh0ZXh0cmFTZWN0aW9uOiBcIuWIoOmZpOWFg+e0oFwiLFxuXHQgICAgc2hvd0NoYXJ0OiBcIuaYvuekuuWbvuihqFwiLFxuXHQgICAgaGlkZUNoYXJ0OiBcIumakOiXj+WbvuihqFwiLFxuXHQgICAgcmVzaXplQ2hhcnQ6IFwi6LCD5pW05Zu+XCJcblx0ICB9LFxuXHQgIHJpY2h0ZXh0OiB7XG5cdCAgICB1bmRlcmxpbmU6IFwi5by66LCDXCIsXG5cdCAgICBib2xkOiBcIueyl+mrlFwiLFxuXHQgICAgaXRhbGljOiBcIuaWnOS9k1wiXG5cdCAgfSxcblx0ICBjb21ibzoge1xuXHQgICAgc2VsZWN0OiBcIumAieaLqVwiLFxuXHQgICAgc2VsZWN0QWxsOiBcIuWFqOmAiVwiLFxuXHQgICAgdW5zZWxlY3RBbGw6IFwi5YWo6YOo5Y+W5raI6YCJ5oupXCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcIuWlvVwiLFxuXHQgICAgY2FuY2VsOiBcIuWPlua2iFwiXG5cdCAgfSxcblx0ICBjb21tZW50czoge1xuXHQgICAgc2VuZDogXCLlj5HpgIFcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcIuivhOiuuuWwhuiiq+WIoOmZpC4g5L2g56Gu5a6a5ZCXP1wiLFxuXHQgICAgZWRpdDogXCLnvJbovpFcIixcblx0ICAgIHJlbW92ZTogXCLljrvmjolcIixcblx0ICAgIHBsYWNlaG9sZGVyOiBcIuWcqOatpOi+k+WFpS4uXCIsXG5cdCAgICBtb3JlQ29tbWVudHM6IFwi5pu05aSa6K+E6K66XCJcblx0ICB9XG5cdH07XG5cblx0dmFyIHJ1ID0ge1xuXHQgIGdyb3VwRGVsaW1pdGVyOiBcIiBcIixcblx0ICBncm91cFNpemU6IDMsXG5cdCAgZGVjaW1hbERlbGltaXRlcjogXCIsXCIsXG5cdCAgZGVjaW1hbFNpemU6IDIsXG5cdCAgZGF0ZUZvcm1hdDogXCIlZC4lbS4lWVwiLFxuXHQgIHRpbWVGb3JtYXQ6IFwiJUg6JWlcIixcblx0ICBsb25nRGF0ZUZvcm1hdDogXCIlZCAlRiAlWVwiLFxuXHQgIGZ1bGxEYXRlRm9ybWF0OiBcIiVkLiVtLiVZICVIOiVpXCIsXG5cdCAgcHJpY2U6IFwie29ian0g0YDRg9CxLlwiLFxuXHQgIHByaWNlU2V0dGluZ3M6IG51bGwsXG5cdCAgLy91c2UgbnVtYmVyIGRlZmF1bHRzXG5cdCAgY2FsZW5kYXI6IHtcblx0ICAgIG1vbnRoRnVsbDogW1wi0K/QvdCy0LDRgNGMXCIsIFwi0KTQtdCy0YDQsNC70YxcIiwgXCLQnNCw0YDRglwiLCBcItCQ0L/RgNC10LvRjFwiLCBcIk1h0LlcIiwgXCLQmNGO0L3RjFwiLCBcItCY0Y7Qu9GMXCIsIFwi0JDQstCz0YPRgdGCXCIsIFwi0KHQtdC90YLRj9Cx0YDRjFwiLCBcIk/QutGC0Y/QsdGA0YxcIiwgXCLQndC+0Y/QsdGA0YxcIiwgXCLQlNC10LrQsNCx0YDRjFwiXSxcblx0ICAgIG1vbnRoU2hvcnQ6IFtcItCv0L3QslwiLCBcItCk0LXQslwiLCBcIk1h0YBcIiwgXCJB0L/RgFwiLCBcIk1h0LlcIiwgXCLQmNGO0L1cIiwgXCLQmNGO0LtcIiwgXCJB0LLQs1wiLCBcItCh0LXQvVwiLCBcItCe0LrRglwiLCBcItCd0L7Rj1wiLCBcItCU0LXQulwiXSxcblx0ICAgIGRheUZ1bGw6IFtcItCS0L7RgdC60YDQtdGB0LXQvdGM0LVcIiwgXCLQn9C+0L3QtdC00LXQu9GM0L3QuNC6XCIsIFwi0JLRgtC+0YDQvdC40LpcIiwgXCLQodGA0LXQtNCwXCIsIFwi0KfQtdGC0LLQtdGA0LNcIiwgXCLQn9GP0YLQvdC40YbQsFwiLCBcItCh0YPQsdCx0L7RgtCwXCJdLFxuXHQgICAgZGF5U2hvcnQ6IFtcItCS0YFcIiwgXCLQn9C9XCIsIFwi0JLRglwiLCBcItCh0YBcIiwgXCLQp9GCXCIsIFwi0J/RglwiLCBcItCh0LFcIl0sXG5cdCAgICBob3VyczogXCLQp9Cw0YHRi1wiLFxuXHQgICAgbWludXRlczogXCLQnNC40L3Rg9GC0YtcIixcblx0ICAgIGRvbmU6IFwi0JNv0YLQvtCyb1wiLFxuXHQgICAgY2xlYXI6IFwi0J7Rh9C40YHRgtC40YLRjFwiLFxuXHQgICAgdG9kYXk6IFwi0KHQtdCz0L7QtNC90Y9cIlxuXHQgIH0sXG5cdCAgZGF0YUV4cG9ydDoge1xuXHQgICAgcGFnZTogXCLQodGC0YDQsNC90LjRhtCwXCIsXG5cdCAgICBvZjogXCLQuNC3XCJcblx0ICB9LFxuXHQgIFBERnZpZXdlcjoge1xuXHQgICAgb2Y6IFwi0LjQt1wiLFxuXHQgICAgYXV0b21hdGljWm9vbTogXCLQkNCy0YLQvtC80LDRgtC40YfQtdGB0LrQuNC5INC30YPQvFwiLFxuXHQgICAgYWN0dWFsU2l6ZTogXCLQndCw0YHRgtC+0Y/RidC40Lkg0YDQsNC30LzQtdGAXCIsXG5cdCAgICBwYWdlRml0OiBcItCg0LDQt9C80LXRgCDRgdGC0YDQsNC90LjRhtGLXCIsXG5cdCAgICBwYWdlV2lkdGg6IFwi0KjQuNGA0LjQvdCwINGB0YLRgNCw0L3QuNGG0YtcIixcblx0ICAgIHBhZ2VIZWlnaHQ6IFwi0JLRi9GB0L7RgtCwINGB0YLRgNCw0L3QuNGG0YtcIixcblx0ICAgIGVudGVyUGFzc3dvcmQ6IFwi0JLQstC10LTQuNGC0LUg0L/QsNGA0L7Qu9GMXCIsXG5cdCAgICBwYXNzd29yZEVycm9yOiBcItCd0LXQstC10YDQvdGL0Lkg0L/QsNGA0L7Qu9GMXCJcblx0ICB9LFxuXHQgIGFyaWE6IHtcblx0ICAgIGNhbGVuZGFyOiBcItCa0LDQu9C10L3QtNCw0YDRjFwiLFxuXHQgICAgaW5jcmVhc2VWYWx1ZTogXCLQo9Cy0LXQu9C40YfQuNGC0Ywg0LfQvdCw0YfQtdC90LjQtVwiLFxuXHQgICAgZGVjcmVhc2VWYWx1ZTogXCLQo9C80LXQvdGM0YjQuNGC0Ywg0LfQvdCw0YfQtdC90LjQtVwiLFxuXHQgICAgbmF2TW9udGg6IFtcItCf0YDQtdC00YvQtNGD0YnQuNC5INC80LXRgdGP0YZcIiwgXCLQodC70LXQtNGD0Y7RidC40Lkg0LzQtdGB0Y/RhlwiXSxcblx0ICAgIG5hdlllYXI6IFtcItCf0YDQtdC00YvQtNGD0YnQuNC5INCz0L7QtFwiLCBcItCh0LvQtdC00YPRjtGJ0LjQuSDQs9C+0LRcIl0sXG5cdCAgICBuYXZEZWNhZGU6IFtcItCf0YDQtdC00YvQtNGD0YnQuNC1INC00LXRgdGP0YLRjCDQu9C10YJcIiwgXCLQodC70LXQtNGD0Y7RidC40LUg0LTQtdGB0Y/RgtGMINC70LXRglwiXSxcblx0ICAgIGRhdGVGb3JtYXQ6IFwiJWQgJUYgJVlcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVGICVZXCIsXG5cdCAgICB5ZWFyRm9ybWF0OiBcIiVZXCIsXG5cdCAgICBob3VyRm9ybWF0OiBcItCn0LDRgdGLOiAlSFwiLFxuXHQgICAgbWludXRlRm9ybWF0OiBcItCc0LjQvdGD0YLRizogJWlcIixcblx0ICAgIHJlbW92ZUl0ZW06IFwi0KPQtNCw0LvQuNGC0Ywg0Y3Qu9C10LzQtdC90YJcIixcblx0ICAgIHBhZ2VzOiBbXCLQn9C10YDQstCw0Y8g0YHRgtGA0LDQvdC40YbQsFwiLCBcItCf0YDQtdC00YvQtNGD0YnQsNGPINGB0YLRgNCw0L3QuNGG0LBcIiwgXCLQodC70LXQtNGD0Y7RidCw0Y8g0YHRgtGA0LDQvdC40YbQsFwiLCBcItCf0L7RgdC70LXQtNC90Y/RjyDRgdGC0YDQsNC90LjRhtCwXCJdLFxuXHQgICAgcGFnZTogXCLQodGC0YDQsNC90LjRhtCwXCIsXG5cdCAgICBoZWFkZXJtZW51OiBcItCc0LXQvdGOINGI0LDQv9C60Lgg0YLQsNCx0LvQuNGG0YtcIixcblx0ICAgIG9wZW5Hcm91cDogXCLQoNCw0LfQstC10YDQvdGD0YLRjCDQs9GA0YPQv9C/0YMg0YHRgtC+0LvQsdGG0L7QslwiLFxuXHQgICAgY2xvc2VHcm91cDogXCLQodCy0LXRgNC90YPRgtGMINCz0YDRg9C/0L/RgyDRgdGC0L7Qu9Cx0YbQvtCyXCIsXG5cdCAgICBjbG9zZVRhYjogXCLQl9Cw0LrRgNGL0YLRjCDQstC60LvQsNC00LrRg1wiLFxuXHQgICAgc2hvd1RhYnM6IFwi0J/QvtC60LDQt9Cw0YLRjCDQsdC+0LvRjNGI0LUg0LLQutC70LDQtNC+0LpcIixcblx0ICAgIHJlc2V0VHJlZU1hcDogXCLQktC10YDQvdGD0YLRjNGB0Y8g0Log0L/QtdGA0LLQvtC90LDRh9Cw0LvRjNC90L7QvNGDINC/0YDQtdC00YHRgtCw0LLQu9C10L3QuNGOXCIsXG5cdCAgICBuYXZUcmVlTWFwOiBcItCf0LXRgNC10LnRgtC4INC90LAg0YPRgNC+0LLQtdC90Ywg0LLRi9GI0LVcIixcblx0ICAgIG5leHRUYWI6IFwi0KHQu9C10LTRg9GO0YnQsNGPINCy0LrQu9Cw0LTQutCwXCIsXG5cdCAgICBwcmV2VGFiOiBcItCf0YDQtdC00YvQtNGD0YnQsNGPINCy0LrQu9Cw0LTQutCwXCIsXG5cdCAgICBtdWx0aXRleHRTZWN0aW9uOiBcItCU0L7QsdCw0LLQuNGC0Ywg0Y3Qu9C10LzQtdC90YJcIixcblx0ICAgIG11bHRpdGV4dGV4dHJhU2VjdGlvbjogXCLQo9C00LDQu9C40YLRjCDRjdC70LXQvNC10L3RglwiLFxuXHQgICAgc2hvd0NoYXJ0OiBcItCf0L7QutCw0LfQsNGC0Ywg0YfQsNGA0YJcIixcblx0ICAgIGhpZGVDaGFydDogXCLQodC/0YDRj9GC0LDRgtGMINGH0LDRgNGCXCIsXG5cdCAgICByZXNpemVDaGFydDogXCLQmNC30LzQtdC90LjRgtGMINGA0LDQt9C80LXRgCDRh9Cw0YDRgtCwXCJcblx0ICB9LFxuXHQgIHJpY2h0ZXh0OiB7XG5cdCAgICB1bmRlcmxpbmU6IFwi0J/QvtC00YfQtdGA0LrQuNCy0LDQvdC40LVcIixcblx0ICAgIGJvbGQ6IFwi0JbQuNGA0L3Ri9C5XCIsXG5cdCAgICBpdGFsaWM6IFwi0JrRg9GA0YHQuNCyXCJcblx0ICB9LFxuXHQgIGNvbWJvOiB7XG5cdCAgICBzZWxlY3Q6IFwi0JLRi9Cx0YDQsNGC0YxcIixcblx0ICAgIHNlbGVjdEFsbDogXCLQktGL0LHRgNCw0YLRjCDQstGB0LVcIixcblx0ICAgIHVuc2VsZWN0QWxsOiBcItCh0LHRgNC+0YEg0LLRi9Cx0L7RgNCwXCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcIk9LXCIsXG5cdCAgICBjYW5jZWw6IFwi0J7RgtC80LXQvdCwXCJcblx0ICB9LFxuXHQgIGNvbW1lbnRzOiB7XG5cdCAgICBzZW5kOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuXHQgICAgY29uZmlybU1lc3NhZ2U6IFwi0JrQvtC80LzQtdC90YLQsNGA0LjQuSDQsdGD0LTQtdGCINGD0LTQsNC70LXQvS4g0JLRiyDRg9Cy0LXRgNC10L3Riz9cIixcblx0ICAgIGVkaXQ6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0YxcIixcblx0ICAgIHJlbW92ZTogXCLQo9C00LDQu9C40YLRjFwiLFxuXHQgICAgcGxhY2Vob2xkZXI6IFwi0JLQstC10LTQuNGC0LUg0YLQtdC60YHRgi4uXCIsXG5cdCAgICBtb3JlQ29tbWVudHM6IFwi0JHQvtC70YzRiNC1INC60L7QvNC80LXQvdGC0LDRgNC40LXQslwiXG5cdCAgfVxuXHR9O1xuXG5cdHZhciBiZSA9IHtcblx0ICBncm91cERlbGltaXRlcjogXCIgXCIsXG5cdCAgZ3JvdXBTaXplOiAzLFxuXHQgIGRlY2ltYWxEZWxpbWl0ZXI6IFwiLFwiLFxuXHQgIGRlY2ltYWxTaXplOiAyLFxuXHQgIGRhdGVGb3JtYXQ6IFwiJWQuJW0uJVlcIixcblx0ICB0aW1lRm9ybWF0OiBcIiVIOiVpXCIsXG5cdCAgbG9uZ0RhdGVGb3JtYXQ6IFwiJWQgJUYgJVlcIixcblx0ICBmdWxsRGF0ZUZvcm1hdDogXCIlZC4lbS4lWSAlSDolaVwiLFxuXHQgIHByaWNlOiBcIntvYmp9INGA0YPQsS5cIixcblx0ICBwcmljZVNldHRpbmdzOiB7XG5cdCAgICBncm91cFNpemU6IDMsXG5cdCAgICBncm91cERlbGltaXRlcjogXCIgXCIsXG5cdCAgICBkZWNpbWFsRGVsaW1pdGVyOiBcIlwiLFxuXHQgICAgZGVjaW1hbFNpemU6IDBcblx0ICB9LFxuXHQgIGNhbGVuZGFyOiB7XG5cdCAgICBtb250aEZ1bGw6IFtcItCh0YLRg9C00LfQtdC90YxcIiwgXCLQm9GO0YLRi1wiLCBcItCh0LDQutCw0LLRltC6XCIsIFwi0JrRgNCw0YHQsNCy0ZbQulwiLCBcItCi0YDQsNCy0LXQvdGMXCIsIFwi0KfRjdGA0LLQtdC90YxcIiwgXCLQm9GW0L/QtdC90YxcIiwgXCLQltC90ZbQstC10L3RjFwiLCBcItCS0LXRgNCw0YHQtdC90YxcIiwgXCLQmtCw0YHRgtGA0YvRh9C90ZbQulwiLCBcItCb0ZbRgdGC0LDQv9Cw0LRcIiwgXCLQodC90LXQttCw0L3RjFwiXSxcblx0ICAgIG1vbnRoU2hvcnQ6IFtcItCh0YLRg9C00LdcIiwgXCLQm9GO0YJcIiwgXCLQodCw0LpcIiwgXCLQmtGA0LDRgVwiLCBcItCi0YDQsNCyXCIsIFwi0KfRjdGAXCIsIFwi0JvRltC/XCIsIFwi0JbQvdGW0LJcIiwgXCLQktC10YBcIiwgXCLQmtCw0YHRglwiLCBcItCb0ZbRgdGCXCIsIFwi0KHQvdC10LZcIl0sXG5cdCAgICBkYXlGdWxsOiBbXCLQndGP0LTQt9C10LvRj1wiLCBcItCf0LDQvdGP0LTQt9C10LvQsNC6XCIsIFwi0JDRntGC0L7RgNCw0LpcIiwgXCLQodC10YDQsNC00LBcIiwgXCLQp9Cw0YbQstC10YBcIiwgXCLQn9GP0YLQvdGW0YbQsFwiLCBcItCh0YPQsdC+0YLQsFwiXSxcblx0ICAgIGRheVNob3J0OiBbXCLQndC0XCIsIFwi0J/QvVwiLCBcItCQ0Z7RglwiLCBcItCh0YBcIiwgXCLQp9GG0LJcIiwgXCLQn9GCXCIsIFwi0KHQsVwiXSxcblx0ICAgIGhvdXJzOiBcItCT0LDQtNC30ZbQvdGLXCIsXG5cdCAgICBtaW51dGVzOiBcItCl0LLRltC70ZbQvdGLXCIsXG5cdCAgICBkb25lOiBcItCT0LDRgtC+0LLQsFwiLFxuXHQgICAgdG9kYXk6IFwiQ9GR0L3QvdGPXCIsXG5cdCAgICBjbGVhcjogXCLQkNGH0YvRgdGG0ZbRhtGMXCJcblx0ICB9LFxuXHQgIGRhdGFFeHBvcnQ6IHtcblx0ICAgIHBhZ2U6IFwi0KHRgtCw0YDQvtC90LrQsFwiLFxuXHQgICAgb2Y6IFwi0LdcIlxuXHQgIH0sXG5cdCAgUERGdmlld2VyOiB7XG5cdCAgICBvZjogXCLQt1wiLFxuXHQgICAgYXV0b21hdGljWm9vbTogXCLQkNGe0YLQsNC80LDRgtGL0YfQvdGLINC30YPQvFwiLFxuXHQgICAgYWN0dWFsU2l6ZTogXCLQodCw0L/RgNCw0Z7QtNC90Ysg0L/QsNC80LXRgFwiLFxuXHQgICAgcGFnZUZpdDogXCLQn9Cw0LzQtdGAINGB0YLQsNGA0L7QvdC60ZZcIixcblx0ICAgIHBhZ2VXaWR0aDogXCLQqNGL0YDRi9C90Y8g0YHRgtCw0YDQvtC90LrRllwiLFxuXHQgICAgcGFnZUhlaWdodDogXCLQktGL0YjRi9C90Y8g0YHRgtCw0YDQvtC90LrRllwiLFxuXHQgICAgZW50ZXJQYXNzd29yZDogXCLQo9Cy0Y/QtNC30ZbRhtC1INC/0LDRgNC+0LvRjFwiLFxuXHQgICAgcGFzc3dvcmRFcnJvcjogXCLQndGP0L/RgNCw0LLRltC70YzQvdGLINC/0LDRgNC+0LvRjFwiXG5cdCAgfSxcblx0ICBhcmlhOiB7XG5cdCAgICBjYWxlbmRhcjogXCLQmtCw0LvRj9C90LTQsNGAXCIsXG5cdCAgICBpbmNyZWFzZVZhbHVlOiBcItCf0LDQstGP0LvRltGH0YvRhtGMINC30L3QsNGH0Y3QvdC90LVcIixcblx0ICAgIGRlY3JlYXNlVmFsdWU6IFwi0J/QsNC80LXQvdGI0YvRhtGMINC30L3QsNGH0Y3QvdC90LVcIixcblx0ICAgIG5hdk1vbnRoOiBbXCLQn9Cw0L/Rj9GA0Y3QtNC90ZYg0LzQtdGB0Y/RhlwiLCBcItCd0LDRgdGC0YPQv9C90Ysg0LzQtdGB0Y/RhlwiXSxcblx0ICAgIG5hdlllYXI6IFtcItCf0LDQv9GP0YDRjdC00L3RliDQs9C+0LRcIiwgXCLQndCw0YHRgtGD0L/QvdGLINCz0L7QtFwiXSxcblx0ICAgIG5hdkRlY2FkZTogW1wi0J/QsNC/0Y/RgNGN0LTQvdGW0Y8g0LTQt9C10YHRj9GG0Ywg0LPQvtC0XCIsIFwi0J3QsNGB0YLRg9C/0L3Ri9GPINC00LfQtdGB0Y/RhtGMINCz0L7QtFwiXSxcblx0ICAgIGRhdGVGb3JtYXQ6IFwiJWQgJUYgJVlcIixcblx0ICAgIG1vbnRoRm9ybWF0OiBcIiVGICVZXCIsXG5cdCAgICB5ZWFyRm9ybWF0OiBcIiVZXCIsXG5cdCAgICBob3VyRm9ybWF0OiBcIkhvdXJzOiAlaFwiLFxuXHQgICAgbWludXRlRm9ybWF0OiBcItCT0LDQtNC30ZbQvdGLOiAlaVwiLFxuXHQgICAgcmVtb3ZlSXRlbTogXCLQn9GA0YvQsdGA0LDRhtGMINGN0LvQtdC80LXQvdGCXCIsXG5cdCAgICBwYWdlczogW1wi0J/QtdGA0YjQsNGPINGB0YLQsNGA0L7QvdC60LBcIiwgXCLQn9Cw0L/Rj9GA0Y3QtNC90Y/RjyDRgdGC0LDRgNC+0L3QutCwXCIsIFwi0J3QsNGB0YLRg9C/0L3QsNGPINGB0YLQsNGA0L7QvdC60LBcIiwgXCLQkNC/0L7RiNC90Y/RjyDRgdGC0LDRgNC+0L3QutCwXCJdLFxuXHQgICAgcGFnZTogXCLQodGC0LDRgNC+0L3QutCwXCIsXG5cdCAgICBoZWFkZXJtZW51OiBcItCc0LXQvdGOINC30LDQs9Cw0LvQvtGe0LrQsFwiLFxuXHQgICAgb3Blbkdyb3VwOiBcItCQ0LTQutGA0YvRhtGMINCz0YDRg9C/0YMg0YHQu9GD0L/QutC+0Z5cIixcblx0ICAgIGNsb3NlR3JvdXA6IFwi0JfQsNC60YDRi9GG0Ywg0LPRgNGD0L/RgyDRgdC70YPQv9C60L7RnlwiLFxuXHQgICAgY2xvc2VUYWI6IFwi0JfQsNC60YDRi9GG0Ywg0YPQutC70LDQtNC60YNcIixcblx0ICAgIHNob3dUYWJzOiBcItCf0LDQutCw0LfQsNGG0Ywg0LHQvtC70YzRiCDRg9C60LvQsNC00LDQulwiLFxuXHQgICAgcmVzZXRUcmVlTWFwOiBcItCS0Y/RgNC90YPRhtGG0LAg0LTQsCDQv9C10YDRiNCw0L/QsNGH0LDRgtC60L7QstCw0LPQsCDQstGL0LPQu9GP0LTRg1wiLFxuXHQgICAgbmF2VHJlZU1hcDogXCLQn9Cw0LTQvdGP0YbRhtCwINC90LAg0Z7Qt9GA0L7QstC10L3RjCDQstGL0YjRjdC5XCIsXG5cdCAgICBuZXh0VGFiOiBcItCd0LDRgdGC0YPQv9C90LDRjyDRntC60LvQsNC00LrQsFwiLFxuXHQgICAgcHJldlRhYjogXCLQn9Cw0L/Rj9GA0Y3QtNC90Y/RjyDRntC60LvQsNC00LrQsFwiLFxuXHQgICAgbXVsdGl0ZXh0U2VjdGlvbjogXCLQlNCw0LTQsNGG0Ywg0Y3Qu9C10LzQtdC90YJcIixcblx0ICAgIG11bHRpdGV4dGV4dHJhU2VjdGlvbjogXCLQn9GA0YvQsdGA0LDRhtGMINGN0LvQtdC80LXQvdGCXCIsXG5cdCAgICBzaG93Q2hhcnQ6IFwi0J/QsNC60LDQt9Cw0YbRjCDQs9GA0LDRhNGW0LpcIixcblx0ICAgIGhpZGVDaGFydDogXCLQodGF0LDQstCw0YbRjCDQs9GA0LDRhNGW0LpcIixcblx0ICAgIHJlc2l6ZUNoYXJ0OiBcItCX0LzRj9C90ZbRhtGMINC/0LDQvNC10YAg0LPRgNCw0YTRltC60LBcIlxuXHQgIH0sXG5cdCAgcmljaHRleHQ6IHtcblx0ICAgIHVuZGVybGluZTogXCLQn9Cw0LTQutGA0Y3RgdC70ZbQstCw0L3QvdC1XCIsXG5cdCAgICBib2xkOiBcItCf0LDRntGC0LvRg9GB0YLRi1wiLFxuXHQgICAgaXRhbGljOiBcItCa0YPRgNGB0ZbRnlwiXG5cdCAgfSxcblx0ICBjb21ibzoge1xuXHQgICAgc2VsZWN0OiBcItCQ0LHRgNCw0YbRjFwiLFxuXHQgICAgc2VsZWN0QWxsOiBcItCQ0LHRgNCw0YbRjCDRg9GB0ZFcIixcblx0ICAgIHVuc2VsZWN0QWxsOiBcItCQ0YfRi9GB0YbRltGG0Ywg0Z7RgdC1XCJcblx0ICB9LFxuXHQgIG1lc3NhZ2U6IHtcblx0ICAgIG9rOiBcItCe0JpcIixcblx0ICAgIGNhbmNlbDogXCLQkNC00LzQtdC90LBcIlxuXHQgIH0sXG5cdCAgY29tbWVudHM6IHtcblx0ICAgIHNlbmQ6IFwi0JTQsNGB0LvQsNGG0YxcIixcblx0ICAgIGNvbmZpcm1NZXNzYWdlOiBcItCa0LDQvNC10L3RgtCw0YDRi9C5INCx0YPQtNC30LUg0LLRi9C00LDQu9C10L3Riy4g0JLRiyDRntC/0Y3RntC90LXQvdGLP1wiLFxuXHQgICAgZWRpdDogXCLQoNGN0LTQsNCz0LDQstCw0YbRjFwiLFxuXHQgICAgcmVtb3ZlOiBcItCS0YvQtNCw0LvRltGG0YxcIixcblx0ICAgIHBsYWNlaG9sZGVyOiBcItCf0ZbRiNGL0YbQtSDRgtGD0YIuLlwiLFxuXHQgICAgbW9yZUNvbW1lbnRzOiBcItCR0L7Qu9GM0Ygg0LrQsNC80LXQvdGC0LDRgNGL0Y/RnlwiXG5cdCAgfVxuXHR9O1xuXG5cdC8vIGVuLUVOIGxvY2FsZSBpcyBidW5kbGVkIGJ5IGRlZmF1bHRcblx0aTE4bi5sb2NhbGVzW1wiZGUtREVcIl0gPSBkZTsgLy8gc3BhaW5cblx0aTE4bi5sb2NhbGVzW1wiZXMtRVNcIl0gPSBlczsgLy8gZnJhbmNlXG5cdGkxOG4ubG9jYWxlc1tcImZyLUZSXCJdID0gZnI7IC8vIGl0YWx5XG5cdGkxOG4ubG9jYWxlc1tcIml0LUlUXCJdID0gaXQ7IC8vIGphcGFuXG5cdGkxOG4ubG9jYWxlc1tcImphLUpQXCJdID0gamE7IC8vIHBvcnR1Z3Vlc2Vcblx0aTE4bi5sb2NhbGVzW1wicHQtQlJcIl0gPSBwdDsgLy8gY2hpbmVzZVxuXHRpMThuLmxvY2FsZXNbXCJ6aC1DTlwiXSA9IHpoOyAvLyBydXNzaWFuXG5cdGkxOG4ubG9jYWxlc1tcInJ1LVJVXCJdID0gcnU7IC8vIGJlbGFydXNcblx0aTE4bi5sb2NhbGVzW1wiYmUtQllcIl0gPSBiZTtcblxuXHR2YXIgYXBpJDQgPSB7XG5cdCAgbmFtZTogXCJiYXNlbGF5b3V0XCIsXG5cdCAgcmVzdG9yZTogZnVuY3Rpb24gKHN0YXRlJCQxLCBmYWN0b3J5LCBjb25maWdPbmx5KSB7XG5cdCAgICB2YXIgb3V0ID0gdGhpcy5fcmVzdG9yZShjb3B5KHN0YXRlJCQxKSwgZmFjdG9yeSk7XG5cblx0ICAgIGlmIChjb25maWdPbmx5KSByZXR1cm4gb3V0O2Vsc2UgdWkob3V0LmNvbHMgfHwgb3V0LnJvd3MsIHRoaXMpO1xuXHQgIH0sXG5cdCAgX3Jlc3RvcmU6IGZ1bmN0aW9uIChzdGF0ZSQkMSwgZmFjdG9yeSkge1xuXHQgICAgaWYgKHN0YXRlJCQxLiRsYXlvdXQpIHtcblx0ICAgICAgdmFyIHN1YiA9IHN0YXRlJCQxLmNvbHMgfHwgc3RhdGUkJDEucm93cztcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1Yi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHN1YltpXSA9IHRoaXMuX3Jlc3RvcmUoc3ViW2ldLCBmYWN0b3J5KTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGZhY3RvcnkuY2FsbCh0aGlzLCBzdGF0ZSQkMSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzdGF0ZSQkMTtcblx0ICB9LFxuXHQgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKHNlcmlhbGl6ZXIpIHtcblx0ICAgIHZhciBvdXQgPSBbXTtcblx0ICAgIHZhciBjaGlsZHMgPSB0aGlzLmdldENoaWxkVmlld3MoKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHN1YiA9IGNoaWxkc1tpXTtcblxuXHQgICAgICBpZiAoc3ViLm1vdmVQb3J0bGV0KSB7XG5cdCAgICAgICAgdmFyIGNoaWxkID0gc3ViLmdldENoaWxkVmlld3MoKTtcblx0ICAgICAgICBvdXQucHVzaChzZXJpYWxpemVyLmNhbGwodGhpcywgY2hpbGRbY2hpbGQubGVuZ3RoIC0gMV0pKTtcblx0ICAgICAgfSBlbHNlIGlmIChzdWIuc2VyaWFsaXplKSB7XG5cdCAgICAgICAgLy8gc29tZSBraW5kIG9mIGxheW91dFxuXHQgICAgICAgIG91dC5wdXNoKHN1Yi5zZXJpYWxpemUoc2VyaWFsaXplciwgdHJ1ZSkpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIGxlYWYgdmlld1xuXHQgICAgICAgIG91dC5wdXNoKHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBzdWIpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgb2JqID0ge1xuXHQgICAgICAkbGF5b3V0OiB0cnVlLFxuXHQgICAgICB0eXBlOiB0aGlzLmNvbmZpZy50eXBlXG5cdCAgICB9O1xuXHQgICAgaWYgKHRoaXMuY29uZmlnLnJvd3MpIG9iai5yb3dzID0gb3V0O2Vsc2Ugb2JqLmNvbHMgPSBvdXQ7XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fcGFyc2VfY2VsbHMpO1xuXHQgICAgdGhpcy5fZGF0YW9iaiA9IHRoaXMuX2NvbnRlbnRvYmo7XG5cdCAgICB0aGlzLl9sYXlvdXRfc2l6ZXMgPSBbXTtcblx0ICAgIHRoaXMuX3Jlc3BvbnNpdmUgPSBbXTtcblx0ICAgIHRoaXMuX3BhZGRpbmcgPSB7XG5cdCAgICAgIHRvcDogMCxcblx0ICAgICAgbGVmdDogMCxcblx0ICAgICAgcmlnaHQ6IDAsXG5cdCAgICAgIGJvdHRvbTogMFxuXHQgICAgfTtcblxuXHQgICAgaWYgKGNvbmZpZy4kdG9wVmlldykge1xuXHQgICAgICBjb25maWcuYm9yZGVybGVzcyA9IHRydWU7XG5cdCAgICAgIGNvbmZpZy5faW5uZXIgPSB7XG5cdCAgICAgICAgdG9wOiB0cnVlLFxuXHQgICAgICAgIGxlZnQ6IHRydWUsXG5cdCAgICAgICAgYm90dG9tOiB0cnVlLFxuXHQgICAgICAgIHJpZ2h0OiB0cnVlXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb25maWcuaXNvbGF0ZSkgZXhwb3J0cy5leHRlbmQodGhpcywgSWRTcGFjZSk7XG5cdCAgfSxcblx0ICByb3dzX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbiA9IDE7XG5cdCAgICB0aGlzLl9jb2xsZWN0aW9uID0gdmFsdWU7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIGNvbHNfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID0gMDtcblx0ICAgIHRoaXMuJHZpZXcuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG5cdCAgICB0aGlzLl9jb2xsZWN0aW9uID0gdmFsdWU7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF9yZW1vdmU6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICBQb3dlckFycmF5LnJlbW92ZUF0LmNhbGwodGhpcy5fY2VsbHMsIFBvd2VyQXJyYXkuZmluZC5jYWxsKHRoaXMuX2NlbGxzLCB2aWV3KSk7XG5cdCAgICB0aGlzLnJlc2l6ZUNoaWxkcmVuKHRydWUpO1xuXHQgIH0sXG5cdCAgX3JlcGxhY2U6IGZ1bmN0aW9uIChuZXdfdmlldywgdGFyZ2V0X2lkKSB7XG5cdCAgICBpZiAoaXNVbmRlZmluZWQodGFyZ2V0X2lkKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy5fY2VsbHNbaV0uZGVzdHJ1Y3RvcigpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IG5ld192aWV3O1xuXG5cdCAgICAgIHRoaXMuX3BhcnNlX2NlbGxzKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgc291cmNlO1xuXG5cdCAgICAgIGlmICh0eXBlb2YgdGFyZ2V0X2lkID09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBpZiAodGFyZ2V0X2lkIDwgMCB8fCB0YXJnZXRfaWQgPiB0aGlzLl9jZWxscy5sZW5ndGgpIHRhcmdldF9pZCA9IHRoaXMuX2NlbGxzLmxlbmd0aDtcblx0ICAgICAgICB2YXIgcHJldl9ub2RlID0gKHRoaXMuX2NlbGxzW3RhcmdldF9pZF0gfHwge30pLl92aWV3b2JqO1xuXHQgICAgICAgIFBvd2VyQXJyYXkuaW5zZXJ0QXQuY2FsbCh0aGlzLl9jZWxscywgbmV3X3ZpZXcsIHRhcmdldF9pZCk7XG5cdCAgICAgICAgaWYgKCFuZXdfdmlldy5fc2V0dGluZ3MuaGlkZGVuKSBpbnNlcnRCZWZvcmUobmV3X3ZpZXcuX3ZpZXdvYmosIHByZXZfbm9kZSwgdGhpcy5fZGF0YW9iaik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgc291cmNlID0gJCQodGFyZ2V0X2lkKTtcblx0ICAgICAgICB0YXJnZXRfaWQgPSBQb3dlckFycmF5LmZpbmQuY2FsbCh0aGlzLl9jZWxscywgc291cmNlKTtcblx0ICAgICAgICBhc3NlcnQodGFyZ2V0X2lkICE9IC0xLCBcIkF0dGVtcHQgdG8gcmVwbGFjZSB0aGUgbm9uLWV4aXN0aW5nIHZpZXdcIik7XG5cdCAgICAgICAgdmFyIHBhcmVudCA9IHNvdXJjZS5fdmlld29iai5wYXJlbnROb2RlO1xuXHQgICAgICAgIGlmIChwYXJlbnQgJiYgIW5ld192aWV3Ll9zZXR0aW5ncy5oaWRkZW4pIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3X3ZpZXcuX3ZpZXdvYmosIHNvdXJjZS5fdmlld29iaik7XG5cdCAgICAgICAgc291cmNlLmRlc3RydWN0b3IoKTtcblx0ICAgICAgICB0aGlzLl9jZWxsc1t0YXJnZXRfaWRdID0gbmV3X3ZpZXc7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIXRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uKSB0aGlzLl9maXhfdmVydGljYWxfbGF5b3V0KG5ld192aWV3KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5yZXNpemVDaGlsZHJlbih0cnVlKTtcblx0ICAgIHZhciBmb3JtID0gdGhpcy5lbGVtZW50cyA/IHRoaXMgOiB0aGlzLmdldEZvcm1WaWV3KCk7XG5cdCAgICBpZiAoZm9ybSkgZm9ybS5fcmVjb2xsZWN0X2VsZW1lbnRzKCk7XG5cdCAgICBjYWxsRXZlbnQoXCJvblJlY29uc3RydWN0XCIsIFt0aGlzXSk7XG5cdCAgfSxcblx0ICBfZml4X3ZlcnRpY2FsX2xheW91dDogZnVuY3Rpb24gKGNlbGwpIHtcblx0ICAgIGNlbGwuX3ZpZXdvYmouc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdCAgICBjZWxsLl92aWV3b2JqLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiO1xuXHQgIH0sXG5cdCAgYWRkVmlldzogZnVuY3Rpb24gKHZpZXcsIGluZGV4JCQxKSB7XG5cdCAgICBpZiAoaXNVbmRlZmluZWQoaW5kZXgkJDEpKSBpbmRleCQkMSA9IHRoaXMuX2NlbGxzLmxlbmd0aDtcblx0ICAgIHZhciB0b3AgPSB0aGlzLiQkID8gdGhpcyA6IHRoaXMuZ2V0VG9wUGFyZW50VmlldygpO1xuXHQgICAgc3RhdGUuX3BhcmVudF9jZWxsID0gdGhpcztcblx0ICAgIHZhciBuZXd1aSA9IHRvcCAmJiB0b3AudWkgPyB0b3AudWkodmlldywgdGhpcywgaW5kZXgkJDEpIDogdWkodmlldywgdGhpcywgaW5kZXgkJDEpO1xuXHQgICAgc3RhdGUuX3BhcmVudF9jZWxsID0gbnVsbDtcblx0ICAgIHJldHVybiBuZXd1aS5fc2V0dGluZ3MuaWQ7XG5cdCAgfSxcblx0ICByZW1vdmVWaWV3OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciB2aWV3O1xuXHQgICAgaWYgKF90eXBlb2YoaWQpICE9IFwib2JqZWN0XCIpIHZpZXcgPSAkJChpZCkgfHwgKHRoaXMuJCQgPyB0aGlzLiQkKGlkKSA6IG51bGwpO2Vsc2UgdmlldyA9IGlkO1xuXHQgICAgdmFyIHRhcmdldCA9IFBvd2VyQXJyYXkuZmluZC5jYWxsKHRoaXMuX2NlbGxzLCB2aWV3KTtcblxuXHQgICAgaWYgKHRhcmdldCA+PSAwKSB7XG5cdCAgICAgIGlmICh0aGlzLl9iZWZvcmVSZW1vdmVWaWV3KSB0aGlzLl9iZWZvcmVSZW1vdmVWaWV3KHRhcmdldCwgdmlldyk7XG5cdCAgICAgIHZhciBmb3JtID0gdGhpcy5lbGVtZW50cyA/IHRoaXMgOiB0aGlzLmdldEZvcm1WaWV3KCk7XG5cblx0ICAgICAgdGhpcy5fY2VsbHMuc3BsaWNlKHRhcmdldCwgMSk7XG5cblx0ICAgICAgaWYgKGZvcm0pIHVpLmVhY2godmlldywgZnVuY3Rpb24gKHN1Yikge1xuXHQgICAgICAgIGlmIChzdWIubmFtZSkgZGVsZXRlIGZvcm0uZ2V0Q2xlYW5WYWx1ZXMoKVtzdWIuY29uZmlnLm5hbWVdO1xuXHQgICAgICB9LCBmb3JtLCB0cnVlKTtcblx0ICAgICAgdmlldy5kZXN0cnVjdG9yKCk7XG5cdCAgICAgIHRoaXMucmVzaXplQ2hpbGRyZW4odHJ1ZSk7XG5cdCAgICAgIGlmIChmb3JtKSBmb3JtLl9yZWNvbGxlY3RfZWxlbWVudHMoKTtcblx0ICAgIH0gZWxzZSBhc3NlcnQoZmFsc2UsIFwiQXR0ZW1wIHRvIHJlbW92ZSBub3QgZXhpc3RpbmcgdmlldzogXCIgKyBpZCk7XG5cblx0ICAgIGNhbGxFdmVudChcIm9uUmVjb25zdHJ1Y3RcIiwgW3RoaXNdKTtcblx0ICB9LFxuXHQgIHJlY29uc3RydWN0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9oaWRkZW5jZWxscyA9IDA7XG5cblx0ICAgIHRoaXMuX3JlcGxhY2UodGhpcy5fY29sbGVjdGlvbik7XG5cdCAgfSxcblx0ICBfaGlkZTogZnVuY3Rpb24gKG9iaiwgc2V0dGluZ3MsIHNpbGVudCkge1xuXHQgICAgaWYgKG9iai5fc2V0dGluZ3MuaGlkZGVuKSByZXR1cm47XG5cdCAgICBvYmouX3NldHRpbmdzLmhpZGRlbiA9IHRydWU7XG5cdCAgICByZW1vdmUob2JqLl92aWV3b2JqKTtcblx0ICAgIHRoaXMuX2hpZGRlbmNlbGxzKys7XG5cdCAgICBpZiAoIXNpbGVudCAmJiAhc3RhdGUuX3VpX2NyZWF0aW9uKSB0aGlzLnJlc2l6ZUNoaWxkcmVuKHRydWUpO1xuXHQgIH0sXG5cdCAgX3NpZ25hbF9oaWRkZW5fY2VsbHM6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICBpZiAodmlldy5jYWxsRXZlbnQpIHZpZXcuY2FsbEV2ZW50KFwib25WaWV3U2hvd1wiLCBbXSk7XG5cdCAgfSxcblx0ICByZXNpemVDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHN0YXRlLl9mcmVlemVfcmVzaXplKSByZXR1cm47XG5cblx0ICAgIGlmICh0aGlzLl9sYXlvdXRfc2l6ZXMpIHtcblx0ICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50VmlldygpO1xuXG5cdCAgICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgICBpZiAocGFyZW50LnJlc2l6ZUNoaWxkcmVuKSByZXR1cm4gcGFyZW50LnJlc2l6ZUNoaWxkcmVuKCk7ZWxzZSByZXR1cm4gcGFyZW50LnJlc2l6ZSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHNpemVzID0gdGhpcy4kZ2V0U2l6ZSgwLCAwKTtcblx0ICAgICAgdmFyIHgsIHksIG54LCBueTtcblx0ICAgICAgbnggPSB4ID0gdGhpcy5fbGF5b3V0X3NpemVzWzBdIHx8IDA7XG5cdCAgICAgIG55ID0geSA9IHRoaXMuX2xheW91dF9zaXplc1sxXSB8fCAwOyAvL2ZvciBhdXRvLWZpbGwgY29udGVudCwgdXNlIGFkanVzdCBzdHJhdGVneVxuXG5cdCAgICAgIGlmICgoc2l6ZXNbMV0gPj0gMTAwMDAwIHx8IHNpemVzWzNdID49IDEwMDAwMCkgJiYgdGhpcy5fdmlld29iai5wYXJlbnROb2RlKSB7XG5cdCAgICAgICAgLy9pbiBoaWRkZW4gY29udGFpbmVyIGFkanVzdCBkb2Vzbid0IHdvcmssIHNvIGZhbGxiYWNrIHRvIGxhc3Qga25vd24gc2l6ZVxuXHQgICAgICAgIC8vYWxzbywgZW5zdXJlIHRoYXQgbWluLXNpemUgaXMgbm90IHZpb2xhdGVkXG5cdCAgICAgICAgbnggPSB4ID0gTWF0aC5tYXgoc2l6ZXNbMF0sIHRoaXMuX3NldHRpbmdzLndpZHRoIHx8IHRoaXMuX3ZpZXdvYmoucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCB8fCB4IHx8IDApO1xuXHQgICAgICAgIG55ID0geSA9IE1hdGgubWF4KHNpemVzWzJdLCB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgfHwgdGhpcy5fdmlld29iai5wYXJlbnROb2RlLm9mZnNldEhlaWdodCB8fCB5IHx8IDApO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFwYXJlbnQpIHtcblx0ICAgICAgICAvL21pbldpZHRoXG5cdCAgICAgICAgaWYgKHNpemVzWzBdID4geCkgbnggPSBzaXplc1swXTsgLy9taW5IZWlnaHRcblxuXHQgICAgICAgIGlmIChzaXplc1syXSA+IHkpIG55ID0gc2l6ZXNbMl07XG5cdCAgICAgICAgdmFyIGZ1bGxzY3JlZW4gPSB0aGlzLl92aWV3b2JqLnBhcmVudE5vZGUgPT0gZG9jdW1lbnQuYm9keSAmJiAhdGhpcy5zZXRQb3NpdGlvbjsgLy9tYXhXaWR0aCBydWxlXG5cblx0ICAgICAgICBpZiAoIWZ1bGxzY3JlZW4gJiYgeCA+IHNpemVzWzFdKSBueCA9IHNpemVzWzFdOyAvL21heEhlaWdodCBydWxlXG5cblx0ICAgICAgICBpZiAoIWZ1bGxzY3JlZW4gJiYgeSA+IHNpemVzWzNdKSBueSA9IHNpemVzWzNdO1xuXHQgICAgICAgIHRoaXMuJHNldFNpemUobngsIG55KTtcblx0ICAgICAgfSBlbHNlIHRoaXMuX3NldF9jaGlsZF9zaXplKHgsIHkpO1xuXG5cdCAgICAgIGlmIChzdGF0ZS5fcmVzcG9uc2l2ZV9leGNlcHRpb24pIHtcblx0ICAgICAgICBzdGF0ZS5fcmVzcG9uc2l2ZV9leGNlcHRpb24gPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLnJlc2l6ZUNoaWxkcmVuKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjYWxsRXZlbnQoXCJvblJlc2l6ZVwiLCBbXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRDaGlsZFZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fY2VsbHM7XG5cdCAgfSxcblx0ICBpbmRleDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgaWYgKG9iai5fc2V0dGluZ3MpIG9iaiA9IG9iai5fc2V0dGluZ3MuaWQ7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuX2NlbGxzW2ldLl9zZXR0aW5ncy5pZCA9PSBvYmopIHJldHVybiBpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfSxcblx0ICBfc2hvdzogZnVuY3Rpb24gKG9iaiwgc2V0dGluZ3MsIHNpbGVudCkge1xuXHQgICAgaWYgKCFvYmouX3NldHRpbmdzLmhpZGRlbikgcmV0dXJuO1xuXHQgICAgb2JqLl9zZXR0aW5ncy5oaWRkZW4gPSBmYWxzZTsgLy9pbmRleCBvZiBzaWJsaW5nIGNlbGwsIG5leHQgdG8gd2hpY2ggbmV3IGl0ZW0gd2lsbCBhcHBlYXJcblxuXHQgICAgdmFyIGluZGV4JCQxID0gdGhpcy5pbmRleChvYmopICsgMTsgLy9sb2NhdGUgbmVhcmVzdCB2aXNpYmxlIGNlbGxcblxuXHQgICAgd2hpbGUgKHRoaXMuX2NlbGxzW2luZGV4JCQxXSAmJiB0aGlzLl9jZWxsc1tpbmRleCQkMV0uX3NldHRpbmdzLmhpZGRlbikge1xuXHQgICAgICBpbmRleCQkMSsrO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdmlldyA9IHRoaXMuX2NlbGxzW2luZGV4JCQxXSA/IHRoaXMuX2NlbGxzW2luZGV4JCQxXS5fdmlld29iaiA6IG51bGw7XG5cdCAgICBpbnNlcnRCZWZvcmUob2JqLl92aWV3b2JqLCB2aWV3LCB0aGlzLl9kYXRhb2JqIHx8IHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgdGhpcy5faGlkZGVuY2VsbHMtLTtcblxuXHQgICAgaWYgKCFzaWxlbnQpIHtcblx0ICAgICAgdGhpcy5yZXNpemVDaGlsZHJlbih0cnVlKTtcblx0ICAgICAgaWYgKG9iai5yZWZyZXNoKSBvYmoucmVmcmVzaCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob2JqLmNhbGxFdmVudCkge1xuXHQgICAgICBvYmouY2FsbEV2ZW50KFwib25WaWV3U2hvd1wiLCBbXSk7XG5cdCAgICAgIHVpLmVhY2gob2JqLCB0aGlzLl9zaWduYWxfaGlkZGVuX2NlbGxzKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHNob3dCYXRjaDogZnVuY3Rpb24gKG5hbWUsIG1vZGUpIHtcblx0ICAgIHZhciBwcmVzZXJ2ZSA9IHR5cGVvZiBtb2RlICE9IFwidW5kZWZpbmVkXCI7XG5cdCAgICBtb2RlID0gbW9kZSAhPT0gZmFsc2U7XG5cblx0ICAgIGlmICghcHJlc2VydmUpIHtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnZpc2libGVCYXRjaCA9PSBuYW1lKSByZXR1cm47XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnZpc2libGVCYXRjaCA9IG5hbWU7XG5cdCAgICB9IGVsc2UgdGhpcy5fc2V0dGluZ3MudmlzaWJsZUJhdGNoID0gXCJcIjtcblxuXHQgICAgdmFyIHNob3cgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoIXRoaXMuX2NlbGxzW2ldLl9zZXR0aW5ncy5iYXRjaCAmJiAhdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmhpZGRlbikgc2hvdy5wdXNoKHRoaXMuX2NlbGxzW2ldKTtlbHNlIGlmICh0aGlzLl9jZWxsc1tpXS5fc2V0dGluZ3MuYmF0Y2ggPT0gbmFtZSkge1xuXHQgICAgICAgIGlmIChtb2RlKSBzaG93LnB1c2godGhpcy5fY2VsbHNbaV0pO2Vsc2UgdGhpcy5faGlkZSh0aGlzLl9jZWxsc1tpXSwgbnVsbCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoIXByZXNlcnZlKSB0aGlzLl9oaWRlKHRoaXMuX2NlbGxzW2ldLCBudWxsLCB0cnVlKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNob3cubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIHRoaXMuX3Nob3coc2hvd1tfaV0sIG51bGwsIHRydWUpO1xuXG5cdCAgICAgIHNob3dbX2ldLl9yZW5kZXJfaGlkZGVuX3ZpZXdzKCk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucmVzaXplQ2hpbGRyZW4odHJ1ZSk7XG5cdCAgfSxcblx0ICBfcGFyc2VfY2VsbHM6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG5cdCAgICB0aGlzLl9jZWxscyA9IFtdO1xuXHQgICAgYXNzZXJ0KGNvbGxlY3Rpb24sIHRoaXMubmFtZSArIFwiIHdhcyBpbmNvcnJlY3RseSBkZWZpbmVkLiA8YnI+PGJyPiBZb3UgaGF2ZSBtaXNzZWQgcm93c3xjb2xzfGNlbGxzfGVsZW1lbnRzIGNvbGxlY3Rpb25cIik7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSB0aGlzO1xuXHQgICAgICBpZiAoIWNvbGxlY3Rpb25baV0uX2lubmVyKSBjb2xsZWN0aW9uW2ldLmJvcmRlcmxlc3MgPSB0cnVlO1xuXHQgICAgICB0aGlzLl9jZWxsc1tpXSA9IHVpLl92aWV3KGNvbGxlY3Rpb25baV0sIHRoaXMpO1xuXHQgICAgICBpZiAoIXRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uKSB0aGlzLl9maXhfdmVydGljYWxfbGF5b3V0KHRoaXMuX2NlbGxzW2ldKTtcblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudmlzaWJsZUJhdGNoICYmIHRoaXMuX3NldHRpbmdzLnZpc2libGVCYXRjaCAhPSB0aGlzLl9jZWxsc1tpXS5fc2V0dGluZ3MuYmF0Y2ggJiYgdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmJhdGNoKSB7XG5cdCAgICAgICAgdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmhpZGRlbiA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5faGlkZGVuY2VsbHMrKztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmhpZGRlbikge1xuXHQgICAgICAgICh0aGlzLl9kYXRhb2JqIHx8IHRoaXMuX2NvbnRlbnRvYmopLmFwcGVuZENoaWxkKHRoaXMuX2NlbGxzW2ldLl92aWV3b2JqKTtcblxuXHQgICAgICAgIGlmICh0aGlzLl9jZWxsc1tpXS4kbm9zcGFjZSkgdGhpcy5faGlkZGVuY2VsbHMrKztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fcGFyc2VfY2VsbHNfZXh0X2VuZCkgdGhpcy5fcGFyc2VfY2VsbHNfZXh0X2VuZChjb2xsZWN0aW9uKTtcblx0ICB9LFxuXHQgIF9idWJibGVfc2l6ZTogZnVuY3Rpb24gKHByb3AsIHNpemUsIHZlcnRpY2FsKSB7XG5cdCAgICBpZiAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gIT0gdmVydGljYWwpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzW3Byb3BdID0gc2l6ZTtcblx0ICAgICAgaWYgKHRoaXMuX2NlbGxzW2ldLl9idWJibGVfc2l6ZSkgdGhpcy5fY2VsbHNbaV0uX2J1YmJsZV9zaXplKHByb3AsIHNpemUsIHZlcnRpY2FsKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICBkZWJ1Z19zaXplX2JveF9zdGFydCh0aGlzLCB0cnVlKTtcblx0ICAgIHZhciBtaW5XaWR0aCA9IDA7XG5cdCAgICB2YXIgbWF4V2lkdGggPSAxMDAwMDA7XG5cdCAgICB2YXIgbWF4SGVpZ2h0ID0gMTAwMDAwO1xuXHQgICAgdmFyIG1pbkhlaWdodCA9IDA7XG5cdCAgICBpZiAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24pIG1heEhlaWdodCA9IDA7ZWxzZSBtYXhXaWR0aCA9IDA7XG5cdCAgICB2YXIgZml4ZWQgPSAwO1xuXHQgICAgdmFyIGZpeGVkX2NvdW50ID0gMDtcblx0ICAgIHZhciBncmF2aXR5ID0gMDtcblx0ICAgIHRoaXMuX3NpemVzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy9pZ25vcmUgaGlkZGVuIGNlbGxzXG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tpXS5fc2V0dGluZ3MuaGlkZGVuKSBjb250aW51ZTtcblxuXHQgICAgICB2YXIgc2l6ZXMgPSB0aGlzLl9zaXplc1tpXSA9IHRoaXMuX2NlbGxzW2ldLiRnZXRTaXplKDAsIDApO1xuXG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tpXS4kbm9zcGFjZSkge1xuXHQgICAgICAgIGZpeGVkX2NvdW50Kys7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24pIHtcblx0ICAgICAgICAvL3Rha2UgbWF4IG1pblNpemUgdmFsdWVcblx0ICAgICAgICBpZiAoc2l6ZXNbMF0gPiBtaW5XaWR0aCkgbWluV2lkdGggPSBzaXplc1swXTsgLy90YWtlIG1pbiBtYXhTaXplIHZhbHVlXG5cblx0ICAgICAgICBpZiAoc2l6ZXNbMV0gPCBtYXhXaWR0aCkgbWF4V2lkdGggPSBzaXplc1sxXTtcblx0ICAgICAgICBtaW5IZWlnaHQgKz0gc2l6ZXNbMl07XG5cdCAgICAgICAgbWF4SGVpZ2h0ICs9IHNpemVzWzNdO1xuXG5cdCAgICAgICAgaWYgKHNpemVzWzJdID09IHNpemVzWzNdICYmIHNpemVzWzJdICE9IC0xKSB7XG5cdCAgICAgICAgICBmaXhlZCArPSBzaXplc1syXTtcblx0ICAgICAgICAgIGZpeGVkX2NvdW50Kys7XG5cdCAgICAgICAgfSBlbHNlIGdyYXZpdHkgKz0gc2l6ZXNbNF07XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy90YWtlIG1heCBtaW5TaXplIHZhbHVlXG5cdCAgICAgICAgaWYgKHNpemVzWzJdID4gbWluSGVpZ2h0KSBtaW5IZWlnaHQgPSBzaXplc1syXTsgLy90YWtlIG1pbiBtYXhTaXplIHZhbHVlXG5cblx0ICAgICAgICBpZiAoc2l6ZXNbM10gPCBtYXhIZWlnaHQpIG1heEhlaWdodCA9IHNpemVzWzNdO1xuXHQgICAgICAgIG1pbldpZHRoICs9IHNpemVzWzBdO1xuXHQgICAgICAgIG1heFdpZHRoICs9IHNpemVzWzFdO1xuXG5cdCAgICAgICAgaWYgKHNpemVzWzBdID09IHNpemVzWzFdICYmIHNpemVzWzBdICE9IC0xKSB7XG5cdCAgICAgICAgICBmaXhlZCArPSBzaXplc1swXTtcblx0ICAgICAgICAgIGZpeGVkX2NvdW50Kys7XG5cdCAgICAgICAgfSBlbHNlIGdyYXZpdHkgKz0gc2l6ZXNbNF07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKG1pbkhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gbWluSGVpZ2h0O1xuXHQgICAgaWYgKG1pbldpZHRoID4gbWF4V2lkdGgpIG1heFdpZHRoID0gbWluV2lkdGg7XG5cdCAgICB0aGlzLl9tYXN0ZXJfc2l6ZSA9IFtmaXhlZCwgdGhpcy5fY2VsbHMubGVuZ3RoIC0gZml4ZWRfY291bnQsIGdyYXZpdHldO1xuXHQgICAgdGhpcy5fZGVzaXJlZF9zaXplID0gW21pbldpZHRoICsgZHgsIG1pbkhlaWdodCArIGR5XTsgLy9nZXQgbGF5b3V0IHNpemVzXG5cblx0ICAgIHZhciBzZWxmX3NpemUgPSBiYXNldmlldy5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCAwLCAwKTsgLy91c2UgY2hpbGQgc2V0dGluZ3MgaWYgbGF5b3V0J3Mgb25lIHdhcyBub3QgZGVmaW5lZFxuXG5cdCAgICBpZiAoc2VsZl9zaXplWzFdID49IDEwMDAwMCkgc2VsZl9zaXplWzFdID0gMDtcblx0ICAgIGlmIChzZWxmX3NpemVbM10gPj0gMTAwMDAwKSBzZWxmX3NpemVbM10gPSAwO1xuXHQgICAgc2VsZl9zaXplWzBdID0gKHNlbGZfc2l6ZVswXSB8fCBtaW5XaWR0aCkgKyBkeDtcblx0ICAgIHNlbGZfc2l6ZVsxXSA9IE1hdGgubWF4KHNlbGZfc2l6ZVswXSwgKHNlbGZfc2l6ZVsxXSB8fCBtYXhXaWR0aCkgKyBkeCk7XG5cdCAgICBzZWxmX3NpemVbMl0gPSAoc2VsZl9zaXplWzJdIHx8IG1pbkhlaWdodCkgKyBkeTtcblx0ICAgIHNlbGZfc2l6ZVszXSA9IE1hdGgubWF4KHNlbGZfc2l6ZVsyXSwgKHNlbGZfc2l6ZVszXSB8fCBtYXhIZWlnaHQpICsgZHkpO1xuXHQgICAgZGVidWdfc2l6ZV9ib3hfZW5kKHRoaXMsIHNlbGZfc2l6ZSk7XG5cdCAgICBpZiAoIXRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uICYmIHRoaXMuX3NldHRpbmdzLnJlc3BvbnNpdmUpIHNlbGZfc2l6ZVswXSA9IDA7XG5cdCAgICByZXR1cm4gc2VsZl9zaXplO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICB0aGlzLl9sYXlvdXRfc2l6ZXMgPSBbeCwgeV07XG5cdCAgICBkZWJ1Z19zaXplX2JveF9zdGFydCh0aGlzKTtcblx0ICAgIGJhc2V2aWV3LmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpO1xuXG5cdCAgICB0aGlzLl9zZXRfY2hpbGRfc2l6ZSh4LCB5KTtcblxuXHQgICAgZGVidWdfc2l6ZV9ib3hfZW5kKHRoaXMsIFt4LCB5XSk7XG5cdCAgfSxcblx0ICBfc2V0X2NoaWxkX3NpemVfYTogZnVuY3Rpb24gKHNpemVzLCBtaW4sIG1heCkge1xuXHQgICAgbWluID0gc2l6ZXNbbWluXTtcblx0ICAgIG1heCA9IHNpemVzW21heF07XG5cdCAgICB2YXIgaGVpZ2h0ID0gbWluO1xuXG5cdCAgICBpZiAobWluICE9IG1heCkge1xuXHQgICAgICB2YXIgcHMgPSB0aGlzLl9zZXRfc2l6ZV9kZWx0YSAqIHNpemVzWzRdIC8gdGhpcy5fc2V0X3NpemVfZ3Jhdml0eTtcblxuXHQgICAgICBpZiAocHMgPCBtaW4pIHtcblx0ICAgICAgICBoZWlnaHQgPSBtaW47XG5cdCAgICAgICAgdGhpcy5fc2V0X3NpemVfZ3Jhdml0eSAtPSBzaXplc1s0XTtcblx0ICAgICAgICB0aGlzLl9zZXRfc2l6ZV9kZWx0YSAtPSBoZWlnaHQ7XG5cdCAgICAgIH0gZWxzZSBpZiAocHMgPiBtYXgpIHtcblx0ICAgICAgICBoZWlnaHQgPSBtYXg7XG5cdCAgICAgICAgdGhpcy5fc2V0X3NpemVfZ3Jhdml0eSAtPSBzaXplc1s0XTtcblx0ICAgICAgICB0aGlzLl9zZXRfc2l6ZV9kZWx0YSAtPSBoZWlnaHQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBoZWlnaHQ7XG5cdCAgfSxcblx0ICBfcmVzcG9uc2l2ZV9oaWRlOiBmdW5jdGlvbiAoY2VsbCwgbW9kZSkge1xuXHQgICAgdmFyIHRhcmdldCA9ICQkKG1vZGUpO1xuXG5cdCAgICBpZiAodGFyZ2V0ID09PSBcImhpZGVcIiB8fCAhdGFyZ2V0KSB7XG5cdCAgICAgIGNlbGwuaGlkZSgpO1xuXHQgICAgICBjZWxsLl9yZXNwb25zaXZlX21hcmtlciA9IFwiaGlkZVwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy9mb3IgU2lkZUJhciBpbiBXZWJpeCAxLjlcblx0ICAgICAgaWYgKCF0YXJnZXQpIHRhcmdldCA9IHVpKHtcblx0ICAgICAgICB2aWV3OiBcInBvcHVwXCIsXG5cdCAgICAgICAgYm9keTogW3t9XVxuXHQgICAgICB9KTtcblx0ICAgICAgY2VsbC5fcmVzcG9uc2l2ZV93aWR0aCA9IGNlbGwuX3NldHRpbmdzLndpZHRoO1xuXHQgICAgICBjZWxsLl9yZXNwb25zaXZlX2hlaWdodCA9IGNlbGwuX3NldHRpbmdzLmhlaWdodDtcblx0ICAgICAgY2VsbC5fcmVzcG9uc2l2ZV9tYXJrZXIgPSB0YXJnZXQuX3NldHRpbmdzLmlkO1xuXHQgICAgICBjZWxsLl9zZXR0aW5ncy53aWR0aCA9IDA7XG5cdCAgICAgIGlmICghY2VsbC5fc2V0dGluZ3MuaGVpZ2h0KSBjZWxsLl9zZXR0aW5ncy5hdXRvaGVpZ2h0ID0gdHJ1ZTtcblx0ICAgICAgdWkoY2VsbCwgdGFyZ2V0LCB0aGlzLl9yZXNwb25zaXZlLmxlbmd0aCk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3Jlc3BvbnNpdmUucHVzaChjZWxsKTtcblx0ICB9LFxuXHQgIF9yZXNwb25zaXZlX3Nob3c6IGZ1bmN0aW9uIChjZWxsKSB7XG5cdCAgICB2YXIgdGFyZ2V0ID0gY2VsbC5fcmVzcG9uc2l2ZV9tYXJrZXI7XG5cdCAgICBjZWxsLl9yZXNwb25zaXZlX21hcmtlciA9IDA7XG5cblx0ICAgIGlmICh0YXJnZXQgPT09IFwiaGlkZVwiIHx8ICF0YXJnZXQpIHtcblx0ICAgICAgY2VsbC5zaG93KCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjZWxsLl9zZXR0aW5ncy53aWR0aCA9IGNlbGwuX3Jlc3BvbnNpdmVfd2lkdGg7XG5cdCAgICAgIGNlbGwuX3NldHRpbmdzLmhlaWdodCA9IGNlbGwuX3Jlc3BvbnNpdmVfaGVpZ2h0O1xuXHQgICAgICBkZWxldGUgY2VsbC5fc2V0dGluZ3MuYXV0b2hlaWdodDtcblx0ICAgICAgdmFyIGluZGV4JCQxID0gMDtcblxuXHQgICAgICB3aGlsZSAodGhpcy5fY2VsbHNbaW5kZXgkJDFdICYmIHRoaXMuX2NlbGxzW2luZGV4JCQxXS5fc2V0dGluZ3MucmVzcG9uc2l2ZUNlbGwgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgaW5kZXgkJDErKztcblx0ICAgICAgfVxuXG5cdCAgICAgIHVpKGNlbGwsIHRoaXMsIGluZGV4JCQxKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcmVzcG9uc2l2ZS5wb3AoKTtcblx0ICB9LFxuXHQgIF9yZXNwb25zaXZlX2NlbGxzOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgc3RhdGUuX3Jlc3BvbnNpdmVfdGlua2VyeSA9IHRydWU7XG5cblx0ICAgIGlmICh4ICsgdGhpcy5fcGFkZGluZy5sZWZ0ICsgdGhpcy5fcGFkZGluZy5yaWdodCArIHRoaXMuX21hcmdpbiAqICh0aGlzLl9jZWxscy5sZW5ndGggLSAxKSA8IHRoaXMuX2Rlc2lyZWRfc2l6ZVswXSkge1xuXHQgICAgICB2YXIgbWF4ID0gdGhpcy5fY2VsbHMubGVuZ3RoIC0gMTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsc1tpXTtcblxuXHQgICAgICAgIGlmICghY2VsbC5fcmVzcG9uc2l2ZV9tYXJrZXIpIHtcblx0ICAgICAgICAgIGlmIChjZWxsLl9zZXR0aW5ncy5yZXNwb25zaXZlQ2VsbCAhPT0gZmFsc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZV9oaWRlKGNlbGwsIHRoaXMuX3NldHRpbmdzLnJlc3BvbnNpdmUpO1xuXG5cdCAgICAgICAgICAgIGNhbGxFdmVudChcIm9uUmVzcG9uc2l2ZUhpZGVcIiwgW2NlbGwuX3NldHRpbmdzLmlkXSk7XG5cdCAgICAgICAgICAgIHN0YXRlLl9yZXNwb25zaXZlX2V4Y2VwdGlvbiA9IHRydWU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbWF4ID0gdGhpcy5fY2VsbHMubGVuZ3RoO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9yZXNwb25zaXZlLmxlbmd0aCkge1xuXHQgICAgICB2YXIgX2NlbGwgPSB0aGlzLl9yZXNwb25zaXZlW3RoaXMuX3Jlc3BvbnNpdmUubGVuZ3RoIC0gMV07XG5cdCAgICAgIHZhciBkeCA9IF9jZWxsLl9yZXNwb25zaXZlX21hcmtlciA9PSBcImhpZGVcIiA/IDAgOiBfY2VsbC5fcmVzcG9uc2l2ZV93aWR0aDtcblxuXHQgICAgICB2YXIgcHggPSBfY2VsbC4kZ2V0U2l6ZShkeCwgMCk7XG5cblx0ICAgICAgaWYgKHB4WzBdICsgdGhpcy5fZGVzaXJlZF9zaXplWzBdICsgdGhpcy5fbWFyZ2luICsgMjAgPD0geCkge1xuXHQgICAgICAgIHRoaXMuX3Jlc3BvbnNpdmVfc2hvdyhfY2VsbCk7XG5cblx0ICAgICAgICBjYWxsRXZlbnQoXCJvblJlc3BvbnNpdmVTaG93XCIsIFtfY2VsbC5fc2V0dGluZ3MuaWRdKTtcblx0ICAgICAgICBzdGF0ZS5fcmVzcG9uc2l2ZV9leGNlcHRpb24gPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLl9yZXNwb25zaXZlX3RpbmtlcnkgPSBmYWxzZTtcblx0ICB9LFxuXHQgIF9zZXRfY2hpbGRfc2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIHN0YXRlLl9jaGlsZF9zaXppbmdfYWN0aXZlID0gKHN0YXRlLl9jaGlsZF9zaXppbmdfYWN0aXZlIHx8IDApICsgMTtcblx0ICAgIGlmICghdGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gJiYgdGhpcy5fc2V0dGluZ3MucmVzcG9uc2l2ZSkgdGhpcy5fcmVzcG9uc2l2ZV9jZWxscyh4LCB5KTtcblx0ICAgIHRoaXMuX3NldF9zaXplX2RlbHRhID0gKHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8geSA6IHgpIC0gdGhpcy5fbWFzdGVyX3NpemVbMF07XG5cdCAgICB0aGlzLl9zZXRfc2l6ZV9ncmF2aXR5ID0gdGhpcy5fbWFzdGVyX3NpemVbMl07XG5cdCAgICB2YXIgd2lkdGggPSB4O1xuXHQgICAgdmFyIGhlaWdodCA9IHk7XG5cdCAgICB2YXIgYXV0byA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vaWdub3JlIGhpZGRlbiBjZWxsc1xuXHQgICAgICBpZiAodGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmhpZGRlbiB8fCAhdGhpcy5fc2l6ZXNbaV0pIGNvbnRpbnVlO1xuXHQgICAgICB2YXIgc2l6ZXMgPSB0aGlzLl9zaXplc1tpXTtcblxuXHQgICAgICBpZiAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24pIHtcblx0ICAgICAgICBoZWlnaHQgPSB0aGlzLl9zZXRfY2hpbGRfc2l6ZV9hKHNpemVzLCAyLCAzKTtcblxuXHQgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG5cdCAgICAgICAgICBhdXRvLnB1c2goaSk7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgd2lkdGggPSB0aGlzLl9zZXRfY2hpbGRfc2l6ZV9hKHNpemVzLCAwLCAxKTtcblxuXHQgICAgICAgIGlmICh3aWR0aCA8IDApIHtcblx0ICAgICAgICAgIGF1dG8ucHVzaChpKTtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2NlbGxzW2ldLiRzZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhdXRvLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgdmFyIGluZGV4JCQxID0gYXV0b1tfaTJdO1xuXHQgICAgICB2YXIgX3NpemVzID0gdGhpcy5fc2l6ZXNbaW5kZXgkJDFdO1xuXHQgICAgICB2YXIgZHggPSBNYXRoLnJvdW5kKHRoaXMuX3NldF9zaXplX2RlbHRhICogX3NpemVzWzRdIC8gdGhpcy5fc2V0X3NpemVfZ3Jhdml0eSk7XG5cdCAgICAgIHRoaXMuX3NldF9zaXplX2RlbHRhIC09IGR4O1xuXHQgICAgICB0aGlzLl9zZXRfc2l6ZV9ncmF2aXR5IC09IF9zaXplc1s0XTtcblx0ICAgICAgaWYgKHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uKSBoZWlnaHQgPSBkeDtlbHNlIHtcblx0ICAgICAgICB3aWR0aCA9IGR4O1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fY2VsbHNbaW5kZXgkJDFdLiRzZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5fY2hpbGRfc2l6aW5nX2FjdGl2ZSAtPSAxO1xuXHQgIH0sXG5cdCAgX25leHQ6IGZ1bmN0aW9uIChvYmosIG1vZGUpIHtcblx0ICAgIHZhciBpbmRleCQkMSA9IHRoaXMuaW5kZXgob2JqKTtcblx0ICAgIGlmIChpbmRleCQkMSA9PSAtMSkgcmV0dXJuIG51bGw7XG5cdCAgICByZXR1cm4gdGhpcy5fY2VsbHNbaW5kZXgkJDEgKyBtb2RlXTtcblx0ICB9LFxuXHQgIF9maXJzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2NlbGxzWzBdO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckNCA9IGV4cG9ydHMucHJvdG9VSShhcGkkNCwgRXZlbnRTeXN0ZW0sIGJhc2V2aWV3LnZpZXcpO1xuXHR2YXIgYmFzZWxheW91dCA9IHtcblx0ICBhcGk6IGFwaSQ0LFxuXHQgIHZpZXc6IHZpZXckNFxuXHR9O1xuXG5cdHZhciBhcGkkNSA9IHtcblx0ICBuYW1lOiBcInNwYWNlclwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBib3JkZXJsZXNzOiB0cnVlXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfc3BhY2VyXCI7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQ1ID0gZXhwb3J0cy5wcm90b1VJKGFwaSQ1LCBiYXNlLnZpZXcpO1xuXG5cdHZhciBhcGkkNiA9IHtcblx0ICBuYW1lOiBcInRlbXBsYXRlXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHZhciBzdWJ0eXBlID0gdGhpcy5fdGVtcGxhdGVfdHlwZXNbY29uZmlnLnR5cGVdO1xuXG5cdCAgICBpZiAoc3VidHlwZSkge1xuXHQgICAgICBleHBvcnRzLmV4dGVuZChjb25maWcsIHN1YnR5cGUpOyAvL3dpbGwgcmVzZXQgYm9yZGVycyBmb3IgXCJzZWN0aW9uXCJcblxuXHQgICAgICBpZiAoY29uZmlnLmJvcmRlcmxlc3MpIHtcblx0ICAgICAgICBkZWxldGUgY29uZmlnLl9pbm5lcjtcblxuXHQgICAgICAgIHRoaXMuX3NldF9pbm5lcihjb25maWcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9kYXRhb2JqID09IHRoaXMuX3ZpZXdvYmopIHtcblx0ICAgICAgdGhpcy5fZGF0YW9iaiA9IGNyZWF0ZShcIkRJVlwiKTtcblx0ICAgICAgdGhpcy5fZGF0YW9iai5jbGFzc05hbWUgPSBcIiB3ZWJpeF90ZW1wbGF0ZVwiO1xuXG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouYXBwZW5kQ2hpbGQodGhpcy5fZGF0YW9iaik7XG5cdCAgICB9IGVsc2UgdGhpcy5fZGF0YW9iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfdGVtcGxhdGVcIjtcblxuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgdGhpcy5fY29ycmVjdF93aWR0aF9zY3JvbGwpO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWVzOiBmdW5jdGlvbiAob2JqLCB1cGRhdGUpIHtcblx0ICAgIHRoaXMuZGF0YSA9IHVwZGF0ZSA/IGV4cG9ydHMuZXh0ZW5kKHRoaXMuZGF0YSwgb2JqLCB0cnVlKSA6IG9iajtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmRhdGE7XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdGVtcGxhdGVfdHlwZXMuaGVhZGVyLmhlaWdodCA9ICRhY3RpdmUuYmFySGVpZ2h0IC0gJGFjdGl2ZS5ib3JkZXJXaWR0aCAqIDI7XG5cdCAgICB0aGlzLl90ZW1wbGF0ZV90eXBlcy5zZWN0aW9uLmhlaWdodCA9ICRhY3RpdmUuYmFySGVpZ2h0O1xuXHQgIH0sXG5cdCAgX3RlbXBsYXRlX3R5cGVzOiB7XG5cdCAgICBcImhlYWRlclwiOiB7XG5cdCAgICAgIGNzczogXCJ3ZWJpeF9oZWFkZXJcIlxuXHQgICAgfSxcblx0ICAgIFwic2VjdGlvblwiOiB7XG5cdCAgICAgIGNzczogXCJ3ZWJpeF9zZWN0aW9uXCIsXG5cdCAgICAgIGJvcmRlcmxlc3M6IHRydWVcblx0ICAgIH0sXG5cdCAgICBcImNsZWFuXCI6IHtcblx0ICAgICAgY3NzOiBcIndlYml4X2NsZWFuXCIsXG5cdCAgICAgIGJvcmRlcmxlc3M6IHRydWVcblx0ICAgIH1cblx0ICB9LFxuXHQgIG9uQ2xpY2tfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMub25fY2xpY2sgPSBleHBvcnRzLmV4dGVuZCh0aGlzLm9uX2NsaWNrIHx8IHt9LCB2YWx1ZSwgdHJ1ZSk7XG5cdCAgICBpZiAoIXRoaXMuX29uQ2xpY2spIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIE1vdXNlRXZlbnRzKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogdGVtcGxhdGUuZW1wdHlcblx0ICB9LFxuXHQgIF9yZW5kZXJfbWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX25vdF9yZW5kZXJfbWUgPSBmYWxzZTtcblxuXHQgICAgdGhpcy5fcHJvYmFibHlfcmVuZGVyX21lKCk7XG5cblx0ICAgIHRoaXMucmVzaXplKCk7XG5cdCAgfSxcblx0ICBfcHJvYmFibHlfcmVuZGVyX21lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX25vdF9yZW5kZXJfbWUpIHtcblx0ICAgICAgdGhpcy5fbm90X3JlbmRlcl9tZSA9IHRydWU7XG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBzcmNfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX25vdF9yZW5kZXJfbWUgPSB0cnVlO1xuXHQgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlTG9hZFwiLCBbXSkpIHJldHVybiBcIlwiO1xuXHQgICAgYWpheCh2YWx1ZSwgYmluZChmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy50ZW1wbGF0ZSA9IHRlbXBsYXRlKHRleHQpO1xuXG5cdCAgICAgIHRoaXMuX3JlbmRlcl9tZSgpO1xuXG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckxvYWRcIiwgW10pO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX2NvcnJlY3Rfd2lkdGhfc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAvL3dlIG5lZWQgdG8gZm9yY2UgYXV0byBoZWlnaHQgY2FsY3VsYXRpb24gYWZ0ZXIgY29udGVudCBjaGFuZ2Vcblx0ICAgIC8vZHJvcHBpbmcgdGhlIGxhc3Rfc2l6ZSBmbGFnIHdpbGwgZW5zdXJlIHRoYXQgaW5uZXIgbG9naWMgb2YgJHNldFNpemUgd2lsbCBiZSBwcm9jZXNzZWRcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0KSB7XG5cdCAgICAgIHRoaXMuX2xhc3Rfc2l6ZSA9IG51bGw7XG5cdCAgICAgIHRoaXMucmVzaXplKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zY3JvbGwgJiYgdGhpcy5fc2V0dGluZ3Muc2Nyb2xsLmluZGV4T2YoXCJ4XCIpICE9IC0xKSB0aGlzLl9kYXRhb2JqLnN0eWxlLndpZHRoID0gdGhpcy5fZGF0YW9iai5zY3JvbGxXaWR0aCArIFwicHhcIjtcblx0ICB9LFxuXHQgIGNvbnRlbnRfc2V0dGVyOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBpZiAoY29uZmlnKSB7XG5cdCAgICAgIHRoaXMuX25vdF9yZW5kZXJfbWUgPSB0cnVlO1xuXG5cdCAgICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XG5cblx0ICAgICAgdGhpcy5fZGF0YW9iai5hcHBlbmRDaGlsZCh0b05vZGUoY29uZmlnKSk7XG5cblx0ICAgICAgZGVsYXkodGhpcy5fY29ycmVjdF93aWR0aF9zY3JvbGwsIHRoaXMpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZW5kZXIoKTtcblx0ICB9LFxuXHQgIHNldEhUTUw6IGZ1bmN0aW9uIChodG1sKSB7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGh0bWw7XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgIHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XG5cdCAgICB0aGlzLl9kYXRhb2JqLmlubmVySFRNTCA9IFwiXCI7XG5cdCAgICB0aGlzLmNvbnRlbnRfc2V0dGVyKGNvbnRlbnQpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KSkge1xuXHQgICAgICB0aGlzLl9wcm9iYWJseV9yZW5kZXJfbWUoKTtcblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2hlaWdodCkge1xuXHQgICAgICAgIHZhciB0b3AgPSB0aGlzLmdldFRvcFBhcmVudFZpZXcoKTtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodG9wLl90ZW1wbGF0ZV9yZXNpemVfdGltZXIpO1xuXHQgICAgICAgIHRvcC5fdGVtcGxhdGVfcmVzaXplX3RpbWVyID0gZGVsYXkodGhpcy5yZXNpemUsIHRoaXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0ICYmICghdGhpcy5fc2V0dGluZ3MudHlwZSB8fCB0aGlzLl9zZXR0aW5ncy50eXBlID09IFwiY2xlYW5cIikpIHRoaXMuX3NldHRpbmdzLmhlaWdodCA9IHRoaXMuX2dldF9hdXRvX2hlaWdodCgpO1xuXHQgICAgcmV0dXJuIGJhc2UuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgeCwgeSk7XG5cdCAgfSxcblx0ICBfZ2V0X2F1dG9faGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgc2l6ZTtcblx0ICAgIHZhciBwYWRkaW5nID0gJGFjdGl2ZS5sYXlvdXRQYWRkaW5nLnNwYWNlO1xuXG5cdCAgICB0aGlzLl9wcm9iYWJseV9yZW5kZXJfbWUoKTtcblxuXHQgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG5cdCAgICAgIC8vdHJ5IGdldHRpbmcgaGVpZ2h0IG9mIGEgaGlkZGVuIHRlbXBsYXRlXG5cdCAgICAgIHNpemUgPSBnZXRUZXh0U2l6ZSh0aGlzLl90b0hUTUwodGhpcy5kYXRhKSB8fCB0aGlzLl9kYXRhb2JqLmlubmVySFRNTCwgLy9jaGVjayBmb3IgY29uZmlnLmNvbnRlbnQgXG5cdCAgICAgIFwid2ViaXhfdGVtcGxhdGVcIiwgKHRoaXMuJHdpZHRoIHx8ICh0aGlzLmdldFBhcmVudFZpZXcoKSA/IHRoaXMuZ2V0UGFyZW50VmlldygpLiR3aWR0aCA6IDApKSAtIHBhZGRpbmcpLmhlaWdodDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2RhdGFvYmouc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG5cdCAgICAgIHNpemUgPSB0aGlzLl9kYXRhb2JqLnNjcm9sbEhlaWdodDtcblx0ICAgICAgdGhpcy5fZGF0YW9iai5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2l6ZTtcblx0ICB9LFxuXHQgIF9vbmVfdGltZV9zY3JvbGw6IHRydWUgLy9zY3JvbGwgd2lsbCBhcHBlYXIgb25seSBpZiBzZXQgZGlyZWN0bHkgaW4gY29uZmlnXG5cblx0fTtcblx0dmFyIHZpZXckNiA9IGV4cG9ydHMucHJvdG9VSShhcGkkNiwgU2Nyb2xsYWJsZSwgQXV0b1Rvb2x0aXAsIEF0b21EYXRhTG9hZGVyLCBBdG9tUmVuZGVyLCBFdmVudFN5c3RlbSwgYmFzZS52aWV3KTtcblx0dmFyIHRlbXBsYXRlJDEgPSB7XG5cdCAgYXBpOiBhcGkkNixcblx0ICB2aWV3OiB2aWV3JDZcblx0fTtcblxuXHQvKnNjcm9sbGFibGUgdmlldyB3aXRoIGFub3RoZXIgdmlldyBpbnNpemUqL1xuXG5cdHZhciBhcGkkNyA9IHtcblx0ICBuYW1lOiBcInNjcm9sbHZpZXdcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgc2Nyb2xsOiBcInlcIixcblx0ICAgIHNjcm9sbFNwZWVkOiBcIjBtc1wiXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfc2Nyb2xsdmlld1wiO1xuXHQgIH0sXG5cdCAgYm9keV9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGNvbmZpZy5ib3JkZXJsZXNzID0gdHJ1ZTtcblx0ICAgIHN0YXRlLl9wYXJlbnRfY2VsbCA9IHRoaXM7XG5cdCAgICB0aGlzLl9ib2R5X2NlbGwgPSB1aS5fdmlldyhjb25maWcpO1xuXG5cdCAgICB0aGlzLl9kYXRhb2JqLmFwcGVuZENoaWxkKHRoaXMuX2JvZHlfY2VsbC5fdmlld29iaik7XG5cdCAgfSxcblx0ICBnZXRDaGlsZFZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gW3RoaXMuX2JvZHlfY2VsbF07XG5cdCAgfSxcblx0ICBnZXRCb2R5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fYm9keV9jZWxsO1xuXHQgIH0sXG5cdCAgcmVzaXplQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fYm9keV9jZWxsKSByZXR1cm47XG5cdCAgICB0aGlzLl9kZXNpcmVkX3NpemUgPSB0aGlzLl9ib2R5X2NlbGwuJGdldFNpemUoMCwgMCk7XG5cblx0ICAgIHRoaXMuX3Jlc2l6ZUNoaWxkcmVuKCk7XG5cblx0ICAgIGNhbGxFdmVudChcIm9uUmVzaXplXCIsIFtdKTtcblx0ICB9LFxuXHQgIF9yZXNpemVDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGN4ID0gTWF0aC5tYXgodGhpcy5fY29udGVudF93aWR0aCwgdGhpcy5fZGVzaXJlZF9zaXplWzBdKTtcblx0ICAgIHZhciBjeSA9IE1hdGgubWF4KHRoaXMuX2NvbnRlbnRfaGVpZ2h0LCB0aGlzLl9kZXNpcmVkX3NpemVbMl0pO1xuXG5cdCAgICB0aGlzLl9ib2R5X2NlbGwuJHNldFNpemUoY3gsIGN5KTtcblxuXHQgICAgdGhpcy5fZGF0YW9iai5zdHlsZS53aWR0aCA9IHRoaXMuX2JvZHlfY2VsbC5fY29udGVudF93aWR0aCArIFwicHhcIjtcblx0ICAgIHRoaXMuX2RhdGFvYmouc3R5bGUuaGVpZ2h0ID0gdGhpcy5fYm9keV9jZWxsLl9jb250ZW50X2hlaWdodCArIFwicHhcIjtcblxuXHQgICAgaWYgKGVudi50b3VjaCkge1xuXHQgICAgICB2YXIgc2Nyb2xsID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpO1xuXHQgICAgICB2YXIgdG9wID0gdGhpcy5fYm9keV9jZWxsLl9jb250ZW50X2hlaWdodCAtIHRoaXMuX2NvbnRlbnRfaGVpZ2h0O1xuXHQgICAgICBpZiAodG9wIDwgc2Nyb2xsLnkpIHRoaXMuc2Nyb2xsVG8obnVsbCwgdG9wKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN0YXRlLl9yZXNwb25zaXZlX2V4Y2VwdGlvbikge1xuXHQgICAgICBzdGF0ZS5fcmVzcG9uc2l2ZV9leGNlcHRpb24gPSBmYWxzZTtcblx0ICAgICAgdGhpcy5fZGVzaXJlZF9zaXplID0gdGhpcy5fYm9keV9jZWxsLiRnZXRTaXplKDAsIDApO1xuXG5cdCAgICAgIHRoaXMuX3Jlc2l6ZUNoaWxkcmVuKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgdmFyIGRlc2lyZWRfc2l6ZSA9IHRoaXMuX2Rlc2lyZWRfc2l6ZSA9IHRoaXMuX2JvZHlfY2VsbC4kZ2V0U2l6ZSgwLCAwKTtcblxuXHQgICAgdmFyIHNlbGZfc2l6ZXMgPSBiYXNlLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cdCAgICB2YXIgc2Nyb2xsX3NpemUgPSB0aGlzLl9uYXRpdmVfc2Nyb2xsIHx8IGVudi5zY3JvbGxTaXplO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2Nyb2xsID09IFwieFwiKSB7XG5cdCAgICAgIHNlbGZfc2l6ZXNbMl0gPSBNYXRoLm1heChzZWxmX3NpemVzWzJdLCBkZXNpcmVkX3NpemVbMl0pICsgc2Nyb2xsX3NpemU7XG5cdCAgICAgIHNlbGZfc2l6ZXNbM10gPSBNYXRoLm1pbihzZWxmX3NpemVzWzNdLCBkZXNpcmVkX3NpemVbM10pICsgc2Nyb2xsX3NpemU7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnNjcm9sbCA9PSBcInlcIikge1xuXHQgICAgICBzZWxmX3NpemVzWzBdID0gTWF0aC5tYXgoc2VsZl9zaXplc1swXSwgZGVzaXJlZF9zaXplWzBdKSArIHNjcm9sbF9zaXplO1xuXHQgICAgICBzZWxmX3NpemVzWzFdID0gTWF0aC5taW4oc2VsZl9zaXplc1sxXSwgZGVzaXJlZF9zaXplWzFdKSArIHNjcm9sbF9zaXplO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2VsZl9zaXplcztcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgdmFyIHRlbXAgPSBlbnYuc2Nyb2xsU2l6ZTtcblx0ICAgIGVudi5zY3JvbGxTaXplID0gdGhpcy5fbmF0aXZlX3Njcm9sbCB8fCB0ZW1wO1xuXHQgICAgaWYgKGJhc2UuYXBpLiRzZXRTaXplLmNhbGwodGhpcywgeCwgeSkgfHwgc3RhdGUuX2ZvcmNlX3Jlc2l6ZSkgdGhpcy5fcmVzaXplQ2hpbGRyZW4oKTtcblx0ICAgIGVudi5zY3JvbGxTaXplID0gdGVtcDtcblx0ICB9LFxuXHQgIHNjcm9sbF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIGN1c3RvbSA9IGVudi4kY3VzdG9tU2Nyb2xsO1xuXG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgJiYgdmFsdWUuaW5kZXhPZihcIm5hdGl2ZS1cIikgPT09IDApIHtcblx0ICAgICAgdGhpcy5fbmF0aXZlX3Njcm9sbCA9IDE3O1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCJuYXRpdmUtXCIpO1xuXHQgICAgICBlbnYuJGN1c3RvbVNjcm9sbCA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICB2YWx1ZSA9IFNjcm9sbGFibGUuc2Nyb2xsX3NldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0ICAgIGVudi4kY3VzdG9tU2Nyb2xsID0gY3VzdG9tO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX3JlcGxhY2U6IGZ1bmN0aW9uIChuZXdfdmlldykge1xuXHQgICAgdGhpcy5fYm9keV9jZWxsLmRlc3RydWN0b3IoKTtcblxuXHQgICAgdGhpcy5fYm9keV9jZWxsID0gbmV3X3ZpZXc7XG5cblx0ICAgIHRoaXMuX2JvZHlvYmouYXBwZW5kQ2hpbGQodGhpcy5fYm9keV9jZWxsLl92aWV3b2JqKTtcblxuXHQgICAgdGhpcy5yZXNpemUoKTtcblx0ICB9LFxuXHQgIHNob3dWaWV3OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciB0b3BQb3MgPSAkJChpZCkuJHZpZXcub2Zmc2V0VG9wIC0gJCQoaWQpLiR2aWV3LnBhcmVudE5vZGUub2Zmc2V0VG9wO1xuXHQgICAgdGhpcy5zY3JvbGxUbygwLCB0b3BQb3MpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckNyA9IGV4cG9ydHMucHJvdG9VSShhcGkkNywgU2Nyb2xsYWJsZSwgRXZlbnRTeXN0ZW0sIGJhc2Uudmlldyk7XG5cblx0dmFyIGFwaSQ4ID0ge1xuXHQgIG5hbWU6IFwiaWZyYW1lXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2RhdGFvYmogPSB0aGlzLl9jb250ZW50b2JqO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgPSBcIjxpZnJhbWUgc3R5bGU9J3dpZHRoOjEwMCU7IGhlaWdodDoxMDAlJyBmcmFtZWJvcmRlcj0nMCcgb25sb2FkPSd2YXIgdCA9ICQkKHRoaXMucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXFxcInZpZXdfaWRcXFwiKSk7IGlmICh0KSB0LmNhbGxFdmVudChcXFwib25BZnRlckxvYWRcXFwiLFtdKTsnIHNyYz0nYWJvdXQ6YmxhbmsnPjwvaWZyYW1lPlwiO1xuXHQgIH0sXG5cdCAgbG9hZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLnNyY19zZXR0ZXIodmFsdWUpO1xuXHQgIH0sXG5cdCAgc3JjX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVMb2FkXCIsIFtdKSkgcmV0dXJuIFwiXCI7XG5cdCAgICB0aGlzLmdldElmcmFtZSgpLnNyYyA9IHZhbHVlO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgZ2V0SWZyYW1lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fY29udGVudG9iai5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlmcmFtZVwiKVswXTtcblx0ICB9LFxuXHQgIGdldFdpbmRvdzogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0SWZyYW1lKCkuY29udGVudFdpbmRvdztcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JDggPSBleHBvcnRzLnByb3RvVUkoYXBpJDgsIGJhc2UudmlldywgRXZlbnRTeXN0ZW0pO1xuXG5cdHZhciBhcGkkOSA9IHtcblx0ICBuYW1lOiBcImxheW91dFwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9oaWRkZW5jZWxscyA9IDA7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdHlwZTogXCJsaW5lXCJcblx0ICB9LFxuXHQgIF9wYXJzZV9jZWxsczogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3BhcnNlX2NlbGxzX2V4dCkgY29sbGVjdGlvbiA9IHRoaXMuX3BhcnNlX2NlbGxzX2V4dChjb2xsZWN0aW9uKTtcblxuXHQgICAgaWYgKCF0aGlzLl9wYXJzZV9vbmNlKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X2xheW91dF9cIiArICh0aGlzLl9zZXR0aW5ncy50eXBlIHx8IFwiXCIpO1xuXHQgICAgICB0aGlzLl9wYXJzZV9vbmNlID0gMTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1hcmdpbiAhPT0gdW5kZWZpbmVkKSB0aGlzLl9tYXJnaW4gPSB0aGlzLl9zZXR0aW5ncy5tYXJnaW47XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MucGFkZGluZyAhPT0gdW5kZWZpbmVkICYmIF90eXBlb2YodGhpcy5fc2V0dGluZ3MucGFkZGluZykgIT09IFwib2JqZWN0XCIpIHRoaXMuX3BhZGRpbmcubGVmdCA9IHRoaXMuX3BhZGRpbmcucmlnaHQgPSB0aGlzLl9wYWRkaW5nLnRvcCA9IHRoaXMuX3BhZGRpbmcuYm90dG9tID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZztcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5wYWRkaW5nWCAhPT0gdW5kZWZpbmVkKSB0aGlzLl9wYWRkaW5nLmxlZnQgPSB0aGlzLl9wYWRkaW5nLnJpZ2h0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ1g7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MucGFkZGluZ1kgIT09IHVuZGVmaW5lZCkgdGhpcy5fcGFkZGluZy50b3AgPSB0aGlzLl9wYWRkaW5nLmJvdHRvbSA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdZO1xuXHQgICAgaWYgKF90eXBlb2YodGhpcy5fc2V0dGluZ3MucGFkZGluZykgPT09IFwib2JqZWN0XCIpIGV4cG9ydHMuZXh0ZW5kKHRoaXMuX3BhZGRpbmcsIHRoaXMuX3NldHRpbmdzLnBhZGRpbmcsIHRydWUpO1xuXHQgICAgaWYgKHRoaXMuX3BhZGRpbmcubGVmdCB8fCB0aGlzLl9wYWRkaW5nLnJpZ2h0IHx8IHRoaXMuX3BhZGRpbmcudG9wIHx8IHRoaXMuX3BhZGRpbmcuYm90dG9tKSB0aGlzLl9wYWRkaW5nLmRlZmluZWQgPSB0cnVlOyAvL2lmIGxheW91dCBoYXMgcGFkZGluZ3Mgd2UgbmVlZCB0byBzZXQgdGhlIHZpc2libGUgYm9yZGVyIFxuXG5cdCAgICBpZiAodGhpcy5faGFzQm9yZGVycygpICYmICF0aGlzLl9zZXR0aW5ncy5ib3JkZXJsZXNzKSB7XG5cdCAgICAgIHRoaXMuX2NvbnRlbnRvYmouc3R5bGUuYm9yZGVyV2lkdGggPSBcIjFweFwiOyAvL2lmIGxheW91dCBoYXMgYm9yZGVyIC0gbm9ybWFsIGJvcmRlcmluZyBydWxlcyBhcmUgYXBwbGllZFxuXG5cdCAgICAgIHRoaXMuX3JlbmRlcl9ib3JkZXJzID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmJvcmRlcmxlc3MpIHRoaXMuX3NldHRpbmdzLl9pbm5lciA9IHtcblx0ICAgICAgdG9wOiB0cnVlLFxuXHQgICAgICBsZWZ0OiB0cnVlLFxuXHQgICAgICByaWdodDogdHJ1ZSxcblx0ICAgICAgYm90dG9tOiB0cnVlXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9iZWZvcmVSZXNldEJvcmRlcnMoY29sbGVjdGlvbik7XG5cblx0ICAgIGJhc2VsYXlvdXQuYXBpLl9wYXJzZV9jZWxscy5jYWxsKHRoaXMsIGNvbGxlY3Rpb24pO1xuXG5cdCAgICB0aGlzLl9hZnRlclJlc2V0Qm9yZGVycyhjb2xsZWN0aW9uKTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICBkeCA9IGR4IHx8IDA7XG5cdCAgICBkeSA9IGR5IHx8IDA7XG5cdCAgICB2YXIgY29ycmVjdGlvbiA9IHRoaXMuX21hcmdpbiAqICh0aGlzLl9jZWxscy5sZW5ndGggLSB0aGlzLl9oaWRkZW5jZWxscyAtIDEpO1xuXG5cdCAgICBpZiAodGhpcy5fcmVuZGVyX2JvcmRlcnMgfHwgdGhpcy5faGFzQm9yZGVycygpKSB7XG5cdCAgICAgIHZhciBfYm9yZGVycyA9IHRoaXMuX3NldHRpbmdzLl9pbm5lcjtcblxuXHQgICAgICBpZiAoX2JvcmRlcnMpIHtcblx0ICAgICAgICBkeCArPSAoX2JvcmRlcnMubGVmdCA/IDAgOiAxKSArIChfYm9yZGVycy5yaWdodCA/IDAgOiAxKTtcblx0ICAgICAgICBkeSArPSAoX2JvcmRlcnMudG9wID8gMCA6IDEpICsgKF9ib3JkZXJzLmJvdHRvbSA/IDAgOiAxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmhlaWdodCkgZHkgKz0gdGhpcy5fcGFkZGluZy50b3AgKyB0aGlzLl9wYWRkaW5nLmJvdHRvbSArICh0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbiA/IGNvcnJlY3Rpb24gOiAwKTtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3Mud2lkdGgpIGR4ICs9IHRoaXMuX3BhZGRpbmcubGVmdCArIHRoaXMuX3BhZGRpbmcucmlnaHQgKyAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gPyAwIDogY29ycmVjdGlvbik7XG5cdCAgICByZXR1cm4gYmFzZWxheW91dC5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCBkeCwgZHkpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICB0aGlzLl9sYXlvdXRfc2l6ZXMgPSBbeCwgeV07XG5cdCAgICBkZWJ1Z19zaXplX2JveF9zdGFydCh0aGlzKTtcblx0ICAgIGlmICh0aGlzLl9oYXNCb3JkZXJzKCkgfHwgdGhpcy5fcmVuZGVyX2JvcmRlcnMpIGJhc2UuYXBpLiRzZXRTaXplLmNhbGwodGhpcywgeCwgeSk7ZWxzZSBiYXNldmlldy5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTsgLy9mb3JtIHdpdGggc2Nyb2xsXG5cblx0ICAgIHkgPSB0aGlzLl9jb250ZW50X2hlaWdodDtcblx0ICAgIHggPSB0aGlzLl9jb250ZW50X3dpZHRoO1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoY29uZmlnLnNjcm9sbCkge1xuXHQgICAgICB5ID0gTWF0aC5tYXgoeSwgdGhpcy5fZGVzaXJlZF9zaXplWzFdKTtcblx0ICAgICAgeCA9IE1hdGgubWF4KHgsIHRoaXMuX2Rlc2lyZWRfc2l6ZVswXSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3NldF9jaGlsZF9zaXplKHgsIHkpO1xuXG5cdCAgICBkZWJ1Z19zaXplX2JveF9lbmQodGhpcywgW3gsIHldKTtcblx0ICB9LFxuXHQgIF9zZXRfY2hpbGRfc2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIHZhciBjb3JyZWN0aW9uID0gdGhpcy5fbWFyZ2luICogKHRoaXMuX2NlbGxzLmxlbmd0aCAtIHRoaXMuX2hpZGRlbmNlbGxzIC0gMSk7XG5cdCAgICB5IC09IHRoaXMuX3BhZGRpbmcudG9wICsgdGhpcy5fcGFkZGluZy5ib3R0b207XG5cdCAgICB4IC09IHRoaXMuX3BhZGRpbmcubGVmdCArIHRoaXMuX3BhZGRpbmcucmlnaHQ7XG5cdCAgICBpZiAodGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24pIHkgLT0gY29ycmVjdGlvbjtlbHNlIHggLT0gY29ycmVjdGlvbjtcblx0ICAgIHJldHVybiBiYXNlbGF5b3V0LmFwaS5fc2V0X2NoaWxkX3NpemUuY2FsbCh0aGlzLCB4LCB5KTtcblx0ICB9LFxuXHQgIHJlc2l6ZUNoaWxkcmVuOiBmdW5jdGlvbiAoc3RydWN0dXJlX2NoYW5nZWQpIHtcblx0ICAgIGlmIChzdHJ1Y3R1cmVfY2hhbmdlZCkge1xuXHQgICAgICB0aGlzLl9sYXN0X3NpemUgPSBudWxsOyAvL2ZvcmNlcyBjaGlsZHJlbiByZXNpemVcblxuXHQgICAgICB2YXIgY29uZmlnID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjZWxsID0gdGhpcy5fY2VsbHNbaV07XG5cdCAgICAgICAgY29uZmlnW2ldID0gY2VsbC5fc2V0dGluZ3M7XG5cdCAgICAgICAgdmFyIG4gPSBjZWxsLl9sYXlvdXRfc2l6ZXMgJiYgIWNlbGwuX3JlbmRlcl9ib3JkZXJzIHx8IGNlbGwuX3NldHRpbmdzLmJvcmRlcmxlc3MgPyBcIjBweFwiIDogXCIxcHhcIjtcblx0ICAgICAgICBjZWxsLl92aWV3b2JqLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gY2VsbC5fdmlld29iai5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IGNlbGwuX3ZpZXdvYmouc3R5bGUuYm9yZGVyTGVmdFdpZHRoID0gY2VsbC5fdmlld29iai5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2JlZm9yZVJlc2V0Qm9yZGVycyhjb25maWcpO1xuXG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjb25maWcubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgaWYgKGNvbmZpZ1tfaV0uYm9yZGVybGVzcyAmJiB0aGlzLl9jZWxsc1tfaV0uX3NldF9pbm5lcikgdGhpcy5fY2VsbHNbX2ldLl9zZXRfaW5uZXIoY29uZmlnW19pXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9hZnRlclJlc2V0Qm9yZGVycyh0aGlzLl9jZWxscyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGF0ZS5fcmVzcG9uc2l2ZV90aW5rZXJ5KSByZXR1cm47XG5cdCAgICBiYXNlbGF5b3V0LmFwaS5yZXNpemVDaGlsZHJlbi5jYWxsKHRoaXMpO1xuXHQgIH0sXG5cdCAgX2hhc0JvcmRlcnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wYWRkaW5nLmRlZmluZWQgJiYgdGhpcy5fbWFyZ2luID4gMCAmJiAhdGhpcy5fY2xlYW5sYXlvdXQ7XG5cdCAgfSxcblx0ICBfYmVmb3JlUmVzZXRCb3JkZXJzOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuXHQgICAgaWYgKHRoaXMuX2hhc0JvcmRlcnMoKSAmJiAoIXRoaXMuX3NldHRpbmdzLmJvcmRlcmxlc3MgfHwgdGhpcy5fc2V0dGluZ3MudHlwZSA9PSBcInNwYWNlXCIpKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmICghY29sbGVjdGlvbltpXS5faW5uZXIgfHwgIWNvbGxlY3Rpb25baV0uYm9yZGVybGVzcykgY29sbGVjdGlvbltpXS5faW5uZXIgPSB7XG5cdCAgICAgICAgICB0b3A6IGZhbHNlLFxuXHQgICAgICAgICAgbGVmdDogZmFsc2UsXG5cdCAgICAgICAgICByaWdodDogZmFsc2UsXG5cdCAgICAgICAgICBib3R0b206IGZhbHNlXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY29sbGVjdGlvbi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgY29sbGVjdGlvbltfaTJdLl9pbm5lciA9IGNsb25lKHRoaXMuX3NldHRpbmdzLl9pbm5lcik7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgbW9kZSA9IGZhbHNlO1xuXHQgICAgICBpZiAodGhpcy5fY2xlYW5sYXlvdXQpIG1vZGUgPSB0cnVlO1xuXHQgICAgICB2YXIgbWF4bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cblx0ICAgICAgaWYgKHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uKSB7XG5cdCAgICAgICAgZm9yICh2YXIgX2kzID0gMTsgX2kzIDwgbWF4bGVuZ3RoIC0gMTsgX2kzKyspIHtcblx0ICAgICAgICAgIGNvbGxlY3Rpb25bX2kzXS5faW5uZXIudG9wID0gY29sbGVjdGlvbltfaTNdLl9pbm5lci5ib3R0b20gPSBtb2RlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChtYXhsZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudHlwZSAhPSBcImhlYWRcIikgY29sbGVjdGlvblswXS5faW5uZXIuYm90dG9tID0gbW9kZTtcblxuXHQgICAgICAgICAgd2hpbGUgKGNvbGxlY3Rpb25bbWF4bGVuZ3RoIC0gMV0uaGlkZGVuICYmIG1heGxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgbWF4bGVuZ3RoLS07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChtYXhsZW5ndGggPiAwKSBjb2xsZWN0aW9uW21heGxlbmd0aCAtIDFdLl9pbm5lci50b3AgPSBtb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBmb3IgKHZhciBfaTQgPSAxOyBfaTQgPCBtYXhsZW5ndGggLSAxOyBfaTQrKykge1xuXHQgICAgICAgICAgY29sbGVjdGlvbltfaTRdLl9pbm5lci5sZWZ0ID0gY29sbGVjdGlvbltfaTRdLl9pbm5lci5yaWdodCA9IG1vZGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG1heGxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50eXBlICE9IFwiaGVhZFwiKSBjb2xsZWN0aW9uWzBdLl9pbm5lci5yaWdodCA9IG1vZGU7XG5cdCAgICAgICAgICBjb2xsZWN0aW9uW21heGxlbmd0aCAtIDFdLl9pbm5lci5sZWZ0ID0gbW9kZTtcblxuXHQgICAgICAgICAgd2hpbGUgKG1heGxlbmd0aCA+IDEgJiYgY29sbGVjdGlvblttYXhsZW5ndGggLSAxXS5oaWRkZW4pIHtcblx0ICAgICAgICAgICAgbWF4bGVuZ3RoLS07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChtYXhsZW5ndGggPiAwKSBjb2xsZWN0aW9uW21heGxlbmd0aCAtIDFdLl9pbm5lci5sZWZ0ID0gbW9kZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9maXhfY29udGFpbmVyX2JvcmRlcnM6IGZ1bmN0aW9uIChzdHlsZSwgaW5uZXIpIHtcblx0ICAgIGlmIChpbm5lci50b3ApIHN0eWxlLmJvcmRlclRvcFdpZHRoID0gXCIwcHhcIjtcblx0ICAgIGlmIChpbm5lci5sZWZ0KSBzdHlsZS5ib3JkZXJMZWZ0V2lkdGggPSBcIjBweFwiO1xuXHQgICAgaWYgKGlubmVyLnJpZ2h0KSBzdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gXCIwcHhcIjtcblx0ICAgIGlmIChpbm5lci5ib3R0b20pIHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gXCIwcHhcIjtcblx0ICB9LFxuXHQgIF9hZnRlclJlc2V0Qm9yZGVyczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY2VsbCA9IHRoaXMuX2NlbGxzW2ldO1xuXHQgICAgICB2YXIgc19pbm5lciA9IGNlbGwuX3NldHRpbmdzLl9pbm5lcjtcblxuXHQgICAgICBpZiAoY2VsbC5fc2V0dGluZ3MuaGlkZGVuICYmIHRoaXMuX2NlbGxzW2kgKyAxXSkge1xuXHQgICAgICAgIHZhciBzX25leHQgPSB0aGlzLl9jZWxsc1tpICsgMV0uX3NldHRpbmdzLl9pbm5lcjtcblx0ICAgICAgICBpZiAoIXNfaW5uZXIudG9wKSBzX25leHQudG9wID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKCFzX2lubmVyLmxlZnQpIHNfbmV4dC5sZWZ0ID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKGkgPT0gc3RhcnQpIHN0YXJ0Kys7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9maXhfY29udGFpbmVyX2JvcmRlcnMoY2VsbC5fdmlld29iai5zdHlsZSwgY2VsbC5fc2V0dGluZ3MuX2lubmVyKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHN0eWxlID0gdGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gPyBcIm1hcmdpbkxlZnRcIiA6IFwibWFyZ2luVG9wXCI7XG5cdCAgICB2YXIgY29udHJzdHlsZSA9IHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gXCJtYXJnaW5Ub3BcIiA6IFwibWFyZ2luTGVmdFwiO1xuXHQgICAgdmFyIHBhZGRpbmcgPSB0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbiA/IHRoaXMuX3BhZGRpbmcubGVmdCA6IHRoaXMuX3BhZGRpbmcudG9wO1xuXHQgICAgdmFyIGNvbnRycGFkZGluZyA9IHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gdGhpcy5fcGFkZGluZy50b3AgOiB0aGlzLl9wYWRkaW5nLmxlZnQ7IC8vYWRkIHRvcCBvZmZzZXQgdG8gYWxsXG5cblx0ICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBfaTUrKykge1xuXHQgICAgICB0aGlzLl9jZWxsc1tfaTVdLl92aWV3b2JqLnN0eWxlW3N0eWxlXSA9IHBhZGRpbmcgKyBcInB4XCI7XG5cdCAgICB9IC8vYWRkIGxlZnQgb2Zmc2V0IHRvIGZpcnN0IGNlbGxcblxuXG5cdCAgICBpZiAodGhpcy5fY2VsbHMubGVuZ3RoKSB0aGlzLl9jZWxsc1tzdGFydF0uX3ZpZXdvYmouc3R5bGVbY29udHJzdHlsZV0gPSBjb250cnBhZGRpbmcgKyBcInB4XCI7IC8vYWRkIG9mZnNldCBiZXR3ZWVuIGNlbGxzXG5cblx0ICAgIGZvciAodmFyIGluZGV4ID0gc3RhcnQgKyAxOyBpbmRleCA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpbmRleCsrKSB7XG5cdCAgICAgIHRoaXMuX2NlbGxzW2luZGV4XS5fdmlld29iai5zdHlsZVtjb250cnN0eWxlXSA9IHRoaXMuX21hcmdpbiArIFwicHhcIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHR5cGVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX21hcmdpbiA9IHR5cGVvZiB0aGlzLl9tYXJnaW5fc2V0W3ZhbHVlXSAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuX21hcmdpbl9zZXRbdmFsdWVdIDogdGhpcy5fbWFyZ2luX3NldFtcImxpbmVcIl07XG5cdCAgICB0aGlzLl9wYWRkaW5nLmxlZnQgPSB0aGlzLl9wYWRkaW5nLnJpZ2h0ID0gdGhpcy5fcGFkZGluZy50b3AgPSB0aGlzLl9wYWRkaW5nLmJvdHRvbSA9IHR5cGVvZiB0aGlzLl9tYXJnaW5fc2V0W3ZhbHVlXSAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuX3BhZGRpbmdfc2V0W3ZhbHVlXSA6IHRoaXMuX3BhZGRpbmdfc2V0W1wibGluZVwiXTtcblx0ICAgIHRoaXMuX2NsZWFubGF5b3V0ID0gdmFsdWUgPT0gXCJtYXRlcmlhbFwiIHx8IHZhbHVlID09IFwiY2xlYW5cIjtcblx0ICAgIGlmICh2YWx1ZSA9PSBcIm1hdGVyaWFsXCIpIHRoaXMuX3NldHRpbmdzLmJvcmRlcmxlc3MgPSB0cnVlO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX21hcmdpbl9zZXQgPSAkYWN0aXZlLmxheW91dE1hcmdpbjtcblx0ICAgIHRoaXMuX3BhZGRpbmdfc2V0ID0gJGFjdGl2ZS5sYXlvdXRQYWRkaW5nO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckOSA9IGV4cG9ydHMucHJvdG9VSShhcGkkOSwgYmFzZWxheW91dC52aWV3KTtcblx0dmFyIGxheW91dCA9IHtcblx0ICBhcGk6IGFwaSQ5LFxuXHQgIHZpZXc6IHZpZXckOVxuXHR9OyAvL25vdCBuZWNlc3NhcnkgYW55bW9yZVxuXHQvL3ByZXNlcnZpbmcgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuXHR2aWV3JDkuY2FsbCgtMSk7XG5cblx0dmFyIGFwaSRhID0ge1xuXHQgIG5hbWU6IFwiYWNjb3JkaW9uXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHBhbmVsQ2xhc3M6IFwiYWNjb3JkaW9uaXRlbVwiLFxuXHQgICAgbXVsdGk6IGZhbHNlLFxuXHQgICAgY29sbGFwc2VkOiBmYWxzZVxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYmxpc3RcIik7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIiwgXCJ0cnVlXCIpO1xuXHQgIH0sXG5cdCAgX3JlcGxhY2U6IGZ1bmN0aW9uIChuZXd2aWV3KSB7XG5cdCAgICBsYXlvdXQuYXBpLl9yZXBsYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0ICAgIGlmIChuZXd2aWV3LmNvbGxhcHNlZF9zZXR0ZXIgJiYgbmV3dmlldy5yZWZyZXNoKSB7XG5cdCAgICAgIG5ld3ZpZXcucmVmcmVzaCgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3BhcnNlX2NlbGxzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcGFuZWwgPSB0aGlzLl9zZXR0aW5ncy5wYW5lbENsYXNzO1xuXHQgICAgdmFyIGNlbGxzID0gdGhpcy5fY29sbGVjdGlvbjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoKGNlbGxzW2ldLmJvZHkgfHwgY2VsbHNbaV0uaGVhZGVyKSAmJiAhY2VsbHNbaV0udmlldyAmJiAhY2VsbHNbaV0uYWxpZ24pIGNlbGxzW2ldLnZpZXcgPSBwYW5lbDtcblx0ICAgICAgaWYgKGlzVW5kZWZpbmVkKGNlbGxzW2ldLmNvbGxhcHNlZCkpIGNlbGxzW2ldLmNvbGxhcHNlZCA9IHRoaXMuX3NldHRpbmdzLmNvbGxhcHNlZDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2tpbl9yZW5kZXJfY29sbGFwc2UgPSB0cnVlO1xuXG5cdCAgICBsYXlvdXQuYXBpLl9wYXJzZV9jZWxscy5jYWxsKHRoaXMpO1xuXG5cdCAgICB0aGlzLl9za2luX3JlbmRlcl9jb2xsYXBzZSA9IGZhbHNlO1xuXG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5fY2VsbHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tfaV0ubmFtZSA9PSBwYW5lbCkgdGhpcy5fY2VsbHNbX2ldLnJlZnJlc2goKTtcblx0ICAgICAgdGhpcy5fY2VsbHNbX2ldLl9hY2NMYXN0Q2hpbGQgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cblx0ICAgIGZvciAodmFyIF9pMiA9IHRoaXMuX2NlbGxzLmxlbmd0aCAtIDE7IF9pMiA+PSAwICYmICFmb3VuZDsgX2kyLS0pIHtcblx0ICAgICAgaWYgKCF0aGlzLl9jZWxsc1tfaTJdLl9zZXR0aW5ncy5oaWRkZW4pIHtcblx0ICAgICAgICB0aGlzLl9jZWxsc1tfaTJdLl9hY2NMYXN0Q2hpbGQgPSB0cnVlO1xuXHQgICAgICAgIGZvdW5kID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2FmdGVyT3BlbjogZnVuY3Rpb24gKHZpZXcpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aSA9PT0gZmFsc2UgJiYgdGhpcy5fc2tpbl9yZW5kZXJfY29sbGFwc2UgIT09IHRydWUpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmICh2aWV3ICE9IHRoaXMuX2NlbGxzW2ldICYmICF0aGlzLl9jZWxsc1tpXS5fc2V0dGluZ3MuY29sbGFwc2VkICYmIHRoaXMuX2NlbGxzW2ldLmNvbGxhcHNlKSB0aGlzLl9jZWxsc1tpXS5jb2xsYXBzZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh2aWV3LmNhbGxFdmVudCkge1xuXHQgICAgICB2aWV3LmNhbGxFdmVudChcIm9uVmlld1Nob3dcIiwgW10pO1xuXHQgICAgICBlYWNoKHZpZXcsIHRoaXMuX3NpZ25hbF9oaWRkZW5fY2VsbHMpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NhbkNvbGxhcHNlOiBmdW5jdGlvbiAodmlldykge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm11bHRpID09PSB0cnVlIHx8IHRoaXMuX3NraW5fcmVuZGVyX2NvbGxhcHNlKSByZXR1cm4gdHJ1ZTsgLy9jYW4gY29sbGFwc2Ugb25seSBpZiB5b3UgaGF2ZSBvdGhlciBpdGVtIHRvIG9wZW5cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodmlldyAhPSB0aGlzLl9jZWxsc1tpXSAmJiAhdGhpcy5fY2VsbHNbaV0uX3NldHRpbmdzLmNvbGxhcHNlZCAmJiB0aGlzLl9jZWxsc1tpXS5pc1Zpc2libGUoKSAmJiAhdGhpcy5fY2VsbHNbaV0uJG5vc3BhY2UpIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0cztcblx0ICAgIGlmICgkYWN0aXZlLmFjY29yZGlvblR5cGUpIGRlZmF1bHRzLnR5cGUgPSAkYWN0aXZlLmFjY29yZGlvblR5cGU7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRhID0gZXhwb3J0cy5wcm90b1VJKGFwaSRhLCBsYXlvdXQudmlldyk7XG5cdHZhciBiYXNlJDEgPSB7XG5cdCAgYXBpOiBhcGkkYSxcblx0ICB2aWV3OiB2aWV3JGFcblx0fTtcblxuXHR2YXIgYXBpJGIgPSB7XG5cdCAgbmFtZTogXCJoZWFkZXJsYXlvdXRcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdHlwZTogXCJhY2NvcmRpb25cIixcblx0ICAgIG11bHRpOiBcIm1peGVkXCIsXG5cdCAgICBjb2xsYXBzZWQ6IGZhbHNlXG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRiID0gZXhwb3J0cy5wcm90b1VJKGFwaSRiLCBiYXNlJDEudmlldyk7XG5cblx0dmFyIGFwaSRjID0ge1xuXHQgIG5hbWU6IFwiYWNjb3JkaW9uaXRlbVwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLmlubmVySFRNTCA9IFwiPGRpdiB0YWJpbmRleD0nMCcgd2ViaXhfYWlfaWQ9J1wiICsgY29uZmlnLmlkICsgXCInICBjbGFzcz0nd2ViaXhfYWNjb3JkaW9uaXRlbV9oZWFkZXInPjxkaXYgY2xhc3M9J3dlYml4X2FjY29yZGlvbml0ZW1fYnV0dG9uJyA+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfYWNjb3JkaW9uaXRlbV9sYWJlbCcgPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3dlYml4X2FjY29yZGlvbml0ZW1fYm9keSc+PC9kaXY+XCI7XG5cdCAgICB0aGlzLl9jb250ZW50b2JqID0gdGhpcy5fdmlld29iajtcblx0ICAgIHRoaXMuX2hlYWRvYmogPSB0aGlzLl9jb250ZW50b2JqLmNoaWxkTm9kZXNbMF07XG5cdCAgICBpZiAoIWNvbmZpZy5oZWFkZXIpIHRoaXMuX2hlYWRvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgdGhpcy5faGVhZGxhYmVsID0gdGhpcy5fY29udGVudG9iai5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMV07XG5cdCAgICB0aGlzLl9oZWFkYnV0dG9uID0gdGhpcy5fY29udGVudG9iai5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF07XG5cdCAgICB0aGlzLl9ib2R5b2JqID0gdGhpcy5fY29udGVudG9iai5jaGlsZE5vZGVzWzFdO1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfYWNjb3JkaW9uaXRlbVwiO1xuXHQgICAgdGhpcy5faGVhZF9jZWxsID0gdGhpcy5fYm9keV9jZWxsID0gbnVsbDtcblx0ICAgIHRoaXMuX2NlbGxzID0gdHJ1ZTtcblxuXHQgICAgdGhpcy5fYm9keW9iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGFicGFuZWxcIik7XG5cblx0ICAgIHRoaXMuX2hlYWRvYmouc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRhYlwiKTtcblxuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uS2V5UHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyk7XG5cdCAgfSxcblx0ICBfcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9ib2R5X2NlbGwgPSB7XG5cdCAgICAgIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHt9XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX3JlcGxhY2U6IGZ1bmN0aW9uIChuZXdfdmlldykge1xuXHQgICAgdGhpcy5fYm9keV9jZWxsLmRlc3RydWN0b3IoKTtcblxuXHQgICAgdGhpcy5fYm9keV9jZWxsID0gbmV3X3ZpZXc7XG5cblx0ICAgIHRoaXMuX2JvZHlvYmouYXBwZW5kQ2hpbGQodGhpcy5fYm9keV9jZWxsLl92aWV3b2JqKTtcblxuXHQgICAgdGhpcy5yZXNpemUoKTtcblx0ICB9LFxuXHQgIF9pZDogXCJ3ZWJpeF9haV9pZFwiLFxuXHQgIGdldENoaWxkVmlld3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBbdGhpcy5fYm9keV9jZWxsXTtcblx0ICB9LFxuXHQgIGJvZHlfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmIChfdHlwZW9mKHZhbHVlKSAhPSBcIm9iamVjdFwiKSB2YWx1ZSA9IHtcblx0ICAgICAgdGVtcGxhdGU6IHZhbHVlXG5cdCAgICB9O1xuXHQgICAgdmFsdWUuX2lubmVyID0ge1xuXHQgICAgICB0b3A6IHRydWUsXG5cdCAgICAgIGxlZnQ6IHRydWUsXG5cdCAgICAgIHJpZ2h0OiB0cnVlLFxuXHQgICAgICBib3R0b206IHRydWVcblx0ICAgIH07XG5cdCAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSB0aGlzO1xuXHQgICAgdGhpcy5fYm9keV9jZWxsID0gdWkuX3ZpZXcodmFsdWUpO1xuXG5cdCAgICB0aGlzLl9ib2R5b2JqLmFwcGVuZENoaWxkKHRoaXMuX2JvZHlfY2VsbC5fdmlld29iaik7XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGhlYWRlcl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHRlbXBsYXRlKHZhbHVlKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGhlYWRlckFsdF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHRlbXBsYXRlKHZhbHVlKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICB2YXIgc2l6ZSA9IHRoaXMuX2JvZHlfY2VsbC4kZ2V0U2l6ZSgwLCAwKTsgLy9hcHBseSBleHRlcm5hbCBib3JkZXIgdG8gaW5uZXIgY29udGVudCBzaXplc1xuXG5cblx0ICAgIHZhciBfYm9yZGVycyA9IHRoaXMuX3NldHRpbmdzLl9pbm5lcjtcblxuXHQgICAgaWYgKF9ib3JkZXJzKSB7XG5cdCAgICAgIGR4ICs9IChfYm9yZGVycy5sZWZ0ID8gMCA6IDEpICsgKF9ib3JkZXJzLnJpZ2h0ID8gMCA6IDEpO1xuXHQgICAgICBkeSArPSAoX2JvcmRlcnMudG9wID8gMCA6IDEpICsgKF9ib3JkZXJzLmJvdHRvbSA/IDAgOiAxKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhlYWRlciA9IDA7XG5cdCAgICB2YXIgc2VsZl9zaXplID0gYmFzZXZpZXcuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgMCwgMCk7IC8vdXNlIGNoaWxkIHNldHRpbmdzIGlmIGxheW91dCdzIG9uZSB3YXMgbm90IGRlZmluZWRcblxuXHQgICAgc2VsZl9zaXplWzBdID0gKHNlbGZfc2l6ZVswXSB8fCBzaXplWzBdKSArIGR4O1xuXHQgICAgaWYgKHNlbGZfc2l6ZVsxXSA+PSAxMDAwMDApIHNlbGZfc2l6ZVsxXSA9IHNpemVbMV07XG5cdCAgICBzZWxmX3NpemVbMV0gKz0gZHg7XG5cdCAgICBzZWxmX3NpemVbMl0gPSAoc2VsZl9zaXplWzJdIHx8IHNpemVbMl0pICsgZHk7XG5cdCAgICB2YXIgZml4ZWRIZWlnaHQgPSBzZWxmX3NpemVbM10gPCAxMDAwMDA7XG5cdCAgICBpZiAoIWZpeGVkSGVpZ2h0KSBzZWxmX3NpemVbM10gPSBzaXplWzNdO1xuXHQgICAgc2VsZl9zaXplWzNdICs9IGR5O1xuXG5cdCAgICBpZiAodGhpcy5nZXRQYXJlbnRWaWV3KCkuX3ZlcnRpY2FsX29yaWVudGF0aW9uKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jb2xsYXBzZWQpIHtcblx0ICAgICAgICBzZWxmX3NpemVbMl0gPSBzZWxmX3NpemVbM10gPSB0aGlzLl9nZXRIZWFkZXJTaXplKCkgKyBkeTtcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy5oZWFkZXIpIGhlYWRlciA9IHRoaXMuX3NldHRpbmdzLmhlYWRlckhlaWdodDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5jb2xsYXBzZWQpIHNlbGZfc2l6ZVswXSA9IHNlbGZfc2l6ZVsxXSA9IHRoaXMuX2dldEhlYWRlclNpemUoKSArIGR4O1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGVhZGVyKSBoZWFkZXIgPSB0aGlzLl9zZXR0aW5ncy5oZWFkZXJIZWlnaHQ7XG5cdCAgICB9IC8vaW5jbHVkZSBoZWFkZXIgaW4gdG90YWwgaGVpZ2h0IGNhbGN1bGF0aW9uXG5cblxuXHQgICAgaWYgKCFmaXhlZEhlaWdodCkge1xuXHQgICAgICBzZWxmX3NpemVbMl0gKz0gaGVhZGVyO1xuXHQgICAgICBzZWxmX3NpemVbM10gKz0gaGVhZGVyO1xuXHQgICAgfVxuXG5cdCAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBzZWxmX3NpemUsIHRydWUpO1xuXHQgICAgcmV0dXJuIHNlbGZfc2l6ZTtcblx0ICB9LFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICB3ZWJpeF9hY2NvcmRpb25pdGVtX2hlYWRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdGhpcy5fdG9nZ2xlKGUpO1xuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0sXG5cdCAgICB3ZWJpeF9hY2NvcmRpb25pdGVtX2hlYWRlcl92OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB0aGlzLl90b2dnbGUoZSk7XG5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3RvZ2dsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZpbmUoXCJjb2xsYXBzZWRcIiwgIXRoaXMuX3NldHRpbmdzLmNvbGxhcHNlZCk7XG5cdCAgfSxcblx0ICBjb2xsYXBzZWRfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5oZWFkZXIgPT09IGZhbHNlKSByZXR1cm47IC8vdXNlIGxhc3QgbGF5b3V0IGVsZW1lbnQgaWYgcGFyZW50IGlzIG5vdCBrbm93biB5ZXRcblxuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50VmlldygpO1xuXG5cdCAgICBpZiAocGFyZW50KSB7XG5cdCAgICAgIGlmICghdmFsdWUpIHRoaXMuX2V4cGFuZCgpO2Vsc2Uge1xuXHQgICAgICAgIGlmIChwYXJlbnQuX2NhbkNvbGxhcHNlKHRoaXMpKSB0aGlzLl9jb2xsYXBzZSgpO2Vsc2Uge1xuXHQgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSAwO1xuXHQgICAgICAgICAgaWYgKHBhcmVudC5fY2VsbHMubGVuZ3RoID4gMSkgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnQuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWJsID0gcGFyZW50Ll9jZWxsc1tpXTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcyAhPSBzaWJsICYmIHNpYmwuaXNWaXNpYmxlKCkgJiYgc2libC5leHBhbmQpIHtcblx0ICAgICAgICAgICAgICBzaWJsLmV4cGFuZCgpO1xuXG5cdCAgICAgICAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcblxuXHQgICAgICAgICAgICAgIHN1Y2Nlc3MgPSAxO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fc2V0dGluZ3MuY29sbGFwc2VkID0gdmFsdWU7XG5cdCAgICAgIGlmICghdmFsdWUpIHBhcmVudC5fYWZ0ZXJPcGVuKHRoaXMpO1xuXHQgICAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgICAgaWYgKCFzdGF0ZS5fdWlfY3JlYXRpb24pIHRoaXMucmVzaXplKCk7XG5cdCAgICAgIHBhcmVudC5jYWxsRXZlbnQoXCJvbkFmdGVyXCIgKyAodmFsdWUgPyBcIkNvbGxhcHNlXCIgOiBcIkV4cGFuZFwiKSwgW3RoaXMuX3NldHRpbmdzLmlkXSk7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLiRub3Jlc2l6ZSA9IHZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBjb2xsYXBzZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZpbmUoXCJjb2xsYXBzZWRcIiwgdHJ1ZSk7XG5cblx0ICAgIFVJTWFuYWdlci5fbW92ZUNoaWxkRm9jdXModGhpcyk7XG5cdCAgfSxcblx0ICBleHBhbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmaW5lKFwiY29sbGFwc2VkXCIsIGZhbHNlKTtcblx0ICB9LFxuXHQgIF9zaG93OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnNob3coKTtcblx0ICB9LFxuXHQgIF9oaWRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmhpZGUoKTtcblx0ICB9LFxuXHQgIF9leHBhbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2JvZHlvYmouc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdCAgICByZW1vdmVDc3ModGhpcy4kdmlldywgXCJjb2xsYXBzZWRcIik7XG5cdCAgICByZW1vdmVDc3ModGhpcy5faGVhZG9iaiwgXCJjb2xsYXBzZWRcIik7XG5cblx0ICAgIHRoaXMuX2hlYWRvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG5cdCAgfSxcblx0ICBfY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5oZWFkZXJBbHQpIHRoaXMuX2hlYWRsYWJlbC5pbm5lckhUTUwgPSB0aGlzLl9zZXR0aW5ncy5oZWFkZXJBbHQoKTtcblx0ICAgIHRoaXMuX2JvZHlvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgYWRkQ3NzKHRoaXMuJHZpZXcsIFwiY29sbGFwc2VkXCIpO1xuXHQgICAgYWRkQ3NzKHRoaXMuX2hlYWRvYmosIFwiY29sbGFwc2VkXCIpO1xuXG5cdCAgICB0aGlzLl9oZWFkb2JqLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcblx0ICB9LFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB0ZW1wbGF0ZSQkMSA9IHRoaXMuX3NldHRpbmdzW3RoaXMuX3NldHRpbmdzLmNvbGxhcHNlZCA/IFwiaGVhZGVyQWx0XCIgOiBcImhlYWRlclwiXSB8fCB0aGlzLl9zZXR0aW5ncy5oZWFkZXI7XG5cblx0ICAgIGlmICh0ZW1wbGF0ZSQkMSkge1xuXHQgICAgICB0aGlzLl9oZWFkbGFiZWwuaW5uZXJIVE1MID0gdGVtcGxhdGUkJDEoKTtcblxuXHQgICAgICB0aGlzLl9oZWFkYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGVtcGxhdGUkJDEoKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjc3MgPSB0aGlzLmdldFBhcmVudFZpZXcoKS5fdmVydGljYWxfb3JpZW50YXRpb24gPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIjtcblxuXHQgICAgaWYgKHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lLmluZGV4T2YoXCIgXCIgKyBjc3MpIDwgMCkge1xuXHQgICAgICBhZGRDc3ModGhpcy5fdmlld29iaiwgY3NzKTtcblx0ICAgIH0gLy9maXggY29sbGFwc2VkIGNvbHVtbnMgaW4gSUU4XG5cblxuXHQgICAgaWYgKCFlbnYudHJhbnNmb3JtKSB7XG5cdCAgICAgIGFkZENzcyh0aGlzLl92aWV3b2JqLCBcIndlYml4X2llXCIsIHRydWUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldEhlYWRlclNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5jb2xsYXBzZWQgPyB0aGlzLl9zZXR0aW5ncy5oZWFkZXJBbHRIZWlnaHQgOiB0aGlzLl9zZXR0aW5ncy5oZWFkZXJIZWlnaHQ7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmIChiYXNlLmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpIHx8IHRoaXMuX2dldEhlYWRlclNpemUoKSAhPSB0aGlzLl9sYXN0X3NldF9oZWFkZXJfc2l6ZSkge1xuXHQgICAgICB4ID0gdGhpcy5fY29udGVudF93aWR0aDtcblx0ICAgICAgeSA9IHRoaXMuX2NvbnRlbnRfaGVpZ2h0O1xuXG5cdCAgICAgIHZhciBoZWFkZXJTaXplID0gdGhpcy5fbGFzdF9zZXRfaGVhZGVyX3NpemUgPSB0aGlzLl9nZXRIZWFkZXJTaXplKCk7IC8vLSh0aGlzLl9zZXR0aW5ncy5faW5uZXIudG9wPzA6MSk7XG5cblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGVhZGVyKSB7XG5cdCAgICAgICAgdGhpcy5faGVhZG9iai5zdHlsZS5oZWlnaHQgPSBoZWFkZXJTaXplICsgXCJweFwiO1xuXHQgICAgICAgIHRoaXMuX2hlYWRvYmouc3R5bGUud2lkdGggPSBcImF1dG9cIjtcblx0ICAgICAgICB0aGlzLl9oZWFkb2JqLnN0eWxlW2Vudi50cmFuc2Zvcm1dID0gXCJcIjtcblx0ICAgICAgICB0aGlzLl9oZWFkb2JqLnN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gKHRoaXMuX3NldHRpbmdzLmNvbGxhcHNlZCA/IDAgOiAxKSArIFwicHhcIjtcblxuXHQgICAgICAgIGlmICh0aGlzLmdldFBhcmVudFZpZXcoKS5fdmVydGljYWxfb3JpZW50YXRpb24gfHwgIXRoaXMuX3NldHRpbmdzLmNvbGxhcHNlZCkge1xuXHQgICAgICAgICAgeSAtPSB0aGlzLl9nZXRIZWFkZXJTaXplKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy5jb2xsYXBzZWQpIHtcblx0ICAgICAgICAgIC8vLTIgLSBib3JkZXJzXG5cdCAgICAgICAgICBpZiAoYW5pbWF0ZS5pc1N1cHBvcnRlZCgpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hlYWRvYmouc3R5bGUud2lkdGggPSB5ICsgXCJweFwiO1xuXHQgICAgICAgICAgICB0aGlzLl9oZWFkb2JqLnN0eWxlLmhlaWdodCA9IHggKyAzICsgXCJweFwiO1xuXHQgICAgICAgICAgICB2YXIgZCA9IE1hdGguZmxvb3IoeSAvIDIgLSB4IC8gMikgKyAoeCAtIHRoaXMuX3NldHRpbmdzLmhlYWRlckFsdEhlaWdodCkgLyAyO1xuXHQgICAgICAgICAgICB0aGlzLl9oZWFkb2JqLnN0eWxlW2Vudi50cmFuc2Zvcm1dID0gXCJyb3RhdGUoOTBkZWcpIHRyYW5zbGF0ZShcIiArIGQgKyBcInB4LCBcIiArIChkICsgMSkgKyBcInB4KVwiO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9JRTggZml4XG5cdCAgICAgICAgICAgIHRoaXMuX2hlYWRvYmouc3R5bGUud2lkdGggPSB4ICsgXCJweFwiO1xuXHQgICAgICAgICAgICB0aGlzLl9oZWFkb2JqLnN0eWxlLmhlaWdodCA9IHkgKyAzICsgXCJweFwiO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MuY29sbGFwc2VkKSB7XG5cdCAgICAgICAgdGhpcy5fYm9keV9jZWxsLiRzZXRTaXplKHgsIHkpO1xuXG5cdCAgICAgICAgdGhpcy5fbGFzdF9zaXplX3kgPSB5O1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKCF0aGlzLl9zZXR0aW5ncy5jb2xsYXBzZWQpIHtcblx0ICAgICAgdmFyIGJvZHkgPSB0aGlzLl9ib2R5X2NlbGw7XG5cdCAgICAgIGlmICh0aGlzLl9sYXN0X3NpemVfeSkgYm9keS4kc2V0U2l6ZSh0aGlzLl9jb250ZW50X3dpZHRoLCB0aGlzLl9sYXN0X3NpemVfeSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0cztcblx0ICAgIGRlZmF1bHRzLmhlYWRlckFsdEhlaWdodCA9IGRlZmF1bHRzLmhlYWRlckhlaWdodCA9ICRhY3RpdmUuYmFySGVpZ2h0IC0gJGFjdGl2ZS5ib3JkZXJXaWR0aCAqIDI7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgaGVhZGVyOiBmYWxzZSxcblx0ICAgIGhlYWRlckFsdDogZmFsc2UsXG5cdCAgICBib2R5OiBcIlwiXG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRjID0gZXhwb3J0cy5wcm90b1VJKGFwaSRjLCBNb3VzZUV2ZW50cywgRXZlbnRTeXN0ZW0sIGJhc2Uudmlldyk7XG5cblx0dmFyIGFwaSRkID0ge1xuXHQgIG5hbWU6IFwicmVzaXplYXJlYVwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBkaXI6IFwieFwiXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdmFyIGRpciA9IGNvbmZpZy5kaXIgfHwgXCJ4XCI7XG5cdCAgICB2YXIgbm9kZSA9IHRvTm9kZShjb25maWcuY29udGFpbmVyKTtcblx0ICAgIHZhciBzaXplID0gZGlyID09IFwieFwiID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIjtcblx0ICAgIHZhciBtYXJnaW4gPSBjb25maWcubWFyZ2luID8gY29uZmlnLm1hcmdpbiArIFwicHhcIiA6IDA7XG5cdCAgICB0aGlzLl9rZXlfcHJvcGVydHkgPSBkaXIgPT0gXCJ4XCIgPyBcImxlZnRcIiA6IFwidG9wXCI7XG5cdCAgICB0aGlzLl92aWV3b2JqID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Jlc2l6ZV9hcmVhIHdlYml4X2Rpcl9cIiArIGRpclxuXHQgICAgfSk7IC8vW1tDT01QQVRdXSBGRjEyIGNhbiBwcm9kdWNlIDIgbW92ZSBldmVudHNcblxuXHQgICAgX2V2ZW50KHRoaXMuX3ZpZXdvYmosIGVudi5tb3VzZS5kb3duLCBzdG9wRXZlbnQpO1xuXG5cdCAgICBpZiAobWFyZ2luKSB7XG5cdCAgICAgIGlmIChkaXIgPT0gXCJ4XCIpIG1hcmdpbiA9IG1hcmdpbiArIFwiIDAgXCIgKyBtYXJnaW47ZWxzZSBtYXJnaW4gPSBcIjAgXCIgKyBtYXJnaW4gKyBcIiAwIFwiICsgbWFyZ2luO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9kcmFnb2JqID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Jlc2l6ZV9oYW5kbGVfXCIgKyBkaXIsXG5cdCAgICAgIFwic3R5bGVcIjogbWFyZ2luID8gXCJwYWRkaW5nOlwiICsgbWFyZ2luIDogXCJcIlxuXHQgICAgfSwgXCI8ZGl2IGNsYXNzPSd3ZWJpeF9oYW5kbGVfY29udGVudCc+PC9kaXY+XCIpO1xuXHQgICAgdGhpcy5fb3JpZ2lub2JqID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3Jlc2l6ZV9vcmlnaW5fXCIgKyBkaXJcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoY29uZmlnW3NpemVdKSB7XG5cdCAgICAgIHRoaXMuX29yaWdpbm9iai5zdHlsZVtzaXplXSA9IGNvbmZpZ1tzaXplXSArIChjb25maWcuYm9yZGVyID8gMSA6IDApICsgXCJweFwiO1xuXHQgICAgICB0aGlzLl9kcmFnb2JqLnN0eWxlW3NpemVdID0gY29uZmlnW3NpemVdICsgXCJweFwiO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29uZmlnLmN1cnNvcikgdGhpcy5fZHJhZ29iai5zdHlsZS5jdXJzb3IgPSB0aGlzLl9vcmlnaW5vYmouc3R5bGUuY3Vyc29yID0gdGhpcy5fdmlld29iai5zdHlsZS5jdXJzb3IgPSBjb25maWcuY3Vyc29yO1xuXHQgICAgdGhpcy5fbW92ZWV2ID0gZXZlbnQkMShub2RlLCBlbnYubW91c2UubW92ZSwgdGhpcy5fb25tb3ZlLCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fdXBldiA9IGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgZW52Lm1vdXNlLnVwLCB0aGlzLl9vbnVwLCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fZHJhZ29iai5zdHlsZVt0aGlzLl9rZXlfcHJvcGVydHldID0gdGhpcy5fb3JpZ2lub2JqLnN0eWxlW3RoaXMuX2tleV9wcm9wZXJ0eV0gPSBjb25maWcuc3RhcnQgKyBcInB4XCI7XG5cdCAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLl9kcmFnb2JqKTtcblx0ICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fb3JpZ2lub2JqKTtcblx0ICB9LFxuXHQgIF9vbnVwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uUmVzaXplRW5kXCIsIFt0aGlzLl9sYXN0X3Jlc3VsdF0pO1xuXHQgICAgZXZlbnRSZW1vdmUodGhpcy5fbW92ZWV2KTtcblx0ICAgIGV2ZW50UmVtb3ZlKHRoaXMuX3VwZXYpO1xuXHQgICAgcmVtb3ZlKHRoaXMuX3ZpZXdvYmopO1xuXHQgICAgcmVtb3ZlKHRoaXMuX2RyYWdvYmopO1xuXHQgICAgcmVtb3ZlKHRoaXMuX29yaWdpbm9iaik7XG5cdCAgICB0aGlzLl92aWV3b2JqID0gdGhpcy5fZHJhZ29iaiA9IHRoaXMuX29yaWdpbm9iaiA9IG51bGw7XG5cdCAgfSxcblx0ICBfb25tb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgdmFyIGV2ZW50UG9zID0gcG9zKGUpO1xuXHQgICAgdGhpcy5fbGFzdF9yZXN1bHQgPSAodGhpcy5fc2V0dGluZ3MuZGlyID09IFwieFwiID8gZXZlbnRQb3MueCA6IGV2ZW50UG9zLnkpICsgdGhpcy5fc2V0dGluZ3Muc3RhcnQgLSB0aGlzLl9zZXR0aW5ncy5ldmVudFBvcztcblx0ICAgIHRoaXMuX2RyYWdvYmouc3R5bGVbdGhpcy5fa2V5X3Byb3BlcnR5XSA9IHRoaXMuX2xhc3RfcmVzdWx0ICsgXCJweFwiO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblJlc2l6ZVwiLCBbdGhpcy5fbGFzdF9yZXN1bHRdKTtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JGQgPSBleHBvcnRzLnByb3RvVUkoYXBpJGQsIEV2ZW50U3lzdGVtLCBTZXR0aW5ncyk7XG5cblx0dmFyIGFwaSRlID0ge1xuXHQgIG5hbWU6IFwicmVzaXplclwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB3aWR0aDogNyxcblx0ICAgIGhlaWdodDogN1xuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGFzc2VydCh0aGlzLmdldFBhcmVudFZpZXcoKSwgXCJSZXNpemVyIGNhbid0IGJlIGluaXRpYWxpemVkIG91dHNpZGUgYSBsYXlvdXRcIik7XG5cdCAgICB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9yZXNpemVyXCI7XG5cblx0ICAgIHZhciBzcGFjZSA9IHRoaXMuZ2V0UGFyZW50VmlldygpLl9tYXJnaW47XG5cblx0ICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBlbnYubW91c2UuZG93biwgdGhpcy5fcnNEb3duLCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXG5cdCAgICBldmVudCQxKGRvY3VtZW50LmJvZHksIGVudi5tb3VzZS51cCwgdGhpcy5fcnNVcCwge1xuXHQgICAgICBiaW5kOiB0aGlzXG5cdCAgICB9KTtcblxuXHQgICAgdmFyIGRpciA9IHRoaXMuX2dldFJlc2l6ZURpcigpO1xuXG5cdCAgICB0aGlzLl9yc19zdGFydGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9yZXNpemVyX2RpciA9IGRpcjtcblx0ICAgIHRoaXMuX3Jlc2l6ZXJfZGltID0gZGlyID09IFwieFwiID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIjtcblx0ICAgIGlmIChkaXIgPT0gXCJ4XCIpIGNvbmZpZy5oZWlnaHQgPSAwO2Vsc2UgY29uZmlnLndpZHRoID0gMDtcblxuXHQgICAgaWYgKHNwYWNlID4gMCkge1xuXHQgICAgICB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9yZXNpemVyX3ZcIiArIGRpcjtcblx0ICAgICAgdGhpcy5fdmlld29iai5zdHlsZS5tYXJnaW5SaWdodCA9IFwiLVwiICsgc3BhY2UgKyBcInB4XCI7XG5cdCAgICAgIGlmIChkaXIgPT0gXCJ4XCIpIGNvbmZpZy53aWR0aCA9IHNwYWNlO2Vsc2UgY29uZmlnLmhlaWdodCA9IHNwYWNlO1xuXHQgICAgICB0aGlzLiRub3NwYWNlID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9yZXNpemVyX1wiICsgZGlyO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfcmVzaXplcl9jb250ZW50Jz48L2Rpdj5cIjtcblx0ICAgIGlmIChkaXIgPT0gXCJ5XCIgJiYgc3BhY2UgPiAwKSB0aGlzLl92aWV3b2JqLnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiLVwiICsgKGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5kZWZhdWx0cy5oZWlnaHQpICsgXCJweFwiO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcIndlYml4X2Rpc2FibGVfZHJhZ1wiLCBcInRydWVcIik7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLWdyYWJiZWRcIiwgXCJmYWxzZVwiKTtcblx0ICB9LFxuXHQgIF9yc0Rvd246IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgY2VsbHMgPSB0aGlzLl9nZXRSZXNpemVyQ2VsbHMoKTsgLy9zb21lIHNpYmxpbmcgY2FuIGJsb2NrIHJlc2l6ZVxuXG5cblx0ICAgIGlmIChjZWxscyAmJiAhdGhpcy5fc2V0dGluZ3MuZGlzYWJsZWQpIHtcblx0ICAgICAgZSA9IGUgfHwgZXZlbnQkMTtcblx0ICAgICAgdGhpcy5fcnNfc3RhcnRlZCA9IHRydWU7XG5cdCAgICAgIHRoaXMuX3JzX3Byb2Nlc3MgPSBwb3MoZSk7XG5cdCAgICAgIHRoaXMuX3JzTGltaXQgPSBbXTtcblxuXHQgICAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcImFyaWEtZ3JhYmJlZFwiLCBcInRydWVcIik7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0ICAgICAgICBjZWxsc1tpXS4kdmlldy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRyb3BlZmZlY3RcIiwgXCJtb3ZlXCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRyb3BlZmZlY3RcIiwgXCJtb3ZlXCIpO1xuXG5cdCAgICAgIHRoaXMuX3JzU3RhcnQoZSwgY2VsbHNbMF0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3JzVXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3JzX3N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3JzX3Byb2Nlc3MgPSBmYWxzZTtcblx0ICB9LFxuXHQgIF9yc1N0YXJ0OiBmdW5jdGlvbiAoZSwgY2VsbCkge1xuXHQgICAgdmFyIGRpciwgY2VsbE9mZnNldCwgcG9zJCQxLCBwb3NQYXJlbnQsIHN0YXJ0O1xuXHQgICAgZSA9IGUgfHwgZXZlbnQkMTtcblx0ICAgIGRpciA9IHRoaXMuX3Jlc2l6ZXJfZGlyO1xuXHQgICAgLypsYXlvdXQgcG9zaXRpb246cmVsYXRpdmUgdG8gcGxhY2UgYWJzb2x1dGVseSBwb3NpdGlvbmVkIGVsZW1lbnRzIGluIGl0Ki9cblxuXHQgICAgdGhpcy5nZXRQYXJlbnRWaWV3KCkuX3ZpZXdvYmouc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdCAgICBwb3MkJDEgPSBvZmZzZXQodGhpcy5fdmlld29iaik7XG5cdCAgICBwb3NQYXJlbnQgPSBvZmZzZXQodGhpcy5nZXRQYXJlbnRWaWV3KCkuX3ZpZXdvYmopO1xuXHQgICAgc3RhcnQgPSBwb3MkJDFbZGlyXSAtIHBvc1BhcmVudFtkaXJdO1xuXHQgICAgY2VsbE9mZnNldCA9IG9mZnNldChjZWxsLiR2aWV3KVtkaXJdIC0gb2Zmc2V0KHRoaXMuZ2V0UGFyZW50VmlldygpLiR2aWV3KVtkaXJdO1xuXHQgICAgdGhpcy5fcnNfcHJvZ3Jlc3MgPSBbZGlyLCBjZWxsLCBzdGFydCwgY2VsbE9mZnNldF07XG5cdCAgICAvKnJlc2l6ZXIgc3RpY2sgKHJlc2l6ZXJlYSBleHQpKi9cblxuXHQgICAgdGhpcy5fcmVzaXplU3RpY2sgPSBuZXcgdWkucmVzaXplYXJlYSh7XG5cdCAgICAgIGNvbnRhaW5lcjogdGhpcy5nZXRQYXJlbnRWaWV3KCkuX3ZpZXdvYmosXG5cdCAgICAgIGRpcjogZGlyLFxuXHQgICAgICBldmVudFBvczogdGhpcy5fcnNfcHJvY2Vzc1tkaXJdLFxuXHQgICAgICBzdGFydDogc3RhcnQgLSAxLFxuXHQgICAgICBoZWlnaHQ6IHRoaXMuJGhlaWdodCxcblx0ICAgICAgd2lkdGg6IHRoaXMuJHdpZHRoLFxuXHQgICAgICBib3JkZXI6IDEsXG5cdCAgICAgIG1hcmdpbjogdGhpcy5nZXRQYXJlbnRWaWV3KCkuX3BhZGRpbmdbZGlyID09PSBcInhcIiA/IFwibGVmdFwiIDogXCJ0b3BcIl1cblx0ICAgIH0pO1xuXHQgICAgLypzdG9wcyByZXNpemluZyBvbiBzdGljayBtb3VzZXVwKi9cblxuXHQgICAgdGhpcy5fcmVzaXplU3RpY2suYXR0YWNoRXZlbnQoXCJvblJlc2l6ZUVuZFwiLCBiaW5kKHRoaXMuX3JzRW5kLCB0aGlzKSk7XG5cdCAgICAvKm5lZWRlZCB0byBzdG9wIHN0aWNrIG1vdmluZyB3aGVuIHRoZSBsaW1pdCBmb3IgZGltZW5zaW9uIGlzIHJlYWNoZWQqL1xuXG5cblx0ICAgIHRoaXMuX3Jlc2l6ZVN0aWNrLmF0dGFjaEV2ZW50KFwib25SZXNpemVcIiwgYmluZCh0aGlzLl9yc1Jlc2l6ZUhhbmRsZXIsIHRoaXMpKTtcblxuXHQgICAgYWRkQ3NzKGRvY3VtZW50LmJvZHksIFwid2ViaXhfbm9zZWxlY3RcIiwgMSk7XG5cdCAgfSxcblx0ICBfZ2V0UmVzaXplRGlyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnRWaWV3KCkuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gXCJ5XCIgOiBcInhcIjtcblx0ICB9LFxuXHQgIF9yc1Jlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjZWxscywgY29uZmlnLCBjRGlmZiwgZGlmZiwgZGlyLCBpLCBsaW1pdHMsIGxpbWl0U2l6ZXMsIHNpemVzLCB0b3RhbFNpemU7XG5cblx0ICAgIGlmICh0aGlzLl9yc19wcm9ncmVzcykge1xuXHQgICAgICBjZWxscyA9IHRoaXMuX2dldFJlc2l6ZXJDZWxscygpO1xuXHQgICAgICBkaXIgPSB0aGlzLl9yc19wcm9ncmVzc1swXTtcblx0ICAgICAgLyp2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiByZXNpemVyIGFuZCBzdGljayovXG5cblx0ICAgICAgZGlmZiA9IHRoaXMuX3Jlc2l6ZVN0aWNrLl9sYXN0X3Jlc3VsdCAtIHRoaXMuX3JzX3Byb2dyZXNzWzJdO1xuXHQgICAgICAvKm5ldyBzaXplcyBmb3IgdGhlIHJlc2l6ZWQgY2VsbHMsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHN0aWNrIHBvc2l0aW9uKi9cblxuXHQgICAgICBzaXplcyA9IHRoaXMuX3JzR2V0RGlmZkNlbGxTaXplcyhjZWxscywgZGlyLCBkaWZmKTtcblx0ICAgICAgLypzdW0gb2YgY2VsbHMgZGltZW5zaW9ucyovXG5cblx0ICAgICAgdG90YWxTaXplID0gY2VsbHNbMF1bXCIkXCIgKyB0aGlzLl9yZXNpemVyX2RpbV0gKyBjZWxsc1sxXVtcIiRcIiArIHRoaXMuX3Jlc2l6ZXJfZGltXTtcblx0ICAgICAgLyptYXggYW5kIG1pbiBsaW1pdHMgaWYgdGhleSdyZSBzZXQqL1xuXG5cdCAgICAgIGxpbWl0cyA9IGRpciA9PSBcInlcIiA/IFtcIm1pbkhlaWdodFwiLCBcIm1heEhlaWdodFwiXSA6IFtcIm1pbldpZHRoXCIsIFwibWF4V2lkdGhcIl07XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IDI7IGkrKykge1xuXHQgICAgICAgIGNvbmZpZyA9IGNlbGxzW2ldLl9zZXR0aW5ncztcblx0ICAgICAgICBjRGlmZiA9IGkgPyAtZGlmZiA6IGRpZmY7XG5cdCAgICAgICAgLyppZiBjRGlmZiBpcyBwb3NpdGl2ZSwgdGhlIHNpemUgb2YgaSBjZWxsIGlzIGluY3JlYXNlZCovXG5cblx0ICAgICAgICAvKmlmIHNpemUgaXMgYmlnZ2VyIHRoYW4gbWF4IGxpbWl0IG9yIHNpemUgaXMgc21hbGxlciB0aGFuIG1pbiBsaW1pdCovXG5cblx0ICAgICAgICB2YXIgbWluID0gY29uZmlnW2xpbWl0c1swXV07XG5cdCAgICAgICAgdmFyIG1heCA9IGNvbmZpZ1tsaW1pdHNbMV1dO1xuXG5cdCAgICAgICAgaWYgKGNEaWZmID4gMCAmJiBtYXggJiYgbWF4IDw9IHNpemVzW2ldIHx8IGNEaWZmIDwgMCAmJiAobWluIHx8IDMpID49IHNpemVzW2ldKSB7XG5cdCAgICAgICAgICB0aGlzLl9yc0xpbWl0W2ldID0gY0RpZmYgPiAwID8gbWF4IDogbWluIHx8IDM7XG5cdCAgICAgICAgICAvKm5ldyBzaXplcywgdGFraW5nIGludG8gYWNjb3VudCBtYXggYW5kIG1pbiBsaW1pdHMqL1xuXG5cdCAgICAgICAgICBsaW1pdFNpemVzID0gdGhpcy5fcnNHZXRMaW1pdENlbGxTaXplcyhjZWxscywgZGlyKTtcblx0ICAgICAgICAgIC8qc3RpY2sgcG9zaXRpb24qL1xuXG5cdCAgICAgICAgICB0aGlzLl9yZXNpemVTdGljay5fZHJhZ29iai5zdHlsZVtkaXIgPT0gXCJ5XCIgPyBcInRvcFwiIDogXCJsZWZ0XCJdID0gdGhpcy5fcnNfcHJvZ3Jlc3NbM10gKyBsaW1pdFNpemVzWzBdICsgXCJweFwiO1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2l6ZXNbaV0gPCAzKSB7XG5cdCAgICAgICAgICAvKmNlbGxzIHNpemUgY2FuIG5vdCBiZSBsZXNzIHRoYW4gMSovXG5cdCAgICAgICAgICB0aGlzLl9yZXNpemVTdGljay5fZHJhZ29iai5zdHlsZVtkaXIgPT0gXCJ5XCIgPyBcInRvcFwiIDogXCJsZWZ0XCJdID0gdGhpcy5fcnNfcHJvZ3Jlc3NbM10gKyBpICogdG90YWxTaXplICsgMSArIFwicHhcIjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5fcnNMaW1pdFtpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0UmVzaXplckNlbGxzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY2VsbHMsIGksIHJlcztcblx0ICAgIGNlbGxzID0gdGhpcy5nZXRQYXJlbnRWaWV3KCkuX2NlbGxzO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGNlbGxzW2ldID09IHRoaXMpIHtcblx0ICAgICAgICByZXMgPSBbdGhpcy5fZ2V0UnNDZWxsKGNlbGxzLCBpLCAxLCAtMSksIHRoaXMuX2dldFJzQ2VsbChjZWxscywgaSwgMSwgMSldO1xuXHQgICAgICAgIGlmICghcmVzWzBdIHx8ICFyZXNbMV0pIHJlcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHJlcztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldFJzQ2VsbDogZnVuY3Rpb24gKGNlbGxzLCBpLCBzdGVwLCBkaXIpIHtcblx0ICAgIHZhciBjZWxsID0gY2VsbHNbaSArIGRpciAqIHN0ZXBdO1xuXHQgICAgaWYgKGNlbGwgJiYgY2VsbC5fc2V0dGluZ3MuaGlkZGVuKSByZXR1cm4gdGhpcy5fZ2V0UnNDZWxsKGNlbGxzLCBpLCBzdGVwICsgMSwgZGlyKTtlbHNlIGlmIChjZWxsICYmIGNlbGwuX3NldHRpbmdzLiRub3Jlc2l6ZSkgcmV0dXJuIG51bGw7ZWxzZSByZXR1cm4gY2VsbDtcblx0ICB9LFxuXHQgIF9yc0VuZDogZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXHQgICAgdmFyIGNlbGxzLCBkaXIsIGRpZmYsIHNpemU7XG5cblx0ICAgIHZhciB2ZXJ0aWNhbCA9IHRoaXMuZ2V0UGFyZW50VmlldygpLl92ZXJ0aWNhbF9vcmllbnRhdGlvbjtcblxuXHQgICAgdGhpcy5fcmVzaXplclN0aWNrID0gbnVsbDtcblxuXHQgICAgaWYgKHRoaXMuX3JzX3Byb2dyZXNzKSB7XG5cdCAgICAgIGRpciA9IHRoaXMuX3JzX3Byb2dyZXNzWzBdO1xuXHQgICAgICBkaWZmID0gcmVzdWx0IC0gdGhpcy5fcnNfcHJvZ3Jlc3NbMl07XG5cdCAgICAgIGNlbGxzID0gdGhpcy5fZ2V0UmVzaXplckNlbGxzKCk7XG5cblx0ICAgICAgaWYgKGNlbGxzWzBdICYmIGNlbGxzWzFdKSB7XG5cdCAgICAgICAgLypuZXcgY2VsbCBzaXplcyovXG5cdCAgICAgICAgc2l6ZSA9IHRoaXMuX3JzR2V0Q2VsbFNpemVzKGNlbGxzLCBkaXIsIGRpZmYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0ICAgICAgICAgIC8vY2VsbCBoYXMgbm90IGZpeGVkIHNpemUsIG9mIGZ1bGx5IGZpeGVkIGxheW91dFxuXHQgICAgICAgICAgdmFyIGNlbGxfc2l6ZSA9IGNlbGxzW2ldLiRnZXRTaXplKDAsIDApO1xuXG5cdCAgICAgICAgICBpZiAodmVydGljYWwgPyBjZWxsX3NpemVbMl0gPT0gY2VsbF9zaXplWzNdIDogTWF0aC5hYnMoY2VsbF9zaXplWzFdIC0gY2VsbF9zaXplWzBdKSA8IDMpIHtcblx0ICAgICAgICAgICAgLypzZXQgZml4ZWQgc2l6ZXMgZm9yIGJvdGggY2VsbHMqL1xuXHQgICAgICAgICAgICBjZWxsc1tpXS5fc2V0dGluZ3NbdGhpcy5fcmVzaXplcl9kaW1dID0gc2l6ZVtpXTtcblx0ICAgICAgICAgICAgaWYgKGNlbGxzW2ldLl9idWJibGVfc2l6ZSkgY2VsbHNbaV0uX2J1YmJsZV9zaXplKHRoaXMuX3Jlc2l6ZXJfZGltLCBzaXplW2ldLCB2ZXJ0aWNhbCk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgYWN0dWFsU2l6ZSA9IGNlbGxzW2ldLiR2aWV3W3ZlcnRpY2FsID8gXCJvZmZzZXRIZWlnaHRcIiA6IFwib2Zmc2V0V2lkdGhcIl07IC8vY2VsbHNbaV1bXCIkXCIrdGhpcy5fcmVzaXplcl9kaW1dO1xuXG5cdCAgICAgICAgICAgIGNlbGxzW2ldLl9zZXR0aW5ncy5ncmF2aXR5ID0gc2l6ZVtpXSAvIGFjdHVhbFNpemUgKiBjZWxsc1tpXS5fc2V0dGluZ3MuZ3Jhdml0eTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjZWxsc1swXS5yZXNpemUoKTtcblxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAyOyBfaSsrKSB7XG5cdCAgICAgICAgICBpZiAoY2VsbHNbX2ldLmNhbGxFdmVudCkgY2VsbHNbX2ldLmNhbGxFdmVudChcIm9uVmlld1Jlc2l6ZVwiLCBbXSk7XG5cblx0ICAgICAgICAgIGNlbGxzW19pXS4kdmlldy5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRyb3BlZmZlY3RcIik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2FsbEV2ZW50KFwib25MYXlvdXRSZXNpemVcIiwgW2NlbGxzXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9yc19wcm9ncmVzcyA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9yc19wcm9ncmVzcyA9IGZhbHNlO1xuXHQgICAgdGhpcy5fcnNfc3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fcnNMaW1pdCA9IG51bGw7XG5cdCAgICByZW1vdmVDc3MoZG9jdW1lbnQuYm9keSwgXCJ3ZWJpeF9ub3NlbGVjdFwiKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLWdyYWJiZWRcIiwgXCJmYWxzZVwiKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRyb3BlZmZlY3RcIik7XG5cdCAgfSxcblx0ICBfcnNHZXRMaW1pdENlbGxTaXplczogZnVuY3Rpb24gKGNlbGxzKSB7XG5cdCAgICB2YXIgc2l6ZTEsIHNpemUyLCB0b3RhbFNpemU7XG5cdCAgICB0b3RhbFNpemUgPSBjZWxsc1swXVtcIiRcIiArIHRoaXMuX3Jlc2l6ZXJfZGltXSArIGNlbGxzWzFdW1wiJFwiICsgdGhpcy5fcmVzaXplcl9kaW1dO1xuXG5cdCAgICBpZiAodGhpcy5fcnNMaW1pdFswXSkge1xuXHQgICAgICBzaXplMSA9IHRoaXMuX3JzTGltaXRbMF07XG5cdCAgICAgIHNpemUyID0gdG90YWxTaXplIC0gc2l6ZTE7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3JzTGltaXRbMV0pIHtcblx0ICAgICAgc2l6ZTIgPSB0aGlzLl9yc0xpbWl0WzFdO1xuXHQgICAgICBzaXplMSA9IHRvdGFsU2l6ZSAtIHNpemUyO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gW3NpemUxLCBzaXplMl07XG5cdCAgfSxcblx0ICBfcnNHZXREaWZmQ2VsbFNpemVzOiBmdW5jdGlvbiAoY2VsbHMsIGRpciwgZGlmZikge1xuXHQgICAgdmFyIHNpemVzID0gW107XG5cdCAgICB2YXIgc3R5bGVEaW0gPSB0aGlzLl9yZXNpemVyX2RpbSA9PSBcImhlaWdodFwiID8gXCJvZmZzZXRIZWlnaHRcIiA6IFwib2Zmc2V0V2lkdGhcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0ICAgICAgc2l6ZXNbaV0gPSBjZWxsc1tpXS4kdmlld1tzdHlsZURpbV0gKyAoaSA/IC0xIDogMSkgKiBkaWZmO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2l6ZXM7XG5cdCAgfSxcblx0ICBfcnNHZXRDZWxsU2l6ZXM6IGZ1bmN0aW9uIChjZWxscywgZGlyLCBkaWZmKSB7XG5cdCAgICB2YXIgaSwgc2l6ZXMsIHRvdGFsU2l6ZTtcblx0ICAgIC8qaWYgbWF4IG9yIG1pbiBkaW1lbnRzaW9ucyBhcmUgc2V0Ki9cblxuXHQgICAgaWYgKHRoaXMuX3JzTGltaXRbMF0gfHwgdGhpcy5fcnNMaW1pdFsxXSkge1xuXHQgICAgICBzaXplcyA9IHRoaXMuX3JzR2V0TGltaXRDZWxsU2l6ZXMoY2VsbHMsIGRpcik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzaXplcyA9IHRoaXMuX3JzR2V0RGlmZkNlbGxTaXplcyhjZWxscywgZGlyLCBkaWZmKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdCAgICAgICAgLyppZiBzdGljayBtb3ZpbmcgaXMgc3RvcHBlZCBvdXRzaXplIGNlbGxzIGJvcmRlcnMqL1xuXHQgICAgICAgIGlmIChzaXplc1tpXSA8IDApIHtcblx0ICAgICAgICAgIHRvdGFsU2l6ZSA9IHNpemVzWzBdICsgc2l6ZXNbMV07XG5cdCAgICAgICAgICBzaXplc1tpXSA9IDE7XG5cdCAgICAgICAgICBzaXplc1sxIC0gaV0gPSB0b3RhbFNpemUgLSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2l6ZXM7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRlID0gZXhwb3J0cy5wcm90b1VJKGFwaSRlLCBNb3VzZUV2ZW50cywgRGVzdHJ1Y3Rpb24sIGJhc2Uudmlldyk7XG5cblx0dmFyIGFwaSRmID0ge1xuXHQgIG5hbWU6IFwiYWxpZ25cIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgIGxlZnQ6IDAsXG5cdCAgICB0b3A6IDAsXG5cdCAgICByaWdodDogMCxcblx0ICAgIGJvdHRvbTogMFxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X3ZpZXdfYWxpZ25cIjtcblx0ICB9LFxuXHQgIGdldENoaWxkVmlld3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBbdGhpcy5fYm9keV9jZWxsXTtcblx0ICB9LFxuXHQgIGJvZHlfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhbHVlLl9pbm5lciA9IHtcblx0ICAgICAgdG9wOiBmYWxzZSxcblx0ICAgICAgbGVmdDogZmFsc2UsXG5cdCAgICAgIHJpZ2h0OiBmYWxzZSxcblx0ICAgICAgYm90dG9tOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIHN0YXRlLl9wYXJlbnRfY2VsbCA9IHRoaXM7XG5cdCAgICB0aGlzLl9ib2R5X2NlbGwgPSB1aS5fdmlldyh2YWx1ZSk7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouYXBwZW5kQ2hpbGQodGhpcy5fYm9keV9jZWxsLl92aWV3b2JqKTtcblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgYWxpZ25fc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHZhbHVlID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuXHQgICAgdGhpcy5feF9hbGlnbiA9IHRoaXMuX3lfYWxpZ24gPSB0aGlzLl9wX2FsaWduID0gXCJcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgYyA9IHZhbHVlW2ldO1xuXHQgICAgICBpZiAoYyA9PT0gXCJjZW50ZXJcIiB8fCBjID09PSBcImxlZnRcIiB8fCBjID09PSBcInJpZ2h0XCIpIHRoaXMuX3hfYWxpZ24gPSBjO1xuXHQgICAgICBpZiAoYyA9PT0gXCJ0b3BcIiB8fCBjID09PSBcImJvdHRvbVwiIHx8IGMgPT09IFwibWlkZGxlXCIpIHRoaXMuX3lfYWxpZ24gPSBjO1xuXHQgICAgICBpZiAoYyA9PT0gXCJhYnNvbHV0ZVwiKSB0aGlzLl94X2FsaWduID0gdGhpcy5feV9hbGlnbiA9IHRoaXMuX3BfYWxpZ24gPSBcInByZWNpc2VcIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgZ2V0Qm9keTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2JvZHlfY2VsbDtcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTtcblx0ICAgIHZhciBkeCwgZHk7XG5cblx0ICAgIGlmICh0aGlzLl9wX2FsaWduKSB7XG5cdCAgICAgIGR4ID0geCAtIHRoaXMuX3NldHRpbmdzLmxlZnQgLSB0aGlzLl9zZXR0aW5ncy5yaWdodDtcblx0ICAgICAgZHkgPSB5IC0gdGhpcy5fc2V0dGluZ3MudG9wIC0gdGhpcy5fc2V0dGluZ3MuYm90dG9tO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZHggPSB0aGlzLl9kZXNpcmVkX3NpemVbMF0gfHwgeDtcblx0ICAgICAgZHkgPSB0aGlzLl9kZXNpcmVkX3NpemVbMl0gfHwgeTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fYm9keV9jZWxsLiRzZXRTaXplKGR4LCBkeSk7XG5cblx0ICAgIHZhciBib3ggPSB0aGlzLl9ib2R5X2NlbGwuX3ZpZXdvYmo7XG5cdCAgICBpZiAodGhpcy5feF9hbGlnbiA9PSBcImNlbnRlclwiKSBib3guc3R5bGUubWFyZ2luTGVmdCA9IE1hdGguY2VpbCgoeCAtIGR4KSAvIDIpICsgXCJweFwiO2Vsc2UgaWYgKHRoaXMuX3hfYWxpZ24gPT0gXCJyaWdodFwiKSBib3guc3R5bGUubWFyZ2luTGVmdCA9IHggLSBkeCArIFwicHhcIjtlbHNlIGJveC5zdHlsZS5tYXJnaW5MZWZ0ID0gKHRoaXMuX3BfYWxpZ24gPyB0aGlzLl9zZXR0aW5ncy5sZWZ0IDogMCkgKyBcInB4XCI7XG5cdCAgICBpZiAodGhpcy5feV9hbGlnbiA9PSBcIm1pZGRsZVwiKSBib3guc3R5bGUubWFyZ2luVG9wID0gTWF0aC5jZWlsKCh5IC0gZHkpIC8gMikgKyBcInB4XCI7ZWxzZSBpZiAodGhpcy5feV9hbGlnbiA9PSBcImJvdHRvbVwiKSBib3guc3R5bGUubWFyZ2luVG9wID0geSAtIGR5ICsgXCJweFwiO2Vsc2UgYm94LnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLl9wX2FsaWduID8gdGhpcy5fc2V0dGluZ3MudG9wIDogMCkgKyBcInB4XCI7XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgdmFyIHNpemUgPSB0aGlzLl9kZXNpcmVkX3NpemUgPSB0aGlzLl9ib2R5X2NlbGwuJGdldFNpemUoMCwgMCk7XG5cblx0ICAgIHZhciBzZWxmX3NpemUgPSBiYXNldmlldy5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCAwLCAwKTtcblxuXHQgICAgaWYgKHRoaXMuX3BfYWxpZ24pIHtcblx0ICAgICAgZHggKz0gdGhpcy5fc2V0dGluZ3MubGVmdCArIHRoaXMuX3NldHRpbmdzLnJpZ2h0O1xuXHQgICAgICBkeSArPSB0aGlzLl9zZXR0aW5ncy50b3AgKyB0aGlzLl9zZXR0aW5ncy5ib3R0b207XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5feF9hbGlnbiB8fCB0aGlzLl9wX2FsaWduKSB7XG5cdCAgICAgIHNlbGZfc2l6ZVswXSA9IHNpemVbMF0gKyBkeDtcblx0ICAgICAgc2VsZl9zaXplWzFdID0gc2l6ZVsxXSArIGR4O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZl9zaXplWzBdID0gKHNlbGZfc2l6ZVswXSB8fCBzaXplWzBdKSArIGR5O1xuXHQgICAgICBzZWxmX3NpemVbMV0gKz0gZHg7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5feV9hbGlnbiB8fCB0aGlzLl9wX2FsaWduKSB7XG5cdCAgICAgIHNlbGZfc2l6ZVsyXSA9IHNpemVbMl0gKyBkeTtcblx0ICAgICAgc2VsZl9zaXplWzNdID0gc2l6ZVszXSArIGR5O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZl9zaXplWzJdID0gKHNlbGZfc2l6ZVsyXSB8fCBzaXplWzJdKSArIGR5O1xuXHQgICAgICBzZWxmX3NpemVbM10gKz0gZHk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZWxmX3NpemU7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRmID0gZXhwb3J0cy5wcm90b1VJKGFwaSRmLCBiYXNlLnZpZXcpO1xuXG5cdHZhciBhcGkkZyA9IHtcblx0ICBuYW1lOiBcIm11bHRpdmlld1wiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBhbmltYXRlOiB7fVxuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICQkKHZhbCkuc2hvdygpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZUlkKCk7XG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fYWN0aXZlX2NlbGwgPSAwO1xuXHQgICAgdGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gPSAxO1xuXHQgICAgdGhpcy5fdmlld29iai5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X211bHRpdmlld1wiO1xuXHQgICAgdGhpcy5fYmFja19xdWV1ZSA9IFtdO1xuXHQgIH0sXG5cdCAgX2Fza19yZW5kZXI6IGZ1bmN0aW9uIChjZWxsX2lkLCB2aWV3X2lkKSB7XG5cdCAgICB2YXIgY2VsbCA9ICQkKGNlbGxfaWQpO1xuXG5cdCAgICBpZiAoIWNlbGwuX3JlbmRlcl9oYXNoKSB7XG5cdCAgICAgIGNlbGwuX3JlbmRlcl9xdWV1ZSA9IFtdO1xuXHQgICAgICBjZWxsLl9yZW5kZXJfaGFzaCA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNlbGwuX3JlbmRlcl9oYXNoW3ZpZXdfaWRdKSB7XG5cdCAgICAgIGNlbGwuX3JlbmRlcl9oYXNoW3ZpZXdfaWRdID0gdHJ1ZTtcblxuXHQgICAgICBjZWxsLl9yZW5kZXJfcXVldWUucHVzaCh2aWV3X2lkKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9yZW5kZXJfYWN0aXZhdGlvbjogZnVuY3Rpb24gKGNlbGxfaWQpIHtcblx0ICAgIHZhciBjZWxsID0gJCQoY2VsbF9pZCk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3Mua2VlcFZpZXdzKSBjZWxsLl92aWV3b2JqLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHQgICAgLypiYWNrIGFycmF5Ki9cblxuXHQgICAgaWYgKHRoaXMuX2JhY2tfcXVldWVbdGhpcy5fYmFja19xdWV1ZS5sZW5ndGggLSAyXSAhPSBjZWxsX2lkKSB7XG5cdCAgICAgIGlmICh0aGlzLl9iYWNrX3F1ZXVlLmxlbmd0aCA9PSAxMCkgdGhpcy5fYmFja19xdWV1ZS5zcGxpY2UoMCwgMSk7XG5cblx0ICAgICAgdGhpcy5fYmFja19xdWV1ZS5wdXNoKGNlbGxfaWQpO1xuXHQgICAgfSBlbHNlIHRoaXMuX2JhY2tfcXVldWUuc3BsaWNlKHRoaXMuX2JhY2tfcXVldWUubGVuZ3RoIC0gMSwgMSk7XG5cblx0ICAgIGlmIChjZWxsLl9yZW5kZXJfaGFzaCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGwuX3JlbmRlcl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBzdWJjZWxsID0gJCQoY2VsbC5fcmVuZGVyX3F1ZXVlW2ldKTsgLy9jZWxsIGNhbiBiZSBhbHJlYWR5IGRlc3Ryb3llZFxuXG5cdCAgICAgICAgaWYgKHN1YmNlbGwpIHN1YmNlbGwucmVuZGVyKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjZWxsLl9yZW5kZXJfcXVldWUgPSBbXTtcblx0ICAgICAgY2VsbC5fcmVuZGVyX2hhc2ggPSB7fTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGFkZFZpZXc6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpZCA9IGJhc2VsYXlvdXQuYXBpLmFkZFZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5rZWVwVmlld3MpICQkKGlkKS5fdmlld29iai5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7ZWxzZSByZW1vdmUoJCQoaWQpLl92aWV3b2JqKTtcblx0ICAgIHJldHVybiBpZDtcblx0ICB9LFxuXHQgIF9iZWZvcmVSZW1vdmVWaWV3OiBmdW5jdGlvbiAoaW5kZXgkJDEpIHtcblx0ICAgIC8vcmVtb3ZpbmcgY3VycmVudCB2aWV3XG5cdCAgICBpZiAoaW5kZXgkJDEgPT0gdGhpcy5fYWN0aXZlX2NlbGwpIHtcblx0ICAgICAgdmFyIG5leHQgPSBNYXRoLm1heChpbmRleCQkMSAtIDEsIDApO1xuXG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tuZXh0XSkge1xuXHQgICAgICAgIHRoaXMuX2luX2FuaW1hdGlvbiA9IGZhbHNlO1xuXG5cdCAgICAgICAgdGhpcy5fc2hvdyh0aGlzLl9jZWxsc1tuZXh0XSwgZmFsc2UpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChpbmRleCQkMSA8IHRoaXMuX2FjdGl2ZV9jZWxsKSB0aGlzLl9hY3RpdmVfY2VsbC0tO1xuXHQgIH0sXG5cdCAgLy9uZWNlc3NhcnksIGFzIHdlIHdhbnQgdG8gaWdub3JlIGhpZGUgY2FsbHMgZm9yIGVsZW1lbnRzIGluIG11bHRpdmlld1xuXHQgIF9oaWRlOiBmdW5jdGlvbiAoKSB7fSxcblx0ICBfcGFyc2VfY2VsbHM6IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG5cdCAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbiB8fCB0aGlzLl9jb2xsZWN0aW9uO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgY29sbGVjdGlvbltpXS5faW5uZXIgPSB0aGlzLl9zZXR0aW5ncy5ib3JkZXJsZXNzID8ge1xuXHQgICAgICAgIHRvcDogMSxcblx0ICAgICAgICBsZWZ0OiAxLFxuXHQgICAgICAgIHJpZ2h0OiAxLFxuXHQgICAgICAgIGJvdHRvbTogMVxuXHQgICAgICB9IDogdGhpcy5fc2V0dGluZ3MuX2lubmVyIHx8IHt9O1xuXHQgICAgfVxuXG5cdCAgICBiYXNlbGF5b3V0LmFwaS5fcGFyc2VfY2VsbHMuY2FsbCh0aGlzLCBjb2xsZWN0aW9uKTtcblxuXHQgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IHRoaXMuX2NlbGxzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3Mua2VlcFZpZXdzKSB0aGlzLl9jZWxsc1tfaV0uX3ZpZXdvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO2Vsc2UgcmVtb3ZlKHRoaXMuX2NlbGxzW19pXS5fdmlld29iaik7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICB2YXIgY2VsbCA9IHRoaXMuX2NlbGxzW19pMl07XG5cdCAgICAgIGlmIChjZWxsLl9jZWxscyAmJiAhY2VsbC5fcmVuZGVyX2JvcmRlcnMpIGNvbnRpbnVlO1xuXHQgICAgICB2YXIgX2lubmVyID0gY2VsbC5fc2V0dGluZ3MuX2lubmVyO1xuXHQgICAgICBpZiAoX2lubmVyLnRvcCkgY2VsbC5fdmlld29iai5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IFwiMHB4XCI7XG5cdCAgICAgIGlmIChfaW5uZXIubGVmdCkgY2VsbC5fdmlld29iai5zdHlsZS5ib3JkZXJMZWZ0V2lkdGggPSBcIjBweFwiO1xuXHQgICAgICBpZiAoX2lubmVyLnJpZ2h0KSBjZWxsLl92aWV3b2JqLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBcIjBweFwiO1xuXHQgICAgICBpZiAoX2lubmVyLmJvdHRvbSkgY2VsbC5fdmlld29iai5zdHlsZS5ib3JkZXJCb3R0b21XaWR0aCA9IFwiMHB4XCI7XG5cblx0ICAgICAgY2VsbC5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGFicGFuZWxcIik7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3JlbmRlcl9hY3RpdmF0aW9uKHRoaXMuZ2V0QWN0aXZlSWQoKSk7XG5cdCAgfSxcblx0ICBjZWxsc19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgYXNzZXJ0KHZhbHVlICYmIHZhbHVlLmxlbmd0aCwgXCJNdWx0aXZpZXcgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSB2aWV3IGluICdjZWxscydcIik7XG5cdCAgICB0aGlzLl9jb2xsZWN0aW9uID0gdmFsdWU7XG5cdCAgfSxcblx0ICBfZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiAobmV4dCwgYWN0aXZlKSB7XG5cdCAgICB2YXIgZGlyID0gKHRoaXMuX3NldHRpbmdzLmFuaW1hdGUgfHwge30pLmRpcmVjdGlvbjtcblx0ICAgIHZhciB2eCA9IGRpciA9PSBcInRvcFwiIHx8IGRpciA9PSBcImJvdHRvbVwiO1xuXHQgICAgcmV0dXJuIG5leHQgPCBhY3RpdmUgPyB2eCA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIgOiB2eCA/IFwidG9wXCIgOiBcImxlZnRcIjtcblx0ICB9LFxuXHQgIF9zaG93OiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb25fb3B0aW9ucykge1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50VmlldygpO1xuXHQgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuZ2V0VGFiYmFyKSBwYXJlbnQuZ2V0VGFiYmFyKCkuc2V0VmFsdWUob2JqLl9zZXR0aW5ncy4kaWQgfHwgb2JqLl9zZXR0aW5ncy5pZCk7XG5cdCAgICBpZiAodGhpcy5faW5fYW5pbWF0aW9uKSByZXR1cm4gZGVsYXkodGhpcy5fc2hvdywgdGhpcywgW29iaiwgYW5pbWF0aW9uX29wdGlvbnNdLCAxMDApO1xuXG5cdCAgICB2YXIgX25leHRfY2VsbCA9IC0xO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICh0aGlzLl9jZWxsc1tpXSA9PSBvYmopIHtcblx0ICAgICAgICBfbmV4dF9jZWxsID0gaTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoX25leHRfY2VsbCA8IDAgfHwgX25leHRfY2VsbCA9PSB0aGlzLl9hY3RpdmVfY2VsbCkgcmV0dXJuO1xuXHQgICAgdmFyIHByZXYgPSB0aGlzLl9jZWxsc1t0aGlzLl9hY3RpdmVfY2VsbF07XG5cdCAgICB2YXIgbmV4dCA9IHRoaXMuX2NlbGxzW19uZXh0X2NlbGxdO1xuXHQgICAgcHJldi4kZ2V0U2l6ZSgwLCAwKTsgLy9uZWVkIHRvIGJlIG1vdmVkIGluIGFuaW1hdGVcblxuXHQgICAgaWYgKChhbmltYXRpb25fb3B0aW9ucyB8fCB0eXBlb2YgYW5pbWF0aW9uX29wdGlvbnMgPT0gXCJ1bmRlZmluZWRcIikgJiYgYW5pbWF0ZS5pc1N1cHBvcnRlZCgpICYmIHRoaXMuX3NldHRpbmdzLmFuaW1hdGUpIHtcblx0ICAgICAgdmFyIGFuaXNldCA9IGV4cG9ydHMuZXh0ZW5kKHt9LCB0aGlzLl9zZXR0aW5ncy5hbmltYXRlKTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmtlZXBWaWV3cykgYW5pc2V0LmtlZXBWaWV3cyA9IHRydWU7XG5cdCAgICAgIGFuaXNldC5kaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oX25leHRfY2VsbCwgdGhpcy5fYWN0aXZlX2NlbGwpO1xuXHQgICAgICBhbmlzZXQgPSBTZXR0aW5ncy5fbWVyZ2VTZXR0aW5ncyhhbmltYXRpb25fb3B0aW9ucyB8fCB7fSwgYW5pc2V0KTtcblx0ICAgICAgdmFyIGxpbmUgPSBhbmltYXRlLmZvcm1MaW5lKG5leHQuX3ZpZXdvYmosIHByZXYuX3ZpZXdvYmosIGFuaXNldCk7XG5cdCAgICAgIG5leHQuJGdldFNpemUoMCwgMCk7XG5cdCAgICAgIG5leHQuJHNldFNpemUodGhpcy5fY29udGVudF93aWR0aCwgdGhpcy5fY29udGVudF9oZWlnaHQpO1xuXHQgICAgICB2YXIgY2FsbGJhY2tfb3JpZ2luYWwgPSBhbmlzZXQuY2FsbGJhY2s7XG5cblx0ICAgICAgYW5pc2V0LmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGFuaW1hdGUuYnJlYWtMaW5lKGxpbmUsIHRoaXMuX3NldHRpbmdzLmtlZXBWaWV3cyk7XG5cdCAgICAgICAgdGhpcy5faW5fYW5pbWF0aW9uID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKGNhbGxiYWNrX29yaWdpbmFsKSBjYWxsYmFja19vcmlnaW5hbC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGNhbGxiYWNrX29yaWdpbmFsID0gYW5pc2V0Lm1hc3RlciA9IGFuaXNldC5jYWxsYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZXNpemUoKTtcblx0ICAgICAgfTtcblxuXHQgICAgICBhbmlzZXQubWFzdGVyID0gdGhpcztcblx0ICAgICAgdGhpcy5fYWN0aXZlX2NlbGwgPSBfbmV4dF9jZWxsO1xuXG5cdCAgICAgIHRoaXMuX3JlbmRlcl9hY3RpdmF0aW9uKHRoaXMuZ2V0QWN0aXZlSWQoKSk7XG5cblx0ICAgICAgYW5pbWF0ZShsaW5lLCBhbmlzZXQpO1xuXHQgICAgICB0aGlzLl9pbl9hbmltYXRpb24gPSB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gYnJvd3NlcnMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCB0cmFuc2Zvcm0gYW5kIHRyYW5zaXRpb24sIG9yIGFuaW1hdGU6ZmFsc2UgaW4gY29uZmlnXG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5rZWVwVmlld3MpIHtcblx0ICAgICAgICBwcmV2Ll92aWV3b2JqLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZW1vdmUocHJldi5fdmlld29iaik7XG5cblx0ICAgICAgICB0aGlzLl92aWV3b2JqLmFwcGVuZENoaWxkKHRoaXMuX2NlbGxzW2ldLl92aWV3b2JqKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2FjdGl2ZV9jZWxsID0gX25leHRfY2VsbDtcblx0ICAgICAgdGhpcy5yZXNpemVDaGlsZHJlbigpO1xuXG5cdCAgICAgIHRoaXMuX3JlbmRlcl9hY3RpdmF0aW9uKHRoaXMuZ2V0QWN0aXZlSWQoKSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChuZXh0LmNhbGxFdmVudCkge1xuXHQgICAgICBuZXh0LmNhbGxFdmVudChcIm9uVmlld1Nob3dcIiwgW10pO1xuXHQgICAgICBlYWNoKG5leHQsIHRoaXMuX3NpZ25hbF9oaWRkZW5fY2VsbHMpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uVmlld0NoYW5nZVwiLCBbcHJldi5fc2V0dGluZ3MuaWQsIG5leHQuX3NldHRpbmdzLmlkXSk7XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgaWYgKCF0aGlzLl9jZWxscy5sZW5ndGgpIHJldHVybiBiYXNldmlldy5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCAwLCAwKTtcblx0ICAgIGRlYnVnX3NpemVfYm94X3N0YXJ0KHRoaXMsIHRydWUpO1xuXG5cdCAgICB2YXIgc2l6ZSA9IHRoaXMuX2NlbGxzW3RoaXMuX2FjdGl2ZV9jZWxsXS4kZ2V0U2l6ZSgwLCAwKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmZpdEJpZ2dlc3QpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChpICE9IHRoaXMuX2FjdGl2ZV9jZWxsKSB7XG5cdCAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLl9jZWxsc1tpXS4kZ2V0U2l6ZSgwLCAwKTtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcblx0ICAgICAgICAgICAgc2l6ZVtqXSA9IE1hdGgubWF4KHNpemVbal0sIG90aGVyW2pdKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy9nZXQgbGF5b3V0IHNpemVzXG5cblxuXHQgICAgdmFyIHNlbGZfc2l6ZSA9IGJhc2V2aWV3LmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIDAsIDApOyAvL3VzZSBjaGlsZCBzZXR0aW5ncyBpZiBsYXlvdXQncyBvbmUgd2FzIG5vdCBkZWZpbmVkXG5cblx0ICAgIGlmIChzZWxmX3NpemVbMV0gPj0gMTAwMDAwKSBzZWxmX3NpemVbMV0gPSAwO1xuXHQgICAgaWYgKHNlbGZfc2l6ZVszXSA+PSAxMDAwMDApIHNlbGZfc2l6ZVszXSA9IDA7XG5cdCAgICBzZWxmX3NpemVbMF0gPSAoc2VsZl9zaXplWzBdIHx8IHNpemVbMF0pICsgZHg7XG5cdCAgICBzZWxmX3NpemVbMV0gPSAoc2VsZl9zaXplWzFdIHx8IHNpemVbMV0pICsgZHg7XG5cdCAgICBzZWxmX3NpemVbMl0gPSAoc2VsZl9zaXplWzJdIHx8IHNpemVbMl0pICsgZHk7XG5cdCAgICBzZWxmX3NpemVbM10gPSAoc2VsZl9zaXplWzNdIHx8IHNpemVbM10pICsgZHk7XG5cdCAgICBkZWJ1Z19zaXplX2JveF9lbmQodGhpcywgc2VsZl9zaXplKTtcblx0ICAgIHJldHVybiBzZWxmX3NpemU7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmICghdGhpcy5fY2VsbHMubGVuZ3RoKSByZXR1cm47XG5cdCAgICB0aGlzLl9sYXlvdXRfc2l6ZXMgPSBbeCwgeV07XG5cdCAgICBiYXNldmlldy5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTtcblxuXHQgICAgdGhpcy5fY2VsbHNbdGhpcy5fYWN0aXZlX2NlbGxdLiRzZXRTaXplKHgsIHkpO1xuXHQgIH0sXG5cdCAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoYmFzZV9pZCwgY2VsbF9pZCkge1xuXHQgICAgaWYgKGNlbGxfaWQgJiYgY2VsbF9pZCAhPSB0aGlzLmdldEFjdGl2ZUlkKCkpIHtcblx0ICAgICAgaWYgKGJhc2VfaWQpIHRoaXMuX2Fza19yZW5kZXIoY2VsbF9pZCwgYmFzZV9pZCk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJhc2UuYXBpLmlzVmlzaWJsZS5jYWxsKHRoaXMsIGJhc2VfaWQsIHRoaXMuX3NldHRpbmdzLmlkKTtcblx0ICB9LFxuXHQgIGdldEFjdGl2ZUlkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fY2VsbHMubGVuZ3RoID8gdGhpcy5fY2VsbHNbdGhpcy5fYWN0aXZlX2NlbGxdLl9zZXR0aW5ncy5pZCA6IG51bGw7XG5cdCAgfSxcblx0ICBiYWNrOiBmdW5jdGlvbiAoc3RlcCkge1xuXHQgICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuXHQgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVCYWNrXCIsIFt0aGlzLmdldEFjdGl2ZUlkKCksIHN0ZXBdKSkge1xuXHQgICAgICBpZiAodGhpcy5fYmFja19xdWV1ZS5sZW5ndGggPiBzdGVwKSB7XG5cdCAgICAgICAgdmFyIHZpZXdJZCA9IHRoaXMuX2JhY2tfcXVldWVbdGhpcy5fYmFja19xdWV1ZS5sZW5ndGggLSBzdGVwIC0gMV07XG5cdCAgICAgICAgJCQodmlld0lkKS5zaG93KCk7XG5cdCAgICAgICAgcmV0dXJuIHZpZXdJZDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JGcgPSBleHBvcnRzLnByb3RvVUkoYXBpJGcsIGJhc2VsYXlvdXQudmlldyk7XG5cblx0dmFyIGFwaSRoID0ge1xuXHQgIG5hbWU6IFwidGFidmlld1wiLFxuXHQgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICB0aGlzLl9jZWxsc1swXS5zZXRWYWx1ZSh2YWwpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9jZWxsc1swXS5nZXRWYWx1ZSgpO1xuXHQgIH0sXG5cdCAgZ2V0VGFiYmFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fY2VsbHNbMF07XG5cdCAgfSxcblx0ICBnZXRNdWx0aXZpZXc6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9jZWxsc1sxXTtcblx0ICB9LFxuXHQgIGFkZFZpZXc6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHZhciBuaWQgPSB0aGlzLmdldE11bHRpdmlldygpLmFkZFZpZXcob2JqLmJvZHkpO1xuXHQgICAgb2JqLmlkID0gbmlkO1xuXHQgICAgb2JqLnZhbHVlID0gb2JqLmhlYWRlcjtcblx0ICAgIGRlbGV0ZSBvYmouYm9keTtcblx0ICAgIGRlbGV0ZSBvYmouaGVhZGVyO1xuXHQgICAgdmFyIHQgPSB0aGlzLmdldFRhYmJhcigpO1xuXHQgICAgdC5hZGRPcHRpb24ob2JqKTtcblx0ICAgIHJldHVybiBuaWQ7XG5cdCAgfSxcblx0ICByZW1vdmVWaWV3OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciB0ID0gdGhpcy5nZXRUYWJiYXIoKTtcblx0ICAgIHQucmVtb3ZlT3B0aW9uKGlkKTtcblx0ICAgIHQucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5faW5pdF90YWJ2aWV3X2hhbmRsZXJzKTtcblx0ICAgIHZhciBjZWxscyA9IGNvbmZpZy5jZWxscztcblx0ICAgIHZhciB0YWJzID0gW107XG5cdCAgICBhc3NlcnQoY2VsbHMgJiYgY2VsbHMubGVuZ3RoLCBcInRhYnZpZXcgbXVzdCBoYXZlIGNlbGxzIGNvbGxlY3Rpb25cIik7XG5cblx0ICAgIGZvciAodmFyIGkgPSBjZWxscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgdmlldyA9IGNlbGxzW2ldLmJvZHkgfHwgY2VsbHNbaV07XG5cdCAgICAgIGlmICghdmlldy5pZCkgdmlldy5pZCA9IFwidmlld1wiICsgdWlkKCk7XG5cdCAgICAgIHRhYnNbaV0gPSB7XG5cdCAgICAgICAgdmFsdWU6IGNlbGxzW2ldLmhlYWRlcixcblx0ICAgICAgICBpZDogdmlldy5pZCxcblx0ICAgICAgICBjbG9zZTogY2VsbHNbaV0uY2xvc2UsXG5cdCAgICAgICAgd2lkdGg6IGNlbGxzW2ldLndpZHRoLFxuXHQgICAgICAgIGhpZGRlbjogISFjZWxsc1tpXS5oaWRkZW5cblx0ICAgICAgfTtcblx0ICAgICAgY2VsbHNbaV0gPSB2aWV3O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdGFiYmFyID0ge1xuXHQgICAgICB2aWV3OiBcInRhYmJhclwiLFxuXHQgICAgICBtdWx0aXZpZXc6IHRydWVcblx0ICAgIH07XG5cdCAgICB2YXIgbXZpZXcgPSB7XG5cdCAgICAgIHZpZXc6IFwibXVsdGl2aWV3XCIsXG5cdCAgICAgIGNlbGxzOiBjZWxscyxcblx0ICAgICAgYW5pbWF0ZTogISFjb25maWcuYW5pbWF0ZVxuXHQgICAgfTtcblx0ICAgIGlmIChjb25maWcudmFsdWUpIHRhYmJhci52YWx1ZSA9IGNvbmZpZy52YWx1ZTtcblx0ICAgIGlmIChjb25maWcudGFiYmFyKSBleHBvcnRzLmV4dGVuZCh0YWJiYXIsIGNvbmZpZy50YWJiYXIsIHRydWUpO1xuXHQgICAgaWYgKGNvbmZpZy5tdWx0aXZpZXcpIGV4cG9ydHMuZXh0ZW5kKG12aWV3LCBjb25maWcubXVsdGl2aWV3LCB0cnVlKTtcblx0ICAgIHRhYmJhci5vcHRpb25zID0gdGFiYmFyLm9wdGlvbnMgfHwgdGFicztcblx0ICAgIGNvbmZpZy5yb3dzID0gW3RhYmJhciwgbXZpZXddO1xuXHQgICAgZGVsZXRlIGNvbmZpZy5jZWxscztcblx0ICAgIGRlbGV0ZSBjb25maWcudGFicztcblx0ICB9LFxuXHQgIF9pbml0X3RhYnZpZXdfaGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZ2V0VGFiYmFyKCkuYXR0YWNoRXZlbnQoXCJvbk9wdGlvblJlbW92ZVwiLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgdmFyIHZpZXcgPSAkJChpZCk7XG5cblx0ICAgICAgaWYgKHZpZXcpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gdmlldy5nZXRQYXJlbnRWaWV3KCk7XG5cdCAgICAgICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZVZpZXcodmlldyk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckaCA9IGV4cG9ydHMucHJvdG9VSShhcGkkaCwgbGF5b3V0LnZpZXcpO1xuXG5cdHZhciBhcGkkaSA9IHtcblx0ICBuYW1lOiBcImNhcm91c2VsXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHNjcm9sbFNwZWVkOiBcIjMwMG1zXCIsXG5cdCAgICB0eXBlOiBcImNsZWFuXCIsXG5cdCAgICBuYXZpZ2F0aW9uOiB7fSxcblx0ICAgIGFuaW1hdGU6IHRydWVcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9jYXJvdXNlbFwiO1xuXHQgICAgdGhpcy5fbGF5b3V0ID0gbnVsbDtcblx0ICAgIHRoaXMuX2RhdGFvYmogPSBudWxsO1xuXHQgICAgdGhpcy5fYWN0aXZlX2NlbGwgPSAwO1xuXHQgICAgdGhpcy4kcmVhZHkudW5zaGlmdCh0aGlzLl9pbml0TGF5b3V0KTtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fYWZ0ZXJfaW5pdF9jYWxsKTtcblx0ICB9LFxuXHQgIGFkZFZpZXc6IGZ1bmN0aW9uICh2aWV3LCBpbmRleCkge1xuXHQgICAgdmFyIHQgPSB0aGlzLl9sYXlvdXQuYWRkVmlldyh2aWV3LCBpbmRleCk7XG5cblx0ICAgIHRoaXMuX2ZpeF9hZnRlcl92aWV3X2FkZCgpO1xuXG5cdCAgICByZXR1cm4gdDtcblx0ICB9LFxuXHQgIHJlbW92ZVZpZXc6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5fbGF5b3V0LnJlbW92ZVZpZXcoaWQpO1xuXG5cdCAgICB0aGlzLl9maXhfYWZ0ZXJfdmlld19hZGQoKTtcblx0ICB9LFxuXHQgIF9yZXBsYWNlOiBmdW5jdGlvbiAobmV3X3ZpZXcsIHRhcmdldF9pZCkge1xuXHQgICAgdGhpcy5fbGF5b3V0Ll9yZXBsYWNlKG5ld192aWV3LCB0YXJnZXRfaWQpO1xuXG5cdCAgICB0aGlzLl9maXhfYWZ0ZXJfdmlld19hZGQoKTtcblx0ICB9LFxuXHQgIF9maXhfYWZ0ZXJfdmlld19hZGQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2NlbGxzID0gdGhpcy5fbGF5b3V0Ll9jZWxscztcblxuXHQgICAgdGhpcy5fcmVuZGVyUGFuZWwoKTtcblxuXHQgICAgdGhpcy5zZXRBY3RpdmVJbmRleChNYXRoLm1pbih0aGlzLl9hY3RpdmVfY2VsbCwgdGhpcy5fY2VsbHMubGVuZ3RoIC0gMSkpO1xuXHQgIH0sXG5cdCAgX2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmRlc3RydWN0b3IpIHRoaXMuX2xheW91dC5kZXN0cnVjdG9yKCk7XG5cdCAgICB2YXIgbGF5b3V0ID0gXCJcIjtcblxuXHQgICAgaWYgKHRoaXMuY29uZmlnLmNvbHMpIHtcblx0ICAgICAgbGF5b3V0ID0gXCJjb2xzXCI7XG5cdCAgICAgIHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxheW91dCA9IFwicm93c1wiO1xuXHQgICAgICB0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbiA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb25maWcgPSB7XG5cdCAgICAgIGJvcmRlcmxlc3M6IHRydWUsXG5cdCAgICAgIHR5cGU6IFwiY2xlYW5cIlxuXHQgICAgfTtcblx0ICAgIGNvbmZpZ1tsYXlvdXRdID0gY29weSh0aGlzLl9zZXR0aW5nc1tsYXlvdXRdKTtcblx0ICAgIHZhciBsYXlvdXRQcm9wID0gW1widHlwZVwiLCBcIm1hcmdpblwiLCBcIm1hcmdpblhcIiwgXCJtYXJnaW5ZXCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmdYXCIsIFwicGFkZGluZ1lcIl07XG5cdCAgICB2YXIgbGF5b3V0Q29uZmlnID0ge307XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0UHJvcC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3NbbGF5b3V0UHJvcFtpXV0pIHtcblx0ICAgICAgICBsYXlvdXRDb25maWdbbGF5b3V0UHJvcFtpXV0gPSB0aGlzLl9zZXR0aW5nc1tsYXlvdXRQcm9wW2ldXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBleHBvcnRzLmV4dGVuZChjb25maWcsIGxheW91dENvbmZpZywgdHJ1ZSk7XG5cdCAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSB0aGlzO1xuXHQgICAgdGhpcy5fbGF5b3V0ID0gdWkuX3ZpZXcoY29uZmlnKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5hcHBlbmRDaGlsZCh0aGlzLl9sYXlvdXQuX3ZpZXdvYmopO1xuXG5cdCAgICB0aGlzLl9jZWxscyA9IHRoaXMuX2xheW91dC5fY2VsbHM7XG5cdCAgICB0aGlzLl9sYXlvdXQuX3Nob3cgPSBiaW5kKGFwaSRpLl9zaG93LCB0aGlzKTtcblx0ICAgIHRoaXMuX2xheW91dC5hZGp1c3RTY3JvbGwgPSBiaW5kKGFwaSRpLmFkanVzdFNjcm9sbCwgdGhpcyk7XG5cdCAgICBhdHRhY2hFdmVudChcIm9uUmVjb25zdHJ1Y3RcIiwgYmluZChmdW5jdGlvbiAodmlldykge1xuXHQgICAgICBpZiAodmlldyA9PSB0aGlzLl9sYXlvdXQpIHRoaXMuX3NldFNjcm9sbCgpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgdGhpcy5fY29udGVudG9iaiA9IHRoaXMuX3ZpZXdvYmouZmlyc3RDaGlsZDtcblx0ICB9LFxuXHQgIF9vbktleVByZXNzOiBmdW5jdGlvbiAoY29kZSwgZSkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm5hdmlnYXRpb24uaXRlbXMgJiYgZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJ0YWJcIikgdGhpcy5fbW92ZUFjdGl2ZShjb2RlLCBlKTtcblxuXHQgICAgYmFzZXZpZXcuYXBpLl9vbktleVByZXNzLmNhbGwodGhpcywgY29kZSwgZSk7XG5cdCAgfSxcblx0ICBnZXRDaGlsZFZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gW3RoaXMuX2xheW91dF07XG5cdCAgfSxcblx0ICBnZXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG5cdCAgfSxcblx0ICBfYWZ0ZXJfaW5pdF9jYWxsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9jb250ZW50b2JqLnNldEF0dHJpYnV0ZShcInRvdWNoX3Njcm9sbFwiLCB0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbiA/IFwieVwiIDogXCJ4XCIpO1xuXG5cdCAgICB0aGlzLl9sYXlvdXQuYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2Nyb2xsXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uU2hvd1wiLCBbdGhpcy5nZXRBY3RpdmVJZCgpXSk7XG5cdCAgICB9LCB0aGlzKSk7XG5cblx0ICAgIGVhY2godGhpcy5fbGF5b3V0LCBmdW5jdGlvbiAodmlldykge1xuXHQgICAgICB2aWV3Ll92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0YWJwYW5lbFwiKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgYWRqdXN0U2Nyb2xsOiBmdW5jdGlvbiAobWF0cml4KSB7XG5cdCAgICB2YXIgc2l6ZSA9IHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gdGhpcy5fY29udGVudF9oZWlnaHQgOiB0aGlzLl9jb250ZW50X3dpZHRoO1xuXHQgICAgdmFyIGNvcnJlY3Rpb247XG5cblx0ICAgIGlmICh0aGlzLl92ZXJ0aWNhbF9vcmllbnRhdGlvbikge1xuXHQgICAgICBjb3JyZWN0aW9uID0gTWF0aC5yb3VuZChtYXRyaXguZiAvIHNpemUpO1xuXHQgICAgICBtYXRyaXguZiA9IGNvcnJlY3Rpb24gKiBzaXplO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY29ycmVjdGlvbiA9IE1hdGgucm91bmQobWF0cml4LmUgLyBzaXplKTtcblx0ICAgICAgbWF0cml4LmUgPSBjb3JyZWN0aW9uICogc2l6ZTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fYWN0aXZlX2NlbGwgPSAtY29ycmVjdGlvbjtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5uYXZpZ2F0aW9uKSB0aGlzLl9yZW5kZXJOYXZJdGVtcygpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBfc2hvdzogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIGksIGxheW91dCwgX25leHRDZWxsLCBfc2l6ZSwgeCwgeTtcblxuXHQgICAgX25leHRDZWxsID0gLTE7XG5cdCAgICBsYXlvdXQgPSB0aGlzLl9sYXlvdXQ7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsYXlvdXQuX2NlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChsYXlvdXQuX2NlbGxzW2ldID09IG9iaikge1xuXHQgICAgICAgIF9uZXh0Q2VsbCA9IGk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKF9uZXh0Q2VsbCA8IDAgfHwgX25leHRDZWxsID09IHRoaXMuX2FjdGl2ZV9jZWxsKSByZXR1cm47XG5cdCAgICB0aGlzLl9hY3RpdmVfY2VsbCA9IF9uZXh0Q2VsbDtcblx0ICAgIF9zaXplID0gbGF5b3V0Ll92ZXJ0aWNhbF9vcmllbnRhdGlvbiA/IHRoaXMuX2NvbnRlbnRfaGVpZ2h0IDogdGhpcy5fY29udGVudF93aWR0aDtcblx0ICAgIHggPSAtKGxheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24gPyAwIDogX25leHRDZWxsICogX3NpemUpO1xuXHQgICAgeSA9IC0obGF5b3V0Ll92ZXJ0aWNhbF9vcmllbnRhdGlvbiA/IF9uZXh0Q2VsbCAqIF9zaXplIDogMCk7XG5cdCAgICB0aGlzLnNjcm9sbFRvKHgsIHkpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNob3dcIiwgW2xheW91dC5fY2VsbHNbdGhpcy5fYWN0aXZlX2NlbGxdLl9zZXR0aW5ncy5pZF0pO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm5hdmlnYXRpb24pIHRoaXMuX3JlbmRlclBhbmVsKCk7XG5cdCAgfSxcblx0ICBzY3JvbGxUbzogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmIChUb3VjaCAmJiBhbmltYXRlLmlzU3VwcG9ydGVkKCkgJiYgdGhpcy5fc2V0dGluZ3MuYW5pbWF0ZSkgVG91Y2guX3NldF9tYXRyaXgodGhpcy5fY29udGVudG9iaiwgeCwgeSwgdGhpcy5fc2V0dGluZ3Muc2Nyb2xsU3BlZWQgfHwgXCIxMDBtc1wiKTtlbHNlIHtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS5tYXJnaW5MZWZ0ID0geCArIFwicHhcIjtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS5tYXJnaW5Ub3AgPSB5ICsgXCJweFwiO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgbmF2aWdhdGlvbl9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuX21lcmdlU2V0dGluZ3MoY29uZmlnLCB7XG5cdCAgICAgIHR5cGU6IFwiY29ybmVyXCIsXG5cdCAgICAgIGJ1dHRvbnM6IHRydWUsXG5cdCAgICAgIGl0ZW1zOiB0cnVlXG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvbmZpZztcblx0ICB9LFxuXHQgIHNob3dOZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fYWN0aXZlX2NlbGwgPCB0aGlzLl9sYXlvdXQuX2NlbGxzLmxlbmd0aCAtIDEpIHRoaXMuc2V0QWN0aXZlSW5kZXgodGhpcy5fYWN0aXZlX2NlbGwgKyAxKTtcblx0ICB9LFxuXHQgIHNob3dQcmV2OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fYWN0aXZlX2NlbGwgPiAwKSB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuX2FjdGl2ZV9jZWxsIC0gMSk7XG5cdCAgfSxcblx0ICBzZXRBY3RpdmVJbmRleDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBhc3NlcnQodmFsdWUgPCB0aGlzLl9sYXlvdXQuX2NlbGxzLmxlbmd0aCwgXCJOb3QgZXhpc3RpbmcgaW5kZXggaW4gY29sbGVjdGlvblwiKTtcblx0ICAgIHZhciBpZCA9IHRoaXMuX2xheW91dC5fY2VsbHNbdmFsdWVdLl9zZXR0aW5ncy5pZDtcblx0ICAgICQkKGlkKS5zaG93KCk7XG5cdCAgfSxcblx0ICBnZXRBY3RpdmVJbmRleDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZV9jZWxsO1xuXHQgIH0sXG5cdCAgJGdldFNpemU6IGZ1bmN0aW9uIChkeCwgZHkpIHtcblx0ICAgIHZhciBsYXlvdXRTaXplcyA9IHRoaXMuX2xheW91dC4kZ2V0U2l6ZSgwLCAwKTtcblxuXHQgICAgdmFyIHNlbGZTaXplcyA9IGJhc2UuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgZHgsIGR5KTtcblxuXHQgICAgaWYgKHRoaXMuX2xheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24pIHtcblx0ICAgICAgc2VsZlNpemVzWzBdID0gTWF0aC5tYXgoc2VsZlNpemVzWzBdLCBsYXlvdXRTaXplc1swXSk7XG5cdCAgICAgIHNlbGZTaXplc1sxXSA9IE1hdGgubWluKHNlbGZTaXplc1sxXSwgbGF5b3V0U2l6ZXNbMV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsZlNpemVzWzJdID0gTWF0aC5tYXgoc2VsZlNpemVzWzJdLCBsYXlvdXRTaXplc1syXSk7XG5cdCAgICAgIHNlbGZTaXplc1szXSA9IE1hdGgubWluKHNlbGZTaXplc1szXSwgbGF5b3V0U2l6ZXNbM10pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2VsZlNpemVzO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICB2YXIgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXHQgICAgdmFyIGMgPSBsYXlvdXQuX2NlbGxzLmxlbmd0aDtcblx0ICAgIHZhciBjaGFuZ2VkID0gYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTtcblx0ICAgIHZhciB5YyA9IHRoaXMuX2NvbnRlbnRfaGVpZ2h0ICogKGxheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24gPyBjIDogMSk7XG5cdCAgICB2YXIgeGMgPSB0aGlzLl9jb250ZW50X3dpZHRoICogKGxheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24gPyAxIDogYyk7XG5cblx0ICAgIGlmIChjaGFuZ2VkKSB7XG5cdCAgICAgIHRoaXMuX2NvbnRlbnRvYmouc3R5bGUuaGVpZ2h0ID0geWMgKyBcInB4XCI7XG5cdCAgICAgIHRoaXMuX2NvbnRlbnRvYmouc3R5bGUud2lkdGggPSB4YyArIFwicHhcIjtcblx0ICAgICAgbGF5b3V0LiRzZXRTaXplKHhjLCB5Yyk7XG5cblx0ICAgICAgdGhpcy5fc2V0U2Nyb2xsKCk7XG5cdCAgICB9IGVsc2UgbGF5b3V0LiRzZXRTaXplKHhjLCB5Yyk7XG5cdCAgfSxcblx0ICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXHQgICAgdmFyIGFjdGl2ZUNlbGwgPSB0aGlzLl9hY3RpdmVfY2VsbCB8fCAwO1xuXHQgICAgdmFyIHNpemUgPSBsYXlvdXQuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gdGhpcy5fY29udGVudF9oZWlnaHQgOiB0aGlzLl9jb250ZW50X3dpZHRoO1xuXHQgICAgdmFyIHggPSAtKGxheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24gPyAwIDogYWN0aXZlQ2VsbCAqIHNpemUpO1xuXHQgICAgdmFyIHkgPSAtKGxheW91dC5fdmVydGljYWxfb3JpZW50YXRpb24gPyBhY3RpdmVDZWxsICogc2l6ZSA6IDApO1xuXHQgICAgdGhpcy5zY3JvbGxUbyh4LCB5KTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5uYXZpZ2F0aW9uKSB0aGlzLl9yZW5kZXJQYW5lbCgpO1xuXHQgIH0sXG5cdCAgZ2V0QWN0aXZlSWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjZWxsID0gdGhpcy5fbGF5b3V0Ll9jZWxsc1t0aGlzLl9hY3RpdmVfY2VsbF07XG5cdCAgICByZXR1cm4gY2VsbCA/IGNlbGwuX3NldHRpbmdzLmlkIDogbnVsbDtcblx0ICB9LFxuXHQgIHNldEFjdGl2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAkJCh2YWx1ZSkuc2hvdygpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckaSA9IGV4cG9ydHMucHJvdG9VSShhcGkkaSwgRXZlbnRTeXN0ZW0sIE5hdmlnYXRpb25CdXR0b25zLCBiYXNlLnZpZXcpO1xuXG5cdHZhciBhcGkkaiA9IHtcblx0ICBuYW1lOiBcInByb3h5XCIsXG5cdCAgYm9keV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgc3RhdGUuX3BhcmVudF9jZWxsID0gdGhpcztcblx0ICAgIHRoaXMuX2JvZHlfY2VsbCA9IHVpLl92aWV3KHZhbHVlKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5hcHBlbmRDaGlsZCh0aGlzLl9ib2R5X2NlbGwuX3ZpZXdvYmopO1xuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBnZXRDaGlsZFZpZXdzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gW3RoaXMuX2JvZHlfY2VsbF07XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGJhc2UuYXBpLiRzZXRTaXplLmNhbGwodGhpcywgeCwgeSk7XG5cblx0ICAgIHRoaXMuX2JvZHlfY2VsbC4kc2V0U2l6ZSh0aGlzLiR3aWR0aCwgdGhpcy4kaGVpZ2h0KTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICB2YXIgc2VsZlNpemUgPSBiYXNlLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cblx0ICAgIHZhciBzaXplID0gdGhpcy5fYm9keV9jZWxsLiRnZXRTaXplKGR4LCBkeSk7XG5cblx0ICAgIHNpemVbMF0gPSBNYXRoLm1heChzZWxmU2l6ZVswXSwgc2l6ZVswXSk7XG5cdCAgICBzaXplWzFdID0gTWF0aC5taW4oc2VsZlNpemVbMV0sIHNpemVbMV0pO1xuXHQgICAgc2l6ZVsyXSA9IE1hdGgubWF4KHNlbGZTaXplWzJdLCBzaXplWzJdKTtcblx0ICAgIHNpemVbM10gPSBNYXRoLm1pbihzZWxmU2l6ZVszXSwgc2l6ZVszXSk7XG5cdCAgICBzaXplWzRdID0gTWF0aC5tYXgoc2VsZlNpemVbNF0sIHNpemVbNF0pO1xuXHQgICAgcmV0dXJuIHNpemU7XG5cdCAgfSxcblx0ICBfcmVwbGFjZTogZnVuY3Rpb24gKG4pIHtcblx0ICAgIHRoaXMuX2JvZHlfY2VsbC5kZXN0cnVjdG9yKCk7XG5cblx0ICAgIHRoaXMuX2JvZHlfY2VsbCA9IG47XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouYXBwZW5kQ2hpbGQobi5fdmlld29iaik7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRqID0gZXhwb3J0cy5wcm90b1VJKGFwaSRqLCBiYXNlLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJwb3J0bGV0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBwb3J0bGV0IDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcImRhc2hib2FyZFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogXCJHUEwgdmVyc2lvbiBkb2Vzbid0IHN1cHBvcnQgZGFzaGJvYXJkIDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcInBhbmVsXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBwYW5lbCA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJhYnNsYXlvdXRcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGFic2xheW91dCA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJncmlkbGF5b3V0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBncmlkbGF5b3V0IDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0dmFyIGFwaSRrID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBGbGV4TGF5b3V0LCB0cnVlKTtcblx0ICB9LFxuXHQgIG5hbWU6IFwiZmxleGxheW91dFwiXG5cdH07XG5cdHZhciB2aWV3JGsgPSBleHBvcnRzLnByb3RvVUkoYXBpJGssIGxheW91dC52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwiZmxleGRhdGFsYXlvdXRcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGZsZXhkYXRhbGF5b3V0IDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0dmFyIGFwaSRsID0ge1xuXHQgIG5hbWU6IFwicG9wdXBcIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuaGVhZCA9IGZhbHNlO1xuXHQgICAgdGhpcy4kdmlldy5jbGFzc05hbWUgKz0gXCIgd2ViaXhfcG9wdXBcIjtcblx0ICAgIGF0dGFjaEV2ZW50KFwib25DbGlja1wiLCBiaW5kKHRoaXMuX2hpZGUsIHRoaXMpKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkhpZGVcIiwgdGhpcy5faGlkZV9wb2ludCk7XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZhdWx0cy5oZWFkSGVpZ2h0ID0gJGFjdGl2ZS5iYXJIZWlnaHQ7XG5cdCAgICB0aGlzLmRlZmF1bHRzLnBhZGRpbmcgPSAkYWN0aXZlLnBvcHVwUGFkZGluZztcblx0ICAgIHRoaXMuZGVmYXVsdHMucG9pbnQgPSAhJGFjdGl2ZS5wb3B1cE5vUG9pbnQ7XG5cdCAgICB0aGlzLmRlZmF1bHRzLmJvcmRlcmxlc3MgPSAkYWN0aXZlLmJvcmRlcmxlc3NQb3B1cDtcblx0ICB9LFxuXHQgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZW1vdmUodGhpcy5fcG9pbnRfZWxlbWVudCk7XG5cdCAgICB3aW5kb3ckMS5hcGkuY2xvc2UuY2FsbCh0aGlzKTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgcmV0dXJuIHdpbmRvdyQxLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIHggKyB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nICogMiwgeSArIHRoaXMuX3NldHRpbmdzLnBhZGRpbmcgKiAyKTtcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTtcblx0ICAgIHggPSB0aGlzLl9jb250ZW50X3dpZHRoIC0gdGhpcy5fc2V0dGluZ3MucGFkZGluZyAqIDI7XG5cdCAgICB5ID0gdGhpcy5fY29udGVudF9oZWlnaHQgLSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nICogMjtcblx0ICAgIHRoaXMuX2NvbnRlbnRvYmouc3R5bGUucGFkZGluZyA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmcgKyBcInB4XCI7XG5cdCAgICB0aGlzLl9oZWFkb2JqLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuXHQgICAgdGhpcy5fYm9keV9jZWxsLiRzZXRTaXplKHgsIHkpO1xuXHQgIH0sXG5cdCAgLy9yZWRlZmluZSB0byBwcmVzZXJ2ZSBpbm5lciBib3JkZXJzXG5cdCAgLy9faW5uZXJfYm9keV9zZXQ6ZnVuY3Rpb24oKXt9LCAvL3NhbWUgYXMgd2luP1xuXHQgIF9pbm5lcl9ib2R5X3NldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlLmJvcmRlcmxlc3MgPT0gXCJ1bmRlZmluZWRcIikgdmFsdWUuYm9yZGVybGVzcyA9IGZhbHNlO1xuXHQgIH0sXG5cdCAgaGVhZF9zZXR0ZXI6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIF9zZXRfcG9pbnQ6IGZ1bmN0aW9uIChtb2RlLCBsZWZ0LCB0b3AsIGZpeGVkKSB7XG5cdCAgICB0aGlzLl9oaWRlX3BvaW50KCk7XG5cblx0ICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcG9pbnRfZWxlbWVudCA9IGNyZWF0ZShcIkRJVlwiLCB7XG5cdCAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9wb2ludF9cIiArIG1vZGVcblx0ICAgIH0sIFwiXCIpKTtcblx0ICAgIHRoaXMuX3BvaW50X2VsZW1lbnQuc3R5bGUuekluZGV4ID0gekluZGV4KCk7XG5cdCAgICB0aGlzLl9wb2ludF9lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gZml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG5cdCAgICB0aGlzLl9wb2ludF9lbGVtZW50LnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcblx0ICAgIHRoaXMuX3BvaW50X2VsZW1lbnQuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG5cdCAgfSxcblx0ICBfaGlkZV9wb2ludDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fcG9pbnRfZWxlbWVudCA9IHJlbW92ZSh0aGlzLl9wb2ludF9lbGVtZW50KTtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JGwgPSBleHBvcnRzLnByb3RvVUkoYXBpJGwsIHdpbmRvdyQxLnZpZXcpO1xuXHR2YXIgcG9wdXAgPSB7XG5cdCAgYXBpOiBhcGkkbCxcblx0ICB2aWV3OiB2aWV3JGxcblx0fTtcblxuXHR2YXIgYXBpJG0gPSB7XG5cdCAgbmFtZTogXCJ0b29sYmFyXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHR5cGU6IFwidG9vbGJhclwiXG5cdCAgfSxcblx0ICBfcmVuZGVyX2JvcmRlcnM6IHRydWUsXG5cdCAgX2Zvcm1fY2xhc3NuYW1lOiBcIndlYml4X3Rvb2xiYXJcIixcblx0ICBfZm9ybV92ZXJ0aWNhbDogZmFsc2UsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmICghY29uZmlnLmJvcmRlcmxlc3MpIHtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS5ib3JkZXJXaWR0aCA9IFwiMXB4XCI7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLl9pbm5lciA9IHtcblx0ICAgICAgICB0b3A6IGZhbHNlLFxuXHQgICAgICAgIGxlZnQ6IGZhbHNlLFxuXHQgICAgICAgIHJpZ2h0OiBmYWxzZSxcblx0ICAgICAgICBib3R0b206IGZhbHNlXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2NvbnRlbnRvYmouY2xhc3NOYW1lICs9IFwiIFwiICsgdGhpcy5fZm9ybV9jbGFzc25hbWU7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG5cdCAgfSxcblx0ICBfcmVjb2xsZWN0X2VsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZm9ybSA9IHRoaXM7XG5cdCAgICBmb3JtLmVsZW1lbnRzID0ge307XG5cdCAgICBlYWNoKHRoaXMsIGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICAgIGlmICh2aWV3Ll9zZXR0aW5ncy5uYW1lICYmIHZpZXcuZ2V0VmFsdWUgJiYgdmlldy5zZXRWYWx1ZSkge1xuXHQgICAgICAgIGZvcm0uZWxlbWVudHNbdmlldy5fc2V0dGluZ3MubmFtZV0gPSB2aWV3O1xuXHQgICAgICAgIGlmICh2aWV3Lm1hcEV2ZW50KSB2aWV3Lm1hcEV2ZW50KHtcblx0ICAgICAgICAgIG9uYmVmb3JldGFiY2xpY2s6IGZvcm0sXG5cdCAgICAgICAgICBvbmFmdGVydGFiY2xpY2s6IGZvcm0sXG5cdCAgICAgICAgICBvbml0ZW1jbGljazogZm9ybSxcblx0ICAgICAgICAgIG9uY2hhbmdlOiBmb3JtXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodmlldy5zZXRWYWx1ZXMpIHJldHVybiBmYWxzZTtcblx0ICAgIH0pO1xuXHQgICAgdmFyIG9sZCA9IHRoaXMuX3ZhbHVlcztcblx0ICAgIHRoaXMuc2V0RGlydHkoZmFsc2UpO1xuXG5cdCAgICBpZiAob2xkKSB7XG5cdCAgICAgIC8vcmVzdG9yZSBkaXJ0eSBzdGF0ZSBhZnRlciBmb3JtIHJlY29uc3RydWN0aW5nXG5cdCAgICAgIHZhciBub3cgPSB0aGlzLl92YWx1ZXM7XG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIGZvcm0uZWxlbWVudHMpIHtcblx0ICAgICAgICBpZiAob2xkW2tleV0gJiYgbm93W2tleV0gIT0gb2xkW2tleV0pIHtcblx0ICAgICAgICAgIG5vd1trZXldID0gb2xkW2tleV07XG5cdCAgICAgICAgICB0aGlzLnNldERpcnR5KHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3BhcnNlX2NlbGxzX2V4dF9lbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3JlY29sbGVjdF9lbGVtZW50cygpO1xuXHQgIH0sXG5cdCAgX3BhcnNlX2NlbGxzX2V4dDogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblxuXHQgICAgaWYgKGNvbmZpZy5lbGVtZW50cyAmJiAhY29sbGVjdGlvbikge1xuXHQgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbiA9IGNvbmZpZy5lbGVtZW50cztcblx0ICAgICAgdGhpcy5fdmVydGljYWxfb3JpZW50YXRpb24gPSB0aGlzLl9mb3JtX3ZlcnRpY2FsO1xuXHQgICAgICBkZWxldGUgY29uZmlnLmVsZW1lbnRzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZWxlbWVudHNDb25maWcpIHRoaXMuX3JlY19hcHBseV9zZXR0aW5ncyh0aGlzLl9jb2xsZWN0aW9uLCBjb25maWcuZWxlbWVudHNDb25maWcpO1xuXHQgICAgcmV0dXJuIGNvbGxlY3Rpb247XG5cdCAgfSxcblx0ICBfcmVjX2FwcGx5X3NldHRpbmdzOiBmdW5jdGlvbiAoY29sLCBzZXR0aW5ncykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGVsZW1lbnQgPSBjb2xbaV07XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKGVsZW1lbnQsIHNldHRpbmdzKTtcblx0ICAgICAgdmFyIG5leHRzZXR0aW5ncyA9IHNldHRpbmdzO1xuXHQgICAgICBpZiAoZWxlbWVudC5lbGVtZW50c0NvbmZpZykgbmV4dHNldHRpbmdzID0gZXhwb3J0cy5leHRlbmQoZXhwb3J0cy5leHRlbmQoe30sIGVsZW1lbnQuZWxlbWVudHNDb25maWcpLCBzZXR0aW5ncyk7XG5cdCAgICAgIHZhciBzdWI7XG5cdCAgICAgIGlmIChlbGVtZW50LmJvZHkpIHN1YiA9IFtlbGVtZW50LmJvZHldO2Vsc2Ugc3ViID0gZWxlbWVudC5yb3dzIHx8IGVsZW1lbnQuY29scyB8fCBlbGVtZW50LmNlbGxzIHx8IGVsZW1lbnQuYm9keTtcblx0ICAgICAgaWYgKHN1YikgdGhpcy5fcmVjX2FwcGx5X3NldHRpbmdzKHN1YiwgbmV4dHNldHRpbmdzKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICB2YXIgc2l6ZXMgPSBsYXlvdXQuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgZHgsIGR5KTtcblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFZpZXcoKTtcblx0ICAgIHZhciBpbmRleCA9IHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uID8gMyA6IDE7XG5cdCAgICBpZiAocGFyZW50ICYmIHRoaXMuX3ZlcnRpY2FsX29yaWVudGF0aW9uICE9IHBhcmVudC5fdmVydGljYWxfb3JpZW50YXRpb24pIHNpemVzW2luZGV4XSArPSAxMDAwMDA7XG5cdCAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBzaXplcywgdHJ1ZSk7XG5cdCAgICByZXR1cm4gc2l6ZXM7XG5cdCAgfSxcblx0ICByZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRtID0gZXhwb3J0cy5wcm90b1VJKGFwaSRtLCBTY3JvbGxhYmxlLCBBdG9tRGF0YUxvYWRlciwgVmFsdWVzLCBsYXlvdXQudmlldywgVmFsaWRhdGVEYXRhKTtcblx0dmFyIHRvb2xiYXIgPSB7XG5cdCAgYXBpOiBhcGkkbSxcblx0ICB2aWV3OiB2aWV3JG1cblx0fTtcblxuXHR2YXIgYXBpJG4gPSB7XG5cdCAgbmFtZTogXCJmb3JtXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHR5cGU6IFwiZm9ybVwiLFxuXHQgICAgYXV0b2hlaWdodDogdHJ1ZVxuXHQgIH0sXG5cdCAgX2RlZmF1bHRfaGVpZ2h0OiAtMSxcblx0ICBfZm9ybV9jbGFzc25hbWU6IFwid2ViaXhfZm9ybVwiLFxuXHQgIF9mb3JtX3ZlcnRpY2FsOiB0cnVlLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJmb3JtXCIpO1xuXHQgIH0sXG5cdCAgJGdldFNpemU6IGZ1bmN0aW9uIChkeCwgZHkpIHtcblx0ICAgIGlmICh0aGlzLl9zY3JvbGxfeSAmJiAhdGhpcy5fc2V0dGluZ3Mud2lkdGgpIGR4ICs9IGVudi5zY3JvbGxTaXplO1xuXHQgICAgdmFyIHNpemVzID0gbGF5b3V0LmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zY3JvbGwgfHwgIXRoaXMuX3NldHRpbmdzLmF1dG9oZWlnaHQpIHtcblx0ICAgICAgc2l6ZXNbMl0gPSB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgfHwgdGhpcy5fc2V0dGluZ3MubWluSGVpZ2h0IHx8IDA7XG5cdCAgICAgIHNpemVzWzNdICs9IDEwMDAwMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHNpemVzO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckbiA9IGV4cG9ydHMucHJvdG9VSShhcGkkbiwgdG9vbGJhci52aWV3KTtcblxuXHR2YXIgYXBpJG8gPSB7XG5cdCAgbmFtZTogXCJmaWVsZHNldFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBib3JkZXJsZXNzOiB0cnVlLFxuXHQgICAgJGNzc05hbWU6IFwid2ViaXhfZmllbGRzZXRcIixcblx0ICAgIHBhZGRpbmdYOiAxOCxcblx0ICAgIHBhZGRpbmdZOiAzMFxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIG9iai5ib2R5ID0gb2JqLmJvZHkgfHwge307XG5cdCAgICB2YXIgY3NzID0gdGhpcy5kZWZhdWx0cy4kY3NzTmFtZTtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIFwiICsgY3NzO1xuXHQgICAgdGhpcy5fdmlld29iai5pbm5lckhUTUwgPSBcIjxmaWVsZHNldD48bGVnZW5kIGNsYXNzPSdcIiArIGNzcyArIFwiX2xhYmVsXCIgKyAob2JqLnJlcXVpcmVkID8gXCIgd2ViaXhfcmVxdWlyZWRcIiA6IFwiXCIpICsgXCInPjwvbGVnZW5kPjxkaXYgY2xhc3M9J1wiICsgY3NzICsgXCJfYm9keSc+PC9kaXY+PC9maWVsZHNldD5cIjtcblx0ICB9LFxuXHQgIGxhYmVsX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLmZpcnN0Q2hpbGQuY2hpbGROb2Rlc1swXS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGdldENoaWxkVmlld3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBbdGhpcy5fYm9keV92aWV3XTtcblx0ICB9LFxuXHQgIGJvZHlfc2V0dGVyOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBzdGF0ZS5fcGFyZW50X2NlbGwgPSB0aGlzO1xuXHQgICAgdGhpcy5fYm9keV92aWV3ID0gdWkoY29uZmlnLCB0aGlzLl92aWV3b2JqLmZpcnN0Q2hpbGQuY2hpbGROb2Rlc1sxXSk7XG5cdCAgICByZXR1cm4gY29uZmlnO1xuXHQgIH0sXG5cdCAgZ2V0Qm9keTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2JvZHlfdmlldztcblx0ICB9LFxuXHQgIHJlc2l6ZUNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX2JvZHlfdmlldykgcmV0dXJuO1xuXHQgICAgdmFyIHggPSB0aGlzLiR3aWR0aCAtIHRoaXMuX3NldHRpbmdzLnBhZGRpbmdYO1xuXHQgICAgdmFyIHkgPSB0aGlzLiRoZWlnaHQgLSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nWTtcblxuXHQgICAgdmFyIHNpemVzID0gdGhpcy5fYm9keV92aWV3LiRnZXRTaXplKDAsIDApOyAvL21pbldpZHRoXG5cblxuXHQgICAgaWYgKHNpemVzWzBdID4geCkgeCA9IHNpemVzWzBdOyAvL21pbkhlaWdodFxuXG5cdCAgICBpZiAoc2l6ZXNbMl0gPiB5KSB5ID0gc2l6ZXNbMl07XG5cblx0ICAgIHRoaXMuX2JvZHlfdmlldy4kc2V0U2l6ZSh4LCB5KTtcblxuXHQgICAgdGhpcy5yZXNpemUoKTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgZGVidWdfc2l6ZV9ib3hfc3RhcnQodGhpcywgdHJ1ZSk7XG5cdCAgICB4ICs9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdYO1xuXHQgICAgeSArPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nWTtcblxuXHQgICAgdmFyIHQgPSB0aGlzLl9ib2R5X3ZpZXcuJGdldFNpemUoeCwgeSk7XG5cblx0ICAgIHZhciBzID0gdGhpcy5fbGFzdF9ib2R5X3NpemUgPSBiYXNlLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpOyAvL2lubmVyIGNvbnRlbnQgbWluV2lkdGggPiBvdXRlclxuXG5cdCAgICBpZiAoc1swXSA8IHRbMF0pIHNbMF0gPSB0WzBdO1xuXHQgICAgaWYgKHNbMl0gPCB0WzJdKSBzWzJdID0gdFsyXTsgLy9pbm5lciBjb250ZW50IG1heFdpZHRoIDwgb3V0ZXJcblxuXHQgICAgaWYgKHNbMV0gPiB0WzFdKSBzWzFdID0gdFsxXTtcblx0ICAgIGlmIChzWzNdID4gdFszXSkgc1szXSA9IHRbM107IC8vbWFrZSBtYXggc2l6ZSBub3QgbGVzcyB0aGFuIG1pbiBzaXplXG5cblx0ICAgIGlmIChzWzFdIDwgc1swXSkgc1sxXSA9IHNbMF07XG5cdCAgICBpZiAoc1szXSA8IHNbMl0pIHNbM10gPSBzWzJdO1xuXHQgICAgZGVidWdfc2l6ZV9ib3hfZW5kKHRoaXMsIHMpO1xuXHQgICAgcmV0dXJuIHM7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmIChiYXNlLmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpKSB7XG5cdCAgICAgIHggPSBNYXRoLm1pbih0aGlzLl9sYXN0X2JvZHlfc2l6ZVsxXSwgeCk7XG5cdCAgICAgIHkgPSBNYXRoLm1pbih0aGlzLl9sYXN0X2JvZHlfc2l6ZVszXSwgeSk7XG5cblx0ICAgICAgdGhpcy5fYm9keV92aWV3LiRzZXRTaXplKHggLSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nWCwgeSAtIHRoaXMuX3NldHRpbmdzLnBhZGRpbmdZKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JG8gPSBleHBvcnRzLnByb3RvVUkoYXBpJG8sIGJhc2Uudmlldyk7XG5cdHZhciBmaWVsZHNldCA9IHtcblx0ICBhcGk6IGFwaSRvLFxuXHQgIHZpZXc6IHZpZXckb1xuXHR9O1xuXG5cdHZhciBhcGkkcCA9IHtcblx0ICBuYW1lOiBcImZvcm1pbnB1dFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICAkY3NzTmFtZTogXCJ3ZWJpeF9mb3JtaW5wdXRcIixcblx0ICAgIGxhYmVsV2lkdGg6IDgwLFxuXHQgICAgbGFiZWxBbGlnbjogXCJsZWZ0XCIsXG5cdCAgICAvLyByZW1vdmUgZmllbGRzZXQgc2l6aW5nXG5cdCAgICBwYWRkaW5nWTogMCxcblx0ICAgIHBhZGRpbmdYOiAwXG5cdCAgfSxcblx0ICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fYm9keV92aWV3LnNldFZhbHVlKSB0aGlzLl9ib2R5X3ZpZXcuc2V0VmFsdWUodmFsdWUpO2Vsc2UgaWYgKHRoaXMuX2JvZHlfdmlldy5zZXRWYWx1ZXMpIHRoaXMuX2JvZHlfdmlldy5zZXRWYWx1ZXModmFsdWUpO1xuXHQgIH0sXG5cdCAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9ib2R5X3ZpZXcuZm9jdXMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2JvZHlfdmlldy5mb2N1cygpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX2JvZHlfdmlldy5nZXRWYWx1ZSkgcmV0dXJuIHRoaXMuX2JvZHlfdmlldy5nZXRWYWx1ZSgpO2Vsc2UgaWYgKHRoaXMuX2JvZHlfdmlldy5nZXRWYWx1ZXMpIHJldHVybiB0aGlzLl9ib2R5X3ZpZXcuZ2V0VmFsdWVzKCk7XG5cdCAgfSxcblx0ICBnZXRCb2R5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fYm9keV92aWV3O1xuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2lucHV0UGFkZGluZyA9ICRhY3RpdmUuaW5wdXRQYWRkaW5nO1xuXHQgICAgdGhpcy5faW5wdXRTcGFjaW5nID0gJGFjdGl2ZS5pbnB1dFNwYWNpbmc7XG5cdCAgICB0aGlzLl9sYWJlbFRvcEhlaWdodCA9ICRhY3RpdmUubGFiZWxUb3BIZWlnaHQgfHwgMTU7XG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdGhpcy4kcmVhZHkucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBsYWJlbCA9IHRoaXMuX3ZpZXdvYmouZmlyc3RDaGlsZC5jaGlsZE5vZGVzWzBdO1xuXG5cdCAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MubGFiZWwgfHwgIXRoaXMuX3NldHRpbmdzLmxhYmVsV2lkdGgpIHtcblx0ICAgICAgICBsYWJlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgICAgdGhpcy5fc2V0dGluZ3MucGFkZGluZ1ggPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nWSA9IDA7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmxhYmVsUG9zaXRpb24gPT0gXCJ0b3BcIikge1xuXHQgICAgICAgIGxhYmVsLnN0eWxlLmxpbmVIZWlnaHQgPSB0aGlzLl9sYWJlbFRvcEhlaWdodCAtIHRoaXMuX2lucHV0UGFkZGluZyArIFwicHhcIjtcblx0ICAgICAgICBsYWJlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyB0aGlzLmRlZmF1bHRzLiRjc3NOYW1lICsgXCJfbGFiZWxfdG9wXCI7XG5cdCAgICAgIH0gZWxzZSBsYWJlbC5zdHlsZS53aWR0aCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdYICsgXCJweFwiO1xuXG5cdCAgICAgIGxhYmVsLnN0eWxlLnRleHRBbGlnbiA9IHRoaXMuX3NldHRpbmdzLmxhYmVsQWxpZ247XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy52YWx1ZSkgdGhpcy5zZXRWYWx1ZSh0aGlzLl9zZXR0aW5ncy52YWx1ZSk7XG5cdCAgICB9KTtcblxuXHQgICAgaWYgKG9iai5sYWJlbFBvc2l0aW9uICE9IFwidG9wXCIpIHtcblx0ICAgICAgdmFyIGx3ID0gaXNVbmRlZmluZWQob2JqLmxhYmVsV2lkdGgpID8gdGhpcy5kZWZhdWx0cy5sYWJlbFdpZHRoIDogb2JqLmxhYmVsV2lkdGg7XG5cdCAgICAgIG9iai5wYWRkaW5nWCA9IGx3IC0gdGhpcy5faW5wdXRQYWRkaW5nICogMiArIHRoaXMuX2lucHV0U3BhY2luZyAqIDI7XG5cdCAgICB9IGVsc2Ugb2JqLnBhZGRpbmdZID0gdGhpcy5fbGFiZWxUb3BIZWlnaHQ7XG5cdCAgfSxcblx0ICBzZXRCb3R0b21UZXh0OiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAodHlwZW9mIHRleHQgIT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICBpZiAoY29uZmlnLmJvdHRvbUxhYmVsID09IHRleHQpIHJldHVybjtcblx0ICAgICAgY29uZmlnLmJvdHRvbUxhYmVsID0gdGV4dDtcblx0ICAgIH1cblxuXHQgICAgdmFyIG1lc3NhZ2UgPSAoY29uZmlnLmludmFsaWQgPyBjb25maWcuaW52YWxpZE1lc3NhZ2UgOiBcIlwiKSB8fCBjb25maWcuYm90dG9tTGFiZWw7XG5cblx0ICAgIGlmICh0aGlzLl9pbnZhbGlkTWVzc2FnZSkge1xuXHQgICAgICByZW1vdmUodGhpcy5faW52YWxpZE1lc3NhZ2UpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWVzc2FnZSkge1xuXHQgICAgICB0aGlzLiR2aWV3LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHQgICAgICB0aGlzLl9pbnZhbGlkTWVzc2FnZSA9IGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X2lucF9ib3R0b21fbGFiZWxcIixcblx0ICAgICAgICByb2xlOiBjb25maWcuaW52YWxpZCA/IFwiYWxlcnRcIiA6IFwiXCIsXG5cdCAgICAgICAgXCJhcmlhLXJlbGV2YW50XCI6IFwiYWxsXCIsXG5cdCAgICAgICAgc3R5bGU6IFwicG9zaXRpb246YWJzb2x1dGU7IGJvdHRvbTowcHg7IHBhZGRpbmc6MnB4OyBiYWNrZ3JvdW5kOiB3aGl0ZTsgbGVmdDpcIiArIHRoaXMuX3NldHRpbmdzLmxhYmVsV2lkdGggKyBcInB4OyBcIlxuXHQgICAgICB9LCBtZXNzYWdlKTtcblxuXHQgICAgICB0aGlzLl92aWV3b2JqLmFwcGVuZENoaWxkKHRoaXMuX2ludmFsaWRNZXNzYWdlKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JHAgPSBleHBvcnRzLnByb3RvVUkoYXBpJHAsIGZpZWxkc2V0LnZpZXcpO1xuXG5cdGZ1bmN0aW9uIF90YWduYW1lKGVsKSB7XG5cdCAgaWYgKCFlbC50YWdOYW1lKSByZXR1cm4gbnVsbDtcblx0ICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2F0dHJpYnV0ZShlbCwgbmFtZSkge1xuXHQgIGlmICghZWwuZ2V0QXR0cmlidXRlKSByZXR1cm4gbnVsbDtcblx0ICB2YXIgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0ICByZXR1cm4gYXR0ciA/IGF0dHIudG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0X2h0bWxfdmFsdWUoKSB7XG5cdCAgdmFyIHRhZ25hbWUgPSBfdGFnbmFtZSh0aGlzKTtcblxuXHQgIGlmIChfZ2V0X3ZhbHVlW3RhZ25hbWVdKSByZXR1cm4gX2dldF92YWx1ZVt0YWduYW1lXSh0aGlzKTtcblx0ICByZXR1cm4gX2dldF92YWx1ZS5vdGhlcih0aGlzKTtcblx0fVxuXG5cdHZhciBfZ2V0X3ZhbHVlID0ge1xuXHQgIHJhZGlvOiBmdW5jdGlvbiAoZWwpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGVsW2ldLmNoZWNrZWQpIHJldHVybiBlbFtpXS52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFwiXCI7XG5cdCAgfSxcblx0ICBpbnB1dDogZnVuY3Rpb24gKGVsKSB7XG5cdCAgICB2YXIgdHlwZSA9IF9hdHRyaWJ1dGUoZWwsIFwidHlwZVwiKTtcblxuXHQgICAgaWYgKHR5cGUgPT09IFwiY2hlY2tib3hcIikgcmV0dXJuIGVsLmNoZWNrZWQ7XG5cdCAgICByZXR1cm4gZWwudmFsdWU7XG5cdCAgfSxcblx0ICB0ZXh0YXJlYTogZnVuY3Rpb24gKGVsKSB7XG5cdCAgICByZXR1cm4gZWwudmFsdWU7XG5cdCAgfSxcblx0ICBzZWxlY3Q6IGZ1bmN0aW9uIChlbCkge1xuXHQgICAgdmFyIGluZGV4JCQxID0gZWwuc2VsZWN0ZWRJbmRleDtcblx0ICAgIHJldHVybiBlbC5vcHRpb25zW2luZGV4JCQxXS52YWx1ZTtcblx0ICB9LFxuXHQgIG90aGVyOiBmdW5jdGlvbiAoZWwpIHtcblx0ICAgIHJldHVybiBlbC5pbm5lckhUTUw7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9zZXRfaHRtbF92YWx1ZSh2YWx1ZSkge1xuXHQgIHZhciB0YWduYW1lID0gX3RhZ25hbWUodGhpcyk7XG5cblx0ICBpZiAoX3NldF92YWx1ZVt0YWduYW1lXSkgcmV0dXJuIF9zZXRfdmFsdWVbdGFnbmFtZV0odGhpcywgdmFsdWUpO1xuXHQgIHJldHVybiBfc2V0X3ZhbHVlLm90aGVyKHRoaXMsIHZhbHVlKTtcblx0fVxuXG5cdHZhciBfc2V0X3ZhbHVlID0ge1xuXHQgIHJhZGlvOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGVsW2ldLmNoZWNrZWQgPSBlbFtpXS52YWx1ZSA9PSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGlucHV0OiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG5cdCAgICB2YXIgdHlwZSA9IF9hdHRyaWJ1dGUoZWwsIFwidHlwZVwiKTtcblxuXHQgICAgaWYgKHR5cGUgPT09IFwiY2hlY2tib3hcIikgZWwuY2hlY2tlZCA9IHZhbHVlID8gdHJ1ZSA6IGZhbHNlO2Vsc2UgZWwudmFsdWUgPSB2YWx1ZTtcblx0ICB9LFxuXHQgIHRleHRhcmVhOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG5cdCAgICBlbC52YWx1ZSA9IHZhbHVlO1xuXHQgIH0sXG5cdCAgc2VsZWN0OiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG5cdCAgICAvL3NlbGVjdCBmaXJzdCBvcHRpb24gaWYgbm8gcHJvdmlkZWQgYW5kIGlmIHBvc3NpYmxlXG5cdCAgICBlbC52YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBlbC5maXJzdEVsZW1lbnRDaGlsZC52YWx1ZSB8fCB2YWx1ZTtcblx0ICB9LFxuXHQgIG90aGVyOiBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7XG5cdCAgICBlbC5pbm5lckhUTUwgPSB2YWx1ZTtcblx0ICB9XG5cdH07XG5cdHZhciBhcGkkcSA9IHtcblx0ICBuYW1lOiBcImh0bWxmb3JtXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcblx0ICAgIHRoaXMuX2RlZmF1bHRfdmFsdWVzID0gZmFsc2U7XG5cdCAgICBpZiAoY29uZmlnLmNvbnRlbnQgJiYgKGNvbmZpZy5jb250YWluZXIgPT0gY29uZmlnLmNvbnRlbnQgfHwgIWNvbmZpZy5jb250YWluZXIgJiYgY29uZmlnLmNvbnRlbnQgPT0gZG9jdW1lbnQuYm9keSkpIHRoaXMuX2NvcHlfaW5uZXJfY29udGVudCA9IHRydWU7XG5cdCAgfSxcblx0ICBjb250ZW50X3NldHRlcjogZnVuY3Rpb24gKGNvbnRlbnQpIHtcblx0ICAgIGNvbnRlbnQgPSB0b05vZGUoY29udGVudCk7XG5cblx0ICAgIGlmICh0aGlzLl9jb3B5X2lubmVyX2NvbnRlbnQpIHtcblx0ICAgICAgd2hpbGUgKGNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgdGhpcy5fdmlld29iai5jaGlsZE5vZGVzWzBdLmFwcGVuZENoaWxkKGNvbnRlbnQuY2hpbGROb2Rlc1swXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouY2hpbGROb2Rlc1swXS5hcHBlbmRDaGlsZChjb250ZW50KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcGFyc2VfaW5wdXRzKCk7XG5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0ZW1wbGF0ZSQxLmFwaS5yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHQgICAgdGhpcy5fcGFyc2VfaW5wdXRzKCk7XG5cdCAgfSxcblx0ICBfcGFyc2VfaW5wdXRzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaW5wdXRzID0gdGhpcy5fdmlld29iai5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWVdXCIpO1xuXG5cdCAgICB0aGlzLmVsZW1lbnRzID0ge307XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBlbCA9IGlucHV0c1tpXTtcblxuXHQgICAgICB2YXIgbmFtZSA9IF9hdHRyaWJ1dGUoZWwsIFwibmFtZVwiKTtcblxuXHQgICAgICBpZiAobmFtZSkge1xuXHQgICAgICAgIHZhciB0YWcgPSBfdGFnbmFtZShlbCkgPT09IFwiYnV0dG9uXCI7XG5cblx0ICAgICAgICB2YXIgdHlwZSA9IF9hdHRyaWJ1dGUoZWwsIFwidHlwZVwiKTtcblxuXHQgICAgICAgIHZhciBjYW50X2NsZWFyID0gdGFnIHx8IHR5cGUgPT09IFwiYnV0dG9uXCIgfHwgdHlwZSA9PT0gXCJzdWJtaXRcIjtcblxuXHQgICAgICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIpIHtcblx0ICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuZWxlbWVudHNbbmFtZV0gfHwgW107XG5cdCAgICAgICAgICBzdGFjay50YWdOYW1lID0gXCJyYWRpb1wiO1xuXHQgICAgICAgICAgc3RhY2sucHVzaChlbCk7XG5cdCAgICAgICAgICBlbCA9IHN0YWNrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZWxlbWVudHNbbmFtZV0gPSBlbDtcblx0ICAgICAgICBlbC5nZXRWYWx1ZSA9IF9nZXRfaHRtbF92YWx1ZTtcblx0ICAgICAgICBlbC5zZXRWYWx1ZSA9IF9zZXRfaHRtbF92YWx1ZTtcblx0ICAgICAgICBlbC4kYWxsb3dzQ2xlYXIgPSAhY2FudF9jbGVhcjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcblx0ICB9LFxuXHQgIF9tYXJrX2ludmFsaWQ6IGZ1bmN0aW9uIChpZCwgb2JqKSB7XG5cdCAgICB0aGlzLl9jbGVhcl9pbnZhbGlkKGlkLCBvYmopO1xuXG5cdCAgICB2YXIgZWwgPSB0aGlzLl92aWV3b2JqLnF1ZXJ5U2VsZWN0b3IoXCJbbmFtZT1cXFwiXCIgKyBpZCArIFwiXFxcIl1cIik7XG5cblx0ICAgIGlmIChlbCkgYWRkQ3NzKGVsLCBcImludmFsaWRcIik7XG5cdCAgfSxcblx0ICBfY2xlYXJfaW52YWxpZDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgZWwgPSB0aGlzLl92aWV3b2JqLnF1ZXJ5U2VsZWN0b3IoXCJbbmFtZT1cXFwiXCIgKyBpZCArIFwiXFxcIl1cIik7XG5cblx0ICAgIGlmIChlbCkgcmVtb3ZlQ3NzKGVsLCBcImludmFsaWRcIik7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRxID0gZXhwb3J0cy5wcm90b1VJKGFwaSRxLCB0ZW1wbGF0ZSQxLnZpZXcsIFZhbHVlcyk7XG5cblx0dmFyIGFwaSRyID0ge1xuXHQgIG5hbWU6IFwicHJvcGVydHlcIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fY29udGVudG9iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfcHJvcGVydHlcIjtcblxuXHQgICAgdGhpcy5fY29udGVudG9iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcblxuXHQgICAgdGhpcy5fZGVzdHJveV93aXRoX21lID0gW107XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlckVkaXRTdGFydFwiLCBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKGlkKTtcblx0ICAgICAgYWRkQ3NzKG5vZGUsIFwid2ViaXhfZm9jdXNlZFwiKTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJFZGl0U3RvcFwiLCBmdW5jdGlvbiAoaWQsIGVkaXRvcikge1xuXHQgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0SXRlbU5vZGUoZWRpdG9yLmNvbmZpZy5pZCk7XG5cdCAgICAgIHJlbW92ZUNzcyhub2RlLCBcIndlYml4X2ZvY3VzZWRcIik7XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBuYW1lV2lkdGg6IDEwMCxcblx0ICAgIGVkaXRhYmxlOiB0cnVlXG5cdCAgfSxcblx0ICBvbl9yZW5kZXI6IHtcblx0ICAgIGNoZWNrYm94OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBjbGFzcz0nd2ViaXhfcHJvcGVydHlfY2hlY2snIFwiICsgKHZhbHVlID8gXCJjaGVja2VkXCIgOiBcIlwiKSArIFwiPlwiO1xuXHQgICAgfSxcblx0ICAgIGNvbG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwid2ViaXhfcHJvcGVydHlfY29sX3ZhbFxcXCI+PGRpdiBjbGFzcz0nd2ViaXhfcHJvcGVydHlfY29sX2luZCcgc3R5bGU9XFxcImJhY2tncm91bmQtY29sb3I6XCIgKyAodmFsdWUgfHwgXCIjRkZGRkZGXCIpICsgXCI7XFxcIj48L2Rpdj48c3Bhbj5cIiArIHZhbHVlICsgXCI8L3NwYW4+PC9kaXY+XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBvbl9lZGl0OiB7XG5cdCAgICBsYWJlbDogZmFsc2Vcblx0ICB9LFxuXHQgIF9pZDogXCJ3ZWJpeF9mX2lkXCIsXG5cdCAgb25fY2xpY2s6IHtcblx0ICAgIHdlYml4X3Byb3BlcnR5X2NoZWNrOiBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgdmFyIGlkID0gdGhpcy5sb2NhdGUoZXYpO1xuXHQgICAgICB0aGlzLmdldEl0ZW0oaWQpLnZhbHVlID0gIXRoaXMuZ2V0SXRlbShpZCkudmFsdWU7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25DaGVja1wiLCBbaWQsIHRoaXMuZ2V0SXRlbShpZCkudmFsdWVdKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fZGJsY2xpY2s6IHt9LFxuXHQgIHJlZ2lzdGVyVHlwZTogZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcblx0ICAgIGlmIChkYXRhLnRlbXBsYXRlKSB0aGlzLm9uX3JlbmRlcltuYW1lXSA9IGRhdGEudGVtcGxhdGU7XG5cdCAgICBpZiAoZGF0YS5lZGl0b3IpIHRoaXMub25fZWRpdFtuYW1lXSA9IGRhdGEuZWRpdG9yO1xuXHQgICAgaWYgKGRhdGEuY2xpY2spIGZvciAodmFyIGtleSBpbiBkYXRhLmNsaWNrKSB7XG5cdCAgICAgIHRoaXMub25fY2xpY2tba2V5XSA9IGRhdGEuY2xpY2tba2V5XTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGVsZW1lbnRzX3NldHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHRoaXMuX2lkVG9MaW5lID0ge307XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbGluZSA9IGRhdGFbaV07XG5cdCAgICAgIGlmIChsaW5lLnR5cGUgPT0gXCJtdWx0aXNlbGVjdFwiKSBsaW5lLm9wdGlvbnNsaXN0ID0gdHJ1ZTsgLy9saW5lLnR5cGUgXHQ9IFx0bGluZS50eXBlfHxcImxhYmVsXCI7XG5cblx0ICAgICAgbGluZS5pZCA9IGxpbmUuaWQgfHwgdWlkKCk7XG5cdCAgICAgIGxpbmUubGFiZWwgPSBsaW5lLmxhYmVsIHx8IFwiXCI7XG5cdCAgICAgIGxpbmUudmFsdWUgPSBsaW5lLnZhbHVlIHx8IFwiXCI7XG5cdCAgICAgIHRoaXMuX2lkVG9MaW5lW2xpbmUuaWRdID0gaTtcblx0ICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuX21hcF9vcHRpb25zKGRhdGFbaV0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIHNob3dJdGVtOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIFJlbmRlclN0YWNrLnNob3dJdGVtLmNhbGwodGhpcywgaWQpO1xuXHQgIH0sXG5cdCAgbG9jYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gbG9jYXRlKGFyZ3VtZW50c1swXSwgdGhpcy5faWQpO1xuXHQgIH0sXG5cdCAgZ2V0SXRlbU5vZGU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2RhdGFvYmouY2hpbGROb2Rlc1t0aGlzLl9pZFRvTGluZVtpZF1dO1xuXHQgIH0sXG5cdCAgZ2V0SXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MuZWxlbWVudHNbdGhpcy5faWRUb0xpbmVbaWRdXTtcblx0ICB9LFxuXHQgIF9nZXRfZWRpdG9yX3R5cGU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIHR5cGUgPSB0aGlzLmdldEl0ZW0oaWQpLnR5cGU7XG5cdCAgICBpZiAodHlwZSA9PSBcImNoZWNrYm94XCIpIHJldHVybiBcImlubGluZS1jaGVja2JveFwiO1xuXHQgICAgdmFyIGFsdGVyX3R5cGUgPSB0aGlzLm9uX2VkaXRbdHlwZV07XG5cdCAgICByZXR1cm4gYWx0ZXJfdHlwZSA9PT0gZmFsc2UgPyBmYWxzZSA6IGFsdGVyX3R5cGUgfHwgdHlwZTtcblx0ICB9LFxuXHQgIF9nZXRfZWRpdF9jb25maWc6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgfSxcblx0ICBfZmluZF9jZWxsX25leHQ6IGZ1bmN0aW9uIChzdGFydCwgY2hlY2ssIGRpcmVjdGlvbikge1xuXHQgICAgdmFyIHJvdyA9IHRoaXMuX2lkVG9MaW5lW3N0YXJ0LmlkXTtcblx0ICAgIHZhciBvcmRlciA9IHRoaXMuX3NldHRpbmdzLmVsZW1lbnRzO1xuXG5cdCAgICBpZiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSByb3cgKyAxOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoY2hlY2suY2FsbCh0aGlzLCBvcmRlcltpXS5pZCkpIHJldHVybiBvcmRlcltpXS5pZDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgX2kgPSByb3cgLSAxOyBfaSA+PSAwOyBfaS0tKSB7XG5cdCAgICAgICAgaWYgKGNoZWNrLmNhbGwodGhpcywgb3JkZXJbX2ldLmlkKSkgcmV0dXJuIG9yZGVyW19pXS5pZDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIHVwZGF0ZUl0ZW06IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcblx0ICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXHQgICAgdmFyIGxpbmUgPSB0aGlzLmdldEl0ZW0oa2V5KTtcblx0ICAgIGlmIChsaW5lKSBleHBvcnRzLmV4dGVuZChsaW5lLCBkYXRhLCB0cnVlKTtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgX2NlbGxQb3NpdGlvbjogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgaHRtbCA9IHRoaXMuZ2V0SXRlbU5vZGUoaWQpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgbGVmdDogaHRtbC5vZmZzZXRMZWZ0ICsgdGhpcy5fc2V0dGluZ3MubmFtZVdpZHRoLFxuXHQgICAgICB0b3A6IGh0bWwub2Zmc2V0VG9wLFxuXHQgICAgICBoZWlnaHQ6IGh0bWwuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQsXG5cdCAgICAgIHdpZHRoOiB0aGlzLl9kYXRhX3dpZHRoLFxuXHQgICAgICBwYXJlbnQ6IHRoaXMuX2NvbnRlbnRvYmpcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfY2xlYXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBsaW5lcyA9IHRoaXMuX3NldHRpbmdzLmVsZW1lbnRzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGxpbmVzW2ldLnZhbHVlID0gXCJcIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9jbGVhcigpO1xuXG5cdCAgICB0aGlzLl9wcm9wc19kYXRhc2V0ID0ge307XG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgIHNldFZhbHVlczogZnVuY3Rpb24gKGRhdGEsIHVwZGF0ZSkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNvbXBsZXhEYXRhKSBkYXRhID0gQ29kZVBhcnNlci5jb2xsYXBzZU5hbWVzKGRhdGEpO1xuXHQgICAgaWYgKCF1cGRhdGUpIHRoaXMuX2NsZWFyKCk7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdCAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRJdGVtKGtleSk7XG5cdCAgICAgIGlmIChsaW5lKSBsaW5lLnZhbHVlID0gZGF0YVtrZXldO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9wcm9wc19kYXRhc2V0ID0gZGF0YTtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWVzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZGF0YSA9IGNsb25lKHRoaXMuX3Byb3BzX2RhdGFzZXQgfHwge30pO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NldHRpbmdzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBsaW5lID0gdGhpcy5fc2V0dGluZ3MuZWxlbWVudHNbaV07XG5cdCAgICAgIGlmIChsaW5lLnR5cGUgIT0gXCJsYWJlbFwiKSBkYXRhW2xpbmUuaWRdID0gbGluZS52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNvbXBsZXhEYXRhKSBkYXRhID0gQ29kZVBhcnNlci5leHBhbmROYW1lcyhkYXRhKTtcblx0ICAgIHJldHVybiBkYXRhO1xuXHQgIH0sXG5cdCAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZW5kZXIoKTtcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgaWYgKGJhc2UuYXBpLiRzZXRTaXplLmNhbGwodGhpcywgeCwgeSkpIHtcblx0ICAgICAgdGhpcy5fZGF0YV93aWR0aCA9IHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl9zZXR0aW5ncy5uYW1lV2lkdGg7XG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG9oZWlnaHQpIHtcblx0ICAgICAgdmFyIGNvdW50ID0gdGhpcy5fc2V0dGluZ3MuZWxlbWVudHMubGVuZ3RoO1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLnR5cGUuaGVpZ2h0ICogY291bnQsIHRoaXMuX3NldHRpbmdzLm1pbkhlaWdodCB8fCAwKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJhc2UuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgZHgsIGR5KTtcblx0ICB9LFxuXHQgIF90b0hUTUw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBodG1sID0gW107XG5cdCAgICB2YXIgZWxzID0gdGhpcy5fc2V0dGluZ3MuZWxlbWVudHM7XG5cdCAgICBpZiAoZWxzKSBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZGF0YSA9IGVsc1tpXTtcblx0ICAgICAgaWYgKGRhdGEuY3NzICYmIF90eXBlb2YoZGF0YS5jc3MpID09IFwib2JqZWN0XCIpIGRhdGEuY3NzID0gY3JlYXRlQ3NzKGRhdGEuY3NzKTtcblx0ICAgICAgdmFyIHByZSA9IFwiPGRpdiB3ZWJpeF9mX2lkPVxcXCJcIiArIGRhdGEuaWQgKyBcIlxcXCJcIiArIChkYXRhLnR5cGUgIT09IFwibGFiZWxcIiA/IFwicm9sZT1cXFwib3B0aW9uXFxcIiB0YWJpbmRleD1cXFwiMFxcXCJcIiA6IFwiXCIpICsgXCIgY2xhc3M9XFxcIndlYml4X3Byb3BlcnR5X2xpbmUgXCIgKyAoZGF0YS5jc3MgfHwgXCJcIikgKyBcIlxcXCI+XCI7XG5cdCAgICAgIGlmIChkYXRhLnR5cGUgPT0gXCJsYWJlbFwiKSBodG1sW2ldID0gcHJlICsgXCI8ZGl2IGNsYXNzPSd3ZWJpeF9wcm9wZXJ0eV9sYWJlbF9saW5lJz5cIiArIGRhdGEubGFiZWwgKyBcIjwvZGl2PjwvZGl2PlwiO2Vsc2Uge1xuXHQgICAgICAgIHZhciByZW5kZXIgPSB0aGlzLm9uX3JlbmRlcltkYXRhLnR5cGVdLFxuXHQgICAgICAgICAgICBjb250ZW50O1xuXHQgICAgICAgIHZhciBwb3N0ID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9wcm9wZXJ0eV9sYWJlbCcgc3R5bGU9J3dpZHRoOlwiICsgdGhpcy5fc2V0dGluZ3MubmFtZVdpZHRoICsgXCJweCc+XCIgKyBkYXRhLmxhYmVsICsgXCI8L2Rpdj48ZGl2IGNsYXNzPSd3ZWJpeF9wcm9wZXJ0eV92YWx1ZScgc3R5bGU9J3dpZHRoOlwiICsgdGhpcy5fZGF0YV93aWR0aCArIFwicHgnPlwiO1xuXG5cdCAgICAgICAgaWYgKGRhdGEuY29sbGVjdGlvbiB8fCBkYXRhLm9wdGlvbnMpIHtcblx0ICAgICAgICAgIGNvbnRlbnQgPSBkYXRhLnRlbXBsYXRlKGRhdGEsIGRhdGEudmFsdWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5mb3JtYXQpIGNvbnRlbnQgPSBkYXRhLmZvcm1hdChkYXRhLnZhbHVlKTtlbHNlIGNvbnRlbnQgPSBkYXRhLnZhbHVlO1xuXG5cdCAgICAgICAgaWYgKHJlbmRlcikgY29udGVudCA9IHJlbmRlci5jYWxsKHRoaXMsIGRhdGEudmFsdWUsIGRhdGEpO1xuXHQgICAgICAgIGh0bWxbaV0gPSBwcmUgKyBwb3N0ICsgY29udGVudCArIFwiPC9kaXY+PC9kaXY+XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBodG1sLmpvaW4oXCJcIik7XG5cdCAgfSxcblx0ICB0eXBlOiB7XG5cdCAgICBoZWlnaHQ6IDI0LFxuXHQgICAgdGVtcGxhdGVTdGFydDogdGVtcGxhdGUoXCJcIiksXG5cdCAgICB0ZW1wbGF0ZUVuZDogdGVtcGxhdGUoXCI8L2Rpdj5cIilcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnR5cGUuaGVpZ2h0ID0gJGFjdGl2ZS5wcm9wZXJ0eUl0ZW1IZWlnaHQ7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRyID0gZXhwb3J0cy5wcm90b1VJKGFwaSRyLCBBdXRvVG9vbHRpcCwgRWRpdEFiaWxpdHksIE1hcENvbGxlY3Rpb24sIE1vdXNlRXZlbnRzLCBTY3JvbGxhYmxlLCBTaW5nbGVSZW5kZXIsIEF0b21EYXRhTG9hZGVyLCBFdmVudFN5c3RlbSwgYmFzZS52aWV3KTtcblxuXHR2YXIgYXBpJHMgPSB7XG5cdCAgbmFtZTogXCJjYWxlbmRhclwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuXHQgICAgLy9zZWxlY3RlZCBkYXRlLCBub3Qgc2VsZWN0ZWQgYnkgZGVmYXVsdFxuXHQgICAgc2VsZWN0OiBmYWxzZSxcblx0ICAgIG5hdmlnYXRpb246IHRydWUsXG5cdCAgICBtb250aFNlbGVjdDogdHJ1ZSxcblx0ICAgIHdlZWtIZWFkZXI6IHRydWUsXG5cdCAgICB3ZWVrTnVtYmVyOiBmYWxzZSxcblx0ICAgIHNraXBFbXB0eVdlZWtzOiBmYWxzZSxcblx0ICAgIGNhbGVuZGFySGVhZGVyOiBcIiVGICVZXCIsXG5cdCAgICBjYWxlbmRhcldlZWtIZWFkZXI6IFwiVyNcIixcblx0ICAgIC8vY2FsZW5kYXJUaW1lOiBcIiVIOiVpXCIsXG5cdCAgICBldmVudHM6IHdEYXRlLmlzSG9saWRheSxcblx0ICAgIG1pbnV0ZVN0ZXA6IDUsXG5cdCAgICB0aW1lSWNvbjogXCJ3eGktY2xvY2tcIixcblx0ICAgIGljb25zOiBmYWxzZSxcblx0ICAgIHRpbWVwaWNrZXJIZWlnaHQ6IDMwLFxuXHQgICAgaGVhZGVySGVpZ2h0OiA3MCxcblx0ICAgIGRheVRlbXBsYXRlOiBmdW5jdGlvbiAoZCkge1xuXHQgICAgICByZXR1cm4gZC5nZXREYXRlKCk7XG5cdCAgICB9LFxuXHQgICAgd2lkdGg6IDI2MCxcblx0ICAgIGhlaWdodDogMjUwXG5cdCAgfSxcblx0ICBkYXlUZW1wbGF0ZV9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIGNhbGVuZGFySGVhZGVyX3NldHRlcjogd0RhdGUuZGF0ZVRvU3RyLFxuXHQgIGNhbGVuZGFyV2Vla0hlYWRlcl9zZXR0ZXI6IHdEYXRlLmRhdGVUb1N0cixcblx0ICBjYWxlbmRhclRpbWVfc2V0dGVyOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICB0aGlzLl9jYWxlbmRhclRpbWUgPSBmb3JtYXQ7XG5cdCAgICByZXR1cm4gd0RhdGUuZGF0ZVRvU3RyKGZvcm1hdCk7XG5cdCAgfSxcblx0ICBkYXRlX3NldHRlcjogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9zdHJpbmdfdG9fZGF0ZShkYXRlKTtcblx0ICB9LFxuXHQgIG1heERhdGVfc2V0dGVyOiBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3N0cmluZ190b19kYXRlKGRhdGUpO1xuXHQgIH0sXG5cdCAgbWluRGF0ZV9zZXR0ZXI6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc3RyaW5nX3RvX2RhdGUoZGF0ZSk7XG5cdCAgfSxcblx0ICBtaW5UaW1lX3NldHRlcjogZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdGltZSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIHRpbWUgPSBpMThuLnBhcnNlVGltZUZvcm1hdERhdGUodGltZSk7XG5cdCAgICAgIHRpbWUgPSBbdGltZS5nZXRIb3VycygpLCB0aW1lLmdldE1pbnV0ZXMoKV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aW1lO1xuXHQgIH0sXG5cdCAgbWF4VGltZV9zZXR0ZXI6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICBpZiAodHlwZW9mIHRpbWUgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICB0aW1lID0gaTE4bi5wYXJzZVRpbWVGb3JtYXREYXRlKHRpbWUpO1xuXHQgICAgICB0aW1lID0gW3RpbWUuZ2V0SG91cnMoKSwgdGltZS5nZXRNaW51dGVzKCldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGltZTtcblx0ICB9LFxuXHQgIF9hcmlhRm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBldiA9IFwiZm9jdXNcIiArIChlbnYuaXNJRSA/IFwiaW5cIiA6IFwiXCIpO1xuXG5cdCAgICBpZiAoIWVudi50b3VjaCkge1xuXHQgICAgICBfZXZlbnQodGhpcy4kdmlldywgZXYsIGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICB2YXIgdCA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcblx0ICAgICAgICB2YXIgY3NzID0gdC5pbmRleE9mKFwid2ViaXhfY2FsX2RheVwiKSAhPT0gLTEgPyBcIndlYml4X2NhbF9kYXlcIiA6IHQuaW5kZXhPZihcIndlYml4X2NhbF9ibG9ja1wiKSAhPT0gLTEgPyBcIndlYml4X2NhbF9ibG9ja1wiIDogXCJcIjtcblxuXHQgICAgICAgIGlmIChuZXcgRGF0ZSgpIC0gVUlNYW5hZ2VyLl90YWJfdGltZSA+IDMwMCAmJiBuZXcgRGF0ZSgpIC0gVUlNYW5hZ2VyLl9tb3VzZV90aW1lID4gMTAwICYmIGNzcykge1xuXHQgICAgICAgICAgdmFyIHByZXYgPSBlLnJlbGF0ZWRUYXJnZXQ7XG5cblx0ICAgICAgICAgIGlmIChwcmV2ICYmICFpc1VuZGVmaW5lZChwcmV2LmNsYXNzTmFtZSkpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGUgPSBjc3MgPT0gXCJ3ZWJpeF9jYWxfZGF5XCIgPyB0aGlzLl9sb2NhdGVfZGF5KGUudGFyZ2V0KSA6IHRoaXMuX2xvY2F0ZV9kYXRlKGUudGFyZ2V0KTtcblxuXHQgICAgICAgICAgICB0aGlzLl9tb3ZlU2VsZWN0aW9uKGRhdGUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSwgdGhpcyksIHtcblx0ICAgICAgICBjYXB0dXJlOiAhZW52LmlzSUVcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfY2FsZW5kYXJcIjtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicmVnaW9uXCIpO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgaTE4bi5hcmlhLmNhbGVuZGFyKTsgLy9zcGVjaWFsIGRhdGVzXG5cblxuXHQgICAgdGhpcy5fc3BlY2lhbF9kYXRlcyA9IHt9O1xuXHQgICAgdGhpcy5fc2VsZWN0ZWRfZGF5cyA9IHt9O1xuXHQgICAgdGhpcy5fem9vbV9sZXZlbCA9IDA7IC8vbmF2aWdhdGlvbiBhbmQgYXJpYVxuXG5cdCAgICB0aGlzLl9hcmlhRm9jdXMoKTtcblxuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uS2V5UHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlclpvb21cIiwgZnVuY3Rpb24gKHpvb20pIHtcblx0ICAgICAgaWYgKHpvb20gPj0gMCkgdGhpcy4kdmlldy5xdWVyeVNlbGVjdG9yKFwiLndlYml4X2NhbF9tb250aF9uYW1lXCIpLmJsdXIoKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgdHlwZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09IFwidGltZVwiKSB7XG5cdCAgICAgIHRoaXMuX3pvb21faW4gPSB0cnVlO1xuXHQgICAgICB0aGlzLl96b29tX2xldmVsID0gLTE7XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwieWVhclwiKSB7XG5cdCAgICAgIHRoaXMuX2ZpeGVkID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KSkge1xuXHQgICAgICAvL3JlcGFpbnQgY2FsZW5kYXIgd2hlbiBzaXplIGNoYW5nZWRcblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuY2VsbEhlaWdodCkge1xuXHQgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9nZXREYXRlQm91bmRhcmllcyh0aGlzLl9zZXR0aW5ncy5kYXRlKTtcblxuXHQgICAgICB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5jZWxsSGVpZ2h0ICogc3RhdGUuX3Jvd3MgKyAoJGFjdGl2ZS5jYWxlbmRhckhlaWdodCB8fCA3MCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBiYXNlLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cdCAgfSxcblx0ICBtb3ZlU2VsZWN0aW9uOiBmdW5jdGlvbiAobW9kZSwgZGV0YWlscywgZm9jdXMpIHtcblx0ICAgIGlmICh0aGlzLmNvbmZpZy5tYXN0ZXIpIHJldHVybjsgLy9pbiBkYXRlcmFuZ2VcblxuXHQgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRTZWxlY3RlZERhdGUoKTtcblx0ICAgIGlmICh0aGlzLmNvbmZpZy5tdWx0aXNlbGVjdCkgc3RhcnQgPSBzdGFydFswXTtcblx0ICAgIHZhciBkYXRlID0gd0RhdGUuY29weShzdGFydCB8fCB0aGlzLmdldFZpc2libGVEYXRlKCkpO1xuXG5cdCAgICB0aGlzLl9tb3ZlU2VsZWN0aW9uKGRhdGUsIG1vZGUsIGZvY3VzKTtcblx0ICB9LFxuXHQgIF9tb3ZlU2VsZWN0aW9uOiBmdW5jdGlvbiAoZGF0ZSwgbW9kZSwgZm9jdXMpIHtcblx0ICAgIHZhciBjc3MgPSB0aGlzLl96b29tX2xvZ2ljW3RoaXMuX3pvb21fbGV2ZWxdLl9rZXlzaGlmdChkYXRlLCBtb2RlLCB0aGlzKTtcblxuXHQgICAgaWYgKGZvY3VzICE9PSBmYWxzZSkge1xuXHQgICAgICB2YXIgc2VsID0gdGhpcy5fdmlld29iai5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY3NzICsgXCJbdGFiaW5kZXg9JzAnXVwiKTtcblxuXHQgICAgICBpZiAoc2VsKSBzZWwuZm9jdXMoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9nZXREYXRlQm91bmRhcmllczogZnVuY3Rpb24gKGRhdGUsIHJlc2V0KSB7XG5cdCAgICAvLyBhZGRpdGlvbiBpbmZvcm1hdGlvbiBhYm91dCByZW5kZXJpbmcgZXZlbnQ6XG5cdCAgICAvLyBob3cgbWFueSBkYXlzIGZyb20gdGhlIHByZXZpb3VzIG1vbnRoLFxuXHQgICAgLy8gbmV4dCxcblx0ICAgIC8vIG51bWJlciBvZiB3ZWVrcyB0byBkaXNwbGF5IGFuZCBzbyBvblxuXHQgICAgaWYgKCF0aGlzLl9zZXRfZGF0ZV9ib3VuZHMgfHwgcmVzZXQpIHtcblx0ICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xuXHQgICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0ICAgICAgdmFyIG5leHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDEpO1xuXHQgICAgICB2YXIgc3RhcnQgPSB3RGF0ZS53ZWVrU3RhcnQobmV3IERhdGUoeWVhciwgbW9udGgsIDEpKTtcblx0ICAgICAgdmFyIGRheXMgPSBNYXRoLnJvdW5kKChuZXh0LnZhbHVlT2YoKSAtIHN0YXJ0LnZhbHVlT2YoKSkgLyAoNjAgKiAxMDAwICogNjAgKiAyNCkpO1xuXHQgICAgICB2YXIgcm93cyA9IHRoaXMuX3NldHRpbmdzLnNraXBFbXB0eVdlZWtzID8gTWF0aC5jZWlsKGRheXMgLyA3KSA6IDY7XG5cdCAgICAgIHRoaXMuX3NldF9kYXRlX2JvdW5kcyA9IHtcblx0ICAgICAgICBfbW9udGg6IG1vbnRoLFxuXHQgICAgICAgIF9zdGFydDogc3RhcnQsXG5cdCAgICAgICAgX25leHQ6IG5leHQsXG5cdCAgICAgICAgX3Jvd3M6IHJvd3Ncblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX3NldF9kYXRlX2JvdW5kcztcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoJGFjdGl2ZS5jYWxlbmRhcikge1xuXHQgICAgICBpZiAoJGFjdGl2ZS5jYWxlbmRhci53aWR0aCkgdGhpcy5kZWZhdWx0cy53aWR0aCA9ICRhY3RpdmUuY2FsZW5kYXIud2lkdGg7XG5cdCAgICAgIGlmICgkYWN0aXZlLmNhbGVuZGFyLmhlaWdodCkgdGhpcy5kZWZhdWx0cy5oZWlnaHQgPSAkYWN0aXZlLmNhbGVuZGFyLmhlaWdodDtcblx0ICAgICAgaWYgKCRhY3RpdmUuY2FsZW5kYXIuaGVhZGVySGVpZ2h0KSB0aGlzLmRlZmF1bHRzLmhlYWRlckhlaWdodCA9ICRhY3RpdmUuY2FsZW5kYXIuaGVhZGVySGVpZ2h0O1xuXHQgICAgICBpZiAoJGFjdGl2ZS5jYWxlbmRhci50aW1lcGlja2VySGVpZ2h0KSB0aGlzLmRlZmF1bHRzLnRpbWVwaWNrZXJIZWlnaHQgPSAkYWN0aXZlLmNhbGVuZGFyLnRpbWVwaWNrZXJIZWlnaHQ7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0Q29sdW1uQ29uZmlnU2l6ZXM6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICB2YXIgYm91bmRzID0gdGhpcy5fZ2V0RGF0ZUJvdW5kYXJpZXMoZGF0ZSk7XG5cblx0ICAgIHZhciBzID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICB2YXIgX2NvbHVtbnNIZWlnaHQgPSBbXTtcblx0ICAgIHZhciBfY29sdW1uc1dpZHRoID0gW107XG5cdCAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cdCAgICB2YXIgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250ZW50X3dpZHRoIC0gMzY7XG5cdCAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gdGhpcy5fY29udGVudF9oZWlnaHQgLSB0aGlzLl9zZXR0aW5ncy5oZWFkZXJIZWlnaHQgLSAxMCAtICh0aGlzLl9zZXR0aW5ncy50aW1lcGlja2VyIHx8IHRoaXMuX2ljb25zID8gdGhpcy5fc2V0dGluZ3MudGltZXBpY2tlckhlaWdodCA6IDApO1xuXHQgICAgdmFyIGNvbHVtbnNOdW1iZXIgPSBzLndlZWtOdW1iZXIgPyA4IDogNztcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zTnVtYmVyOyBpKyspIHtcblx0ICAgICAgX2NvbHVtbnNXaWR0aFtpXSA9IE1hdGguY2VpbChjb250YWluZXJXaWR0aCAvIChjb2x1bW5zTnVtYmVyIC0gaSkpO1xuXHQgICAgICBjb250YWluZXJXaWR0aCAtPSBfY29sdW1uc1dpZHRoW2ldO1xuXHQgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIF9jb2x1bW5zV2lkdGhbaV0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcm93c051bWJlciA9IGJvdW5kcy5fcm93cztcblxuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCByb3dzTnVtYmVyOyBrKyspIHtcblx0ICAgICAgX2NvbHVtbnNIZWlnaHRba10gPSBNYXRoLmNlaWwoY29udGFpbmVySGVpZ2h0IC8gKHJvd3NOdW1iZXIgLSBrKSk7XG5cdCAgICAgIGNvbnRhaW5lckhlaWdodCAtPSBfY29sdW1uc0hlaWdodFtrXTtcblx0ICAgICAgbWluID0gTWF0aC5taW4obWluLCBfY29sdW1uc0hlaWdodFtrXSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBbX2NvbHVtbnNXaWR0aCwgX2NvbHVtbnNIZWlnaHQsIG1pbl07XG5cdCAgfSxcblx0ICBpY29uc19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKCF2YWx1ZSkgdGhpcy5faWNvbnMgPSBudWxsO2Vsc2UgaWYgKF90eXBlb2YodmFsdWUpID09IFwib2JqZWN0XCIpIHRoaXMuX2ljb25zID0gdmFsdWU7ZWxzZSB0aGlzLl9pY29ucyA9IHRoaXMuX2ljb25zMjtcblx0ICB9LFxuXHQgIF9pY29uczogW10sXG5cdCAgX2ljb25zMjogW3tcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBcIjxzcGFuIHJvbGU9J2J1dHRvbicgdGFiaW5kZXg9JzAnIGNsYXNzPSd3ZWJpeF9jYWxfaWNvbl90b2RheSB3ZWJpeF9jYWxfaWNvbic+XCIgKyBpMThuLmNhbGVuZGFyLnRvZGF5ICsgXCI8L3NwYW4+XCI7XG5cdCAgICB9LFxuXHQgICAgb25fY2xpY2s6IHtcblx0ICAgICAgXCJ3ZWJpeF9jYWxfaWNvbl90b2RheVwiOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MudGltZXBpY2tlcikgZGF0ZSA9IHdEYXRlLmRhdGVQYXJ0KGRhdGUpO1xuXHQgICAgICAgIHRoaXMuc2V0VmFsdWUoZGF0ZSk7XG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblRvZGF5U2V0XCIsIFt0aGlzLmdldFNlbGVjdGVkRGF0ZSgpXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gXCI8c3BhbiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBjbGFzcz0nd2ViaXhfY2FsX2ljb25fY2xlYXIgd2ViaXhfY2FsX2ljb24nPlwiICsgaTE4bi5jYWxlbmRhci5jbGVhciArIFwiPC9zcGFuPlwiO1xuXHQgICAgfSxcblx0ICAgIG9uX2NsaWNrOiB7XG5cdCAgICAgIFwid2ViaXhfY2FsX2ljb25fY2xlYXJcIjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuc2V0VmFsdWUoXCJcIik7XG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkRhdGVDbGVhclwiLCBbdGhpcy5nZXRTZWxlY3RlZERhdGUoKV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfV0sXG5cdCAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZW5kZXIoKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgLy9yZXNldCB6b29tIGxldmVsXG5cdCAgICB0aGlzLl96b29tX2xldmVsID0gMDtcblx0ICAgIHRoaXMuX3pvb21fc2l6ZSA9IGZhbHNlO1xuXHQgICAgdmFyIHMgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGlmICghdGhpcy5pc1Zpc2libGUocy5pZCkpIHJldHVybjtcblx0ICAgIHRoaXMuX2N1cnJlbnRfdGltZSA9IHdEYXRlLmRhdGVQYXJ0KG5ldyBEYXRlKCkpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbXSk7XG5cdCAgICB2YXIgZGF0ZSA9IHRoaXMuX3NldHRpbmdzLmRhdGU7XG5cblx0ICAgIHZhciBib3VuZHMgPSB0aGlzLl9nZXREYXRlQm91bmRhcmllcyhkYXRlLCB0cnVlKTtcblxuXHQgICAgdmFyIHNpemVzID0gdGhpcy5fZ2V0Q29sdW1uQ29uZmlnU2l6ZXMoZGF0ZSk7XG5cblx0ICAgIHZhciB3aWR0aCA9IHNpemVzWzBdO1xuXHQgICAgdmFyIGhlaWdodCA9IHNpemVzWzFdO1xuXHQgICAgdmFyIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF9tb250aCc+PHNwYW4gcm9sZT0nYnV0dG9uJyB0YWJpbmRleD0nMCcgYXJpYS1saXZlPSdhc3NlcnRpdmUnIGFyaWEtYXRvbWljPSd0cnVlJyBjbGFzcz0nd2ViaXhfY2FsX21vbnRoX25hbWVcIiArICghdGhpcy5fc2V0dGluZ3MubW9udGhTZWxlY3QgPyBcIiB3ZWJpeF9yZWFkb25seVwiIDogXCJcIikgKyBcIic+XCIgKyBzLmNhbGVuZGFySGVhZGVyKGRhdGUpICsgXCI8L3NwYW4+XCI7XG5cdCAgICBpZiAocy5uYXZpZ2F0aW9uKSBodG1sICs9IFwiPGRpdiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBhcmlhLWxhYmVsPSdcIiArIGkxOG4uYXJpYS5uYXZNb250aFswXSArIFwiJyBjbGFzcz0nd2ViaXhfY2FsX3ByZXZfYnV0dG9uJz48L2Rpdj48ZGl2IHJvbGU9J2J1dHRvbicgdGFiaW5kZXg9JzAnIGFyaWEtbGFiZWw9J1wiICsgaTE4bi5hcmlhLm5hdk1vbnRoWzFdICsgXCInIGNsYXNzPSd3ZWJpeF9jYWxfbmV4dF9idXR0b24nPjwvZGl2PlwiO1xuXHQgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgaWYgKHMud2Vla0hlYWRlcikgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF9oZWFkZXInIGFyaWEtaGlkZGVuPSd0cnVlJz5cIiArIHRoaXMuX3dlZWtfdGVtcGxhdGUod2lkdGgpICsgXCI8L2Rpdj5cIjtcblx0ICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9jYWxfYm9keSc+XCIgKyB0aGlzLl9ib2R5X3RlbXBsYXRlKHdpZHRoLCBoZWlnaHQsIGJvdW5kcywgc2l6ZXNbMl0pICsgXCI8L2Rpdj5cIjtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRpbWVwaWNrZXIgfHwgdGhpcy5faWNvbnMpIHtcblx0ICAgICAgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF9mb290ZXInPlwiO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MudGltZXBpY2tlcikgaHRtbCArPSB0aGlzLl90aW1lcGlja2VyX3RlbXBsYXRlKGRhdGUpO1xuXHQgICAgICBpZiAodGhpcy5faWNvbnMpIGh0bWwgKz0gdGhpcy5faWNvbnNfdGVtcGxhdGUoKTtcblx0ICAgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9jb250ZW50b2JqLmlubmVySFRNTCA9IGh0bWw7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy50eXBlID09IFwidGltZVwiKSB7XG5cdCAgICAgIHZhciB0aW1lID0gdGhpcy5fc2V0dGluZ3MuZGF0ZTtcblxuXHQgICAgICBpZiAodGltZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgdGltZSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICBkYXRlID0gaTE4bi5wYXJzZVRpbWVGb3JtYXREYXRlKHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aW1lKSkge1xuXHQgICAgICAgICAgZGF0ZS5zZXRIb3Vycyh0aW1lWzBdKTtcblx0ICAgICAgICAgIGRhdGUuc2V0TWludXRlcyh0aW1lWzFdKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9jaGFuZ2Vab29tTGV2ZWwoLTEsIGRhdGUpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy50eXBlID09IFwibW9udGhcIikge1xuXHQgICAgICB0aGlzLl9jaGFuZ2Vab29tTGV2ZWwoMSwgZGF0ZSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnR5cGUgPT0gXCJ5ZWFyXCIpIHtcblx0ICAgICAgdGhpcy5fY2hhbmdlWm9vbUxldmVsKDIsIGRhdGUpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgW10pO1xuXHQgIH0sXG5cdCAgX2ljb25zX3RlbXBsYXRlOiBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgdmFyIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF9pY29ucyc+XCI7XG5cdCAgICB2YXIgaWNvbnMgPSB0aGlzLl9pY29ucztcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoaWNvbnNbaV0udGVtcGxhdGUpIHtcblx0ICAgICAgICB2YXIgdGVtcGxhdGUkJDEgPSB0eXBlb2YgaWNvbnNbaV0udGVtcGxhdGUgPT0gXCJmdW5jdGlvblwiID8gaWNvbnNbaV0udGVtcGxhdGUgOiB0ZW1wbGF0ZSQkMShpY29uc1tpXS50ZW1wbGF0ZSk7XG5cdCAgICAgICAgaHRtbCArPSB0ZW1wbGF0ZSQkMS5jYWxsKHRoaXMsIGRhdGUpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGljb25zW2ldLm9uX2NsaWNrKSB7XG5cdCAgICAgICAgZXhwb3J0cy5leHRlbmQodGhpcy5vbl9jbGljaywgaWNvbnNbaV0ub25fY2xpY2spO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGh0bWwgKz0gXCI8L2Rpdj5cIjtcblx0ICAgIHJldHVybiBodG1sO1xuXHQgIH0sXG5cdCAgX3RpbWVwaWNrZXJfdGVtcGxhdGU6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICB2YXIgdGltZUZvcm1hdCA9IHRoaXMuX3NldHRpbmdzLmNhbGVuZGFyVGltZSB8fCBpMThuLnRpbWVGb3JtYXRTdHI7XG5cdCAgICB2YXIgY2xvY2sgPSB0aGlzLl9zZXR0aW5ncy50aW1lSWNvbjtcblx0ICAgIHZhciB0cGwgPSBcIlwiO1xuXHQgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpIHRwbCA9IFwiPGRpdiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBjbGFzcz0nd2ViaXhfY2FsX3RpbWVcIiArICh0aGlzLl9pY29ucyA/IFwiIHdlYml4X2NhbF90aW1lX2ljb25zXCIgOiBcIlwiKSArIFwiJz48c3BhbiBjbGFzcz0nd2ViaXhfaWNvbiBcIiArIGNsb2NrICsgXCInPjwvc3Bhbj4gXCIgKyB0aW1lRm9ybWF0KGRhdGUpICsgXCI8L2Rpdj5cIjtlbHNlIHtcblx0ICAgICAgLy9kYXRlcmFuZ2UgbmVlZHMgdHdvIGNsb2Nrc1xuXHQgICAgICB2YXIgcmFuZ2VfZGF0ZSA9IGNvcHkoJCQodGhpcy5fc2V0dGluZ3MubWFzdGVyKS5fc2V0dGluZ3MudmFsdWUpO1xuXHQgICAgICBpZiAod0RhdGUuZXF1YWwocmFuZ2VfZGF0ZS5lbmQsIGRhdGUpKSByYW5nZV9kYXRlLnN0YXJ0ID0gcmFuZ2VfZGF0ZS5lbmQ7XG5cblx0ICAgICAgZm9yICh2YXIgaSBpbiByYW5nZV9kYXRlKSB7XG5cdCAgICAgICAgdHBsICs9IFwiPGRpdiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBjbGFzcz0nd2ViaXhfcmFuZ2VfdGltZV9cIiArIGkgKyBcIiB3ZWJpeF9jYWxfdGltZSc+PHNwYW4gY2xhc3M9J3dlYml4X2ljb24gXCIgKyBjbG9jayArIFwiJz48L3NwYW4+IFwiICsgdGltZUZvcm1hdChyYW5nZV9kYXRlW2ldKSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0cGw7XG5cdCAgfSxcblx0ICBfd2Vla190ZW1wbGF0ZTogZnVuY3Rpb24gKHdpZHRocykge1xuXHQgICAgdmFyIHMgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHZhciB3ZWVrX3RlbXBsYXRlID0gXCJcIjtcblx0ICAgIHZhciBjb3JyZWN0aW9uID0gMDtcblxuXHQgICAgaWYgKHMud2Vla051bWJlcikge1xuXHQgICAgICBjb3JyZWN0aW9uID0gMTtcblx0ICAgICAgd2Vla190ZW1wbGF0ZSArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF93ZWVrX2hlYWRlcicgc3R5bGU9J3dpZHRoOiBcIiArIHdpZHRoc1swXSArIFwicHg7JyA+XCIgKyBzLmNhbGVuZGFyV2Vla0hlYWRlcigpICsgXCI8L2Rpdj5cIjtcblx0ICAgIH1cblxuXHQgICAgdmFyIGsgPSB3RGF0ZS5zdGFydE9uTW9uZGF5ID8gMSA6IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNzsgaSsrKSB7XG5cdCAgICAgIC8vIDcgZGF5cyB0b3RhbFxuXHQgICAgICB2YXIgZGF5X2luZGV4ID0gKGsgKyBpKSAlIDc7IC8vIDAgLSBTdW4sIDYgLSBTYXQgYXMgaW4gTG9jYWxlLmRhdGUuZGF5X3Nob3J0XG5cblx0ICAgICAgdmFyIGRheSA9IGkxOG4uY2FsZW5kYXIuZGF5U2hvcnRbZGF5X2luZGV4XTsgLy8gMDEsIDAyIC4uIDMxXG5cblx0ICAgICAgd2Vla190ZW1wbGF0ZSArPSBcIjxkaXYgZGF5PSdcIiArIGRheV9pbmRleCArIFwiJyBzdHlsZT0nd2lkdGg6IFwiICsgd2lkdGhzW2kgKyBjb3JyZWN0aW9uXSArIFwicHg7JyA+XCIgKyBkYXkgKyBcIjwvZGl2PlwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd2Vla190ZW1wbGF0ZTtcblx0ICB9LFxuXHQgIGJsb2NrRGF0ZXNfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0b0Z1bmN0b3IodmFsdWUsIHRoaXMuJHNjb3BlKTtcblx0ICB9LFxuXHQgIF9kYXlfY3NzOiBmdW5jdGlvbiAoZGF5LCBib3VuZHMpIHtcblx0ICAgIHZhciBjc3MgPSBcIlwiLFxuXHQgICAgICAgIGlzT3V0c2lkZSA9IGZhbHNlO1xuXHQgICAgaWYgKHdEYXRlLmVxdWFsKGRheSwgdGhpcy5fY3VycmVudF90aW1lKSkgY3NzICs9IFwiIHdlYml4X2NhbF90b2RheVwiO1xuXHQgICAgaWYgKCF0aGlzLl9jaGVja0RhdGUoZGF5KSkgY3NzICs9IFwiIHdlYml4X2NhbF9kYXlfZGlzYWJsZWRcIjtcblxuXHQgICAgaWYgKGRheS5nZXRNb250aCgpICE9IGJvdW5kcy5fbW9udGgpIHtcblx0ICAgICAgaXNPdXRzaWRlID0gdHJ1ZTtcblx0ICAgICAgY3NzICs9IFwiIHdlYml4X2NhbF9vdXRzaWRlXCI7XG5cdCAgICB9XG5cblx0ICAgIGlmICghaXNPdXRzaWRlICYmIHRoaXMuX3NlbGVjdGVkRGF5KGRheSkpIGNzcyArPSBcIiB3ZWJpeF9jYWxfc2VsZWN0XCI7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZXZlbnRzKSBjc3MgKz0gXCIgXCIgKyAodGhpcy5fc2V0dGluZ3MuZXZlbnRzKGRheSwgaXNPdXRzaWRlKSB8fCBcIlwiKTtcblx0ICAgIGNzcyArPSBcIiB3ZWJpeF9jYWxfZGF5XCI7XG5cdCAgICByZXR1cm4gY3NzO1xuXHQgIH0sXG5cdCAgX2JvZHlfdGVtcGxhdGU6IGZ1bmN0aW9uICh3aWR0aHMsIGhlaWdodHMsIGJvdW5kcywgc3FTaXplKSB7XG5cdCAgICB2YXIgcyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgdmFyIGh0bWwgPSBcIlwiO1xuXHQgICAgdmFyIGRheSA9IHdEYXRlLmRhdGVQYXJ0KHdEYXRlLmNvcHkoYm91bmRzLl9zdGFydCkpO1xuXHQgICAgdmFyIHN0YXJ0ID0gcy53ZWVrTnVtYmVyID8gMSA6IDA7XG5cdCAgICB2YXIgd2Vla051bWJlciA9IHdEYXRlLmdldElTT1dlZWsod0RhdGUuYWRkKGRheSwgMiwgXCJkYXlcIiwgdHJ1ZSkpO1xuXG5cdCAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodHMubGVuZ3RoOyB5KyspIHtcblx0ICAgICAgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2NhbF9yb3cnIHN0eWxlPSdoZWlnaHQ6XCIgKyBoZWlnaHRzW3ldICsgXCJweDtsaW5lLWhlaWdodDpcIiArIGhlaWdodHNbeV0gKyBcInB4Jz5cIjtcblxuXHQgICAgICBpZiAoc3RhcnQpIHtcblx0ICAgICAgICAvLyByZWNhbGN1bGF0ZSB3ZWVrIG51bWJlciBmb3IgdGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyXG5cdCAgICAgICAgaWYgKCFkYXkuZ2V0TW9udGgoKSAmJiBkYXkuZ2V0RGF0ZSgpIDwgNykgd2Vla051bWJlciA9IHdEYXRlLmdldElTT1dlZWsod0RhdGUuYWRkKGRheSwgMiwgXCJkYXlcIiwgdHJ1ZSkpO1xuXHQgICAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9jYWxfd2Vla19udW0nIGFyaWEtaGlkZGVuPSd0cnVlJyBzdHlsZT0nd2lkdGg6XCIgKyB3aWR0aHNbMF0gKyBcInB4Jz5cIiArIHdlZWtOdW1iZXIgKyBcIjwvZGl2PlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgeCA9IHN0YXJ0OyB4IDwgd2lkdGhzLmxlbmd0aDsgeCsrKSB7XG5cdCAgICAgICAgdmFyIGNzcyA9IHRoaXMuX2RheV9jc3MoZGF5LCBib3VuZHMpO1xuXG5cdCAgICAgICAgdmFyIGQgPSB0aGlzLl9zZXR0aW5ncy5kYXlUZW1wbGF0ZS5jYWxsKHRoaXMsIGRheSk7XG5cblx0ICAgICAgICB2YXIgc2VsID0gdGhpcy5fc2VsZWN0ZWREYXkoZGF5KTtcblxuXHQgICAgICAgIHZhciBhbGFiZWwgPSBcIlwiO1xuXG5cdCAgICAgICAgdmFyIGlzT3V0c2lkZSA9IGRheS5nZXRNb250aCgpICE9IGJvdW5kcy5fbW9udGg7XG5cblx0ICAgICAgICBpZiAoX3R5cGVvZihkKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgICBhbGFiZWwgPSBkLmFyaWEgfHwgYWxhYmVsO1xuXHQgICAgICAgICAgZCA9IGQudGV4dDtcblx0ICAgICAgICB9IGVsc2UgYWxhYmVsID0gd0RhdGUuZGF0ZVRvU3RyKGkxOG4uYXJpYS5kYXRlRm9ybWF0KShkYXkpO1xuXG5cdCAgICAgICAgaHRtbCArPSBcIjxkaXYgZGF5PSdcIiArIHggKyBcIicgcm9sZT0nZ3JpZGNlbGwnIFwiICsgKGlzT3V0c2lkZSA/IFwiYXJpYS1oaWRkZW49J3RydWUnXCIgOiBcIlwiKSArIFwiIGFyaWEtbGFiZWw9J1wiICsgYWxhYmVsICsgXCInIHRhYmluZGV4PSdcIiArIChzZWwgJiYgIWlzT3V0c2lkZSA/IFwiMFwiIDogXCItMVwiKSArIFwiJyBhcmlhLXNlbGVjdGVkPSdcIiArIChzZWwgJiYgIWlzT3V0c2lkZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiJyBjbGFzcz0nXCIgKyBjc3MgKyBcIicgc3R5bGU9J3RleHQtYWxpZ246Y2VudGVyOyB3aWR0aDpcIiArIHdpZHRoc1t4XSArIFwicHgnPjxzcGFuIGFyaWEtaGlkZGVuPSd0cnVlJyBjbGFzcz0nd2ViaXhfY2FsX2RheV9pbm5lcicgc3R5bGU9J2Rpc3BsYXk6aW5saW5lLWJsb2NrOyBcIiArIHRoaXMuX2dldENhbFNpemVzU3RyaW5nKHNxU2l6ZSwgc3FTaXplKSArIFwiJz5cIiArIGQgKyBcIjwvc3Bhbj48L2Rpdj5cIjtcblx0ICAgICAgICBkYXkgPSB3RGF0ZS5hZGQoZGF5LCAxLCBcImRheVwiKTtcblxuXHQgICAgICAgIGlmIChkYXkuZ2V0SG91cnMoKSkge1xuXHQgICAgICAgICAgZGF5ID0gd0RhdGUuZGF0ZVBhcnQoZGF5KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICAgIHdlZWtOdW1iZXIrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICBfY2hhbmdlRGF0ZTogZnVuY3Rpb24gKGRpciwgc3RlcCkge1xuXHQgICAgdmFyIG5vdyA9IHRoaXMuX3NldHRpbmdzLmRhdGU7XG5cblx0ICAgIGlmICghc3RlcCkge1xuXHQgICAgICBzdGVwID0gdGhpcy5fem9vbV9sb2dpY1t0aGlzLl96b29tX2xldmVsXS5fY2hhbmdlU3RlcDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLl96b29tX2xldmVsKSB7XG5cdCAgICAgIG5vdyA9IHdEYXRlLmNvcHkobm93KTtcblx0ICAgICAgbm93LnNldERhdGUoMSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBuZXh0ID0gd0RhdGUuYWRkKG5vdywgZGlyICogc3RlcCwgXCJtb250aFwiLCB0cnVlKTtcblxuXHQgICAgdGhpcy5fY2hhbmdlRGF0ZUludGVybmFsKG5vdywgbmV4dCk7XG5cdCAgfSxcblx0ICBfY2hhbmdlRGF0ZUludGVybmFsOiBmdW5jdGlvbiAobm93LCBuZXh0KSB7XG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZU1vbnRoQ2hhbmdlXCIsIFtub3csIG5leHRdKSkge1xuXHQgICAgICBpZiAodGhpcy5fem9vbV9sZXZlbCkge1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZV96b29tX2xldmVsKG5leHQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuc2hvd0NhbGVuZGFyKG5leHQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyTW9udGhDaGFuZ2VcIiwgW25leHQsIG5vd10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3pvb21fbG9naWM6IHtcblx0ICAgIFwiLTJcIjoge1xuXHQgICAgICBfaXNCbG9ja2VkOiBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncyxcblx0ICAgICAgICAgICAgZGF0ZSA9IGNvbmZpZy5kYXRlLFxuXHQgICAgICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgbWluSG91ciA9IGNvbmZpZy5taW5UaW1lID8gY29uZmlnLm1pblRpbWVbMF0gOiAwO1xuXHQgICAgICAgIHZhciBtYXhIb3VyID0gY29uZmlnLm1heFRpbWUgPyBjb25maWcubWF4VGltZVswXSArIChjb25maWcubWF4VGltZVsxXSA/IDEgOiAwKSA6IDI0O1xuXHQgICAgICAgIHZhciBtaW5NaW51dGUgPSBjb25maWcubWluVGltZSAmJiBkYXRlLmdldEhvdXJzKCkgPT0gbWluSG91ciA/IGNvbmZpZy5taW5UaW1lWzFdIDogMDtcblx0ICAgICAgICB2YXIgbWF4TWludXRlID0gY29uZmlnLm1heFRpbWUgJiYgY29uZmlnLm1heFRpbWVbMV0gJiYgZGF0ZS5nZXRIb3VycygpID09IG1heEhvdXIgLSAxID8gY29uZmlnLm1heFRpbWVbMV0gOiA2MDtcblxuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5ibG9ja1RpbWUpIHtcblx0ICAgICAgICAgIHZhciBkID0gd0RhdGUuY29weShkYXRlKTtcblx0ICAgICAgICAgIGQuc2V0TWludXRlcyhpKTtcblx0ICAgICAgICAgIGlzQmxvY2tlZCA9IHRoaXMuX3NldHRpbmdzLmJsb2NrVGltZShkKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gaSA8IG1pbk1pbnV0ZSB8fCBpID49IG1heE1pbnV0ZSB8fCBpc0Jsb2NrZWQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9zZXRDb250ZW50OiBmdW5jdGlvbiAobmV4dCwgaSkge1xuXHQgICAgICAgIG5leHQuc2V0TWludXRlcyhpKTtcblx0ICAgICAgfSxcblx0ICAgICAgX2ZpbmRBY3RpdmU6IGZ1bmN0aW9uIChkYXRlLCBtb2RlLCBjYWxlbmRhcikge1xuXHQgICAgICAgIGlmICghdGhpcy5faXNCbG9ja2VkLmNhbGwoY2FsZW5kYXIsIGRhdGUuZ2V0TWludXRlcygpKSkgcmV0dXJuIGRhdGU7ZWxzZSB7XG5cdCAgICAgICAgICB2YXIgc3RlcCA9IGNhbGVuZGFyLl9zZXR0aW5ncy5taW51dGVTdGVwO1xuXHQgICAgICAgICAgdmFyIG5ld2RhdGUgPSB3RGF0ZS5hZGQoZGF0ZSwgbW9kZSA9PSBcInJpZ2h0XCIgPyBzdGVwIDogLXN0ZXAsIFwibWludXRlXCIsIHRydWUpO1xuXHQgICAgICAgICAgaWYgKGRhdGUuZ2V0SG91cnMoKSA9PT0gbmV3ZGF0ZS5nZXRIb3VycygpKSByZXR1cm4gdGhpcy5fZmluZEFjdGl2ZShuZXdkYXRlLCBtb2RlLCBjYWxlbmRhcik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgXCItMVwiOiB7XG5cdCAgICAgIF9pc0Jsb2NrZWQ6IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzLFxuXHQgICAgICAgICAgICBkYXRlID0gY29uZmlnLmRhdGU7XG5cdCAgICAgICAgdmFyIG1pbkhvdXIgPSBjb25maWcubWluVGltZSA/IGNvbmZpZy5taW5UaW1lWzBdIDogMDtcblx0ICAgICAgICB2YXIgbWF4SG91ciA9IGNvbmZpZy5tYXhUaW1lID8gY29uZmlnLm1heFRpbWVbMF0gKyAoY29uZmlnLm1heFRpbWVbMV0gPyAxIDogMCkgOiAyNDtcblx0ICAgICAgICBpZiAoaSA8IG1pbkhvdXIgfHwgaSA+PSBtYXhIb3VyKSByZXR1cm4gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChjb25maWcuYmxvY2tUaW1lKSB7XG5cdCAgICAgICAgICB2YXIgZCA9IHdEYXRlLmNvcHkoZGF0ZSk7XG5cdCAgICAgICAgICBkLnNldEhvdXJzKGkpO1xuXHQgICAgICAgICAgdmFyIG1pbk1pbnV0ZSA9IGNvbmZpZy5taW5UaW1lICYmIGkgPT0gbWluSG91ciA/IGNvbmZpZy5taW5UaW1lWzFdIDogMDtcblx0ICAgICAgICAgIHZhciBtYXhNaW51dGUgPSBjb25maWcubWF4VGltZSAmJiBjb25maWcubWF4VGltZVsxXSAmJiBpID09IG1heEhvdXIgLSAxID8gY29uZmlnLm1heFRpbWVbMV0gOiA2MDtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaiA9IG1pbk1pbnV0ZTsgaiA8IG1heE1pbnV0ZTsgaiArPSBjb25maWcubWludXRlU3RlcCkge1xuXHQgICAgICAgICAgICBkLnNldE1pbnV0ZXMoaik7XG5cdCAgICAgICAgICAgIGlmICghY29uZmlnLmJsb2NrVGltZShkKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIF9zZXRDb250ZW50OiBmdW5jdGlvbiAobmV4dCwgaSkge1xuXHQgICAgICAgIG5leHQuc2V0SG91cnMoaSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9rZXlzaGlmdDogZnVuY3Rpb24gKGRhdGUsIG1vZGUsIGNhbGVuZGFyKSB7XG5cdCAgICAgICAgdmFyIG5ld2RhdGUsXG5cdCAgICAgICAgICAgIGluYyxcblx0ICAgICAgICAgICAgc3RlcCA9IGNhbGVuZGFyLl9zZXR0aW5ncy5taW51dGVTdGVwO1xuXG5cdCAgICAgICAgaWYgKG1vZGUgPT09IFwiYm90dG9tXCIgfHwgbW9kZSA9PT0gXCJ0b3BcIikge1xuXHQgICAgICAgICAgZGF0ZS5zZXRIb3Vycyhtb2RlID09PSBcImJvdHRvbVwiID8gMjMgOiAwKTtcblx0ICAgICAgICAgIGRhdGUuc2V0TWludXRlcyhtb2RlID09PSBcImJvdHRvbVwiID8gNTUgOiAwKTtcblx0ICAgICAgICAgIGRhdGUuc2V0U2Vjb25kcygwKTtcblx0ICAgICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuXHQgICAgICAgICAgbmV3ZGF0ZSA9IGRhdGU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImxlZnRcIiB8fCBtb2RlID09PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICAgIC8vbWludXRlc1xuXHQgICAgICAgICAgaW5jID0gbW9kZSA9PT0gXCJyaWdodFwiID8gc3RlcCA6IC1zdGVwO1xuXHQgICAgICAgICAgaWYgKG1vZGUgPT09IFwibGVmdFwiICYmIGRhdGUuZ2V0TWludXRlcygpIDwgc3RlcCkgaW5jID0gNjAgLSBzdGVwO1xuXHQgICAgICAgICAgaWYgKG1vZGUgPT09IFwicmlnaHRcIiAmJiBkYXRlLmdldE1pbnV0ZXMoKSA+PSA2MCAtIHN0ZXApIGluYyA9IHN0ZXAgLSA2MDtcblx0ICAgICAgICAgIGluYyAtPSBkYXRlLmdldE1pbnV0ZXMoKSAlIHN0ZXA7XG5cdCAgICAgICAgICBuZXdkYXRlID0gY2FsZW5kYXIuX3pvb21fbG9naWNbXCItMlwiXS5fZmluZEFjdGl2ZSh3RGF0ZS5hZGQoZGF0ZSwgaW5jLCBcIm1pbnV0ZVwiKSwgbW9kZSwgY2FsZW5kYXIpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJ1cFwiIHx8IG1vZGUgPT09IFwiZG93blwiKSB7XG5cdCAgICAgICAgICAvL2hvdXJzXG5cdCAgICAgICAgICBpbmMgPSBtb2RlID09PSBcImRvd25cIiA/IDEgOiAtMTtcblx0ICAgICAgICAgIGlmIChtb2RlID09PSBcImRvd25cIiAmJiBkYXRlLmdldEhvdXJzKCkgPT09IDIzKSBpbmMgPSAtMjM7XG5cdCAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ1cFwiICYmIGRhdGUuZ2V0SG91cnMoKSA9PT0gMCkgaW5jID0gMjM7XG5cdCAgICAgICAgICBuZXdkYXRlID0gdGhpcy5fZmluZEFjdGl2ZSh3RGF0ZS5hZGQoZGF0ZSwgaW5jLCBcImhvdXJcIiksIG1vZGUsIGNhbGVuZGFyKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IGZhbHNlKSBuZXdkYXRlID0gdGhpcy5fZmluZEFjdGl2ZShkYXRlLCBtb2RlLCBjYWxlbmRhcik7XG5cblx0ICAgICAgICBjYWxlbmRhci5zZWxlY3REYXRlKG5ld2RhdGUsIGZhbHNlKTtcblxuXHQgICAgICAgIGlmIChuZXdkYXRlKSB7XG5cdCAgICAgICAgICBjYWxlbmRhci5fdXBkYXRlX3pvb21fbGV2ZWwobmV3ZGF0ZSk7XG5cblx0ICAgICAgICAgIGNhbGVuZGFyLnNlbGVjdERhdGUobmV3ZGF0ZSwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBcIndlYml4X2NhbF9ibG9ja1wiICsgKG1vZGUgPT09IFwibGVmdFwiIHx8IG1vZGUgPT09IFwicmlnaHRcIiA/IFwiX21pblwiIDogXCJcIik7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9maW5kQWN0aXZlOiBmdW5jdGlvbiAoZGF0ZSwgbW9kZSwgY2FsZW5kYXIpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2lzQmxvY2tlZC5jYWxsKGNhbGVuZGFyLCBkYXRlLmdldEhvdXJzKCkpKSByZXR1cm4gZGF0ZTtlbHNlIHtcblx0ICAgICAgICAgIHZhciBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT0gXCJkb3duXCIgPyAxIDogLTEsIFwiaG91clwiLCB0cnVlKTtcblx0ICAgICAgICAgIGlmIChkYXRlLmdldERhdGUoKSA9PT0gbmV3ZGF0ZS5nZXREYXRlKCkpIHJldHVybiB0aGlzLl9maW5kQWN0aXZlKG5ld2RhdGUsIG1vZGUsIGNhbGVuZGFyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBcIjBcIjoge1xuXHQgICAgICAvL2RheXNcblx0ICAgICAgX2NoYW5nZVN0ZXA6IDEsXG5cdCAgICAgIF9rZXlzaGlmdDogZnVuY3Rpb24gKGRhdGUsIG1vZGUsIGNhbGVuZGFyKSB7XG5cdCAgICAgICAgdmFyIG5ld2RhdGUgPSBkYXRlO1xuXHQgICAgICAgIGlmIChtb2RlID09PSBcInBndXBcIiB8fCBtb2RlID09PSBcInBnZG93blwiKSBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT09IFwicGdkb3duXCIgPyAxIDogLTEsIFwibW9udGhcIik7ZWxzZSBpZiAobW9kZSA9PT0gXCJib3R0b21cIikgbmV3ZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCk7ZWxzZSBpZiAobW9kZSA9PT0gXCJ0b3BcIikgbmV3ZGF0ZSA9IG5ldyBEYXRlKGRhdGUuc2V0RGF0ZSgxKSk7ZWxzZSBpZiAobW9kZSA9PT0gXCJsZWZ0XCIgfHwgbW9kZSA9PT0gXCJyaWdodFwiKSBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT09IFwicmlnaHRcIiA/IDEgOiAtMSwgXCJkYXlcIik7ZWxzZSBpZiAobW9kZSA9PT0gXCJ1cFwiIHx8IG1vZGUgPT09IFwiZG93blwiKSBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT09IFwiZG93blwiID8gMSA6IC0xLCBcIndlZWtcIik7XG5cdCAgICAgICAgaWYgKCFjYWxlbmRhci5fY2hlY2tEYXRlKG5ld2RhdGUpKSBuZXdkYXRlID0gY2FsZW5kYXIuX2ZpbmRBY3RpdmUoZGF0ZSwgbW9kZSk7XG5cdCAgICAgICAgaWYgKG5ld2RhdGUpIGNhbGVuZGFyLnNlbGVjdERhdGUobmV3ZGF0ZSwgdHJ1ZSk7XG5cdCAgICAgICAgcmV0dXJuIFwid2ViaXhfY2FsX2RheVwiO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgXCIxXCI6IHtcblx0ICAgICAgLy9tb250aHNcblx0ICAgICAgX2lzQmxvY2tlZDogZnVuY3Rpb24gKGksIGNhbGVuZGFyKSB7XG5cdCAgICAgICAgdmFyIGJsb2NrZWQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgbWluWWVhcixcblx0ICAgICAgICAgICAgbWF4WWVhcixcblx0ICAgICAgICAgICAgbWluID0gY2FsZW5kYXIuX3NldHRpbmdzLm1pbkRhdGUgfHwgbnVsbCxcblx0ICAgICAgICAgICAgbWF4ID0gY2FsZW5kYXIuX3NldHRpbmdzLm1heERhdGUgfHwgbnVsbCxcblx0ICAgICAgICAgICAgeWVhciA9IGNhbGVuZGFyLl9zZXR0aW5ncy5kYXRlLmdldEZ1bGxZZWFyKCk7XG5cblx0ICAgICAgICBpZiAobWluICYmIG1heCkge1xuXHQgICAgICAgICAgbWluWWVhciA9IG1pbi5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgICAgbWF4WWVhciA9IG1heC5nZXRGdWxsWWVhcigpO1xuXHQgICAgICAgICAgaWYgKHllYXIgPCBtaW5ZZWFyIHx8IHllYXIgPT0gbWluWWVhciAmJiBtaW4uZ2V0TW9udGgoKSA+IGkgfHwgeWVhciA+IG1heFllYXIgfHwgeWVhciA9PSBtYXhZZWFyICYmIG1heC5nZXRNb250aCgpIDwgaSkgYmxvY2tlZCA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGJsb2NrZWQ7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9jb3JyZWN0RGF0ZTogZnVuY3Rpb24gKGRhdGUsIGNhbGVuZGFyKSB7XG5cdCAgICAgICAgaWYgKGRhdGUgPCBjYWxlbmRhci5fc2V0dGluZ3MubWluRGF0ZSkge1xuXHQgICAgICAgICAgZGF0ZSA9IHdEYXRlLmNvcHkoY2FsZW5kYXIuX3NldHRpbmdzLm1pbkRhdGUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGF0ZSA+IGNhbGVuZGFyLl9zZXR0aW5ncy5tYXhEYXRlKSB7XG5cdCAgICAgICAgICBkYXRlID0gd0RhdGUuY29weShjYWxlbmRhci5fc2V0dGluZ3MubWF4RGF0ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9nZXRUaXRsZTogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHQgICAgICB9LFxuXHQgICAgICBfZ2V0Q29udGVudDogZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICByZXR1cm4gaTE4bi5jYWxlbmRhci5tb250aFNob3J0W2ldO1xuXHQgICAgICB9LFxuXHQgICAgICBfc2V0Q29udGVudDogZnVuY3Rpb24gKG5leHQsIGkpIHtcblx0ICAgICAgICBpZiAoaSAhPSBuZXh0LmdldE1vbnRoKCkpIG5leHQuc2V0RGF0ZSgxKTtcblx0ICAgICAgICBuZXh0LnNldE1vbnRoKGkpO1xuXHQgICAgICB9LFxuXHQgICAgICBfY2hhbmdlU3RlcDogMTIsXG5cdCAgICAgIF9rZXlzaGlmdDogZnVuY3Rpb24gKGRhdGUsIG1vZGUsIGNhbGVuZGFyKSB7XG5cdCAgICAgICAgdmFyIG5ld2RhdGUgPSBkYXRlO1xuXHQgICAgICAgIGlmIChtb2RlID09PSBcInBndXBcIiB8fCBtb2RlID09PSBcInBnZG93blwiKSBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT09IFwicGdkb3duXCIgPyAxIDogLTEsIFwieWVhclwiKTtlbHNlIGlmIChtb2RlID09PSBcImJvdHRvbVwiKSBuZXdkYXRlID0gbmV3IERhdGUoZGF0ZS5zZXRNb250aCgxMSkpO2Vsc2UgaWYgKG1vZGUgPT09IFwidG9wXCIpIG5ld2RhdGUgPSBuZXcgRGF0ZShkYXRlLnNldE1vbnRoKDApKTtlbHNlIGlmIChtb2RlID09PSBcImxlZnRcIiB8fCBtb2RlID09PSBcInJpZ2h0XCIpIG5ld2RhdGUgPSB3RGF0ZS5hZGQoZGF0ZSwgbW9kZSA9PT0gXCJyaWdodFwiID8gMSA6IC0xLCBcIm1vbnRoXCIpO2Vsc2UgaWYgKG1vZGUgPT09IFwidXBcIiB8fCBtb2RlID09PSBcImRvd25cIikgbmV3ZGF0ZSA9IHdEYXRlLmFkZChkYXRlLCBtb2RlID09PSBcImRvd25cIiA/IDQgOiAtNCwgXCJtb250aFwiKTtcblx0ICAgICAgICBpZiAoIWNhbGVuZGFyLl9jaGVja0RhdGUobmV3ZGF0ZSkpIG5ld2RhdGUgPSBjYWxlbmRhci5fZmluZEFjdGl2ZShkYXRlLCBtb2RlKTtcblxuXHQgICAgICAgIGlmIChuZXdkYXRlKSB7XG5cdCAgICAgICAgICBjYWxlbmRhci5fdXBkYXRlX3pvb21fbGV2ZWwobmV3ZGF0ZSk7XG5cblx0ICAgICAgICAgIGNhbGVuZGFyLnNlbGVjdERhdGUobmV3ZGF0ZSwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBcIndlYml4X2NhbF9ibG9ja1wiO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgXCIyXCI6IHtcblx0ICAgICAgLy95ZWFyc1xuXHQgICAgICBfaXNCbG9ja2VkOiBmdW5jdGlvbiAoaSwgY2FsZW5kYXIpIHtcblx0ICAgICAgICBpICs9IGNhbGVuZGFyLl96b29tX3N0YXJ0X2RhdGU7XG5cdCAgICAgICAgdmFyIGJsb2NrZWQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgbWluID0gY2FsZW5kYXIuX3NldHRpbmdzLm1pbkRhdGU7XG5cdCAgICAgICAgdmFyIG1heCA9IGNhbGVuZGFyLl9zZXR0aW5ncy5tYXhEYXRlO1xuXG5cdCAgICAgICAgaWYgKG1pbiAmJiBtYXggJiYgKG1pbi5nZXRGdWxsWWVhcigpID4gaSB8fCBtYXguZ2V0RnVsbFllYXIoKSA8IGkpKSB7XG5cdCAgICAgICAgICBibG9ja2VkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gYmxvY2tlZDtcblx0ICAgICAgfSxcblx0ICAgICAgX2NvcnJlY3REYXRlOiBmdW5jdGlvbiAoZGF0ZSwgY2FsZW5kYXIpIHtcblx0ICAgICAgICBpZiAoZGF0ZSA8IGNhbGVuZGFyLl9zZXR0aW5ncy5taW5EYXRlKSB7XG5cdCAgICAgICAgICBkYXRlID0gd0RhdGUuY29weShjYWxlbmRhci5fc2V0dGluZ3MubWluRGF0ZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChkYXRlID4gY2FsZW5kYXIuX3NldHRpbmdzLm1heERhdGUpIHtcblx0ICAgICAgICAgIGRhdGUgPSB3RGF0ZS5jb3B5KGNhbGVuZGFyLl9zZXR0aW5ncy5tYXhEYXRlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgICAgfSxcblx0ICAgICAgX2dldFRpdGxlOiBmdW5jdGlvbiAoZGF0ZSwgY2FsZW5kYXIpIHtcblx0ICAgICAgICB2YXIgc3RhcnQgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdCAgICAgICAgY2FsZW5kYXIuX3pvb21fc3RhcnRfZGF0ZSA9IHN0YXJ0ID0gc3RhcnQgLSBzdGFydCAlIDEwIC0gMTtcblx0ICAgICAgICByZXR1cm4gc3RhcnQgKyBcIiAtIFwiICsgKHN0YXJ0ICsgMTAgKyAxKTtcblx0ICAgICAgfSxcblx0ICAgICAgX2dldENvbnRlbnQ6IGZ1bmN0aW9uIChpLCBjYWxlbmRhcikge1xuXHQgICAgICAgIHJldHVybiBjYWxlbmRhci5fem9vbV9zdGFydF9kYXRlICsgaTtcblx0ICAgICAgfSxcblx0ICAgICAgX3NldENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0LCBpLCBjYWxlbmRhcikge1xuXHQgICAgICAgIG5leHQuc2V0RnVsbFllYXIoY2FsZW5kYXIuX3pvb21fc3RhcnRfZGF0ZSArIGkpO1xuXHQgICAgICB9LFxuXHQgICAgICBfY2hhbmdlU3RlcDogMTIgKiAxMCxcblx0ICAgICAgX2tleXNoaWZ0OiBmdW5jdGlvbiAoZGF0ZSwgbW9kZSwgY2FsZW5kYXIpIHtcblx0ICAgICAgICB2YXIgbmV3ZGF0ZSA9IGRhdGU7XG5cdCAgICAgICAgaWYgKG1vZGUgPT09IFwicGd1cFwiIHx8IG1vZGUgPT09IFwicGdkb3duXCIpIG5ld2RhdGUgPSB3RGF0ZS5hZGQoZGF0ZSwgbW9kZSA9PT0gXCJwZ2Rvd25cIiA/IDEwIDogLTEwLCBcInllYXJcIik7ZWxzZSBpZiAobW9kZSA9PT0gXCJib3R0b21cIikgbmV3ZGF0ZSA9IG5ldyBEYXRlKGRhdGUuc2V0WWVhcihjYWxlbmRhci5fem9vbV9zdGFydF9kYXRlICsgMTApKTtlbHNlIGlmIChtb2RlID09PSBcInRvcFwiKSBuZXdkYXRlID0gbmV3IERhdGUoZGF0ZS5zZXRZZWFyKGNhbGVuZGFyLl96b29tX3N0YXJ0X2RhdGUpKTtlbHNlIGlmIChtb2RlID09PSBcImxlZnRcIiB8fCBtb2RlID09PSBcInJpZ2h0XCIpIG5ld2RhdGUgPSB3RGF0ZS5hZGQoZGF0ZSwgbW9kZSA9PT0gXCJyaWdodFwiID8gMSA6IC0xLCBcInllYXJcIik7ZWxzZSBpZiAobW9kZSA9PT0gXCJ1cFwiIHx8IG1vZGUgPT09IFwiZG93blwiKSBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIG1vZGUgPT09IFwiZG93blwiID8gNCA6IC00LCBcInllYXJcIik7XG5cdCAgICAgICAgaWYgKCFjYWxlbmRhci5fY2hlY2tEYXRlKG5ld2RhdGUpKSBuZXdkYXRlID0gY2FsZW5kYXIuX2ZpbmRBY3RpdmUoZGF0ZSwgbW9kZSk7XG5cblx0ICAgICAgICBpZiAobmV3ZGF0ZSkge1xuXHQgICAgICAgICAgY2FsZW5kYXIuX3VwZGF0ZV96b29tX2xldmVsKG5ld2RhdGUpO1xuXG5cdCAgICAgICAgICBjYWxlbmRhci5zZWxlY3REYXRlKG5ld2RhdGUsIGZhbHNlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gXCJ3ZWJpeF9jYWxfYmxvY2tcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NvcnJlY3RCbG9ja2VkVGltZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGksIGlzRGlzYWJsZWRIb3VyLCBpc0Rpc2FibGVkTWludXRlcztcblx0ICAgIGlzRGlzYWJsZWRIb3VyID0gdGhpcy5fem9vbV9sb2dpY1stMV0uX2lzQmxvY2tlZC5jYWxsKHRoaXMsIHRoaXMuX3NldHRpbmdzLmRhdGUuZ2V0SG91cnMoKSk7XG5cblx0ICAgIGlmIChpc0Rpc2FibGVkSG91cikge1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgIGlmICghdGhpcy5fem9vbV9sb2dpY1stMV0uX2lzQmxvY2tlZC5jYWxsKHRoaXMsIGkpKSB7XG5cdCAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5kYXRlLnNldEhvdXJzKGkpO1xuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaXNEaXNhYmxlZE1pbnV0ZXMgPSB0aGlzLl96b29tX2xvZ2ljWy0yXS5faXNCbG9ja2VkLmNhbGwodGhpcywgdGhpcy5fc2V0dGluZ3MuZGF0ZS5nZXRNaW51dGVzKCkpO1xuXG5cdCAgICBpZiAoaXNEaXNhYmxlZE1pbnV0ZXMpIHtcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IDYwOyBpICs9IHRoaXMuX3NldHRpbmdzLm1pbnV0ZVN0ZXApIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX3pvb21fbG9naWNbLTJdLl9pc0Jsb2NrZWQuY2FsbCh0aGlzLCBpKSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0dGluZ3MuZGF0ZS5zZXRNaW51dGVzKGkpO1xuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF91cGRhdGVfem9vbV9sZXZlbDogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIHZhciBjb25maWcsIGNzcywgaGVpZ2h0LCBpLCBpbmRleCQkMSwgc2VjdGlvbnMsIHNlbGVjdGVkLCB0eXBlLCB3aWR0aCwgemxvZ2ljLCB0ZW1wLCBzcVNpemU7XG5cdCAgICB2YXIgaHRtbCA9IFwiXCI7XG5cdCAgICBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGluZGV4JCQxID0gY29uZmlnLndlZWtIZWFkZXIgPyAyIDogMTtcblx0ICAgIHpsb2dpYyA9IHRoaXMuX3pvb21fbG9naWNbdGhpcy5fem9vbV9sZXZlbF07XG5cdCAgICBzZWN0aW9ucyA9IHRoaXMuX2NvbnRlbnRvYmouY2hpbGROb2RlcztcblxuXHQgICAgaWYgKGRhdGUpIHtcblx0ICAgICAgY29uZmlnLmRhdGUgPSBkYXRlO1xuXHQgICAgfVxuXG5cdCAgICB0eXBlID0gY29uZmlnLnR5cGU7IC8vc3RvcmUgd2lkdGggYW5kIGhlaWdodCBvZiBkcmF3IGFyZWFcblxuXHQgICAgaWYgKCF0aGlzLl96b29tX3NpemUpIHtcblx0ICAgICAgLyp0aGlzLl9yZXNlcnZlX2JveF9oZWlnaHQgPSBzZWN0aW9uc1tpbmRleF0ub2Zmc2V0SGVpZ2h0ICsoaW5kZXg9PTI/c2VjdGlvbnNbMV0ub2Zmc2V0SGVpZ2h0OjApOyovXG5cdCAgICAgIHRoaXMuX3Jlc2VydmVfYm94X2hlaWdodCA9IHRoaXMuX2NvbnRlbnRvYmoub2Zmc2V0SGVpZ2h0IC0gY29uZmlnLmhlYWRlckhlaWdodDtcblx0ICAgICAgaWYgKHR5cGUgIT0gXCJ5ZWFyXCIgJiYgdHlwZSAhPSBcIm1vbnRoXCIpIHRoaXMuX3Jlc2VydmVfYm94X2hlaWdodCAtPSBjb25maWcudGltZXBpY2tlckhlaWdodDtlbHNlIGlmICh0aGlzLl9pY29ucykge1xuXHQgICAgICAgIHRoaXMuX3Jlc2VydmVfYm94X2hlaWdodCAtPSAxMDtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9yZXNlcnZlX2JveF93aWR0aCA9IHNlY3Rpb25zW2luZGV4JCQxXS5vZmZzZXRXaWR0aDtcblx0ICAgICAgdGhpcy5fem9vbV9zaXplID0gMTtcblx0ICAgIH0gLy9tYWluIHNlY3Rpb25cblxuXG5cdCAgICBpZiAodGhpcy5fem9vbV9pbikge1xuXHQgICAgICAvL2hvdXJzIGFuZCBtaW51dGVzXG5cdCAgICAgIGhlaWdodCA9IHRoaXMuX3Jlc2VydmVfYm94X2hlaWdodCAvIDY7XG5cdCAgICAgIHZhciB0aW1lQ29sTnVtID0gNjtcblx0ICAgICAgdmFyIHRpbWVGb3JtYXQgPSB0aGlzLl9jYWxlbmRhclRpbWUgfHwgaTE4bi50aW1lRm9ybWF0O1xuXHQgICAgICB2YXIgZW5Mb2NhbGUgPSB0aW1lRm9ybWF0Lm1hdGNoKC8lKFthLEFdKS8pO1xuXHQgICAgICBpZiAoZW5Mb2NhbGUpIHRpbWVDb2xOdW0rKztcblx0ICAgICAgd2lkdGggPSBwYXJzZUludCgodGhpcy5fcmVzZXJ2ZV9ib3hfd2lkdGggLSAzKSAvIHRpbWVDb2xOdW0sIDEwKTtcblx0ICAgICAgc3FTaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG5cdCAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90aW1lX2hlYWRlcic+XCIgKyB0aGlzLl90aW1lSGVhZGVyVGVtcGxhdGUod2lkdGgsIGVuTG9jYWxlKSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIGh0bWwgKz0gXCI8ZGl2ICBjbGFzcz0nd2ViaXhfY2FsX2JvZHknIHN0eWxlPSdoZWlnaHQ6XCIgKyB0aGlzLl9yZXNlcnZlX2JveF9oZWlnaHQgKyBcInB4Jz5cIjsgLy8gY2hlY2sgYW5kIGNoYW5nZSBibG9ja2VkIHNlbGVjdGVkIHRpbWVcblxuXHQgICAgICB0aGlzLl9jb3JyZWN0QmxvY2tlZFRpbWUoKTtcblxuXHQgICAgICBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfaG91cnMnPlwiO1xuXHQgICAgICBzZWxlY3RlZCA9IGNvbmZpZy5kYXRlLmdldEhvdXJzKCk7XG5cdCAgICAgIHRlbXAgPSB3RGF0ZS5jb3B5KGNvbmZpZy5kYXRlKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgIGNzcyA9IFwiXCI7XG5cblx0ICAgICAgICBpZiAoZW5Mb2NhbGUpIHtcblx0ICAgICAgICAgIGlmIChpICUgNCA9PT0gMCkge1xuXHQgICAgICAgICAgICB2YXIgbGFiZWwgPSAhaSA/IGkxOG4uYW1bMF0gOiBpID09IDEyID8gaTE4bi5wbVswXSA6IFwiXCI7XG5cdCAgICAgICAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9jYWxfYmxvY2tfZW1wdHlcIiArIGNzcyArIFwiJyBzdHlsZT0nXCIgKyB0aGlzLl9nZXRDYWxTaXplc1N0cmluZyh3aWR0aCwgaGVpZ2h0KSArIFwiY2xlYXI6Ym90aDtcIiArIFwiJz5cIiArIGxhYmVsICsgXCI8L2Rpdj5cIjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodGhpcy5fem9vbV9sb2dpY1stMV0uX2lzQmxvY2tlZC5jYWxsKHRoaXMsIGkpKSB7XG5cdCAgICAgICAgICBjc3MgKz0gXCIgd2ViaXhfY2FsX2RheV9kaXNhYmxlZFwiO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWQgPT0gaSkgY3NzICs9IFwiIHdlYml4X3NlbGVjdGVkXCI7XG5cblx0ICAgICAgICB0ZW1wLnNldEhvdXJzKGkpO1xuXHQgICAgICAgIGh0bWwgKz0gXCI8ZGl2IGFyaWEtbGFiZWw9J1wiICsgd0RhdGUuZGF0ZVRvU3RyKGkxOG4uYXJpYS5ob3VyRm9ybWF0KSh0ZW1wKSArIFwiJyByb2xlPSdncmlkY2VsbCdcIiArIFwiIHRhYmluZGV4PSdcIiArIChzZWxlY3RlZCA9PSBpID8gXCIwXCIgOiBcIi0xXCIpICsgXCInIGFyaWEtc2VsZWN0ZWQ9J1wiICsgKHNlbGVjdGVkID09IGkgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIicgY2xhc3M9J3dlYml4X2NhbF9ibG9ja1wiICsgY3NzICsgXCInIGRhdGEtdmFsdWU9J1wiICsgaSArIFwiJyBzdHlsZT0nXCIgKyB0aGlzLl9nZXRDYWxTaXplc1N0cmluZyh3aWR0aCwgaGVpZ2h0KSArIChpICUgNCA9PT0gMCAmJiAhZW5Mb2NhbGUgPyBcImNsZWFyOmJvdGg7XCIgOiBcIlwiKSArIFwiJz48c3BhbiBzdHlsZT0nZGlzcGxheTppbmxpbmUtYmxvY2s7IFwiICsgdGhpcy5fZ2V0Q2FsU2l6ZXNTdHJpbmcoc3FTaXplLCBzcVNpemUpICsgXCInPlwiICsgd0RhdGUudG9GaXhlZChlbkxvY2FsZSA/ICFpIHx8IGkgPT0gMTIgPyAxMiA6IGkgJSAxMiA6IGkpICsgXCI8L3NwYW4+PC9kaXY+XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICAgIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9taW51dGVzJz5cIjtcblx0ICAgICAgc2VsZWN0ZWQgPSBjb25maWcuZGF0ZS5nZXRNaW51dGVzKCk7XG5cdCAgICAgIHRlbXAgPSB3RGF0ZS5jb3B5KGNvbmZpZy5kYXRlKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgNjA7IGkgKz0gY29uZmlnLm1pbnV0ZVN0ZXApIHtcblx0ICAgICAgICBjc3MgPSBcIlwiO1xuXG5cdCAgICAgICAgaWYgKHRoaXMuX3pvb21fbG9naWNbLTJdLl9pc0Jsb2NrZWQuY2FsbCh0aGlzLCBpKSkge1xuXHQgICAgICAgICAgY3NzID0gXCIgd2ViaXhfY2FsX2RheV9kaXNhYmxlZFwiO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWQgPT0gaSkgY3NzID0gXCIgd2ViaXhfc2VsZWN0ZWRcIjtcblxuXHQgICAgICAgIHRlbXAuc2V0TWludXRlcyhpKTtcblx0ICAgICAgICBodG1sICs9IFwiPGRpdiBhcmlhLWxhYmVsPSdcIiArIHdEYXRlLmRhdGVUb1N0cihpMThuLmFyaWEubWludXRlRm9ybWF0KSh0ZW1wKSArIFwiJyByb2xlPSdncmlkY2VsbCcgdGFiaW5kZXg9J1wiICsgKHNlbGVjdGVkID09IGkgPyBcIjBcIiA6IFwiLTFcIikgKyBcIicgYXJpYS1zZWxlY3RlZD0nXCIgKyAoc2VsZWN0ZWQgPT0gaSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSArIFwiJyBjbGFzcz0nd2ViaXhfY2FsX2Jsb2NrIHdlYml4X2NhbF9ibG9ja19taW5cIiArIGNzcyArIFwiJyBkYXRhLXZhbHVlPSdcIiArIGkgKyBcIicgc3R5bGU9J1wiICsgdGhpcy5fZ2V0Q2FsU2l6ZXNTdHJpbmcod2lkdGgsIGhlaWdodCkgKyAoaSAlIDIgPT09IDAgPyBcImNsZWFyOmJvdGg7XCIgOiBcIlwiKSArIFwiJz48c3BhbiBzdHlsZT0nZGlzcGxheTppbmxpbmUtYmxvY2s7IFwiICsgdGhpcy5fZ2V0Q2FsU2l6ZXNTdHJpbmcoc3FTaXplLCBzcVNpemUpICsgXCInPlwiICsgd0RhdGUudG9GaXhlZChpKSArIFwiPC9zcGFuPjwvZGl2PlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICAgIGh0bWwgKz0gXCI8ZGl2ICBjbGFzcz0nd2ViaXhfdGltZV9mb290ZXInPlwiICsgdGhpcy5fdGltZUJ1dHRvbnNUZW1wbGF0ZSgpICsgXCI8L2Rpdj5cIjtcblx0ICAgICAgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgPSBodG1sO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy95ZWFycyBhbmQgbW9udGhzXG5cdCAgICAgIC8vcmVzZXQgaGVhZGVyXG5cdCAgICAgIHZhciBoZWFkZXIgPSBzZWN0aW9uc1swXS5jaGlsZE5vZGVzO1xuXHQgICAgICB2YXIgbGFiZWxzID0gaTE4bi5hcmlhW1wibmF2XCIgKyAodGhpcy5fem9vbV9sZXZlbCA9PSAxID8gXCJZZWFyXCIgOiBcIkRlY2FkZVwiKV07XG5cdCAgICAgIGhlYWRlclswXS5pbm5lckhUTUwgPSB6bG9naWMuX2dldFRpdGxlKGNvbmZpZy5kYXRlLCB0aGlzKTtcblx0ICAgICAgaGVhZGVyWzFdLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWxzWzBdKTtcblx0ICAgICAgaGVhZGVyWzJdLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWxzWzFdKTtcblx0ICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLl9yZXNlcnZlX2JveF9oZWlnaHQgLyAzKTtcblx0ICAgICAgd2lkdGggPSBNYXRoLmZsb29yKHRoaXMuX3Jlc2VydmVfYm94X3dpZHRoIC8gNCk7XG5cdCAgICAgIHNxU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgd2lkdGgpO1xuXHQgICAgICBpZiAodGhpcy5fY2hlY2tEYXRlKGNvbmZpZy5kYXRlKSkgc2VsZWN0ZWQgPSB0aGlzLl96b29tX2xldmVsID09IDEgPyBjb25maWcuZGF0ZS5nZXRNb250aCgpIDogY29uZmlnLmRhdGUuZ2V0RnVsbFllYXIoKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuXHQgICAgICAgIGNzcyA9IHNlbGVjdGVkID09ICh0aGlzLl96b29tX2xldmVsID09IDEgPyBpIDogemxvZ2ljLl9nZXRDb250ZW50KGksIHRoaXMpKSA/IFwiIHdlYml4X3NlbGVjdGVkXCIgOiBcIlwiO1xuXG5cdCAgICAgICAgaWYgKHpsb2dpYy5faXNCbG9ja2VkKGksIHRoaXMpKSB7XG5cdCAgICAgICAgICBjc3MgKz0gXCIgd2ViaXhfY2FsX2RheV9kaXNhYmxlZFwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBmb3JtYXQgPSBpMThuLmFyaWFbKHRoaXMuX3pvb21fbGV2ZWwgPT0gMSA/IFwibW9udGhcIiA6IFwieWVhclwiKSArIFwiRm9ybWF0XCJdO1xuXHQgICAgICAgIGh0bWwgKz0gXCI8ZGl2IHJvbGU9J2dyaWRjZWxsJyBhcmlhLWxhYmVsPSdcIiArIHdEYXRlLmRhdGVUb1N0cihmb3JtYXQpKGNvbmZpZy5kYXRlKSArIFwiJyB0YWJpbmRleD0nXCIgKyAoY3NzLmluZGV4T2YoXCJzZWxlY3RlZFwiKSAhPT0gLTEgPyBcIjBcIiA6IFwiLTFcIikgKyBcIicgYXJpYS1zZWxlY3RlZD0nXCIgKyAoY3NzLmluZGV4T2YoXCJzZWxlY3RlZFwiKSAhPT0gLTEgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIicgY2xhc3M9J3dlYml4X2NhbF9ibG9ja1wiICsgY3NzICsgXCInIGRhdGEtdmFsdWU9J1wiICsgaSArIFwiJyBzdHlsZT0nXCIgKyB0aGlzLl9nZXRDYWxTaXplc1N0cmluZyh3aWR0aCwgaGVpZ2h0KSArIFwiJz48c3BhbiBzdHlsZT0nZGlzcGxheTppbmxpbmUtYmxvY2s7IFwiICsgdGhpcy5fZ2V0Q2FsU2l6ZXNTdHJpbmcoc3FTaXplLCBzcVNpemUpICsgXCInPlwiICsgemxvZ2ljLl9nZXRDb250ZW50KGksIHRoaXMpICsgXCI8L3NwYW4+PC9kaXY+XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaW5kZXgkJDEgLSAxKSB7XG5cdCAgICAgICAgc2VjdGlvbnNbaW5kZXgkJDEgLSAxXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBzZWN0aW9uc1tpbmRleCQkMV0uaW5uZXJIVE1MID0gaHRtbDtcblxuXHQgICAgICBpZiAodHlwZSAhPSBcInllYXJcIiAmJiB0eXBlICE9IFwibW9udGhcIikge1xuXHQgICAgICAgIGlmICghc2VjdGlvbnNbaW5kZXgkJDEgKyAxXSkgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgKz0gXCI8ZGl2ICBjbGFzcz0nd2ViaXhfdGltZV9mb290ZXInPlwiICsgdGhpcy5fdGltZUJ1dHRvbnNUZW1wbGF0ZSgpICsgXCI8L2Rpdj5cIjtlbHNlIHNlY3Rpb25zW2luZGV4JCQxICsgMV0uaW5uZXJIVE1MID0gdGhpcy5fdGltZUJ1dHRvbnNUZW1wbGF0ZSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2VjdGlvbnNbaW5kZXgkJDFdLnN0eWxlLmhlaWdodCA9IHRoaXMuX3Jlc2VydmVfYm94X2hlaWdodCArIFwicHhcIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9nZXRDYWxTaXplc1N0cmluZzogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgIHJldHVybiBcIndpZHRoOlwiICsgd2lkdGggKyBcInB4OyBoZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4OyBsaW5lLWhlaWdodDpcIiArIGhlaWdodCArIFwicHg7XCI7XG5cdCAgfSxcblx0ICBfdGltZUJ1dHRvbnNUZW1wbGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIFwiPGlucHV0IHR5cGU9J2J1dHRvbicgc3R5bGU9J3dpZHRoOjEwMCUnIGNsYXNzPSd3ZWJpeF9jYWxfZG9uZScgdmFsdWU9J1wiICsgaTE4bi5jYWxlbmRhci5kb25lICsgXCInPlwiO1xuXHQgIH0sXG5cdCAgX3RpbWVIZWFkZXJUZW1wbGF0ZTogZnVuY3Rpb24gKHdpZHRoLCBlbkxvY2FsZSkge1xuXHQgICAgdmFyIHcxID0gd2lkdGggKiAoZW5Mb2NhbGUgPyA1IDogNCk7XG5cdCAgICB2YXIgdzIgPSB3aWR0aCAqIDI7XG5cdCAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9jYWxfaG91cnMnIHN0eWxlPSd3aWR0aDpcIiArIHcxICsgXCJweCc+XCIgKyBpMThuLmNhbGVuZGFyLmhvdXJzICsgXCI8L2Rpdj48ZGl2IGNsYXNzPSd3ZWJpeF9jYWxfbWludXRlcycgc3R5bGU9J3dpZHRoOlwiICsgdzIgKyBcInB4Jz5cIiArIGkxOG4uY2FsZW5kYXIubWludXRlcyArIFwiPC9kaXY+XCI7XG5cdCAgfSxcblx0ICBfY2hhbmdlWm9vbUxldmVsOiBmdW5jdGlvbiAoem9vbSwgZGF0ZSkge1xuXHQgICAgdmFyIG9sZHpvb20gPSB0aGlzLl96b29tX2xldmVsO1xuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVpvb21cIiwgW3pvb20sIG9sZHpvb21dKSkge1xuXHQgICAgICB0aGlzLl96b29tX2xldmVsID0gem9vbTtcblx0ICAgICAgaWYgKHpvb20pIHRoaXMuX3VwZGF0ZV96b29tX2xldmVsKGRhdGUpO2Vsc2UgdGhpcy5zaG93Q2FsZW5kYXIoZGF0ZSk7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclpvb21cIiwgW3pvb20sIG9sZHpvb21dKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jb3JyZWN0RGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIGlmICghdGhpcy5fY2hlY2tEYXRlKGRhdGUpICYmIHRoaXMuX3pvb21fbG9naWNbdGhpcy5fem9vbV9sZXZlbF0uX2NvcnJlY3REYXRlKSBkYXRlID0gdGhpcy5fem9vbV9sb2dpY1t0aGlzLl96b29tX2xldmVsXS5fY29ycmVjdERhdGUoZGF0ZSwgdGhpcyk7XG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9LFxuXHQgIF9tb2RlX3NlbGVjdGVkOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdCAgICB2YXIgbmV4dCA9IHRoaXMuX2xvY2F0ZV9kYXRlKHRhcmdldCk7XG5cblx0ICAgIHZhciB6b29tID0gdGhpcy5fem9vbV9sZXZlbCAtICh0aGlzLl9maXhlZCA/IDAgOiAxKTtcblx0ICAgIG5leHQgPSB0aGlzLl9jb3JyZWN0RGF0ZShuZXh0KTtcblxuXHQgICAgaWYgKHRoaXMuX2NoZWNrRGF0ZShuZXh0KSkge1xuXHQgICAgICB0aGlzLl9jaGFuZ2Vab29tTGV2ZWwoem9vbSwgbmV4dCk7XG5cblx0ICAgICAgdmFyIHR5cGUgPSB0aGlzLl9zZXR0aW5ncy50eXBlO1xuXHQgICAgICBpZiAodHlwZSA9PSBcIm1vbnRoXCIgfHwgdHlwZSA9PSBcInllYXJcIikgdGhpcy5fc2VsZWN0RGF0ZShuZXh0KTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vIHNlbGVjdHMgZGF0ZSBhbmQgcmVkcmF3IGNhbGVuZGFyXG5cdCAgX3NlbGVjdERhdGU6IGZ1bmN0aW9uIChkYXRlLCBhZGQpIHtcblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlRGF0ZVNlbGVjdFwiLCBbZGF0ZV0pKSB7XG5cdCAgICAgIHRoaXMuc2VsZWN0RGF0ZShkYXRlLCB0cnVlLCBhZGQpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uRGF0ZVNlbGVjdFwiLCBbZGF0ZV0pOyAvLyBzaG91bGQgYmUgZGVsZXRlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRGF0ZVNlbGVjdFwiLCBbZGF0ZV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2xvY2F0ZV9kYXk6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgIHZhciBjaW5kID0gaW5kZXgodGFyZ2V0KSAtICh0aGlzLl9zZXR0aW5ncy53ZWVrTnVtYmVyID8gMSA6IDApO1xuXHQgICAgdmFyIHJpbmQgPSBpbmRleCh0YXJnZXQucGFyZW50Tm9kZSk7XG5cdCAgICB2YXIgZGF0ZSA9IHdEYXRlLmFkZCh0aGlzLl9nZXREYXRlQm91bmRhcmllcygpLl9zdGFydCwgY2luZCArIHJpbmQgKiA3LCBcImRheVwiLCB0cnVlKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRpbWVwaWNrZXIpIHtcblx0ICAgICAgZGF0ZS5zZXRIb3Vycyh0aGlzLl9zZXR0aW5ncy5kYXRlLmdldEhvdXJzKCkpO1xuXHQgICAgICBkYXRlLnNldE1pbnV0ZXModGhpcy5fc2V0dGluZ3MuZGF0ZS5nZXRNaW51dGVzKCkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9LFxuXHQgIF9sb2NhdGVfZGF0ZTogZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgICAgdmFyIHZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikgKiAxO1xuXHQgICAgdmFyIGxldmVsID0gdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFwid2ViaXhfY2FsX2Jsb2NrX21pblwiKSAhPSAtMSA/IHRoaXMuX3pvb21fbGV2ZWwgLSAxIDogdGhpcy5fem9vbV9sZXZlbDtcblx0ICAgIHZhciBub3cgPSB0aGlzLl9zZXR0aW5ncy5kYXRlO1xuXHQgICAgdmFyIG5leHQgPSB3RGF0ZS5jb3B5KG5vdyk7XG5cblx0ICAgIHRoaXMuX3pvb21fbG9naWNbbGV2ZWxdLl9zZXRDb250ZW50KG5leHQsIHZhbHVlLCB0aGlzKTtcblxuXHQgICAgcmV0dXJuIG5leHQ7XG5cdCAgfSxcblx0ICBvbl9jbGljazoge1xuXHQgICAgd2ViaXhfY2FsX3ByZXZfYnV0dG9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuX2NoYW5nZURhdGUoLTEpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9uZXh0X2J1dHRvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLl9jaGFuZ2VEYXRlKDEpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9kYXlfZGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9vdXRzaWRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MubmF2aWdhdGlvbikgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9kYXk6IGZ1bmN0aW9uIChlLCBpZCwgdGFyZ2V0KSB7XG5cdCAgICAgIHZhciBkYXRlID0gdGhpcy5fbG9jYXRlX2RheSh0YXJnZXQpO1xuXG5cdCAgICAgIHZhciBhZGQgPSB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PT0gXCJ0b3VjaFwiIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXk7XG5cblx0ICAgICAgdGhpcy5fc2VsZWN0RGF0ZShkYXRlLCBhZGQpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF90aW1lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl96b29tX2xvZ2ljW3RoaXMuX3pvb21fbGV2ZWwgLSAxXSkge1xuXHQgICAgICAgIHRoaXMuX3pvb21faW4gPSB0cnVlO1xuXHQgICAgICAgIHZhciB6b29tID0gdGhpcy5fem9vbV9sZXZlbCAtIDE7XG5cblx0ICAgICAgICB0aGlzLl9jaGFuZ2Vab29tTGV2ZWwoem9vbSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB3ZWJpeF9yYW5nZV90aW1lX3N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICQkKHRoaXMuX3NldHRpbmdzLm1hc3RlcikuX3RpbWVfbW9kZSA9IFwic3RhcnRcIjtcblx0ICAgIH0sXG5cdCAgICB3ZWJpeF9yYW5nZV90aW1lX2VuZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAkJCh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpLl90aW1lX21vZGUgPSBcImVuZFwiO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9kb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBkYXRlID0gd0RhdGUuY29weSh0aGlzLl9zZXR0aW5ncy5kYXRlKTtcblx0ICAgICAgZGF0ZSA9IHRoaXMuX2NvcnJlY3REYXRlKGRhdGUpO1xuXG5cdCAgICAgIHRoaXMuX3NlbGVjdERhdGUoZGF0ZSk7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfY2FsX21vbnRoX25hbWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fem9vbV9pbiA9IGZhbHNlOyAvL21heGltdW0gem9vbSByZWFjaGVkXG5cblx0ICAgICAgaWYgKHRoaXMuX3pvb21fbGV2ZWwgPT0gMiB8fCAhdGhpcy5fc2V0dGluZ3MubW9udGhTZWxlY3QpIHJldHVybjtcblx0ICAgICAgdmFyIHpvb20gPSBNYXRoLm1heCh0aGlzLl96b29tX2xldmVsLCAwKSArIDE7XG5cblx0ICAgICAgdGhpcy5fY2hhbmdlWm9vbUxldmVsKHpvb20pO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2NhbF9ibG9jazogZnVuY3Rpb24gKGUsIGlkLCB0cmcpIHtcblx0ICAgICAgaWYgKHRoaXMuX3pvb21faW4pIHtcblx0ICAgICAgICBpZiAodHJnLmNsYXNzTmFtZS5pbmRleE9mKFwid2ViaXhfY2FsX2RheV9kaXNhYmxlZFwiKSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fbG9jYXRlX2RhdGUodHJnKTtcblxuXHQgICAgICAgIHRoaXMuX3VwZGF0ZV96b29tX2xldmVsKG5leHQpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0cmcuY2xhc3NOYW1lLmluZGV4T2YoXCJ3ZWJpeF9jYWxfZGF5X2Rpc2FibGVkXCIpID09IC0xKSB0aGlzLl9tb2RlX3NlbGVjdGVkKHRyZyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zdHJpbmdfdG9fZGF0ZTogZnVuY3Rpb24gKGRhdGUsIGZvcm1hdCkge1xuXHQgICAgaWYgKCFkYXRlKSB7XG5cdCAgICAgIHJldHVybiB3RGF0ZS5kYXRlUGFydChuZXcgRGF0ZSgpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBkYXRlID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgaWYgKGZvcm1hdCkgZGF0ZSA9IHdEYXRlLnN0clRvRGF0ZShmb3JtYXQpKGRhdGUpO2Vsc2UgZGF0ZSA9IGkxOG4ucGFyc2VGb3JtYXREYXRlKGRhdGUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9LFxuXHQgIF9jaGVja0RhdGU6IGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICB2YXIgYmxvY2tlZERhdGUgPSB0aGlzLl9zZXR0aW5ncy5ibG9ja0RhdGVzICYmIHRoaXMuX3NldHRpbmdzLmJsb2NrRGF0ZXMuY2FsbCh0aGlzLCBkYXRlKTtcblxuXHQgICAgdmFyIG1pbkRhdGUgPSB0aGlzLl9zZXR0aW5ncy5taW5EYXRlO1xuXHQgICAgdmFyIG1heERhdGUgPSB0aGlzLl9zZXR0aW5ncy5tYXhEYXRlO1xuXHQgICAgdmFyIG91dE9mUmFuZ2UgPSBkYXRlIDwgbWluRGF0ZSB8fCBkYXRlID4gbWF4RGF0ZTtcblx0ICAgIHJldHVybiAhYmxvY2tlZERhdGUgJiYgIW91dE9mUmFuZ2U7XG5cdCAgfSxcblx0ICBfZmluZEFjdGl2ZTogZnVuY3Rpb24gKGRhdGUsIG1vZGUpIHtcblx0ICAgIHZhciBkaXIgPSBtb2RlID09PSBcInRvcFwiIHx8IG1vZGUgPT09IFwibGVmdFwiIHx8IG1vZGUgPT09IFwicGd1cFwiIHx8IG1vZGUgPT09IFwidXBcIiA/IC0xIDogMTtcblx0ICAgIHZhciBuZXdkYXRlID0gd0RhdGUuYWRkKGRhdGUsIGRpciwgXCJkYXlcIiwgdHJ1ZSk7XG5cdCAgICBpZiAodGhpcy5fY2hlY2tEYXRlKG5ld2RhdGUpKSByZXR1cm4gbmV3ZGF0ZTtlbHNlIHtcblx0ICAgICAgdmFyIGNvbXBhcmU7XG5cdCAgICAgIGlmICh0aGlzLl96b29tX2xldmVsID09PSAwKSBjb21wYXJlID0gZGF0ZS5nZXRNb250aCgpID09PSBuZXdkYXRlLmdldE1vbnRoKCk7ZWxzZSBpZiAodGhpcy5fem9vbV9sZXZlbCA9PT0gMSkgY29tcGFyZSA9IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gbmV3ZGF0ZS5nZXRGdWxsWWVhcigpO2Vsc2UgaWYgKHRoaXMuX3pvb21fbGV2ZWwgPT09IDIpIGNvbXBhcmUgPSBuZXdkYXRlLmdldEZ1bGxZZWFyKCkgPiB0aGlzLl96b29tX3N0YXJ0X2RhdGUgJiYgbmV3ZGF0ZS5nZXRGdWxsWWVhcigpIDwgdGhpcy5fem9vbV9zdGFydF9kYXRlICsgMTA7XG5cdCAgICAgIGlmIChjb21wYXJlKSByZXR1cm4gdGhpcy5fZmluZEFjdGl2ZShuZXdkYXRlLCBtb2RlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHNob3dDYWxlbmRhcjogZnVuY3Rpb24gKGRhdGUpIHtcblx0ICAgIGRhdGUgPSB0aGlzLl9zdHJpbmdfdG9fZGF0ZShkYXRlKTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmRhdGUgPSBkYXRlO1xuXHQgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIHRoaXMucmVzaXplKCk7XG5cdCAgfSxcblx0ICBfc2VsZWN0ZWREYXk6IGZ1bmN0aW9uIChkYXkpIHtcblx0ICAgIHJldHVybiBkYXkgJiYgdGhpcy5fc2VsZWN0ZWRfZGF5c1tkYXkudmFsdWVPZigpXTtcblx0ICB9LFxuXHQgIGdldFNlbGVjdGVkRGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fc2VsZWN0ZWRfZGF5cykge1xuXHQgICAgICByZXN1bHQucHVzaCh3RGF0ZS5jb3B5KHRoaXMuX3NlbGVjdGVkX2RheXNba2V5XSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5jb25maWcubXVsdGlzZWxlY3QgPyByZXN1bHQgOiByZXN1bHRbMF0gfHwgbnVsbDtcblx0ICB9LFxuXHQgIGdldFZpc2libGVEYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gd0RhdGUuY29weSh0aGlzLl9zZXR0aW5ncy5kYXRlKTtcblx0ICB9LFxuXHQgIHNldFZhbHVlOiBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgdGhpcy5zZWxlY3REYXRlKGRhdGUsIHRydWUpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgIHZhciBkYXRlID0gdGhpcy5nZXRTZWxlY3RlZERhdGUoKTtcblx0ICAgIGlmIChmb3JtYXQpIGRhdGUgPSB3RGF0ZS5kYXRlVG9TdHIoZm9ybWF0KShkYXRlKTtcblx0ICAgIHJldHVybiBkYXRlO1xuXHQgIH0sXG5cdCAgc2VsZWN0RGF0ZTogZnVuY3Rpb24gKGRhdGUsIHNob3csIGFkZCkge1xuXHQgICAgaWYgKCFkYXRlIHx8ICFhZGQgfHwgIXRoaXMuY29uZmlnLm11bHRpc2VsZWN0KSB0aGlzLl9zZWxlY3RlZF9kYXlzID0ge307XG5cblx0ICAgIGlmIChkYXRlKSB7XG5cdCAgICAgIGlmICghaXNBcnJheShkYXRlKSkgZGF0ZSA9IFtkYXRlXTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZGF5cyA9IHRoaXMuX3N0cmluZ190b19kYXRlKGRhdGVbaV0pO1xuXG5cdCAgICAgICAgdmFyIGtleSA9IHdEYXRlLmRhdGVQYXJ0KHdEYXRlLmNvcHkoZGF5cykpLnZhbHVlT2YoKTtcblx0ICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRfZGF5c1trZXldICYmIGFkZCkgZGVsZXRlIHRoaXMuX3NlbGVjdGVkX2RheXNba2V5XTtlbHNlIHRoaXMuX3NlbGVjdGVkX2RheXNba2V5XSA9IGRheXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5tdWx0aXNlbGVjdCkgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZGF0ZS5sZW5ndGggJiYgc2hvdykgdGhpcy5zaG93Q2FsZW5kYXIoZGF0ZVswXSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzaG93ICE9PSBmYWxzZSkgdGhpcy5yZW5kZXIoKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25DaGFuZ2VcIiwgW2RhdGVdKTtcblx0ICB9LFxuXHQgIGxvY2F0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRzID0gZXhwb3J0cy5wcm90b1VJKGFwaSRzLCBLZXlzTmF2aWdhdGlvbiwgTW91c2VFdmVudHMsIGJhc2UudmlldywgRXZlbnRTeXN0ZW0pO1xuXG5cdHZhciBhcGkkdCA9IHtcblx0ICBuYW1lOiBcImNvbG9yYm9hcmRcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiPGRpdiBzdHlsZT1cXFwid2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOntvYmoudmFsfVxcXCI+PC9kaXY+XCIsXG5cdCAgICBwYWxldHRlOiBudWxsLFxuXHQgICAgaGVpZ2h0OiAyMjAsXG5cdCAgICB3aWR0aDogMjIwLFxuXHQgICAgY29sczogMTIsXG5cdCAgICByb3dzOiAxMCxcblx0ICAgIG1pbkxpZ2h0bmVzczogMC4xNSxcblx0ICAgIG1heExpZ2h0bmVzczogMSxcblx0ICAgIG5hdmlnYXRpb246IHRydWVcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBfZXZlbnQodGhpcy5fdmlld29iaiwgXCJjbGlja1wiLCBiaW5kKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGxvY2F0ZShlLCBcIndlYml4X3ZhbFwiKTtcblx0ICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25JdGVtQ2xpY2tcIiwgW3RoaXMuX3NldHRpbmdzLnZhbHVlLCBlXSk7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TZWxlY3RcIiwgW3RoaXMuX3NldHRpbmdzLnZhbHVlXSk7XG5cdCAgICB9LCB0aGlzKSk7XG5cblx0ICAgIHRoaXMuJHZpZXcuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImdyaWRcIik7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1yZWFkb25seVwiLCBcInRydWVcIik7XG5cdCAgfSxcblx0ICBfc2V0X2l0ZW1fZm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5nZXRWYWx1ZSgpKSB0aGlzLm1vdmVTZWxlY3Rpb24oXCJ1cFwiKTtcblx0ICB9LFxuXHQgIF9maW5kSW5kZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHBhbCA9IHRoaXMuX3NldHRpbmdzLnBhbGV0dGU7XG5cdCAgICB2YWx1ZSA9ICh2YWx1ZSB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuXG5cdCAgICBmb3IgKHZhciByID0gMCwgcm93cyA9IHBhbC5sZW5ndGg7IHIgPCByb3dzOyByKyspIHtcblx0ICAgICAgZm9yICh2YXIgYyA9IDAsIGNvbHMgPSBwYWxbcl0ubGVuZ3RoOyBjIDwgY29sczsgYysrKSB7XG5cdCAgICAgICAgaWYgKHBhbFtyXVtjXS50b1VwcGVyQ2FzZSgpID09IHZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICByb3c6IHIsXG5cdCAgICAgICAgICAgIGNvbDogY1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmIChiYXNlLmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpKSB7XG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnZhbHVlO1xuXHQgIH0sXG5cdCAgX2dldEJveDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3ZpZXdvYmouZmlyc3RDaGlsZDtcblx0ICB9LFxuXHQgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpLmNoYXJBdCgwKSAhPSBcIiNcIikgdmFsdWUgPSBcIiNcIiArIHZhbHVlO1xuXHQgICAgdmFyIG9sZHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgdGhpcy4kc2V0VmFsdWUodmFsdWUsIG9sZHZhbHVlKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9zZWxlY3RCb3g6IG51bGwsXG5cdCAgX2dldFNlbGVjdEJveDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NlbGVjdEJveCAmJiB0aGlzLl9zZWxlY3RCb3gucGFyZW50Tm9kZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0Qm94O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGRpdiA9IHRoaXMuX3NlbGVjdEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdCAgICAgIGRpdi5jbGFzc05hbWUgPSBcIndlYml4X2NvbG9yX3NlbGVjdG9yXCI7XG5cblx0ICAgICAgdGhpcy5fdmlld29iai5sYXN0Q2hpbGQuYXBwZW5kQ2hpbGQoZGl2KTtcblxuXHQgICAgICByZXR1cm4gZGl2O1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG9sZHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5pc1Zpc2libGUodGhpcy5fc2V0dGluZ3MuaWQpKSB7XG5cdCAgICAgIHZhciBjZWxsLFxuXHQgICAgICAgICAgZGl2LFxuXHQgICAgICAgICAgaW5kLFxuXHQgICAgICAgICAgcGFyZW50LFxuXHQgICAgICAgICAgc3R5bGUsXG5cdCAgICAgICAgICBsZWZ0ID0gMCxcblx0ICAgICAgICAgIHRvcCA9IDA7IC8vcmVtb3ZlIHRhYmluZGV4IGZvciBwcmV2aW91cyBzZWxlY3Rpb25cblxuXHQgICAgICBpZiAob2xkdmFsdWUpIGluZCA9IHRoaXMuX2ZpbmRJbmRleChvbGR2YWx1ZSk7XG5cdCAgICAgIGlmICghaW5kKSBpbmQgPSB7XG5cdCAgICAgICAgcm93OiAwLFxuXHQgICAgICAgIGNvbDogMFxuXHQgICAgICB9O1xuXG5cdCAgICAgIHRoaXMuX3ZpZXdvYmoubGFzdENoaWxkLmNoaWxkTm9kZXNbaW5kLnJvd10uY2hpbGROb2Rlc1tpbmQuY29sXS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuXG5cdCAgICAgIGluZCA9IHRoaXMuX2ZpbmRJbmRleCh2YWx1ZSk7XG5cblx0ICAgICAgaWYgKGluZCkge1xuXHQgICAgICAgIGNlbGwgPSB0aGlzLl92aWV3b2JqLmxhc3RDaGlsZC5jaGlsZE5vZGVzW2luZC5yb3ddLmNoaWxkTm9kZXNbaW5kLmNvbF07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY2VsbCAmJiBjZWxsLnBhcmVudE5vZGUgJiYgY2VsbC5wYXJlbnROb2RlLnBhcmVudE5vZGUpIHtcblx0ICAgICAgICBwYXJlbnQgPSBjZWxsLnBhcmVudE5vZGU7XG5cdCAgICAgICAgbGVmdCA9IGNlbGwub2Zmc2V0TGVmdCAtIHBhcmVudC5vZmZzZXRMZWZ0O1xuXHQgICAgICAgIHRvcCA9IC0odGhpcy4kaGVpZ2h0IC0gKGNlbGwub2Zmc2V0VG9wIC0gcGFyZW50LnBhcmVudE5vZGUub2Zmc2V0VG9wKSk7XG5cdCAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG5cdCAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKTtcblx0ICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcblx0ICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0aGlzLl9zZWxlY3RCb3gpIHRoaXMuX3NlbGVjdEJveC5zdHlsZS5sZWZ0ID0gXCItMTAwcHhcIjtcblxuXHQgICAgICAgIHRoaXMuX3ZpZXdvYmoubGFzdENoaWxkLmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1swXS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICBkaXYgPSB0aGlzLl9nZXRTZWxlY3RCb3goKTtcblx0ICAgICAgc3R5bGUgPSBbXCJsZWZ0OlwiICsgbGVmdCArIFwicHhcIiwgXCJ0b3A6XCIgKyB0b3AgKyBcInB4XCIsIFwid2lkdGg6XCIgKyBjZWxsLnN0eWxlLndpZHRoLCBcImhlaWdodDpcIiArIGNlbGwuc3R5bGUuaGVpZ2h0XS5qb2luKFwiO1wiKTtcblxuXHQgICAgICBpZiAodHlwZW9mIGRpdi5zdHlsZS5jc3NUZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgc3R5bGUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaW5pdFBhbGV0dGU6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGZ1bmN0aW9uIG51bVRvSGV4KG4pIHtcblx0ICAgICAgcmV0dXJuIGNvbG9yLnRvSGV4KG4sIDIpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByZ2JUb0hleChyLCBnLCBiKSB7XG5cdCAgICAgIHJldHVybiBcIiNcIiArIG51bVRvSGV4KE1hdGguZmxvb3IocikpICsgbnVtVG9IZXgoTWF0aC5mbG9vcihnKSkgKyBudW1Ub0hleChNYXRoLmZsb29yKGIpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuXHQgICAgICB2YXIgciwgZywgYjtcblxuXHQgICAgICBpZiAoIXMpIHtcblx0ICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuXHQgICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuXHQgICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG5cdCAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG5cdCAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgcjogciAqIDI1NSxcblx0ICAgICAgICBnOiBnICogMjU1LFxuXHQgICAgICAgIGI6IGIgKiAyNTVcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG5cdCAgICAgIGlmICh0IDwgMCkgdCArPSAxO1xuXHQgICAgICBpZiAodCA+IDEpIHQgLT0gMTtcblx0ICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7ZWxzZSBpZiAodCA8PSAxIC8gMikgcmV0dXJuIHE7ZWxzZSBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7ZWxzZSByZXR1cm4gcDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVuZGVyR3JheUJhcihjb2xDb3VudCkge1xuXHQgICAgICB2YXIgZ3JheSA9IFtdLFxuXHQgICAgICAgICAgdmFsID0gMjU1LFxuXHQgICAgICAgICAgc3RlcCA9IHZhbCAvIGNvbENvdW50O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhbCA9IE1hdGgucm91bmQodmFsID4gMCA/IHZhbCA6IDApO1xuXHQgICAgICAgIGdyYXkucHVzaChyZ2JUb0hleCh2YWwsIHZhbCwgdmFsKSk7XG5cdCAgICAgICAgdmFsIC09IHN0ZXA7XG5cdCAgICAgIH1cblxuXHQgICAgICBncmF5W2dyYXkubGVuZ3RoIC0gMV0gPSBcIiMwMDAwMDBcIjtcblx0ICAgICAgcmV0dXJuIGdyYXk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb2xvcnMgPSBbXTtcblx0ICAgIHZhciBjb2xvclJvd3MgPSBjb25maWcucm93cyAtIDE7XG5cdCAgICB2YXIgY29sb3JTdGVwID0gMSAvIGNvbmZpZy5jb2xzO1xuXHQgICAgdmFyIGxpZ2h0U3RlcCA9IChjb25maWcubWF4TGlnaHRuZXNzIC0gY29uZmlnLm1pbkxpZ2h0bmVzcykgLyBjb2xvclJvd3M7XG5cdCAgICB2YXIgY29sb3JSYW5nZSA9IG51bGw7XG5cdCAgICBjb2xvcnMucHVzaChyZW5kZXJHcmF5QmFyKGNvbmZpZy5jb2xzKSk7XG5cblx0ICAgIGZvciAodmFyIHN0ZXAgPSAwLCBsdCA9IGNvbmZpZy5taW5MaWdodG5lc3M7IHN0ZXAgPCBjb2xvclJvd3M7IHN0ZXArKykge1xuXHQgICAgICBjb2xvclJhbmdlID0gW107XG5cblx0ICAgICAgZm9yICh2YXIgYyA9IDAsIGNvbCA9IDA7IGMgPCBjb25maWcuY29sczsgYysrKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IGhzbFRvUmdiKGNvbCwgMSwgbHQpO1xuXHQgICAgICAgIGNvbG9yUmFuZ2UucHVzaChyZ2JUb0hleCh2YWwuciwgdmFsLmcsIHZhbC5iKSk7XG5cdCAgICAgICAgY29sICs9IGNvbG9yU3RlcDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbG9ycy5wdXNoKGNvbG9yUmFuZ2UpO1xuXHQgICAgICBsdCArPSBsaWdodFN0ZXA7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3NldHRpbmdzLnBhbGV0dGUgPSBjb2xvcnM7XG5cdCAgfSxcblx0ICBtb3ZlU2VsZWN0aW9uOiBmdW5jdGlvbiAobW9kZSwgZGV0YWlscywgZm9jdXMpIHtcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcblx0ICAgICAgICBpbmQsXG5cdCAgICAgICAgY2VsbDtcblx0ICAgIGlmICh2YWx1ZSkgaW5kID0gdGhpcy5fZmluZEluZGV4KHZhbHVlKTtcblx0ICAgIGlmICghaW5kKSBpbmQgPSB7XG5cdCAgICAgIHJvdzogMCxcblx0ICAgICAgY29sOiAwXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoaW5kKSB7XG5cdCAgICAgIGlmIChtb2RlID09IFwidXBcIiB8fCBtb2RlID09IFwiZG93blwiKSBpbmQucm93ID0gaW5kLnJvdyArIChtb2RlID09IFwidXBcIiA/IC0xIDogMSk7ZWxzZSBpZiAobW9kZSA9PSBcInJpZ2h0XCIgfHwgbW9kZSA9PSBcImxlZnRcIikgaW5kLmNvbCA9IGluZC5jb2wgKyAobW9kZSA9PSBcInJpZ2h0XCIgPyAxIDogLTEpO2Vsc2UgaWYgKG1vZGUgPT0gXCJ0b3BcIikgaW5kLnJvdyA9IGluZC5jb2wgPSAwO2Vsc2UgaWYgKG1vZGUgPT0gXCJib3R0b21cIikge1xuXHQgICAgICAgIGluZC5yb3cgPSB0aGlzLl92aWV3b2JqLmxhc3RDaGlsZC5xdWVyeVNlbGVjdG9yQWxsKFwiLndlYml4X2NvbG9yX3Jvd1wiKS5sZW5ndGggLSAxO1xuXHQgICAgICAgIGluZC5jb2wgPSB0aGlzLl92aWV3b2JqLmxhc3RDaGlsZC5jaGlsZE5vZGVzW2luZC5yb3ddLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgfVxuXHQgICAgICBpbmQucm93ID0gTWF0aC5tYXgoaW5kLnJvdywgMCk7XG5cdCAgICAgIGlmIChpbmQucm93ID49IDApIGNlbGwgPSB0aGlzLl92aWV3b2JqLmxhc3RDaGlsZC5jaGlsZE5vZGVzW2luZC5yb3ddLmNoaWxkTm9kZXNbaW5kLmNvbF07XG5cblx0ICAgICAgaWYgKGNlbGwpIHtcblx0ICAgICAgICB2YWx1ZSA9IGNlbGwuZ2V0QXR0cmlidXRlKFwid2ViaXhfdmFsXCIpO1xuXHQgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TZWxlY3RcIiwgW3RoaXMuX3NldHRpbmdzLnZhbHVlXSk7XG5cblx0ICAgICAgICBpZiAoZm9jdXMgIT09IGZhbHNlKSB7XG5cdCAgICAgICAgICB2YXIgc2VsID0gdGhpcy5fdmlld29iai5xdWVyeVNlbGVjdG9yKFwiZGl2W3RhYmluZGV4PScwJ11cIik7XG5cblx0ICAgICAgICAgIGlmIChzZWwpIHNlbC5mb2N1cygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSkgcmV0dXJuO1xuXHQgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5wYWxldHRlKSB0aGlzLl9pbml0UGFsZXR0ZSh0aGlzLl9zZXR0aW5ncyk7XG5cdCAgICB2YXIgcGFsZXR0ZSA9IHRoaXMuX3NldHRpbmdzLnBhbGV0dGU7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUmVuZGVyXCIsIFtdKTtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncyxcblx0ICAgICAgICBpdGVtVHBsID0gdGVtcGxhdGUoXCI8ZGl2IHJvbGU9J2dyaWRjZWxsJyB0YWJpbmRleD0nLTEnIGFyaWEtbGFiZWw9XFxcIntvYmoudmFsfVxcXCIgc3R5bGU9XFxcIndpZHRoOntvYmoud2lkdGh9cHg7aGVpZ2h0OntvYmouaGVpZ2h0fXB4O1xcXCIgd2ViaXhfdmFsPVxcXCJ7b2JqLnZhbH1cXFwiPlwiICsgKGNvbmZpZy50ZW1wbGF0ZSB8fCBcIlwiKSArIFwiPC9kaXY+XCIpLFxuXHQgICAgICAgIGRhdGEgPSB7XG5cdCAgICAgIHdpZHRoOiAwLFxuXHQgICAgICBoZWlnaHQ6IDAsXG5cdCAgICAgIHZhbDogMFxuXHQgICAgfSxcblx0ICAgICAgICB3aWR0aCA9IHRoaXMuJHdpZHRoLFxuXHQgICAgICAgIGhlaWdodCA9IHRoaXMuJGhlaWdodCxcblx0ICAgICAgICB3aWR0aHMgPSBbXTtcblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPVxcXCJ3ZWJpeF9jb2xvcl9wYWxldHRlXFxcInJvbGU9XFxcInJvd2dyb3VwXFxcIj5cIjtcblx0ICAgIHZhciBmaXJzdFJvdyA9IF90eXBlb2YocGFsZXR0ZVswXSkgPT0gXCJvYmplY3RcIiA/IHBhbGV0dGVbMF0gOiBwYWxldHRlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Um93Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHdpZHRoc1tpXSA9IE1hdGguZmxvb3Iod2lkdGggLyAoZmlyc3RSb3cubGVuZ3RoIC0gaSkpO1xuXHQgICAgICB3aWR0aCAtPSB3aWR0aHNbaV07XG5cdCAgICB9XG5cblx0ICAgIGlmIChfdHlwZW9mKHBhbGV0dGVbMF0pID09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBwYWxldHRlLmxlbmd0aDsgcisrKSB7XG5cdCAgICAgICAgdmFyIGNlbGxIZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIChwYWxldHRlLmxlbmd0aCAtIHIpKTtcblx0ICAgICAgICBoZWlnaHQgLT0gY2VsbEhlaWdodDtcblx0ICAgICAgICB2YXIgcm93ID0gcGFsZXR0ZVtyXTtcblx0ICAgICAgICBodG1sICs9IHJlbmRlclJvdyhyb3csIHdpZHRocywgY2VsbEhlaWdodCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGh0bWwgKz0gcmVuZGVyUm93KHBhbGV0dGUsIHdpZHRocywgaGVpZ2h0KTtcblx0ICAgIH1cblxuXHQgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgdGhpcy5fdmlld29iai5pbm5lckhUTUwgPSBodG1sO1xuXG5cdCAgICBmdW5jdGlvbiByZW5kZXJSb3cocm93LCB3aWR0aHMsIGhlaWdodCkge1xuXHQgICAgICB2YXIgcm93SHRtbCA9IFwiPGRpdiBjbGFzcz1cXFwid2ViaXhfY29sb3Jfcm93XFxcIiByb2xlPVxcXCJyb3dcXFwiPlwiO1xuXG5cdCAgICAgIGZvciAodmFyIGNlbGwgPSAwOyBjZWxsIDwgcm93Lmxlbmd0aDsgY2VsbCsrKSB7XG5cdCAgICAgICAgZGF0YS53aWR0aCA9IHdpZHRoc1tjZWxsXTtcblx0ICAgICAgICBkYXRhLmhlaWdodCA9IGhlaWdodDtcblx0ICAgICAgICBkYXRhLnZhbCA9IHJvd1tjZWxsXTtcblx0ICAgICAgICByb3dIdG1sICs9IGl0ZW1UcGwoZGF0YSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByb3dIdG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICAgIHJldHVybiByb3dIdG1sO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9zZWxlY3RCb3ggPSBudWxsO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnZhbHVlKSB0aGlzLiRzZXRWYWx1ZSh0aGlzLl9zZXR0aW5ncy52YWx1ZSk7ZWxzZSB0aGlzLl92aWV3b2JqLmxhc3RDaGlsZC5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNbMF0uc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFtdKTtcblx0ICB9LFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyR0ID0gZXhwb3J0cy5wcm90b1VJKGFwaSR0LCBLZXlzTmF2aWdhdGlvbiwgYmFzZS52aWV3LCBFdmVudFN5c3RlbSk7XG5cblx0dmFyIGFwaSR1ID0ge1xuXHQgIG5hbWU6IFwiYnV0dG9uXCIsXG5cdCAgdG91Y2hhYmxlOiB0cnVlLFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmF1bHRzLmhlaWdodCA9ICRhY3RpdmUuYnV0dG9uSGVpZ2h0IHx8ICRhY3RpdmUuaW5wdXRIZWlnaHQ7IC8vdXNlZCBpbiBcInRleHRcIlxuXG5cdCAgICB0aGlzLl9sYWJlbFRvcEhlaWdodCA9ICRhY3RpdmUubGFiZWxUb3BIZWlnaHQgfHwgMTU7XG5cdCAgICB0aGlzLl9ib3JkZXJXaWR0aCA9ICRhY3RpdmUuYm9yZGVyV2lkdGg7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICB2YXIgdGV4dCA9IGNvbW1vbi4kcmVuZGVySW5wdXQob2JqLCBjb21tb24pO1xuXHQgICAgICBpZiAob2JqLmJhZGdlKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKFwiPC9idXR0b24+XCIsIFwiPHNwYW4gY2xhc3M9J3dlYml4X2JhZGdlJz5cIiArIG9iai5iYWRnZSArIFwiPC9zcGFuPjwvYnV0dG9uPlwiKTtcblx0ICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nd2ViaXhfZWxfYm94JyBzdHlsZT0nd2lkdGg6XCIgKyBvYmouYXdpZHRoICsgXCJweDsgaGVpZ2h0OlwiICsgb2JqLmFoZWlnaHQgKyBcInB4Jz5cIiArIHRleHQgKyBcIjwvZGl2PlwiO1xuXHQgICAgfSxcblx0ICAgIGxhYmVsOiBcIlwiLFxuXHQgICAgYm9yZGVybGVzczogdHJ1ZVxuXHQgIH0sXG5cdCAgJHJlbmRlcklucHV0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgY3NzID0gXCJjbGFzcz0nd2ViaXh0eXBlX1wiICsgKG9iai50eXBlIHx8IFwiYmFzZVwiKSArIFwiJyBcIjtcblx0ICAgIHJldHVybiBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBcIiArIChvYmoucG9wdXAgPyBcImFyaWEtaGFzcG9wdXA9J3RydWUnXCIgOiBcIlwiKSArIGNzcyArIFwiPlwiICsgdGVtcGxhdGUuZXNjYXBlKG9iai5sYWJlbCB8fCBvYmoudmFsdWUpICsgXCI8L2J1dHRvbj5cIjtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9jb250cm9sIHdlYml4X2VsX1wiICsgKHRoaXMuJGNzc05hbWUgfHwgdGhpcy5uYW1lKTtcblx0ICAgIHRoaXMuZGF0YSA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgdGhpcy5fZGF0YW9iaiA9IHRoaXMuX3ZpZXdvYmo7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fY2FsY19zaXplKHRoaXMuY29uZmlnKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgaG90a2V5X3NldHRlcjogZnVuY3Rpb24gKGtleSkge1xuXHQgICAgdmFyIGNvbnRyb2wgPSB0aGlzO1xuXG5cdCAgICB0aGlzLl9hZGRFbGVtZW50SG90S2V5KGtleSwgZnVuY3Rpb24gKHZpZXcsIGV2KSB7XG5cdCAgICAgIGlmIChjb250cm9sLmlzVmlzaWJsZSgpKSB7XG5cdCAgICAgICAgdmFyIGVsZW0gPSBjb250cm9sLiR2aWV3LmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgdHJpZ2dlckV2ZW50KGVsZW0sIFwiTW91c2VFdmVudHNcIiwgXCJjbGlja1wiKTtcblx0ICAgICAgICBwcmV2ZW50RXZlbnQoZXYpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIF9hZGRFbGVtZW50SG90S2V5OiBmdW5jdGlvbiAoa2V5LCBmdW5jLCB2aWV3KSB7XG5cdCAgICB2YXIga2V5Q29kZSA9IFVJTWFuYWdlci5hZGRIb3RLZXkoa2V5LCBmdW5jLCB2aWV3KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgVUlNYW5hZ2VyLnJlbW92ZUhvdEtleShrZXlDb2RlLCBmdW5jLCB2aWV3KTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgdHlwZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHRoaXMuX3R5cGVzW3ZhbHVlXSkgdGhpcy4kcmVuZGVySW5wdXQgPSB0ZW1wbGF0ZSh0aGlzLl90eXBlc1t2YWx1ZV0pO1xuXHQgICAgaWYgKHZhbHVlID09IFwicHJldlwiIHx8IHZhbHVlID09IFwibmV4dFwiKSB0aGlzLl9zZXRfaW5uZXJfc2l6ZSA9IHRoaXMuX3NldF9pbm5lcl9zaXplX25leHQ7ZWxzZSB0aGlzLl9zZXRfaW5uZXJfc2l6ZSA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX3R5cGVzOiB7XG5cdCAgICBodG1sYnV0dG9uOiBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nd2ViaXhfZWxfaHRtbGJ1dHRvbiB3ZWJpeHR5cGVfYmFzZSc+I2xhYmVsIzwvYnV0dG9uPlwiLFxuXHQgICAgcHJldjogXCI8aW5wdXQgdHlwZT0nYnV0dG9uJyBjbGFzcz0nd2ViaXh0eXBlX3ByZXYnIHZhbHVlPScjbGFiZWwjJyAvPjxkaXYgY2xhc3M9J3dlYml4X2VsX2Fycm93IHdlYml4dHlwZV9wcmV2X2Fycm93Jz48L2Rpdj5cIixcblx0ICAgIG5leHQ6IFwiPGlucHV0IHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4dHlwZV9uZXh0JyB2YWx1ZT0nI2xhYmVsIycgLz48ZGl2IGNsYXNzPSd3ZWJpeF9lbF9hcnJvdyB3ZWJpeHR5cGVfbmV4dF9hcnJvdyc+PC9kaXY+XCIsXG5cdCAgICBpbWFnZUJ1dHRvbjogXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4X2ltZ19idG5fYWJzIHdlYml4dHlwZV9iYXNlJyBzdHlsZT0nd2lkdGg6MTAwJTsgbGluZS1oZWlnaHQ6I2NoZWlnaHQjcHgnPjxkaXYgY2xhc3M9J3dlYml4X2ltYWdlJyBzdHlsZT0nd2lkdGg6I2RoZWlnaHQjcHg7aGVpZ2h0OiNkaGVpZ2h0I3B4O2JhY2tncm91bmQtaW1hZ2U6dXJsKCNpbWFnZSMpOyc+PC9kaXY+I2xhYmVsIzwvYnV0dG9uPlwiLFxuXHQgICAgaW1hZ2VCdXR0b25Ub3A6IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd3ZWJpeF9pbWdfYnRuX2FicyB3ZWJpeF9pbWdfYnRuX2Fic190b3Agd2ViaXh0eXBlX2Jhc2UnPjxkaXYgY2xhc3M9J3dlYml4X2ltYWdlJyBzdHlsZT0nd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWltYWdlOnVybCgjaW1hZ2UjKTsnPjwvZGl2PjxkaXYgY2xhc3M9J3dlYml4X2ltZ19idG5fdGV4dCc+I2xhYmVsIzwvZGl2PjwvYnV0dG9uPlwiLFxuXHQgICAgaW1hZ2U6IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd3ZWJpeF9pbWdfYnRuJyBzdHlsZT0nbGluZS1oZWlnaHQ6I2NoZWlnaHQjcHg7Jz48ZGl2IGNsYXNzPSd3ZWJpeF9pbWFnZScgc3R5bGU9J3dpZHRoOiNjaGVpZ2h0I3B4O2hlaWdodDojY2hlaWdodCNweDtiYWNrZ3JvdW5kLWltYWdlOnVybCgjaW1hZ2UjKTsnPjwvZGl2PiNsYWJlbCM8L2J1dHRvbj5cIixcblx0ICAgIGltYWdlVG9wOiBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nd2ViaXhfaW1nX2J0bl90b3AnPjxkaXYgY2xhc3M9J3dlYml4X2ltYWdlJyBzdHlsZT0nd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWltYWdlOnVybCgjaW1hZ2UjKTsnPjwvZGl2PjxkaXYgY2xhc3M9J3dlYml4X2ltZ19idG5fdGV4dCc+I2xhYmVsIzwvZGl2PjwvYnV0dG9uPlwiLFxuXHQgICAgaWNvbjogXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4X2ltZ19idG4nIHN0eWxlPSdsaW5lLWhlaWdodDojY2hlaWdodCNweDsnPjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uX2J0biAjaWNvbiMnIHN0eWxlPSdtYXgtd2lkdGg6I2NoZWlnaHQjcHg7Jz48L3NwYW4+I2xhYmVsIzwvYnV0dG9uPlwiLFxuXHQgICAgaWNvbkJ1dHRvbjogXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4X2ltZ19idG5fYWJzIHdlYml4dHlwZV9iYXNlJyBzdHlsZT0nd2lkdGg6MTAwJTsnPjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uICNpY29uIyc+PC9zcGFuPiNsYWJlbCM8L2J1dHRvbj5cIixcblx0ICAgIGljb25Ub3A6IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd3ZWJpeF9pbWdfYnRuX3RvcCcgc3R5bGU9J3dpZHRoOjEwMCU7dG9wOjRweDt0ZXh0LWFsaWduOmNlbnRlcjsnPjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uICNpY29uIyc+PC9zcGFuPjxkaXYgY2xhc3M9J3dlYml4X2ltZ19idG5fdGV4dCc+I2xhYmVsIzwvZGl2PjwvYnV0dG9uPlwiLFxuXHQgICAgaWNvbkJ1dHRvblRvcDogXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4X2ltZ19idG5fYWJzIHdlYml4X2ltZ19idG5fYWJzX3RvcCB3ZWJpeHR5cGVfYmFzZScgc3R5bGU9J3dpZHRoOjEwMCU7dG9wOjBweDt0ZXh0LWFsaWduOmNlbnRlcjsnPjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uICNpY29uIyc+PC9zcGFuPjxkaXYgY2xhc3M9J3dlYml4X2ltZ19idG5fdGV4dCc+I2xhYmVsIzwvZGl2PjwvYnV0dG9uPlwiXG5cdCAgfSxcblx0ICBfZmluZEFsbElucHV0czogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgdmFyIHRhZ05hbWVzID0gW1wiaW5wdXRcIiwgXCJzZWxlY3RcIiwgXCJ0ZXh0YXJlYVwiLCBcImJ1dHRvblwiXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWdOYW1lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaW5wdXRzID0gdGhpcy4kdmlldy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lc1tpXSk7XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICByZXN1bHQucHVzaChpbnB1dHNbal0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfSxcblx0ICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaSxcblx0ICAgICAgICBub2RlLFxuXHQgICAgICAgIGVsZW0gPSB0aGlzLl9nZXRCb3goKTtcblxuXHQgICAgYmFzZXZpZXcuYXBpLmRpc2FibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHQgICAgaWYgKGVsZW0gJiYgZWxlbS5jbGFzc05hbWUuaW5kZXhPZihcIiB3ZWJpeF9kaXNhYmxlZF9ib3hcIikgPT0gLTEpIHtcblx0ICAgICAgZWxlbS5jbGFzc05hbWUgKz0gXCIgd2ViaXhfZGlzYWJsZWRfYm94XCI7XG5cblx0ICAgICAgdmFyIGlucHV0cyA9IHRoaXMuX2ZpbmRBbGxJbnB1dHMoKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaW5wdXRzW2ldLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIHRydWUpO1xuXHQgICAgICB9IC8vIHJpY2hzZWxlY3QgYW5kIGJhc2VkIG9uIGl0XG5cblxuXHQgICAgICBub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblxuXHQgICAgICBpZiAobm9kZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImRpdlwiKSB7XG5cdCAgICAgICAgdGhpcy5fZGlzYWJsZWRUYWJJbmRleCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIik7XG5cdCAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5sYWJlbFBvc2l0aW9uID09IFwidG9wXCIpIHtcblx0ICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9kYXRhb2JqLmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgaWYgKGxhYmVsKSBsYWJlbC5jbGFzc05hbWUgKz0gXCIgd2ViaXhfZGlzYWJsZWRfdG9wX2xhYmVsXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgYmFzZXZpZXcuYXBpLmVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdCAgICB2YXIgbm9kZSxcblx0ICAgICAgICBlbGVtID0gdGhpcy5fZ2V0Qm94KCk7XG5cblx0ICAgIGlmIChlbGVtKSB7XG5cdCAgICAgIGVsZW0uY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUucmVwbGFjZShcIiB3ZWJpeF9kaXNhYmxlZF9ib3hcIiwgXCJcIik7XG5cblx0ICAgICAgdmFyIGlucHV0cyA9IHRoaXMuX2ZpbmRBbGxJbnB1dHMoKTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlucHV0c1tpXS5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG5vZGUgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXHQgICAgICBpZiAobm9kZSAmJiAhaXNVbmRlZmluZWQodGhpcy5fZGlzYWJsZWRUYWJJbmRleCkpIG5vZGUuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdGhpcy5fZGlzYWJsZWRUYWJJbmRleCk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmxhYmVsUG9zaXRpb24gPT0gXCJ0b3BcIikge1xuXHQgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX2RhdGFvYmouZmlyc3RDaGlsZDtcblx0ICAgICAgICBpZiAobGFiZWwpIGxhYmVsLmNsYXNzTmFtZSA9IGxhYmVsLmNsYXNzTmFtZS5yZXBsYWNlKFwiIHdlYml4X2Rpc2FibGVkX3RvcF9sYWJlbFwiLCBcIlwiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KSkge1xuXHQgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSB0aGlzLiRwcmVwYXJlVmFsdWUodmFsdWUpO1xuXHQgICAgdmFyIG9sZHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgICBpZiAodGhpcy4kY29tcGFyZVZhbHVlKG9sZHZhbHVlLCB2YWx1ZSkpIHJldHVybiBmYWxzZTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLnZhbHVlID0gdmFsdWU7XG5cdCAgICBpZiAodGhpcy5fcmVuZGVyZWRfaW5wdXQpIHRoaXMuJHNldFZhbHVlKHZhbHVlKTtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25DaGFuZ2VcIiwgW3ZhbHVlLCBvbGR2YWx1ZV0pO1xuXHQgIH0sXG5cdCAgJGNvbXBhcmVWYWx1ZTogZnVuY3Rpb24gKG9sZHZhbHVlLCB2YWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgaWYgKHR5cGVvZiBvbGR2YWx1ZSA9PT0gXCJudW1iZXJcIikgb2xkdmFsdWUgPSBvbGR2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgcmV0dXJuIG9sZHZhbHVlID09IHZhbHVlO1xuXHQgIH0sXG5cdCAgJHByZXBhcmVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcGF0dGVybih2YWx1ZSwgZmFsc2UpO1xuXHQgIH0sXG5cdCAgX3BhdHRlcm46IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSAwID8gXCIwXCIgOiAodmFsdWUgfHwgXCJcIikudG9TdHJpbmcoKTtcblx0ICB9LFxuXHQgIC8vdmlzdWFsIHBhcnQgb2Ygc2V0VmFsdWVcblx0ICAkc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgLy9cdFx0dGhpcy5fc2V0dGluZ3MubGFiZWwgPSB2YWx1ZTtcblx0ICAgIHZhciBub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblxuXHQgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PSBcIkJVVFRPTlwiKSBub2RlLmlubmVySFRNTCA9IHZhbHVlO2Vsc2Ugbm9kZS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vaWYgYnV0dG9uIHdhcyByZW5kZXJlZCAtIHJldHVybmluZyBhY3R1YWwgdmFsdWVcblx0ICAgIC8vb3RoZXJ3aXNlIC0gcmV0dXJuaW5nIGxhc3Qgc2V0IHZhbHVlXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZW5kZXJlZF9pbnB1dCA/IHRoaXMuJGdldFZhbHVlKCkgOiB0aGlzLl9zZXR0aW5ncy52YWx1ZTtcblx0ICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJ1bmRlZmluZWRcIiA/IFwiXCIgOiB2YWx1ZTtcblx0ICB9LFxuXHQgICRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnZhbHVlIHx8IFwiXCI7XG5cdCAgfSxcblx0ICBmb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFVSU1hbmFnZXIuY2FuRm9jdXModGhpcykpIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZm9jdXMpIGlucHV0LmZvY3VzKCk7XG5cdCAgfSxcblx0ICBibHVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaW5wdXQgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXHQgICAgaWYgKGlucHV0ICYmIGlucHV0LmJsdXIpIGlucHV0LmJsdXIoKTtcblx0ICB9LFxuXHQgIC8vZ2V0IGlucHV0IGVsZW1lbnRcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF0gfHwgdGhpcy5fZGF0YW9iai5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJ1dHRvblwiKVswXTtcblx0ICB9LFxuXHQgIC8vZ2V0IHRvcC1sZXZlbCBzdWItY29udGFpbmVyXG5cdCAgX2dldEJveDogZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kYXRhb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuX2RhdGFvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZihcIndlYml4X2VsX2JveFwiKSA+PSAwKSByZXR1cm4gdGhpcy5fZGF0YW9iai5jaGlsZE5vZGVzW2ldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIF9nZXRfdG9vbHRpcF9kYXRhOiBmdW5jdGlvbiAodCwgZSkge1xuXHQgICAgdmFyIG5vZGUgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cblx0ICAgIHZhciBib3ggPSB0aGlzLl9nZXRCb3goKTtcblxuXHQgICAgaWYgKGJveCAmJiBib3guY29udGFpbnMobm9kZSkpIHJldHVybiB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgX3NxcnRfMjogTWF0aC5zcXJ0KDIpLFxuXHQgIF9zZXRfaW5uZXJfc2l6ZV9uZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY2ZnID0gdGhpcy5fc2V0dGluZ3M7XG5cblx0ICAgIHZhciBhcnJvdyA9IHRoaXMuX2dldEJveCgpLmNoaWxkTm9kZXNbMV07XG5cblx0ICAgIHZhciBidXR0b24gPSBhcnJvdy5wcmV2aW91c1NpYmxpbmc7XG5cdCAgICB2YXIgc3R5bGUgPSBjZmcudHlwZSA9PSBcIm5leHRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuXHQgICAgdmFyIGhlaWdodCA9IGNmZy5haGVpZ2h0IC0gJGFjdGl2ZS5pbnB1dFBhZGRpbmcgKiAyIC0gMiAqIHRoaXMuX2JvcmRlcldpZHRoOyAvLy0yIC0gYm9yZGVyc1xuXG5cdCAgICB2YXIgYXJyb3dFZGdlID0gaGVpZ2h0ICogdGhpcy5fc3FydF8yIC8gMjtcblx0ICAgIGFycm93LnN0eWxlLndpZHRoID0gYXJyb3dFZGdlICsgXCJweFwiO1xuXHQgICAgYXJyb3cuc3R5bGUuaGVpZ2h0ID0gYXJyb3dFZGdlICsgXCJweFwiO1xuXHQgICAgYXJyb3cuc3R5bGUudG9wID0gKGhlaWdodCAtIGFycm93RWRnZSkgLyAyICsgJGFjdGl2ZS5pbnB1dFBhZGRpbmcgKyBcInB4XCI7XG5cdCAgICBhcnJvdy5zdHlsZVtzdHlsZV0gPSAoaGVpZ2h0IC0gYXJyb3dFZGdlKSAvIDIgKyB0aGlzLl9zcXJ0XzIgLyAyICsgXCJweFwiO1xuXHQgICAgYnV0dG9uLnN0eWxlLndpZHRoID0gY2ZnLmF3aWR0aCAtIGhlaWdodCAvIDIgLSAyICsgXCJweFwiO1xuXHQgICAgYnV0dG9uLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIDIgKyBcInB4XCI7XG5cdCAgICBidXR0b24uc3R5bGVbc3R5bGVdID0gaGVpZ2h0IC8gMiArIDIgKyBcInB4XCI7XG5cdCAgICBidXR0b24uc3R5bGUudG9wID0gJGFjdGl2ZS5pbnB1dFBhZGRpbmcgKyBcInB4XCI7XG5cdCAgfSxcblx0ICBfY2FsY19zaXplOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBjb25maWcgPSBjb25maWcgfHwgdGhpcy5fc2V0dGluZ3M7XG5cdCAgICBpZiAoY29uZmlnLmF1dG93aWR0aCkgY29uZmlnLndpZHRoID0gZ2V0VGV4dFNpemUoY29uZmlnLnZhbHVlIHx8IGNvbmZpZy5sYWJlbCB8fCBcIlwiLCBcIndlYml4YnV0dG9uXCIpLndpZHRoICsgKGNvbmZpZy5iYWRnZSA/IDE2IDogMCkgKyAoY29uZmlnLnR5cGUgPT09IFwiaWNvbkJ1dHRvblwiIHx8IGNvbmZpZy50eXBlID09PSBcImljb25cIiA/IDI0IDogMCkgKyAoY29uZmlnLnR5cGUgPT09IFwiaW1hZ2VCdXR0b25cIiB8fCBjb25maWcudHlwZSA9PT0gXCJpbWFnZVwiID8gY29uZmlnLmhlaWdodCAtICRhY3RpdmUuaW5wdXRQYWRkaW5nIDogMCk7XG5cdCAgfSxcblx0ICBfY2FsY2tfaW5wdXRfc2l6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgLy91c2Ugd2lkdGggZm9yIGJvdGggd2lkdGggYW5kIGlucHV0V2lkdGggc2V0dGluZ3MgaW4gY2xldmVyIHdheVxuXHQgICAgLy9pbiBmb3JtLCB3ZSBjYW4gZGVmaW5lIHdpZHRoIGZvciBzb21lIGVsZW1lbnQgc21hbGxlciB0aGFuIGZvciBzaWJsaW5nc1xuXHQgICAgLy9pdCB3aWxsIHVzZSBpbnB1dFdpZHRoIHRvIHJlbmRlciB0aGUgZGVzaXJlZCB2aWV3XG5cdCAgICB0aGlzLl9pbnB1dF93aWR0aCA9IHRoaXMuX3NldHRpbmdzLmlucHV0V2lkdGggfHwgKHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl9zZXR0aW5ncy53aWR0aCA+IDIgPyB0aGlzLl9zZXR0aW5ncy53aWR0aCA6IDApIHx8IHRoaXMuX2NvbnRlbnRfd2lkdGg7XG5cdCAgICB0aGlzLl9pbnB1dF9oZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5pbnB1dEhlaWdodCB8fCB0aGlzLl9pbnB1dEhlaWdodCB8fCAwO1xuXHQgIH0sXG5cdCAgcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9jYWxjX3NpemUoKTtcblxuXHQgICAgcmV0dXJuIGJhc2UuYXBpLnJlc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9jYWxja19pbnB1dF9zaXplKCk7XG5cblx0ICAgIHRoaXMuX3NldHRpbmdzLmF3aWR0aCA9IHRoaXMuX2lucHV0X3dpZHRoIHx8IHRoaXMuX2NvbnRlbnRfd2lkdGg7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy5haGVpZ2h0ID0gdGhpcy5faW5wdXRfaGVpZ2h0IHx8IHRoaXMuX2NvbnRlbnRfaGVpZ2h0OyAvL2ltYWdlIGJ1dHRvbiAtIGltYWdlIHdpZHRoXG5cblx0ICAgIHRoaXMuX3NldHRpbmdzLmJoZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5haGVpZ2h0ICsgMjtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmNoZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5haGVpZ2h0IC0gMiAqICRhY3RpdmUuaW5wdXRQYWRkaW5nO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuZGhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmNoZWlnaHQgLSAyOyAvLyAtIGJvcmRlcnNcblxuXHQgICAgaWYgKEF0b21SZW5kZXIucmVuZGVyLmNhbGwodGhpcykpIHtcblx0ICAgICAgdGhpcy5fcmVuZGVyZWRfaW5wdXQgPSB0cnVlO1xuXHQgICAgICBpZiAodGhpcy5fc2V0X2lubmVyX3NpemUpIHRoaXMuX3NldF9pbm5lcl9zaXplKCk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmFsaWduKSB7XG5cdCAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuX2RhdGFvYmouZmlyc3RDaGlsZDtcblx0ICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubGFiZWxQb3NpdGlvbiA9PSBcInRvcFwiICYmIGhhbmRsZS5uZXh0U2libGluZykgaGFuZGxlID0gaGFuZGxlLm5leHRTaWJsaW5nO1xuXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy5hbGlnbikge1xuXHQgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG5cdCAgICAgICAgICAgIGhhbmRsZS5zdHlsZS5jc3NGbG9hdCA9IFwicmlnaHRcIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcblx0ICAgICAgICAgICAgaGFuZGxlLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHQgICAgICAgICAgICBoYW5kbGUucGFyZW50Tm9kZS5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuXHQgICAgICAgICAgICBoYW5kbGUuc3R5bGUubWFyZ2luVG9wID0gTWF0aC5yb3VuZCgodGhpcy5fY29udGVudF9oZWlnaHQgLSB0aGlzLl9pbnB1dF9oZWlnaHQpIC8gMikgKyBcInB4XCI7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG5cdCAgICAgICAgICAgIGhhbmRsZS5zdHlsZS5tYXJnaW5Ub3AgPSB0aGlzLl9jb250ZW50X2hlaWdodCAtIHRoaXMuX2lucHV0X2hlaWdodCArIFwicHhcIjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG5cdCAgICAgICAgICAgIGhhbmRsZS5zdHlsZS5jc3NGbG9hdCA9IFwibGVmdFwiO1xuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gYWxpZ24gbW9kZTogXCIgKyB0aGlzLl9zZXR0aW5ncy5hbGlnbik7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLiRyZW5kZXIpIHRoaXMuJHJlbmRlcih0aGlzLmRhdGEpO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuZGlzYWJsZWQpIHRoaXMuZGlzYWJsZSgpO1xuXG5cdCAgICAgIGlmICh0aGlzLl9pbml0X29uY2UpIHtcblx0ICAgICAgICB0aGlzLl9pbml0X29uY2UodGhpcy5kYXRhKTtcblxuXHQgICAgICAgIHRoaXMuX2luaXRfb25jZSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgfSxcblx0ICBvbl9jbGljazoge1xuXHQgICAgX2hhbmRsZV90YWJfY2xpY2s6IGZ1bmN0aW9uIChldikge1xuXHQgICAgICB2YXIgaWQgPSBsb2NhdGUoZXYsIFwiYnV0dG9uX2lkXCIpO1xuXG5cdCAgICAgIGlmIChpZCAmJiB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlVGFiQ2xpY2tcIiwgW2lkLCBldl0pKSB7XG5cdCAgICAgICAgdGhpcy5zZXRWYWx1ZShpZCk7XG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyVGFiQ2xpY2tcIiwgW2lkLCBldl0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfYWxsX3NlZ21lbnRzOiBmdW5jdGlvbiAoZXYsIGJ1dHRvbikge1xuXHQgICAgICB0aGlzLm9uX2NsaWNrLl9oYW5kbGVfdGFiX2NsaWNrLmNhbGwodGhpcywgZXYsIGJ1dHRvbik7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfYWxsX3RhYnM6IGZ1bmN0aW9uIChldiwgYnV0dG9uKSB7XG5cdCAgICAgIHRoaXMub25fY2xpY2suX2hhbmRsZV90YWJfY2xpY2suY2FsbCh0aGlzLCBldiwgYnV0dG9uKTtcblx0ICAgIH0sXG5cdCAgICB3ZWJpeF9pbnBfY291bnRlcl9uZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MucmVhZG9ubHkpIHRoaXMubmV4dCgpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2lucF9jb3VudGVyX3ByZXY6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5yZWFkb25seSkgdGhpcy5wcmV2KCk7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfaW5wdXRfaWNvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmdldElucHV0Tm9kZSgpLmZvY3VzKCk7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfaW5wX2NoZWNrYm94X2JvcmRlcjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5kaXNhYmxlZCAmJiAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KS50YWdOYW1lICE9IFwiRElWXCIgJiYgIXRoaXMuX3NldHRpbmdzLnJlYWRvbmx5KSB0aGlzLnRvZ2dsZSgpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2lucF9jaGVja2JveF9sYWJlbDogZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnJlYWRvbmx5KSB0aGlzLnRvZ2dsZSgpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2lucF9yYWRpb19ib3JkZXI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGxvY2F0ZShlLCBcInJhZGlvX2lkXCIpO1xuXHQgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcblx0ICAgICAgdGhpcy5mb2N1cygpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X2lucF9yYWRpb19sYWJlbDogZnVuY3Rpb24gKGUsIG9iaiwgbm9kZSkge1xuXHQgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG5cdCAgICAgIHJldHVybiB0aGlzLm9uX2NsaWNrLndlYml4X2lucF9yYWRpb19ib3JkZXIuY2FsbCh0aGlzLCBub2RlLCBvYmosIG5vZGUpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X3RhYl9tb3JlX2ljb246IGZ1bmN0aW9uIChldiwgb2JqLCBub2RlKSB7XG5cdCAgICAgIHRoaXMuZ2V0UG9wdXAoKS5yZXNpemUoKTtcblx0ICAgICAgdGhpcy5nZXRQb3B1cCgpLnNob3cobm9kZSwgbnVsbCwgdHJ1ZSk7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfdGFiX2Nsb3NlOiBmdW5jdGlvbiAoZXYpIHtcblx0ICAgICAgdmFyIGlkID0gbG9jYXRlKGV2LCBcImJ1dHRvbl9pZFwiKTtcblx0ICAgICAgaWYgKGlkICYmIHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVUYWJDbG9zZVwiLCBbaWQsIGV2XSkpIHRoaXMucmVtb3ZlT3B0aW9uKGlkKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vbWV0aG9kIGRvIG5vdCB1c2VkIGJ5IGJ1dHRvbiwgYnV0ICB1c2VkIGJ5IG90aGVyIGNoaWxkLXZpZXdzXG5cdCAgX2NoZWNrX29wdGlvbnM6IGZ1bmN0aW9uIChvcHRzKSB7XG5cdCAgICBhc3NlcnQob3B0cywgdGhpcy5uYW1lICsgXCI6IG9wdGlvbnMgbm90IGRlZmluZWRcIik7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvLyBhc3NlcnRzIG5lZWQgdG8gYmUgcmVtb3ZlZCBpbiBmaW5hbCB2ZXJzaW9uXHRcdFx0XG5cdCAgICAgIGFzc2VydCghb3B0c1tpXS50ZXh0LCBcIlBsZWFzZSByZXBsYWNlIC50ZXh0IHdpdGggLnZhbHVlIGluIGNvbnRyb2wgY29uZmlnXCIpO1xuXHQgICAgICBhc3NlcnQoIW9wdHNbaV0ubGFiZWwsIFwiUGxlYXNlIHJlcGxhY2UgLmxhYmVsIHdpdGggLnZhbHVlIGluIGNvbnRyb2wgY29uZmlnXCIpO1xuXG5cdCAgICAgIGlmICh0eXBlb2Ygb3B0c1tpXSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgb3B0c1tpXSA9IHtcblx0ICAgICAgICAgIGlkOiBvcHRzW2ldLFxuXHQgICAgICAgICAgdmFsdWU6IG9wdHNbaV1cblx0ICAgICAgICB9O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChpc1VuZGVmaW5lZChvcHRzW2ldLmlkKSkgb3B0c1tpXS5pZCA9IG9wdHNbaV0udmFsdWU7XG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG9wdHNbaV0udmFsdWUpKSBvcHRzW2ldLnZhbHVlID0gb3B0c1tpXS5pZDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3B0cztcblx0ICB9LFxuXHQgIF9nZXRfZGl2X3BsYWNlaG9sZGVyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgcGxhY2Vob2xkZXIgPSBvYmogPyBvYmoucGxhY2Vob2xkZXIgOiB0aGlzLl9zZXR0aW5ncy5wbGFjZWhvbGRlcjtcblx0ICAgIHJldHVybiBwbGFjZWhvbGRlciA/IFwiPHNwYW4gY2xhc3M9J3dlYml4X3BsYWNlaG9sZGVyJz5cIiArIHBsYWNlaG9sZGVyICsgXCI8L3NwYW4+XCIgOiBcIlwiO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckdSA9IGV4cG9ydHMucHJvdG9VSShhcGkkdSwgYmFzZS52aWV3LCBBdXRvVG9vbHRpcCwgQXRvbVJlbmRlciwgU2V0dGluZ3MsIEV2ZW50U3lzdGVtKTtcblx0dmFyIGJ1dHRvbiQxID0ge1xuXHQgIGFwaTogYXBpJHUsXG5cdCAgdmlldzogdmlldyR1XG5cdH07XG5cblx0dmFyIGFwaSR2ID0ge1xuXHQgIG5hbWU6IFwibGFiZWxcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nd2ViaXhfZWxfYm94JyBzdHlsZT0nd2lkdGg6I2F3aWR0aCNweDtoZWlnaHQ6I2FoZWlnaHQjcHg7bGluZS1oZWlnaHQ6I2NoZWlnaHQjcHgnPiNsYWJlbCM8L2Rpdj5cIlxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmYXVsdHMuaGVpZ2h0ID0gJGFjdGl2ZS5pbnB1dEhlaWdodDtcblx0ICB9LFxuXHQgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBfZ2V0Qm94OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGF0YW9iai5maXJzdENoaWxkO1xuXHQgIH0sXG5cdCAgc2V0SFRNTDogZnVuY3Rpb24gKGh0bWwpIHtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmxhYmVsID0gaHRtbDtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5fc2V0dGluZ3MubGFiZWwgPSB2YWx1ZTtcblx0ICAgIGJ1dHRvbiQxLmFwaS5zZXRWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX2RhdGFvYmouZmlyc3RDaGlsZC5pbm5lckhUTUwgPSB2YWx1ZTtcblx0ICB9LFxuXHQgIF9zZXRfaW5uZXJfc2l6ZTogZnVuY3Rpb24gKCkge30sXG5cdCAgX2NhbGNfc2l6ZTogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgY29uZmlnID0gY29uZmlnIHx8IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgaWYgKGNvbmZpZy5hdXRvd2lkdGgpIGNvbmZpZy53aWR0aCA9IGdldFRleHRTaXplKGNvbmZpZy52YWx1ZSB8fCBjb25maWcubGFiZWwsIFwid2ViaXhfZWxfbGFiZWxcIikud2lkdGg7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyR2ID0gZXhwb3J0cy5wcm90b1VJKGFwaSR2LCBidXR0b24kMS52aWV3KTtcblxuXHR2YXIgY29udHJvbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpIGluIFVJTWFuYWdlci5fY29udHJvbHMpIHtcblx0ICBjb250cm9sc1tVSU1hbmFnZXIuX2NvbnRyb2xzW2ldXSA9IGk7XG5cdH1cblxuXHR2YXIgbmF2X2NvbnRyb2xzID0ge1xuXHQgIDk6IFwidGFiXCIsXG5cdCAgMzg6IFwidXBcIixcblx0ICA0MDogXCJkb3duXCIsXG5cdCAgMzc6IFwibGVmdFwiLFxuXHQgIDM5OiBcInJpZ2h0XCJcblx0fTtcblx0dmFyIFRleHRQYXR0ZXJuID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB2YXIgcGF0dGVybiA9IHRoaXMuZGVmYXVsdHMucGF0dGVybiB8fCBjb25maWcucGF0dGVybjtcblx0ICAgIHZhciBmb3JtYXQgPSB0aGlzLmRlZmF1bHRzLmZvcm1hdCB8fCBjb25maWcuZm9ybWF0O1xuXHQgICAgY29uZmlnLnZhbHVlID0gaXNVbmRlZmluZWQoY29uZmlnLnZhbHVlKSA/IFwiXCIgOiBjb25maWcudmFsdWU7XG5cblx0ICAgIGlmIChwYXR0ZXJuIHx8IGZvcm1hdCAmJiAhdGhpcy5mb3JtYXRfc2V0dGVyKSB7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbktleVByZXNzXCIsIGZ1bmN0aW9uIChjb2RlLCBlKSB7XG5cdCAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCB0aGlzLl9jdXN0b21fZm9ybWF0KSByZXR1cm47XG5cdCAgICAgICAgaWYgKGNvZGUgPiAxMDUgJiYgY29kZSA8IDExMikgLy9udW1wYWQgb3BlcmF0b3JzXG5cdCAgICAgICAgICBjb2RlIC09IDY0O1xuXG5cdCAgICAgICAgaWYgKGNvbnRyb2xzW2NvZGVdICYmIGNvZGUgIT09IDggJiYgY29kZSAhPT0gNDYpIHtcblx0ICAgICAgICAgIC8vZGVsICYmIGJzcFxuXHQgICAgICAgICAgaWYgKCFuYXZfY29udHJvbHNbY29kZV0pIHByZXZlbnRFdmVudChlKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwcmV2ZW50RXZlbnQoZSk7XG5cblx0ICAgICAgICB0aGlzLl9vbl9rZXlfcHJlc3NlZChlLCBjb2RlKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIHRoaXMuX2FmdGVyX3JlbmRlcik7XG5cblx0ICAgICAgdGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIHRoaXMuX3BhdHRlcm4gPSBmdW5jdGlvbiAodmFsdWUsIG1vZGUpIHtcblx0ICAgICAgICBpZiAobW9kZSA9PT0gZmFsc2UpIHJldHVybiB0aGlzLl9nZXRSYXdWYWx1ZSh2YWx1ZSk7ZWxzZSByZXR1cm4gdGhpcy5fbWF0Y2hQYXR0ZXJuKHZhbHVlKTtcblx0ICAgICAgfTtcblxuXHQgICAgICBpZiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKF90eXBlb2YoZm9ybWF0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgdGhpcy5fY3VzdG9tX2Zvcm1hdCA9IGZvcm1hdDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZm9ybWF0ID0gTnVtYmVyJDEuZ2V0Q29uZmlnKGZvcm1hdCk7XG5cdCAgICAgICAgICB0aGlzLl9jdXN0b21fZm9ybWF0ID0ge1xuXHQgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIE51bWJlciQxLnBhcnNlKHZhbHVlLCBmb3JtYXQpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBlZGl0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyJDEuZm9ybWF0KHZhbHVlLCBmb3JtYXQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgcGF0dGVybl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1t2YWx1ZV0gfHwgdmFsdWU7XG5cdCAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikgcGF0dGVybiA9IHtcblx0ICAgICAgbWFzazogcGF0dGVyblxuXHQgICAgfTtcblx0ICAgIHBhdHRlcm4uYWxsb3cgPSBwYXR0ZXJuLmFsbG93IHx8IC9bQS1aYS16MC05XS9nO1xuXG5cdCAgICB0aGlzLl9wYXR0ZXJuU2NoZW1lKHBhdHRlcm4pO1xuXG5cdCAgICByZXR1cm4gcGF0dGVybjtcblx0ICB9LFxuXHQgIF9pbml0X3ZhbGlkYXRpb246IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuY29uZmlnLnZhbGlkYXRlID0gdGhpcy5jb25maWcudmFsaWRhdGUgfHwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuXHQgICAgICB2YXIgcmF3ID0gdmFsdWUucmVwbGFjZSh0aGlzLl9wYXR0ZXJuX2NoYXJzLCBcIlwiKTtcblx0ICAgICAgdmFyIG1hdGNoZXMgPSAodmFsdWUudG9TdHJpbmcoKS5tYXRjaCh0aGlzLl9wYXR0ZXJuX2FsbG93cykgfHwgW10pLmpvaW4oXCJcIik7XG5cdCAgICAgIHJldHVybiBtYXRjaGVzLmxlbmd0aCA9PSByYXcubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA9PSB0aGlzLl9zZXR0aW5ncy5wYXR0ZXJuLm1hc2subGVuZ3RoO1xuXHQgICAgfSwgdGhpcyk7XG5cdCAgfSxcblx0ICBfYWZ0ZXJfcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXYgPSBlbnYuaXNJRTggPyBcInByb3BlcnR5Y2hhbmdlXCIgOiBcImlucHV0XCI7XG5cdCAgICBpZiAoIXRoaXMuX2N1c3RvbV9mb3JtYXQpIF9ldmVudCh0aGlzLmdldElucHV0Tm9kZSgpLCBldiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgc3RhbXAgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTsgLy9kYXJrIGllOCBtYWdpY1xuXG5cdCAgICAgIHZhciB3aWR0aCA9IHRoaXMuJHZpZXcub2Zmc2V0V2lkdGg7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5cdCAgICAgIGlmICghdGhpcy5fcHJvcGVydHlfc3RhbXAgfHwgc3RhbXAgLSB0aGlzLl9wcm9wZXJ0eV9zdGFtcCA+IDEwMCkge1xuXHQgICAgICAgIHRoaXMuX3Byb3BlcnR5X3N0YW1wID0gc3RhbXA7XG5cdCAgICAgICAgdGhpcy4kc2V0VmFsdWUodGhpcy5nZXRUZXh0KCkpO1xuXHQgICAgICB9XG5cdCAgICB9LCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXG5cdCAgICBfZXZlbnQodGhpcy5nZXRJbnB1dE5vZGUoKSwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XG5cdCAgICB9LCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgX3BhdHRlcm5TY2hlbWU6IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG5cdCAgICB2YXIgbWFzayA9IHBhdHRlcm4ubWFzayxcblx0ICAgICAgICBzY2hlbWUgPSB7fSxcblx0ICAgICAgICBjaGFycyA9IFwiXCIsXG5cdCAgICAgICAgY291bnQgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hc2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKG1hc2tbaV0gPT09IFwiI1wiKSB7XG5cdCAgICAgICAgc2NoZW1lW2ldID0gY291bnQ7XG5cdCAgICAgICAgY291bnQrKztcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzY2hlbWVbaV0gPSBmYWxzZTtcblx0ICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihtYXNrW2ldKSA9PT0gLTEpIGNoYXJzICs9IFwiXFxcXFwiICsgbWFza1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9wYXR0ZXJuX2FsbG93cyA9IHBhdHRlcm4uYWxsb3c7XG5cdCAgICB0aGlzLl9wYXR0ZXJuX2NoYXJzID0gbmV3IFJlZ0V4cChcIltcIiArIGNoYXJzICsgXCJdXCIsIFwiZ1wiKTtcblx0ICAgIHRoaXMuX3BhdHRlcm5fc2NoZW1lID0gc2NoZW1lO1xuXG5cdCAgICB0aGlzLl9pbml0X3ZhbGlkYXRpb24oKTtcblx0ICB9LFxuXHQgIF9vbl9rZXlfcHJlc3NlZDogZnVuY3Rpb24gKGUsIGNvZGUpIHtcblx0ICAgIHZhciBub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblx0ICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG5cdCAgICB2YXIgcG9zJCQxID0gZ2V0U2VsZWN0aW9uUmFuZ2Uobm9kZSk7XG5cdCAgICB2YXIgY2hyID0gXCJcIjtcblxuXHQgICAgaWYgKGNvZGUgPT0gOCB8fCBjb2RlID09IDQ2KSB7XG5cdCAgICAgIGlmIChwb3MkJDEuc3RhcnQgPT0gcG9zJCQxLmVuZCkge1xuXHQgICAgICAgIGlmIChjb2RlID09IDgpIHBvcyQkMS5zdGFydC0tO2Vsc2UgcG9zJCQxLmVuZCsrO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHQgICAgICBpZiAoIWUuc2hpZnRLZXkpIGNociA9IGNoci50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXG5cdCAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBwb3MkJDEuc3RhcnQpICsgY2hyICsgdmFsdWUuc3Vic3RyKHBvcyQkMS5lbmQpO1xuXHQgICAgcG9zJCQxID0gdGhpcy5fZ2V0Q2FyZXRQb3MoY2hyLCB2YWx1ZS5sZW5ndGgsIHBvcyQkMS5zdGFydCwgY29kZSk7XG5cdCAgICB0aGlzLl9pbnB1dF9jb2RlID0gY29kZTtcblx0ICAgIHRoaXMuJHNldFZhbHVlKHZhbHVlKTtcblx0ICAgIHNldFNlbGVjdGlvblJhbmdlKG5vZGUsIHBvcyQkMSk7XG5cdCAgfSxcblx0ICBfZ2V0Q2FyZXRQb3M6IGZ1bmN0aW9uIChjaHIsIGxlbiwgcG9zJCQxLCBjb2RlKSB7XG5cdCAgICBpZiAoY2hyICYmIGNoci5tYXRjaCh0aGlzLl9wYXR0ZXJuX2FsbG93cykgfHwgY29kZSA9PSA4IHx8IGNvZGUgPT0gNDYpIHtcblx0ICAgICAgcG9zJCQxID0gY2hyID8gcG9zJCQxICsgMSA6IHBvcyQkMTtcblx0ICAgICAgcG9zJCQxID0gdGhpcy5fZml4Q2FyZXRQb3MocG9zJCQxLCBjb2RlKTtcblx0ICAgIH0gZWxzZSBpZiAobGVuIC0gMSA9PSBwb3MkJDEgJiYgY29kZSAhPT0gOCAmJiBjb2RlICE9PSA0Nikge1xuXHQgICAgICB2YXIgcmVzdCA9IHRoaXMuX3NldHRpbmdzLnBhdHRlcm4ubWFzay5pbmRleE9mKFwiI1wiLCBwb3MkJDEpO1xuXG5cdCAgICAgIGlmIChyZXN0ID4gMCkgcG9zJCQxICs9IHJlc3Q7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwb3MkJDE7XG5cdCAgfSxcblx0ICBfZml4Q2FyZXRQb3M6IGZ1bmN0aW9uIChwb3MkJDEsIGNvZGUpIHtcblx0ICAgIHZhciBwcmV2ID0gcG9zJCQxIC0gKGNvZGUgIT09IDQ2KSAqIDE7XG5cblx0ICAgIGlmICh0aGlzLl9wYXR0ZXJuX3NjaGVtZVtwcmV2XSA9PT0gZmFsc2UpIHtcblx0ICAgICAgcG9zJCQxID0gcG9zJCQxICsgKGNvZGUgPT0gOCA/IC0xIDogMSk7XG5cdCAgICAgIHJldHVybiB0aGlzLl9maXhDYXJldFBvcyhwb3MkJDEsIGNvZGUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fcGF0dGVybl9zY2hlbWVbcG9zJCQxXSA9PT0gZmFsc2UgJiYgY29kZSAhPT0gOCkgcmV0dXJuIHRoaXMuX2ZpeENhcmV0UG9zKHBvcyQkMSArIDEsIGNvZGUpIC0gMTtcblx0ICAgIHJldHVybiBwb3MkJDE7XG5cdCAgfSxcblx0ICBfZ2V0UmF3VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHRoaXMuX2N1c3RvbV9mb3JtYXQpIHJldHVybiB0aGlzLl9jdXN0b21fZm9ybWF0LnBhcnNlKHZhbHVlKTtcblx0ICAgIHZhbHVlID0gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZSA6IFwiXCI7XG5cdCAgICB2YXIgbWF0Y2hlcyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2godGhpcy5fcGF0dGVybl9hbGxvd3MpIHx8IFtdO1xuXHQgICAgcmV0dXJuIG1hdGNoZXMuam9pbihcIlwiKS5yZXBsYWNlKHRoaXMuX3BhdHRlcm5fY2hhcnMsIFwiXCIpO1xuXHQgIH0sXG5cdCAgX21hdGNoUGF0dGVybjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fY3VzdG9tX2Zvcm1hdCkgcmV0dXJuIHRoaXMuX2N1c3RvbV9mb3JtYXQuZWRpdCh0aGlzLl9jdXN0b21fZm9ybWF0LnBhcnNlKHZhbHVlKSk7XG5cblx0ICAgIHZhciByYXcgPSB0aGlzLl9nZXRSYXdWYWx1ZSh2YWx1ZSksXG5cdCAgICAgICAgcGF0dGVybiA9IHRoaXMuX3NldHRpbmdzLnBhdHRlcm4ubWFzayxcblx0ICAgICAgICBtYXNrID0gdGhpcy5fc2V0dGluZ3MucGF0dGVybi5tYXNrLFxuXHQgICAgICAgIHNjaGVtZSA9IHRoaXMuX3BhdHRlcm5fc2NoZW1lLFxuXHQgICAgICAgIGVuZCA9IGZhbHNlLFxuXHQgICAgICAgIGluZGV4JCQxID0gMCxcblx0ICAgICAgICByYXdJbmRleCA9IDAsXG5cdCAgICAgICAgcmF3TGVuZ3RoID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSBpbiBzY2hlbWUpIHtcblx0ICAgICAgaWYgKHNjaGVtZVtpXSAhPT0gZmFsc2UpIHtcblx0ICAgICAgICBpZiAoIWVuZCkge1xuXHQgICAgICAgICAgaW5kZXgkJDEgPSBpICogMTtcblx0ICAgICAgICAgIHJhd0luZGV4ID0gc2NoZW1lW2ldO1xuXHQgICAgICAgICAgdmFyIHJjaGFyID0gcmF3W3Jhd0luZGV4XSB8fCBcIlwiO1xuXHQgICAgICAgICAgdmFyIG5leHQgPSByYXdbcmF3SW5kZXggKyAxXTtcblx0ICAgICAgICAgIHBhdHRlcm4gPSAocmNoYXIgPyBwYXR0ZXJuLnN1YnN0cigwLCBpbmRleCQkMSkgOiBcIlwiKSArIHJjaGFyICsgKHJjaGFyICYmIG5leHQgPyBwYXR0ZXJuLnN1YnN0cihpbmRleCQkMSArIDEpIDogXCJcIik7XG5cdCAgICAgICAgICBpZiAoIW5leHQpIGVuZCA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmF3TGVuZ3RoKys7XG5cdCAgICAgIH1cblx0ICAgIH0gLy9maW5hbGl6ZSB2YWx1ZSB3aXRoIHN1YnNlcXVlbnQgbWFzayBjaGFycyBcblxuXG5cdCAgICB2YXIgaWNvZGUgPSB0aGlzLl9pbnB1dF9jb2RlO1xuXG5cdCAgICBpZiAoaWNvZGUgJiYgaWNvZGUgIT09IDggfHwgIWljb2RlICYmIHJhd0xlbmd0aCAtIDEgPT09IHJhd0luZGV4ICYmIHBhdHRlcm4ubGVuZ3RoIDwgbWFzay5sZW5ndGgpIHtcblx0ICAgICAgaWYgKHJhdykge1xuXHQgICAgICAgIHZhciBuaW5kID0gaW5kZXgkJDEgKyAxO1xuXG5cdCAgICAgICAgaWYgKG1hc2suY2hhckF0KG5pbmQpICE9PSBcIiNcIiAmJiBwYXR0ZXJuLmxlbmd0aCA8IG1hc2subGVuZ3RoKSB7XG5cdCAgICAgICAgICB2YXIgbGluZCA9IG1hc2suaW5kZXhPZihcIiNcIiwgbmluZCk7XG5cdCAgICAgICAgICBpZiAobGluZCA8IDApIGxpbmQgPSBtYXNrLmxlbmd0aDtcblx0ICAgICAgICAgIHBhdHRlcm4gKz0gbWFzay5zdWJzdHIobmluZCwgbGluZCAtIG5pbmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChpY29kZSAhPT0gNDYpIHtcblx0ICAgICAgICBwYXR0ZXJuICs9IG1hc2suc3Vic3RyKDAsIG1hc2suaW5kZXhPZihcIiNcIikpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lucHV0X2NvZGUgPSBudWxsO1xuXHQgICAgcmV0dXJuIHBhdHRlcm47XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBhcGkkdyA9IHtcblx0ICBuYW1lOiBcInRleHRcIixcblx0ICAkYWxsb3dzQ2xlYXI6IHRydWUsXG5cdCAgX2luaXRfb25jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLiRhbGxvd3NDbGVhcikge1xuXHQgICAgICAvL2F0dGFjaCBvbkNoYW5nZSBoYW5kbGVyIG9ubHkgZm9yIGNvbnRyb2xzIHdoaWNoIGRvIG5vdCBtYW5hZ2UgYmx1ciBvbiB0aGVpciBvd25cblx0ICAgICAgLy9mb3IgZXhhbXBsZSAtIGNvbWJvXG5cdCAgICAgIGlmICghdGhpcy5fb25CbHVyKSBfZXZlbnQodGhpcy5nZXRJbnB1dE5vZGUoKSwgXCJjaGFuZ2VcIiwgdGhpcy5fYXBwbHlDaGFuZ2VzLCB7XG5cdCAgICAgICAgYmluZDogdGhpc1xuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnN1Z2dlc3QpICQkKHRoaXMuX3NldHRpbmdzLnN1Z2dlc3QpLmxpbmtJbnB1dCh0aGlzKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9hcHBseUNoYW5nZXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBuZXd2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0ICAgIHZhciByZXMgPSB0aGlzLnNldFZhbHVlKG5ld3ZhbHVlLCB0cnVlKTsgLy9jb250cm9scyB3aXRoIHBvc3QgZm9ybWF0aW5nLCB3ZSBuZWVkIHRvIHJlcGFpbnQgdmFsdWVcblxuXHQgICAgaWYgKHRoaXMuX2N1c3RvbV9mb3JtYXQgJiYgcmVzID09PSBmYWxzZSkge1xuXHQgICAgICB0aGlzLiRzZXRWYWx1ZShuZXd2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZhdWx0cy5oZWlnaHQgPSAkYWN0aXZlLmlucHV0SGVpZ2h0O1xuXHQgICAgdGhpcy5kZWZhdWx0cy5pbnB1dFBhZGRpbmcgPSAkYWN0aXZlLmlucHV0UGFkZGluZztcblx0ICAgIHRoaXMuX2lucHV0U3BhY2luZyA9ICRhY3RpdmUuaW5wdXRTcGFjaW5nO1xuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcubGFiZWxQb3NpdGlvbiA9PSBcInRvcFwiKSBpZiAoaXNVbmRlZmluZWQoY29uZmlnLmhlaWdodCkgJiYgdGhpcy5kZWZhdWx0cy5oZWlnaHQpIC8vIHRleHRhcmVhXG5cdCAgICAgIGNvbmZpZy5oZWlnaHQgPSB0aGlzLmRlZmF1bHRzLmhlaWdodCArIChjb25maWcubGFiZWwgPyB0aGlzLl9sYWJlbFRvcEhlaWdodCA6IDApOyAvL3N1Z2dlc3QgcmVmZXJlbmNlIGZvciBkZXN0cnVjdG9yXG5cblx0ICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZSA9IFtdO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgdGhpcy5faW5pdF9vbmNoYW5nZSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CbHVyXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX29uQmx1cikgdGhpcy5fb25CbHVyKCk7XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgICRyZW5kZXJJY29uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cblx0ICAgIGlmIChjb25maWcuaWNvbikge1xuXHQgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmFoZWlnaHQgLSAyICogY29uZmlnLmlucHV0UGFkZGluZyxcblx0ICAgICAgICAgIHBhZGRpbmcgPSAoaGVpZ2h0IC0gMTgpIC8gMiAtIDEsXG5cdCAgICAgICAgICBhcmlhID0gdGhpcy5hZGRTZWN0aW9uID8gXCJyb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBhcmlhLWxhYmVsPSdcIiArIGkxOG4uYXJpYVtcIm11bHRpdGV4dFwiICsgKGNvbmZpZy5tb2RlIHx8IFwiXCIpICsgXCJTZWN0aW9uXCJdICsgXCInXCIgOiBcIlwiO1xuXHQgICAgICByZXR1cm4gXCI8c3BhbiBzdHlsZT0naGVpZ2h0OlwiICsgKGhlaWdodCAtIHBhZGRpbmcpICsgXCJweDtwYWRkaW5nLXRvcDpcIiArIHBhZGRpbmcgKyBcInB4OycgY2xhc3M9J3dlYml4X2lucHV0X2ljb24gXCIgKyBjb25maWcuaWNvbiArIFwiJyBcIiArIGFyaWEgKyBcIj48L3NwYW4+XCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBcIlwiO1xuXHQgIH0sXG5cdCAgcmVsYXRlZFZpZXdfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0ICAgICAgdmFyIG1vZGUgPSB0aGlzLl9zZXR0aW5ncy5yZWxhdGVkQWN0aW9uO1xuXHQgICAgICB2YXIgdmlld2lkID0gdGhpcy5fc2V0dGluZ3MucmVsYXRlZFZpZXc7XG5cdCAgICAgIHZhciB2aWV3ID0gJCQodmlld2lkKTtcblxuXHQgICAgICBpZiAoIXZpZXcpIHtcblx0ICAgICAgICB2YXIgdG9wID0gdGhpcy5nZXRUb3BQYXJlbnRWaWV3KCk7XG5cdCAgICAgICAgaWYgKHRvcCAmJiB0b3AuJCQpIHZpZXcgPSB0b3AuJCQodmlld2lkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFzc2VydCh2aWV3LCBcIkludmFsaWQgcmVsYXRlZFZpZXc6IFwiICsgdmlld2lkKTtcblxuXHQgICAgICBpZiAobW9kZSA9PSBcImVuYWJsZVwiKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlKSB2aWV3LmVuYWJsZSgpO2Vsc2Ugdmlldy5kaXNhYmxlKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHZhbHVlKSB2aWV3LnNob3coKTtlbHNlIHZpZXcuaGlkZSgpO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIHZhbGlkYXRlRXZlbnRfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PSBcImJsdXJcIikgdGhpcy5hdHRhY2hFdmVudChcIm9uQmx1clwiLCB0aGlzLnZhbGlkYXRlKTtcblx0ICAgIGlmICh2YWx1ZSA9PSBcImtleVwiKSB0aGlzLmF0dGFjaEV2ZW50KFwib25UaW1lZEtleVByZXNzXCIsIHRoaXMudmFsaWRhdGUpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBydWxlID0gdGhpcy5fc2V0dGluZ3MudmFsaWRhdGU7XG5cdCAgICBpZiAoIXJ1bGUgJiYgdGhpcy5fc2V0dGluZ3MucmVxdWlyZWQpIHJ1bGUgPSBydWxlcy5pc05vdEVtcHR5O1xuXHQgICAgdmFyIGZvcm0gPSB0aGlzLmdldEZvcm1WaWV3KCk7XG5cdCAgICB2YXIgbmFtZSA9IHRoaXMuX3NldHRpbmdzLm5hbWU7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdCAgICB2YXIgZGF0YSA9IHt9O1xuXHQgICAgZGF0YVtuYW1lXSA9IHZhbHVlO1xuXHQgICAgYXNzZXJ0KGZvcm0sIFwiVmFsaWRhdGlvbiB3b3JrcyBvbmx5IGZvciBmaWVsZHMgaW4gdGhlIGZvcm1cIik7XG5cdCAgICBhc3NlcnQobmFtZSwgXCJWYWxpZGF0aW9uIHdvcmtzIG9ubHkgZm9yIGZpZWxkcyB3aXRoIG5hbWVcIik7XG5cdCAgICBpZiAocnVsZSAmJiAhZm9ybS5fdmFsaWRhdGUocnVsZSwgdmFsdWUsIGRhdGEsIG5hbWUpKSByZXR1cm4gZmFsc2U7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIGJvdHRvbUxhYmVsX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmJvdHRvbVBhZGRpbmcpIHRoaXMuX3NldHRpbmdzLmJvdHRvbVBhZGRpbmcgPSAxODtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9nZXRJbnZhbGlkVGV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHRleHQgPSB0aGlzLl9zZXR0aW5ncy5pbnZhbGlkTWVzc2FnZTtcblxuXHQgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB0ZXh0LmNhbGwodGhpcyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0ZXh0O1xuXHQgIH0sXG5cdCAgc2V0Qm90dG9tVGV4dDogZnVuY3Rpb24gKHRleHQsIGhlaWdodCkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAodHlwZW9mIHRleHQgIT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICBpZiAoY29uZmlnLmJvdHRvbUxhYmVsID09IHRleHQpIHJldHVybjtcblx0ICAgICAgY29uZmlnLmJvdHRvbUxhYmVsID0gdGV4dDtcblx0ICAgIH1cblxuXHQgICAgdmFyIG1lc3NhZ2UgPSAoY29uZmlnLmludmFsaWQgPyBjb25maWcuaW52YWxpZE1lc3NhZ2UgOiBcIlwiKSB8fCBjb25maWcuYm90dG9tTGFiZWw7XG5cdCAgICBpZiAoIW1lc3NhZ2UgJiYgIWNvbmZpZy5ib3R0b21QYWRkaW5nKSBjb25maWcuaW5wdXRIZWlnaHQgPSAwO1xuXG5cdCAgICBpZiAobWVzc2FnZSAmJiAhY29uZmlnLmJvdHRvbVBhZGRpbmcpIHtcblx0ICAgICAgdGhpcy5fcmVzdG9yZVBhZGRpbmcgPSAxO1xuXHQgICAgICBjb25maWcuYm90dG9tUGFkZGluZyA9IGNvbmZpZy5ib3R0b21QYWRkaW5nIHx8IGhlaWdodCB8fCAxODtcblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgICAgdGhpcy5yZXNpemUoKTtcblx0ICAgIH0gZWxzZSBpZiAoIW1lc3NhZ2UgJiYgdGhpcy5fcmVzdG9yZVBhZGRpbmcpIHtcblx0ICAgICAgY29uZmlnLmJvdHRvbVBhZGRpbmcgPSB0aGlzLl9yZXN0b3JlUGFkZGluZyA9IDA7IC8vdGV4dGFyZWFcblxuXHQgICAgICBpZiAoIWNvbmZpZy5oZWlnaHQpIHRoaXMucmVuZGVyKCk7XG5cdCAgICAgIHRoaXMucmVzaXplKCk7XG5cdCAgICB9IGVsc2UgdGhpcy5yZW5kZXIoKTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgc2l6ZXMgPSBiYXNlLmFwaS4kZ2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdmFyIGhlaWdodEluYyA9IHRoaXMuY29uZmlnLmJvdHRvbVBhZGRpbmc7XG5cblx0ICAgIGlmIChoZWlnaHRJbmMpIHtcblx0ICAgICAgc2l6ZXNbMl0gKz0gaGVpZ2h0SW5jO1xuXHQgICAgICBzaXplc1szXSArPSBoZWlnaHRJbmM7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzaXplcztcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KSkge1xuXHQgICAgICBpZiAoIXggfHwgIXkpIHJldHVybjtcblxuXHQgICAgICBpZiAoY29uZmlnLmxhYmVsUG9zaXRpb24gPT0gXCJ0b3BcIikge1xuXHQgICAgICAgIC8vIHRleHRhcmVhXG5cdCAgICAgICAgaWYgKCFjb25maWcuaW5wdXRIZWlnaHQpIHRoaXMuX2lucHV0SGVpZ2h0ID0gdGhpcy5fY29udGVudF9oZWlnaHQgLSAoY29uZmlnLmxhYmVsID8gdGhpcy5fbGFiZWxUb3BIZWlnaHQgOiAwKSAtICh0aGlzLmNvbmZpZy5ib3R0b21QYWRkaW5nIHx8IDApO1xuXHQgICAgICAgIGNvbmZpZy5sYWJlbFdpZHRoID0gMDtcblx0ICAgICAgfSBlbHNlIGlmIChjb25maWcuYm90dG9tUGFkZGluZykge1xuXHQgICAgICAgIGNvbmZpZy5pbnB1dEhlaWdodCA9IHRoaXMuX2NvbnRlbnRfaGVpZ2h0IC0gdGhpcy5jb25maWcuYm90dG9tUGFkZGluZztcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0X2lucHV0X3dpZHRoOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB2YXIgd2lkdGggPSAodGhpcy5faW5wdXRfd2lkdGggfHwgMCkgLSAoY29uZmlnLmxhYmVsID8gdGhpcy5fc2V0dGluZ3MubGFiZWxXaWR0aCA6IDApIC0gdGhpcy5faW5wdXRTcGFjaW5nIC0gKGNvbmZpZy5pY29uV2lkdGggfHwgMCk7IC8vcHJldmVudCBqcyBlcnJvciBpbiBJRVxuXG5cdCAgICByZXR1cm4gd2lkdGggPCAwID8gMCA6IHdpZHRoO1xuXHQgIH0sXG5cdCAgX3JlbmRlcl9kaXZfYmxvY2s6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgdmFyIGlkID0gXCJ4XCIgKyB1aWQoKTtcblxuXHQgICAgdmFyIHdpZHRoID0gY29tbW9uLl9nZXRfaW5wdXRfd2lkdGgob2JqKTtcblxuXHQgICAgdmFyIGlucHV0QWxpZ24gPSBvYmouaW5wdXRBbGlnbiB8fCBcImxlZnRcIjtcblx0ICAgIHZhciBoZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5haGVpZ2h0IC0gMiAqICRhY3RpdmUuaW5wdXRQYWRkaW5nIC0gMiAqIHRoaXMuX2JvcmRlcldpZHRoO1xuXG5cdCAgICB2YXIgdGV4dCA9IG9iai50ZXh0IHx8IG9iai52YWx1ZSB8fCB0aGlzLl9nZXRfZGl2X3BsYWNlaG9sZGVyKG9iaik7XG5cblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9pbnBfc3RhdGljJyByb2xlPSdjb21ib2JveCcgYXJpYS1sYWJlbD0nXCIgKyB0ZW1wbGF0ZS5lc2NhcGUob2JqLmxhYmVsKSArIFwiJyB0YWJpbmRleD0nMCdcIiArIChvYmoucmVhZG9ubHkgPyBcIiBhcmlhLXJlYWRvbmx5PSd0cnVlJ1wiIDogXCJcIikgKyAob2JqLmludmFsaWQgPyBcImFyaWEtaW52YWxpZD0ndHJ1ZSdcIiA6IFwiXCIpICsgXCIgb25jbGljaz0nJyBzdHlsZT0nbGluZS1oZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4O3dpZHRoOiBcIiArIHdpZHRoICsgXCJweDsgdGV4dC1hbGlnbjogXCIgKyBpbnB1dEFsaWduICsgXCI7JyA+XCIgKyB0ZXh0ICsgXCI8L2Rpdj5cIjtcblx0ICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KG9iaiwgaHRtbCwgaWQpO1xuXHQgIH0sXG5cdCAgX2Jhc2VJbnB1dEhUTUw6IGZ1bmN0aW9uICh0YWcpIHtcblx0ICAgIHZhciBodG1sID0gXCI8XCIgKyB0YWcgKyAodGhpcy5fc2V0dGluZ3MucGxhY2Vob2xkZXIgPyBcIiBwbGFjZWhvbGRlcj0nXCIgKyB0aGlzLl9zZXR0aW5ncy5wbGFjZWhvbGRlciArIFwiJyBcIiA6IFwiIFwiKTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5yZWFkb25seSkgaHRtbCArPSBcInJlYWRvbmx5PSd0cnVlJyBhcmlhLXJlYWRvbmx5PScnXCI7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MucmVxdWlyZWQpIGh0bWwgKz0gXCJhcmlhLXJlcXVpcmVkPSd0cnVlJ1wiO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmludmFsaWQpIGh0bWwgKz0gXCJhcmlhLWludmFsaWQ9J3RydWUnXCI7XG5cdCAgICB2YXIgYXR0cnMgPSB0aGlzLl9zZXR0aW5ncy5hdHRyaWJ1dGVzO1xuXHQgICAgaWYgKGF0dHJzKSBmb3IgKHZhciBwcm9wIGluIGF0dHJzKSB7XG5cdCAgICAgIGh0bWwgKz0gcHJvcCArIFwiPSdcIiArIGF0dHJzW3Byb3BdICsgXCInIFwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICAkcmVuZGVyTGFiZWw6IGZ1bmN0aW9uIChjb25maWcsIGlkKSB7XG5cdCAgICB2YXIgbGFiZWwgPSBcIlwiO1xuXG5cdCAgICBpZiAoY29uZmlnLmxhYmVsKSB7XG5cdCAgICAgIHZhciBsYWJlbEFsaWduID0gY29uZmlnLmxhYmVsQWxpZ24gfHwgXCJsZWZ0XCI7XG5cdCAgICAgIHZhciB0b3AgPSB0aGlzLl9zZXR0aW5ncy5sYWJlbFBvc2l0aW9uID09IFwidG9wXCI7XG5cdCAgICAgIHZhciBsYWJlbFRvcCA9IHRvcCA/IFwiZGlzcGxheTpibG9jaztcIiA6IFwid2lkdGg6IFwiICsgdGhpcy5fc2V0dGluZ3MubGFiZWxXaWR0aCArIFwicHg7XCI7XG5cblx0ICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gdGhpcy5fZ2V0TGFiZWxIZWlnaHQodG9wKTtcblxuXHQgICAgICBsYWJlbCA9IFwiPGxhYmVsIHN0eWxlPSdcIiArIGxhYmVsVG9wICsgXCJ0ZXh0LWFsaWduOiBcIiArIGxhYmVsQWxpZ24gKyBcIjtsaW5lLWhlaWdodDpcIiArIGxhYmVsSGVpZ2h0ICsgXCJweDsnIG9uY2xpY2s9JycgZm9yPSdcIiArIGlkICsgXCInIGNsYXNzPSd3ZWJpeF9pbnBfXCIgKyAodG9wID8gXCJ0b3BfXCIgOiBcIlwiKSArIFwibGFiZWwgXCIgKyAoY29uZmlnLnJlcXVpcmVkID8gXCJ3ZWJpeF9yZXF1aXJlZFwiIDogXCJcIikgKyBcIic+XCIgKyAoY29uZmlnLmxhYmVsIHx8IFwiXCIpICsgXCI8L2xhYmVsPlwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbGFiZWw7XG5cdCAgfSxcblx0ICBfZ2V0TGFiZWxIZWlnaHQ6IGZ1bmN0aW9uICh0b3ApIHtcblx0ICAgIHJldHVybiB0b3AgPyB0aGlzLl9sYWJlbFRvcEhlaWdodCAtIHRoaXMuX3NldHRpbmdzLmlucHV0UGFkZGluZyA6IHRoaXMuX3NldHRpbmdzLmFoZWlnaHQgLSAyICogdGhpcy5fc2V0dGluZ3MuaW5wdXRQYWRkaW5nO1xuXHQgIH0sXG5cdCAgJHJlbmRlcklucHV0OiBmdW5jdGlvbiAoY29uZmlnLCBkaXZfc3RhcnQsIGlkKSB7XG5cdCAgICB2YXIgaW5wdXRBbGlnbiA9IGNvbmZpZy5pbnB1dEFsaWduIHx8IFwibGVmdFwiO1xuXHQgICAgdmFyIHRvcCA9IGNvbmZpZy5sYWJlbFBvc2l0aW9uID09IFwidG9wXCI7XG5cblx0ICAgIHZhciBpbnB1dFdpZHRoID0gdGhpcy5fZ2V0X2lucHV0X3dpZHRoKGNvbmZpZyk7XG5cblx0ICAgIGlkID0gaWQgfHwgdWlkKCk7XG5cdCAgICB2YXIgbGFiZWwgPSB0aGlzLiRyZW5kZXJMYWJlbChjb25maWcsIGlkKTtcblx0ICAgIHZhciBodG1sID0gXCJcIjtcblxuXHQgICAgaWYgKGRpdl9zdGFydCkge1xuXHQgICAgICBodG1sICs9IGRpdl9zdGFydDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRlbXBsYXRlLmVzY2FwZShjb25maWcudGV4dCB8fCB0aGlzLl9wYXR0ZXJuKGNvbmZpZy52YWx1ZSkpO1xuXHQgICAgICBodG1sICs9IHRoaXMuX2Jhc2VJbnB1dEhUTUwoXCJpbnB1dFwiKSArIFwiaWQ9J1wiICsgaWQgKyBcIicgdHlwZT0nXCIgKyAoY29uZmlnLnR5cGUgfHwgdGhpcy5uYW1lKSArIFwiJ1wiICsgKGNvbmZpZy5lZGl0YWJsZSA/IFwiIHJvbGU9J2NvbWJvYm94J1wiIDogXCJcIikgKyBcIiB2YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJyBzdHlsZT0nd2lkdGg6IFwiICsgaW5wdXRXaWR0aCArIFwicHg7IHRleHQtYWxpZ246IFwiICsgaW5wdXRBbGlnbiArIFwiOydcIjtcblx0ICAgICAgdmFyIGF0dHJzID0gY29uZmlnLmF0dHJpYnV0ZXM7XG5cdCAgICAgIGlmIChhdHRycykgZm9yICh2YXIgcHJvcCBpbiBhdHRycykge1xuXHQgICAgICAgIGh0bWwgKz0gXCIgXCIgKyBwcm9wICsgXCI9J1wiICsgYXR0cnNbcHJvcF0gKyBcIidcIjtcblx0ICAgICAgfVxuXHQgICAgICBodG1sICs9IFwiIC8+XCI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBpY29uID0gdGhpcy4kcmVuZGVySWNvbiA/IHRoaXMuJHJlbmRlckljb24oY29uZmlnKSA6IFwiXCI7XG5cdCAgICBodG1sICs9IGljb247XG5cdCAgICB2YXIgcmVzdWx0ID0gXCJcIjsgLy9sYWJlbCBwb3NpdGlvbiwgdG9wIG9yIGxlZnRcblxuXHQgICAgaWYgKHRvcCkgcmVzdWx0ID0gbGFiZWwgKyBcIjxkaXYgY2xhc3M9J3dlYml4X2VsX2JveCcgc3R5bGU9J3dpZHRoOlwiICsgY29uZmlnLmF3aWR0aCArIFwicHg7IGhlaWdodDpcIiArIGNvbmZpZy5haGVpZ2h0ICsgXCJweCc+XCIgKyBodG1sICsgXCI8L2Rpdj5cIjtlbHNlIHJlc3VsdCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfZWxfYm94JyBzdHlsZT0nd2lkdGg6XCIgKyBjb25maWcuYXdpZHRoICsgXCJweDsgaGVpZ2h0OlwiICsgY29uZmlnLmFoZWlnaHQgKyBcInB4Jz5cIiArIGxhYmVsICsgaHRtbCArIFwiPC9kaXY+XCI7IC8vYm90dG9tIG1lc3NhZ2Ugd2lkdGhcblxuXHQgICAgdmFyIHBhZGRpbmcgPSBjb25maWcuYXdpZHRoIC0gaW5wdXRXaWR0aCAtICRhY3RpdmUuaW5wdXRQYWRkaW5nICogMjsgLy9ib3R0b20gbWVzc2FnZSB0ZXh0XG5cblx0ICAgIHZhciBtZXNzYWdlID0gKGNvbmZpZy5pbnZhbGlkID8gY29uZmlnLmludmFsaWRNZXNzYWdlIDogXCJcIikgfHwgY29uZmlnLmJvdHRvbUxhYmVsO1xuXHQgICAgaWYgKG1lc3NhZ2UpIHJlc3VsdCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2lucF9ib3R0b21fbGFiZWwnXCIgKyAoY29uZmlnLmludmFsaWQgPyBcInJvbGU9J2FsZXJ0JyBhcmlhLXJlbGV2YW50PSdhbGwnXCIgOiBcIlwiKSArIFwiIHN0eWxlPSd3aWR0aDpcIiArIChpbnB1dFdpZHRoIHx8IGNvbmZpZy5hd2lkdGgpICsgXCJweDttYXJnaW4tbGVmdDpcIiArIE1hdGgubWF4KHBhZGRpbmcsICRhY3RpdmUuaW5wdXRQYWRkaW5nKSArIFwicHg7Jz5cIiArIG1lc3NhZ2UgKyBcIjwvZGl2PlwiO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KG9iaik7XG5cdCAgICB9LFxuXHQgICAgbGFiZWw6IFwiXCIsXG5cdCAgICBsYWJlbFdpZHRoOiA4MFxuXHQgIH0sXG5cdCAgdHlwZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX3NldF9pbm5lcl9zaXplOiBmYWxzZSxcblx0ICAkc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5nZXRJbnB1dE5vZGUoKS52YWx1ZSA9IHRoaXMuX3BhdHRlcm4odmFsdWUpO1xuXHQgIH0sXG5cdCAgJGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcGF0dGVybih0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlLCBmYWxzZSk7XG5cdCAgfSxcblx0ICBzdWdnZXN0X3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgYXNzZXJ0KHZhbHVlICE9PSB0cnVlLCBcInN1Z2dlc3Qgb3B0aW9ucyBjYW4ndCBiZSBzZXQgYXMgdHJ1ZSwgZGF0YSBuZWVkIHRvIGJlIHByb3ZpZGVkIGluc3RlYWRcIik7XG5cblx0ICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIGF0dGVtcHQgPSAkJCh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGF0dGVtcHQpIHJldHVybiAkJCh2YWx1ZSkuX3NldHRpbmdzLmlkO1xuXHQgICAgICAgIHZhbHVlID0ge1xuXHQgICAgICAgICAgYm9keToge1xuXHQgICAgICAgICAgICB1cmw6IHZhbHVlLFxuXHQgICAgICAgICAgICBkYXRhRmVlZDogdmFsdWVcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlLmdldEl0ZW0pIHZhbHVlID0ge1xuXHQgICAgICAgIGJvZHk6IHtcblx0ICAgICAgICAgIGRhdGE6IHZhbHVlXG5cdCAgICAgICAgfVxuXHQgICAgICB9O2Vsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IHtcblx0ICAgICAgICBib2R5OiB7XG5cdCAgICAgICAgICBkYXRhOiB0aGlzLl9jaGVja19vcHRpb25zKHZhbHVlKVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtlbHNlIGlmICghdmFsdWUuYm9keSkgdmFsdWUuYm9keSA9IHt9O1xuXG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHZhbHVlLCB7XG5cdCAgICAgICAgdmlldzogXCJzdWdnZXN0XCJcblx0ICAgICAgfSk7XG5cdCAgICAgIHZhciB2aWV3ID0gdWkodmFsdWUpO1xuXG5cdCAgICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZS5wdXNoKHZpZXcpO1xuXG5cdCAgICAgIHJldHVybiB2aWV3Ll9zZXR0aW5ncy5pZDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckdyA9IGV4cG9ydHMucHJvdG9VSShhcGkkdywgVGV4dFBhdHRlcm4sIGJ1dHRvbiQxLnZpZXcpO1xuXHR2YXIgdGV4dCA9IHtcblx0ICBhcGk6IGFwaSR3LFxuXHQgIHZpZXc6IHZpZXckd1xuXHR9O1xuXG5cdHZhciBEYXRhQ29sbGVjdGlvbiA9IGV4cG9ydHMucHJvdG8oe1xuXHQgIG5hbWU6IFwiRGF0YUNvbGxlY3Rpb25cIixcblx0ICBpc1Zpc2libGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5kYXRhLm9yZGVyLmxlbmd0aCAmJiAhdGhpcy5kYXRhLl9maWx0ZXJfb3JkZXIgJiYgIXRoaXMuX3NldHRpbmdzLmRhdGFGZWVkKSByZXR1cm4gZmFsc2U7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLmRhdGEucHJvdmlkZUFwaSh0aGlzLCB0cnVlKTtcblx0ICAgIHZhciBpZCA9IGNvbmZpZyAmJiBjb25maWcuaWQgPyBjb25maWcuaWQgOiB1aWQoKTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmlkID0gaWQ7XG5cdCAgICB1aS52aWV3c1tpZF0gPSB0aGlzO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZUxvYWRcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25CaW5kUmVxdWVzdFwiLCBbXSk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmluZFJlcXVlc3RcIiwgW10pO1xuXHQgIH1cblx0fSwgRGF0YU1vdmUsIENvbGxlY3Rpb25CaW5kLCBCaW5kU291cmNlLCBWYWxpZGF0ZUNvbGxlY3Rpb24sIERhdGFMb2FkZXIsIE1hcENvbGxlY3Rpb24sIEV2ZW50U3lzdGVtLCBCYXNlQmluZCwgRGVzdHJ1Y3Rpb24sIFNldHRpbmdzKTtcblx0ZGVmaW5lKFwiRGF0YUNvbGxlY3Rpb25cIiwgRGF0YUNvbGxlY3Rpb24pO1xuXG5cdHZhciBhcGkkeCA9IHtcblx0ICBuYW1lOiBcInNlbGVjdFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgIHZhciBvcHRpb25zID0gY29tbW9uLl9jaGVja19vcHRpb25zKG9iai5vcHRpb25zKTtcblxuXHQgICAgICB2YXIgaWQgPSBcInhcIiArIHVpZCgpO1xuXHQgICAgICB2YXIgaHRtbCA9IGNvbW1vbi5fYmFzZUlucHV0SFRNTChcInNlbGVjdFwiKSArIFwiaWQ9J1wiICsgaWQgKyBcIicgc3R5bGU9J3dpZHRoOlwiICsgY29tbW9uLl9nZXRfaW5wdXRfd2lkdGgob2JqKSArIFwicHg7Jz5cIjtcblx0ICAgICAgdmFyIG9wdHZpZXcgPSAkJChvcHRpb25zKTtcblxuXHQgICAgICBpZiAob3B0dmlldyAmJiBvcHR2aWV3LmRhdGEgJiYgb3B0dmlldy5kYXRhLmVhY2gpIHtcblx0ICAgICAgICBvcHR2aWV3LmRhdGEuZWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG5cdCAgICAgICAgICBodG1sICs9IFwiPG9wdGlvblwiICsgKG9wdGlvbi5pZCA9PSBvYmoudmFsdWUgPyBcIiBzZWxlY3RlZD0ndHJ1ZSdcIiA6IFwiXCIpICsgXCIgdmFsdWU9J1wiICsgb3B0aW9uLmlkICsgXCInPlwiICsgb3B0aW9uLnZhbHVlICsgXCI8L29wdGlvbj5cIjtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGh0bWwgKz0gXCI8b3B0aW9uXCIgKyAob3B0aW9uc1tpXS5pZCA9PSBvYmoudmFsdWUgPyBcIiBzZWxlY3RlZD0ndHJ1ZSdcIiA6IFwiXCIpICsgXCIgdmFsdWU9J1wiICsgb3B0aW9uc1tpXS5pZCArIFwiJz5cIiArIG9wdGlvbnNbaV0udmFsdWUgKyBcIjwvb3B0aW9uPlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgaHRtbCArPSBcIjwvc2VsZWN0PlwiO1xuXHQgICAgICByZXR1cm4gY29tbW9uLiRyZW5kZXJJbnB1dChvYmosIGh0bWwsIGlkKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIG9wdGlvbnNfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBEYXRhQ29sbGVjdGlvbih7XG5cdCAgICAgICAgICB1cmw6IHZhbHVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29sbGVjdGlvbi5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZUxvYWRcIiwgYmluZCh0aGlzLnJlZnJlc2gsIHRoaXMpKTtcblx0ICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcblx0ICAgICAgfSBlbHNlIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vZ2V0IGlucHV0IGVsZW1lbnRcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2VsZWN0XCIpWzBdO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckeCA9IGV4cG9ydHMucHJvdG9VSShhcGkkeCwgdGV4dC52aWV3KTtcblxuXHR2YXIgYXBpJHkgPSB7XG5cdCAgbmFtZTogXCJjaGVja2JveFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBjaGVja1ZhbHVlOiAxLFxuXHQgICAgdW5jaGVja1ZhbHVlOiAwLFxuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChjb25maWcsIGNvbW1vbikge1xuXHQgICAgICB2YXIgaWQgPSBcInhcIiArIHVpZCgpO1xuXHQgICAgICB2YXIgcmlnaHRsYWJlbCA9IFwiXCI7XG5cblx0ICAgICAgaWYgKGNvbmZpZy5sYWJlbFJpZ2h0KSB7XG5cdCAgICAgICAgcmlnaHRsYWJlbCA9IFwiPGxhYmVsIGNsYXNzPSd3ZWJpeF9sYWJlbF9yaWdodCc+XCIgKyBjb25maWcubGFiZWxSaWdodCArIFwiPC9sYWJlbD5cIjsgLy91c2VyIGNsZWFybHkgYXR0ZW1wdHMgdG8gaGlkZSB0aGUgbGFiZWwsIGhlbHAgaGltXG5cblx0ICAgICAgICBpZiAoY29uZmlnLmxhYmVsV2lkdGgpIGNvbmZpZy5sYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCBcIiZuYnNwO1wiO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNoZWNrZWQgPSBjb25maWcuY2hlY2tWYWx1ZSA9PSBjb25maWcudmFsdWU7XG5cdCAgICAgIHZhciBtYXJnaW4gPSBNYXRoLmZsb29yKChjb21tb24uX3NldHRpbmdzLmFoZWlnaHQgLSAxNikgLyAyKTtcblx0ICAgICAgdmFyIGNoID0gY29tbW9uLl9iYXNlSW5wdXRIVE1MKFwiaW5wdXRcIikgKyBcInN0eWxlPSdtYXJnaW4tdG9wOlwiICsgbWFyZ2luICsgXCJweDtcIiArIChjb25maWcuY3VzdG9tQ2hlY2tib3ggPyBcImRpc3BsYXk6bm9uZVwiIDogXCJcIikgKyBcIicgaWQ9J1wiICsgaWQgKyBcIicgdHlwZT0nY2hlY2tib3gnIFwiICsgKGNoZWNrZWQgPyBcImNoZWNrZWQ9JzEnXCIgOiBcIlwiKSArIChjb25maWcubGFiZWxSaWdodCA/IFwiIGFyaWEtbGFiZWw9J1wiICsgdGVtcGxhdGUuZXNjYXBlKGNvbmZpZy5sYWJlbFJpZ2h0KSArIFwiJ1wiIDogXCJcIikgKyBcIi8+XCI7XG5cdCAgICAgIHZhciBjbGFzc05hbWUgPSBcIndlYml4X2lucF9jaGVja2JveF9ib3JkZXIgd2ViaXhfZWxfZ3JvdXAgd2ViaXhfY2hlY2tib3hfXCIgKyAoY2hlY2tlZCA/IFwiMVwiIDogXCIwXCIpO1xuXHQgICAgICB2YXIgY3VzdG9tQ2hlY2tib3ggPSBjb25maWcuY3VzdG9tQ2hlY2tib3ggfHwgXCJcIjtcblxuXHQgICAgICBpZiAoY3VzdG9tQ2hlY2tib3gpIHtcblx0ICAgICAgICBjdXN0b21DaGVja2JveCA9IGN1c3RvbUNoZWNrYm94LnJlcGxhY2UoLyhhcmlhLWNoZWNrZWQ9JylcXHcqKD89JykvLCBcIiQxXCIgKyAoY29uZmlnLnZhbHVlID09IGNvbmZpZy5jaGVja1ZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpKTtcblx0ICAgICAgICBjdXN0b21DaGVja2JveCA9IGN1c3RvbUNoZWNrYm94LnJlcGxhY2UoLyhhcmlhLWxhYmVsPScpXFx3Kig/PScpLywgXCIkMVwiICsgdGVtcGxhdGUuZXNjYXBlKGNvbmZpZy5sYWJlbFJpZ2h0IHx8IGNvbmZpZy5sYWJlbCkpO1xuXHQgICAgICAgIGN1c3RvbUNoZWNrYm94ID0gY3VzdG9tQ2hlY2tib3gucmVwbGFjZSgvKGFyaWEtaW52YWxpZD0nKVxcdyooPz0nKS8sIFwiJDFcIiArIChjb25maWcuaW52YWxpZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaHRtbCA9IFwiPGRpdiBzdHlsZT0nbGluZS1oZWlnaHQ6XCIgKyBjb21tb24uX3NldHRpbmdzLmNoZWlnaHQgKyBcInB4JyBjbGFzcz0nXCIgKyBjbGFzc05hbWUgKyBcIic+XCIgKyBjaCArIGN1c3RvbUNoZWNrYm94ICsgcmlnaHRsYWJlbCArIFwiPC9kaXY+XCI7XG5cdCAgICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KGNvbmZpZywgaHRtbCwgaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgY3VzdG9tQ2hlY2tib3hfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSAmJiAkYWN0aXZlLmN1c3RvbUNoZWNrYm94KSB7XG5cdCAgICAgIHZhbHVlID0gXCI8YSByb2xlPSdwcmVzZW50YXRpb24nIG9uY2xpY2s9J2phdmFzY3JpcHQ6dm9pZCgwKSc+PGJ1dHRvbiByb2xlPSdjaGVja2JveCcgYXJpYS1jaGVja2VkPSdmYWxzZScgYXJpYS1sYWJlbD0nJyB0eXBlPSdidXR0b24nIGFyaWEtaW52YWxpZD0nJyBjbGFzcz0nd2ViaXhfY3VzdG9tX2NoZWNrYm94Jz48L2J1dHRvbj48L2E+XCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGJsdXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICBpZiAoaW5wdXQpIGlucHV0LmJsdXIoKTtcblx0ICB9LFxuXHQgIF9wYXR0ZXJuOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9pbml0X29uY2hhbmdlOiBmdW5jdGlvbiAoKSB7fSxcblx0ICAkc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIGlzQ2hlY2tlZCA9IHZhbHVlID09IHRoaXMuX3NldHRpbmdzLmNoZWNrVmFsdWU7XG5cdCAgICB2YXIgaW5wdXQgPSB0aGlzLiR2aWV3LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG5cdCAgICB2YXIgcGFyZW50Tm9kZSA9IGlucHV0ID8gaW5wdXQucGFyZW50Tm9kZSA6IG51bGw7XG5cblx0ICAgIGlmIChwYXJlbnROb2RlICYmIHRoaXMuX3NldHRpbmdzLmN1c3RvbUNoZWNrYm94KSB7XG5cdCAgICAgIHZhciBidXR0b24gPSBwYXJlbnROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQlVUVE9OXCIpO1xuXHQgICAgICBpZiAoYnV0dG9uWzBdKSBidXR0b25bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIGlzQ2hlY2tlZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHBhcmVudE5vZGUpIHtcblx0ICAgICAgcGFyZW50Tm9kZS5jbGFzc05hbWUgPSBwYXJlbnROb2RlLmNsYXNzTmFtZS5yZXBsYWNlKC8od2ViaXhfY2hlY2tib3hfKVxcZC8sIFwiJDFcIiArIChpc0NoZWNrZWQgPyAxIDogMCkpO1xuXHQgICAgfVxuXG5cdCAgICBpbnB1dC5jaGVja2VkID0gaXNDaGVja2VkO1xuXHQgIH0sXG5cdCAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCkgIT0gdGhpcy5fc2V0dGluZ3MuY2hlY2tWYWx1ZSA/IHRoaXMuX3NldHRpbmdzLmNoZWNrVmFsdWUgOiB0aGlzLl9zZXR0aW5ncy51bmNoZWNrVmFsdWU7XG5cdCAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcblx0ICB9LFxuXHQgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLl9zZXR0aW5ncy52YWx1ZTtcblx0ICAgIHJldHVybiB2YWx1ZSA9PSB0aGlzLl9zZXR0aW5ncy5jaGVja1ZhbHVlID8gdGhpcy5fc2V0dGluZ3MuY2hlY2tWYWx1ZSA6IHRoaXMuX3NldHRpbmdzLnVuY2hlY2tWYWx1ZTtcblx0ICB9LFxuXHQgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuJHZpZXcuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGhpcy5fc2V0dGluZ3MuY3VzdG9tQ2hlY2tib3ggPyBcImJ1dHRvblwiIDogXCJpbnB1dFwiKVswXTtcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmF1bHRzLmN1c3RvbUNoZWNrYm94ID0gISEkYWN0aXZlLmN1c3RvbUNoZWNrYm94O1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckeSA9IGV4cG9ydHMucHJvdG9VSShhcGkkeSwgdGV4dC52aWV3KTtcblx0dmFyIGNoZWNrYm94ID0ge1xuXHQgIGFwaTogYXBpJHksXG5cdCAgdmlldzogdmlldyR5XG5cdH07XG5cblx0dmFyIGFwaSR6ID0ge1xuXHQgIG5hbWU6IFwicmFkaW9cIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChjb25maWcsIGNvbW1vbikge1xuXHQgICAgICB2YXIgb3B0aW9ucyA9IGNvbW1vbi5fY2hlY2tfb3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG5cblx0ICAgICAgdmFyIGh0bWwgPSBbXTtcblx0ICAgICAgdmFyIGlkO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBlYWNoaWQgPSBcInhcIiArIHVpZCgpO1xuXHQgICAgICAgIGlkID0gaWQgfHwgZWFjaGlkO1xuXHQgICAgICAgIGlmIChpICYmIChvcHRpb25zW2ldLm5ld2xpbmUgfHwgY29uZmlnLnZlcnRpY2FsKSkgaHRtbC5wdXNoKFwiPGRpdiBjbGFzcz0nd2ViaXhfbGluZV9icmVhayc+PC9kaXY+XCIpO1xuXHQgICAgICAgIHZhciBpc0NoZWNrZWQgPSBvcHRpb25zW2ldLmlkID09IGNvbmZpZy52YWx1ZTtcblx0ICAgICAgICB2YXIgbGFiZWwgPSBvcHRpb25zW2ldLnZhbHVlIHx8IFwiXCI7XG5cdCAgICAgICAgdmFyIHRvb2x0aXAgPSBjb25maWcudG9vbHRpcCA/IFwiIHdlYml4X3RfaWQ9J1wiICsgb3B0aW9uc1tpXS5pZCArIFwiJ1wiIDogXCJcIjtcblx0ICAgICAgICB2YXIgY3VzdG9tUmFkaW8gPSBjb25maWcuY3VzdG9tUmFkaW8gfHwgXCJcIjtcblxuXHQgICAgICAgIGlmIChjdXN0b21SYWRpbykge1xuXHQgICAgICAgICAgdmFyIG9wdGxhYmVsID0gKGkgPT09IDAgPyBjb25maWcubGFiZWwgKyBcIiBcIiA6IFwiXCIpICsgbGFiZWw7XG5cdCAgICAgICAgICBjdXN0b21SYWRpbyA9IGN1c3RvbVJhZGlvLnJlcGxhY2UoLyhhcmlhLWxhYmVsPScpXFx3Kig/PScpLywgXCIkMVwiICsgdGVtcGxhdGUuZXNjYXBlKG9wdGxhYmVsKSk7XG5cdCAgICAgICAgICBjdXN0b21SYWRpbyA9IGN1c3RvbVJhZGlvLnJlcGxhY2UoLyhhcmlhLWNoZWNrZWQ9JylcXHcqKD89JykvLCBcIiQxXCIgKyAoaXNDaGVja2VkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpKTtcblx0ICAgICAgICAgIGN1c3RvbVJhZGlvID0gY3VzdG9tUmFkaW8ucmVwbGFjZSgvKHRhYmluZGV4PScpXFx3Kig/PScpLywgXCIkMVwiICsgKGlzQ2hlY2tlZCB8fCBpID09PSAwICYmICFjb25maWcudmFsdWUgPyBcIjBcIiA6IFwiLTFcIikpO1xuXHQgICAgICAgICAgY3VzdG9tUmFkaW8gPSBjdXN0b21SYWRpby5yZXBsYWNlKC8oYXJpYS1pbnZhbGlkPScpXFx3Kig/PScpLywgXCIkMVwiICsgKGNvbmZpZy5pbnZhbGlkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpKTtcblx0ICAgICAgICAgIGN1c3RvbVJhZGlvID0gY3VzdG9tUmFkaW8ucmVwbGFjZSgvKGJ1dHRvbl9pZD0nKVxcdyooPz0nKS8sIFwiJDFcIiArIG9wdGlvbnNbaV0uaWQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciByZCA9IGNvbW1vbi5fYmFzZUlucHV0SFRNTChcImlucHV0XCIpICsgXCIgbmFtZT0nXCIgKyAoY29uZmlnLm5hbWUgfHwgY29uZmlnLmlkKSArIFwiJyB0eXBlPSdyYWRpbycgXCIgKyAoaXNDaGVja2VkID8gXCJjaGVja2VkPScxJ1wiIDogXCJcIikgKyBcInRhYmluZGV4PVwiICsgKGlzQ2hlY2tlZCB8fCBpID09PSAwICYmICFjb25maWcudmFsdWUgPyBcIjBcIiA6IFwiLTFcIikgKyBcIiB2YWx1ZT0nXCIgKyBvcHRpb25zW2ldLmlkICsgXCInIGlkPSdcIiArIGVhY2hpZCArIFwiJyBzdHlsZT0nXCIgKyAoY3VzdG9tUmFkaW8gPyBcImRpc3BsYXk6bm9uZVwiIDogXCJcIikgKyBcIicgLz5cIjtcblx0ICAgICAgICB2YXIgaW5wdXQgPSBcIjxkaXYgcmFkaW9faWQ9J1wiICsgb3B0aW9uc1tpXS5pZCArIFwiJyBjbGFzcz0nd2ViaXhfaW5wX3JhZGlvX2JvcmRlciB3ZWJpeF9yYWRpb19cIiArIChpc0NoZWNrZWQgPyBcIjFcIiA6IFwiMFwiKSArIFwiJyByb2xlPSdwcmVzZW50YXRpb24nPlwiICsgcmQgKyBjdXN0b21SYWRpbyArIFwiPC9kaXY+XCI7XG5cdCAgICAgICAgaWYgKGxhYmVsKSBsYWJlbCA9IFwiPGxhYmVsIGZvcj0nXCIgKyBlYWNoaWQgKyBcIicgY2xhc3M9J3dlYml4X2xhYmVsX3JpZ2h0Jz5cIiArIGxhYmVsICsgXCI8L2xhYmVsPlwiO1xuXHQgICAgICAgIGh0bWwucHVzaChcIjxkaXYgY2xhc3M9J3dlYml4X3JhZGlvX29wdGlvbicgcm9sZT0ncHJlc2VudGF0aW9uJ1wiICsgdG9vbHRpcCArIFwiPlwiICsgaW5wdXQgKyBsYWJlbCArIFwiPC9kaXY+XCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaHRtbCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfZWxfZ3JvdXAnIHJvbGU9J3JhZGlvZ3JvdXAnIHN0eWxlPSdtYXJnaW4tbGVmdDpcIiArIChjb25maWcubGFiZWwgPyBjb25maWcubGFiZWxXaWR0aCA6IDApICsgXCJweDsnPlwiICsgaHRtbC5qb2luKFwiXCIpICsgXCI8L2Rpdj5cIjtcblx0ICAgICAgcmV0dXJuIGNvbW1vbi4kcmVuZGVySW5wdXQoY29uZmlnLCBodG1sLCBpZCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgaWYgKHRoaXMuX2xhc3Rfc2l6ZSAmJiB0aGlzLiRnZXRTaXplKDAsIDApWzJdICE9IHRoaXMuX2xhc3Rfc2l6ZVsxXSkgdGhpcy5yZXNpemUoKTtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICB2YXIgc2l6ZSA9IGJ1dHRvbiQxLmFwaS4kZ2V0U2l6ZS5jYWxsKHRoaXMsIGR4LCBkeSk7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5vcHRpb25zKSB7XG5cdCAgICAgIHZhciBjb3VudCA9IHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsID8gMCA6IDE7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZXR0aW5ncy5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsIHx8IHRoaXMuX3NldHRpbmdzLm9wdGlvbnNbaV0ubmV3bGluZSkgY291bnQrKztcblx0ICAgICAgfVxuXG5cdCAgICAgIHNpemVbM10gPSBzaXplWzJdID0gTWF0aC5tYXgoc2l6ZVsyXSwgKHRoaXMuX3NldHRpbmdzLm9wdGlvbkhlaWdodCB8fCAyNSkgKiBjb3VudCArIHRoaXMuX3NldHRpbmdzLmlucHV0UGFkZGluZyAqIDIgKyAodGhpcy5fc2V0dGluZ3MubGFiZWxQb3NpdGlvbiA9PSBcInRvcFwiID8gdGhpcy5fbGFiZWxUb3BIZWlnaHQgOiAwKSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBoZWlnaHRJbmMgPSB0aGlzLmNvbmZpZy5ib3R0b21QYWRkaW5nO1xuXG5cdCAgICBpZiAoaGVpZ2h0SW5jKSB7XG5cdCAgICAgIHNpemVbMl0gKz0gaGVpZ2h0SW5jO1xuXHQgICAgICBzaXplWzNdICs9IGhlaWdodEluYztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHNpemU7XG5cdCAgfSxcblx0ICBfZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGF0YW9iai5nZXRFbGVtZW50c0J5VGFnTmFtZSh0aGlzLl9zZXR0aW5ncy5jdXN0b21SYWRpbyA/IFwiYnV0dG9uXCIgOiBcImlucHV0XCIpO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBpbnAgPSB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIik7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChpbnBbaV0ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJyYWRpb19pZFwiKSA9PSB2YWx1ZSkge1xuXHQgICAgICAgIGlucFtpXS5jaGVja2VkID0gdHJ1ZTtcblx0ICAgICAgICBpbnBbaV0uc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlucFtpXS5jaGVja2VkID0gZmFsc2U7XG5cdCAgICAgICAgaW5wW2ldLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcGFyZW50Tm9kZSA9IGlucFtpXSA/IGlucFtpXS5wYXJlbnROb2RlIDogbnVsbDtcblxuXHQgICAgICBpZiAocGFyZW50Tm9kZSkge1xuXHQgICAgICAgIHBhcmVudE5vZGUuY2xhc3NOYW1lID0gcGFyZW50Tm9kZS5jbGFzc05hbWUucmVwbGFjZSgvKHdlYml4X3JhZGlvXylcXGQvLCBcIiQxXCIgKyAoaW5wW2ldLmNoZWNrZWQgPyAxIDogMCkpO1xuXG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmN1c3RvbVJhZGlvKSB7XG5cdCAgICAgICAgICB2YXIgYnV0dG9uID0gcGFyZW50Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkJVVFRPTlwiKTtcblxuXHQgICAgICAgICAgaWYgKGJ1dHRvblswXSkge1xuXHQgICAgICAgICAgICBidXR0b25bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIGlucFtpXS5jaGVja2VkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuXHQgICAgICAgICAgICBidXR0b25bMF0uc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgaW5wW2ldLmNoZWNrZWQgPyBcIjBcIiA6IFwiLTFcIik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnZhbHVlO1xuXHQgIH0sXG5cdCAgZm9jdXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9mb2N1cygpO1xuXHQgIH0sXG5cdCAgYmx1cjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fYmx1cigpO1xuXHQgIH0sXG5cdCAgY3VzdG9tUmFkaW9fc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSAmJiAkYWN0aXZlLmN1c3RvbVJhZGlvKSB2YWx1ZSA9IFwiPGEgcm9sZT0ncHJlc2VudGF0aW9uJyBvbmNsaWNrPSdqYXZhc2NyaXB0OnZvaWQoMCknPjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nd2ViaXhfY3VzdG9tX3JhZGlvJyBidXR0b25faWQ9Jycgcm9sZT0ncmFkaW8nIGFyaWEtY2hlY2tlZD0nZmFsc2UnIGFyaWEtbGFiZWw9JycgYXJpYS1pbnZhbGlkPScnIHRhYmluZGV4PScnPjwvYnV0dG9uPjwvYT5cIjtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmF1bHRzLmN1c3RvbVJhZGlvID0gISEkYWN0aXZlLmN1c3RvbVJhZGlvO1xuXHQgICAgaWYgKCRhY3RpdmUub3B0aW9uSGVpZ2h0KSB0aGlzLmRlZmF1bHRzLm9wdGlvbkhlaWdodCA9ICRhY3RpdmUub3B0aW9uSGVpZ2h0O1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckeiA9IGV4cG9ydHMucHJvdG9VSShhcGkkeiwgdGV4dC52aWV3LCBIVE1MT3B0aW9ucyk7XG5cblx0dmFyIGFwaSRBID0ge1xuXHQgIG5hbWU6IFwiZGF0ZXBpY2tlclwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX2luaXRfcG9wdXApO1xuXHQgIH0sXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgaWYgKGNvbW1vbi5fc2V0dGluZ3MudHlwZSA9PSBcInRpbWVcIikge1xuXHQgICAgICAgIGNvbW1vbi5fc2V0dGluZ3MuaWNvbiA9IGNvbW1vbi5fc2V0dGluZ3MudGltZUljb247XG5cdCAgICAgIH0gLy90ZW1wb3JhcnkgcmVtb3ZlIG9iai50eXBlIFtbRElSVFldXVxuXG5cblx0ICAgICAgdmFyIHQgPSBvYmoudHlwZTtcblx0ICAgICAgb2JqLnR5cGUgPSBcIlwiO1xuXHQgICAgICB2YXIgcmVzID0gb2JqLmVkaXRhYmxlID8gY29tbW9uLiRyZW5kZXJJbnB1dChvYmopIDogY29tbW9uLl9yZW5kZXJfZGl2X2Jsb2NrKG9iaiwgY29tbW9uKTtcblx0ICAgICAgb2JqLnR5cGUgPSB0O1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfSxcblx0ICAgIHN0cmluZ1Jlc3VsdDogZmFsc2UsXG5cdCAgICB0aW1lcGlja2VyOiBmYWxzZSxcblx0ICAgIGljb246IFwid3hpLWNhbGVuZGFyXCIsXG5cdCAgICBpY29uczogdHJ1ZSxcblx0ICAgIHRpbWVJY29uOiBcInd4aS1jbG9ja1wiLFxuXHQgICAgc2VwYXJhdG9yOiBcIiwgXCJcblx0ICB9LFxuXHQgIF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy50ZXh0ID09IHRoaXMuZ2V0VGV4dCgpIHx8IGlzVW5kZWZpbmVkKHRoaXMuX3NldHRpbmdzLnRleHQpICYmICF0aGlzLmdldFRleHQoKSkgcmV0dXJuO1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRQb3B1cCgpLmdldFZhbHVlKCk7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmYXVsdHMuaW5wdXRQYWRkaW5nID0gJGFjdGl2ZS5pbnB1dFBhZGRpbmc7XG5cdCAgICB0aGlzLmRlZmF1bHRzLnBvaW50ID0gISRhY3RpdmUucG9wdXBOb1BvaW50O1xuXHQgIH0sXG5cdCAgZ2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiAkJCh0aGlzLl9zZXR0aW5ncy5wb3B1cCk7XG5cdCAgfSxcblx0ICBfaW5pdF9wb3B1cDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG9iaiA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgaWYgKG9iai5zdWdnZXN0KSBvYmoucG9wdXAgPSBvYmouc3VnZ2VzdDtlbHNlIGlmICghb2JqLnBvcHVwKSB7XG5cdCAgICAgIHZhciB0aW1lcGlja2VyID0gdGhpcy5fc2V0dGluZ3MudGltZXBpY2tlcjtcblx0ICAgICAgb2JqLnBvcHVwID0gb2JqLnN1Z2dlc3QgPSB0aGlzLnN1Z2dlc3Rfc2V0dGVyKHtcblx0ICAgICAgICB0eXBlOiBcImNhbGVuZGFyXCIsXG5cdCAgICAgICAgcG9pbnQ6IHRoaXMuX3NldHRpbmdzLnBvaW50ID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSxcblx0ICAgICAgICBwYWRkaW5nOiAwLFxuXHQgICAgICAgIGJvZHk6IHtcblx0ICAgICAgICAgIGhlaWdodDogMjQwICsgKHRpbWVwaWNrZXIgfHwgdGhpcy5fc2V0dGluZ3MuaWNvbnMgPyAzMCA6IDApLFxuXHQgICAgICAgICAgd2lkdGg6IDI1MCxcblx0ICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCxcblx0ICAgICAgICAgIHRpbWVwaWNrZXI6IHRpbWVwaWNrZXIsXG5cdCAgICAgICAgICB0eXBlOiB0aGlzLl9zZXR0aW5ncy50eXBlLFxuXHQgICAgICAgICAgaWNvbnM6IHRoaXMuX3NldHRpbmdzLmljb25zLFxuXHQgICAgICAgICAgdGltZUljb246IHRoaXMuX3NldHRpbmdzLnRpbWVJY29uXG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faW5pdF9vbmNlID0gZnVuY3Rpb24gKCkge307XG5cdCAgfSxcblx0ICAkcmVuZGVyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAoaXNVbmRlZmluZWQob2JqLnZhbHVlKSkgcmV0dXJuO1xuXHQgICAgb2JqLnZhbHVlID0gdGhpcy4kcHJlcGFyZVZhbHVlKG9iai52YWx1ZSk7XG5cdCAgICB0aGlzLiRzZXRWYWx1ZShvYmoudmFsdWUpO1xuXHQgIH0sXG5cdCAgJHByZXBhcmVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubXVsdGlzZWxlY3QpIHtcblx0ICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdmFsdWUgPSB2YWx1ZS5zcGxpdCh0aGlzLl9zZXR0aW5ncy5zZXBhcmF0b3IpO2Vsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcblx0ICAgICAgfSBlbHNlIGlmICghdmFsdWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IFtdO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhbHVlW2ldID0gdGhpcy5fcHJlcGFyZVNpbmdsZVZhbHVlKHZhbHVlW2ldKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9wcmVwYXJlU2luZ2xlVmFsdWUodmFsdWUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3ByZXBhcmVTaW5nbGVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuX3NldHRpbmdzLnR5cGU7XG5cdCAgICB2YXIgdGltZU1vZGUgPSB0eXBlID09IFwidGltZVwiOyAvL3NldFZhbHVlKFwiMTk4MC0xMi0yNVwiKVxuXG5cdCAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSkgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG5cblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSkge1xuXHQgICAgICB2YXIgZm9ybWF0RGF0ZSA9IG51bGw7XG5cblx0ICAgICAgaWYgKCh0eXBlID09IFwibW9udGhcIiB8fCB0eXBlID09IFwieWVhclwiKSAmJiB0aGlzLl9mb3JtYXREYXRlKSB7XG5cdCAgICAgICAgZm9ybWF0RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGU7XG5cdCAgICAgIH0gZWxzZSBmb3JtYXREYXRlID0gdGltZU1vZGUgPyBpMThuLnBhcnNlVGltZUZvcm1hdERhdGUgOiBpMThuLnBhcnNlRm9ybWF0RGF0ZTtcblxuXHQgICAgICB2YWx1ZSA9IGZvcm1hdERhdGUodmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgLy90aW1lIG1vZGVcblx0ICAgICAgaWYgKHRpbWVNb2RlKSB7XG5cdCAgICAgICAgLy9zZXRWYWx1ZShbMTYsMjRdKVxuXHQgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgICAgdGltZS5zZXRIb3Vycyh2YWx1ZVswXSk7XG5cdCAgICAgICAgICB0aW1lLnNldE1pbnV0ZXModmFsdWVbMV0pO1xuXHQgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSAvL3NldFZhbHVlKGludmFsaWQgZGF0ZSlcblxuXG5cdCAgICAgIGlmIChpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB2YWx1ZSA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9nZXRfdmlzaWJsZV90ZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCkge1xuXHQgICAgICByZXR1cm4gW10uY29uY2F0KHZhbHVlKS5tYXAoZnVuY3Rpb24gKGEpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZ2V0X3Zpc2libGVfdGV4dF9zaW5nbGUoYSk7XG5cdCAgICAgIH0uYmluZCh0aGlzKSkuam9pbih0aGlzLmNvbmZpZy5zZXBhcmF0b3IpO1xuXHQgICAgfSBlbHNlIHJldHVybiB0aGlzLl9nZXRfdmlzaWJsZV90ZXh0X3NpbmdsZSh2YWx1ZSk7XG5cdCAgfSxcblx0ICBfZ2V0X3Zpc2libGVfdGV4dF9zaW5nbGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHRpbWVNb2RlID0gdGhpcy5fc2V0dGluZ3MudHlwZSA9PSBcInRpbWVcIjtcblx0ICAgIHZhciB0aW1lcGlja2VyID0gdGhpcy5jb25maWcudGltZXBpY2tlcjtcblx0ICAgIHZhciBmb3JtYXRTdHIgPSB0aGlzLl9mb3JtYXRTdHIgfHwgKHRpbWVNb2RlID8gaTE4bi50aW1lRm9ybWF0U3RyIDogdGltZXBpY2tlciA/IGkxOG4uZnVsbERhdGVGb3JtYXRTdHIgOiBpMThuLmRhdGVGb3JtYXRTdHIpO1xuXHQgICAgcmV0dXJuIGZvcm1hdFN0cih2YWx1ZSk7XG5cdCAgfSxcblx0ICBfc2V0X3Zpc2libGVfdGV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG5vZGUgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXG5cdCAgICBpZiAobm9kZS52YWx1ZSA9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgbm9kZS5pbm5lckhUTUwgPSB0aGlzLl9zZXR0aW5ncy50ZXh0IHx8IHRoaXMuX2dldF9kaXZfcGxhY2Vob2xkZXIoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5vZGUudmFsdWUgPSB0aGlzLl9zZXR0aW5ncy50ZXh0IHx8IFwiXCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkY29tcGFyZVZhbHVlOiBmdW5jdGlvbiAob2xkdmFsdWUsIHZhbHVlKSB7XG5cdCAgICBpZiAoIW9sZHZhbHVlICYmICF2YWx1ZSkgcmV0dXJuIHRydWU7XG5cdCAgICByZXR1cm4gd0RhdGUuZXF1YWwob2xkdmFsdWUsIHZhbHVlKTtcblx0ICB9LFxuXHQgICRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy50ZXh0ID0gdmFsdWUgPyB0aGlzLl9nZXRfdmlzaWJsZV90ZXh0KHZhbHVlKSA6IFwiXCI7XG5cblx0ICAgIHRoaXMuX3NldF92aXNpYmxlX3RleHQoKTtcblx0ICB9LFxuXHQgIGZvcm1hdF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fZm9ybWF0U3RyID0gdmFsdWU7ZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fZm9ybWF0U3RyID0gd0RhdGUuZGF0ZVRvU3RyKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9mb3JtYXREYXRlID0gd0RhdGUuc3RyVG9EYXRlKHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHRoaXMuX2Zvcm1hdFN0ciA9IHRoaXMuX2Zvcm1hdERhdGUgPSBudWxsO1xuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5lZGl0YWJsZSA/IHRoaXMuX2RhdGFvYmouZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXSA6IHRoaXMuX2RhdGFvYmouZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJESVZcIilbMV07XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0KSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NldHRpbmdzLnZhbHVlO1xuXHQgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gW107XG5cdCAgICAgIHZhciByZXN1bHQgPSBbXS5jb25jYXQodmFsdWUpLm1hcChmdW5jdGlvbiAoYSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9nZXRfdmFsdWVfc2luZ2xlKGEpO1xuXHQgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc3RyaW5nUmVzdWx0KSByZXR1cm4gcmVzdWx0LmpvaW4odGhpcy5fc2V0dGluZ3Muc2VwYXJhdG9yKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX2dldF92YWx1ZV9zaW5nbGUodGhpcy5fc2V0dGluZ3MudmFsdWUpO1xuXHQgIH0sXG5cdCAgX2dldF92YWx1ZV9zaW5nbGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHR5cGUgPSB0aGlzLl9zZXR0aW5ncy50eXBlOyAvL3RpbWUgbW9kZVxuXG5cdCAgICB2YXIgdGltZU1vZGUgPSB0eXBlID09IFwidGltZVwiOyAvL2RhdGUgYW5kIHRpbWUgbW9kZVxuXG5cdCAgICB2YXIgdGltZXBpY2tlciA9IHRoaXMuY29uZmlnLnRpbWVwaWNrZXI7IC8vaW5wdXQgd2FzIG5vdCByZW5kZXJlZCwgd2UgbmVlZCB0byBwYXJzZSB2YWx1ZSBmcm9tIHNldFZhbHVlIG1ldGhvZFxuXG5cdCAgICBpZiAoIXRoaXMuX3JlbmRlcmVkX2lucHV0KSB2YWx1ZSA9IHRoaXMuJHByZXBhcmVWYWx1ZSh2YWx1ZSkgfHwgbnVsbDsgLy9yZW5kZXJlIGFuZCBpbiBlZGl0IG1vZGVcblx0ICAgIGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLmVkaXRhYmxlKSB7XG5cdCAgICAgICAgdmFyIGZvcm1hdERhdGUgPSB0aGlzLl9mb3JtYXREYXRlIHx8ICh0aW1lTW9kZSA/IGkxOG4udGltZUZvcm1hdERhdGUgOiB0aW1lcGlja2VyID8gaTE4bi5mdWxsRGF0ZUZvcm1hdERhdGUgOiBpMThuLmRhdGVGb3JtYXREYXRlKTtcblx0ICAgICAgICB2YWx1ZSA9IGZvcm1hdERhdGUodGhpcy5nZXRJbnB1dE5vZGUoKS52YWx1ZSk7XG5cdCAgICAgIH0gLy9yZXR1cm4gc3RyaW5nIGZyb20gZ2V0VmFsdWVcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnN0cmluZ1Jlc3VsdCkge1xuXHQgICAgICB2YXIgZm9ybWF0U3RyID0gaTE4bi5wYXJzZUZvcm1hdFN0cjtcblx0ICAgICAgaWYgKHRpbWVNb2RlKSBmb3JtYXRTdHIgPSBpMThuLnBhcnNlVGltZUZvcm1hdFN0cjtcblxuXHQgICAgICBpZiAodGhpcy5fZm9ybWF0U3RyICYmICh0eXBlID09IFwibW9udGhcIiB8fCB0eXBlID09IFwieWVhclwiKSkge1xuXHQgICAgICAgIGZvcm1hdFN0ciA9IHRoaXMuX2Zvcm1hdFN0cjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCkgcmV0dXJuIFtdLmNvbmNhdCh2YWx1ZSkubWFwKGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgICAgcmV0dXJuIGEgPyBmb3JtYXRTdHIoYSkgOiBcIlwiO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHZhbHVlID8gZm9ybWF0U3RyKHZhbHVlKSA6IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZSB8fCBudWxsO1xuXHQgIH0sXG5cdCAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG5vZGUgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXHQgICAgcmV0dXJuIG5vZGUgPyB0eXBlb2Ygbm9kZS52YWx1ZSA9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5nZXRWYWx1ZSgpID8gbm9kZS5pbm5lckhUTUwgOiBcIlwiIDogbm9kZS52YWx1ZSA6IFwiXCI7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRBID0gZXhwb3J0cy5wcm90b1VJKGFwaSRBLCB0ZXh0LnZpZXcpO1xuXHR2YXIgZGF0ZXBpY2tlciA9IHtcblx0ICBhcGk6IGFwaSRBLFxuXHQgIHZpZXc6IHZpZXckQVxuXHR9O1xuXG5cdHZhciBhcGkkQiA9IHtcblx0ICBuYW1lOiBcImNvbG9ycGlja2VyXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5faW5pdF9wb3B1cCk7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgaWNvbjogdHJ1ZVxuXHQgIH0sXG5cdCAgX2luaXRfcG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBvYmogPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGlmIChvYmouc3VnZ2VzdCkgb2JqLnBvcHVwID0gb2JqLnN1Z2dlc3Q7ZWxzZSBpZiAoIW9iai5wb3B1cCkgb2JqLnBvcHVwID0gb2JqLnN1Z2dlc3QgPSB0aGlzLnN1Z2dlc3Rfc2V0dGVyKHtcblx0ICAgICAgdHlwZTogXCJjb2xvcmJvYXJkXCIsXG5cdCAgICAgIGhlaWdodDogMjAwXG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5faW5pdF9vbmNlID0gZnVuY3Rpb24gKCkge307XG5cdCAgfSxcblx0ICAkcmVuZGVyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAoaXNVbmRlZmluZWQob2JqLnZhbHVlKSkgcmV0dXJuO1xuXHQgICAgb2JqLnZhbHVlID0gdGhpcy4kcHJlcGFyZVZhbHVlKG9iai52YWx1ZSk7XG5cdCAgICB0aGlzLiRzZXRWYWx1ZShvYmoudmFsdWUpO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9yZW5kZXJlZF9pbnB1dCAmJiB0aGlzLl9zZXR0aW5ncy5lZGl0YWJsZSkgcmV0dXJuIHRoaXMuZ2V0SW5wdXROb2RlKCkudmFsdWU7ZWxzZSByZXR1cm4gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgfSxcblx0ICAkcHJlcGFyZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jaGFyQXQgJiYgdmFsdWUuY2hhckF0KDApICE9IFwiI1wiKSB2YWx1ZSA9IFwiI1wiICsgdmFsdWU7XG5cdCAgICByZXR1cm4gdmFsdWUgfHwgXCJcIjtcblx0ICB9LFxuXHQgIF9nZXRDb2xvck5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLiR2aWV3LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRElWXCIpW3RoaXMuX3NldHRpbmdzLmVkaXRhYmxlID8gMSA6IDJdO1xuXHQgIH0sXG5cdCAgX2dldF92aXNpYmxlX3RleHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX2dldENvbG9yTm9kZSgpLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MudGV4dCA9IHZhbHVlO1xuXHQgICAgdmFyIG5vZGUgPSB0aGlzLmdldElucHV0Tm9kZSgpO1xuXHQgICAgaWYgKG5vZGUudmFsdWUgPT0gdW5kZWZpbmVkKSBub2RlLmlubmVySFRNTCA9IHZhbHVlO2Vsc2Ugbm9kZS52YWx1ZSA9IHZhbHVlO1xuXHQgIH0sXG5cdCAgJHJlbmRlckljb246IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZztcblx0ICAgIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcIndlYml4X2lucHV0X2ljb25cXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOlwiICsgY29uZmlnLnZhbHVlICsgXCI7XFxcIj4gPC9kaXY+XCI7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRCID0gZXhwb3J0cy5wcm90b1VJKGFwaSRCLCBkYXRlcGlja2VyLnZpZXcpO1xuXG5cdHZhciBhcGkkQyA9IHtcblx0ICBuYW1lOiBcInJpY2hzZWxlY3RcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICByZXR1cm4gY29tbW9uLl9yZW5kZXJfZGl2X2Jsb2NrKG9iaiwgY29tbW9uKTtcblx0ICAgIH0sXG5cdCAgICBwb3B1cFdpZHRoOiAyMDAsXG5cdCAgICBpY29uOiBcInd4aS1tZW51LWRvd25cIlxuXHQgIH0sXG5cdCAgX29uQmx1cjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRleHQgPT0gdGhpcy5nZXRUZXh0KCkgfHwgaXNVbmRlZmluZWQodGhpcy5fc2V0dGluZ3MudGV4dCkgJiYgIXRoaXMuZ2V0VGV4dCgpKSByZXR1cm47XG5cdCAgICB2YXIgc3VnZ2VzdCA9IHRoaXMuZ2V0UG9wdXAoKSxcblx0ICAgICAgICBub2RlVmFsdWUgPSB0aGlzLmdldElucHV0Tm9kZSgpLnZhbHVlLFxuXHQgICAgICAgIHZhbHVlID0gc3VnZ2VzdC5nZXRTdWdnZXN0aW9uKG5vZGVWYWx1ZSksXG5cdCAgICAgICAgb2xkdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7IC8vbm9uLWVtcHR5IHZhbHVlIHRoYXQgZGlmZmVycyBmcm9tIG9sZCB2YWx1ZSBhbmQgbWF0Y2hlcyBmaWx0ZXJpbmcgcnVsZVxuXG5cdCAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT0gb2xkdmFsdWUgJiYgIShub2RlVmFsdWUgPT09IFwiXCIgJiYgc3VnZ2VzdC5nZXRJdGVtVGV4dCh2YWx1ZSkgIT09IFwiXCIpKSB0aGlzLnNldFZhbHVlKHZhbHVlKTtlbHNlIGlmIChub2RlVmFsdWUgPT09IFwiXCIpIHRoaXMuc2V0VmFsdWUoXCJcIik7ZWxzZSBpZiAodGhpcy5fcmV2ZXJ0VmFsdWUpIHRoaXMuX3JldmVydFZhbHVlKCk7XG5cdCAgfSxcblx0ICBzdWdnZXN0X3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vcHRpb25zX3NldHRlcih2YWx1ZSk7XG5cdCAgfSxcblx0ICBvcHRpb25zX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHRoaXMuX3N1Z2dlc3RfY29uZmlnID8gdGhpcy5fc3VnZ2VzdF9jb25maWcodmFsdWUpIDogdmFsdWU7XG5cdCAgICB2YXIgc3VnZ2VzdCA9IHRoaXMuX3NldHRpbmdzLnBvcHVwID0gdGhpcy5fc2V0dGluZ3Muc3VnZ2VzdCA9IHRleHQuYXBpLnN1Z2dlc3Rfc2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuXHQgICAgdmFyIGxpc3QgPSAkJChzdWdnZXN0KS5nZXRMaXN0KCk7XG5cdCAgICBpZiAobGlzdCkgbGlzdC5hdHRhY2hFdmVudChcIm9uQWZ0ZXJMb2FkXCIsIGJpbmQodGhpcy5fcmVzZXRfdmFsdWUsIHRoaXMpKTtcblx0ICAgIHJldHVybiBzdWdnZXN0O1xuXHQgIH0sXG5cdCAgZ2V0TGlzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHN1Z2dlc3QgPSAkJCh0aGlzLl9zZXR0aW5ncy5zdWdnZXN0KTtcblx0ICAgIGFzc2VydChzdWdnZXN0LCBcIklucHV0IGRvZXNuJ3QgaGF2ZSBhIGxpc3RcIik7XG5cdCAgICByZXR1cm4gc3VnZ2VzdC5nZXRMaXN0KCk7XG5cdCAgfSxcblx0ICBfcGF0dGVybjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfcmVzZXRfdmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NldHRpbmdzLnZhbHVlOyAvL3RoaXMuX2RhdGFvYmouZmlyc3RDaGlsZCAtIGNoZWNrIHRoYXQgaW5wdXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgYXMgaW4gSUUxMSBpdCBjYW4gYmUgZGVzdHJveSBkdXJpbmcgcGFyZW50IHJlcGFpbnRpbmdcblxuXHQgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgIXRoaXMuZ2V0UG9wdXAoKS5pc1Zpc2libGUoKSAmJiAhdGhpcy5fc2V0dGluZ3MudGV4dCAmJiB0aGlzLl9kYXRhb2JqLmZpcnN0Q2hpbGQpIHRoaXMuJHNldFZhbHVlKHZhbHVlKTtcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmF1bHRzLmlucHV0UGFkZGluZyA9ICRhY3RpdmUuaW5wdXRQYWRkaW5nO1xuXHQgIH0sXG5cdCAgJHJlbmRlcjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgaWYgKGlzVW5kZWZpbmVkKG9iai52YWx1ZSkpIHJldHVybjtcblx0ICAgIHRoaXMuJHNldFZhbHVlKG9iai52YWx1ZSk7XG5cdCAgfSxcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRElWXCIpWzFdO1xuXHQgIH0sXG5cdCAgZ2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiAkJCh0aGlzLl9zZXR0aW5ncy5wb3B1cCk7XG5cdCAgfSxcblx0ICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLl9zZXR0aW5ncy52YWx1ZSxcblx0ICAgICAgICBub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblx0ICAgIGlmICghbm9kZSkgcmV0dXJuIHZhbHVlID8gdGhpcy5nZXRQb3B1cCgpLmdldEl0ZW1UZXh0KHZhbHVlKSA6IFwiXCI7XG5cblx0ICAgIGlmICh0eXBlb2Ygbm9kZS52YWx1ZSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQgJiYgbm9kZS5maXJzdENoaWxkLmNsYXNzTmFtZSA9PT0gXCJ3ZWJpeF9wbGFjZWhvbGRlclwiKSByZXR1cm4gXCJcIjtcblx0ICAgICAgcmV0dXJuIG5vZGUuaW5uZXJIVE1MO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbm9kZS52YWx1ZTtcblx0ICB9LFxuXHQgICRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXRoaXMuX3JlbmRlcmVkX2lucHV0KSByZXR1cm47XG5cdCAgICB2YXIgdGV4dCQkMSA9IHZhbHVlO1xuXHQgICAgdmFyIHBvcHVwID0gdGhpcy5nZXRQb3B1cCgpO1xuXHQgICAgaWYgKHBvcHVwKSB0ZXh0JCQxID0gdGhpcy5nZXRQb3B1cCgpLmdldEl0ZW1UZXh0KHZhbHVlKTtcblxuXHQgICAgaWYgKCF0ZXh0JCQxICYmIHZhbHVlICYmIHZhbHVlLmlkKSB7XG5cdCAgICAgIC8vYWRkIG5ldyB2YWx1ZVxuXHQgICAgICB2YXIgX3BvcHVwID0gdGhpcy5nZXRQb3B1cCgpO1xuXG5cdCAgICAgIHZhciBsaXN0ID0gX3BvcHVwLmdldExpc3QoKTsgLy8gYWRkIG5ldyBpdGVtIG9ubHkgd2hlbiBpdGVtIHdpdGggc3VjaCBpZCBkb2Vzbid0IGV4aXN0cyB5ZXRcblxuXG5cdCAgICAgIHZhciBleGlzdHMgPSBsaXN0LmV4aXN0cyh2YWx1ZS5pZCk7XG5cdCAgICAgIGlmICghZXhpc3RzKSBsaXN0LmFkZCh2YWx1ZSk7XG5cdCAgICAgIHRleHQkJDEgPSBfcG9wdXAuZ2V0SXRlbVRleHQodmFsdWUuaWQpOyAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgbGlzdCwgd2UgY2FuJ3QgYWRkIGV4dHJhIGl0ZW1zXG5cdCAgICAgIC8vIHRvIG5vdCBpbnRlcmZlcmUgd2l0aCBkeW5hbWljIGxvYWRpbmdcblxuXHQgICAgICBpZiAobGlzdC5fc2V0dGluZ3MuZHluYW1pYyAmJiAhZXhpc3RzKSBsaXN0LnJlbW92ZSh2YWx1ZS5pZCk7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnZhbHVlID0gdmFsdWUuaWQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBub2RlID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblx0ICAgIGlmIChpc1VuZGVmaW5lZChub2RlLnZhbHVlKSkgbm9kZS5pbm5lckhUTUwgPSB0ZXh0JCQxIHx8IHRoaXMuX2dldF9kaXZfcGxhY2Vob2xkZXIoKTtlbHNlIG5vZGUudmFsdWUgPSB0ZXh0JCQxID0gdGV4dCQkMS5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MudGV4dCA9IHRleHQkJDE7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnZhbHVlIHx8IFwiXCI7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRDID0gZXhwb3J0cy5wcm90b1VJKGFwaSRDLCB0ZXh0LnZpZXcpO1xuXHR2YXIgcmljaHNlbGVjdCA9IHtcblx0ICBhcGk6IGFwaSRDLFxuXHQgIHZpZXc6IHZpZXckQ1xuXHR9O1xuXG5cdHZhciBhcGkkRCA9IHtcblx0ICBuYW1lOiBcImNvbWJvXCIsXG5cdCAgZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGF0YW9iai5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuXHQgIH0sXG5cdCAgJHJlbmRlcjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgaWYgKGlzVW5kZWZpbmVkKG9iai52YWx1ZSkpIHJldHVybjtcblx0ICAgIHRoaXMuJHNldFZhbHVlKG9iai52YWx1ZSk7XG5cdCAgfSxcblx0ICBfcmV2ZXJ0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MuZWRpdGFibGUpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHQgICAgICB0aGlzLiRzZXRWYWx1ZShpc1VuZGVmaW5lZCh2YWx1ZSkgPyBcIlwiIDogdmFsdWUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2FwcGx5Q2hhbmdlczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dE5vZGUoKSxcblx0ICAgICAgICB2YWx1ZSA9IFwiXCIsXG5cdCAgICAgICAgc3VnZ2VzdCA9IHRoaXMuZ2V0UG9wdXAoKTtcblxuXHQgICAgaWYgKGlucHV0LnZhbHVlKSB7XG5cdCAgICAgIHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgICAgIGlmIChzdWdnZXN0LmdldEl0ZW1UZXh0KHZhbHVlKSAhPSB0aGlzLmdldFRleHQoKSkgdmFsdWUgPSBzdWdnZXN0LmdldFN1Z2dlc3Rpb24oKSB8fCB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHZhbHVlICE9IHRoaXMuX3NldHRpbmdzLnZhbHVlKSB0aGlzLnNldFZhbHVlKHZhbHVlLCB0cnVlKTtlbHNlIHRoaXMuJHNldFZhbHVlKHZhbHVlKTtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKGNvbmZpZywgY29tbW9uKSB7XG5cdCAgICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KGNvbmZpZykucmVwbGFjZSgvKDxpbnB1dClcXHMqKD89XFx3KS8sIFwiJDFcIiArIFwiIHJvbGU9J2NvbWJvYm94J1wiKTtcblx0ICAgIH0sXG5cdCAgICBpY29uOiBcInd4aS1tZW51LWRvd25cIlxuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckRCA9IGV4cG9ydHMucHJvdG9VSShhcGkkRCwgcmljaHNlbGVjdC52aWV3KTtcblxuXHR2YXIgYXBpJEUgPSB7XG5cdCAgbmFtZTogXCJjb3VudGVyXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAoY29uZmlnLCBjb21tb24pIHtcblx0ICAgICAgdmFyIHZhbHVlID0gY29uZmlnLnZhbHVlO1xuXHQgICAgICB2YXIgaWQgPSBcInhcIiArIHVpZCgpO1xuXHQgICAgICB2YXIgaHRtbCA9IFwiPGRpdiByb2xlPSdzcGluYnV0dG9uJyBhcmlhLWxhYmVsPSdcIiArIHRlbXBsYXRlLmVzY2FwZShjb25maWcubGFiZWwpICsgXCInIGFyaWEtdmFsdWVtaW49J1wiICsgY29uZmlnLm1pbiArIFwiJyBhcmlhLXZhbHVlbWF4PSdcIiArIGNvbmZpZy5tYXggKyBcIicgYXJpYS12YWx1ZW5vdz0nXCIgKyBjb25maWcudmFsdWUgKyBcIicgY2xhc3M9J3dlYml4X2VsX2dyb3VwJyBzdHlsZT0nd2lkdGg6XCIgKyBjb21tb24uX2dldF9pbnB1dF93aWR0aChjb25maWcpICsgXCJweCc+XCI7XG5cdCAgICAgIGh0bWwgKz0gXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3dlYml4X2lucF9jb3VudGVyX3ByZXYnIHRhYmluZGV4PSctMScgYXJpYS1sYWJlbD0nXCIgKyBpMThuLmFyaWEuZGVjcmVhc2VWYWx1ZSArIFwiJz4tPC9idXR0b24+XCI7XG5cdCAgICAgIGh0bWwgKz0gY29tbW9uLl9iYXNlSW5wdXRIVE1MKFwiaW5wdXRcIikgKyBcIiBpZD0nXCIgKyBpZCArIFwiJyB0eXBlPSd0ZXh0JyBjbGFzcz0nd2ViaXhfaW5wX2NvdW50ZXJfdmFsdWUnIGFyaWEtbGl2ZT0nYXNzZXJ0aXZlJ1wiICsgXCIgdmFsdWU9J1wiICsgdmFsdWUgKyBcIic+PC9pbnB1dD5cIjtcblx0ICAgICAgaHRtbCArPSBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nd2ViaXhfaW5wX2NvdW50ZXJfbmV4dCcgdGFiaW5kZXg9Jy0xJyBhcmlhLWxhYmVsPSdcIiArIGkxOG4uYXJpYS5pbmNyZWFzZVZhbHVlICsgXCInPis8L2J1dHRvbj48L2Rpdj5cIjtcblx0ICAgICAgcmV0dXJuIGNvbW1vbi4kcmVuZGVySW5wdXQoY29uZmlnLCBodG1sLCBpZCk7XG5cdCAgICB9LFxuXHQgICAgbWluOiAwLFxuXHQgICAgbWF4OiBJbmZpbml0eSxcblx0ICAgIHZhbHVlOiAwLFxuXHQgICAgc3RlcDogMVxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIF9ldmVudCh0aGlzLiR2aWV3LCBcImtleWRvd25cIiwgdGhpcy5fa2V5c2hpZnQsIHtcblx0ICAgICAgYmluZDogdGhpc1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfa2V5c2hpZnQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgY29kZSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlLFxuXHQgICAgICAgIGMgPSB0aGlzLl9zZXR0aW5ncyxcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuXHQgICAgaWYgKGNvZGUgPiAzMiAmJiBjb2RlIDwgNDEpIHtcblx0ICAgICAgaWYgKGNvZGUgPT09IDM2KSB2YWx1ZSA9IGMubWluO2Vsc2UgaWYgKGNvZGUgPT09IDM1KSB2YWx1ZSA9IGMubWF4ID09PSBJbmZpbml0eSA/IDEwMDAwMDAgOiBjLm1heDtlbHNlIGlmIChjb2RlID09PSAzMykgdGhpcy5uZXh0KCk7ZWxzZSBpZiAoY29kZSA9PT0gMzQpIHRoaXMucHJldigpO2Vsc2UgdmFsdWUgPSB2YWx1ZSArIChjb2RlID09PSAzNyB8fCBjb2RlID09PSA0MCA/IC0xIDogMSk7XG5cdCAgICAgIGlmIChjb2RlID4gMzQgJiYgdmFsdWUgPj0gYy5taW4gJiYgdmFsdWUgPD0gYy5tYXgpIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkudmFsdWUgPSB2YWx1ZTtcblx0ICB9LFxuXHQgICRwcmVwYXJlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblx0ICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG5cdCAgfSxcblx0ICB2YWx1ZV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHRoaXMuJHByZXBhcmVWYWx1ZSh2YWx1ZSk7XG5cdCAgfSxcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIGJ1dHRvbiQxLmFwaS5nZXRWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTtcblx0ICB9LFxuXHQgIG5leHQ6IGZ1bmN0aW9uIChzdGVwKSB7XG5cdCAgICBzdGVwID0gMSAqIChzdGVwIHx8IHRoaXMuX3NldHRpbmdzLnN0ZXApO1xuXHQgICAgdGhpcy5zaGlmdChzdGVwKTtcblx0ICB9LFxuXHQgIHByZXY6IGZ1bmN0aW9uIChzdGVwKSB7XG5cdCAgICBzdGVwID0gLTEgKiAoc3RlcCB8fCB0aGlzLl9zZXR0aW5ncy5zdGVwKTtcblx0ICAgIHRoaXMuc2hpZnQoc3RlcCk7XG5cdCAgfSxcblx0ICBzaGlmdDogZnVuY3Rpb24gKHN0ZXApIHtcblx0ICAgIHZhciBtaW4gPSB0aGlzLl9zZXR0aW5ncy5taW47XG5cdCAgICB2YXIgbWF4ID0gdGhpcy5fc2V0dGluZ3MubWF4O1xuXHQgICAgdmFyIG5ld192YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKSArIHN0ZXA7XG5cdCAgICBpZiAobmV3X3ZhbHVlID49IG1pbiAmJiBuZXdfdmFsdWUgPD0gbWF4KSB0aGlzLnNldFZhbHVlKG5ld192YWx1ZSk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRFID0gZXhwb3J0cy5wcm90b1VJKGFwaSRFLCB0ZXh0LnZpZXcpO1xuXG5cdHZhciBhcGkkRiA9IHtcblx0ICBuYW1lOiBcImljb25cIixcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZhdWx0cy5oZWlnaHQgPSAkYWN0aXZlLmlucHV0SGVpZ2h0O1xuXHQgICAgdGhpcy5kZWZhdWx0cy53aWR0aCA9ICRhY3RpdmUuaW5wdXRIZWlnaHQ7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIHZpZXcpIHtcblx0ICAgICAgdmFyIG1pbiA9IE1hdGgubWluKG9iai5hd2lkdGgsIG9iai5haGVpZ2h0KTtcblx0ICAgICAgdmFyIHRvcCA9IE1hdGgucm91bmQoKHZpZXcuX2NvbnRlbnRfaGVpZ2h0IC0gb2JqLmFoZWlnaHQpIC8gMik7XG5cdCAgICAgIHZhciBpbm5lciA9IFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIHN0eWxlPSdoZWlnaHQ6XCIgKyBtaW4gKyBcInB4O3dpZHRoOlwiICsgbWluICsgXCJweDsnIGNsYXNzPSd3ZWJpeF9pY29uX2J1dHRvbic+XCIgKyBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIFwiICsgb2JqLmljb24gKyBcIic+PC9zcGFuPjwvYnV0dG9uPlwiO1xuXHQgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9lbF9ib3gnIHN0eWxlPSd3aWR0aDpcIiArIG9iai5hd2lkdGggKyBcInB4O2hlaWdodDpcIiArIG9iai5haGVpZ2h0ICsgXCJweDtsaW5lLWhlaWdodDpcIiArIG9iai5haGVpZ2h0ICsgXCJweDttYXJnaW4tdG9wOlwiICsgdG9wICsgXCJweCc+XCIgKyBpbm5lciArIChvYmouYmFkZ2UgPyBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9iYWRnZSc+XCIgKyBvYmouYmFkZ2UgKyBcIjwvc3Bhbj5cIiA6IFwiXCIpICsgXCI8L2Rpdj5cIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zZXRfaW5uZXJfc2l6ZTogZnVuY3Rpb24gKCkge30sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7fVxuXHR9O1xuXHR2YXIgdmlldyRGID0gZXhwb3J0cy5wcm90b1VJKGFwaSRGLCBidXR0b24kMS52aWV3KTtcblxuXHR2YXIgYXBpJEcgPSB7XG5cdCAgbmFtZTogXCJzZWFyY2hcIixcblx0ICBvbl9jbGljazoge1xuXHQgICAgXCJ3ZWJpeF9pbnB1dF9pY29uXCI6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHRoaXMuZ2V0SW5wdXROb2RlKCkuZm9jdXMoKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNlYXJjaEljb25DbGlja1wiLCBbZV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmYXVsdHMuaW5wdXRQYWRkaW5nID0gJGFjdGl2ZS5pbnB1dFBhZGRpbmc7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdHlwZTogXCJ0ZXh0XCIsXG5cdCAgICBpY29uOiBcInd4aS1zZWFyY2hcIlxuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckRyA9IGV4cG9ydHMucHJvdG9VSShhcGkkRywgdGV4dC52aWV3KTtcblxuXHR2YXIgYXBpJEggPSB7XG5cdCAgbmFtZTogXCJzZWdtZW50ZWRcIixcblx0ICAkYWxsb3dzQ2xlYXI6IGZhbHNlLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25DaGFuZ2VcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aXZpZXcpIHRoaXMuX3Nob3dfdmlldyh2YWx1ZSk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIG9uY2UoZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubXVsdGl2aWV3ICYmIHRoaXMuX3NldHRpbmdzLnZhbHVlKSB0aGlzLl9zaG93X3ZpZXcodGhpcy5fc2V0dGluZ3MudmFsdWUpO1xuXHQgICAgfSkpO1xuXHQgIH0sXG5cdCAgX3Nob3dfdmlldzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgdG9wID0gdGhpcy5nZXRUb3BQYXJlbnRWaWV3KCk7XG5cdCAgICB2YXIgdmlldyA9IG51bGw7IC8vZ2V0IGZyb20gbG9jYWwgaXNvbGF0ZVxuXG5cdCAgICBpZiAodG9wICYmIHRvcC4kJCkgdmlldyA9IHRvcC4kJCh2YWx1ZSk7IC8vb3IgY2hlY2sgZ2xvYmFsbHlcblxuXHQgICAgaWYgKCF2aWV3KSB2aWV3ID0gJCQodmFsdWUpO1xuXHQgICAgaWYgKHZpZXcgJiYgdmlldy5zaG93KSB2aWV3LnNob3coKTtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgIGlmICghb2JqLm9wdGlvbnMpIGFzc2VydChmYWxzZSwgXCJzZWdtZW50ZWQ6IG9wdGlvbnMgdW5kZWZpbmVkXCIpO1xuXHQgICAgICB2YXIgb3B0aW9ucyA9IG9iai5vcHRpb25zO1xuXG5cdCAgICAgIGNvbW1vbi5fY2hlY2tfb3B0aW9ucyhvcHRpb25zKTtcblxuXHQgICAgICBvcHRpb25zID0gY29tbW9uLl9maWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xuXG5cdCAgICAgIHZhciB3aWR0aCA9IGNvbW1vbi5fZ2V0X2lucHV0X3dpZHRoKG9iaik7XG5cblx0ICAgICAgdmFyIGlkID0gdWlkKCk7XG5cdCAgICAgIHZhciBodG1sID0gXCI8ZGl2IHN0eWxlPSd3aWR0aDpcIiArIHdpZHRoICsgXCJweCcgY2xhc3M9J3dlYml4X2FsbF9zZWdtZW50cycgcm9sZT0ndGFibGlzdCcgYXJpYS1sYWJlbD0nXCIgKyB0ZW1wbGF0ZS5lc2NhcGUob2JqLmxhYmVsKSArIFwiJz5cIjtcblx0ICAgICAgdmFyIG9wdGlvbldpZHRoID0gb2JqLm9wdGlvbldpZHRoIHx8IE1hdGguZmxvb3Iod2lkdGggLyBvcHRpb25zLmxlbmd0aCk7XG5cdCAgICAgIGlmICghb2JqLnZhbHVlKSBvYmoudmFsdWUgPSBvcHRpb25zWzBdLmlkO1xuXHQgICAgICB2YXIgdG9vbHRpcDtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0b29sdGlwID0gb2JqLnRvb2x0aXAgPyBcIiB3ZWJpeF90X2lkPSdcIiArIG9wdGlvbnNbaV0uaWQgKyBcIidcIiA6IFwiXCI7XG5cdCAgICAgICAgaHRtbCArPSBcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBzdHlsZT0nd2lkdGg6XCIgKyAob3B0aW9uc1tpXS53aWR0aCB8fCBvcHRpb25XaWR0aCkgKyBcInB4JyByb2xlPSd0YWInIGFyaWEtc2VsZWN0ZWQ9J1wiICsgKG9iai52YWx1ZSA9PSBvcHRpb25zW2ldLmlkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCInIHRhYmluZGV4PSdcIiArIChvYmoudmFsdWUgPT0gb3B0aW9uc1tpXS5pZCA/IFwiMFwiIDogXCItMVwiKSArIFwiJ1wiO1xuXHQgICAgICAgIGh0bWwgKz0gXCJjbGFzcz0nXCIgKyBcIndlYml4X3NlZ21lbnRfXCIgKyAoaSA9PSBvcHRpb25zLmxlbmd0aCAtIDEgPyBcIk5cIiA6IGkgPiAwID8gMSA6IDApICsgKG9iai52YWx1ZSA9PSBvcHRpb25zW2ldLmlkID8gXCIgd2ViaXhfc2VsZWN0ZWQgXCIgOiBcIlwiKSArIFwiJyBidXR0b25faWQ9J1wiICsgb3B0aW9uc1tpXS5pZCArIFwiJ1wiICsgdG9vbHRpcCArIFwiPlwiO1xuXHQgICAgICAgIGh0bWwgKz0gb3B0aW9uc1tpXS52YWx1ZSArIFwiPC9idXR0b24+XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gY29tbW9uLiRyZW5kZXJJbnB1dChvYmosIGh0bWwgKyBcIjwvZGl2PlwiLCBpZCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy4kdmlldy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkJVVFRPTlwiKTtcblx0ICB9LFxuXHQgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZm9jdXMoKTtcblx0ICB9LFxuXHQgIGJsdXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2JsdXIoKTtcblx0ICB9LFxuXHQgICRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX2dldElucHV0Tm9kZSgpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGlkID0gb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJidXR0b25faWRcIik7XG5cdCAgICAgIG9wdGlvbnNbaV0uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCB2YWx1ZSA9PSBpZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblx0ICAgICAgb3B0aW9uc1tpXS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB2YWx1ZSA9PSBpZCA/IFwiMFwiIDogXCItMVwiKTtcblx0ICAgICAgaWYgKHZhbHVlID09IGlkKSBhZGRDc3Mob3B0aW9uc1tpXSwgXCJ3ZWJpeF9zZWxlY3RlZFwiKTtlbHNlIHJlbW92ZUNzcyhvcHRpb25zW2ldLCBcIndlYml4X3NlbGVjdGVkXCIpO1xuXHQgICAgfSAvL3JlZnJlc2ggdGFiYmFyIGlmIHRoZSBvcHRpb24gaXMgaW4gdGhlIHBvcHVwIGxpc3RcblxuXG5cdCAgICB2YXIgcG9wdXAgPSB0aGlzLmNvbmZpZy50YWJiYXJQb3B1cDtcblx0ICAgIGlmIChwb3B1cCAmJiAkJChwb3B1cCkgJiYgJCQocG9wdXApLmdldEJvZHkoKS5leGlzdHModmFsdWUpKSB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgfSxcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgb3B0aW9uSW5kZXg6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIHBhZ2VzID0gdGhpcy5fc2V0dGluZ3Mub3B0aW9ucztcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAocGFnZXNbaV0uaWQgPT0gaWQpIHJldHVybiBpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfSxcblx0ICBhZGRPcHRpb246IGZ1bmN0aW9uIChpZCwgdmFsdWUsIHNob3csIGluZGV4JCQxKSB7XG5cdCAgICB2YXIgb2JqID0gaWQ7XG5cblx0ICAgIGlmIChfdHlwZW9mKGlkKSAhPSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIHZhbHVlID0gdmFsdWUgfHwgaWQ7XG5cdCAgICAgIG9iaiA9IHtcblx0ICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZCA9IG9iai5pZDtcblx0ICAgICAgaW5kZXgkJDEgPSBzaG93O1xuXHQgICAgICBzaG93ID0gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbkluZGV4KGlkKSA8IDApIFBvd2VyQXJyYXkuaW5zZXJ0QXQuY2FsbCh0aGlzLl9zZXR0aW5ncy5vcHRpb25zLCBvYmosIGluZGV4JCQxKTtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgaWYgKHNob3cpIHRoaXMuc2V0VmFsdWUoaWQpO1xuXHQgIH0sXG5cdCAgcmVtb3ZlT3B0aW9uOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBpbmRleCQkMSA9IHRoaXMub3B0aW9uSW5kZXgoaWQpO1xuXHQgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncy5vcHRpb25zO1xuXHQgICAgaWYgKGluZGV4JCQxID49IDApIFBvd2VyQXJyYXkucmVtb3ZlQXQuY2FsbChvcHRpb25zLCBpbmRleCQkMSk7IC8vIGlmIHdlIHJlbW92ZSBhIHNlbGVjdGVkIG9wdGlvblxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudmFsdWUgPT0gaWQpIHRoaXMuX3NldE5leHRWaXNpYmxlKG9wdGlvbnMsIGluZGV4JCQxKTtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbk9wdGlvblJlbW92ZVwiLCBbaWQsIHRoaXMuX3NldHRpbmdzLnZhbHVlXSk7XG5cdCAgfSxcblx0ICBfc2V0TmV4dFZpc2libGU6IGZ1bmN0aW9uIChvcHRpb25zLCBpbmRleCQkMSkge1xuXHQgICAgdmFyIHNpemUgPSBvcHRpb25zLmxlbmd0aDtcblxuXHQgICAgaWYgKHNpemUpIHtcblx0ICAgICAgaW5kZXgkJDEgPSBNYXRoLm1pbihpbmRleCQkMSwgc2l6ZSAtIDEpOyAvL2ZvcndhcmQgc2VhcmNoXG5cblx0ICAgICAgZm9yICh2YXIgaSA9IGluZGV4JCQxOyBpIDwgc2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zW2ldLmhpZGRlbikgcmV0dXJuIHRoaXMuc2V0VmFsdWUob3B0aW9uc1tpXS5pZCk7XG5cdCAgICAgIH0gLy9iYWNrd2FyZCBzZWFyY2hcblxuXG5cdCAgICAgIGZvciAodmFyIF9pID0gaW5kZXgkJDE7IF9pID49IDA7IF9pLS0pIHtcblx0ICAgICAgICBpZiAoIW9wdGlvbnNbX2ldLmhpZGRlbikgcmV0dXJuIHRoaXMuc2V0VmFsdWUob3B0aW9uc1tfaV0uaWQpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vbm90aGluZyBmb3VuZFx0XHRcblxuXG5cdCAgICB0aGlzLnNldFZhbHVlKFwiXCIpO1xuXHQgIH0sXG5cdCAgX2ZpbHRlck9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICB2YXIgY29weSQkMSA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKCFvcHRpb25zW2ldLmhpZGRlbikgY29weSQkMS5wdXNoKG9wdGlvbnNbaV0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY29weSQkMTtcblx0ICB9LFxuXHQgIF9zZXRPcHRpb25WaXNpYmlsaXR5OiBmdW5jdGlvbiAoaWQsIHN0YXRlKSB7XG5cdCAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3NldHRpbmdzLm9wdGlvbnM7XG5cdCAgICB2YXIgaW5kZXgkJDEgPSB0aGlzLm9wdGlvbkluZGV4KGlkKTtcblx0ICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2luZGV4JCQxXTtcblxuXHQgICAgaWYgKG9wdGlvbiAmJiBzdGF0ZSA9PSAhIW9wdGlvbi5oaWRkZW4pIHtcblx0ICAgICAgLy9uZXcgc3RhdGUgZGlmZmVycyBmcm9tIHByZXZpb3VzIG9uZVxuXHQgICAgICBvcHRpb24uaGlkZGVuID0gIXN0YXRlO1xuXG5cdCAgICAgIGlmIChzdGF0ZSB8fCB0aGlzLl9zZXR0aW5ncy52YWx1ZSAhPSBpZCkge1xuXHQgICAgICAgIC8vc2hvdyBpdGVtLCBubyBuZWVkIGZvciBleHRyYSBzdGVwc1xuXHQgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vaGlkZSBpdGVtLCBzd2l0Y2ggdG8gbmV4dCB2aXNpYmxlIG9uZVxuXHQgICAgICAgIHRoaXMuX3NldE5leHRWaXNpYmxlKG9wdGlvbnMsIGluZGV4JCQxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgaGlkZU9wdGlvbjogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB0aGlzLl9zZXRPcHRpb25WaXNpYmlsaXR5KGlkLCBmYWxzZSk7XG5cdCAgfSxcblx0ICBzaG93T3B0aW9uOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMuX3NldE9wdGlvblZpc2liaWxpdHkoaWQsIHRydWUpO1xuXHQgIH0sXG5cdCAgX3NldF9pbm5lcl9zaXplOiBmYWxzZVxuXHR9O1xuXHR2YXIgdmlldyRIID0gZXhwb3J0cy5wcm90b1VJKGFwaSRILCB0ZXh0LnZpZXcsIEhUTUxPcHRpb25zKTtcblx0dmFyIHNlZ21lbnRlZCA9IHtcblx0ICBhcGk6IGFwaSRILFxuXHQgIHZpZXc6IHZpZXckSFxuXHR9O1xuXG5cdHZhciBhcGkkSSA9IHtcblx0ICBuYW1lOiBcInRleHRhcmVhXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgdmFyIG5hbWUgPSBvYmoubmFtZSB8fCBvYmouaWQ7XG5cdCAgICAgIHZhciBpZCA9IFwieFwiICsgdWlkKCk7XG5cdCAgICAgIHZhciBodG1sID0gY29tbW9uLl9iYXNlSW5wdXRIVE1MKFwidGV4dGFyZWFcIikgKyBcInN0eWxlPSd3aWR0aDpcIiArIGNvbW1vbi5fZ2V0X2lucHV0X3dpZHRoKG9iaikgKyBcInB4OydcIjtcblx0ICAgICAgaHRtbCArPSBcIiBpZD0nXCIgKyBpZCArIFwiJyBuYW1lPSdcIiArIG5hbWUgKyBcIicgY2xhc3M9J3dlYml4X2lucF90ZXh0YXJlYSc+XCIgKyBjb21tb24uX3BhdHRlcm4ob2JqLnZhbHVlKSArIFwiPC90ZXh0YXJlYT5cIjtcblx0ICAgICAgcmV0dXJuIGNvbW1vbi4kcmVuZGVySW5wdXQob2JqLCBodG1sLCBpZCk7XG5cdCAgICB9LFxuXHQgICAgaGVpZ2h0OiAwLFxuXHQgICAgbWluSGVpZ2h0OiA2MFxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmYXVsdHMuaW5wdXRQYWRkaW5nID0gJGFjdGl2ZS5pbnB1dFBhZGRpbmc7XG5cdCAgICB0aGlzLl9pbnB1dFNwYWNpbmcgPSAkYWN0aXZlLmlucHV0U3BhY2luZztcblx0ICB9LFxuXHQgIF9za2lwU3VibWl0OiB0cnVlLFxuXHQgIF9nZXRMYWJlbEhlaWdodDogZnVuY3Rpb24gKHRvcCkge1xuXHQgICAgcmV0dXJuIHRvcCA/IHRoaXMuX2xhYmVsVG9wSGVpZ2h0IC0gdGhpcy5fc2V0dGluZ3MuaW5wdXRQYWRkaW5nIDogXCJcIjtcblx0ICB9LFxuXHQgIC8vZ2V0IGlucHV0IGVsZW1lbnRcblx0ICBnZXRJbnB1dE5vZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kYXRhb2JqLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGV4dGFyZWFcIilbMF07XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRJID0gZXhwb3J0cy5wcm90b1VJKGFwaSRJLCB0ZXh0LnZpZXcpO1xuXG5cdHZhciBhcGkkSiA9IHtcblx0ICBuYW1lOiBcInRvZ2dsZVwiLFxuXHQgICRhbGxvd3NDbGVhcjogdHJ1ZSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uSXRlbUNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy50b2dnbGUoKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXROb2RlKCk7XG5cdCAgICB2YXIgb2JqID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICB2YXIgaXNQcmVzc2VkID0gdmFsdWUgJiYgdmFsdWUgIT0gXCIwXCI7XG5cdCAgICB2YXIgdGV4dCA9IChpc1ByZXNzZWQgPyBvYmoub25MYWJlbCA6IG9iai5vZmZMYWJlbCkgfHwgb2JqLmxhYmVsO1xuXHQgICAgdmFyIHRleHROb2RlID0gaW5wdXQubGFzdENoaWxkO1xuXHQgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiYXJpYS1wcmVzc2VkXCIsIGlzUHJlc3NlZCA/IFwidHJ1ZVwiIDogZmFsc2UpO1xuXHQgICAgaW5wdXQudmFsdWUgPSB0ZXh0O1xuXHQgICAgaWYgKHRleHROb2RlKSAodGV4dE5vZGUuZmlyc3RDaGlsZCB8fCB0ZXh0Tm9kZSkubm9kZVZhbHVlID0gdGV4dDsgLy9pY29uIG9yIGltYWdlIGJ1dHRvblxuXG5cdCAgICBpZiAoaW5wdXQuZmlyc3RDaGlsZCAmJiBpbnB1dC5maXJzdENoaWxkLm5vZGVOYW1lID09PSBcIlNQQU5cIiAmJiBvYmoub25JY29uICYmIG9iai5vZmZJY29uICYmIG9iai5vbkljb24gIT09IG9iai5vZmZJY29uKSBpbnB1dC5maXJzdENoaWxkLmNsYXNzTmFtZSA9IGlucHV0LmZpcnN0Q2hpbGQuY2xhc3NOYW1lLnJlcGxhY2UoaXNQcmVzc2VkID8gb2JqLm9mZkljb24gOiBvYmoub25JY29uLCBpc1ByZXNzZWQgPyBvYmoub25JY29uIDogb2JqLm9mZkljb24pO1xuXHQgICAgdmFyIHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGU7XG5cdCAgICBpZiAoaXNQcmVzc2VkKSBhZGRDc3MocGFyZW50LCBcIndlYml4X3ByZXNzZWRcIik7ZWxzZSByZW1vdmVDc3MocGFyZW50LCBcIndlYml4X3ByZXNzZWRcIik7XG5cdCAgfSxcblx0ICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuc2V0VmFsdWUoIXRoaXMuZ2V0VmFsdWUoKSk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlID09IFwiMFwiID8gMCA6IDE7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICB2YXIgaXNQcmVzc2VkID0gb2JqLnZhbHVlICYmIG9iai52YWx1ZSAhPSBcIjBcIjtcblx0ICAgICAgdmFyIGNzcyA9IGlzUHJlc3NlZCA/IFwiIHdlYml4X3ByZXNzZWRcIiA6IFwiXCI7XG5cdCAgICAgIG9iai5sYWJlbCA9IChpc1ByZXNzZWQgPyBvYmoub25MYWJlbCA6IG9iai5vZmZMYWJlbCkgfHwgb2JqLmxhYmVsO1xuXHQgICAgICBvYmouaWNvbiA9IChpc1ByZXNzZWQgPyBvYmoub25JY29uIDogb2JqLm9mZkljb24pIHx8IG9iai5pY29uO1xuXHQgICAgICB2YXIgaHRtbCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfZWxfYm94XCIgKyBjc3MgKyBcIicgc3R5bGU9J3dpZHRoOlwiICsgb2JqLmF3aWR0aCArIFwicHg7IGhlaWdodDpcIiArIG9iai5haGVpZ2h0ICsgXCJweCc+XCIgKyBjb21tb24uJHJlbmRlcklucHV0KG9iaiwgY29tbW9uKSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoLyhidXR0b24pXFxzKig/PVxcdykvLCBcIiQxXCIgKyAoXCIgYXJpYS1wcmVzc2VkPSdcIiArIChpc1ByZXNzZWQgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIicgXCIpKTtcblx0ICAgICAgaWYgKG9iai5iYWRnZSkgaHRtbCA9IGh0bWwucmVwbGFjZSgvPFxcL2Rpdj4kLywgXCI8c3BhbiBjbGFzcz0nd2ViaXhfYmFkZ2UnPlwiICsgb2JqLmJhZGdlICsgXCI8L3NwYW4+PC9kaXY+XCIpO1xuXHQgICAgICByZXR1cm4gaHRtbDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zZXRfaW5uZXJfc2l6ZTogZmFsc2Vcblx0fTtcblx0dmFyIHZpZXckSiA9IGV4cG9ydHMucHJvdG9VSShhcGkkSiwgYnV0dG9uJDEudmlldyk7XG5cblx0dmFyIGFwaSRLID0ge1xuXHQgIG5hbWU6IFwibXVsdGl0ZXh0XCIsXG5cdCAgJGNzc05hbWU6IFwidGV4dFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBpY29uOiBcInd4aS1wbHVzLWNpcmNsZVwiLFxuXHQgICAgaWNvbldpZHRoOiAyNSxcblx0ICAgIHNlcGFyYXRvcjogXCIsIFwiXG5cdCAgfSxcblx0ICBnZXRWYWx1ZUhlcmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0ZXh0LmFwaS5nZXRWYWx1ZS5jYWxsKHRoaXMpO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWVIZXJlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0ZXh0LmFwaS4kc2V0VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuY29uZmlnLm1vZGUgPT0gXCJleHRyYVwiKSByZXR1cm4gdGhpcy5nZXRWYWx1ZUhlcmUoKTtcblx0ICAgIGlmICh0aGlzLl9mdWxsX3ZhbHVlKSByZXR1cm4gdGhpcy5fZnVsbF92YWx1ZTtcblx0ICAgIHZhciB2YWx1ZXMgPSBbdGhpcy5nZXRWYWx1ZUhlcmUodGhpcyldO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHNlZyA9ICQkKHRoaXMuX3N1YnNbaV0pLmdldFZhbHVlSGVyZSgpO1xuXHQgICAgICBpZiAoc2VnKSB2YWx1ZXMucHVzaChzZWcpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWVzLmpvaW4odGhpcy5jb25maWcuc2VwYXJhdG9yKTtcblx0ICB9LFxuXHQgICRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHZhbHVlIHx8IFwiXCI7XG5cdCAgICBpZiAodGhpcy5jb25maWcubW9kZSA9PSBcImV4dHJhXCIpIHJldHVybiB0aGlzLnNldFZhbHVlSGVyZSh2YWx1ZSk7XG5cdCAgICB0aGlzLl9mdWxsX3ZhbHVlID0gdmFsdWU7XG5cdCAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCh0aGlzLmNvbmZpZy5zZXBhcmF0b3IpO1xuXG5cdCAgICBpZiAocGFydHMubGVuZ3RoID09IHRoaXMuX3N1YnMubGVuZ3RoICsgMSkge1xuXHQgICAgICB0aGlzLnNldFZhbHVlSGVyZShwYXJ0c1swXSk7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgJCQodGhpcy5fc3Vic1tpXSkuc2V0VmFsdWVIZXJlKHBhcnRzW2kgKyAxXSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9mdWxsX3ZhbHVlID0gXCJcIjtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbW92ZVNlY3Rpb24oKTtcblx0ICAgIHRoaXMuc2V0VmFsdWVIZXJlLmNhbGwodGhpcywgcGFydHNbMF0pO1xuXG5cdCAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgcGFydHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIHRoaXMuYWRkU2VjdGlvbihwYXJ0c1tfaV0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9mdWxsX3ZhbHVlID0gXCJcIjtcblx0ICB9LFxuXHQgIF9zdWJPbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuY29uZmlnLm1hc3RlciA/ICQkKHRoaXMuY29uZmlnLm1hc3RlcikgOiB0aGlzO1xuXHQgICAgdmFyIG5ld3ZhbHVlID0gcGFyZW50LmdldFZhbHVlKCk7XG5cdCAgICB2YXIgb2xkdmFsdWUgPSBwYXJlbnQuX3NldHRpbmdzLnZhbHVlO1xuXG5cdCAgICBpZiAobmV3dmFsdWUgIT09IG9sZHZhbHVlKSB7XG5cdCAgICAgIHBhcmVudC5fc2V0dGluZ3MudmFsdWUgPSBuZXd2YWx1ZTtcblx0ICAgICAgcGFyZW50LmNhbGxFdmVudChcIm9uQ2hhbmdlXCIsIFtuZXd2YWx1ZSwgb2xkdmFsdWVdKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGFkZFNlY3Rpb246IGZ1bmN0aW9uICh0ZXh0JCQxKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcsXG5cdCAgICAgICAgbmV3Q29uZmlnID0ge1xuXHQgICAgICBsYWJlbFdpZHRoOiBjb25maWcubGFiZWxXaWR0aCxcblx0ICAgICAgaW5wdXRXaWR0aDogY29uZmlnLmlucHV0V2lkdGgsXG5cdCAgICAgIHdpZHRoOiBjb25maWcud2lkdGgsXG5cdCAgICAgIGxhYmVsOiBjb25maWcubGFiZWwgPyBcIiZuYnNwO1wiIDogXCJcIixcblx0ICAgICAgdmlldzogdGhpcy5uYW1lLFxuXHQgICAgICBtb2RlOiBcImV4dHJhXCIsXG5cdCAgICAgIHZhbHVlOiB0ZXh0JCQxIHx8IFwiXCIsXG5cdCAgICAgIGljb246IFwid3hpLW1pbnVzLWNpcmNsZVwiLFxuXHQgICAgICB0b29sdGlwOiBjb25maWcudG9vbHRpcCxcblx0ICAgICAgc3VnZ2VzdDogY29uZmlnLnN1Z2dlc3QgfHwgbnVsbCxcblx0ICAgICAgbWFzdGVyOiBjb25maWcuaWRcblx0ICAgIH07XG5cdCAgICBleHBvcnRzLmV4dGVuZChuZXdDb25maWcsIGNvbmZpZy5zdWJDb25maWcgfHwge30sIHRydWUpO1xuXHQgICAgdmFyIG5ld29uZSA9IHRoaXMuZ2V0UGFyZW50VmlldygpLmFkZFZpZXcobmV3Q29uZmlnKTtcblx0ICAgICQkKG5ld29uZSkuYXR0YWNoRXZlbnQoXCJvbkNoYW5nZVwiLCB0aGlzLl9zdWJPbkNoYW5nZSk7XG5cblx0ICAgIHRoaXMuX3N1YnMucHVzaChuZXdvbmUpO1xuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU2VjdGlvbkFkZFwiLCBbbmV3b25lLCB0aGlzLl9zdWJzLmxlbmd0aF0pO1xuXHQgICAgcmV0dXJuIG5ld29uZTtcblx0ICB9LFxuXHQgIHJlbW92ZVNlY3Rpb246IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIHBhcmVudCA9IHRoaXMuY29uZmlnLm1hc3RlciA/ICQkKHRoaXMuY29uZmlnLm1hc3RlcikgOiB0aGlzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gcGFyZW50Ll9zdWJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciBzZWN0aW9uID0gcGFyZW50Ll9zdWJzW2ldO1xuXG5cdCAgICAgIGlmICghaWQgfHwgc2VjdGlvbiA9PSBpZCkge1xuXHQgICAgICAgIHBhcmVudC5fc3Vicy5yZW1vdmVBdChpKTtcblxuXHQgICAgICAgIHRoaXMuZ2V0UGFyZW50VmlldygpLnJlbW92ZVZpZXcoc2VjdGlvbik7XG5cdCAgICAgICAgcGFyZW50LmNhbGxFdmVudChcIm9uU2VjdGlvblJlbW92ZVwiLCBbc2VjdGlvbiwgaSArIDFdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fY2xpY2s6IHtcblx0ICAgIFwid2ViaXhfaW5wdXRfaWNvblwiOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLmNvbmZpZy5tb2RlID09IFwiZXh0cmFcIikge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlU2VjdGlvbih0aGlzLmNvbmZpZy5pZCk7XG5cdCAgICAgICAgdmFyIGNoaWxkcyA9IHRoaXMuZ2V0UGFyZW50VmlldygpLmdldENoaWxkVmlld3MoKTtcblx0ICAgICAgICBjaGlsZHNbY2hpbGRzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG5cblx0ICAgICAgICB0aGlzLl9zdWJPbkNoYW5nZSgpO1xuXHQgICAgICB9IGVsc2UgJCQodGhpcy5hZGRTZWN0aW9uKCkpLmZvY3VzKCk7XG5cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3N1YnMgPSB0b0FycmF5KFtdKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbktleVByZXNzXCIsIHRoaXMuX29uS2V5UHJlc3MpO1xuXHQgIH0sXG5cdCAgJHJlbmRlcjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdGhpcy4kc2V0VmFsdWUob2JqLnZhbHVlKTtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JEsgPSBleHBvcnRzLnByb3RvVUkoYXBpJEssIHRleHQudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcIm11bHRpc2VsZWN0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBtdWx0aXNlbGVjdCA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJtdWx0aWNvbWJvXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBtdWx0aWNvbWJvIDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0dmFyIGFwaSRMID0ge1xuXHQgIG5hbWU6IFwic2xpZGVyXCIsXG5cdCAgJHRvdWNoQ2FwdHVyZTogdHJ1ZSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgbWluOiAwLFxuXHQgICAgbWF4OiAxMDAsXG5cdCAgICB2YWx1ZTogNTAsXG5cdCAgICBzdGVwOiAxLFxuXHQgICAgdGl0bGU6IGZhbHNlLFxuXHQgICAgbW92ZVRpdGxlOiB0cnVlLFxuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICB2YXIgaWQgPSBjb21tb24uX2hhbmRsZV9pZCA9IFwieFwiICsgdWlkKCk7XG5cdCAgICAgIHZhciBodG1sID0gXCJcIjtcblx0ICAgICAgdmFyIHRpdGxlID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9zbGlkZXJfdGl0bGVcIiArIChvYmoubW92ZVRpdGxlID8gXCIgd2ViaXhfc2xpZGVyX21vdmVcIiA6IFwiXCIpICsgXCInXCIgKyAoIW9iai5tb3ZlVGl0bGUgJiYgb2JqLnZlcnRpY2FsID8gXCIgc3R5bGU9J2xpbmUtaGVpZ2h0OlwiICsgKG9iai5haGVpZ2h0IC0gb2JqLmlucHV0UGFkZGluZyAqIDIpICsgXCJweDsnXCIgOiBcIlwiKSArIFwiPjwvZGl2PlwiO1xuXHQgICAgICB2YXIgbGVmdCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfc2xpZGVyX2xlZnQnPiZuYnNwOzwvZGl2PlwiO1xuXHQgICAgICB2YXIgcmlnaHQgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3NsaWRlcl9yaWdodCc+PC9kaXY+XCI7XG5cdCAgICAgIHZhciBoYW5kbGUgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3NsaWRlcl9oYW5kbGUnIHdlYml4X2Rpc2FibGVfZHJhZz0ndHJ1ZScgcm9sZT0nc2xpZGVyJyBhcmlhLWxhYmVsPSdcIiArIG9iai5sYWJlbCArIChvYmoudGl0bGUgPyBcIiBcIiArIG9iai50aXRsZShvYmopIDogXCJcIikgKyBcIicgYXJpYS12YWx1ZW1heD0nXCIgKyBvYmoubWF4ICsgXCInIGFyaWEtdmFsdWVtaW49J1wiICsgb2JqLm1pbiArIFwiJyBhcmlhLXZhbHVlbm93PSdcIiArIG9iai52YWx1ZSArIFwiJyB0YWJpbmRleD0nMCcgaWQ9J1wiICsgaWQgKyBcIic+Jm5ic3A7PC9kaXY+XCI7XG5cdCAgICAgIGlmIChvYmoudmVydGljYWwpIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3NsaWRlcl9ib3gnPlwiICsgcmlnaHQgKyBsZWZ0ICsgaGFuZGxlICsgXCI8L2Rpdj5cIiArIHRpdGxlO2Vsc2UgaHRtbCA9IHRpdGxlICsgXCI8ZGl2IGNsYXNzPSd3ZWJpeF9zbGlkZXJfYm94Jz5cIiArIGxlZnQgKyByaWdodCArIGhhbmRsZSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KG9iaiwgaHRtbCwgaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgdHlwZV9zZXR0ZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICB0aGlzLl92aWV3b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9zbGlkZXJfXCIgKyB0eXBlO1xuXHQgIH0sXG5cdCAgdGl0bGVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHRlbXBsYXRlKHZhbHVlKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9nZXRfc2xpZGVyX2hhbmRsZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuJHZpZXcucXVlcnlTZWxlY3RvcihcIi53ZWJpeF9zbGlkZXJfaGFuZGxlXCIpO1xuXHQgIH0sXG5cdCAgX3NldF9pbm5lcl9zaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaGFuZGxlID0gdGhpcy5fZ2V0X3NsaWRlcl9oYW5kbGUoKTtcblxuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoaGFuZGxlKSB7XG5cdCAgICAgIC8vdmlldyBpcyByZW5kZXJlZCBmb3Igc3VyZVxuXHQgICAgICB2YXIgc2l6ZSA9IGNvbmZpZy52ZXJ0aWNhbCA/IHRoaXMuX2NvbnRlbnRfaGVpZ2h0IDogdGhpcy5fZ2V0X2lucHV0X3dpZHRoKGNvbmZpZyk7IC8vd2lkdGggb3IgaGVpZ2h0XG5cblx0ICAgICAgdmFyIHZhbHVlID0gY29uZmlnLnZhbHVlICUgY29uZmlnLnN0ZXAgPyBNYXRoLnJvdW5kKGNvbmZpZy52YWx1ZSAvIGNvbmZpZy5zdGVwKSAqIGNvbmZpZy5zdGVwIDogY29uZmlnLnZhbHVlO1xuXHQgICAgICB2YXIgbWF4ID0gY29uZmlnLm1heCAtIGNvbmZpZy5taW47XG5cdCAgICAgIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIGNvbmZpZy5tYXgpLCBjb25maWcubWluKTtcblx0ICAgICAgdmFsdWUgPSBjb25maWcudmVydGljYWwgPyBtYXggLSAodmFsdWUgLSBjb25maWcubWluKSA6IHZhbHVlIC0gY29uZmlnLm1pbjsgLy90b3Agb3IgbGVmdFxuXG5cdCAgICAgIHZhciBjb3JuZXIxID0gTWF0aC5jZWlsKChzaXplIC0gMiAqIHRoaXMuX3NsaWRlclBhZGRpbmcpICogdmFsdWUgLyBtYXgpOyAvL2JvdHRvbSBvciByaWdodFxuXG5cdCAgICAgIHZhciBjb3JuZXIyID0gc2l6ZSAtIDIgKiB0aGlzLl9zbGlkZXJQYWRkaW5nIC0gY29ybmVyMTtcblx0ICAgICAgdmFyIGNvcm5lclN0ciA9IGNvbmZpZy52ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIjtcblx0ICAgICAgdmFyIHNpemVTdHIgPSBjb25maWcudmVydGljYWwgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuXHQgICAgICBoYW5kbGUuc3R5bGVbY29ybmVyU3RyXSA9IHRoaXMuX3NsaWRlclBhZGRpbmcgKyBjb3JuZXIxIC0gdGhpcy5fc2xpZGVySGFuZGxlV2lkdGggLyAyICsgXCJweFwiO1xuXHQgICAgICBoYW5kbGUucGFyZW50Tm9kZS5zdHlsZVtzaXplU3RyXSA9IHNpemUgKyBcInB4XCI7IC8vMXB4IGJvcmRlclxuXG5cdCAgICAgIGNvcm5lcjIgPSBNYXRoLm1pbihNYXRoLm1heChjb3JuZXIyLCAyICogdGhpcy5fc2xpZGVyQm9yZGVyKSwgc2l6ZSAtIHRoaXMuX3NsaWRlclBhZGRpbmcgKiAyIC0gMiAqIHRoaXMuX3NsaWRlckJvcmRlcik7XG5cdCAgICAgIGNvcm5lcjEgPSBNYXRoLm1pbihNYXRoLm1heChjb3JuZXIxLCAyICogdGhpcy5fc2xpZGVyQm9yZGVyKSwgc2l6ZSAtIHRoaXMuX3NsaWRlclBhZGRpbmcgKiAyIC0gMiAqIHRoaXMuX3NsaWRlckJvcmRlcik7IC8vd2lkdGggZm9yIGxlZnQvdG9wIGFuZCByaWdodC9ib3R0b20gYmFyc1xuXG5cdCAgICAgIHZhciBwYXJ0ID0gaGFuZGxlLnByZXZpb3VzU2libGluZztcblx0ICAgICAgcGFydC5zdHlsZVtzaXplU3RyXSA9IGNvcm5lcjIgKyBcInB4XCI7XG5cdCAgICAgIHZhciBsYXN0ID0gcGFydC5wcmV2aW91c1NpYmxpbmc7XG5cdCAgICAgIGxhc3Quc3R5bGVbc2l6ZVN0cl0gPSBjb3JuZXIxICsgXCJweFwiO1xuXG5cdCAgICAgIHRoaXMuX3NldF90aXRsZShoYW5kbGUsIGNvcm5lcjEsIGNvcm5lcjIsIGNvcm5lclN0cik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfc2V0X3RpdGxlOiBmdW5jdGlvbiAoaGFuZGxlLCBjb3JuZXIxLCBjb3JuZXIyLCBjb3JuZXJTdHIpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRpdGxlKSB7XG5cdCAgICAgIHZhciB0aXRsZSA9IGhhbmRsZS5wYXJlbnROb2RlW2NvbmZpZy52ZXJ0aWNhbCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCJdO1xuXHQgICAgICB0aXRsZS5pbm5lckhUTUwgPSB0aGlzLl9zZXR0aW5ncy50aXRsZSh0aGlzLl9zZXR0aW5ncywgdGhpcyk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1vdmVUaXRsZSkge1xuXHQgICAgICAgIHZhciBwb3MkJDEgPSAwO1xuXHQgICAgICAgIGlmIChjb25maWcudmVydGljYWwpIHBvcyQkMSA9IGNvcm5lcjEgKyAyICogdGhpcy5fc2xpZGVyQm9yZGVyIC0gdGhpcy5fc2xpZGVySGFuZGxlV2lkdGggLyAyO2Vsc2Uge1xuXHQgICAgICAgICAgdmFyIGhhbGYgPSB0aXRsZS5jbGllbnRXaWR0aCAvIDI7XG5cdCAgICAgICAgICB2YXIgcG9zMSA9IGhhbGYgPiBjb3JuZXIxID8gaGFsZiAtIGNvcm5lcjEgLSAyICogdGhpcy5fc2xpZGVyQm9yZGVyIDogMDsgLy9sZWZ0L3RvcCB0ZXh0IGlzIHRvIGxhcmdlXG5cblx0ICAgICAgICAgIHZhciBwb3MyID0gaGFsZiA+IGNvcm5lcjIgPyBoYWxmIC0gY29ybmVyMiAtIDIgKiB0aGlzLl9zbGlkZXJCb3JkZXIgLSB0aGlzLl9zbGlkZXJIYW5kbGVXaWR0aCAvIDIgOiAwOyAvL3JpZ2h0L2JvdHRvbSB0ZXh0IGlzIHRvbyBsYXJnZVxuXG5cdCAgICAgICAgICBwb3MkJDEgPSB0aGlzLl9zbGlkZXJQYWRkaW5nICsgY29ybmVyMSAtIGhhbGYgKyBwb3MxIC0gcG9zMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGl0bGUuc3R5bGVbY29ybmVyU3RyXSA9IHBvcyQkMSArIFwicHhcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NldF92YWx1ZV9ub3c6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2dldF9zbGlkZXJfaGFuZGxlKCkuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCB0aGlzLl9zZXR0aW5ncy52YWx1ZSk7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaGFuZGxlID0gdGhpcy5fZ2V0X3NsaWRlcl9oYW5kbGUoKTtcblxuXHQgICAgaWYgKGhhbmRsZSkge1xuXHQgICAgICB0aGlzLl9zZXRfdmFsdWVfbm93KCk7XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRpdGxlKSBoYW5kbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9zZXR0aW5ncy5sYWJlbCArIFwiIFwiICsgdGhpcy5fc2V0dGluZ3MudGl0bGUodGhpcy5fc2V0dGluZ3MsIHRoaXMpKTtcblxuXHQgICAgICB0aGlzLl9zZXRfaW5uZXJfc2l6ZSgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgdmFsdWVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0aGlzLiRwcmVwYXJlVmFsdWUodmFsdWUpO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgICRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnZhbHVlO1xuXHQgIH0sXG5cdCAgJHByZXBhcmVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXHQgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBpZiAoZW52LnRvdWNoKSB0aGlzLmF0dGFjaEV2ZW50KFwib25Ub3VjaFN0YXJ0XCIsIGJpbmQodGhpcy5fb25fbW91c2VfZG93bl9zdGFydCwgdGhpcykpO2Vsc2UgX2V2ZW50KHRoaXMuX3ZpZXdvYmosIFwibW91c2Vkb3duXCIsIGJpbmQodGhpcy5fb25fbW91c2VfZG93bl9zdGFydCwgdGhpcykpO1xuXG5cdCAgICBfZXZlbnQodGhpcy4kdmlldywgXCJrZXlkb3duXCIsIGJpbmQodGhpcy5faGFuZGxlX21vdmVfa2V5Ym9hcmQsIHRoaXMpKTtcblxuXHQgICAgaWYgKGNvbmZpZy52ZXJ0aWNhbCkge1xuXHQgICAgICBjb25maWcuaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCAkYWN0aXZlLnZTbGlkZXJIZWlnaHQ7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X3NsaWRlcl92ZXJ0aWNhbFwiO1xuXHQgICAgICB0aGlzLl9zbGlkZXJQYWRkaW5nID0gJGFjdGl2ZS52U2xpZGVyUGFkZGluZztcblx0ICAgIH1cblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9zbGlkZXJIYW5kbGVXaWR0aCA9ICRhY3RpdmUuc2xpZGVySGFuZGxlV2lkdGg7IC8vOCAtIHdpZHRoIG9mIGhhbmRsZSAvIDJcblxuXHQgICAgdGhpcy5fc2xpZGVyUGFkZGluZyA9ICRhY3RpdmUuc2xpZGVyUGFkZGluZzsgLy8xMCAtIHBhZGRpbmcgb2Ygd2ViaXhfc2xpZGVyX2JveCAoIDIwID0gMTAqMiApXG5cblx0ICAgIHRoaXMuX3NsaWRlckJvcmRlciA9ICRhY3RpdmUuc2xpZGVyQm9yZGVyOyAvLzFweCBib3JkZXJcblx0ICB9LFxuXHQgIF9oYW5kbGVfbW92ZV9rZXlib2FyZDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBjb2RlID0gZS5rZXlDb2RlLFxuXHQgICAgICAgIGMgPSB0aGlzLl9zZXR0aW5ncyxcblx0ICAgICAgICB2YWx1ZSA9IGMudmFsdWU7XG5cblx0ICAgIGlmIChjb2RlID4gMzIgJiYgY29kZSA8IDQxKSB7XG5cdCAgICAgIHByZXZlbnRFdmVudChlKTtcblx0ICAgICAgdmFyIHRyZyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0ICAgICAgdmFyIG1hdGNoID0gL3dlYml4X3NsaWRlcl9oYW5kbGVfKFxcZCkvLmV4ZWModHJnLmNsYXNzTmFtZSk7XG5cdCAgICAgIHRoaXMuX2FjdGl2ZUluZGV4ID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogLTE7XG5cdCAgICAgIGlmIChtYXRjaCkgdmFsdWUgPSBjLnZhbHVlW3RoaXMuX2FjdGl2ZUluZGV4XTtcblx0ICAgICAgdmFsdWUgPSB2YWx1ZSA8IGMubWluID8gYy5taW4gOiB2YWx1ZSA+IGMubWF4ID8gYy5tYXggOiB2YWx1ZTtcblx0ICAgICAgaWYgKGNvZGUgPT09IDM2KSB2YWx1ZSA9IGMubWluO2Vsc2UgaWYgKGNvZGUgPT09IDM1KSB2YWx1ZSA9IGMubWF4O2Vsc2Uge1xuXHQgICAgICAgIHZhciBpbmMgPSBjb2RlID09PSAzNyB8fCBjb2RlID09PSA0MCB8fCBjb2RlID09PSAzNCA/IC0xIDogMTtcblx0ICAgICAgICBpZiAoY29kZSA9PT0gMzMgfHwgY29kZSA9PT0gMzQgfHwgYy5zdGVwID4gMSkgaW5jID0gaW5jICogYy5zdGVwO1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxICsgaW5jO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgdmFyIG90aGVyID0gYy52YWx1ZVt0aGlzLl9hY3RpdmVJbmRleCA/IDAgOiAxXTtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2FjdGl2ZUluZGV4ICYmIHZhbHVlIDw9IG90aGVyIHx8ICF0aGlzLl9hY3RpdmVJbmRleCAmJiB2YWx1ZSA+PSBvdGhlciA/IG90aGVyIDogdmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodmFsdWUgPj0gYy5taW4gJiYgdmFsdWUgPD0gYy5tYXgpIHtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgIHZhciB0ZW1wID0gW107XG5cblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy52YWx1ZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0ZW1wW2ldID0gaSA9PT0gdGhpcy5fYWN0aXZlSW5kZXggPyB2YWx1ZSA6IGMudmFsdWVbaV07XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHZhbHVlID0gdGVtcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcblx0ICAgICAgICB0aGlzLl9hY3RpdmVJbmRleCA9IC0xO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25fbW91c2VfZG93bl9zdGFydDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciB0cmcgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cblx0ICAgIGlmICh0aGlzLl9tb3VzZV9kb3duX3Byb2Nlc3MpIHtcblx0ICAgICAgdGhpcy5fbW91c2VfZG93bl9wcm9jZXNzKGUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLl9zZXR0aW5ncy52YWx1ZTtcblx0ICAgIGlmIChpc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBjb3B5KHZhbHVlKTtcblxuXHQgICAgaWYgKHRyZy5jbGFzc05hbWUuaW5kZXhPZihcIndlYml4X3NsaWRlcl9oYW5kbGVcIikgIT0gLTEpIHtcblx0ICAgICAgdGhpcy5fc3RhcnRfdmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0X2hhbmRsZV9kbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH0gZWxzZSBpZiAodHJnLmNsYXNzTmFtZS5pbmRleE9mKFwid2ViaXhfc2xpZGVyXCIpICE9IC0xKSB7XG5cdCAgICAgIHRoaXMuX3N0YXJ0X3ZhbHVlID0gdmFsdWU7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnZhbHVlID0gdGhpcy5fZ2V0X3ZhbHVlX2Zyb21fZXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHQgICAgICB0aGlzLl9zdGFydF9oYW5kbGVfZG5kKGUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3N0YXJ0X2hhbmRsZV9kbmQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChlbnYudG91Y2gpIHtcblx0ICAgICAgdGhpcy5faGFuZGxlX2RyYWdfZXZlbnRzID0gW3RoaXMuYXR0YWNoRXZlbnQoXCJvblRvdWNoTW92ZVwiLCBiaW5kKHRoaXMuX2hhbmRsZV9tb3ZlX3Byb2Nlc3MsIHRoaXMpKSwgdGhpcy5hdHRhY2hFdmVudChcIm9uVG91Y2hFbmRcIiwgYmluZCh0aGlzLl9oYW5kbGVfbW92ZV9zdG9wLCB0aGlzKSldO1xuXHQgICAgfSBlbHNlIHRoaXMuX2hhbmRsZV9kcmFnX2V2ZW50cyA9IFtldmVudCQxKGRvY3VtZW50LmJvZHksIFwibW91c2Vtb3ZlXCIsIGJpbmQodGhpcy5faGFuZGxlX21vdmVfcHJvY2VzcywgdGhpcykpLCBldmVudCQxKHdpbmRvdywgXCJtb3VzZXVwXCIsIGJpbmQodGhpcy5faGFuZGxlX21vdmVfc3RvcCwgdGhpcykpXTtcblxuXHQgICAgYWRkQ3NzKGRvY3VtZW50LmJvZHksIFwid2ViaXhfbm9zZWxlY3RcIik7XG5cdCAgfSxcblx0ICBfaGFuZGxlX21vdmVfc3RvcDogZnVuY3Rpb24gKCkge1xuXHQgICAgLy9kZXRhY2ggZXZlbnQgaGFuZGxlcnNcblx0ICAgIGlmICh0aGlzLl9oYW5kbGVfZHJhZ19ldmVudHMpIHtcblx0ICAgICAgaWYgKGVudi50b3VjaCkge1xuXHQgICAgICAgIHRoaXMuZGV0YWNoRXZlbnQodGhpcy5faGFuZGxlX2RyYWdfZXZlbnRzWzBdKTtcblx0ICAgICAgICB0aGlzLmRldGFjaEV2ZW50KHRoaXMuX2hhbmRsZV9kcmFnX2V2ZW50c1sxXSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXZlbnRSZW1vdmUodGhpcy5faGFuZGxlX2RyYWdfZXZlbnRzWzBdKTtcblx0ICAgICAgICBldmVudFJlbW92ZSh0aGlzLl9oYW5kbGVfZHJhZ19ldmVudHNbMV0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5faGFuZGxlX2RyYWdfZXZlbnRzID0gW107XG5cdCAgICB9XG5cblx0ICAgIHJlbW92ZUNzcyhkb2N1bWVudC5ib2R5LCBcIndlYml4X25vc2VsZWN0XCIpO1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cdCAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHZhbHVlID0gY29weSh2YWx1ZSk7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy52YWx1ZSA9IHRoaXMuX3N0YXJ0X3ZhbHVlO1xuXHQgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG5cblx0ICAgIHRoaXMuX2dldF9zbGlkZXJfaGFuZGxlKHRoaXMuX2FjdGl2ZUluZGV4KS5mb2N1cygpO1xuXG5cdCAgICB0aGlzLl9hY3RpdmVJbmRleCA9IC0xO1xuXHQgIH0sXG5cdCAgX2hhbmRsZV9tb3ZlX3Byb2Nlc3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3NldHRpbmdzLnZhbHVlID0gdGhpcy5fZ2V0X3ZhbHVlX2Zyb21fZXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNsaWRlckRyYWdcIiwgW10pO1xuXHQgIH0sXG5cdCAgX2dldF92YWx1ZV9mcm9tX2V2ZW50OiBmdW5jdGlvbiAoZXZlbnQsIHRvdWNoQ29udGV4dCkge1xuXHQgICAgLy8gdGhpcyBtZXRob2QgdGFrZXMgMiBhcmd1bWVudHMgaW4gY2FzZSBvZiB0b3VjaCBlbnZcblx0ICAgIHZhciBwb3MkJDEgPSAwO1xuXHQgICAgdmFyIGF4ID0gdGhpcy5fc2V0dGluZ3MudmVydGljYWwgPyBcInlcIiA6IFwieFwiO1xuXHQgICAgaWYgKGVudi50b3VjaCkgcG9zJCQxID0gdG91Y2hDb250ZXh0ID8gdG91Y2hDb250ZXh0W2F4XSA6IGV2ZW50W2F4XTtlbHNlIHBvcyQkMSA9IHBvcyhldmVudClbYXhdO1xuXHQgICAgcmV0dXJuIHRoaXMuX2dldF92YWx1ZV9mcm9tX3Bvcyhwb3MkJDEpO1xuXHQgIH0sXG5cdCAgX2dldF92YWx1ZV9mcm9tX3BvczogZnVuY3Rpb24gKHBvcyQkMSkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgdmFyIG1heCA9IGNvbmZpZy5tYXggLSBjb25maWcubWluO1xuXHQgICAgdmFyIGF4ID0gY29uZmlnLnZlcnRpY2FsID8gXCJ5XCIgOiBcInhcIjsgLy90b3Agb3IgbGVmdCBkZXBlbmRpbmcgb24gc2xpZGVyIHR5cGVcblxuXHQgICAgdmFyIGNvcm5lciA9IG9mZnNldCh0aGlzLl9nZXRfc2xpZGVyX2hhbmRsZSgpLnBhcmVudE5vZGUpW2F4XSArIHRoaXMuX3NsaWRlclBhZGRpbmc7IC8vaGVpZ2h0IG9yIHdpZHRoIGRlcGVuZGluZyBvbiBzbGlkZXIgdHlwZVxuXG5cblx0ICAgIHZhciBzaXplID0gKGNvbmZpZy52ZXJ0aWNhbCA/IHRoaXMuX2NvbnRlbnRfaGVpZ2h0IDogdGhpcy5fZ2V0X2lucHV0X3dpZHRoKGNvbmZpZykpIC0gMiAqIHRoaXMuX3NsaWRlclBhZGRpbmc7XG5cdCAgICB2YXIgbmV3dmFsdWUgPSBzaXplID8gKHBvcyQkMSAtIGNvcm5lcikgKiBtYXggLyBzaXplIDogMDtcblx0ICAgIGlmIChjb25maWcudmVydGljYWwpIG5ld3ZhbHVlID0gbWF4IC0gbmV3dmFsdWU7XG5cdCAgICBuZXd2YWx1ZSA9IE1hdGgucm91bmQoKG5ld3ZhbHVlICsgMSAqIGNvbmZpZy5taW4pIC8gY29uZmlnLnN0ZXApICogY29uZmlnLnN0ZXA7XG5cdCAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obmV3dmFsdWUsIGNvbmZpZy5tYXgpLCBjb25maWcubWluKTtcblx0ICB9LFxuXHQgIF9pbml0X29uY2hhbmdlOiBmdW5jdGlvbiAoKSB7fSAvL25lZWQgbm90IHVpLnRleHQgbG9naWNcblxuXHR9O1xuXHR2YXIgdmlldyRMID0gZXhwb3J0cy5wcm90b1VJKGFwaSRMLCB0ZXh0LnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJyYW5nZXNsaWRlclwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogXCJHUEwgdmVyc2lvbiBkb2Vzbid0IHN1cHBvcnQgcmFuZ2VzbGlkZXIgPGJyPiBZb3UgbmVlZCBXZWJpeCBQUk9cIlxuXHQgIH1cblx0fSwgdGVtcGxhdGUkMS52aWV3KTtcblxuXHR2YXIgYXBpJE0gPSB7XG5cdCAgbmFtZTogXCJzd2l0Y2hcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChjb25maWcsIGNvbW1vbikge1xuXHQgICAgICBjb21tb24uX2NhbGNrX3N3aXRjaF9zaXplKCk7XG5cblx0ICAgICAgdmFyIGlkID0gY29uZmlnLm5hbWUgfHwgXCJ4XCIgKyB1aWQoKTtcblx0ICAgICAgdmFyIHJpZ2h0bGFiZWwgPSBcIlwiO1xuXG5cdCAgICAgIGlmIChjb25maWcubGFiZWxSaWdodCkge1xuXHQgICAgICAgIHJpZ2h0bGFiZWwgPSBcIjxsYWJlbCBjbGFzcz0nd2ViaXhfbGFiZWxfcmlnaHQnPlwiICsgY29uZmlnLmxhYmVsUmlnaHQgKyBcIjwvbGFiZWw+XCI7XG5cdCAgICAgICAgaWYgKGNvbmZpZy5sYWJlbFdpZHRoKSBjb25maWcubGFiZWwgPSBjb25maWcubGFiZWwgfHwgXCImbmJzcDtcIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBjaGVja2VkID0gY29uZmlnLmNoZWNrVmFsdWUgPT0gY29uZmlnLnZhbHVlO1xuXHQgICAgICB2YXIgYXJpYSA9IFwiYXJpYS1sYWJlbD1cXFwiXCIgKyAoY29uZmlnLmxhYmVsIHx8IGNvbmZpZy5sYWJlbFJpZ2h0IHx8IFwiXCIpICsgXCJcXFwiIHJvbGU9XFxcImNoZWNrYm94XFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgYXJpYS1jaGVja2VkPVxcXCJcIiArIChjaGVja2VkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCJcXFwiIFwiICsgKGNvbmZpZy5yZWFkb25seSA/IFwiYXJpYS1yZWFkb25seT0ndHJ1ZSdcIiA6IFwiXCIpICsgXCJcXFwiXCI7XG5cdCAgICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPVxcXCJ3ZWJpeF9zd2l0Y2hfYm94IFwiICsgKGNoZWNrZWQgPyBcIiB3ZWJpeF9zd2l0Y2hfb25cIiA6IFwiXCIpICsgXCJcXFwiIHN0eWxlPVxcXCJ3aWR0aDpcIiArIGNvbW1vbi5fc3dpdGNoV2lkdGggKyBcInB4XFxcIj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcIndlYml4X3N3aXRjaF90ZXh0XFxcIj5cIiArICgoY2hlY2tlZCA/IGNvbmZpZy5vbkxhYmVsIDogY29uZmlnLm9mZkxhYmVsKSB8fCBcIlwiKSArIFwiPC9zcGFuPlwiICsgXCI8YnV0dG9uIGNsYXNzPVxcXCJ3ZWJpeF9zd2l0Y2hfaGFuZGxlXFxcIiBcIiArIGFyaWEgKyBcIiBzdHlsZT1cXFwibGVmdDpcIiArIChjaGVja2VkID8gY29tbW9uLl9zd2l0Y2hXaWR0aCAtIGNvbW1vbi5fc3dpdGNoSGVpZ2h0IDogMCkgKyBcInB4O1xcXCI+XCIgKyBcIjxpbnB1dCAgaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIgY2xhc3M9XFxcIndlYml4X3N3aXRjaF90b2dnbGVcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBcIiArIChjaGVja2VkID8gXCJjaGVja2VkXCIgOiBcIlwiKSArIFwiPjwvYnV0dG9uPlwiICsgXCI8L2Rpdj5cIiArIHJpZ2h0bGFiZWw7XG5cdCAgICAgIHJldHVybiBjb21tb24uJHJlbmRlcklucHV0KGNvbmZpZywgaHRtbCwgaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3N3aXRjaEhlaWdodCA9ICRhY3RpdmUuc3dpdGNoSGVpZ2h0O1xuXHQgICAgdGhpcy5fc3dpdGNoV2lkdGggPSAkYWN0aXZlLnN3aXRjaFdpZHRoO1xuXHQgIH0sXG5cdCAgJHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHZhciBjaGVja2VkID0gdmFsdWUgPT0gY29uZmlnLmNoZWNrVmFsdWU7XG5cdCAgICB2YXIgYm94ID0gdGhpcy4kdmlldy5xdWVyeVNlbGVjdG9yKFwiLndlYml4X3N3aXRjaF9ib3hcIik7XG5cblx0ICAgIGlmIChib3gpIHtcblx0ICAgICAgdmFyIGhhbmRsZSA9IGJveC5jaGlsZE5vZGVzWzFdO1xuXHQgICAgICB2YXIgdGV4dCA9IChjaGVja2VkID8gY29uZmlnLm9uTGFiZWwgOiBjb25maWcub2ZmTGFiZWwpIHx8IFwiXCI7XG5cdCAgICAgIGlmIChjaGVja2VkKSBhZGRDc3MoYm94LCBcIndlYml4X3N3aXRjaF9vblwiKTtlbHNlIHJlbW92ZUNzcyhib3gsIFwid2ViaXhfc3dpdGNoX29uXCIpO1xuXHQgICAgICBoYW5kbGUuc3R5bGUubGVmdCA9IChjaGVja2VkID8gdGhpcy5fc3dpdGNoV2lkdGggLSB0aGlzLl9zd2l0Y2hIZWlnaHQgOiAwKSArIFwicHhcIjtcblx0ICAgICAgaGFuZGxlLmZpcnN0Q2hpbGQuY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdCAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNoZWNrZWRcIiwgY2hlY2tlZCA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblxuXHQgICAgICBpZiAodGV4dCkge1xuXHQgICAgICAgIGJveC5jaGlsZE5vZGVzWzBdLmlubmVySFRNTCA9IHRleHQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jYWxja19zd2l0Y2hfc2l6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoY29uZmlnLm9uTGFiZWwgfHwgY29uZmlnLm9mZkxhYmVsKSB7XG5cdCAgICAgIHZhciBvbldpZHRoID0gY29uZmlnLm9uTGFiZWwgPyBnZXRUZXh0U2l6ZShjb25maWcub25MYWJlbCwgXCJ3ZWJpeF9zd2l0Y2hfdGV4dFwiKS53aWR0aCA6IDA7XG5cdCAgICAgIHZhciBvZmZXaWR0aCA9IGNvbmZpZy5vbkxhYmVsID8gZ2V0VGV4dFNpemUoY29uZmlnLm9mZkxhYmVsLCBcIndlYml4X3N3aXRjaF90ZXh0XCIpLndpZHRoIDogMDtcblx0ICAgICAgdGhpcy5fc3dpdGNoV2lkdGggPSBNYXRoLm1heChvbldpZHRoLCBvZmZXaWR0aCkgKyB0aGlzLl9zd2l0Y2hIZWlnaHQ7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBvbl9jbGljazoge1xuXHQgICAgXCJ3ZWJpeF9zd2l0Y2hfYm94XCI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5yZWFkb25seSkgdGhpcy50b2dnbGUoKTtcblx0ICAgIH0sXG5cdCAgICBcIndlYml4X2xhYmVsX3JpZ2h0XCI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5yZWFkb25seSkgdGhpcy50b2dnbGUoKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JE0gPSBleHBvcnRzLnByb3RvVUkoYXBpJE0sIGNoZWNrYm94LnZpZXcpO1xuXG5cdHZhciBhcGkkTiA9IHtcblx0ICBuYW1lOiBcInRhYmJhclwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25LZXlQcmVzc1wiLCB0aGlzLl9vbktleVByZXNzKTtcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgc2tpbiA9ICRhY3RpdmU7XG5cdCAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzO1xuXHQgICAgZGVmYXVsdHMudG9wT2Zmc2V0ID0gc2tpbi50YWJUb3BPZmZzZXQgfHwgMDtcblx0ICAgIGRlZmF1bHRzLnRhYk9mZnNldCA9IHR5cGVvZiBza2luLnRhYk9mZnNldCAhPSBcInVuZGVmaW5lZFwiID8gc2tpbi50YWJPZmZzZXQgOiAxMDtcblx0ICAgIGRlZmF1bHRzLmJvdHRvbU9mZnNldCA9IHNraW4udGFiQm90dG9tT2Zmc2V0IHx8IDA7XG5cdCAgICBkZWZhdWx0cy5oZWlnaHQgPSBza2luLnRhYmJhckhlaWdodDtcblx0ICAgIGRlZmF1bHRzLnRhYk1hcmdpbiA9IHNraW4udGFiTWFyZ2luO1xuXHQgICAgZGVmYXVsdHMuaW5wdXRQYWRkaW5nID0gc2tpbi5pbnB1dFBhZGRpbmc7XG5cdCAgICBkZWZhdWx0cy50YWJNaW5XaWR0aCA9IHNraW4udGFiTWluV2lkdGggfHwgMTAwO1xuXHQgICAgZGVmYXVsdHMudGFiTW9yZVdpZHRoID0gc2tpbi50YWJNb3JlV2lkdGggfHwgNDA7XG5cdCAgICBkZWZhdWx0cy5ib3JkZXJsZXNzID0gIXNraW4udGFiQm9yZGVyO1xuXHQgIH0sXG5cdCAgX2dldFRhYmJhclNpemVzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3MsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBsZW4sXG5cdCAgICAgICAgdGFicyA9IHRoaXMuX3RhYnMgfHwgY29uZmlnLm9wdGlvbnMsXG5cdCAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMuX2lucHV0X3dpZHRoIC0gY29uZmlnLnRhYk9mZnNldCAqIDIsXG5cdCAgICAgICAgbGltaXRXaWR0aCA9IGNvbmZpZy5vcHRpb25XaWR0aCB8fCBjb25maWcudGFiTWluV2lkdGg7XG5cdCAgICBsZW4gPSB0YWJzLmxlbmd0aDtcblxuXHQgICAgaWYgKGNvbmZpZy50YWJNaW5XaWR0aCAmJiB0b3RhbFdpZHRoIC8gbGVuIDwgbGltaXRXaWR0aCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIG1heDogcGFyc2VJbnQodG90YWxXaWR0aCAvIGxpbWl0V2lkdGgsIDEwKSB8fCAxXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICghY29uZmlnLm9wdGlvbldpZHRoKSB7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgIGlmICh0YWJzW2ldLndpZHRoKSB7XG5cdCAgICAgICAgICB0b3RhbFdpZHRoIC09IHRhYnNbaV0ud2lkdGggKyAoIWkgJiYgIWNvbmZpZy50eXBlID8gY29uZmlnLnRhYk1hcmdpbiA6IDApO1xuXHQgICAgICAgICAgbGVuLS07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHdpZHRoOiBsZW4gPyB0b3RhbFdpZHRoIC8gbGVuIDogY29uZmlnLnRhYk1pbldpZHRoXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2luaXRfcG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBvYmogPSB0aGlzLl9zZXR0aW5ncztcblxuXHQgICAgaWYgKCFvYmoudGFiYmFyUG9wdXApIHtcblx0ICAgICAgdmFyIHBvcHVwQ29uZmlnID0ge1xuXHQgICAgICAgIHZpZXc6IFwicG9wdXBcIixcblx0ICAgICAgICB3aWR0aDogb2JqLnBvcHVwV2lkdGggfHwgMjAwLFxuXHQgICAgICAgIGJvZHk6IHtcblx0ICAgICAgICAgIHZpZXc6IFwibGlzdFwiLFxuXHQgICAgICAgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgICAgICAgIHNlbGVjdDogdHJ1ZSxcblx0ICAgICAgICAgIGNzczogXCJ3ZWJpeF90YWJfbGlzdFwiLFxuXHQgICAgICAgICAgYXV0b2hlaWdodDogdHJ1ZSxcblx0ICAgICAgICAgIHlDb3VudDogb2JqLnlDb3VudCxcblx0ICAgICAgICAgIHR5cGU6IHtcblx0ICAgICAgICAgICAgdGVtcGxhdGU6IG9iai5wb3B1cFRlbXBsYXRlXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgICB2YXIgdmlldyA9IHVpKHBvcHVwQ29uZmlnKTtcblx0ICAgICAgdmlldy5nZXRCb2R5KCkuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVNlbGVjdFwiLCBiaW5kKGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgIGlmIChpZCAmJiB0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlVGFiQ2xpY2tcIiwgW2lkXSkpIHtcblx0ICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaWQpO1xuXHQgICAgICAgICAgJCQodGhpcy5fc2V0dGluZ3MudGFiYmFyUG9wdXApLmhpZGUoKTtcblx0ICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclRhYkNsaWNrXCIsIFtpZF0pO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICAgIHZpZXcuZ2V0Qm9keSgpLmF0dGFjaEV2ZW50KFwib25BZnRlclNlbGVjdFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgICBvYmoudGFiYmFyUG9wdXAgPSB2aWV3Ll9zZXR0aW5ncy5pZDtcblxuXHQgICAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUucHVzaCh2aWV3KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faW5pdF9wb3B1cCA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgIH0sXG5cdCAgZ2V0UG9wdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2luaXRfcG9wdXAoKTtcblxuXHQgICAgcmV0dXJuICQkKHRoaXMuX3NldHRpbmdzLnRhYmJhclBvcHVwKTtcblx0ICB9LFxuXHQgIG1vcmVUZW1wbGF0ZV9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIHBvcHVwVGVtcGxhdGVfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgcG9wdXBXaWR0aDogMjAwLFxuXHQgICAgcG9wdXBUZW1wbGF0ZTogXCIjdmFsdWUjXCIsXG5cdCAgICB5Q291bnQ6IDcsXG5cdCAgICBtb3JlVGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIndlYml4X2ljb24gd3hpLWRvdHNcXFwiPjwvc3Bhbj5cIixcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgdmFyIGNvbnRlbnRXaWR0aCwgaHRtbCwgaSwgbGVhZldpZHRoLCByZXN1bHRIVE1MLCBzdHlsZSwgc3VtLCB0YWJzLCB2ZXJ0aWNhbE9mZnNldCwgd2lkdGg7XG5cdCAgICAgIGNvbW1vbi5fdGFicyA9IHRhYnMgPSBjb21tb24uX2ZpbHRlck9wdGlvbnMob2JqLm9wdGlvbnMpO1xuXG5cdCAgICAgIGlmICghdGFicy5sZW5ndGgpIHtcblx0ICAgICAgICBodG1sID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90YWJfZmlsbGVyJyBzdHlsZT0nd2lkdGg6XCIgKyBjb21tb24uX2lucHV0X3dpZHRoICsgXCJweDsgYm9yZGVyLXJpZ2h0OjBweDsnPjwvZGl2PlwiO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGNvbW1vbi5fY2hlY2tfb3B0aW9ucyh0YWJzKTtcblxuXHQgICAgICAgIGlmICghb2JqLnZhbHVlICYmIHRhYnMubGVuZ3RoKSBvYmoudmFsdWUgPSB0YWJzWzBdLmlkO1xuXHQgICAgICAgIGh0bWwgPSBcIlwiO1xuXHQgICAgICAgIGlmIChvYmoudGFiT2Zmc2V0KSBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfdGFiX2ZpbGxlcicgc3R5bGU9J3dpZHRoOlwiICsgb2JqLnRhYk9mZnNldCArIFwicHg7Jz4mbmJzcDs8L2Rpdj5cIjtcblx0ICAgICAgICBjb250ZW50V2lkdGggPSBjb21tb24uX2lucHV0X3dpZHRoIC0gb2JqLnRhYk9mZnNldCAqIDIgLSAoIW9iai50eXBlID8gb2JqLnRhYk1hcmdpbiAqICh0YWJzLmxlbmd0aCAtIDEpIDogMCk7XG5cdCAgICAgICAgdmVydGljYWxPZmZzZXQgPSBvYmoudG9wT2Zmc2V0ICsgb2JqLmJvdHRvbU9mZnNldDtcblxuXHQgICAgICAgIHZhciBzaXplcyA9IGNvbW1vbi5fZ2V0VGFiYmFyU2l6ZXMoKTtcblxuXHQgICAgICAgIGlmIChzaXplcy5tYXggJiYgc2l6ZXMubWF4IDwgdGFicy5sZW5ndGgpIHtcblx0ICAgICAgICAgIC8vd2UgbmVlZCBwb3B1cFxuXHQgICAgICAgICAgdmFyIHBvcHVwID0gY29tbW9uLmdldFBvcHVwKCk7XG5cdCAgICAgICAgICBwb3B1cC5oaWRlKCk7XG5cdCAgICAgICAgICB2YXIgbGlzdCA9IHBvcHVwLmdldEJvZHkoKSB8fCBudWxsO1xuXG5cdCAgICAgICAgICBpZiAobGlzdCkge1xuXHQgICAgICAgICAgICBpZiAoc2l6ZXMubWF4KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFicy5sZW5ndGggJiYgIWZvdW5kOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0YWJzW2ldLmlkID09IG9iai52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cblx0ICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxID4gc2l6ZXMubWF4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkVGFiID0gdGFicy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlUYWJzID0gdGFicy5zcGxpY2UoMCwgc2l6ZXMubWF4IC0gMSkuY29uY2F0KHNlbGVjdGVkVGFiKTtcblx0ICAgICAgICAgICAgICAgICAgICB0YWJzID0gZGlzcGxheVRhYnMuY29uY2F0KHRhYnMpO1xuXHQgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgbGlzdC5jbGVhckFsbCgpO1xuXHQgICAgICAgICAgICAgIGxpc3QucGFyc2UodGFicy5zbGljZShzaXplcy5tYXgpKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICBsaXN0LmNsZWFyQWxsKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKGNvbW1vbi5fc2V0dGluZ3MudGFiYmFyUG9wdXApICQkKGNvbW1vbi5fc2V0dGluZ3MudGFiYmFyUG9wdXApLmhpZGUoKTtcblxuXHQgICAgICAgIHN1bSA9IG9iai50YWJPZmZzZXQ7XG5cdCAgICAgICAgdmFyIGxhc3RUYWIgPSBmYWxzZTtcblxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0YWJzLmxlbmd0aCAmJiAhbGFzdFRhYjsgaSsrKSB7XG5cdCAgICAgICAgICAvLyB0YWIgd2lkdGhcblx0ICAgICAgICAgIGlmIChzaXplcyAmJiBzaXplcy5tYXgpIHtcblx0ICAgICAgICAgICAgaWYgKHNpemVzLm1heCA9PSBpICsgMSkge1xuXHQgICAgICAgICAgICAgIGxhc3RUYWIgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY29udGVudFdpZHRoID0gY29tbW9uLl9pbnB1dF93aWR0aCAtIG9iai50YWJPZmZzZXQgKiAyIC0gKCFvYmoudHlwZSAmJiBzaXplcy5tYXggPiAxID8gb2JqLnRhYk1hcmdpbiAqIChzaXplcy5tYXggLSAxKSA6IDApO1xuXHQgICAgICAgICAgICB3aWR0aCA9IChjb250ZW50V2lkdGggLSBvYmoudGFiTW9yZVdpZHRoKSAvIHNpemVzLm1heDtcblx0ICAgICAgICAgIH0gZWxzZSB3aWR0aCA9IHNpemVzLndpZHRoO1xuXG5cdCAgICAgICAgICB3aWR0aCA9IHRhYnNbaV0ud2lkdGggfHwgb2JqLm9wdGlvbldpZHRoIHx8IHdpZHRoO1xuXHQgICAgICAgICAgc3VtICs9IHdpZHRoICsgKGkgJiYgIW9iai50eXBlID8gb2JqLnRhYk1hcmdpbiA6IDApO1xuXHQgICAgICAgICAgaWYgKG9iai50YWJNYXJnaW4gPiAwICYmIGkgJiYgIW9iai50eXBlKSBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfdGFiX2ZpbGxlcicgc3R5bGU9J3dpZHRoOlwiICsgb2JqLnRhYk1hcmdpbiArIFwicHg7Jz48L2Rpdj5cIjsgLy8gdGFiIGlubmVySFRNTFxuXG5cdCAgICAgICAgICBodG1sICs9IGNvbW1vbi5fZ2V0VGFiSFRNTCh0YWJzW2ldLCB3aWR0aCk7XG5cblx0ICAgICAgICAgIGlmIChsYXN0VGFiKSB7XG5cdCAgICAgICAgICAgIGh0bWwgKz0gXCI8ZGl2IHJvbGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGFyaWEtbGFiZWw9XFxcIlwiICsgaTE4bi5hcmlhLnNob3dUYWJzICsgXCJcXFwiIGNsYXNzPVxcXCJ3ZWJpeF90YWJfbW9yZV9pY29uXFxcIiBzdHlsZT1cXFwid2lkdGg6XCIgKyBvYmoudGFiTW9yZVdpZHRoICsgXCJweDtcXFwiPlwiICsgb2JqLm1vcmVUZW1wbGF0ZShvYmosIGNvbW1vbikgKyBcIjwvZGl2PlwiO1xuXHQgICAgICAgICAgICBzdW0gKz0gb2JqLnRhYk1vcmVXaWR0aDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsZWFmV2lkdGggPSBjb21tb24uX2NvbnRlbnRfd2lkdGggLSBzdW07XG5cdCAgICAgICAgaWYgKGxlYWZXaWR0aCA+IDAgJiYgIW9iai50eXBlKSBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfdGFiX2ZpbGxlcicgc3R5bGU9J3dpZHRoOlwiICsgbGVhZldpZHRoICsgXCJweDsnPiZuYnNwOzwvZGl2PlwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmVzdWx0SFRNTCA9IFwiXCI7IC8vIGNvbnNpZGVyIHRvcCBhbmQgYm90dG9tIG9mZnNldCBpbiB0YWJzIGhlaWdodCAodG9wIHRhYmJhcilcblxuXHQgICAgICBzdHlsZSA9IHZlcnRpY2FsT2Zmc2V0ICYmICFvYmoudHlwZSA/IFwiaGVpZ2h0OlwiICsgKGNvbW1vbi5fY29udGVudF9oZWlnaHQgLSB2ZXJ0aWNhbE9mZnNldCkgKyBcInB4XCIgOiBcIlwiOyAvL3NwYWNlIGFib3ZlIHRhYnMgKHRvcCB0YWJiYXIpXG5cblx0ICAgICAgaWYgKG9iai50b3BPZmZzZXQgJiYgIW9iai50eXBlKSByZXN1bHRIVE1MICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfYmVmb3JlX2FsbF90YWJzJyBzdHlsZT0nd2lkdGg6MTAwJTtoZWlnaHQ6XCIgKyBvYmoudG9wT2Zmc2V0ICsgXCJweCc+PC9kaXY+XCI7IC8vIHRhYnMgaHRtbFxuXG5cdCAgICAgIHJlc3VsdEhUTUwgKz0gXCI8ZGl2IHN0eWxlPSdcIiArIHN0eWxlICsgXCInIHJvbGU9J3RhYmxpc3QnIGNsYXNzPSd3ZWJpeF9hbGxfdGFicyBcIiArIChvYmoudHlwZSA/IFwid2ViaXh0eXBlX1wiICsgb2JqLnR5cGUgOiBcIlwiKSArIFwiJz5cIiArIGh0bWwgKyBcIjwvZGl2PlwiOyAvL3NwYWNlIGJlbG93IHRvIHRhYnMgKHRvcCB0YWJiYXIpXG5cblx0ICAgICAgaWYgKG9iai5ib3R0b21PZmZzZXQgJiYgIW9iai50eXBlKSByZXN1bHRIVE1MICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfYWZ0ZXJfYWxsX3RhYnMnIHN0eWxlPSd3aWR0aDoxMDAlO2hlaWdodDpcIiArIG9iai5ib3R0b21PZmZzZXQgKyBcInB4Jz48L2Rpdj5cIjtcblx0ICAgICAgcmV0dXJuIHJlc3VsdEhUTUw7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0SW5wdXROb2RlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy4kdmlldy5xdWVyeVNlbGVjdG9yQWxsKFwiLndlYml4X2l0ZW1fdGFiXCIpO1xuXHQgIH0sXG5cdCAgX2dldFRhYkhUTUw6IGZ1bmN0aW9uICh0YWIsIHdpZHRoKSB7XG5cdCAgICB2YXIgaHRtbCxcblx0ICAgICAgICBjbGFzc05hbWUgPSBcIlwiLFxuXHQgICAgICAgIHRvb2x0aXAgPSBcIlwiLFxuXHQgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXHQgICAgaWYgKHRhYi5pZCA9PSBjb25maWcudmFsdWUpIGNsYXNzTmFtZSA9IFwiIHdlYml4X3NlbGVjdGVkXCI7XG5cdCAgICBpZiAodGFiLmNzcykgY2xhc3NOYW1lICs9IFwiIFwiICsgdGFiLmNzcztcblx0ICAgIGlmIChjb25maWcudG9vbHRpcCkgdG9vbHRpcCA9IFwiIHdlYml4X3RfaWQ9J1wiICsgdGFiLmlkICsgXCInXCI7XG5cdCAgICB3aWR0aCA9IHRhYi53aWR0aCB8fCB3aWR0aDtcblx0ICAgIGh0bWwgPSBcIjxkaXYgY2xhc3M9XFxcIndlYml4X2l0ZW1fdGFiXCIgKyBjbGFzc05hbWUgKyBcIlxcXCIgYnV0dG9uX2lkPVxcXCJcIiArIHRhYi5pZCArIFwiXFxcIiByb2xlPVxcXCJ0YWJcXFwiIGFyaWEtc2VsZWN0ZWQ9XFxcIlwiICsgKHRhYi5pZCA9PSBjb25maWcudmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIlxcXCIgdGFiaW5kZXg9XFxcIlwiICsgKHRhYi5pZCA9PSBjb25maWcudmFsdWUgPyBcIjBcIiA6IFwiLTFcIikgKyBcIlxcXCIgc3R5bGU9XFxcIndpZHRoOlwiICsgd2lkdGggKyBcInB4O1xcXCJcIiArIHRvb2x0aXAgKyBcIj5cIjsgLy8gYSB0YWIgdGl0bGVcblxuXHQgICAgaWYgKHRoaXMuX3RhYlRlbXBsYXRlKSB7XG5cdCAgICAgIHZhciBjYWxjSGVpZ2h0ID0gdGhpcy5fY29udGVudF9oZWlnaHQgLSBjb25maWcuaW5wdXRQYWRkaW5nICogMiAtIDI7XG5cdCAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9jb250ZW50X2hlaWdodCAtIDI7XG5cdCAgICAgIHZhciB0ZW1wID0gZXhwb3J0cy5leHRlbmQoe1xuXHQgICAgICAgIGNoZWlnaHQ6IGNhbGNIZWlnaHQsXG5cdCAgICAgICAgYWhlaWdodDogaGVpZ2h0XG5cdCAgICAgIH0sIHRhYik7XG5cdCAgICAgIGh0bWwgKz0gdGhpcy5fdGFiVGVtcGxhdGUodGVtcCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgaWNvbiA9IHRhYi5pY29uID8gXCI8c3BhbiBjbGFzcz0nd2ViaXhfaWNvbiBcIiArIHRhYi5pY29uICsgXCInPjwvc3Bhbj4gXCIgOiBcIlwiO1xuXHQgICAgICBodG1sICs9IGljb24gKyB0YWIudmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0YWIuY2xvc2UgfHwgY29uZmlnLmNsb3NlKSBodG1sICs9IFwiPHNwYW4gcm9sZT0nYnV0dG9uJyB0YWJpbmRleD0nMCcgYXJpYS1sYWJlbD0nXCIgKyBpMThuLmFyaWEuY2xvc2VUYWIgKyBcIicgY2xhc3M9J3dlYml4X3RhYl9jbG9zZSB3ZWJpeF9pY29uIHd4aS1jbG9zZSc+PC9zcGFuPlwiO1xuXHQgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICBfZ2V0Qm94OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGF0YW9iai5maXJzdENoaWxkO1xuXHQgIH0sXG5cdCAgX3R5cGVzOiB7XG5cdCAgICBpbWFnZTogXCI8ZGl2IGNsYXNzPSd3ZWJpeF9pbWdfYnRuX3RvcCcgc3R5bGU9J2hlaWdodDojY2hlaWdodCNweDtiYWNrZ3JvdW5kLWltYWdlOnVybCgjaW1hZ2UjKTsnPjxkaXYgY2xhc3M9J3dlYml4X2ltZ19idG5fdGV4dCc+I3ZhbHVlIzwvZGl2PjwvZGl2PlwiLFxuXHQgICAgaWNvbjogXCI8ZGl2IGNsYXNzPSd3ZWJpeF9pbWdfYnRuJyBzdHlsZT0nbGluZS1oZWlnaHQ6I2NoZWlnaHQjcHg7aGVpZ2h0OiNjaGVpZ2h0I3B4Oyc+PHNwYW4gY2xhc3M9J3dlYml4X2ljb25fYnRuICNpY29uIycgc3R5bGU9J21heC13aWR0aDojY2hlaWdodCNweDttYXgtaGVpZ2h0OiNjaGVpZ2h0I3B4Oyc+PC9zcGFuPiN2YWx1ZSM8L2Rpdj5cIixcblx0ICAgIGljb25Ub3A6IFwiPGRpdiBjbGFzcz0nd2ViaXhfaW1nX2J0bl90b3AnIHN0eWxlPSdoZWlnaHQ6I2NoZWlnaHQjcHg7d2lkdGg6MTAwJTt0b3A6MHB4O3RleHQtYWxpZ246Y2VudGVyOyc+PHNwYW4gY2xhc3M9J3dlYml4X2ljb24gI2ljb24jJz48L3NwYW4+PGRpdiBjbGFzcz0nd2ViaXhfaW1nX2J0bl90ZXh0Jz4jdmFsdWUjPC9kaXY+PC9kaXY+XCJcblx0ICB9LFxuXHQgIHR5cGVfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX3NldHRpbmdzLnRhYk9mZnNldCA9IDA7XG5cdCAgICBpZiAodGhpcy5fdHlwZXNbdmFsdWVdKSB0aGlzLl90YWJUZW1wbGF0ZSA9IHRlbXBsYXRlKHRoaXMuX3R5cGVzW3ZhbHVlXSk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyROID0gZXhwb3J0cy5wcm90b1VJKGFwaSROLCBzZWdtZW50ZWQudmlldyk7XG5cblx0dmFyIGFwaSRPID0ge1xuXHQgIG5hbWU6IFwicmljaHRleHRcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgbGFiZWw6IFwiXCIsXG5cdCAgICBsYWJlbFdpZHRoOiA4MCxcblx0ICAgIGxhYmVsUG9zaXRpb246IFwibGVmdFwiXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfcmljaHRleHRcIjtcblx0ICAgIHRoaXMuJHJlYWR5LnVuc2hpZnQodGhpcy5fc2V0TGF5b3V0KTtcblx0ICB9LFxuXHQgIGdldElucHV0Tm9kZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuJHZpZXcucXVlcnlTZWxlY3RvcihcIi53ZWJpeF9yaWNodGV4dF9lZGl0b3JcIik7XG5cdCAgfSxcblx0ICBfYnV0dG9uOiBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgdmlldzogXCJ0b2dnbGVcIixcblx0ICAgICAgdHlwZTogXCJpY29uQnV0dG9uXCIsXG5cdCAgICAgIGljb246IFwid3hpLVwiICsgbmFtZSxcblx0ICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgaWQ6IG5hbWUsXG5cdCAgICAgIGxhYmVsOiBpMThuLnJpY2h0ZXh0W25hbWVdLFxuXHQgICAgICBhdXRvd2lkdGg6IHRydWUsXG5cdCAgICAgIGFjdGlvbjogbmFtZSxcblx0ICAgICAgY2xpY2s6IHRoaXMuX2FkZF9kYXRhXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX3NldExheW91dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHRvcCA9IHRoaXM7XG5cdCAgICB2YXIgZWRpdEZpZWxkID0ge1xuXHQgICAgICB2aWV3OiBcInRlbXBsYXRlXCIsXG5cdCAgICAgIGNzczogXCJ3ZWJpeF9yaWNodGV4dF9jb250YWluZXJcIixcblx0ICAgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nd2ViaXhfcmljaHRleHRfZWRpdG9yJyBjb250ZW50ZWRpdGFibGU9J3RydWUnPlwiICsgdGhpcy5nZXRWYWx1ZSgpICsgXCI8L2Rpdj5cIixcblx0ICAgICAgb246IHtcblx0ICAgICAgICBvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB0b3AuX3JlbmRlcmVkX2lucHV0ID0gdHJ1ZTtcblxuXHQgICAgICAgICAgX2V2ZW50KHRvcC5nZXRJbnB1dE5vZGUoKSwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdG9wLl91cGRhdGVWYWx1ZSh0aGlzLmlubmVySFRNTCk7XG5cdCAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgX2V2ZW50KHRvcC5nZXRJbnB1dE5vZGUoKSwgXCJrZXl1cFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRvcC5fZ2V0c2VsZWN0aW9uKCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uQ2xpY2s6IHtcblx0ICAgICAgICB3ZWJpeF9yaWNodGV4dF9lZGl0b3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHRvcC5fZ2V0c2VsZWN0aW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgdmFyIGVkaXRvclRvb2xiYXIgPSB7XG5cdCAgICAgIHZpZXc6IFwidG9vbGJhclwiLFxuXHQgICAgICBpZDogXCJ0b29sYmFyXCIsXG5cdCAgICAgIGVsZW1lbnRzOiBbdGhpcy5fYnV0dG9uKFwidW5kZXJsaW5lXCIpLCB0aGlzLl9idXR0b24oXCJib2xkXCIpLCB0aGlzLl9idXR0b24oXCJpdGFsaWNcIiksIHt9XVxuXHQgICAgfTtcblx0ICAgIHZhciByb3dzID0gW2VkaXRvclRvb2xiYXIsIGVkaXRGaWVsZF07XG5cblx0ICAgIGlmICh0aGlzLmNvbmZpZy5sYWJlbFBvc2l0aW9uID09PSBcInRvcFwiIHx8ICF0aGlzLmNvbmZpZy5sYWJlbFdpZHRoKSB7XG5cdCAgICAgIGVkaXRvclRvb2xiYXIuZWxlbWVudHMuY29uY2F0KFt7XG5cdCAgICAgICAgdmlldzogXCJsYWJlbFwiLFxuXHQgICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5sYWJlbCxcblx0ICAgICAgICBhbGlnbjogXCJyaWdodFwiXG5cdCAgICAgIH0sIHtcblx0ICAgICAgICB3aWR0aDogNFxuXHQgICAgICB9XSk7XG5cdCAgICAgIHRoaXMucm93c19zZXR0ZXIocm93cyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJsZXNzID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5jb2xzX3NldHRlcihbe1xuXHQgICAgICAgIHRlbXBsYXRlOiB0aGlzLmNvbmZpZy5sYWJlbCB8fCBcIiBcIixcblx0ICAgICAgICBjc3M6IFwid2ViaXhfcmljaHRleHRfaW5wX2xhYmVsXCIgKyAodGhpcy5jb25maWcucmVxdWlyZWQgPyBcIiB3ZWJpeF9yZXF1aXJlZFwiIDogXCJcIiksXG5cdCAgICAgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgICAgICB3aWR0aDogdGhpcy5jb25maWcubGFiZWxXaWR0aFxuXHQgICAgICB9LCB7XG5cdCAgICAgICAgcm93czogcm93c1xuXHQgICAgICB9XSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0c2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdG9wID0gdGhpcztcblx0ICAgIHZhciBiYXIgPSB0b3AuJCQoXCJ0b29sYmFyXCIpO1xuXHQgICAgdmFyIHNlbDtcblx0ICAgIGJhci5zZXRWYWx1ZXMoe1xuXHQgICAgICBpdGFsaWM6IGZhbHNlLFxuXHQgICAgICB1bmRlcmxpbmU6IGZhbHNlLFxuXHQgICAgICBib2xkOiBmYWxzZVxuXHQgICAgfSk7XG5cblx0ICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG5cdCAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNlbCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZUNvdW50OyArK2kpIHtcblx0ICAgICAgaWYgKHRvcC4kdmlldy5jb250YWlucyh0aGlzLmdldElucHV0Tm9kZSgpKSkge1xuXHQgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShcImJvbGRcIikpIHtcblx0ICAgICAgICAgIHRvcC4kJChcImJvbGRcIikuc2V0VmFsdWUodHJ1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwidW5kZXJsaW5lXCIpKSB7XG5cdCAgICAgICAgICB0b3AuJCQoXCJ1bmRlcmxpbmVcIikuc2V0VmFsdWUodHJ1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpKSB7XG5cdCAgICAgICAgICB0b3AuJCQoXCJpdGFsaWNcIikuc2V0VmFsdWUodHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fcmVuZGVyZWRfaW5wdXQpIHRoaXMuZ2V0SW5wdXROb2RlKCkuaW5uZXJIVE1MID0gdGhpcy5jb25maWcudmFsdWU7XG5cdCAgfSxcblx0ICBfZXhlY0NvbW1hbmRPbkVsZW1lbnQ6IGZ1bmN0aW9uIChlbCwgY29tbWFuZE5hbWUpIHtcblx0ICAgIHZhciBzZWwsIHNlbFRleHQ7XG5cblx0ICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpIHtcblx0ICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHQgICAgICBzZWxUZXh0ID0gc2VsLnRvU3RyaW5nKCkubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc2VsID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG5cdCAgICAgIHNlbFRleHQgPSBzZWwudGV4dC5sZW5ndGg7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzZWxUZXh0ID4gMCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZUNvdW50OyArK2kpIHtcblx0ICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdChpKTtcblxuXHQgICAgICAgIGlmICghc2VsLmlzQ29sbGFwc2VkKSB7XG5cdCAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChjb21tYW5kTmFtZSwgZmFsc2UsIFwiXCIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gc2VsLmZvY3VzTm9kZS50ZXh0Q29udGVudDtcblx0ICAgICAgICAgIHZhciBmb2N1c0VsID0gc2VsLmZvY3VzTm9kZTtcblx0ICAgICAgICAgIHZhciBmb2N1c3RleHQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuXHQgICAgICAgICAgdmFyIHdvcmRCZWdpbmluZyA9IHRleHRWYWx1ZS5zdWJzdHJpbmcoMCwgZm9jdXN0ZXh0KS5tYXRjaCgvW0EtWmEtel0qJC8pWzBdO1xuXHQgICAgICAgICAgdmFyIHdvcmRFbmQgPSB0ZXh0VmFsdWUuc3Vic3RyaW5nKGZvY3VzdGV4dCkubWF0Y2goL15bQS1aYS16XSovKVswXTtcblx0ICAgICAgICAgIHZhciBzdGFydFdvcmQgPSBmb2N1c3RleHQgLSB3b3JkQmVnaW5pbmcubGVuZ3RoO1xuXHQgICAgICAgICAgdmFyIGVuZFdvcmQgPSBmb2N1c3RleHQgKyB3b3JkRW5kLmxlbmd0aDtcblx0ICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRWwsIHN0YXJ0V29yZCk7XG5cdCAgICAgICAgICByYW5nZS5zZXRFbmQoZm9jdXNFbCwgZW5kV29yZCk7XG5cdCAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cdCAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuYWRkUmFuZ2UocmFuZ2UpO1xuXHQgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoY29tbWFuZE5hbWUsIGZhbHNlLCBcIlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9hZGRfZGF0YTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHRvcCA9IHRoaXMuZ2V0VG9wUGFyZW50VmlldygpO1xuXHQgICAgdmFyIGVkaXRhYmxlRWxlbWVudCA9IHRvcC5nZXRJbnB1dE5vZGUoKTtcblxuXHQgICAgaWYgKHRoaXMuJHZpZXcuY29udGFpbnModGhpcy5nZXRJbnB1dE5vZGUoKSkpIHtcblx0ICAgICAgdG9wLl9leGVjQ29tbWFuZE9uRWxlbWVudChlZGl0YWJsZUVsZW1lbnQsIHRoaXMuY29uZmlnLmFjdGlvbik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBmb2N1czogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCFVSU1hbmFnZXIuY2FuRm9jdXModGhpcykpIHJldHVybiBmYWxzZTtcblx0ICAgIHZhciBlZGl0YWJsZUVsZW1lbnQgPSB0aGlzLiR2aWV3LnF1ZXJ5U2VsZWN0b3IoXCIud2ViaXhfcmljaHRleHRfZWRpdG9yXCIpO1xuXHQgICAgZWRpdGFibGVFbGVtZW50LmZvY3VzKCk7XG5cdCAgfSxcblx0ICBfdXBkYXRlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIG9sZCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuXHQgICAgdGhpcy5jb25maWcudmFsdWUgPSB2YWx1ZSB8fCBcIlwiO1xuXHQgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHRoaXMuY2FsbEV2ZW50KFwib25DaGFuZ2VcIiwgW3ZhbHVlLCBvbGRdKTtcblx0ICB9LFxuXHQgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX3VwZGF0ZVZhbHVlKHZhbHVlKTtcblxuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGlucHV0ID0gdGhpcy5nZXRJbnB1dE5vZGUoKTtcblx0ICAgIGlmIChpbnB1dCkgdGhpcy5jb25maWcudmFsdWUgPSB0aGlzLmdldElucHV0Tm9kZSgpLmlubmVySFRNTDtcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuY29uZmlnLnZhbHVlO1xuXHQgICAgcmV0dXJuIHZhbHVlIHx8ICh2YWx1ZSA9PT0gMCA/IFwiMFwiIDogXCJcIik7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRPID0gZXhwb3J0cy5wcm90b1VJKGFwaSRPLCBJZFNwYWNlLCBsYXlvdXQudmlldyk7XG5cblx0dmFyIGFwaSRQID0ge1xuXHQgIG5hbWU6IFwicHJvdG9cIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kYXRhLnByb3ZpZGVBcGkodGhpcywgdHJ1ZSk7XG5cdCAgICB0aGlzLl9kYXRhb2JqID0gdGhpcy5fZGF0YW9iaiB8fCB0aGlzLl9jb250ZW50b2JqOyAvL3JlbmRlciBzZWxmICwgZWFjaCB0aW1lIHdoZW4gZGF0YSBpcyB1cGRhdGVkXG5cblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmIChiYXNlLmFwaS4kc2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB0aGlzLnJlbmRlcigpO1xuXHQgIH0sXG5cdCAgX2lkOiBcIndlYml4X2l0ZW1cIixcblx0ICBvbl9tb3VzZV9tb3ZlOiB7fSxcblx0ICB0eXBlOiB7fVxuXHR9O1xuXHR2YXIgdmlldyRQID0gZXhwb3J0cy5wcm90b1VJKGFwaSRQLCBQYWdpbmdBYmlsaXR5LCBEYXRhTWFya3MsIEF1dG9Ub29sdGlwLCBWYWxpZGF0ZUNvbGxlY3Rpb24sIFJlbmRlclN0YWNrLCBEYXRhTG9hZGVyLCBiYXNlLnZpZXcsIEV2ZW50U3lzdGVtLCBTZXR0aW5ncyk7XG5cdHZhciBwcm90byA9IHtcblx0ICBhcGk6IGFwaSRQLFxuXHQgIHZpZXc6IHZpZXckUFxuXHR9O1xuXG5cdHZhciBhcGkkUSA9IHtcblx0ICBuYW1lOiBcImxpc3RcIixcblx0ICBfbGlzdENsYXNzTmFtZTogXCJ3ZWJpeF9saXN0XCIsXG5cdCAgX2l0ZW1DbGFzc05hbWU6IFwid2ViaXhfbGlzdF9pdGVtXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGFkZENzcyh0aGlzLl92aWV3b2JqLCB0aGlzLl9saXN0Q2xhc3NOYW1lICsgKChjb25maWcubGF5b3V0IHx8IHRoaXMuZGVmYXVsdHMubGF5b3V0KSA9PSBcInhcIiA/IFwiLXhcIiA6IFwiXCIpKTtcblx0ICAgIHRoaXMuZGF0YS5wcm92aWRlQXBpKHRoaXMsIHRydWUpO1xuXHQgICAgdGhpcy5fYXV0b19yZXNpemUgPSBiaW5kKHRoaXMuX2F1dG9fcmVzaXplLCB0aGlzKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIHRoaXMuX2F1dG9fcmVzaXplKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3luY0FwcGx5XCIsIHRoaXMuX2F1dG9fcmVzaXplKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIHRoaXMuX2NvcnJlY3Rfd2lkdGhfc2Nyb2xsKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcblx0ICB9LFxuXHQgIGR5bmFtaWNfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkgZXhwb3J0cy5leHRlbmQodGhpcywgVlJlbmRlclN0YWNrLCB0cnVlKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgICRkcmFnSFRNTDogZnVuY3Rpb24gKG9iaiwgZSwgY29udGV4dCkge1xuXHQgICAgdmFyIGh0bWw7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5sYXlvdXQgPT0gXCJ5XCIgJiYgdGhpcy50eXBlLndpZHRoID09IFwiYXV0b1wiKSB7XG5cdCAgICAgIHRoaXMudHlwZS53aWR0aCA9IHRoaXMuX2NvbnRlbnRfd2lkdGg7XG5cdCAgICAgIGh0bWwgPSB0aGlzLl90b0hUTUwob2JqKTtcblx0ICAgICAgdGhpcy50eXBlLndpZHRoID0gXCJhdXRvXCI7XG5cdCAgICB9IGVsc2UgaHRtbCA9IHRoaXMuX3RvSFRNTChvYmopO1xuXG5cdCAgICBpZiAoaXNBcnJheShjb250ZXh0LnNvdXJjZSkgJiYgY29udGV4dC5zb3VyY2UubGVuZ3RoID4gMSkgaHRtbCA9IHRoaXMuX3RvTXVsdGlwbGVIVE1MKGh0bWwsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBzZWxlY3Q6IGZhbHNlLFxuXHQgICAgc2Nyb2xsOiB0cnVlLFxuXHQgICAgbGF5b3V0OiBcInlcIixcblx0ICAgIG5hdmlnYXRpb246IHRydWUsXG5cdCAgICBkYXRhZmV0Y2g6IDUwXG5cdCAgfSxcblx0ICBfaWQ6IFwid2ViaXhfbF9pZFwiLFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICB3ZWJpeF9saXN0X2l0ZW06IGZ1bmN0aW9uIChlLCBpZCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2VsZWN0KSB7XG5cdCAgICAgICAgdGhpcy5fbm9fYW5pbWF0aW9uID0gdHJ1ZTtcblx0ICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2VsZWN0ID09IFwibXVsdGlzZWxlY3RcIiB8fCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCkgdGhpcy5zZWxlY3QoaWQsIGZhbHNlLCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0ID09IFwidG91Y2hcIiwgZS5zaGlmdEtleSk7IC8vbXVsdGlzZWxlY3Rpb25cblx0ICAgICAgICBlbHNlIHRoaXMuc2VsZWN0KGlkKTtcblx0ICAgICAgICB0aGlzLl9ub19hbmltYXRpb24gPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fZGJsY2xpY2s6IHt9LFxuXHQgIGdldFZpc2libGVDb3VudDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fY29udGVudF9oZWlnaHQgLyB0aGlzLl9vbmVfaGVpZ2h0KCkpO1xuXHQgIH0sXG5cdCAgX2F1dG9fcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2hlaWdodCB8fCB0aGlzLl9zZXR0aW5ncy5hdXRvd2lkdGgpIHRoaXMucmVzaXplKCk7XG5cdCAgfSxcblx0ICBfYXV0b19oZWlnaHRfY2FsYzogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGEuJHBhZ2VzaXplIHx8IHRoaXMuY291bnQoKTtcblxuXHQgICAgdGhpcy5fb25vZmZfc2Nyb2xsKGNvdW50ICYmIGNvdW50IDwgdmFsdWUsIFwieVwiKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG9oZWlnaHQgJiYgdmFsdWUgPCAoY291bnQgfHwgSW5maW5pdHkpKSBjb3VudCA9IHZhbHVlO1xuXHQgICAgdmFyIGhlaWdodCA9IHRoaXMuX29uZV9oZWlnaHQoKSAqIGNvdW50ICsgKHRoaXMudHlwZS5tYXJnaW4gfHwgMCk7IC8vdW5pdGxpc3RcblxuXHQgICAgaWYgKHRoaXMuZ2V0VW5pdHMpIGhlaWdodCArPSB0aGlzLmdldFVuaXRzKCkubGVuZ3RoICogdGhpcy50eXBlLmhlYWRlckhlaWdodDtcblx0ICAgIHJldHVybiBNYXRoLm1heChoZWlnaHQsIHRoaXMuX3NldHRpbmdzLm1pbkhlaWdodCB8fCAwKTtcblx0ICB9LFxuXHQgIF9vbmVfaGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50eXBlLmhlaWdodCArICh0aGlzLnR5cGUubWFyZ2luIHx8IDApO1xuXHQgIH0sXG5cdCAgX2F1dG9fd2lkdGhfY2FsYzogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGEuJHBhZ2VzaXplIHx8IHRoaXMuY291bnQoKTtcblxuXHQgICAgdGhpcy5fb25vZmZfc2Nyb2xsKGNvdW50ICYmIGNvdW50IDwgdmFsdWUsIFwieFwiKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG93aWR0aCAmJiB2YWx1ZSA8IChjb3VudCB8fCBJbmZpbml0eSkpIGNvdW50ID0gdmFsdWU7XG5cdCAgICByZXR1cm4gdGhpcy50eXBlLndpZHRoICogY291bnQ7XG5cdCAgfSxcblx0ICBfY29ycmVjdF93aWR0aF9zY3JvbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5sYXlvdXQgPT0gXCJ4XCIpIHRoaXMuX2RhdGFvYmouc3R5bGUud2lkdGggPSB0aGlzLnR5cGUud2lkdGggIT0gXCJhdXRvXCIgPyB0aGlzLnR5cGUud2lkdGggKiB0aGlzLmNvdW50KCkgKyBcInB4XCIgOiBcImF1dG9cIjtcblx0ICB9LFxuXHQgICRnZXRTaXplOiBmdW5jdGlvbiAoZHgsIGR5KSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGF5b3V0ID09IFwieVwiKSB7XG5cdCAgICAgIGlmICh0aGlzLnR5cGUud2lkdGggIT0gXCJhdXRvXCIpIHRoaXMuX3NldHRpbmdzLndpZHRoID0gdGhpcy50eXBlLndpZHRoICsgKHRoaXMuX3Njcm9sbF95ID8gZW52LnNjcm9sbFNpemUgOiAwKTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnlDb3VudCB8fCB0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0KSB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgPSB0aGlzLl9hdXRvX2hlaWdodF9jYWxjKHRoaXMuX3NldHRpbmdzLnlDb3VudCkgfHwgMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0aGlzLnR5cGUuaGVpZ2h0ICE9IFwiYXV0b1wiKSB0aGlzLl9zZXR0aW5ncy5oZWlnaHQgPSB0aGlzLl9vbmVfaGVpZ2h0KCkgKyAodGhpcy5fc2Nyb2xsX3ggPyBlbnYuc2Nyb2xsU2l6ZSA6IDApO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MueENvdW50IHx8IHRoaXMuX3NldHRpbmdzLmF1dG93aWR0aCkgdGhpcy5fc2V0dGluZ3Mud2lkdGggPSB0aGlzLl9hdXRvX3dpZHRoX2NhbGModGhpcy5fc2V0dGluZ3MueENvdW50KSB8fCAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYmFzZS5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCBkeCwgZHkpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGJhc2UuYXBpLiRzZXRTaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfSxcblx0ICB0eXBlOiB7XG5cdCAgICBjc3M6IFwiXCIsXG5cdCAgICB3aWR0aFNpemU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICByZXR1cm4gY29tbW9uLndpZHRoICsgKGNvbW1vbi53aWR0aCA+IC0xID8gXCJweFwiIDogXCJcIik7XG5cdCAgICB9LFxuXHQgICAgaGVpZ2h0U2l6ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgIHJldHVybiBjb21tb24uaGVpZ2h0ICsgKGNvbW1vbi5oZWlnaHQgPiAtMSA/IFwicHhcIiA6IFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIGNsYXNzbmFtZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uLCBtYXJrcykge1xuXHQgICAgICB2YXIgY3NzID0gXCJ3ZWJpeF9saXN0X2l0ZW1cIjtcblx0ICAgICAgaWYgKGNvbW1vbi5jc3MpIGNzcyArPSBcIiBcIiArIGNvbW1vbi5jc3M7XG5cblx0ICAgICAgaWYgKG9iai4kY3NzKSB7XG5cdCAgICAgICAgaWYgKF90eXBlb2Yob2JqLiRjc3MpID09IFwib2JqZWN0XCIpIG9iai4kY3NzID0gY3JlYXRlQ3NzKG9iai4kY3NzKTtcblx0ICAgICAgICBjc3MgKz0gXCIgXCIgKyBvYmouJGNzcztcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChtYXJrcyAmJiBtYXJrcy4kY3NzKSBjc3MgKz0gXCIgXCIgKyBtYXJrcy4kY3NzO1xuXHQgICAgICByZXR1cm4gY3NzO1xuXHQgICAgfSxcblx0ICAgIGFyaWE6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgcmV0dXJuIFwicm9sZT1cXFwib3B0aW9uXFxcIlwiICsgKG1hcmtzICYmIG1hcmtzLndlYml4X3NlbGVjdGVkID8gXCIgYXJpYS1zZWxlY3RlZD1cXFwidHJ1ZVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiXCIgOiBcIiB0YWJpbmRleD1cXFwiLTFcXFwiXCIpICsgKG9iai4kY291bnQgJiYgb2JqLiR0ZW1wbGF0ZSA/IFwiYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCJcIiA6IFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHJldHVybiAob2JqLmljb24gPyBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9saXN0X2ljb24gd2ViaXhfaWNvbiBcIiArIG9iai5pY29uICsgXCInPjwvc3Bhbj5cIiA6IFwiXCIpICsgb2JqLnZhbHVlICsgKG9iai5iYWRnZSA/IFwiPGRpdiBjbGFzcz0nd2ViaXhfYmFkZ2UnPlwiICsgb2JqLmJhZGdlICsgXCI8L2Rpdj5cIiA6IFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIHdpZHRoOiBcImF1dG9cIixcblx0ICAgIHRlbXBsYXRlU3RhcnQ6IHRlbXBsYXRlKFwiPGRpdiB3ZWJpeF9sX2lkPVxcXCIjaWQjXFxcIiBjbGFzcz1cXFwie2NvbW1vbi5jbGFzc25hbWUoKX1cXFwiIHN0eWxlPVxcXCJ3aWR0aDp7Y29tbW9uLndpZHRoU2l6ZSgpfTsgaGVpZ2h0Ontjb21tb24uaGVpZ2h0U2l6ZSgpfTsgb3ZlcmZsb3c6aGlkZGVuO1xcXCIge2NvbW1vbi5hcmlhKCl9PlwiKSxcblx0ICAgIHRlbXBsYXRlRW5kOiB0ZW1wbGF0ZShcIjwvZGl2PlwiKVxuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMudHlwZS5oZWlnaHQgPSAkYWN0aXZlLmxpc3RJdGVtSGVpZ2h0O1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckUSA9IGV4cG9ydHMucHJvdG9VSShhcGkkUSwgQ3VzdG9tUHJpbnQsIEtleXNOYXZpZ2F0aW9uLCBEYXRhTW92ZSwgRHJhZ0l0ZW0sIE1vdXNlRXZlbnRzLCBTZWxlY3Rpb25Nb2RlbCwgU2Nyb2xsYWJsZSwgcHJvdG8udmlldywgQ29weVBhc3RlKTtcblx0dmFyIGxpc3QgPSB7XG5cdCAgYXBpOiBhcGkkUSxcblx0ICB2aWV3OiB2aWV3JFFcblx0fTtcblxuXHQvKlxuXHRcdFVJOlVwbG9hZGVyXG5cdCovXG5cdC8vICNpbmNsdWRlIHVpL3ZpZXcuanNcblx0Ly8gI2luY2x1ZGUgdWkvbGlzdC5qc1xuXG5cdHR5cGUobGlzdC52aWV3LCB7XG5cdCAgbmFtZTogXCJ1cGxvYWRlclwiLFxuXHQgIHRlbXBsYXRlOiBcIntjb21tb24ucmVtb3ZlSWNvbigpfXtjb21tb24ucGVyY2VudCgpfTxkaXYgc3R5bGU9J2Zsb2F0OnJpZ2h0Jz4jc2l6ZXRleHQjPC9kaXY+e2NvbW1vbi5maWxlTmFtZSgpfVwiLFxuXHQgIHBlcmNlbnQ6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIGlmIChvYmouc3RhdHVzID09IFwidHJhbnNmZXJcIikgcmV0dXJuIFwiPGRpdiBzdHlsZT0nd2lkdGg6NjBweDsgdGV4dC1hbGlnbjpjZW50ZXI7IGZsb2F0OnJpZ2h0Jz5cIiArIG9iai5wZXJjZW50ICsgXCIlPC9kaXY+XCI7XG5cdCAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF91cGxvYWRfXCIgKyBvYmouc3RhdHVzICsgXCInPjxzcGFuIGNsYXNzPSdcIiArIChvYmouc3RhdHVzID09IFwiZXJyb3JcIiA/IFwiZXJyb3JfaWNvblwiIDogXCJ3ZWJpeF9pY29uIHd4aS1jaGVja1wiKSArIFwiJz48L3NwYW4+PC9kaXY+XCI7XG5cdCAgfSxcblx0ICByZW1vdmVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9yZW1vdmVfdXBsb2FkJz48c3BhbiBjbGFzcz0nY2FuY2VsX2ljb24nPjwvc3Bhbj48L2Rpdj5cIjtcblx0ICB9LFxuXHQgIGZpbGVOYW1lOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICByZXR1cm4gXCI8ZGl2IHN0eWxlPSd0ZXh0LW92ZXJmbG93OmVsbGlwc2lzOyB3aGl0ZS1zcGFjZTpub3dyYXA7IG92ZXJmbG93OmhpZGRlbjsgcGFkZGluZy1yaWdodDo4cHg7Jz5cIiArIG9iai5uYW1lICsgXCI8L2Rpdj5cIjtcblx0ICB9LFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICBcIndlYml4X3JlbW92ZV91cGxvYWRcIjogZnVuY3Rpb24gKGV2LCBpZCkge1xuXHQgICAgICAkJCh0aGlzLmNvbmZpZy51cGxvYWRlcikuZmlsZXMucmVtb3ZlKGlkKTtcblx0ICAgIH1cblx0ICB9XG5cdH0pO1xuXHR2YXIgYXBpJFIgPSB7XG5cdCAgbmFtZTogXCJ1cGxvYWRlclwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBhdXRvc2VuZDogdHJ1ZSxcblx0ICAgIG11bHRpcGxlOiB0cnVlLFxuXHQgICAgaW5wdXROYW1lOiBcInVwbG9hZFwiXG5cdCAgfSxcblx0ICAkY3NzTmFtZTogXCJidXR0b24gd2ViaXhfdXBsb2FkZXJcIixcblx0ICAkYWxsb3dzQ2xlYXI6IHRydWUsXG5cdCAgb25fY2xpY2s6IHtcblx0ICAgIC8vZG9uJ3QgZmlyZSBleHRyYSBvbkl0ZW1DbGljayBldmVudHMsIHZpc2libGUgYnV0dG9uIHdpbGwgZG8gaXRcblx0ICAgIFwid2ViaXhfaGlkZGVuX3VwbG9hZFwiOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vd2lsbCBiZSByZWRlZmluZWQgYnkgdXBsb2FkIGRyaXZlclxuXHQgIHNlbmQ6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIGZpbGVEaWFsb2c6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIHN0b3BVcGxvYWQ6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZHJpdmVyID0gVXBsb2FkRHJpdmVyLmh0bWw1O1xuXHQgICAgdGhpcy5maWxlcyA9IG5ldyBEYXRhQ29sbGVjdGlvbigpO1xuXHQgICAgdGhpcy5fZGVzdHJveV93aXRoX21lID0gW3RoaXMuZmlsZXNdOyAvLyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdDJcblxuXHQgICAgaWYgKGlzVW5kZWZpbmVkKFhNTEh0dHBSZXF1ZXN0KSB8fCBpc1VuZGVmaW5lZChuZXcgWE1MSHR0cFJlcXVlc3QoKS51cGxvYWQpKSBkcml2ZXIgPSBVcGxvYWREcml2ZXIuZmxhc2g7XG5cdCAgICBhc3NlcnQoZHJpdmVyLCBcImluY29ycmVjdCBkcml2ZXJcIik7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBkcml2ZXIsIHRydWUpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KSkge1xuXHQgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgYXBpT25seV9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgZGVsYXkodGhpcy5yZW5kZXIsIHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMuJGFwaU9ubHkgPSB2YWx1ZTtcblx0ICB9LFxuXHQgIF9hZGRfZmlsZXM6IGZ1bmN0aW9uIChmaWxlcykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLmFkZEZpbGUoZmlsZXNbaV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgbGlua19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciB2aWV3ID0gJCQodGhpcy5fc2V0dGluZ3MubGluayk7XG5cblx0ICAgICAgaWYgKCF2aWV3KSB7XG5cdCAgICAgICAgdmFyIHRvcCA9IHRoaXMuZ2V0VG9wUGFyZW50VmlldygpO1xuXHQgICAgICAgIGlmICh0b3AuJCQpIHZpZXcgPSB0b3AuJCQodGhpcy5fc2V0dGluZ3MubGluayk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodmlldy5zeW5jICYmIHZpZXcuZmlsdGVyKSB2aWV3LnN5bmModGhpcy5maWxlcyk7ZWxzZSBpZiAodmlldy5zZXRWYWx1ZXMpIHRoaXMuZmlsZXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2aWV3LnNldFZhbHVlcyh0aGlzKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHZpZXcuX3NldHRpbmdzLnVwbG9hZGVyID0gdGhpcy5fc2V0dGluZ3MuaWQ7XG5cdCAgICB9LCB0aGlzKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIGFkZEZpbGU6IGZ1bmN0aW9uIChuYW1lLCBzaXplLCB0eXBlJCQxLCBleHRyYSkge1xuXHQgICAgdmFyIGZpbGUgPSBudWxsO1xuXG5cdCAgICBpZiAoX3R5cGVvZihuYW1lKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIGZpbGUgPSBuYW1lO1xuXHQgICAgICBuYW1lID0gZmlsZS5uYW1lO1xuXHQgICAgICBzaXplID0gZmlsZS5zaXplO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZm9ybWF0ID0gdGhpcy5fZm9ybWF0X3NpemUoc2l6ZSk7XG5cblx0ICAgIHR5cGUkJDEgPSB0eXBlJCQxIHx8IG5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuXHQgICAgdmFyIGZpbGVfc3RydWN0ID0ge1xuXHQgICAgICBmaWxlOiBmaWxlLFxuXHQgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICBpZDogdWlkKCksXG5cdCAgICAgIHNpemU6IHNpemUsXG5cdCAgICAgIHNpemV0ZXh0OiBmb3JtYXQsXG5cdCAgICAgIHR5cGU6IHR5cGUkJDEsXG5cdCAgICAgIGNvbnRleHQ6IHRoaXMuX2xhc3RfZmlsZV9jb250ZXh0LFxuXHQgICAgICBzdGF0dXM6IFwiY2xpZW50XCJcblx0ICAgIH07XG5cdCAgICBpZiAoZmlsZSAmJiBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aCkgZmlsZV9zdHJ1Y3QubmFtZSA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuXHQgICAgaWYgKGV4dHJhKSBleHBvcnRzLmV4dGVuZChmaWxlX3N0cnVjdCwgZXh0cmEsIHRydWUpO1xuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUZpbGVBZGRcIiwgW2ZpbGVfc3RydWN0XSkpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5tdWx0aXBsZSkgdGhpcy5maWxlcy5jbGVhckFsbCgpO1xuXHQgICAgICB2YXIgaWQgPSB0aGlzLmZpbGVzLmFkZChmaWxlX3N0cnVjdCk7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckZpbGVBZGRcIiwgW2ZpbGVfc3RydWN0XSk7XG5cdCAgICAgIGlmIChpZCAmJiB0aGlzLl9zZXR0aW5ncy5hdXRvc2VuZCkgdGhpcy5zZW5kKGlkKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZpbGVfc3RydWN0O1xuXHQgIH0sXG5cdCAgX2dldF9hY3RpdmVfdXJsOiBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgdmFyIHVybCA9IHRoaXMuX3NldHRpbmdzLnVwbG9hZDtcblx0ICAgIHZhciB1cmxkYXRhID0gZXhwb3J0cy5leHRlbmQoaXRlbS51cmxEYXRhIHx8IHt9LCB0aGlzLl9zZXR0aW5ncy51cmxEYXRhIHx8IHt9KTtcblxuXHQgICAgaWYgKHVybCAmJiB1cmxkYXRhKSB7XG5cdCAgICAgIHZhciBzdWJsaW5lID0gW107XG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIHVybGRhdGEpIHtcblx0ICAgICAgICBzdWJsaW5lLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh1cmxkYXRhW2tleV0pKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzdWJsaW5lLmxlbmd0aCkgdXJsICs9ICh1cmwuaW5kZXhPZihcIj9cIikgPT0gLTEgPyBcIj9cIiA6IFwiJlwiKSArIHN1YmxpbmUuam9pbihcIiZcIik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1cmw7XG5cdCAgfSxcblx0ICBhZGREcm9wWm9uZTogZnVuY3Rpb24gKGlkLCBob3Zlcl90ZXh0KSB7XG5cdCAgICB2YXIgbm9kZSA9IHRvTm9kZShpZCk7XG5cdCAgICB2YXIgZXh0cmFfY3NzID0gXCJcIjtcblx0ICAgIGlmIChob3Zlcl90ZXh0KSBleHRyYV9jc3MgPSBcIiBcIiArIGNyZWF0ZUNzcyh7XG5cdCAgICAgIGNvbnRlbnQ6IFwiXFxcIlwiICsgaG92ZXJfdGV4dCArIFwiXFxcIlwiXG5cdCAgICB9LCBcIjpiZWZvcmVcIik7XG5cdCAgICB2YXIgZnVsbGNzcyA9IFwid2ViaXhfZHJvcF9maWxlXCIgKyBleHRyYV9jc3M7XG5cdCAgICB2YXIgdGltZXIgPSBudWxsOyAvL3dlYlxuXG5cdCAgICBfZXZlbnQobm9kZSwgXCJkcmFnb3ZlclwiLCBwcmV2ZW50RXZlbnQpO1xuXG5cdCAgICBfZXZlbnQobm9kZSwgXCJkcmFnb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGFkZENzcyhub2RlLCBmdWxsY3NzLCB0cnVlKTtcblxuXHQgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICAgIHRpbWVyID0gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIF9ldmVudChub2RlLCBcImRyYWdsZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vd2hlbiBtb3Zpbmcgb3ZlciBodG1sIGNoaWxkIGVsZW1lbnRzXG5cdCAgICAgIC8vYnJvd3NlciB3aWxsIGlzc3VlIGRyYWdsZWF2ZSBhbmQgZHJhZ292ZXIgZXZlbnRzXG5cdCAgICAgIC8vaWdub3JlIGZpcnN0IG9uZVxuXHQgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJlbW92ZUNzcyhub2RlLCBmdWxsY3NzKTtcblx0ICAgICAgfSwgMTUwKTtcblx0ICAgIH0pO1xuXG5cdCAgICBfZXZlbnQobm9kZSwgXCJkcm9wXCIsIGJpbmQoZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgcmVtb3ZlQ3NzKG5vZGUsIGZ1bGxjc3MpO1xuXG5cdCAgICAgIHRoaXMuX2Ryb3AoZSk7XG5cblx0ICAgICAgcmV0dXJuIHByZXZlbnRFdmVudChlKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICB9LFxuXHQgIF9mb3JtYXRfc2l6ZTogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgIHZhciBpbmRleCQkMSA9IDA7XG5cblx0ICAgIHdoaWxlIChzaXplID4gMTAyNCkge1xuXHQgICAgICBpbmRleCQkMSsrO1xuXHQgICAgICBzaXplID0gc2l6ZSAvIDEwMjQ7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKHNpemUgKiAxMDApIC8gMTAwICsgXCIgXCIgKyBpMThuLmZpbGVTaXplW2luZGV4JCQxXTtcblx0ICB9LFxuXHQgIF9jb21wbGV0ZTogZnVuY3Rpb24gKGlkLCByZXNwb25zZSkge1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbGVzLmdldEl0ZW0oaWQpO1xuXHQgICAgZXhwb3J0cy5leHRlbmQoaXRlbSwgcmVzcG9uc2UsIHRydWUpO1xuXHQgICAgaXRlbS5zdGF0dXMgPSBcInNlcnZlclwiO1xuXHQgICAgaXRlbS5wcm9ncmVzcyA9IDEwMDtcblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25GaWxlVXBsb2FkXCIsIFtpdGVtLCByZXNwb25zZV0pO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkNoYW5nZVwiLCBbXSk7XG5cdCAgICB0aGlzLmZpbGVzLnVwZGF0ZUl0ZW0oaWQpO1xuXHQgICAgaWYgKHRoaXMuaXNVcGxvYWRlZCgpKSB0aGlzLl91cGxvYWRfY29tcGxldGUocmVzcG9uc2UpO1xuXHQgIH0sXG5cdCAgX3VwbG9hZF9jb21wbGV0ZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uVXBsb2FkQ29tcGxldGVcIiwgW3Jlc3BvbnNlXSk7XG5cblx0ICAgIGlmICh0aGlzLl9sYXN0X2Fzc2lnbmVkX3VwbG9hZF9jYWxsYmFjaykge1xuXHQgICAgICB0aGlzLl9sYXN0X2Fzc2lnbmVkX3VwbG9hZF9jYWxsYmFjay5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcblxuXHQgICAgICB0aGlzLl9sYXN0X2Fzc2lnbmVkX3VwbG9hZF9jYWxsYmFjayA9IDA7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBpc1VwbG9hZGVkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgb3JkZXIgPSB0aGlzLmZpbGVzLmRhdGEub3JkZXI7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuZmlsZXMuZ2V0SXRlbShvcmRlcltpXSkuc3RhdHVzICE9IFwic2VydmVyXCIpIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICAkb25VcGxvYWRDb21wbGV0ZTogZnVuY3Rpb24gKCkge30sXG5cdCAgJHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoaWQsIHBlcmNlbnQpIHtcblx0ICAgIHZhciBpdGVtID0gdGhpcy5maWxlcy5nZXRJdGVtKGlkKTtcblx0ICAgIGl0ZW0ucGVyY2VudCA9IE1hdGgucm91bmQocGVyY2VudCk7XG5cdCAgICB0aGlzLmZpbGVzLnVwZGF0ZUl0ZW0oaWQpO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHZhbHVlKSB2YWx1ZSA9IHtcblx0ICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICBzdGF0dXM6IFwic2VydmVyXCJcblx0ICAgIH07XG5cdCAgICB0aGlzLmZpbGVzLmNsZWFyQWxsKCk7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuZmlsZXMucGFyc2UodmFsdWUpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkNoYW5nZVwiLCBbXSk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRhdGEgPSBbXTtcblx0ICAgIHRoaXMuZmlsZXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgaWYgKG9iai5zdGF0dXMgPT0gXCJzZXJ2ZXJcIikgZGF0YS5wdXNoKG9iai52YWx1ZSB8fCBvYmoubmFtZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBkYXRhLmpvaW4oXCIsXCIpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckUiA9IGV4cG9ydHMucHJvdG9VSShhcGkkUiwgYnV0dG9uJDEudmlldyk7XG5cblx0dmFyIGFwaSRTID0ge1xuXHQgIG5hbWU6IFwic3VnZ2VzdFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBhdXRvZm9jdXM6IGZhbHNlLFxuXHQgICAgdHlwZTogXCJsaXN0XCIsXG5cdCAgICBrZXlQcmVzc1RpbWVvdXQ6IDEsXG5cdCAgICBib2R5OiB7XG5cdCAgICAgIHlDb3VudDogMTAsXG5cdCAgICAgIGF1dG9oZWlnaHQ6IHRydWUsXG5cdCAgICAgIGJvZHk6IHRydWUsXG5cdCAgICAgIHNlbGVjdDogdHJ1ZSxcblx0ICAgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgICAgbmF2aWdhdGlvbjogdHJ1ZVxuXHQgICAgfSxcblx0ICAgIGZpbHRlcjogZnVuY3Rpb24gKGl0ZW0sIHZhbHVlKSB7XG5cdCAgICAgIGlmIChpdGVtLnZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpID09PSAwKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgdGVtcGxhdGVfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBmaWx0ZXJfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0b0Z1bmN0b3IodmFsdWUsIHRoaXMuJHNjb3BlKTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB2YXIgdGVtcCA9IHt9O1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGVtcCwgY29weSh0aGlzLmRlZmF1bHRzLmJvZHkpKTtcblx0ICAgIHRlbXAudmlldyA9IG9iai50eXBlIHx8IHRoaXMuZGVmYXVsdHMudHlwZTtcblxuXHQgICAgdmFyIGV0ZW1wID0gdGhpcy5fZ2V0X2V4dGVuZGFibGVfY2VsbCh0ZW1wKTtcblxuXHQgICAgaWYgKG9iai5ib2R5KSBleHBvcnRzLmV4dGVuZChldGVtcCwgb2JqLmJvZHksIHRydWUpO1xuXHQgICAgaWYgKG9iai5kYXRhKSBldGVtcC5kYXRhID0gb2JqLmRhdGE7XG5cdCAgICBpZiAob2JqLnVybCkgZXRlbXAudXJsID0gb2JqLnVybDtcblx0ICAgIGlmIChvYmouZGF0YXR5cGUpIGV0ZW1wLmRhdGF0eXBlID0gb2JqLmRhdGF0eXBlO1xuXHQgICAgaWYgKG9iai5pZCkgdGVtcC5pZCA9IHRlbXAuaWQgfHwgb2JqLmlkICsgXCJfXCIgKyB0ZW1wLnZpZXc7XG5cdCAgICBvYmouYm9keSA9IHRlbXA7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMuX3NldF9vbl9wb3B1cF9jbGljayk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TaG93XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1hc3Rlcikge1xuXHQgICAgICAgIHZhciBtYXN0ZXIgPSAkJCh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpO1xuXG5cdCAgICAgICAgaWYgKG1hc3Rlcikge1xuXHQgICAgICAgICAgdmFyIG5vZGUgPSBtYXN0ZXIuX2dldElucHV0RGl2ID8gbWFzdGVyLl9nZXRJbnB1dERpdigpIDogbWFzdGVyLmdldElucHV0Tm9kZSgpO1xuXHQgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9zaG93X3NlbGVjdGlvbigpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25IaWRlXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1hc3Rlcikge1xuXHQgICAgICAgIHZhciBtYXN0ZXIgPSAkJCh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpO1xuXG5cdCAgICAgICAgaWYgKG1hc3Rlcikge1xuXHQgICAgICAgICAgdmFyIG5vZGUgPSBtYXN0ZXIuX2dldElucHV0RGl2ID8gbWFzdGVyLl9nZXRJbnB1dERpdigpIDogbWFzdGVyLmdldElucHV0Tm9kZSgpO1xuXHQgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuX29sZF90ZXh0ID0ge307XG5cdCAgfSxcblx0ICBfZ2V0X2V4dGVuZGFibGVfY2VsbDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9LFxuXHQgIF9wcmVzZWxlY3RNYXN0ZXJPcHRpb246IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICB2YXIgbWFzdGVyLFxuXHQgICAgICAgIG5vZGUsXG5cdCAgICAgICAgdGV4dCA9IFwiXCI7XG5cblx0ICAgIGlmIChkYXRhKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpIHtcblx0ICAgICAgICBtYXN0ZXIgPSAkJCh0aGlzLl9zZXR0aW5ncy5tYXN0ZXIpO1xuXHQgICAgICAgIG5vZGUgPSBtYXN0ZXIuZ2V0SW5wdXROb2RlKCk7XG5cblx0ICAgICAgICBpZiAobm9kZSAmJiBtYXN0ZXIuJHNldFZhbHVlSGVyZSkge1xuXHQgICAgICAgICAgbWFzdGVyLiRzZXRWYWx1ZUhlcmUoZGF0YS52YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG5cdCAgICAgICAgICBpZiAobWFzdGVyLm9wdGlvbnNfc2V0dGVyKSB0ZXh0ID0gdGhpcy5nZXRJdGVtVGV4dChkYXRhLmlkKTtlbHNlIGlmIChkYXRhLnZhbHVlKSB0ZXh0ID0gbWFzdGVyLl9nZXRfdmlzaWJsZV90ZXh0ID8gbWFzdGVyLl9nZXRfdmlzaWJsZV90ZXh0KGRhdGEudmFsdWUpIDogZGF0YS52YWx1ZS50b1N0cmluZygpO1xuXHQgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vZGUudmFsdWUpKSBub2RlLmlubmVySFRNTCA9IHRleHQ7ZWxzZSBub2RlLnZhbHVlID0gdGV4dC5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBub2RlID0gbm9kZSB8fCB0aGlzLl9sYXN0X2lucHV0X3RhcmdldDtcblx0ICAgIGlmIChub2RlKSBub2RlLmZvY3VzKCk7XG5cdCAgfSxcblx0ICBzZXRNYXN0ZXJWYWx1ZTogZnVuY3Rpb24gKGRhdGEsIHJlZnJlc2gpIHtcblx0ICAgIHZhciB0ZXh0ID0gZGF0YS5pZCA/IHRoaXMuZ2V0SXRlbVRleHQoZGF0YS5pZCkgOiBkYXRhLnRleHQgfHwgZGF0YS52YWx1ZTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1hc3Rlcikge1xuXHQgICAgICB2YXIgbWFzdGVyID0gJCQodGhpcy5fc2V0dGluZ3MubWFzdGVyKTtcblx0ICAgICAgaWYgKHJlZnJlc2ggJiYgZGF0YS5pZCkgbWFzdGVyLnJlZnJlc2goKTtlbHNlIGlmIChtYXN0ZXIub3B0aW9uc19zZXR0ZXIpIG1hc3Rlci5zZXRWYWx1ZShkYXRhLiRlbXB0eSA/IFwiXCIgOiBkYXRhLmlkKTtlbHNlIGlmIChtYXN0ZXIuc2V0VmFsdWVIZXJlKSBtYXN0ZXIuc2V0VmFsdWVIZXJlKHRleHQpO2Vsc2UgbWFzdGVyLnNldFZhbHVlKHRleHQpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0X2lucHV0X3RhcmdldCkge1xuXHQgICAgICB0aGlzLl9sYXN0X2lucHV0X3RhcmdldC52YWx1ZSA9IHRleHQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICghcmVmcmVzaCkge1xuXHQgICAgICB0aGlzLmhpZGUodHJ1ZSk7XG5cdCAgICAgIGlmICh0aGlzLl9sYXN0X2lucHV0X3RhcmdldCkgdGhpcy5fbGFzdF9pbnB1dF90YXJnZXQuZm9jdXMoKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblZhbHVlU3VnZ2VzdFwiLCBbZGF0YSwgdGV4dF0pO1xuXHQgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICBjYWxsRXZlbnQoXCJvbkVkaXRFbmRcIiwgW10pO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBnZXRNYXN0ZXJWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1hc3RlcikgcmV0dXJuICQkKHRoaXMuX3NldHRpbmdzLm1hc3RlcikuZ2V0VmFsdWUoKTtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgZ2V0SXRlbUlkOiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgdmFyIGxpc3QgPSB0aGlzLmdldExpc3QoKTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIGxpc3QuZGF0YS5wdWxsKSB7XG5cdCAgICAgIHZhciBvYmogPSBsaXN0LmdldEl0ZW0oa2V5KTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmZpbHRlci5jYWxsKHRoaXMsIG9iaiwgdGV4dCkpIHJldHVybiBvYmouaWQ7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRJdGVtVGV4dDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0TGlzdCgpLmdldEl0ZW0oaWQpO1xuXHQgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcy5fb2xkX3RleHRbaWRdIHx8IFwiXCI7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudGVtcGxhdGUpIHJldHVybiB0aGlzLl9zZXR0aW5ncy50ZW1wbGF0ZS5jYWxsKHRoaXMsIGl0ZW0sIHRoaXMudHlwZSk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudGV4dFZhbHVlKSByZXR1cm4gXCJcIiArIGl0ZW1bdGhpcy5fc2V0dGluZ3MudGV4dFZhbHVlXSArIFwiXCI7XG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0TGlzdCgpLnR5cGU7XG5cdCAgICB2YXIgdGV4dCA9IHR5cGUudGVtcGxhdGUuY2FsbCh0eXBlLCBpdGVtLCB0eXBlKTtcblx0ICAgIHJldHVybiB0aGlzLl9vbGRfdGV4dFtpZF0gPSB0ZXh0O1xuXHQgIH0sXG5cdCAgZ2V0U3VnZ2VzdGlvbjogZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgIHZhciBpZCxcblx0ICAgICAgICBsaXN0ID0gdGhpcy5nZXRMaXN0KCksXG5cdCAgICAgICAgb3JkZXIgPSBsaXN0LmRhdGEub3JkZXI7XG5cdCAgICBpZiAobGlzdC5nZXRTZWxlY3RlZElkKSBpZCA9IGxpc3QuZ2V0U2VsZWN0ZWRJZCgpO1xuXG5cdCAgICBpZiAodGV4dCAmJiBvcmRlci5sZW5ndGggJiYgKCFpZCB8fCBvcmRlci5maW5kKGlkKSA8IDApKSB7XG5cdCAgICAgIGlkID0gb3JkZXJbMF07IC8vZW5zdXJlIHRoYXQgb3B0aW9uIHJlYWxseSBkb2VzIG1hdGNoIGNsaWVudC1zaWRlIGZpbHRlcmluZyBydWxlc1xuXG5cdCAgICAgIGlmICghbGlzdC5jb25maWcuZGF0YUZlZWQgJiYgIXRoaXMuY29uZmlnLmZpbHRlci5jYWxsKHRoaXMsIGxpc3QuZGF0YS5wdWxsW2lkXSwgdGV4dCkpIHJldHVybiBudWxsO1xuXHQgICAgfSAvL2NvbXBsZXggaWQgaW4gZGF0YXRhYmxlXG5cblxuXHQgICAgaWYgKGlkICYmIF90eXBlb2YoaWQpID09IFwib2JqZWN0XCIpIGlkID0gaWQgKyBcIlwiO1xuXHQgICAgcmV0dXJuIGlkO1xuXHQgIH0sXG5cdCAgZ2V0TGlzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2JvZHlfY2VsbDtcblx0ICB9LFxuXHQgIF9zZXRfb25fcG9wdXBfY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBsaXN0ID0gdGhpcy5nZXRMaXN0KCk7XG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuX3NldHRpbmdzLnR5cGU7XG5cblx0ICAgIGlmIChsaXN0LmNvdW50KSB7XG5cdCAgICAgIGxpc3QuYXR0YWNoRXZlbnQoXCJvbkl0ZW1DbGlja1wiLCBiaW5kKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgdGhpcy5zZXRNYXN0ZXJWYWx1ZShsaXN0LmdldEl0ZW0oaXRlbSkpO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICAgIGxpc3QuZGF0YS5hdHRhY2hFdmVudChcIm9uc3RvcmV1cGRhdGVkXCIsIGJpbmQoZnVuY3Rpb24gKGlkLCBvYmosIG1vZGUpIHtcblx0ICAgICAgICBpZiAobW9kZSA9PSBcImRlbGV0ZVwiICYmIGlkID09IHRoaXMuZ2V0TWFzdGVyVmFsdWUoKSkgdGhpcy5zZXRNYXN0ZXJWYWx1ZSh7XG5cdCAgICAgICAgICBpZDogXCJcIixcblx0ICAgICAgICAgIHRleHQ6IFwiXCJcblx0ICAgICAgICB9LCAxKTtlbHNlIGlmIChtb2RlID09IFwidXBkYXRlXCIgJiYgaWQgPT0gdGhpcy5nZXRNYXN0ZXJWYWx1ZSgpKSB7XG5cdCAgICAgICAgICB0aGlzLnNldE1hc3RlclZhbHVlKG9iaiwgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICAgIGxpc3QuZGF0YS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJGaWx0ZXJcIiwgYmluZCh0aGlzLl9zdWdnZXN0X2FmdGVyX2ZpbHRlciwgdGhpcykpO1xuXHQgICAgICBsaXN0LmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlTG9hZFwiLCBiaW5kKHRoaXMuX3N1Z2dlc3RfYWZ0ZXJfZmlsdGVyLCB0aGlzKSk7XG5cdCAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLl9zZXR0aW5ncy5maXRNYXN0ZXIpKSB0aGlzLl9zZXR0aW5ncy5maXRNYXN0ZXIgPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlID09IFwiY2FsZW5kYXJcIikge1xuXHQgICAgICBsaXN0LmF0dGFjaEV2ZW50KFwib25EYXRlU2VsZWN0XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmdldFBhcmVudFZpZXcoKS5zZXRNYXN0ZXJWYWx1ZSh7XG5cdCAgICAgICAgICB2YWx1ZTogbGlzdC5nZXRTZWxlY3RlZERhdGUoKVxuXHQgICAgICAgIH0sIGxpc3QuY29uZmlnLm11bHRpc2VsZWN0KTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGxpc3QuYXR0YWNoRXZlbnQoXCJvblRvZGF5U2V0XCIsIGZ1bmN0aW9uIChkYXRlKSB7XG5cdCAgICAgICAgdGhpcy5nZXRQYXJlbnRWaWV3KCkuc2V0TWFzdGVyVmFsdWUoe1xuXHQgICAgICAgICAgdmFsdWU6IGRhdGVcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGxpc3QuYXR0YWNoRXZlbnQoXCJvbkRhdGVDbGVhclwiLCBmdW5jdGlvbiAoZGF0ZSkge1xuXHQgICAgICAgIHRoaXMuZ2V0UGFyZW50VmlldygpLnNldE1hc3RlclZhbHVlKHtcblx0ICAgICAgICAgIHZhbHVlOiBkYXRlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlID09IFwiY29sb3Jib2FyZFwiKSB7XG5cdCAgICAgIGxpc3QuYXR0YWNoRXZlbnQoXCJvbkl0ZW1DbGlja1wiLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB0aGlzLmdldFBhcmVudFZpZXcoKS5zZXRNYXN0ZXJWYWx1ZSh7XG5cdCAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBpbnB1dF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5saW5rSW5wdXQodmFsdWUpO1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfSxcblx0ICBsaW5rSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgdmFyIG5vZGU7XG5cblx0ICAgIGlmIChpbnB1dC5nZXRJbnB1dE5vZGUpIHtcblx0ICAgICAgbm9kZSA9IGlucHV0LmdldElucHV0Tm9kZSgpO1xuXHQgICAgICBub2RlLndlYml4X21hc3Rlcl9pZCA9IGlucHV0Ll9zZXR0aW5ncy5pZDtcblx0ICAgIH0gZWxzZSBub2RlID0gdG9Ob2RlKGlucHV0KTtcblxuXHQgICAgX2V2ZW50KG5vZGUsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAoKG5vZGUgIT0gZG9jdW1lbnQuYm9keSB8fCB0aGlzLmlzVmlzaWJsZSgpKSAmJiAoaW5wdXQuY29uZmlnID8gIWlucHV0LmNvbmZpZy5yZWFkb25seSA6ICFub2RlLmdldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIpKSkgdGhpcy5fc3VnZ2VzdGlvbnMoZSk7XG5cdCAgICB9LCB7XG5cdCAgICAgIGJpbmQ6IHRoaXNcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAoaW5wdXQuX2dldElucHV0RGl2KSBub2RlID0gaW5wdXQuX2dldElucHV0RGl2KCk7XG5cdCAgICBub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtYXV0b2NvbXBsZXRlXCIsIFwibGlzdFwiKTtcblx0ICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpO1xuXG5cdCAgICBpZiAobm9kZS50YWdOYW1lID09PSBcIkRJVlwiKSB7XG5cdCAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwiYXNzZXJ0aXZlXCIpO1xuXHQgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImFyaWEtYXRvbWljXCIsIFwidHJ1ZVwiKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fbm9uX3VpX21vZGUgPSB0cnVlO1xuXHQgIH0sXG5cdCAgX3N1Z2dlc3Rpb25zOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgZSA9IGUgfHwgZXZlbnQ7XG5cdCAgICB2YXIgbGlzdCA9IHRoaXMuZ2V0TGlzdCgpO1xuXHQgICAgdmFyIHRyZyA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0ICAgIGlmICh0cmcgPT0gZG9jdW1lbnQuYm9keSAmJiAhdGhpcy5pc1Zpc2libGUoKSB8fCB0cmcuY2xhc3NOYW1lID09IFwid2ViaXhfY2xpcGJ1ZmZlclwiKSByZXR1cm47XG5cdCAgICB0aGlzLl9sYXN0X2lucHV0X3RhcmdldCA9IHRyZztcblx0ICAgIHRoaXMuX3NldHRpbmdzLm1hc3RlciA9IHRyZy53ZWJpeF9tYXN0ZXJfaWQ7XG5cdCAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2tleV90aW1lcik7XG5cdCAgICB2YXIgY29kZSA9IGUua2V5Q29kZTsgLy9zaGlmdCBhbmQgY3RybFxuXG5cdCAgICBpZiAoY29kZSA9PSAxNiB8fCBjb2RlID09IDE3KSByZXR1cm47IC8vIHRhYiAtIGhpZGUgcG9wdXAgYW5kIGRvIG5vdGhpbmdcblxuXHQgICAgaWYgKGNvZGUgPT0gOSkgcmV0dXJuIHRoaXMuX3RhYl9rZXkodGhpcywgbGlzdCk7IC8vIGVzY2FwZSAtIGhpZGUgcG9wdXBcblxuXHQgICAgaWYgKGNvZGUgPT0gMjcpIHJldHVybiB0aGlzLl9lc2NhcGVfa2V5KHRoaXMsIGxpc3QpOyAvLyBlbnRlclxuXG5cdCAgICBpZiAoY29kZSA9PSAxMykgcmV0dXJuIHRoaXMuJGVudGVyS2V5KHRoaXMsIGxpc3QpOyAvLyB1cC9kb3duL3JpZ2h0L2xlZnQgYXJlIHVzZWQgZm9yIG5hdmlnYXRpb25cblxuXHQgICAgaWYgKHRoaXMuX25hdmlnYXRlKGUpKSB7XG5cdCAgICAgIHByZXZlbnRFdmVudChlKTtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaXNVbmRlZmluZWQodHJnLnZhbHVlKSkgcmV0dXJuO1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xhc3RfZGVsYXkpO1xuXHQgICAgdGhpcy5fbGFzdF9kZWxheSA9IGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgLy9mb2N1cyBtb3ZlZCB0byB0aGUgZGlmZmVyZW50IGNvbnRyb2wsIHN1Z2dlc3QgaXMgbm90IG5lY2Vzc2FyeVxuXHQgICAgICBpZiAoIXRoaXMuX25vbl91aV9tb2RlICYmIFVJTWFuYWdlci5nZXRGb2N1cygpICE9ICQkKHRoaXMuX3NldHRpbmdzLm1hc3RlcikpIHJldHVybjtcblx0ICAgICAgdGhpcy5fcmVzb2x2ZV9wb3B1cCA9IHRydWU7IC8vZm9yIG11bHRpY29tYm9cblxuXHQgICAgICB2YXIgdmFsID0gdHJnLnZhbHVlOyAvLyB1c2VkIHRvIHByZXZlbnQgc2hvd2luZyBwb3B1cCB3aGVuIGl0IHdhcyBpbml0aWFsaXplZFxuXG5cdCAgICAgIGlmIChsaXN0LmNvbmZpZy5kYXRhRmVlZCkgbGlzdC5maWx0ZXIoXCJ2YWx1ZVwiLCB2YWwpO2Vsc2UgaWYgKGxpc3QuZmlsdGVyKSB7XG5cdCAgICAgICAgbGlzdC5maWx0ZXIoYmluZChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzLmZpbHRlci5jYWxsKHRoaXMsIGl0ZW0sIHZhbCk7XG5cdCAgICAgICAgfSwgdGhpcykpO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzLCBbXSwgdGhpcy5fc2V0dGluZ3Mua2V5UHJlc3NUaW1lb3V0KTtcblx0ICB9LFxuXHQgIF9zdWdnZXN0X2FmdGVyX2ZpbHRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLl9yZXNvbHZlX3BvcHVwKSByZXR1cm4gdHJ1ZTtcblx0ICAgIHRoaXMuX3Jlc29sdmVfcG9wdXAgPSBmYWxzZTtcblx0ICAgIHZhciBsaXN0ID0gdGhpcy5nZXRMaXN0KCk7IC8vIGZpbHRlcmluZyBpcyBjb21wbGV0ZVxuXHQgICAgLy8gaWYgdGhlcmUgYXJlIGFzIG1pbiAxIHZhcmlhbnQgaXQgbXVzdCBiZSBzaG93biwgaGlkZGVuIG90aGVyd2lzZVxuXG5cdCAgICBpZiAobGlzdC5jb3VudCgpID4gMCkge1xuXHQgICAgICB0aGlzLmFkanVzdCgpO1xuXHQgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkpIHRoaXMuX2RvbnRfdW5maWx0ZXIgPSB0cnVlO1xuXHQgICAgICB0aGlzLnNob3codGhpcy5fbGFzdF9pbnB1dF90YXJnZXQsIG51bGwsIHRydWUpO1xuXHQgICAgICB0aGlzLl9kb250X3VuZmlsdGVyID0gZmFsc2U7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmhpZGUodHJ1ZSk7XG5cdCAgICAgIHRoaXMuX2xhc3RfaW5wdXRfdGFyZ2V0ID0gbnVsbDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHNob3c6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkpIHtcblx0ICAgICAgdmFyIGxpc3QgPSB0aGlzLmdldExpc3QoKTtcblxuXHQgICAgICBpZiAobGlzdC5maWx0ZXIgJiYgIXRoaXMuX2RvbnRfdW5maWx0ZXIpIHtcblx0ICAgICAgICBsaXN0LmZpbHRlcihcIlwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLiRjdXN0b21XaWR0aCkge1xuXHQgICAgICAgIHRoaXMuJGN1c3RvbVdpZHRoKG5vZGUpO1xuXHQgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnTmFtZSAmJiB0aGlzLl9zZXR0aW5ncy5maXRNYXN0ZXIpIHtcblx0ICAgICAgICB0aGlzLl9zZXR0aW5ncy53aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGggLSAyOyAvLzIgLSBib3JkZXJzXG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobGlzdC5fem9vbV9sZXZlbCkgbGlzdC5yZW5kZXIoKTtcblx0ICAgICAgdGhpcy5hZGp1c3QoKTsgLy8gbmVlZGVkIHRvIHJldHVybiBmb2N1c1xuXG5cdCAgICAgIGlmIChub2RlLnRhZ05hbWUgPT0gXCJJTlBVVFwiKSB0aGlzLl9sYXN0X2lucHV0X3RhcmdldCA9IG5vZGU7XG5cdCAgICB9XG5cblx0ICAgIHBvcHVwLmFwaS5zaG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfSxcblx0ICBfc2hvd19zZWxlY3Rpb246IGZ1bmN0aW9uIChsaXN0KSB7XG5cdCAgICBsaXN0ID0gbGlzdCB8fCB0aGlzLmdldExpc3QoKTtcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0TWFzdGVyVmFsdWUoKTtcblxuXHQgICAgaWYgKGxpc3Quc2VsZWN0ICYmIGxpc3Quc2hvd0l0ZW0pIHtcblx0ICAgICAgaWYgKHZhbHVlICYmIGxpc3QuZXhpc3RzICYmIGxpc3QuZXhpc3RzKHZhbHVlKSkge1xuXHQgICAgICAgIGxpc3Quc2VsZWN0KHZhbHVlKTtcblx0ICAgICAgICBsaXN0LnNob3dJdGVtKHZhbHVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBsaXN0LnVuc2VsZWN0KCk7XG5cdCAgICAgICAgbGlzdC5zaG93SXRlbShsaXN0LmdldEZpcnN0SWQoKSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobGlzdC5zZXRWYWx1ZSkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubWFzdGVyKSB2YWx1ZSA9ICQkKHRoaXMuX3NldHRpbmdzLm1hc3RlcikuJHByZXBhcmVWYWx1ZSh2YWx1ZSk7XG5cdCAgICAgIGxpc3Quc2V0VmFsdWUodmFsdWUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgJGVudGVyS2V5OiBmdW5jdGlvbiAocG9wdXAkJDEsIGxpc3QpIHtcblx0ICAgIHZhciB2YWx1ZTtcblxuXHQgICAgaWYgKHBvcHVwJCQxLmlzVmlzaWJsZSgpKSB7XG5cdCAgICAgIGlmIChsaXN0LmNvdW50ICYmIGxpc3QuY291bnQoKSkge1xuXHQgICAgICAgIHZhbHVlID0gbGlzdC5nZXRTZWxlY3RlZElkKGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICBpZiAobGlzdC5jb3VudCgpID09IDEgJiYgbGlzdC5nZXRGaXJzdElkKCkgIT0gdmFsdWUpIHZhbHVlID0gbGlzdC5nZXRGaXJzdElkKCk7XG5cdCAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IGxpc3QuZ2V0SXRlbSh2YWx1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAobGlzdC5nZXRTZWxlY3RlZERhdGUgJiYgbGlzdC5nZXRTZWxlY3RlZERhdGUoKSkgdmFsdWUgPSB7XG5cdCAgICAgICAgdmFsdWU6IGxpc3QuZ2V0U2VsZWN0ZWREYXRlKClcblx0ICAgICAgfTtlbHNlIGlmIChsaXN0LmdldFZhbHVlICYmIGxpc3QuZ2V0VmFsdWUoKSkgdmFsdWUgPSB7XG5cdCAgICAgICAgdmFsdWU6IGxpc3QuZ2V0VmFsdWUoKVxuXHQgICAgICB9O1xuXG5cdCAgICAgIGlmICh2YWx1ZSkgdGhpcy5zZXRNYXN0ZXJWYWx1ZSh2YWx1ZSk7XG5cdCAgICAgIHBvcHVwJCQxLmhpZGUodHJ1ZSk7XG5cdCAgICB9IGVsc2UgcG9wdXAkJDEuc2hvdyh0aGlzLl9sYXN0X2lucHV0X3RhcmdldCk7XG5cdCAgfSxcblx0ICBfZXNjYXBlX2tleTogZnVuY3Rpb24gKHBvcHVwJCQxKSB7XG5cdCAgICByZXR1cm4gcG9wdXAkJDEuaGlkZSh0cnVlKTtcblx0ICB9LFxuXHQgIF90YWJfa2V5OiBmdW5jdGlvbiAocG9wdXAkJDEpIHtcblx0ICAgIHJldHVybiBwb3B1cCQkMS5oaWRlKHRydWUpO1xuXHQgIH0sXG5cblx0ICAvKiEgc3VnZ2VzdGlvbnMgbmF2aWdhdGlvbjogdXAvZG93biBidXR0b25zIG1vdmUgc2VsZWN0aW9uXG5cdCAgICpcdEBwYXJhbSBlXG5cdCAgICpcdFx0ZXZlbnQgb2JqZWN0XG5cdCAgICoqL1xuXHQgIF9uYXZpZ2F0ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBsaXN0ID0gdGhpcy5nZXRMaXN0KCk7XG5cdCAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcblx0ICAgIHZhciBkYXRhO1xuXG5cdCAgICBpZiAobGlzdC5tb3ZlU2VsZWN0aW9uICYmIGNvZGUgPCA0MSAmJiBjb2RlID4gMzIgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5ICYmICFlLnNoaWZ0S2V5ICYmICFlLmFsdEtleSkge1xuXHQgICAgICAvLyBkb3duIGFycm93XG5cdCAgICAgIGlmIChjb2RlID09PSA0MCkge1xuXHQgICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5pc1Zpc2libGUoKTtcblx0ICAgICAgICBpZiAoIXZpc2libGUpIHRoaXMuc2hvdyh0aGlzLl9sYXN0X2lucHV0X3RhcmdldCk7XG5cdCAgICAgICAgbGlzdC5tb3ZlU2VsZWN0aW9uKFwiZG93blwiLCBmYWxzZSwgZmFsc2UpO1xuXHQgICAgICB9IC8vIG90aGVyIGFycm93c1xuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICAgIGlmIChsaXN0LmNvdW50ICYmIGNvZGUgIT09IDM4IHx8ICFsaXN0LmNvdW50ICYmICFsaXN0LmlzVmlzaWJsZSgpKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICB2YXIgZGlyO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gMzMpIGRpciA9IFwicGd1cFwiO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gMzQpIGRpciA9IFwicGdkb3duXCI7XG5cdCAgICAgICAgICBpZiAoY29kZSA9PSAzNSkgZGlyID0gXCJib3R0b21cIjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDM2KSBkaXIgPSBcInRvcFwiO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gMzcpIGRpciA9IFwibGVmdFwiO1xuXHQgICAgICAgICAgaWYgKGNvZGUgPT0gMzgpIGRpciA9IFwidXBcIjtcblx0ICAgICAgICAgIGlmIChjb2RlID09IDM5KSBkaXIgPSBcInJpZ2h0XCI7XG5cdCAgICAgICAgICBsaXN0Lm1vdmVTZWxlY3Rpb24oZGlyLCBmYWxzZSwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICBpZiAobGlzdC5jb3VudCkgZGF0YSA9IGxpc3QuZ2V0U2VsZWN0ZWRJdGVtKCk7ZWxzZSBpZiAobGlzdC5nZXRTZWxlY3RlZERhdGUpIGRhdGEgPSB7XG5cdCAgICAgICAgdmFsdWU6IGxpc3QuZ2V0VmlzaWJsZURhdGUoKVxuXHQgICAgICB9O2Vsc2UgaWYgKGxpc3QuZ2V0VmFsdWUpIGRhdGEgPSB7XG5cdCAgICAgICAgdmFsdWU6IGxpc3QuZ2V0VmFsdWUoKVxuXHQgICAgICB9O1xuXG5cdCAgICAgIHRoaXMuX3ByZXNlbGVjdE1hc3Rlck9wdGlvbihkYXRhKTtcblxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBsaXN0ID0gdGhpcy5nZXRMaXN0KCk7XG5cdCAgICB2YXIgdmFsdWUgPSAobGlzdC5nZXRWYWx1ZSA/IGxpc3QuZ2V0VmFsdWUoKSA6IGxpc3QuZ2V0U2VsZWN0ZWRJZCgpKSB8fCBcIlwiO1xuXHQgICAgdmFsdWUgPSB2YWx1ZS5pZCB8fCB2YWx1ZTsgLy8gY2hlY2sgZW1wdHlcblxuXHQgICAgaWYgKGxpc3QuZ2V0SXRlbSkge1xuXHQgICAgICB2YXIgaXRlbSA9IGxpc3QuZ2V0SXRlbSh2YWx1ZSk7XG5cdCAgICAgIGlmIChpdGVtICYmIGl0ZW0uJGVtcHR5KSByZXR1cm4gXCJcIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIGxpc3QgPSB0aGlzLmdldExpc3QoKTtcblxuXHQgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgIGlmIChsaXN0LmV4aXN0cyh2YWx1ZSkpIHtcblx0ICAgICAgICBsaXN0LnNlbGVjdCh2YWx1ZSk7XG5cdCAgICAgICAgbGlzdC5zaG93SXRlbSh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxpc3QudW5zZWxlY3QoKTtcblx0ICAgICAgbGlzdC5zaG93SXRlbShsaXN0LmdldEZpcnN0SWQoKSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRTID0gZXhwb3J0cy5wcm90b1VJKGFwaSRTLCBwb3B1cC52aWV3KTtcblx0dmFyIHN1Z2dlc3QgPSB7XG5cdCAgYXBpOiBhcGkkUyxcblx0ICB2aWV3OiB2aWV3JFNcblx0fTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwibXVsdGlzdWdnZXN0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBtdWx0aXN1Z2dlc3QgPGJyPiBZb3UgbmVlZCBXZWJpeCBQUk9cIlxuXHQgIH1cblx0fSwgdGVtcGxhdGUkMS52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwiY2hlY2tzdWdnZXN0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBjaGVja3N1Z2dlc3QgPGJyPiBZb3UgbmVlZCBXZWJpeCBQUk9cIlxuXHQgIH1cblx0fSwgdGVtcGxhdGUkMS52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwiZGF0YXN1Z2dlc3RcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGRhdGFzdWdnZXN0IDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcImdyaWRzdWdnZXN0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBncmlkc3VnZ2VzdCA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJkYXRlcmFuZ2VcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGRhdGVyYW5nZSA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdHZhciBhcGkkVCA9IHtcblx0ICBuYW1lOiBcImRhdGVyYW5nZXN1Z2dlc3RcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdHlwZTogXCJkYXRlcmFuZ2VcIixcblx0ICAgIGJvZHk6IHtcblx0ICAgICAgdmlldzogXCJkYXRlcmFuZ2VcIixcblx0ICAgICAgaWNvbnM6IHRydWUsXG5cdCAgICAgIGJ1dHRvbjogdHJ1ZSxcblx0ICAgICAgYm9yZGVybGVzczogdHJ1ZVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldFJhbmdlKCkuZ2V0VmFsdWUoKTtcblx0ICB9LFxuXHQgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuZ2V0UmFuZ2UoKS5zZXRWYWx1ZShjb3B5KHZhbHVlKSk7XG5cdCAgfSxcblx0ICBnZXRSYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0Qm9keSgpO1xuXHQgIH0sXG5cdCAgZ2V0QnV0dG9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRCb2R5KCkuZ2V0Q2hpbGRWaWV3cygpWzFdLmdldENoaWxkVmlld3MoKVsxXTtcblx0ICB9LFxuXHQgIF9zZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBoaWRlKSB7XG5cdCAgICB2YXIgbWFzdGVyID0gJCQodGhpcy5fc2V0dGluZ3MubWFzdGVyKTtcblxuXHQgICAgaWYgKG1hc3Rlcikge1xuXHQgICAgICBtYXN0ZXIuc2V0VmFsdWUodmFsdWUpO1xuXHQgICAgICBpZiAoaGlkZSkgdGhpcy5oaWRlKCk7XG5cdCAgICB9IGVsc2UgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG5cdCAgfSxcblx0ICBfc2V0X29uX3BvcHVwX2NsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG5cdCAgICByYW5nZS5hdHRhY2hFdmVudChcIm9uQWZ0ZXJEYXRlU2VsZWN0XCIsIGJpbmQoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIHJhbmdlLmF0dGFjaEV2ZW50KFwib25EYXRlQ2xlYXJcIiwgYmluZChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5fc2V0VmFsdWUodmFsdWUpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgcmFuZ2UuYXR0YWNoRXZlbnQoXCJvblRvZGF5U2V0XCIsIGJpbmQoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JFQgPSBleHBvcnRzLnByb3RvVUkoYXBpJFQsIHN1Z2dlc3Qudmlldyk7XG5cblx0dmFyIGFwaSRVID0ge1xuXHQgICRjc3NOYW1lOiBcImRhdGVwaWNrZXJcIixcblx0ICBuYW1lOiBcImRhdGVyYW5nZXBpY2tlclwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICAvL3NldCBub24tZW1wdHkgaW5pdGlhbCB2YWx1ZVxuXHQgICAgdGhpcy5fc2V0dGluZ3MudmFsdWUgPSB7fTsgLy8gb3RoZXIgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZFxuXG5cdCAgICBkZWxldGUgY29uZmlnLnR5cGU7XG5cdCAgfSxcblx0ICBfaW5pdF9wb3B1cDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG9iaiA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgaWYgKG9iai5zdWdnZXN0KSBvYmoucG9wdXAgPSBvYmouc3VnZ2VzdDtlbHNlIGlmICghb2JqLnBvcHVwKSB7XG5cdCAgICAgIG9iai5wb3B1cCA9IG9iai5zdWdnZXN0ID0gdGhpcy5zdWdnZXN0X3NldHRlcih7XG5cdCAgICAgICAgdmlldzogXCJkYXRlcmFuZ2VzdWdnZXN0XCIsXG5cdCAgICAgICAgYm9keToge1xuXHQgICAgICAgICAgdGltZXBpY2tlcjogb2JqLnRpbWVwaWNrZXIsXG5cdCAgICAgICAgICBjYWxlbmRhckNvdW50OiBvYmouY2FsZW5kYXJDb3VudCxcblx0ICAgICAgICAgIGhlaWdodDogMjUwICsgKG9iai5idXR0b24gfHwgb2JqLmljb25zID8gMzAgOiAwKVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2luaXRfb25jZSA9IGZ1bmN0aW9uICgpIHt9O1xuXHQgIH0sXG5cdCAgJHByZXBhcmVWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHZhbHVlIHx8IHt9O1xuXHQgICAgdmFsdWUuc3RhcnQgPSBkYXRlcGlja2VyLmFwaS4kcHJlcGFyZVZhbHVlLmNhbGwodGhpcywgdmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IG51bGwpO1xuXHQgICAgdmFsdWUuZW5kID0gZGF0ZXBpY2tlci5hcGkuJHByZXBhcmVWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlLmVuZCA/IHZhbHVlLmVuZCA6IG51bGwpO1xuXHQgICAgdmFyIGRhdGVyYW5nZSA9ICQkKHRoaXMuX3NldHRpbmdzLnBvcHVwKS5nZXRSYW5nZSgpO1xuXHQgICAgcmV0dXJuIGNvcHkoZGF0ZXJhbmdlLl9jb3JyZWN0X3ZhbHVlKHZhbHVlKSk7XG5cdCAgfSxcblx0ICAkY29tcGFyZVZhbHVlOiBmdW5jdGlvbiAob2xkdmFsdWUsIHZhbHVlKSB7XG5cdCAgICB2YXIgY29tcGFyZSA9IGRhdGVwaWNrZXIuYXBpLiRjb21wYXJlVmFsdWU7XG5cdCAgICB2YXIgc3RhcnQgPSBjb21wYXJlLmNhbGwodGhpcywgb2xkdmFsdWUuc3RhcnQsIHZhbHVlLnN0YXJ0KTtcblx0ICAgIHZhciBlbmQgPSBjb21wYXJlLmNhbGwodGhpcywgb2xkdmFsdWUuZW5kLCB2YWx1ZS5lbmQpO1xuXHQgICAgcmV0dXJuIHN0YXJ0ICYmIGVuZDtcblx0ICB9LFxuXHQgICRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YWx1ZSA9IHZhbHVlIHx8IHt9O1xuXHQgICAgdGhpcy5fc2V0dGluZ3MudGV4dCA9ICh2YWx1ZS5zdGFydCA/IHRoaXMuX2dldF92aXNpYmxlX3RleHQodmFsdWUuc3RhcnQpIDogXCJcIikgKyAodmFsdWUuZW5kID8gXCIgLSBcIiArIHRoaXMuX2dldF92aXNpYmxlX3RleHQodmFsdWUuZW5kKSA6IFwiXCIpO1xuXG5cdCAgICB0aGlzLl9zZXRfdmlzaWJsZV90ZXh0KCk7XG5cdCAgfSxcblx0ICAkcmVuZGVyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBvYmoudmFsdWUgPSB0aGlzLiRwcmVwYXJlVmFsdWUob2JqLnZhbHVlKTtcblx0ICAgIHRoaXMuJHNldFZhbHVlKG9iai52YWx1ZSk7XG5cdCAgfSxcblx0ICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5fc2V0dGluZ3MudmFsdWU7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zdHJpbmdSZXN1bHQpIHtcblx0ICAgICAgdmFyIGZvcm1hdFN0ciA9IGkxOG4ucGFyc2VGb3JtYXRTdHI7XG5cdCAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRWYWx1ZShmb3JtYXRTdHIsIHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlIHx8IG51bGw7XG5cdCAgfSxcblx0ICBfZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIChmb3JtYXQsIHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUuc3RhcnQpIHZhbHVlLnN0YXJ0ID0gZm9ybWF0KHZhbHVlLnN0YXJ0KTtcblx0ICAgIGlmICh2YWx1ZS5lbmQpIHZhbHVlLmVuZCA9IGZvcm1hdCh2YWx1ZS5lbmQpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckVSA9IGV4cG9ydHMucHJvdG9VSShhcGkkVSwgZGF0ZXBpY2tlci52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwiZXhjZWxiYXJcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGV4Y2VsYmFyIDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcImV4Y2Vsdmlld2VyXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBleGNlbHZpZXdlciA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJwZGZiYXJcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IHBkZmJhciA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJwZGZ2aWV3ZXJcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IHBkZnZpZXdlciA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdC8qXG5cdFx0VUk6VmlkZW9cblx0Ki9cblx0Ly8gI2luY2x1ZGUgdWkvdmlldy5qc1xuXG5cdHZhciBhcGkkViA9IHtcblx0ICBuYW1lOiBcInZpZGVvXCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmICghY29uZmlnLmlkKSBjb25maWcuaWQgPSB1aWQoKTtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5faW5pdF92aWRlbyk7XG5cdCAgfSxcblx0ICBfaW5pdF92aWRlbzogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGMgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHRoaXMuX2NvbnRlbnRvYmogPSBjcmVhdGUoXCJ2aWRlb1wiLCB7XG5cdCAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF92aWV3X3ZpZGVvXCIsXG5cdCAgICAgIFwic3R5bGVcIjogXCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO1wiLFxuXHQgICAgICBcImF1dG9idWZmZXJcIjogXCJhdXRvYnVmZmVyXCJcblx0ICAgIH0sIFwiXCIpO1xuXHQgICAgaWYgKGMucG9zdGVyKSB0aGlzLl9jb250ZW50b2JqLnBvc3RlciA9IGMucG9zdGVyO1xuXG5cdCAgICBpZiAoYy5zcmMpIHtcblx0ICAgICAgaWYgKF90eXBlb2YoYy5zcmMpICE9IFwib2JqZWN0XCIpIGMuc3JjID0gW2Muc3JjXTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMuc3JjLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgKz0gXCIgPHNvdXJjZSBzcmM9XFxcIlwiICsgYy5zcmNbaV0gKyBcIlxcXCI+XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGMuY29udHJvbHMpIHRoaXMuX2NvbnRlbnRvYmouY29udHJvbHMgPSB0cnVlO1xuXHQgICAgaWYgKGMuYXV0b3BsYXkpIHRoaXMuX2NvbnRlbnRvYmouYXV0b3BsYXkgPSB0cnVlO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnRvYmopO1xuXHQgIH0sXG5cdCAgZ2V0VmlkZW86IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9jb250ZW50b2JqO1xuXHQgIH0sXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHNyYzogXCJcIixcblx0ICAgIGNvbnRyb2xzOiB0cnVlXG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRWID0gZXhwb3J0cy5wcm90b1VJKGFwaSRWLCBiYXNlLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJnYWdlXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCBnYWdlIDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0ZXhwb3J0cy5wcm90b1VJKHtcblx0ICBuYW1lOiBcImJhcmNvZGVcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGJhcmNvZGUgPGJyPiBZb3UgbmVlZCBXZWJpeCBQUk9cIlxuXHQgIH1cblx0fSwgdGVtcGxhdGUkMS52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwiYnVsbGV0Z3JhcGhcIixcblx0ICBkZWZhdWx0czoge1xuXHQgICAgdGVtcGxhdGU6IFwiR1BMIHZlcnNpb24gZG9lc24ndCBzdXBwb3J0IGJ1bGxldGdyYXBoIDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0dmFyIGdvb2dsZSwgc2NyaXB0O1xuXHR2YXIgYXBpJFcgPSB7XG5cdCAgbmFtZTogXCJnZW9jaGFydFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBjaGFydDoge1xuXHQgICAgICBkaXNwbGF5TW9kZTogXCJhdXRvXCIsXG5cdCAgICAgIHJlZ2lvbjogXCJ3b3JsZFwiLFxuXHQgICAgICByZXNvbHV0aW9uOiBcImNvdW50cmllc1wiXG5cdCAgICB9XG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy4kdmlldy5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X21hcF9jb250ZW50JyBzdHlsZT0nd2lkdGg6MTAwJTtoZWlnaHQ6MTAwJSc+PC9kaXY+XCI7XG5cdCAgICB0aGlzLl9jb250ZW50b2JqID0gdGhpcy4kdmlldy5maXJzdENoaWxkO1xuXHQgICAgdGhpcy5fd2FpdE1hcCA9IERlZmVycmVkLmRlZmVyKCk7XG5cdCAgICBjb25maWcuY2hhcnQgPSBleHBvcnRzLmV4dGVuZChjb25maWcuY2hhcnQgfHwge30sIHRoaXMuZGVmYXVsdHMuY2hhcnQpO1xuXHQgICAgdGhpcy5kYXRhLnByb3ZpZGVBcGkodGhpcywgdHJ1ZSk7XG5cdCAgICB0aGlzLiRyZWFkeS5wdXNoKHRoaXMucmVuZGVyKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uQ2xlYXJBbGxcIiwgYmluZCh0aGlzLl9yZWZyZXNoQ29sdW1ucywgdGhpcykpO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgYmluZCh0aGlzLl9kcmF3RGF0YSwgdGhpcykpO1xuXHQgIH0sXG5cdCAgZ2V0TWFwOiBmdW5jdGlvbiAod2FpdE1hcCkge1xuXHQgICAgcmV0dXJuIHdhaXRNYXAgPyB0aGlzLl93YWl0TWFwIDogdGhpcy5fbWFwO1xuXHQgIH0sXG5cdCAgX2dldENhbGxCYWNrOiBmdW5jdGlvbiAocHJldikge1xuXHQgICAgcmV0dXJuIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAodHlwZW9mIHByZXYgPT09IFwiZnVuY3Rpb25cIikgcHJldigpO1xuXHQgICAgICBnb29nbGUgPSBnb29nbGUgfHwgd2luZG93Lmdvb2dsZTtcblxuXHQgICAgICB0aGlzLl9pbml0TWFwKCk7XG5cdCAgICB9LCB0aGlzKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cuZ29vZ2xlID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5nb29nbGUuY2hhcnRzID09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgaWYgKCFzY3JpcHQpIHtcblx0ICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXHQgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0ICAgICAgICBzY3JpcHQuc3JjID0gXCIvL3d3dy5nc3RhdGljLmNvbS9jaGFydHMvbG9hZGVyLmpzXCI7XG5cdCAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBzY3JpcHQub25sb2FkID0gdGhpcy5fZ2V0Q2FsbEJhY2soc2NyaXB0Lm9ubG9hZCk7XG5cdCAgICB9IGVsc2UgLy90aGVyZSdzIGEgY3VzdG9tIGxpbmsgdG8gZ29vZ2xlIGFwaSBpbiBkb2N1bWVudCBoZWFkXG5cdCAgICAgIHRoaXMuX2dldENhbGxCYWNrKCkoKTtcblx0ICB9LFxuXHQgIF9pbml0TWFwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIWdvb2dsZS52aXN1YWxpemF0aW9uIHx8ICFnb29nbGUudmlzdWFsaXphdGlvbi5HZW9DaGFydCkge1xuXHQgICAgICBnb29nbGUuY2hhcnRzLmxvYWQoXCJjdXJyZW50XCIsIHtcblx0ICAgICAgICBcInBhY2thZ2VzXCI6IFtcImdlb2NoYXJ0XCJdLFxuXHQgICAgICAgIFwibWFwc0FwaUtleVwiOiB0aGlzLl9zZXR0aW5ncy5rZXlcblx0ICAgICAgfSk7XG5cdCAgICAgIGdvb2dsZS5jaGFydHMuc2V0T25Mb2FkQ2FsbGJhY2soYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5faW5pdE1hcCgpO1xuXHQgICAgICB9LCB0aGlzKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9tYXAgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uR2VvQ2hhcnQodGhpcy5fY29udGVudG9iaik7XG5cblx0ICAgICAgdGhpcy5fbWFwRXZlbnRzKCk7XG5cblx0ICAgICAgdGhpcy5fd2FpdE1hcC5yZXNvbHZlKHRoaXMuX21hcCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkb25Mb2FkOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICBpZiAoIXRoaXMuX21hcCkge1xuXHQgICAgICB0aGlzLl93YWl0TWFwLnRoZW4oYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5wYXJzZShvYmosIHRoaXMuX3NldHRpbmdzLmRhdGF0eXBlKTtcblx0ICAgICAgfSwgdGhpcykpO1xuXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBfZHJhd0RhdGE6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICghdGhpcy5fbWFwKSB7XG5cdCAgICAgIGlmICghdGhpcy5fbWFwKSB0aGlzLl93YWl0TWFwLnRoZW4oYmluZCh0aGlzLl9kcmF3RGF0YSwgdGhpcykpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBjb2x1bW5zID0gdGhpcy5fY29sdW1ucyAmJiB0aGlzLl9jb2x1bW5zLmxlbmd0aCA/IHRoaXMuX2NvbHVtbnMgOiB0aGlzLl9kZWZpbmVDb2x1bW5zKCk7XG5cdCAgICB2YXIgZGF0YSA9IFtdO1xuXHQgICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICB2YXIgbGluZSA9IFtdO1xuXG5cdCAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sdW1ucy5sZW5ndGg7IGMrKykge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG9ialtjb2x1bW5zW2NdLmxhYmVsXTtcblx0ICAgICAgICBpZiAoY29sdW1uc1tjXS50eXBlID09IFwibnVtYmVyXCIpIHZhbHVlID0gdmFsdWUgKiAxO2Vsc2UgaWYgKGNvbHVtbnNbY10ucm9sZSA9PSBcInRvb2x0aXBcIikgdmFsdWUgPSB0aGlzLl9zZXR0aW5ncy50b29sdGlwKG9iaik7XG5cdCAgICAgICAgbGluZS5wdXNoKHZhbHVlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGRhdGEucHVzaChsaW5lKTtcblx0ICAgIH0sIHRoaXMpO1xuXG5cdCAgICBpZiAoY29sdW1ucy5sZW5ndGgpIHtcblx0ICAgICAgdmFyIHRhYmxlID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZSgpO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRhYmxlLmFkZENvbHVtbihjb2x1bW5zW2ldKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRhYmxlLmFkZFJvd3MoZGF0YSk7XG5cdCAgICAgIHZhciB2aWV3ID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFWaWV3KHRhYmxlKTtcblxuXHQgICAgICB0aGlzLl9tYXAuZHJhdyh2aWV3LCB0aGlzLl9zZXR0aW5ncy5jaGFydCk7XG5cdCAgICB9IGVsc2UgLy9kcmF3IGNsZWFuIGNoYXJ0XG5cdCAgICAgIHRoaXMuX21hcC5kcmF3KGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoW1tcIlwiLCBcIlwiXV0pLCB7fSk7XG5cdCAgfSxcblx0ICBzZXREaXNwbGF5TW9kZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy5jaGFydC5kaXNwbGF5TW9kZSA9IHZhbHVlO1xuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgfSxcblx0ICBzZXRSZWdpb246IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuY2hhcnQucmVnaW9uID0gdmFsdWU7XG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX21hcC5jbGVhckNoYXJ0KCk7XG5cblx0ICAgIHRoaXMuX2RyYXdEYXRhKCk7XG5cdCAgfSxcblx0ICB0b29sdGlwX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgdG9vbHRpcCA9IHRoaXMuX3NldHRpbmdzLmNoYXJ0LnRvb2x0aXA7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy5jaGFydC50b29sdGlwID0gZXhwb3J0cy5leHRlbmQodG9vbHRpcCB8fCB7fSwge1xuXHQgICAgICBpc0h0bWw6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHRlbXBsYXRlKHZhbHVlKTtcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAodywgaCkge1xuXHQgICAgaWYgKGJhc2UuYXBpLiRzZXRTaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgdGhpcy5fbWFwKSB7XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMuX3NldHRpbmdzLCB7XG5cdCAgICAgICAgd2lkdGg6IHcsXG5cdCAgICAgICAgaGVpZ2h0OiBoXG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLnJlZnJlc2goKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9yZWZyZXNoQ29sdW1uczogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fY29sdW1ucyA9IG51bGw7XG5cblx0ICAgIHRoaXMuX2RyYXdEYXRhKCk7XG5cdCAgfSxcblx0ICBfZ2V0Q29sdW1uVHlwZTogZnVuY3Rpb24gKGl0ZW0sIGtleSkge1xuXHQgICAgaWYgKCFpdGVtIHx8IGlzVW5kZWZpbmVkKGl0ZW1ba2V5XSkpIHJldHVybiBcInN0cmluZ1wiO1xuXG5cdCAgICB2YXIgdHlwZSA9IF90eXBlb2YoaXRlbVtrZXldKTtcblxuXHQgICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIiAmJiAhaXNOYU4oaXRlbVtrZXldICogMSkpIHR5cGUgPSBcIm51bWJlclwiO1xuXHQgICAgcmV0dXJuIHR5cGU7XG5cdCAgfSxcblx0ICBfZGVmaW5lQ29sdW1uczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNvbHVtbnMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zIHx8IFtdO1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGEucHVsbFt0aGlzLmRhdGEub3JkZXJbMF1dOyAvL2F1dG8gY29sdW1uc1xuXG5cdCAgICBpZiAoIWNvbHVtbnMubGVuZ3RoICYmIGl0ZW0pIHtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW0pIHtcblx0ICAgICAgICBpZiAoa2V5ICE9PSBcImlkXCIpIGNvbHVtbnMucHVzaChrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vW1widGl0bGVcIiwgXCJhcmVhXCJdXG5cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChfdHlwZW9mKGNvbHVtbnNbaV0pICE9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgY29sdW1uc1tpXSA9IHtcblx0ICAgICAgICAgIHR5cGU6IHRoaXMuX2dldENvbHVtblR5cGUoaXRlbSwgY29sdW1uc1tpXSksXG5cdCAgICAgICAgICBsYWJlbDogY29sdW1uc1tpXVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRvb2x0aXApIGNvbHVtbnMucHVzaCh7XG5cdCAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG5cdCAgICAgIHJvbGU6IFwidG9vbHRpcFwiLFxuXHQgICAgICBwOiB7XG5cdCAgICAgICAgXCJodG1sXCI6IHRydWVcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcblx0ICAgIHJldHVybiBjb2x1bW5zO1xuXHQgIH0sXG5cdCAgX21hcEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHQgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKHRoaXMuX21hcCwgXCJlcnJvclwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbk1hcEVycm9yXCIsIGFyZ3VtZW50cyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMuYWRkTGlzdGVuZXIodGhpcy5fbWFwLCBcInJlYWR5XCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uTWFwUmVhZHlcIiwgYXJndW1lbnRzKTtcblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcih0aGlzLl9tYXAsIFwicmVnaW9uQ2xpY2tcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25SZWdpb25DbGlja1wiLCBhcmd1bWVudHMpO1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZXZlbnRzLmFkZExpc3RlbmVyKHRoaXMuX21hcCwgXCJzZWxlY3RcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBzZWxub3cgPSB0aGlzLl9tYXAuZ2V0U2VsZWN0aW9uKClbMF07XG5cblx0ICAgICAgdmFyIHNlbCA9IHNlbG5vdyB8fCB0aGlzLl9zZWxwcmV2O1xuXG5cdCAgICAgIGlmIChzZWwpIHtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLmRhdGEub3JkZXJbc2VsLnJvd107XG5cdCAgICAgICAgdGhpcy5fc2VscHJldiA9IHNlbDtcblx0ICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uSXRlbUNsaWNrXCIsIFtpZCwgISFzZWxub3ddKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcykpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckVyA9IGV4cG9ydHMucHJvdG9VSShhcGkkVywgRGF0YUxvYWRlciwgRXZlbnRTeXN0ZW0sIGJhc2Uudmlldyk7XG5cblx0dmFyIGdvb2dsZSQxLCBzY3JpcHQkMTtcblx0dmFyIGFwaSRYID0ge1xuXHQgIG5hbWU6IFwiZ29vZ2xlLW1hcFwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLiR2aWV3LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfbWFwX2NvbnRlbnQnIHN0eWxlPSd3aWR0aDoxMDAlO2hlaWdodDoxMDAlJz48L2Rpdj5cIjtcblx0ICAgIHRoaXMuX2NvbnRlbnRvYmogPSB0aGlzLiR2aWV3LmZpcnN0Q2hpbGQ7XG5cdCAgICB0aGlzLl93YWl0TWFwID0gRGVmZXJyZWQuZGVmZXIoKTtcblx0ICAgIHRoaXMuZGF0YS5wcm92aWRlQXBpKHRoaXMsIHRydWUpO1xuXHQgICAgdGhpcy4kcmVhZHkucHVzaCh0aGlzLnJlbmRlcik7XG5cdCAgfSxcblx0ICBnZXRNYXA6IGZ1bmN0aW9uICh3YWl0TWFwKSB7XG5cdCAgICByZXR1cm4gd2FpdE1hcCA/IHRoaXMuX3dhaXRNYXAgOiB0aGlzLl9tYXA7XG5cdCAgfSxcblx0ICBfZ2V0Q2FsbEJhY2s6IGZ1bmN0aW9uIChwcmV2KSB7XG5cdCAgICByZXR1cm4gYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSBwcmV2KCk7XG5cdCAgICAgIGdvb2dsZSQxID0gZ29vZ2xlJDEgfHwgd2luZG93Lmdvb2dsZTtcblxuXHQgICAgICB0aGlzLl9pbml0TWFwLmNhbGwodGhpcyk7XG5cdCAgICB9LCB0aGlzKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cuZ29vZ2xlID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHdpbmRvdy5nb29nbGUubWFwcyA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIGlmICghc2NyaXB0JDEpIHtcblx0ICAgICAgICBzY3JpcHQkMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cdCAgICAgICAgc2NyaXB0JDEudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdCAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgICAgIHZhciBzcmMgPSBjb25maWcuc3JjIHx8IFwiLy9tYXBzLmdvb2dsZS5jb20vbWFwcy9hcGkvanNcIjtcblx0ICAgICAgICBzcmMgKz0gc3JjLmluZGV4T2YoXCI/XCIpID09PSAtMSA/IFwiP1wiIDogXCImXCI7XG5cdCAgICAgICAgaWYgKGNvbmZpZy5rZXkpIHNyYyArPSBcIiZrZXk9XCIgKyBjb25maWcua2V5O1xuXHQgICAgICAgIGlmIChjb25maWcubGlicmFyaWVzKSBzcmMgKz0gXCImbGlicmFyaWVzPVwiICsgY29uZmlnLmxpYnJhcmllcztcblx0ICAgICAgICBzY3JpcHQkMS5zcmMgPSBzcmM7XG5cdCAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCQxKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHNjcmlwdCQxLm9ubG9hZCA9IHRoaXMuX2dldENhbGxCYWNrKHNjcmlwdCQxLm9ubG9hZCk7XG5cdCAgICB9IGVsc2UgLy90aGVyZSdzIGEgY3VzdG9tIGxpbmsgdG8gZ29vZ2xlIGFwaSBpbiBkb2N1bWVudCBoZWFkXG5cdCAgICAgIHRoaXMuX2dldENhbGxCYWNrKCkoKTtcblx0ICB9LFxuXHQgIF9pbml0TWFwOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYyA9IHRoaXMuY29uZmlnO1xuXG5cdCAgICBpZiAodGhpcy5pc1Zpc2libGUoYy5pZCkpIHtcblx0ICAgICAgdGhpcy5fbWFwID0gbmV3IGdvb2dsZSQxLm1hcHMuTWFwKHRoaXMuX2NvbnRlbnRvYmosIHtcblx0ICAgICAgICB6b29tOiBjLnpvb20sXG5cdCAgICAgICAgY2VudGVyOiBuZXcgZ29vZ2xlJDEubWFwcy5MYXRMbmcoYy5jZW50ZXJbMF0sIGMuY2VudGVyWzFdKSxcblx0ICAgICAgICBtYXBUeXBlSWQ6IGdvb2dsZSQxLm1hcHMuTWFwVHlwZUlkW2MubWFwVHlwZV1cblx0ICAgICAgfSk7XG5cblx0ICAgICAgdGhpcy5fd2FpdE1hcC5yZXNvbHZlKHRoaXMuX21hcCk7XG5cblx0ICAgICAgdGhpcy5fY29udGVudG9iai5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcIndlYml4X2Rpc2FibGVfZHJhZ1wiLCBcInRydWVcIik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBjZW50ZXJfc2V0dGVyOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBpZiAodGhpcy5fbWFwKSB0aGlzLl9tYXAuc2V0Q2VudGVyKG5ldyBnb29nbGUkMS5tYXBzLkxhdExuZyhjb25maWdbMF0sIGNvbmZpZ1sxXSkpO1xuXHQgICAgcmV0dXJuIGNvbmZpZztcblx0ICB9LFxuXHQgIG1hcFR5cGVfc2V0dGVyOiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICAvKlJPQURNQVAsU0FURUxMSVRFLEhZQlJJRCxURVJSQUlOKi9cblx0ICAgIGlmICh0aGlzLl9tYXApIHRoaXMuX21hcC5zZXRNYXBUeXBlSWQoZ29vZ2xlJDEubWFwcy5NYXBUeXBlSWRbY29uZmlnXSk7XG5cdCAgICByZXR1cm4gY29uZmlnO1xuXHQgIH0sXG5cdCAgem9vbV9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmICh0aGlzLl9tYXApIHRoaXMuX21hcC5zZXRab29tKGNvbmZpZyk7XG5cdCAgICByZXR1cm4gY29uZmlnO1xuXHQgIH0sXG5cdCAgbGF5ZXJUeXBlX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgaWYgKGNvbmZpZyA9PSBcImhlYXRtYXBcIikgdGhpcy5jb25maWcubGlicmFyaWVzID0gXCJ2aXN1YWxpemF0aW9uXCI7XG5cblx0ICAgIGlmICh0aGlzLl9sYXllckFwaVtjb25maWddKSB7XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIHRoaXMuX2xheWVyQXBpW2NvbmZpZ10sIHRydWUpO1xuXHQgICAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl93YWl0TWFwLnRoZW4oYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB0aGlzLmRyYXdEYXRhLmNhbGwodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9LCB0aGlzKSk7XG5cdCAgICAgIH0sIHRoaXMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNvbmZpZztcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB6b29tOiA1LFxuXHQgICAgY2VudGVyOiBbMzkuNSwgLTk4LjVdLFxuXHQgICAgbWFwVHlwZTogXCJST0FETUFQXCIsXG5cdCAgICBsYXllclR5cGU6IFwibWFya2VyXCJcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBiYXNlLmFwaS4kc2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgaWYgKHRoaXMuX21hcCkgZ29vZ2xlJDEubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMuX21hcCwgXCJyZXNpemVcIik7XG5cdCAgfSxcblx0ICAkb25Mb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgaWYgKCF0aGlzLl9tYXApIHtcblx0ICAgICAgdGhpcy5fd2FpdE1hcC50aGVuKGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucGFyc2UoZGF0YSk7XG5cdCAgICAgIH0sIHRoaXMpKTtcblxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgX2xheWVyQXBpOiB7XG5cdCAgICBtYXJrZXI6IHtcblx0ICAgICAgZHJhd0RhdGE6IGZ1bmN0aW9uIChpZCwgaXRlbSwgb3BlcmF0aW9uKSB7XG5cdCAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcblx0ICAgICAgICAgIGNhc2UgXCJhZGRcIjpcblx0ICAgICAgICAgICAgaXRlbS4kbWFya2VyID0gdGhpcy5fZ2V0SXRlbUNvbmZpZyhpdGVtKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcblx0ICAgICAgICAgICAgaXRlbS4kbWFya2VyID0gdGhpcy5fZ2V0SXRlbUNvbmZpZyhpdGVtKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcblx0ICAgICAgICAgICAgaXRlbS4kbWFya2VyLnNldE1hcChudWxsKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgICAgICAgaXRlbS4kbWFya2VyID0gdGhpcy5fZ2V0SXRlbUNvbmZpZyhpdGVtKTtcblx0ICAgICAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgY2xlYXJBbGw6IGZ1bmN0aW9uIChzb2Z0KSB7XG5cdCAgICAgICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgb2JqLiRtYXJrZXIuc2V0TWFwKG51bGwpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuZGF0YS5jbGVhckFsbChzb2Z0KTtcblx0ICAgICAgfSxcblx0ICAgICAgc2hvd0l0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcblxuXHQgICAgICAgIHRoaXMuX21hcC5zZXRDZW50ZXIobmV3IGdvb2dsZSQxLm1hcHMuTGF0TG5nKGl0ZW0ubGF0LCBpdGVtLmxuZykpO1xuXHQgICAgICB9LFxuXHQgICAgICBfZ2V0SXRlbUNvbmZpZzogZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICB2YXIgb2JqID0ge307XG5cblx0ICAgICAgICBmb3IgKHZhciBpIGluIGl0ZW0pIHtcblx0ICAgICAgICAgIG9ialtpXSA9IGl0ZW1baV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb2JqLnBvc2l0aW9uID0gbmV3IGdvb2dsZSQxLm1hcHMuTGF0TG5nKGl0ZW0ubGF0LCBpdGVtLmxuZyk7XG5cdCAgICAgICAgb2JqLm1hcCA9IGl0ZW0uaGlkZGVuID8gbnVsbCA6IHRoaXMuX21hcDtcblx0ICAgICAgICB2YXIgbWFya2VyID0gaXRlbS4kbWFya2VyO1xuXG5cdCAgICAgICAgaWYgKCFtYXJrZXIpIHtcblx0ICAgICAgICAgIG1hcmtlciA9IG5ldyBnb29nbGUkMS5tYXBzLk1hcmtlcihvYmopO1xuXG5cdCAgICAgICAgICB0aGlzLl9ldmVudHMobWFya2VyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaXRlbS4kbWFya2VyLnNldE1hcChvYmoubWFwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uSXRlbVJlbmRlclwiLCBbaXRlbV0pO1xuXHQgICAgICAgIHJldHVybiBtYXJrZXI7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9ldmVudHM6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0ICAgICAgICB2YXIgbWFwID0gdGhpcztcblx0ICAgICAgICBtYXJrZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBtYXAuY2FsbEV2ZW50KFwib25JdGVtQ2xpY2tcIiwgW3RoaXMuaWQsIHRoaXNdKTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIGlmIChtYXJrZXIuZ2V0RHJhZ2dhYmxlKCkpIHtcblx0ICAgICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcihcImRyYWdlbmRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBtYXAuX29uRHJhZyh0aGlzLCB0cnVlKTtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgbWFya2VyLmFkZExpc3RlbmVyKFwiZHJhZ1wiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIG1hcC5fb25EcmFnKHRoaXMpO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBfb25EcmFnOiBmdW5jdGlvbiAobWFya2VyLCBlbmQpIHtcblx0ICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShtYXJrZXIuaWQpO1xuXHQgICAgICAgIHZhciBwb3MgPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcblx0ICAgICAgICB2YXIgZXYgPSBlbmQgPyBcIm9uQWZ0ZXJEcm9wXCIgOiBcIm9uRHJhZ1wiO1xuXHQgICAgICAgIGl0ZW0ubGF0ID0gcG9zLmxhdCgpO1xuXHQgICAgICAgIGl0ZW0ubG5nID0gcG9zLmxuZygpO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KGV2LCBbaXRlbS5pZCwgaXRlbV0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaGVhdG1hcDoge1xuXHQgICAgICBoZWF0bWFwQ29uZmlnX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB7fTtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH0sXG5cdCAgICAgIGRyYXdEYXRhOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hlYXRtYXApIHtcblx0ICAgICAgICAgIHRoaXMuX2hlYXRtYXAuc2V0TWFwKG51bGwpO1xuXG5cdCAgICAgICAgICB0aGlzLl9oZWF0bWFwID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgaGRhdGEgPSBbXTtcblx0ICAgICAgICB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgaGRhdGEucHVzaCh0aGlzLl9nZXRDb25maWcoaXRlbSkpO1xuXHQgICAgICAgIH0sIHRoaXMpO1xuXG5cdCAgICAgICAgaWYgKGhkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSBleHBvcnRzLmV4dGVuZCh0aGlzLmNvbmZpZy5oZWF0bWFwQ29uZmlnLCB7XG5cdCAgICAgICAgICAgIGRhdGE6IGhkYXRhLFxuXHQgICAgICAgICAgICBtYXA6IHRoaXMuX21hcFxuXHQgICAgICAgICAgfSwgdHJ1ZSk7XG5cdCAgICAgICAgICB0aGlzLl9oZWF0bWFwID0gbmV3IGdvb2dsZSQxLm1hcHMudmlzdWFsaXphdGlvbi5IZWF0bWFwTGF5ZXIoZGF0YSk7XG5cdCAgICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uSGVhdE1hcFJlbmRlclwiLCBbdGhpcy5faGVhdG1hcF0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgZ2V0SGVhdG1hcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9oZWF0bWFwO1xuXHQgICAgICB9LFxuXHQgICAgICBfZ2V0Q29uZmlnOiBmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHZhciBvYmogPSB7fTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgaW4gaXRlbSkge1xuXHQgICAgICAgICAgb2JqW2ldID0gaXRlbVtpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvYmoubG9jYXRpb24gPSBuZXcgZ29vZ2xlJDEubWFwcy5MYXRMbmcoaXRlbS5sYXQsIGl0ZW0ubG5nKTtcblx0ICAgICAgICByZXR1cm4gb2JqO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyRYID0gZXhwb3J0cy5wcm90b1VJKGFwaSRYLCBEYXRhTG9hZGVyLCBFdmVudFN5c3RlbSwgYmFzZS52aWV3KTtcblxuXHRleHBvcnRzLnByb3RvVUkoe1xuXHQgIG5hbWU6IFwib3JnYW5vZ3JhbVwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB0ZW1wbGF0ZTogXCJHUEwgdmVyc2lvbiBkb2Vzbid0IHN1cHBvcnQgb3JnYW5vZ3JhbSA8YnI+IFlvdSBuZWVkIFdlYml4IFBST1wiXG5cdCAgfVxuXHR9LCB0ZW1wbGF0ZSQxLnZpZXcpO1xuXG5cdHZhciBQaWUkMSA9IHtcblx0ICAkcmVuZGVyX3BpZTogZnVuY3Rpb24gKGN0eCwgZGF0YSwgeCwgeSwgc0luZGV4LCBtYXApIHtcblx0ICAgIHRoaXMuX3JlbmRlclBpZShjdHgsIGRhdGEsIHgsIHksIDEsIG1hcCwgc0luZGV4KTtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogICByZW5kZXJzIGEgcGllIGNoYXJ0XG5cdCAgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAgKiAgIEBwYXJhbTogZGF0YSAtIG9iamVjdCB0aG9zZSBuZWVkIHRvIGJlIGRpc3BsYXllZFxuXHQgICAqICAgQHBhcmFtOiB4IC0gdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcblx0ICAgKiAgIEBwYXJhbTogeSAtIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuXHQgICAqICAgQHBhcmFtOiBreSAtIHZhbHVlIGZyb20gMCB0byAxIHRoYXQgZGVmaW5lcyBhbiBhbmdsZSBvZiBpbmNsaW5hdGlvbiAoMDxreTwxIC0gM0QgY2hhcnQpXG5cdCAgICovXG5cdCAgX3JlbmRlclBpZTogZnVuY3Rpb24gKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIGt5LCBtYXAsIHNJbmRleCkge1xuXHQgICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuXG5cdCAgICB2YXIgY29vcmQgPSB0aGlzLl9nZXRQaWVQYXJhbWV0ZXJzKHBvaW50MCwgcG9pbnQxKTtcblx0ICAgIC8qcGllIHJhZGl1cyovXG5cblxuXHQgICAgdmFyIHJhZGl1cyA9IHRoaXMuX3NldHRpbmdzLnJhZGl1cyA/IHRoaXMuX3NldHRpbmdzLnJhZGl1cyA6IGNvb3JkLnJhZGl1cztcblx0ICAgIGlmIChyYWRpdXMgPCAwKSByZXR1cm47XG5cdCAgICAvKnJlYWwgdmFsdWVzKi9cblxuXHQgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldFZhbHVlcyhkYXRhKTtcblxuXHQgICAgdmFyIHRvdGFsVmFsdWUgPSB0aGlzLl9nZXRUb3RhbFZhbHVlKHZhbHVlcyk7XG5cdCAgICAvKndlaWdoZWQgdmFsdWVzICh0aGUgcmF0aW8gb2Ygb2JqZWN0IHZhbHVlIHRvIHRvdGFsIHZhbHVlKSovXG5cblxuXHQgICAgdmFyIHJhdGlvcyA9IHRoaXMuX2dldFJhdGlvcyh2YWx1ZXMsIHRvdGFsVmFsdWUpO1xuXHQgICAgLypwaWUgY2VudGVyKi9cblxuXG5cdCAgICB2YXIgeDAgPSB0aGlzLl9zZXR0aW5ncy54ID8gdGhpcy5fc2V0dGluZ3MueCA6IGNvb3JkLng7XG5cdCAgICB2YXIgeTAgPSB0aGlzLl9zZXR0aW5ncy55ID8gdGhpcy5fc2V0dGluZ3MueSA6IGNvb3JkLnk7XG5cdCAgICAvKmFkZHMgc2hhZG93IHRvIHRoZSAyRCBwaWUqL1xuXG5cdCAgICBpZiAoa3kgPT0gMSAmJiB0aGlzLl9zZXR0aW5ncy5zaGFkb3cpIHRoaXMuX2FkZFNoYWRvdyhjdHgsIHgwLCB5MCwgcmFkaXVzKTtcblx0ICAgIC8qY2hhbmdlcyB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIGFjY29yZGluZyB0byAzRHBpZSBjYW50Ki9cblxuXHQgICAgeTAgPSB5MCAvIGt5O1xuXHQgICAgLyp0aGUgYW5nbGUgZGVmaW5lcyB0aGUgMXN0IGVkZ2Ugb2YgdGhlIHNlY3RvciovXG5cblx0ICAgIHZhciBhbHBoYTAgPSAtTWF0aC5QSSAvIDI7XG5cdCAgICB2YXIgYW5nbGVzID0gW107XG5cdCAgICAvKmNoYW5nZXMgQ2FudmFzIHZlcnRpY2FsIHNjYWxlKi9cblxuXHQgICAgY3R4LnNjYWxlKDEsIGt5KTtcblx0ICAgIC8qYWRkcyByYWRpYWwgZ3JhZGllbnQgdG8gYSBwaWUqL1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZ3JhZGllbnQpIHtcblx0ICAgICAgdmFyIHgxID0ga3kgIT0gMSA/IHgwICsgcmFkaXVzIC8gMyA6IHgwO1xuXHQgICAgICB2YXIgeTEgPSBreSAhPSAxID8geTAgKyByYWRpdXMgLyAzIDogeTA7XG5cblx0ICAgICAgdGhpcy5fc2hvd1JhZGlhbEdyYWRpZW50KGN0eCwgeDAsIHkwLCByYWRpdXMsIHgxLCB5MSk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoIXZhbHVlc1tpXSkgY29udGludWU7XG5cdCAgICAgIC8qZHJhd2luZyBzZWN0b3IqL1xuXHQgICAgICAvL2N0eC5saW5lV2lkdGggPSAyO1xuXG5cdCAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX3NldHRpbmdzLmxpbmVDb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXHQgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcblx0ICAgICAgYW5nbGVzLnB1c2goYWxwaGEwKTtcblx0ICAgICAgLyp0aGUgYW5nbGUgZGVmaW5lcyB0aGUgMm5kIGVkZ2Ugb2YgdGhlIHNlY3RvciovXG5cblx0ICAgICAgdmFyIGFscGhhMSA9IC1NYXRoLlBJIC8gMiArIHJhdGlvc1tpXSAtIDAuMDAwMTtcblx0ICAgICAgY3R4LmFyYyh4MCwgeTAsIHJhZGl1cywgYWxwaGEwLCBhbHBoYTEsIGZhbHNlKTtcblx0ICAgICAgY3R4LmxpbmVUbyh4MCwgeTApO1xuXG5cdCAgICAgIHZhciBjb2xvciA9IHRoaXMuX3NldHRpbmdzLmNvbG9yLmNhbGwodGhpcywgZGF0YVtpXSk7XG5cblx0ICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHQgICAgICBjdHguZmlsbCgpO1xuXHQgICAgICAvKnRleHQgdGhhdCBuZWVkcyBiZWluZyBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBzZWN0b3IqL1xuXG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5waWVJbm5lclRleHQpIHRoaXMuX2RyYXdTZWN0b3JMYWJlbCh4MCwgeTAsIDUgKiByYWRpdXMgLyA2LCBhbHBoYTAsIGFscGhhMSwga3ksIHRoaXMuX3NldHRpbmdzLnBpZUlubmVyVGV4dChkYXRhW2ldLCB0b3RhbFZhbHVlKSwgdHJ1ZSk7XG5cdCAgICAgIC8qbGFiZWwgb3V0c2lkZSB0aGUgc2VjdG9yKi9cblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubGFiZWwpIHRoaXMuX2RyYXdTZWN0b3JMYWJlbCh4MCwgeTAsIHJhZGl1cyArIHRoaXMuX3NldHRpbmdzLmxhYmVsT2Zmc2V0LCBhbHBoYTAsIGFscGhhMSwga3ksIHRoaXMuX3NldHRpbmdzLmxhYmVsKGRhdGFbaV0pKTtcblx0ICAgICAgLypkcmF3aW5nIGxvd2VyIHBhcnQgZm9yIDNEIHBpZSovXG5cblx0ICAgICAgaWYgKGt5ICE9IDEpIHtcblx0ICAgICAgICB0aGlzLl9jcmVhdGVMb3dlclNlY3RvcihjdHgsIHgwLCB5MCwgYWxwaGEwLCBhbHBoYTEsIHJhZGl1cywgdHJ1ZSk7XG5cblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG5cdCAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4yO1xuXG5cdCAgICAgICAgdGhpcy5fY3JlYXRlTG93ZXJTZWN0b3IoY3R4LCB4MCwgeTAsIGFscGhhMCwgYWxwaGExLCByYWRpdXMsIGZhbHNlKTtcblxuXHQgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdCAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHQgICAgICB9XG5cdCAgICAgIC8qY3JlYXRzIG1hcCBhcmVhIChuZWVkZWQgZm9yIGV2ZW50cykqL1xuXG5cblx0ICAgICAgbWFwLmFkZFNlY3RvcihkYXRhW2ldLmlkLCBhbHBoYTAsIGFscGhhMSwgeDAgLSBwb2ludDAueCwgeTAgLSBwb2ludDAueSAvIGt5LCByYWRpdXMsIGt5LCBzSW5kZXgpO1xuXHQgICAgICBhbHBoYTAgPSBhbHBoYTE7XG5cdCAgICB9XG5cdCAgICAvKnJlbmRlcnMgcmFkaXVzIGxpbmVzIGFuZCBsYWJlbHMqL1xuXG5cblx0ICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuODtcblx0ICAgIHZhciBwO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYW5nbGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHAgPSB0aGlzLl9nZXRQb3NpdGlvbkJ5QW5nbGUoYW5nbGVzW2ldLCB4MCwgeTAsIHJhZGl1cyk7XG5cblx0ICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB4MCwgeTAsIHAueCwgcC55LCB0aGlzLl9zZXR0aW5ncy5saW5lQ29sb3IuY2FsbCh0aGlzLCBkYXRhW2ldKSwgMik7XG5cdCAgICB9XG5cblx0ICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cblx0ICAgIGlmIChreSA9PSAxICYmIHRoaXMuX3NldHRpbmdzLmJvcmRlcikge1xuXHQgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5fc2V0dGluZ3MuYm9yZGVyV2lkdGggfHwgMjtcblx0ICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc2V0dGluZ3MuYm9yZGVyQ29sb3IgPyB0aGlzLl9zZXR0aW5ncy5ib3JkZXJDb2xvci5jYWxsKHRoaXMpIDogXCIjZmZmZmZmXCI7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgY3R4LmFyYyh4MCwgeTAsIHJhZGl1cyArIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG5cdCAgICAgIGN0eC5zdHJva2UoKTtcblx0ICAgIH1cblxuXHQgICAgY3R4LnNjYWxlKDEsIDEgLyBreSk7XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICAqICAgcmV0dXJucyBsaXN0IG9mIHZhbHVlc1xuXHQgICAqICAgQHBhcmFtOiBkYXRhIGFycmF5XG5cdCAgICovXG5cdCAgX2dldFZhbHVlczogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHZhciB2ID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2LnB1c2goTWF0aC5hYnMocGFyc2VGbG9hdCh0aGlzLl9zZXR0aW5ncy52YWx1ZShkYXRhW2ldKSB8fCAwKSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdjtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogICByZXR1cm5zIHRvdGFsIHZhbHVlXG5cdCAgICogICBAcGFyYW06IHRoZSBhcnJheSBvZiB2YWx1ZXNcblx0ICAgKi9cblx0ICBfZ2V0VG90YWxWYWx1ZTogZnVuY3Rpb24gKHZhbHVlcykge1xuXHQgICAgdmFyIHQgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0ICs9IHZhbHVlc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICAqICAgZ2V0cyBhbmdsZXMgZm9yIGFsbCB2YWx1ZXNcblx0ICAgKiAgIEBwYXJhbTogdGhlIGFycmF5IG9mIHZhbHVlc1xuXHQgICAqICAgQHBhcmFtOiB0b3RhbCB2YWx1ZSAob3B0aW9uYWwpXG5cdCAgICovXG5cdCAgX2dldFJhdGlvczogZnVuY3Rpb24gKHZhbHVlcywgdG90YWxWYWx1ZSkge1xuXHQgICAgdmFyIHZhbHVlO1xuXHQgICAgdmFyIHJhdGlvcyA9IFtdO1xuXHQgICAgdmFyIHByZXZTdW0gPSAwO1xuXHQgICAgdG90YWxWYWx1ZSA9IHRvdGFsVmFsdWUgfHwgdGhpcy5fZ2V0VG90YWxWYWx1ZSh2YWx1ZXMpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcblx0ICAgICAgcmF0aW9zW2ldID0gTWF0aC5QSSAqIDIgKiAodG90YWxWYWx1ZSA/ICh2YWx1ZSArIHByZXZTdW0pIC8gdG90YWxWYWx1ZSA6IDEgLyB2YWx1ZXMubGVuZ3RoKTtcblx0ICAgICAgcHJldlN1bSArPSB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJhdGlvcztcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogICByZXR1cm5zIGNhbGN1bGF0ZWQgcGllIHBhcmFtZXRlcnM6IGNlbnRlciBwb3NpdGlvbiBhbmQgcmFkaXVzXG5cdCAgICogICBAcGFyYW06IHggLSB0aGUgd2lkdGggb2YgYSBjb250YWluZXJcblx0ICAgKiAgIEBwYXJhbTogeSAtIHRoZSBoZWlnaHQgb2YgYSBjb250YWluZXJcblx0ICAgKi9cblx0ICBfZ2V0UGllUGFyYW1ldGVyczogZnVuY3Rpb24gKHBvaW50MCwgcG9pbnQxKSB7XG5cdCAgICAvKnZhciBvZmZzZXRYID0gMDtcblx0ICAgICB2YXIgb2Zmc2V0WSA9IDA7XG5cdCAgICAgaWYodGhpcy5fc2V0dGluZ3MubGVnZW5kICYmdGhpcy5fc2V0dGluZ3MubGVnZW5kLmxheW91dCE9XCJ4XCIpXG5cdCAgICAgb2Zmc2V0WCA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZC53aWR0aCoodGhpcy5fc2V0dGluZ3MubGVnZW5kLmFsaWduPT1cInJpZ2h0XCI/LTE6MSk7XG5cdCAgICAgdmFyIHgwID0gKHggKyBvZmZzZXRYKS8yO1xuXHQgICAgIGlmKHRoaXMuX3NldHRpbmdzLmxlZ2VuZCAmJnRoaXMuX3NldHRpbmdzLmxlZ2VuZC5sYXlvdXQ9PVwieFwiKVxuXHQgICAgIG9mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5sZWdlbmQuaGVpZ2h0Kih0aGlzLl9zZXR0aW5ncy5sZWdlbmQudmFsaWduPT1cImJvdHRvbVwiPy0xOjEpO1xuXHQgICAgIHZhciB5MCA9ICh5K29mZnNldFkpLzI7Ki9cblx0ICAgIHZhciB3aWR0aCA9IHBvaW50MS54IC0gcG9pbnQwLng7XG5cdCAgICB2YXIgaGVpZ2h0ID0gcG9pbnQxLnkgLSBwb2ludDAueTtcblx0ICAgIHZhciB4MCA9IHBvaW50MC54ICsgd2lkdGggLyAyO1xuXHQgICAgdmFyIHkwID0gcG9pbnQwLnkgKyBoZWlnaHQgLyAyO1xuXHQgICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBcInhcIjogeDAsXG5cdCAgICAgIFwieVwiOiB5MCxcblx0ICAgICAgXCJyYWRpdXNcIjogcmFkaXVzXG5cdCAgICB9O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIGNyZWF0ZXMgbG93ZXIgcGFydCBvZiBzZWN0b3IgaW4gM0RwaWVcblx0ICAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICAqICAgQHBhcmFtOiB4MCAtIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwaWUgY2VudGVyXG5cdCAgICogICBAcGFyYW06IHkwIC0gdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBwaWUgY2VudGVyXG5cdCAgICogICBAcGFyYW06IGEwIC0gdGhlIGFuZ2xlIHRoYXQgZGVmaW5lcyB0aGUgZmlyc3QgZWRnZSBvZiBhIHNlY3RvclxuXHQgICAqICAgQHBhcmFtOiBhMSAtIHRoZSBhbmdsZSB0aGF0IGRlZmluZXMgdGhlIHNlY29uZCBlZGdlIG9mIGEgc2VjdG9yXG5cdCAgICogICBAcGFyYW06IFIgLSBwaWUgcmFkaXVzXG5cdCAgICogICBAcGFyYW06IGxpbmUgKGJvb2xlYW4pIC0gaWYgdGhlIHNlY3RvciBuZWVkcyBhIGJvcmRlclxuXHQgICAqL1xuXHQgIF9jcmVhdGVMb3dlclNlY3RvcjogZnVuY3Rpb24gKGN0eCwgeDAsIHkwLCBhMSwgYTIsIFIsIGxpbmUpIHtcblx0ICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXHQgICAgLypjaGVja3MgaWYgdGhlIGxvd2VyIHNlY3RvciBuZWVkcyBiZWluZyBkaXNwbGF5ZWQqL1xuXG5cdCAgICBpZiAoIShhMSA8PSAwICYmIGEyID49IDAgfHwgYTEgPj0gMCAmJiBhMiA8PSBNYXRoLlBJIHx8IE1hdGguYWJzKGExIC0gTWF0aC5QSSkgPiAwLjAwMyAmJiBhMSA8PSBNYXRoLlBJICYmIGEyID49IE1hdGguUEkpKSByZXR1cm47XG5cblx0ICAgIGlmIChhMSA8PSAwICYmIGEyID49IDApIHtcblx0ICAgICAgYTEgPSAwO1xuXHQgICAgICBsaW5lID0gZmFsc2U7XG5cblx0ICAgICAgdGhpcy5fZHJhd1NlY3RvckxpbmUoY3R4LCB4MCwgeTAsIFIsIGExLCBhMik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChhMSA8PSBNYXRoLlBJICYmIGEyID49IE1hdGguUEkpIHtcblx0ICAgICAgYTIgPSBNYXRoLlBJO1xuXHQgICAgICBsaW5lID0gZmFsc2U7XG5cblx0ICAgICAgdGhpcy5fZHJhd1NlY3RvckxpbmUoY3R4LCB4MCwgeTAsIFIsIGExLCBhMik7XG5cdCAgICB9XG5cdCAgICAvKnRoZSBoZWlnaHQgb2YgM0QgcGllKi9cblxuXG5cdCAgICB2YXIgb2Zmc2V0ID0gKHRoaXMuX3NldHRpbmdzLnBpZUhlaWdodCB8fCBNYXRoLmZsb29yKFIgLyA0KSkgLyB0aGlzLl9zZXR0aW5ncy5jYW50O1xuXG5cdCAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICBjdHguYXJjKHgwLCB5MCwgUiwgYTEsIGEyLCBmYWxzZSk7XG5cdCAgICBjdHgubGluZVRvKHgwICsgUiAqIE1hdGguY29zKGEyKSwgeTAgKyBSICogTWF0aC5zaW4oYTIpICsgb2Zmc2V0KTtcblx0ICAgIGN0eC5hcmMoeDAsIHkwICsgb2Zmc2V0LCBSLCBhMiwgYTEsIHRydWUpO1xuXHQgICAgY3R4LmxpbmVUbyh4MCArIFIgKiBNYXRoLmNvcyhhMSksIHkwICsgUiAqIE1hdGguc2luKGExKSk7XG5cdCAgICBjdHguZmlsbCgpO1xuXHQgICAgaWYgKGxpbmUpIGN0eC5zdHJva2UoKTtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogICBkcmF3cyBhIHNlcmN0b3IgYXJjXG5cdCAgICovXG5cdCAgX2RyYXdTZWN0b3JMaW5lOiBmdW5jdGlvbiAoY3R4LCB4MCwgeTAsIFIsIGExLCBhMikge1xuXHQgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHQgICAgY3R4LmFyYyh4MCwgeTAsIFIsIGExLCBhMiwgZmFsc2UpO1xuXHQgICAgY3R4LnN0cm9rZSgpO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIGFkZHMgYSBzaGFkb3cgdG8gcGllXG5cdCAgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAgKiAgIEBwYXJhbTogeCAtIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwaWUgY2VudGVyXG5cdCAgICogICBAcGFyYW06IHkgLSB0aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHBpZSBjZW50ZXJcblx0ICAgKiAgIEBwYXJhbTogUiAtIHBpZSByYWRpdXNcblx0ICAgKi9cblx0ICBfYWRkU2hhZG93OiBmdW5jdGlvbiAoY3R4LCB4LCB5LCBSKSB7XG5cdCAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjU7XG5cdCAgICB2YXIgc2hhZG93cyA9IFtcIiNjNGM0YzRcIiwgXCIjYzZjNmM2XCIsIFwiI2NhY2FjYVwiLCBcIiNkY2RjZGNcIiwgXCIjZGRkZGRkXCIsIFwiI2UwZTBlMFwiLCBcIiNlZWVlZWVcIiwgXCIjZjVmNWY1XCIsIFwiI2Y4ZjhmOFwiXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IHNoYWRvd3MubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcblx0ICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHQgICAgICBjdHguZmlsbFN0eWxlID0gc2hhZG93c1tpXTtcblx0ICAgICAgY3R4LmFyYyh4ICsgMSwgeSArIDEsIFIgKyBpLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdCAgICAgIGN0eC5maWxsKCk7XG5cdCAgICB9XG5cblx0ICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICAqICAgcmV0dXJucyBhIGdyYXkgZ3JhZGllbnRcblx0ICAgKiAgIEBwYXJhbTogZ3JhZGllbnQgLSBncmFkaWVudCBvYmplY3Rcblx0ICAgKi9cblx0ICBfZ2V0R3JheUdyYWRpZW50OiBmdW5jdGlvbiAoZ3JhZGllbnQpIHtcblx0ICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjAsIFwiI2ZmZmZmZlwiKTtcblx0ICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjcsIFwiIzdhN2E3YVwiKTtcblx0ICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLjAsIFwiIzAwMDAwMFwiKTtcblx0ICAgIHJldHVybiBncmFkaWVudDtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgICogICBhZGRzIGdyYXkgcmFkaWFsIGdyYWRpZW50XG5cdCAgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAgKiAgIEBwYXJhbTogeCAtIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBwaWUgY2VudGVyXG5cdCAgICogICBAcGFyYW06IHkgLSB0aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIHBpZSBjZW50ZXJcblx0ICAgKiAgIEBwYXJhbTogcmFkaXVzIC0gcGllIHJhZGl1c1xuXHQgICAqICAgQHBhcmFtOiB4MCAtIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIGEgZ3JhZGllbnQgY2VudGVyXG5cdCAgICogICBAcGFyYW06IHkwIC0gdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGEgZ3JhZGllbnQgY2VudGVyXG5cdCAgICovXG5cdCAgX3Nob3dSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgeCwgeSwgcmFkaXVzLCB4MCwgeTApIHtcblx0ICAgIC8vY3R4Lmdsb2JhbEFscGhhID0gMC4zO1xuXHQgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHQgICAgdmFyIGdyYWRpZW50O1xuXG5cdCAgICBpZiAodHlwZW9mIHRoaXMuX3NldHRpbmdzLmdyYWRpZW50ICE9IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4MCwgeTAsIHJhZGl1cyAvIDQsIHgsIHksIHJhZGl1cyk7XG5cdCAgICAgIGdyYWRpZW50ID0gdGhpcy5fZ2V0R3JheUdyYWRpZW50KGdyYWRpZW50KTtcblx0ICAgIH0gZWxzZSBncmFkaWVudCA9IHRoaXMuX3NldHRpbmdzLmdyYWRpZW50KGdyYWRpZW50KTtcblxuXHQgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuXHQgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0ICAgIGN0eC5maWxsKCk7IC8vY3R4Lmdsb2JhbEFscGhhID0gMTtcblxuXHQgICAgY3R4Lmdsb2JhbEFscGhhID0gMC43O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIHJldHVybnMgdGhlIGNhbGN1bGF0ZXMgcGllIHBhcmFtZXRlcnM6IGNlbnRlciBwb3NpdGlvbiBhbmQgcmFkaXVzXG5cdCAgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAgKiAgIEBwYXJhbTogeDAgLSB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgcGllIGNlbnRlclxuXHQgICAqICAgQHBhcmFtOiB5MCAtIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgcGllIGNlbnRlclxuXHQgICAqICAgQHBhcmFtOiBSIC0gcGllIHJhZGl1c1xuXHQgICAqICAgQHBhcmFtOiBhbHBoYTEgLSB0aGUgYW5nbGUgdGhhdCBkZWZpbmVzIHRoZSAxc3QgZWRnZSBvZiBhIHNlY3RvclxuXHQgICAqICAgQHBhcmFtOiBhbHBoYTIgLSB0aGUgYW5nbGUgdGhhdCBkZWZpbmVzIHRoZSAybmQgZWRnZSBvZiBhIHNlY3RvclxuXHQgICAqICAgQHBhcmFtOiBreSAtIHRoZSB2YWx1ZSB0aGF0IGRlZmluZXMgYW4gYW5nbGUgb2YgaW5jbGluYXRpb25cblx0ICAgKiAgIEBwYXJhbTogdGV4dCAtIGxhYmVsIHRleHRcblx0ICAgKiAgIEBwYXJhbTogaW5fd2lkdGggKGJvb2xlYW4pIC0gaWYgbGFiZWwgbmVlZHMgYmVpbmcgZGlzcGxheWVkIGluc2lkZSBhIHBpZVxuXHQgICAqL1xuXHQgIF9kcmF3U2VjdG9yTGFiZWw6IGZ1bmN0aW9uICh4MCwgeTAsIFIsIGFscGhhMSwgYWxwaGEyLCBreSwgdGV4dCwgaW5fd2lkdGgpIHtcblx0ICAgIHZhciB0ID0gdGhpcy5jYW52YXNlc1swXS5yZW5kZXJUZXh0KDAsIDAsIHRleHQsIDAsIDEpO1xuXHQgICAgaWYgKCF0KSByZXR1cm47IC8vZ2V0IGV4aXN0aW5nIHdpZHRoIG9mIHRleHRcblxuXHQgICAgdmFyIGxhYmVsV2lkdGggPSB0LnNjcm9sbFdpZHRoO1xuXHQgICAgdC5zdHlsZS53aWR0aCA9IGxhYmVsV2lkdGggKyBcInB4XCI7IC8vYWRqdXN0IHRleHQgbGFiZWwgdG8gZml0IGFsbCB0ZXh0XG5cblx0ICAgIGlmIChsYWJlbFdpZHRoID4geDApIGxhYmVsV2lkdGggPSB4MDsgLy90aGUgdGV4dCBjYW4ndCBiZSBncmVhdGVyIHRoYW4gaGFsZiBvZiB2aWV3XG5cdCAgICAvL2NhbGN1bGF0ZSBleHBlY3RlZCBjb3JyZWN0aW9uIGJhc2VkIG9uIGRlZmF1bHQgZm9udCBtZXRyaWNzXG5cblx0ICAgIHZhciB3aWR0aCA9IGFscGhhMiAtIGFscGhhMSA8IDAuMiA/IDQgOiA4O1xuXHQgICAgaWYgKGluX3dpZHRoKSB3aWR0aCA9IGxhYmVsV2lkdGggLyAxLjg7XG5cdCAgICB2YXIgYWxwaGEgPSBhbHBoYTEgKyAoYWxwaGEyIC0gYWxwaGExKSAvIDI7IC8vcG9zaXRpb24gYW5kIGl0cyBjb3JyZWN0aW9uXG5cblx0ICAgIFIgPSBSIC0gKHdpZHRoIC0gOCkgLyAyO1xuXHQgICAgdmFyIGNvcnJfeCA9IC13aWR0aDtcblx0ICAgIHZhciBjb3JyX3kgPSAtODtcblx0ICAgIHZhciBhbGlnbiA9IFwicmlnaHRcIjsgLy9mb3IgaXRlbXMgaW4gbGVmdCB1cHBlciBhbmQgbG93ZXIgc2VjdG9yXG5cblx0ICAgIGlmIChhbHBoYSA+PSBNYXRoLlBJIC8gMiAmJiBhbHBoYSA8IE1hdGguUEkgfHwgYWxwaGEgPD0gMyAqIE1hdGguUEkgLyAyICYmIGFscGhhID49IE1hdGguUEkpIHtcblx0ICAgICAgY29ycl94ID0gLWxhYmVsV2lkdGggLSBjb3JyX3ggKyAxO1xuXHQgICAgICAvKmNvcnJlY3Rpb24gZm9yIGxhYmVsIHdpZHRoKi9cblxuXHQgICAgICBhbGlnbiA9IFwibGVmdFwiO1xuXHQgICAgfVxuXHQgICAgLypcblx0ICAgICAgIGNhbGN1bGF0ZSBwb3NpdGlvbiBvZiB0ZXh0XG5cdCAgICAgICBiYXNpY2FsbHkgZ2V0IHBvaW50IGF0IGNlbnRlciBvZiBwaWUgc2VjdG9yXG5cdCAgICAqL1xuXG5cblx0ICAgIHZhciBvZmZzZXQgPSAwO1xuXHQgICAgaWYgKCFpbl93aWR0aCAmJiBreSA8IDEgJiYgYWxwaGEgPiAwICYmIGFscGhhIDwgTWF0aC5QSSkgb2Zmc2V0ID0gKHRoaXMuX3NldHRpbmdzLmhlaWdodCB8fCBNYXRoLmZsb29yKFIgLyA0KSkgLyBreTtcblx0ICAgIHZhciB5ID0gKHkwICsgTWF0aC5mbG9vcigoUiArIG9mZnNldCkgKiBNYXRoLnNpbihhbHBoYSkpKSAqIGt5ICsgY29ycl95O1xuXHQgICAgdmFyIHggPSB4MCArIE1hdGguZmxvb3IoKFIgKyB3aWR0aCAvIDIpICogTWF0aC5jb3MoYWxwaGEpKSArIGNvcnJfeDtcblx0ICAgIC8qXG5cdCAgICAgICBpZiBwaWUgc2VjdG9yIHN0YXJ0cyBpbiBsZWZ0IG9mIHJpZ2h0IHBhcnQgcGllLFxuXHQgICAgICAgcmVsYXRlZCB0ZXh0XHRtdXN0IGJlIHBsYWNlZCB0byB0aGUgbGVmdCBvZiB0byB0aGUgcmlnaHQgb2YgcGllIGFzIHdlbGxcblx0ICAgICovXG5cblx0ICAgIHZhciBsZWZ0X2VuZCA9IGFscGhhMiA8IE1hdGguUEkgLyAyICsgMC4wMTtcblx0ICAgIHZhciBsZWZ0X3N0YXJ0ID0gYWxwaGExIDwgTWF0aC5QSSAvIDI7XG5cblx0ICAgIGlmIChsZWZ0X3N0YXJ0ICYmIGxlZnRfZW5kKSB7XG5cdCAgICAgIHggPSBNYXRoLm1heCh4LCB4MCArIDMpOyAvL3JpZ2h0IHBhcnQgb2YgcGllXG5cblx0ICAgICAgLyppZihhbHBoYTItYWxwaGExPDAuMilcblx0ICAgICAgXHR4ID0geDA7Ki9cblx0ICAgIH0gZWxzZSBpZiAoIWxlZnRfc3RhcnQgJiYgIWxlZnRfZW5kKSB4ID0gTWF0aC5taW4oeCwgeDAgLSBsYWJlbFdpZHRoKTsgLy9sZWZ0IHBhcnQgb2YgcGllXG5cdCAgICBlbHNlIGlmICghaW5fd2lkdGggJiYgKGFscGhhID49IE1hdGguUEkgLyAyICYmIGFscGhhIDwgTWF0aC5QSSB8fCBhbHBoYSA8PSAzICogTWF0aC5QSSAvIDIgJiYgYWxwaGEgPj0gTWF0aC5QSSkpIHtcblx0ICAgICAgICB4ICs9IGxhYmVsV2lkdGggLyAzO1xuXHQgICAgICB9IC8vd2UgbmVlZCB0byBzZXQgcG9zaXRpb24gb2YgdGV4dCBtYW51YWxseSwgYmFzZWQgb24gYWJvdmUgY2FsY3VsYXRpb25zXG5cblxuXHQgICAgdC5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuXHQgICAgdC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcblx0ICAgIHQuc3R5bGUud2lkdGggPSBsYWJlbFdpZHRoICsgXCJweFwiO1xuXHQgICAgdC5zdHlsZS50ZXh0QWxpZ24gPSBhbGlnbjtcblx0ICAgIHQuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG5cdCAgfSxcblx0ICAkcmVuZGVyX3BpZTNEOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCB4LCB5LCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdGhpcy5fcmVuZGVyUGllKGN0eCwgZGF0YSwgeCwgeSwgdGhpcy5fc2V0dGluZ3MuY2FudCwgbWFwKTtcblx0ICB9LFxuXHQgICRyZW5kZXJfZG9udXQ6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJQaWUoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgMSwgbWFwLCBzSW5kZXgpO1xuXG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cblx0ICAgIHZhciBjb29yZCA9IHRoaXMuX2dldFBpZVBhcmFtZXRlcnMocG9pbnQwLCBwb2ludDEpO1xuXG5cdCAgICB2YXIgcGllUmFkaXVzID0gY29uZmlnLnJhZGl1cyA/IGNvbmZpZy5yYWRpdXMgOiBjb29yZC5yYWRpdXM7XG5cdCAgICB2YXIgaW5uZXJSYWRpdXMgPSBjb25maWcuaW5uZXJSYWRpdXMgJiYgY29uZmlnLmlubmVyUmFkaXVzIDwgcGllUmFkaXVzID8gY29uZmlnLmlubmVyUmFkaXVzIDogcGllUmFkaXVzIC8gMztcblx0ICAgIHZhciB4MCA9IGNvbmZpZy54ID8gY29uZmlnLnggOiBjb29yZC54O1xuXHQgICAgdmFyIHkwID0gY29uZmlnLnkgPyBjb25maWcueSA6IGNvb3JkLnk7XG5cdCAgICBjdHguZmlsbFN0eWxlID0gXCIjZmZmZmZmXCI7XG5cdCAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICBjdHguYXJjKHgwLCB5MCwgaW5uZXJSYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0ICAgIGN0eC5maWxsKCk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBCYXJDaGFydCA9IHtcblx0ICAvKipcblx0ICAqICAgcmVuZGVycyBhIGJhciBjaGFydFxuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgKiAgIEBwYXJhbTogeCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogeSAtIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuXHQgICogICBAcGFyYW06IHNJbmRleCAtIGluZGV4IG9mIGRyYXdpbmcgY2hhcnRcblx0ICAqL1xuXHQgICRyZW5kZXJfYmFyOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4LCBtYXApIHtcblx0ICAgIHZhciBiYXJXaWR0aCxcblx0ICAgICAgICBjZWxsV2lkdGgsXG5cdCAgICAgICAgaSxcblx0ICAgICAgICBsaW1pdHMsXG5cdCAgICAgICAgbWF4VmFsdWUsXG5cdCAgICAgICAgbWluVmFsdWUsXG5cdCAgICAgICAgcmVsVmFsdWUsXG5cdCAgICAgICAgdmFsdWVGYWN0b3IsXG5cdCAgICAgICAgcmVsYXRpdmVWYWx1ZXMsXG5cdCAgICAgICAgc3RhcnRWYWx1ZSxcblx0ICAgICAgICB1bml0LFxuXHQgICAgICAgIHhheCxcblx0ICAgICAgICB5YXgsXG5cdCAgICAgICAgdG90YWxIZWlnaHQgPSBwb2ludDEueSAtIHBvaW50MC55O1xuXHQgICAgeWF4ID0gISF0aGlzLl9zZXR0aW5ncy55QXhpcztcblx0ICAgIHhheCA9ICEhdGhpcy5fc2V0dGluZ3MueEF4aXM7XG5cdCAgICBsaW1pdHMgPSB0aGlzLl9nZXRMaW1pdHMoKTtcblx0ICAgIG1heFZhbHVlID0gbGltaXRzLm1heDtcblx0ICAgIG1pblZhbHVlID0gbGltaXRzLm1pbjtcblx0ICAgIC8qYW4gYXZhaWxhYmxlIHdpZHRoIGZvciBvbmUgYmFyKi9cblxuXHQgICAgY2VsbFdpZHRoID0gKHBvaW50MS54IC0gcG9pbnQwLngpIC8gZGF0YS5sZW5ndGg7XG5cdCAgICAvKmRyYXdzIHggYW5kIHkgc2NhbGVzKi9cblxuXHQgICAgaWYgKCFzSW5kZXggJiYgISh0aGlzLl9zZXR0aW5ncy5vcmlnaW4gIT0gXCJhdXRvXCIgJiYgIXlheCkpIHtcblx0ICAgICAgdGhpcy5fZHJhd1NjYWxlcyhkYXRhLCBwb2ludDAsIHBvaW50MSwgbWluVmFsdWUsIG1heFZhbHVlLCBjZWxsV2lkdGgpO1xuXHQgICAgfVxuXHQgICAgLypuZWNlc3NhcnkgZm9yIGF1dG9tYXRpYyBzY2FsZSovXG5cblxuXHQgICAgaWYgKHlheCkge1xuXHQgICAgICBtYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MueUF4aXMuZW5kKTtcblx0ICAgICAgbWluVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIC8qdW5pdCBjYWxjdWxhdGlvbiAoYmFyX2hlaWdodCA9IHZhbHVlKnVuaXQpKi9cblxuXG5cdCAgICByZWxhdGl2ZVZhbHVlcyA9IHRoaXMuX2dldFJlbGF0aXZlVmFsdWUobWluVmFsdWUsIG1heFZhbHVlKTtcblx0ICAgIHJlbFZhbHVlID0gcmVsYXRpdmVWYWx1ZXNbMF07XG5cdCAgICB2YWx1ZUZhY3RvciA9IHJlbGF0aXZlVmFsdWVzWzFdO1xuXHQgICAgdW5pdCA9IHJlbFZhbHVlID8gdG90YWxIZWlnaHQgLyByZWxWYWx1ZSA6IHJlbFZhbHVlO1xuXG5cdCAgICBpZiAoIXlheCAmJiAhKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB4YXgpKSB7XG5cdCAgICAgIC8qZGVmaW5lcyBzdGFydCB2YWx1ZSBmb3IgYmV0dGVyIHJlcHJlc2VudGF0aW9uIG9mIHNtYWxsIHZhbHVlcyovXG5cdCAgICAgIHN0YXJ0VmFsdWUgPSAxMDtcblx0ICAgICAgdW5pdCA9IHJlbFZhbHVlID8gKHRvdGFsSGVpZ2h0IC0gc3RhcnRWYWx1ZSkgLyByZWxWYWx1ZSA6IHN0YXJ0VmFsdWU7XG5cdCAgICB9XG5cdCAgICAvKmlmIHlBeGlzIGlzbid0IHNldCwgYnV0IHdpdGggY3VzdG9tIG9yaWdpbiAqL1xuXG5cblx0ICAgIGlmICghc0luZGV4ICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiAheWF4ICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA+IG1pblZhbHVlKSB7XG5cdCAgICAgIHRoaXMuX2RyYXdYQXhpcyhjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBjZWxsV2lkdGgsIHBvaW50MS55IC0gdW5pdCAqICh0aGlzLl9zZXR0aW5ncy5vcmlnaW4gLSBtaW5WYWx1ZSkpO1xuXHQgICAgfVxuXHQgICAgLyphIHJlYWwgYmFyIHdpZHRoICovXG5cblxuXHQgICAgYmFyV2lkdGggPSBwYXJzZUludCh0aGlzLl9zZXR0aW5ncy5iYXJXaWR0aCwgMTApO1xuXHQgICAgdmFyIHNlcmllc051bWJlciA9IDA7XG5cdCAgICB2YXIgc2VyaWVzSW5kZXggPSAwO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChpID09IHNJbmRleCkge1xuXHQgICAgICAgIHNlcmllc0luZGV4ID0gc2VyaWVzTnVtYmVyO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX3Nlcmllc1tpXS50eXBlID09IFwiYmFyXCIpIHNlcmllc051bWJlcisrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2VyaWVzICYmIGJhcldpZHRoICogc2VyaWVzTnVtYmVyICsgNCA+IGNlbGxXaWR0aCkgYmFyV2lkdGggPSBwYXJzZUludChjZWxsV2lkdGggLyBzZXJpZXNOdW1iZXIgLSA0LCAxMCk7XG5cdCAgICAvKnRoZSBoYWxmIG9mIGRpc3RhbmNlIGJldHdlZW4gYmFycyovXG5cblx0ICAgIHZhciBiYXJPZmZzZXQgPSAoY2VsbFdpZHRoIC0gYmFyV2lkdGggKiBzZXJpZXNOdW1iZXIpIC8gMjtcblx0ICAgIC8qdGhlIHJhZGl1cyBvZiByb3VuZGluZyBpbiB0aGUgdG9wIHBhcnQgb2YgZWFjaCBiYXIqL1xuXG5cdCAgICB2YXIgcmFkaXVzID0gdHlwZW9mIHRoaXMuX3NldHRpbmdzLnJhZGl1cyAhPSBcInVuZGVmaW5lZFwiID8gcGFyc2VJbnQodGhpcy5fc2V0dGluZ3MucmFkaXVzLCAxMCkgOiBNYXRoLnJvdW5kKGJhcldpZHRoIC8gNSk7XG5cdCAgICB2YXIgaW5uZXJfZ3JhZGllbnQgPSBmYWxzZTtcblx0ICAgIHZhciBncmFkaWVudCA9IHRoaXMuX3NldHRpbmdzLmdyYWRpZW50O1xuXG5cdCAgICBpZiAoZ3JhZGllbnQgJiYgdHlwZW9mIGdyYWRpZW50ICE9IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICBpbm5lcl9ncmFkaWVudCA9IGdyYWRpZW50O1xuXHQgICAgICBncmFkaWVudCA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIGlmIChncmFkaWVudCkge1xuXHQgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBwb2ludDEueSwgMCwgcG9pbnQwLnkpO1xuXG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLmdyYWRpZW50KGdyYWRpZW50KTtcblx0ICAgIH1cblx0ICAgIC8qZHJhd3MgYSBibGFjayBsaW5lIGlmIHRoZSBob3Jpem9udGFsIHNjYWxlIGlzbid0IGRlZmluZWQqL1xuXG5cblx0ICAgIGlmICgheGF4KSB7XG5cdCAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgcG9pbnQwLngsIHBvaW50MS55ICsgMC41LCBwb2ludDEueCwgcG9pbnQxLnkgKyAwLjUsIFwiI2VkZWZmMFwiLCAxKTsgLy9oYXJkY29kZWQgY29sb3IhXG5cblx0ICAgIH1cblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLl9zZXR0aW5ncy52YWx1ZShkYXRhW2ldKSB8fCAwKTtcblx0ICAgICAgaWYgKHRoaXMuX2xvZ1NjYWxlQ2FsYykgdmFsdWUgPSB0aGlzLl9sb2cxMCh2YWx1ZSk7XG5cdCAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB2YWx1ZSA9IG1heFZhbHVlO1xuXHQgICAgICB2YWx1ZSAtPSBtaW5WYWx1ZTtcblx0ICAgICAgdmFsdWUgKj0gdmFsdWVGYWN0b3I7XG5cdCAgICAgIC8qc3RhcnQgcG9pbnQgKGJvdHRvbSBsZWZ0KSovXG5cblx0ICAgICAgdmFyIHgwID0gcG9pbnQwLnggKyBiYXJPZmZzZXQgKyBpICogY2VsbFdpZHRoICsgKGJhcldpZHRoICsgMSkgKiBzZXJpZXNJbmRleDtcblx0ICAgICAgdmFyIHkwID0gcG9pbnQxLnk7XG5cblx0ICAgICAgdmFyIGNvbG9yJCQxID0gZ3JhZGllbnQgfHwgdGhpcy5fc2V0dGluZ3MuY29sb3IuY2FsbCh0aGlzLCBkYXRhW2ldKTtcblxuXHQgICAgICB2YXIgYm9yZGVyID0gdGhpcy5fc2V0dGluZ3MuYm9yZGVyID8gMSA6IDA7XG5cblx0ICAgICAgdmFyIGxhYmVsID0gdGhpcy5fc2V0dGluZ3MubGFiZWwoZGF0YVtpXSk7XG5cdCAgICAgIC8qIGRvbid0IGRyYXcgYm9yZGVycyBhbmQgbGFiZWxzIGZvciBub3QgcGFpbnRlZCB2YWx1ZXMgKG9uIHktQXhpcyBvciBsb3dlcikgKi9cblxuXG5cdCAgICAgIGlmICh2YWx1ZSA9PSB0aGlzLl9zZXR0aW5ncy5vcmlnaW4gfHwgdGhpcy5fc2V0dGluZ3Mub3JpZ2luID09IFwiYXV0b1wiICYmIHRoaXMuX3NldHRpbmdzLnZhbHVlKGRhdGFbaV0pID09IG1pblZhbHVlKSB7XG5cdCAgICAgICAgYm9yZGVyID0gMDtcblx0ICAgICAgICBsYWJlbCA9IFwiXCI7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwIHx8IHRoaXMuX3NldHRpbmdzLnlBeGlzICYmIHZhbHVlID09PSAwICYmICEodGhpcy5fc2V0dGluZ3Mub3JpZ2luICE9IFwiYXV0b1wiICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA+IG1pblZhbHVlKSkge1xuXHQgICAgICAgIHZhbHVlID0gYm9yZGVyID0gMDtcblx0ICAgICAgICBsYWJlbCA9IFwiXCI7XG5cdCAgICAgIH1cblx0ICAgICAgLyp0YWtlcyBzdGFydCB2YWx1ZSBpbnRvIGNvbnNpZGVyYXRpb24gKi9cblx0ICAgICAgZWxzZSBpZiAoIXlheCAmJiAhKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB4YXgpKSB2YWx1ZSArPSBzdGFydFZhbHVlIC8gdW5pdDtcblx0ICAgICAgLypkcmF3aW5nIGJhciBib2R5Ki9cblxuXG5cdCAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX3NldHRpbmdzLmFscGhhLmNhbGwodGhpcywgZGF0YVtpXSk7XG5cblx0ICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX2RyYXdCYXIoY3R4LCBwb2ludDAsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciQkMSwgZ3JhZGllbnQsIGlubmVyX2dyYWRpZW50LCBib3JkZXIpO1xuXG5cdCAgICAgIGlmIChpbm5lcl9ncmFkaWVudCkge1xuXHQgICAgICAgIHRoaXMuX2RyYXdCYXJHcmFkaWVudChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciQkMSwgaW5uZXJfZ3JhZGllbnQsIGJvcmRlcik7XG5cdCAgICAgIH1cblx0ICAgICAgLypkcmF3aW5nIHRoZSBncmFkaWVudCBib3JkZXIgb2YgYSBiYXIqL1xuXG5cblx0ICAgICAgaWYgKGJvcmRlcikgdGhpcy5fZHJhd0JhckJvcmRlcihjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciQkMSk7XG5cdCAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdCAgICAgIC8qc2V0cyBhIGJhciBsYWJlbCovXG5cblx0ICAgICAgaWYgKHBvaW50c1swXSAhPSB4MCkgdGhpcy5jYW52YXNlc1tzSW5kZXhdLnJlbmRlclRleHRBdChmYWxzZSwgdHJ1ZSwgeDAgKyBNYXRoLmZsb29yKGJhcldpZHRoIC8gMiksIHBvaW50c1sxXSwgbGFiZWwpO2Vsc2UgdGhpcy5jYW52YXNlc1tzSW5kZXhdLnJlbmRlclRleHRBdCh0cnVlLCB0cnVlLCB4MCArIE1hdGguZmxvb3IoYmFyV2lkdGggLyAyKSwgcG9pbnRzWzNdLCBsYWJlbCk7XG5cdCAgICAgIC8qZGVmaW5lcyBhIG1hcCBhcmVhIGZvciBhIGJhciovXG5cblx0ICAgICAgbWFwLmFkZFJlY3QoZGF0YVtpXS5pZCwgW3gwIC0gcG9pbnQwLngsIHBvaW50c1szXSAtIHBvaW50MC55LCBwb2ludHNbMl0gLSBwb2ludDAueCwgcG9pbnRzWzFdIC0gcG9pbnQwLnldLCBzSW5kZXgpOyAvL3RoaXMuX2FkZE1hcFJlY3QobWFwLGRhdGFbaV0uaWQsW3t4OngwLHk6cG9pbnRzWzNdfSx7eDpwb2ludHNbMl0seTpwb2ludHNbMV19XSxwb2ludDAsc0luZGV4KTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jb3JyZWN0QmFyUGFyYW1zOiBmdW5jdGlvbiAoY3R4LCB4LCB5LCB2YWx1ZSwgdW5pdCwgYmFyV2lkdGgsIG1pblZhbHVlKSB7XG5cdCAgICB2YXIgeGF4ID0gdGhpcy5fc2V0dGluZ3MueEF4aXM7XG5cdCAgICB2YXIgYXhpc1N0YXJ0ID0geTtcblxuXHQgICAgaWYgKCEheGF4ICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB0aGlzLl9zZXR0aW5ncy5vcmlnaW4gPiBtaW5WYWx1ZSkge1xuXHQgICAgICB5IC09ICh0aGlzLl9zZXR0aW5ncy5vcmlnaW4gLSBtaW5WYWx1ZSkgKiB1bml0O1xuXHQgICAgICBheGlzU3RhcnQgPSB5O1xuXHQgICAgICB2YWx1ZSA9IHZhbHVlIC0gKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAtIG1pblZhbHVlKTtcblxuXHQgICAgICBpZiAodmFsdWUgPCAwKSB7XG5cdCAgICAgICAgdmFsdWUgKj0gLTE7XG5cdCAgICAgICAgY3R4LnRyYW5zbGF0ZSh4ICsgYmFyV2lkdGgsIHkpO1xuXHQgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XG5cdCAgICAgICAgeCA9IDA7XG5cdCAgICAgICAgeSA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB5IC09IDAuNTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICB4MDogeCxcblx0ICAgICAgeTA6IHksXG5cdCAgICAgIHN0YXJ0OiBheGlzU3RhcnRcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfZHJhd0JhcjogZnVuY3Rpb24gKGN0eCwgcG9pbnQwLCB4MCwgeTAsIGJhcldpZHRoLCBtaW5WYWx1ZSwgcmFkaXVzLCB1bml0LCB2YWx1ZSwgY29sb3IkJDEsIGdyYWRpZW50LCBpbm5lcl9ncmFkaWVudCwgYm9yZGVyKSB7XG5cdCAgICBjdHguc2F2ZSgpO1xuXHQgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yJCQxO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX2NvcnJlY3RCYXJQYXJhbXMoY3R4LCB4MCwgeTAsIHZhbHVlLCB1bml0LCBiYXJXaWR0aCwgbWluVmFsdWUpO1xuXG5cdCAgICB2YXIgcG9pbnRzID0gdGhpcy5fc2V0QmFyUG9pbnRzKGN0eCwgcC54MCwgcC55MCwgYmFyV2lkdGgsIHJhZGl1cywgdW5pdCwgcC52YWx1ZSwgYm9yZGVyKTtcblxuXHQgICAgaWYgKGdyYWRpZW50ICYmICFpbm5lcl9ncmFkaWVudCkgY3R4LmxpbmVUbyhwLngwICsgYm9yZGVyLCBwb2ludDAueSk7IC8vZml4IGdyYWRpZW50IHNwaHJlYWRpbmdcblxuXHQgICAgY3R4LmZpbGwoKTtcblx0ICAgIGN0eC5yZXN0b3JlKCk7XG5cdCAgICB2YXIgeDEgPSBwLngwO1xuXHQgICAgdmFyIHgyID0gcC54MCAhPSB4MCA/IHgwICsgcG9pbnRzWzBdIDogcG9pbnRzWzBdO1xuXHQgICAgdmFyIHkxID0gcC54MCAhPSB4MCA/IHAuc3RhcnQgLSBwb2ludHNbMV0gLSBwLnkwIDogcC55MDtcblx0ICAgIHZhciB5MiA9IHAueDAgIT0geDAgPyBwLnN0YXJ0IC0gcC55MCA6IHBvaW50c1sxXTtcblx0ICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xuXHQgIH0sXG5cdCAgX3NldEJvcmRlclN0eWxlczogZnVuY3Rpb24gKGN0eCwgcmF3Q29sb3IpIHtcblx0ICAgIHZhciBoc3YsIHJnYjtcblx0ICAgIHJnYiA9IGNvbG9yLnRvUmdiKHJhd0NvbG9yKTtcblx0ICAgIGhzdiA9IGNvbG9yLnJnYlRvSHN2KHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuXHQgICAgaHN2WzJdIC89IDEuNDtcblx0ICAgIHZhciByZ2JDb2xvciA9IFwicmdiKFwiICsgY29sb3IuaHN2VG9SZ2IoaHN2WzBdLCBoc3ZbMV0sIGhzdlsyXSkgKyBcIilcIjtcblx0ICAgIGN0eC5zdHJva2VTdHlsZSA9IHJnYkNvbG9yO1xuXHQgICAgaWYgKGN0eC5nbG9iYWxBbHBoYSA9PSAxKSBjdHguZ2xvYmFsQWxwaGEgPSAwLjk7XG5cdCAgfSxcblx0ICBfZHJhd0JhckJvcmRlcjogZnVuY3Rpb24gKGN0eCwgeDAsIHkwLCBiYXJXaWR0aCwgbWluVmFsdWUsIHJhZGl1cywgdW5pdCwgdmFsdWUsIGNvbG9yJCQxKSB7XG5cdCAgICB2YXIgcDtcblx0ICAgIGN0eC5zYXZlKCk7XG5cdCAgICBwID0gdGhpcy5fY29ycmVjdEJhclBhcmFtcyhjdHgsIHgwLCB5MCwgdmFsdWUsIHVuaXQsIGJhcldpZHRoLCBtaW5WYWx1ZSk7XG5cblx0ICAgIHRoaXMuX3NldEJvcmRlclN0eWxlcyhjdHgsIGNvbG9yJCQxKTtcblxuXHQgICAgdGhpcy5fc2V0QmFyUG9pbnRzKGN0eCwgcC54MCwgcC55MCwgYmFyV2lkdGgsIHJhZGl1cywgdW5pdCwgcC52YWx1ZSwgY3R4LmxpbmVXaWR0aCAvIDIsIDEpO1xuXG5cdCAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAvKmN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0ICAgICB0aGlzLl9zZXRCYXJQb2ludHMoY3R4LHAueDAscC55MCxiYXJXaWR0aCxyYWRpdXMsdW5pdCxwLnZhbHVlLDApO1xuXHQgICAgIGN0eC5saW5lVG8ocC54MCwwKTtcblx0ICAgICBjdHguZmlsbCgpXG5cdCAgICBcdFx0IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcblx0ICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM3O1xuXHQgICAgXHQgdGhpcy5fc2V0QmFyUG9pbnRzKGN0eCxwLngwLHAueTAsYmFyV2lkdGgscmFkaXVzLHVuaXQscC52YWx1ZSwwKTtcblx0ICAgICBjdHguZmlsbCgpXG5cdCAgICAgKi9cblxuXHQgICAgY3R4LnJlc3RvcmUoKTtcblx0ICB9LFxuXHQgIF9kcmF3QmFyR3JhZGllbnQ6IGZ1bmN0aW9uIChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciQkMSwgaW5uZXJfZ3JhZGllbnQsIGJvcmRlcikge1xuXHQgICAgY3R4LnNhdmUoKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9jb3JyZWN0QmFyUGFyYW1zKGN0eCwgeDAsIHkwLCB2YWx1ZSwgdW5pdCwgYmFyV2lkdGgsIG1pblZhbHVlKTtcblxuXHQgICAgdmFyIGdyYWRQYXJhbSA9IHRoaXMuX3NldEJhckdyYWRpZW50KGN0eCwgcC54MCwgcC55MCwgcC54MCArIGJhcldpZHRoLCBwLnkwIC0gdW5pdCAqIHAudmFsdWUgKyAyLCBpbm5lcl9ncmFkaWVudCwgY29sb3IkJDEsIFwieVwiKTtcblxuXHQgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRQYXJhbS5ncmFkaWVudDtcblxuXHQgICAgdGhpcy5fc2V0QmFyUG9pbnRzKGN0eCwgcC54MCArIGdyYWRQYXJhbS5vZmZzZXQsIHAueTAsIGJhcldpZHRoIC0gZ3JhZFBhcmFtLm9mZnNldCAqIDIsIHJhZGl1cywgdW5pdCwgcC52YWx1ZSwgZ3JhZFBhcmFtLm9mZnNldCArIGJvcmRlcik7XG5cblx0ICAgIGN0eC5maWxsKCk7XG5cdCAgICBjdHgucmVzdG9yZSgpO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIHNldHMgcG9pbnRzIGZvciBiYXIgYW5kIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBib3R0b20gcmlnaHQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICAqICAgQHBhcmFtOiB4MCAtIHRoZSB4IHBvc2l0aW9uIG9mIHN0YXJ0IHBvaW50XG5cdCAgICogICBAcGFyYW06IHkwIC0gdGhlIHkgcG9zaXRpb24gb2Ygc3RhcnQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogYmFyV2lkdGggLSBiYXIgd2lkdGhcblx0ICAgKiAgIEBwYXJhbTogcmFkaXVzIC0gdGhlIHJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgdG9wXG5cdCAgICogICBAcGFyYW06IHVuaXQgLSB0aGUgdmFsdWUgZGVmaW5lcyB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBpdGVtIHZhbHVlIGFuZCBiYXIgaGVpZ2h0XG5cdCAgICogICBAcGFyYW06IHZhbHVlIC0gaXRlbSB2YWx1ZVxuXHQgICAqICAgQHBhcmFtOiBvZmZzZXQgLSB0aGUgb2Zmc2V0IGZyb20gZXhwZWN0ZWQgYmFyIGVkZ2UgKG5lY2Vzc2FyeSBmb3IgZHJhd2luZyBib3JkZXIpXG5cdCAgICovXG5cdCAgX3NldEJhclBvaW50czogZnVuY3Rpb24gKGN0eCwgeDAsIHkwLCBiYXJXaWR0aCwgcmFkaXVzLCB1bml0LCB2YWx1ZSwgb2Zmc2V0LCBza2lwQm90dG9tKSB7XG5cdCAgICAvKmNvcnJlY3Rpb24gZm9yIGRpc3BsYWluZyBzbWFsbCB2YWx1ZXMgKHdoZW4gcm91bmRpbmcgcmFkaXVzIGlzIGJpZ2dlciB0aGFuIGJhciBoZWlnaHQpKi9cblx0ICAgIGN0eC5iZWdpblBhdGgoKTsgLy95MCA9IDAuNTtcblxuXHQgICAgdmFyIGFuZ2xlX2NvcnIgPSAwO1xuXG5cdCAgICBpZiAocmFkaXVzID4gdW5pdCAqIHZhbHVlKSB7XG5cdCAgICAgIHZhciBjb3NBID0gKHJhZGl1cyAtIHVuaXQgKiB2YWx1ZSkgLyByYWRpdXM7XG5cdCAgICAgIGlmIChjb3NBIDw9IDEgJiYgY29zQSA+PSAtMSkgYW5nbGVfY29yciA9IC1NYXRoLmFjb3MoY29zQSkgKyBNYXRoLlBJIC8gMjtcblx0ICAgIH1cblx0ICAgIC8qc3RhcnQqL1xuXG5cblx0ICAgIGN0eC5tb3ZlVG8oeDAgKyBvZmZzZXQsIHkwKTtcblx0ICAgIC8qc3RhcnQgb2YgbGVmdCByb3VuZGluZyovXG5cblx0ICAgIHZhciB5MSA9IHkwIC0gTWF0aC5mbG9vcih1bml0ICogdmFsdWUpICsgcmFkaXVzICsgKHJhZGl1cyA/IDAgOiBvZmZzZXQpO1xuXHQgICAgaWYgKHJhZGl1cyA8IHVuaXQgKiB2YWx1ZSkgY3R4LmxpbmVUbyh4MCArIG9mZnNldCwgeTEpO1xuXHQgICAgLypsZWZ0IHJvdW5kaW5nKi9cblxuXHQgICAgdmFyIHgyID0geDAgKyByYWRpdXM7XG5cdCAgICBpZiAocmFkaXVzICYmIHJhZGl1cyA+IDApIGN0eC5hcmMoeDIsIHkxLCBNYXRoLm1heChyYWRpdXMgLSBvZmZzZXQsIDApLCAtTWF0aC5QSSArIGFuZ2xlX2NvcnIsIC1NYXRoLlBJIC8gMiwgZmFsc2UpO1xuXHQgICAgLypzdGFydCBvZiByaWdodCByb3VuZGluZyovXG5cblx0ICAgIHZhciB4MyA9IHgwICsgYmFyV2lkdGggLSByYWRpdXMgLSBvZmZzZXQ7XG5cdCAgICB2YXIgeTMgPSB5MSAtIHJhZGl1cyArIChyYWRpdXMgPyBvZmZzZXQgOiAwKTtcblx0ICAgIGN0eC5saW5lVG8oeDMsIHkzKTtcblx0ICAgIC8qcmlnaHQgcm91bmRpbmcqL1xuXG5cdCAgICBpZiAocmFkaXVzICYmIHJhZGl1cyA+IDApIGN0eC5hcmMoeDMgKyBvZmZzZXQsIHkxLCBNYXRoLm1heChyYWRpdXMgLSBvZmZzZXQsIDApLCAtTWF0aC5QSSAvIDIsIDAgLSBhbmdsZV9jb3JyLCBmYWxzZSk7XG5cdCAgICAvKmJvdHRvbSByaWdodCBwb2ludCovXG5cblx0ICAgIHZhciB4NSA9IHgwICsgYmFyV2lkdGggLSBvZmZzZXQ7XG5cdCAgICBjdHgubGluZVRvKHg1LCB5MCk7XG5cdCAgICAvKmxpbmUgdG8gdGhlIHN0YXJ0IHBvaW50Ki9cblxuXHQgICAgaWYgKCFza2lwQm90dG9tKSB7XG5cdCAgICAgIGN0eC5saW5lVG8oeDAgKyBvZmZzZXQsIHkwKTtcblx0ICAgIH0gLy9cdGN0eC5saW5lVG8oeDAsMCk7IC8vSUUgZml4IVxuXG5cblx0ICAgIHJldHVybiBbeDUsIHkzXTtcblx0ICB9XG5cdH07XG5cblx0dmFyIExpbmVDaGFydCA9IHtcblx0ICAvKipcblx0ICAqICAgcmVuZGVycyBhIGdyYXBoaWNcblx0ICAqICAgQHBhcmFtOiBjdHggLSBjYW52YXMgb2JqZWN0XG5cdCAgKiAgIEBwYXJhbTogZGF0YSAtIG9iamVjdCB0aG9zZSBuZWVkIHRvIGJlIGRpc3BsYXllZFxuXHQgICogICBAcGFyYW06IHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcblx0ICAqICAgQHBhcmFtOiBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXJcblx0ICAqICAgQHBhcmFtOiBzSW5kZXggLSBpbmRleCBvZiBkcmF3aW5nIGNoYXJ0XG5cdCAgKi9cblx0ICAkcmVuZGVyX2xpbmU6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIGNvbmZpZywgaSwgaXRlbXMsIHBhcmFtcywgeDAsIHgxLCB4MiwgeTEsIHkyLCB5MCwgcmVzMSwgcmVzMjtcblx0ICAgIHBhcmFtcyA9IHRoaXMuX2NhbGN1bGF0ZUxpbmVQYXJhbXMoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4KTtcblx0ICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXG5cdCAgICBpZiAoZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgeDAgPSBjb25maWcub2Zmc2V0ID8gcG9pbnQwLnggKyBwYXJhbXMuY2VsbFdpZHRoICogMC41IDogcG9pbnQwLng7IC8vZmluZHMgaXRlbXMgd2l0aCBkYXRhIChleGNsdWRlcyBzY2FsZSB1bml0cylcblxuXHQgICAgICBpdGVtcyA9IFtdO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzMiA9IHRoaXMuX2dldFBvaW50WShkYXRhW2ldLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zKTtcblxuXHQgICAgICAgIGlmIChyZXMyIHx8IHJlczIgPT0gXCIwXCIpIHtcblx0ICAgICAgICAgIHgyID0gIWkgPyB4MCA6IHBhcmFtcy5jZWxsV2lkdGggKiBpIC0gMC41ICsgeDA7XG5cdCAgICAgICAgICB5MiA9IF90eXBlb2YocmVzMikgPT0gXCJvYmplY3RcIiA/IHJlczIueTAgOiByZXMyO1xuXG5cdCAgICAgICAgICBpZiAoaSAmJiB0aGlzLl9zZXR0aW5ncy5maXhPdmVyZmxvdykge1xuXHQgICAgICAgICAgICByZXMxID0gdGhpcy5fZ2V0UG9pbnRZKGRhdGFbaSAtIDFdLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICBpZiAocmVzMS5vdXQgJiYgcmVzMS5vdXQgPT0gcmVzMi5vdXQpIHtcblx0ICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHgxID0gcGFyYW1zLmNlbGxXaWR0aCAqIChpIC0gMSkgLSAwLjUgKyB4MDtcblx0ICAgICAgICAgICAgeTEgPSBfdHlwZW9mKHJlczEpID09IFwib2JqZWN0XCIgPyByZXMxLnkwIDogcmVzMTtcblxuXHQgICAgICAgICAgICBpZiAocmVzMS5vdXQpIHtcblx0ICAgICAgICAgICAgICB5MCA9IHJlczEub3V0ID09IFwibWluXCIgPyBwb2ludDEueSA6IHBvaW50MC55O1xuXHQgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgeDogdGhpcy5fY2FsY092ZXJmbG93WCh4MSwgeDIsIHkxLCB5MiwgeTApLFxuXHQgICAgICAgICAgICAgICAgeTogeTBcblx0ICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChyZXMyLm91dCkge1xuXHQgICAgICAgICAgICAgIHkwID0gcmVzMi5vdXQgPT0gXCJtaW5cIiA/IHBvaW50MS55IDogcG9pbnQwLnk7XG5cdCAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICB4OiB0aGlzLl9jYWxjT3ZlcmZsb3dYKHgxLCB4MiwgeTEsIHkyLCB5MCksXG5cdCAgICAgICAgICAgICAgICB5OiB5MFxuXHQgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICghcmVzMi5vdXQpIGl0ZW1zLnB1c2goe1xuXHQgICAgICAgICAgICB4OiB4Mixcblx0ICAgICAgICAgICAgeTogcmVzMixcblx0ICAgICAgICAgICAgaW5kZXg6IGlcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX21hcFN0YXJ0ID0gcG9pbnQwO1xuXG5cdCAgICAgIGZvciAoaSA9IDE7IGkgPD0gaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAvL2xpbmUgc3RhcnQgcG9zaXRpb25cblx0ICAgICAgICB4MSA9IGl0ZW1zW2kgLSAxXS54O1xuXHQgICAgICAgIHkxID0gaXRlbXNbaSAtIDFdLnk7XG5cblx0ICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgLy9saW5lIGVuZCBwb3NpdGlvblxuXHQgICAgICAgICAgeDIgPSBpdGVtc1tpXS54O1xuXHQgICAgICAgICAgeTIgPSBpdGVtc1tpXS55OyAvL2xpbmVcblxuXHQgICAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB4MSwgeTEsIHgyLCB5MiwgY29uZmlnLmxpbmUuY29sb3IuY2FsbCh0aGlzLCBkYXRhW2kgLSAxXSksIGNvbmZpZy5saW5lLndpZHRoKTsgLy9saW5lIHNoYWRvd1xuXG5cblx0ICAgICAgICAgIGlmIChjb25maWcubGluZSAmJiBjb25maWcubGluZS5zaGFkb3cpIHtcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgeDEgKyAyLCB5MSArIGNvbmZpZy5saW5lLndpZHRoICsgOCwgeDIgKyAyLCB5MiArIGNvbmZpZy5saW5lLndpZHRoICsgOCwgXCIjZWVlZWVlXCIsIGNvbmZpZy5saW5lLndpZHRoICsgMyk7XG5cblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IC8vaXRlbVxuXG5cblx0ICAgICAgICBpZiAodHlwZW9mIGl0ZW1zW2kgLSAxXS5pbmRleCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICB0aGlzLl9kcmF3SXRlbShjdHgsIHgxLCB5MSwgZGF0YVtpdGVtc1tpIC0gMV0uaW5kZXhdLCBjb25maWcubGFiZWwoZGF0YVtpdGVtc1tpIC0gMV0uaW5kZXhdKSwgc0luZGV4LCBtYXAsIHBvaW50MCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2FsY092ZXJmbG93WDogZnVuY3Rpb24gKHgxLCB4MiwgeTEsIHkyLCB5KSB7XG5cdCAgICByZXR1cm4geDEgKyAoeSAtIHkxKSAqICh4MiAtIHgxKSAvICh5MiAtIHkxKTtcblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgKiAgIGRyYXdzIGFuIGl0ZW0gYW5kIGl0cyBsYWJlbFxuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiB4MCAtIHRoZSB4IHBvc2l0aW9uIG9mIGEgY2lyY2xlXG5cdCAgKiAgIEBwYXJhbTogeTAgLSB0aGUgeSBwb3NpdGlvbiBvZiBhIGNpcmNsZVxuXHQgICogICBAcGFyYW06IG9iaiAtIGRhdGEgb2JqZWN0XG5cdCAgKiAgIEBwYXJhbTogbGFiZWwgLSAoYm9vbGVhbikgZGVmaW5lcyB3aGVyZXRoZXIgbGFiZWwgbmVlZHMgYmVpbmcgZHJhd25cblx0ICAqL1xuXHQgIF9kcmF3SXRlbTogZnVuY3Rpb24gKGN0eCwgeDAsIHkwLCBvYmosIGxhYmVsLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzLml0ZW07XG5cdCAgICB2YXIgUiA9IHBhcnNlSW50KGNvbmZpZy5yYWRpdXMuY2FsbCh0aGlzLCBvYmopLCAxMCkgfHwgMDtcblx0ICAgIHZhciBtYXBTdGFydCA9IHRoaXMuX21hcFN0YXJ0O1xuXHQgICAgdmFyIGl0ZW0gPSBjb25maWcudHlwZS5jYWxsKHRoaXMsIG9iaik7XG5cblx0ICAgIGlmIChSKSB7XG5cdCAgICAgIGN0eC5zYXZlKCk7XG5cblx0ICAgICAgaWYgKGNvbmZpZy5zaGFkb3cpIHtcblx0ICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcblx0ICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNiZGJkYmRcIjtcblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gXCIjYmRiZGJkXCI7XG5cdCAgICAgICAgdmFyIGFscGhhcyA9IFswLjEsIDAuMiwgMC4zXTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSBhbHBoYXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhc1tpXTtcblx0ICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiI2QwZDBkMFwiO1xuXHQgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG5cdCAgICAgICAgICB0aGlzLl9zdHJva2VDaGFydEl0ZW0oY3R4LCB4MCwgeTAgKyAyICogUiAvIDMsIFIgKyBpICsgMSwgaXRlbSk7XG5cblx0ICAgICAgICAgIGN0eC5zdHJva2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zO1xuXHQgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiNiZGJkYmRcIjtcblxuXHQgICAgICAgIHRoaXMuX3N0cm9rZUNoYXJ0SXRlbShjdHgsIHgwLCB5MCArIDIgKiBSIC8gMywgUiArIDEsIGl0ZW0pO1xuXG5cdCAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGN0eC5yZXN0b3JlKCk7XG5cdCAgICAgIGN0eC5saW5lV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGg7XG5cdCAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3IuY2FsbCh0aGlzLCBvYmopO1xuXHQgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuYm9yZGVyQ29sb3IuY2FsbCh0aGlzLCBvYmopO1xuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBjb25maWcuYWxwaGEuY2FsbCh0aGlzLCBvYmopO1xuXHQgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblx0ICAgICAgdGhpcy5fc3Ryb2tlQ2hhcnRJdGVtKGN0eCwgeDAsIHkwLCBSICsgMSwgaXRlbSk7XG5cblx0ICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgY3R4LnN0cm9rZSgpO1xuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHQgICAgfVxuXHQgICAgLyppdGVtIGxhYmVsKi9cblxuXG5cdCAgICBpZiAobGFiZWwpIHtcblx0ICAgICAgdGhpcy5jYW52YXNlc1tzSW5kZXhdLnJlbmRlclRleHRBdChmYWxzZSwgdHJ1ZSwgeDAsIHkwIC0gUiAtIHRoaXMuX3NldHRpbmdzLmxhYmVsT2Zmc2V0LCB0aGlzLl9zZXR0aW5ncy5sYWJlbC5jYWxsKHRoaXMsIG9iaikpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobWFwKSB7XG5cdCAgICAgIHZhciBhcmVhUG9zID0gdGhpcy5fc2V0dGluZ3MuZXZlbnRSYWRpdXMgfHwgUiArIDE7IC8vdGhpcy5fYWRkTWFwUmVjdChtYXAsb2JqLmlkLFt7eDp4MC1hcmVhUG9zLHk6eTAtYXJlYVBvc30se3gwK2FyZWFQb3MseTp5MCthcmVhUG9zfV0scG9pbnQwLHNJbmRleCk7XG5cblx0ICAgICAgbWFwLmFkZFJlY3Qob2JqLmlkLCBbeDAgLSBhcmVhUG9zIC0gbWFwU3RhcnQueCwgeTAgLSBhcmVhUG9zIC0gbWFwU3RhcnQueSwgeDAgKyBhcmVhUG9zIC0gbWFwU3RhcnQueCwgeTAgKyBhcmVhUG9zIC0gbWFwU3RhcnQueV0sIHNJbmRleCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfc3Ryb2tlQ2hhcnRJdGVtOiBmdW5jdGlvbiAoY3R4LCB4MCwgeTAsIFIsIHR5cGUpIHtcblx0ICAgIHZhciBwID0gW107XG5cblx0ICAgIGlmICh0eXBlICYmICh0eXBlID09IFwic3F1YXJlXCIgfHwgdHlwZSA9PSBcInNcIikpIHtcblx0ICAgICAgUiAqPSBNYXRoLnNxcnQoMikgLyAyO1xuXHQgICAgICBwID0gW1t4MCAtIFIgLSBjdHgubGluZVdpZHRoIC8gMiwgeTAgLSBSXSwgW3gwICsgUiwgeTAgLSBSXSwgW3gwICsgUiwgeTAgKyBSXSwgW3gwIC0gUiwgeTAgKyBSXSwgW3gwIC0gUiwgeTAgLSBSXV07XG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgJiYgKHR5cGUgPT0gXCJkaWFtb25kXCIgfHwgdHlwZSA9PSBcImRcIikpIHtcblx0ICAgICAgdmFyIGNvcnIgPSBjdHgubGluZVdpZHRoID4gMSA/IGN0eC5saW5lV2lkdGggKiBNYXRoLnNxcnQoMikgLyA0IDogMDtcblx0ICAgICAgcCA9IFtbeDAsIHkwIC0gUl0sIFt4MCArIFIsIHkwXSwgW3gwLCB5MCArIFJdLCBbeDAgLSBSLCB5MF0sIFt4MCArIGNvcnIsIHkwIC0gUiAtIGNvcnJdXTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZSAmJiAodHlwZSA9PSBcInRyaWFuZ2xlXCIgfHwgdHlwZSA9PSBcInRcIikpIHtcblx0ICAgICAgcCA9IFtbeDAsIHkwIC0gUl0sIFt4MCArIE1hdGguc3FydCgzKSAqIFIgLyAyLCB5MCArIFIgLyAyXSwgW3gwIC0gTWF0aC5zcXJ0KDMpICogUiAvIDIsIHkwICsgUiAvIDJdLCBbeDAsIHkwIC0gUl1dO1xuXHQgICAgfSBlbHNlIHAgPSBbW3gwLCB5MCwgUiwgMCwgTWF0aC5QSSAqIDIsIHRydWVdXTtcblxuXHQgICAgdGhpcy5fcGF0aChjdHgsIHApO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgZ2V0cyB0aGUgdmVydGljYWwgcG9zaXRpb24gb2YgdGhlIGl0ZW1cblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gZGF0YSBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiB5MCAtIHRoZSB5IHBvc2l0aW9uIG9mIGNoYXJ0IHN0YXJ0XG5cdCAgKiAgIEBwYXJhbTogeTEgLSB0aGUgeSBwb3NpdGlvbiBvZiBjaGFydCBlbmRcblx0ICAqICAgQHBhcmFtOiBwYXJhbXMgLSB0aGUgb2JqZWN0IHdpdGggZWxlbWVudHM6IG1pblZhbHVlLCBtYXhWYWx1ZSwgdW5pdCwgdmFsdWVGYWN0b3IgKHRoZSB2YWx1ZSBtdWx0aXBsZSBvZiAxMClcblx0ICAqL1xuXHQgIF9nZXRQb2ludFk6IGZ1bmN0aW9uIChkYXRhLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zKSB7XG5cdCAgICB2YXIgbWluVmFsdWUgPSBwYXJhbXMubWluVmFsdWU7XG5cdCAgICB2YXIgbWF4VmFsdWUgPSBwYXJhbXMubWF4VmFsdWU7XG5cdCAgICB2YXIgdW5pdCA9IHBhcmFtcy51bml0O1xuXHQgICAgdmFyIHZhbHVlRmFjdG9yID0gcGFyYW1zLnZhbHVlRmFjdG9yO1xuXHQgICAgLyp0aGUgcmVhbCB2YWx1ZSBvZiBhbiBvYmplY3QqL1xuXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLl9zZXR0aW5ncy52YWx1ZShkYXRhKTtcblxuXHQgICAgaWYgKHRoaXMuX2xvZ1NjYWxlQ2FsYykge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMuX2xvZzEwKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8qYSByZWxhdGl2ZSB2YWx1ZSovXG5cblxuXHQgICAgdmFyIHYgPSAocGFyc2VGbG9hdCh2YWx1ZSB8fCAwKSAtIG1pblZhbHVlKSAqIHZhbHVlRmFjdG9yO1xuXHQgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy55QXhpcykgdiArPSBwYXJhbXMuc3RhcnRWYWx1ZSAvIHVuaXQ7XG5cdCAgICAvKmEgdmVydGljYWwgY29vcmRpbmF0ZSovXG5cblx0ICAgIHZhciB5ID0gcG9pbnQxLnkgLSB1bml0ICogdjtcblx0ICAgIC8qdGhlIGxpbWl0IG9mIHRoZSBtYXggYW5kIG1pbiB2YWx1ZXMqL1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZml4T3ZlcmZsb3cgJiYgKHRoaXMuX3NldHRpbmdzLnR5cGUgPT0gXCJsaW5lXCIgfHwgdGhpcy5fc2V0dGluZ3MudHlwZSA9PSBcImFyZWFcIikpIHtcblx0ICAgICAgaWYgKHZhbHVlID4gbWF4VmFsdWUpIHkgPSB7XG5cdCAgICAgICAgeTogcG9pbnQwLnksXG5cdCAgICAgICAgeTA6IHksXG5cdCAgICAgICAgb3V0OiBcIm1heFwiXG5cdCAgICAgIH07ZWxzZSBpZiAodiA8IDAgfHwgdmFsdWUgPCBtaW5WYWx1ZSkgeSA9IHtcblx0ICAgICAgICB5OiBwb2ludDEueSxcblx0ICAgICAgICB5MDogeSxcblx0ICAgICAgICBvdXQ6IFwibWluXCJcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB5ID0gcG9pbnQwLnk7XG5cdCAgICAgIGlmICh2IDwgMCB8fCB2YWx1ZSA8IG1pblZhbHVlKSB5ID0gcG9pbnQxLnk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB5O1xuXHQgIH0sXG5cdCAgX2NhbGN1bGF0ZUxpbmVQYXJhbXM6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgpIHtcblx0ICAgIHZhciBwYXJhbXMgPSB7fTtcblx0ICAgIC8qbWF4VmFsdWUgLSBtaW5WYWx1ZSovXG5cblx0ICAgIHZhciByZWxWYWx1ZTtcblx0ICAgIC8qYXZhaWxhYmxlIGhlaWdodCovXG5cblx0ICAgIHBhcmFtcy50b3RhbEhlaWdodCA9IHBvaW50MS55IC0gcG9pbnQwLnk7XG5cdCAgICAvKmEgc3BhY2UgYXZhaWxhYmxlIGZvciBhIHNpbmdsZSBpdGVtKi9cblx0ICAgIC8vcGFyYW1zLmNlbGxXaWR0aCA9IE1hdGgucm91bmQoKHBvaW50MS54LXBvaW50MC54KS8oKCF0aGlzLl9zZXR0aW5ncy5vZmZzZXQmJnRoaXMuX3NldHRpbmdzLnlBeGlzKT8oZGF0YS5sZW5ndGgtMSk6ZGF0YS5sZW5ndGgpKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNlbGxXaWR0aCkgcGFyYW1zLmNlbGxXaWR0aCA9IE1hdGgubWluKHBvaW50MS54IC0gcG9pbnQwLngsIHRoaXMuX3NldHRpbmdzLmNlbGxXaWR0aCk7ZWxzZSBwYXJhbXMuY2VsbFdpZHRoID0gKHBvaW50MS54IC0gcG9pbnQwLngpIC8gKCF0aGlzLl9zZXR0aW5ncy5vZmZzZXQgPyBkYXRhLmxlbmd0aCAtIDEgOiBkYXRhLmxlbmd0aCk7XG5cdCAgICAvKnNjYWxlcyovXG5cblx0ICAgIHZhciB5YXggPSAhIXRoaXMuX3NldHRpbmdzLnlBeGlzO1xuXHQgICAgdmFyIGxpbWl0cyA9IHRoaXMuX3NldHRpbmdzLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIikgIT0gLTEgPyB0aGlzLl9nZXRTdGFja2VkTGltaXRzKGRhdGEpIDogdGhpcy5fZ2V0TGltaXRzKCk7XG5cdCAgICBwYXJhbXMubWF4VmFsdWUgPSBsaW1pdHMubWF4O1xuXHQgICAgcGFyYW1zLm1pblZhbHVlID0gbGltaXRzLm1pbjtcblx0ICAgIC8qZHJhd3MgeCBhbmQgeSBzY2FsZXMqL1xuXG5cdCAgICBpZiAoIXNJbmRleCkgdGhpcy5fZHJhd1NjYWxlcyhkYXRhLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zLm1pblZhbHVlLCBwYXJhbXMubWF4VmFsdWUsIHBhcmFtcy5jZWxsV2lkdGgpO1xuXHQgICAgLypuZWNlc3NhcnkgZm9yIGF1dG9tYXRpYyBzY2FsZSovXG5cblx0ICAgIGlmICh5YXgpIHtcblx0ICAgICAgcGFyYW1zLm1heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLl9zZXR0aW5ncy55QXhpcy5lbmQpO1xuXHQgICAgICBwYXJhbXMubWluVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIC8qdW5pdCBjYWxjdWxhdGlvbiAoeV9wb3NpdGlvbiA9IHZhbHVlKnVuaXQpKi9cblxuXG5cdCAgICB2YXIgcmVsYXRpdmVWYWx1ZXMgPSB0aGlzLl9nZXRSZWxhdGl2ZVZhbHVlKHBhcmFtcy5taW5WYWx1ZSwgcGFyYW1zLm1heFZhbHVlKTtcblxuXHQgICAgcmVsVmFsdWUgPSByZWxhdGl2ZVZhbHVlc1swXTtcblx0ICAgIHBhcmFtcy52YWx1ZUZhY3RvciA9IHJlbGF0aXZlVmFsdWVzWzFdO1xuXHQgICAgcGFyYW1zLnVuaXQgPSByZWxWYWx1ZSA/IHBhcmFtcy50b3RhbEhlaWdodCAvIHJlbFZhbHVlIDogMTA7XG5cdCAgICBwYXJhbXMuc3RhcnRWYWx1ZSA9IDA7XG5cblx0ICAgIGlmICgheWF4KSB7XG5cdCAgICAgIC8qZGVmaW5lcyBzdGFydCB2YWx1ZSBmb3IgYmV0dGVyIHJlcHJlc2VudGF0aW9uIG9mIHNtYWxsIHZhbHVlcyovXG5cdCAgICAgIHBhcmFtcy5zdGFydFZhbHVlID0gMTA7XG5cdCAgICAgIGlmIChwYXJhbXMudW5pdCAhPSBwYXJhbXMudG90YWxIZWlnaHQpIHBhcmFtcy51bml0ID0gcmVsVmFsdWUgPyAocGFyYW1zLnRvdGFsSGVpZ2h0IC0gcGFyYW1zLnN0YXJ0VmFsdWUpIC8gcmVsVmFsdWUgOiAxMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBhcmFtcztcblx0ICB9XG5cdH07XG5cblx0dmFyIEJhckhDaGFydCA9IHtcblx0ICAvKipcblx0ICAqICAgcmVuZGVycyBhIGJhciBjaGFydFxuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgKiAgIEBwYXJhbTogeCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogeSAtIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuXHQgICogICBAcGFyYW06IHNJbmRleCAtIGluZGV4IG9mIGRyYXdpbmcgY2hhcnRcblx0ICAqL1xuXHQgICRyZW5kZXJfYmFySDogZnVuY3Rpb24gKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIHNJbmRleCwgbWFwKSB7XG5cdCAgICB2YXIgYmFyT2Zmc2V0LCBiYXJXaWR0aCwgY2VsbFdpZHRoLCBjb2xvciwgZ3JhZGllbnQsIGksIGxpbWl0cywgbWF4VmFsdWUsIG1pblZhbHVlLCBpbm5lckdyYWRpZW50LCB2YWx1ZUZhY3RvciwgcmVsVmFsdWUsIHJhZGl1cywgcmVsYXRpdmVWYWx1ZXMsIHN0YXJ0VmFsdWUsIHRvdGFsV2lkdGgsIHZhbHVlLCB1bml0LCB4MCwgeTAsIHhheDtcblx0ICAgIC8qYW4gYXZhaWxhYmxlIHdpZHRoIGZvciBvbmUgYmFyKi9cblxuXHQgICAgY2VsbFdpZHRoID0gKHBvaW50MS55IC0gcG9pbnQwLnkpIC8gZGF0YS5sZW5ndGg7XG5cdCAgICBsaW1pdHMgPSB0aGlzLl9nZXRMaW1pdHMoXCJoXCIpO1xuXHQgICAgbWF4VmFsdWUgPSBsaW1pdHMubWF4O1xuXHQgICAgbWluVmFsdWUgPSBsaW1pdHMubWluO1xuXHQgICAgdG90YWxXaWR0aCA9IHBvaW50MS54IC0gcG9pbnQwLng7XG5cdCAgICB4YXggPSAhIXRoaXMuX3NldHRpbmdzLnhBeGlzO1xuXHQgICAgLypkcmF3cyB4IGFuZCB5IHNjYWxlcyovXG5cblx0ICAgIGlmICghc0luZGV4KSB0aGlzLl9kcmF3SFNjYWxlcyhjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIGNlbGxXaWR0aCk7XG5cdCAgICAvKm5lY2Vzc2FyeSBmb3IgYXV0b21hdGljIHNjYWxlKi9cblxuXHQgICAgaWYgKHhheCkge1xuXHQgICAgICBtYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MueEF4aXMuZW5kKTtcblx0ICAgICAgbWluVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX3NldHRpbmdzLnhBeGlzLnN0YXJ0KTtcblx0ICAgIH1cblx0ICAgIC8qdW5pdCBjYWxjdWxhdGlvbiAoYmFyX2hlaWdodCA9IHZhbHVlKnVuaXQpKi9cblxuXG5cdCAgICByZWxhdGl2ZVZhbHVlcyA9IHRoaXMuX2dldFJlbGF0aXZlVmFsdWUobWluVmFsdWUsIG1heFZhbHVlKTtcblx0ICAgIHJlbFZhbHVlID0gcmVsYXRpdmVWYWx1ZXNbMF07XG5cdCAgICB2YWx1ZUZhY3RvciA9IHJlbGF0aXZlVmFsdWVzWzFdO1xuXHQgICAgdW5pdCA9IHJlbFZhbHVlID8gdG90YWxXaWR0aCAvIHJlbFZhbHVlIDogMTA7XG5cblx0ICAgIGlmICgheGF4KSB7XG5cdCAgICAgIC8qZGVmaW5lcyBzdGFydCB2YWx1ZSBmb3IgYmV0dGVyIHJlcHJlc2VudGF0aW9uIG9mIHNtYWxsIHZhbHVlcyovXG5cdCAgICAgIHN0YXJ0VmFsdWUgPSAxMDtcblx0ICAgICAgdW5pdCA9IHJlbFZhbHVlID8gKHRvdGFsV2lkdGggLSBzdGFydFZhbHVlKSAvIHJlbFZhbHVlIDogMTA7XG5cdCAgICB9XG5cdCAgICAvKmEgcmVhbCBiYXIgd2lkdGggKi9cblxuXG5cdCAgICBiYXJXaWR0aCA9IHBhcnNlSW50KHRoaXMuX3NldHRpbmdzLmJhcldpZHRoLCAxMCk7XG5cdCAgICBpZiAoYmFyV2lkdGggKiB0aGlzLl9zZXJpZXMubGVuZ3RoICsgNCA+IGNlbGxXaWR0aCkgYmFyV2lkdGggPSBjZWxsV2lkdGggLyB0aGlzLl9zZXJpZXMubGVuZ3RoIC0gNDtcblx0ICAgIC8qdGhlIGhhbGYgb2YgZGlzdGFuY2UgYmV0d2VlbiBiYXJzKi9cblxuXHQgICAgYmFyT2Zmc2V0ID0gTWF0aC5mbG9vcigoY2VsbFdpZHRoIC0gYmFyV2lkdGggKiB0aGlzLl9zZXJpZXMubGVuZ3RoKSAvIDIpO1xuXHQgICAgLyp0aGUgcmFkaXVzIG9mIHJvdW5kaW5nIGluIHRoZSB0b3AgcGFydCBvZiBlYWNoIGJhciovXG5cblx0ICAgIHJhZGl1cyA9IHR5cGVvZiB0aGlzLl9zZXR0aW5ncy5yYWRpdXMgIT0gXCJ1bmRlZmluZWRcIiA/IHBhcnNlSW50KHRoaXMuX3NldHRpbmdzLnJhZGl1cywgMTApIDogTWF0aC5yb3VuZChiYXJXaWR0aCAvIDUpO1xuXHQgICAgaW5uZXJHcmFkaWVudCA9IGZhbHNlO1xuXHQgICAgZ3JhZGllbnQgPSB0aGlzLl9zZXR0aW5ncy5ncmFkaWVudDtcblxuXHQgICAgaWYgKGdyYWRpZW50ICYmIHR5cGVvZiBncmFkaWVudCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0ICAgICAgaW5uZXJHcmFkaWVudCA9IGdyYWRpZW50O1xuXHQgICAgICBncmFkaWVudCA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIGlmIChncmFkaWVudCkge1xuXHQgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwb2ludDAueCwgcG9pbnQwLnksIHBvaW50MS54LCBwb2ludDAueSk7XG5cblx0ICAgICAgdGhpcy5fc2V0dGluZ3MuZ3JhZGllbnQoZ3JhZGllbnQpO1xuXHQgICAgfVxuXHQgICAgLypkcmF3cyBhIGJsYWNrIGxpbmUgaWYgdGhlIGhvcml6b250YWwgc2NhbGUgaXNuJ3QgZGVmaW5lZCovXG5cblxuXHQgICAgaWYgKCF4YXgpIHtcblx0ICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCBwb2ludDAueCAtIDAuNSwgcG9pbnQwLnksIHBvaW50MC54IC0gMC41LCBwb2ludDEueSwgXCIjZWRlZmYwXCIsIDEpOyAvL2hhcmRjb2RlZCBjb2xvciFcblxuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MudmFsdWUoZGF0YVtpXSB8fCAwKSk7XG5cdCAgICAgIGlmICh0aGlzLl9sb2dTY2FsZUNhbGMpIHZhbHVlID0gdGhpcy5fbG9nMTAodmFsdWUpO1xuXHQgICAgICBpZiAoIXZhbHVlIHx8IGlzTmFOKHZhbHVlKSkgY29udGludWU7XG5cdCAgICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB2YWx1ZSA9IG1heFZhbHVlO1xuXHQgICAgICB2YWx1ZSAtPSBtaW5WYWx1ZTtcblx0ICAgICAgdmFsdWUgKj0gdmFsdWVGYWN0b3I7XG5cdCAgICAgIC8qc3RhcnQgcG9pbnQgKGJvdHRvbSBsZWZ0KSovXG5cblx0ICAgICAgeDAgPSBwb2ludDAueDtcblx0ICAgICAgeTAgPSBwb2ludDAueSArIGJhck9mZnNldCArIGkgKiBjZWxsV2lkdGggKyAoYmFyV2lkdGggKyAxKSAqIHNJbmRleDtcblxuXHQgICAgICBpZiAodmFsdWUgPCAwICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA9PSBcImF1dG9cIiB8fCB0aGlzLl9zZXR0aW5ncy54QXhpcyAmJiB2YWx1ZSA9PT0gMCAmJiAhKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB0aGlzLl9zZXR0aW5ncy5vcmlnaW4gPiBtaW5WYWx1ZSkpIHtcblx0ICAgICAgICB0aGlzLmNhbnZhc2VzW3NJbmRleF0ucmVuZGVyVGV4dEF0KFwibWlkZGxlXCIsIFwicmlnaHRcIiwgeDAgKyAxMCwgeTAgKyBiYXJXaWR0aCAvIDIgKyBiYXJPZmZzZXQsIHRoaXMuX3NldHRpbmdzLmxhYmVsKGRhdGFbaV0pKTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdGhpcy5fc2V0dGluZ3Mub3JpZ2luICE9IFwiYXV0b1wiICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA+IG1pblZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSAwO1xuXHQgICAgICB9XG5cdCAgICAgIC8qdGFrZXMgc3RhcnQgdmFsdWUgaW50byBjb25zaWRlcmF0aW9uKi9cblxuXG5cdCAgICAgIGlmICgheGF4KSB2YWx1ZSArPSBzdGFydFZhbHVlIC8gdW5pdDtcblx0ICAgICAgY29sb3IgPSBncmFkaWVudCB8fCB0aGlzLl9zZXR0aW5ncy5jb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXHQgICAgICAvKmRyYXdpbmcgdGhlIGdyYWRpZW50IGJvcmRlciBvZiBhIGJhciovXG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmJvcmRlcikge1xuXHQgICAgICAgIHRoaXMuX2RyYXdCYXJIQm9yZGVyKGN0eCwgeDAsIHkwLCBiYXJXaWR0aCwgbWluVmFsdWUsIHJhZGl1cywgdW5pdCwgdmFsdWUsIGNvbG9yKTtcblx0ICAgICAgfVxuXHQgICAgICAvKmRyYXdpbmcgYmFyIGJvZHkqL1xuXG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fc2V0dGluZ3MuYWxwaGEuY2FsbCh0aGlzLCBkYXRhW2ldKTtcblxuXHQgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fZHJhd0JhckgoY3R4LCBwb2ludDEsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciwgZ3JhZGllbnQsIGlubmVyR3JhZGllbnQpO1xuXG5cdCAgICAgIGlmIChpbm5lckdyYWRpZW50KSB7XG5cdCAgICAgICAgdGhpcy5fZHJhd0JhckhHcmFkaWVudChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciwgaW5uZXJHcmFkaWVudCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHQgICAgICAvKnNldHMgYSBiYXIgbGFiZWwgYW5kIG1hcCBhcmVhKi9cblxuXHQgICAgICBpZiAocG9pbnRzWzNdID09IHkwKSB7XG5cdCAgICAgICAgdGhpcy5jYW52YXNlc1tzSW5kZXhdLnJlbmRlclRleHRBdChcIm1pZGRsZVwiLCBcImxlZnRcIiwgcG9pbnRzWzBdIC0gNSwgcG9pbnRzWzNdICsgTWF0aC5mbG9vcihiYXJXaWR0aCAvIDIpLCB0aGlzLl9zZXR0aW5ncy5sYWJlbChkYXRhW2ldKSk7XG5cdCAgICAgICAgbWFwLmFkZFJlY3QoZGF0YVtpXS5pZCwgW3BvaW50c1swXSAtIHBvaW50MC54LCBwb2ludHNbM10gLSBwb2ludDAueSwgcG9pbnRzWzJdIC0gcG9pbnQwLngsIHBvaW50c1szXSArIGJhcldpZHRoIC0gcG9pbnQwLnldLCBzSW5kZXgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuY2FudmFzZXNbc0luZGV4XS5yZW5kZXJUZXh0QXQoXCJtaWRkbGVcIiwgZmFsc2UsIHBvaW50c1syXSArIDUsIHBvaW50c1sxXSArIE1hdGguZmxvb3IoYmFyV2lkdGggLyAyKSwgdGhpcy5fc2V0dGluZ3MubGFiZWwoZGF0YVtpXSkpO1xuXHQgICAgICAgIG1hcC5hZGRSZWN0KGRhdGFbaV0uaWQsIFtwb2ludHNbMF0gLSBwb2ludDAueCwgeTAgLSBwb2ludDAueSwgcG9pbnRzWzJdIC0gcG9pbnQwLngsIHBvaW50c1szXSAtIHBvaW50MC55XSwgc0luZGV4KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIHNldHMgcG9pbnRzIGZvciBiYXIgYW5kIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBib3R0b20gcmlnaHQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICAqICAgQHBhcmFtOiB4MCAtIHRoZSB4IHBvc2l0aW9uIG9mIHN0YXJ0IHBvaW50XG5cdCAgICogICBAcGFyYW06IHkwIC0gdGhlIHkgcG9zaXRpb24gb2Ygc3RhcnQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogYmFyV2lkdGggLSBiYXIgd2lkdGhcblx0ICAgKiAgIEBwYXJhbTogcmFkaXVzIC0gdGhlIHJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgdG9wXG5cdCAgICogICBAcGFyYW06IHVuaXQgLSB0aGUgdmFsdWUgZGVmaW5lcyB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBpdGVtIHZhbHVlIGFuZCBiYXIgaGVpZ2h0XG5cdCAgICogICBAcGFyYW06IHZhbHVlIC0gaXRlbSB2YWx1ZVxuXHQgICAqICAgQHBhcmFtOiBvZmZzZXQgLSB0aGUgb2Zmc2V0IGZyb20gZXhwZWN0ZWQgYmFyIGVkZ2UgKG5lY2Vzc2FyeSBmb3IgZHJhd2luZyBib3JkZXIpXG5cdCAgICovXG5cdCAgX3NldEJhckhQb2ludHM6IGZ1bmN0aW9uIChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIHJhZGl1cywgdW5pdCwgdmFsdWUsIG9mZnNldCwgc2tpcExlZnQpIHtcblx0ICAgIC8qY29ycmVjdGlvbiBmb3IgZGlzcGxhaW5nIHNtYWxsIHZhbHVlcyAod2hlbiByb3VuZGluZyByYWRpdXMgaXMgYmlnZ2VyIHRoYW4gYmFyIGhlaWdodCkqL1xuXHQgICAgdmFyIGFuZ2xlX2NvcnIgPSAwO1xuXG5cdCAgICBpZiAocmFkaXVzID4gdW5pdCAqIHZhbHVlKSB7XG5cdCAgICAgIHZhciBzaW5BID0gKHJhZGl1cyAtIHVuaXQgKiB2YWx1ZSkgLyByYWRpdXM7XG5cdCAgICAgIGFuZ2xlX2NvcnIgPSAtTWF0aC5hc2luKHNpbkEpICsgTWF0aC5QSSAvIDI7XG5cdCAgICB9XG5cdCAgICAvKnN0YXJ0Ki9cblxuXG5cdCAgICBjdHgubW92ZVRvKHgwLCB5MCArIG9mZnNldCk7XG5cdCAgICAvKnN0YXJ0IG9mIGxlZnQgcm91bmRpbmcqL1xuXG5cdCAgICB2YXIgeDEgPSB4MCArIHVuaXQgKiB2YWx1ZSAtIHJhZGl1cyAtIChyYWRpdXMgPyAwIDogb2Zmc2V0KTtcblx0ICAgIHgxID0gTWF0aC5tYXgoeDAsIHgxKTtcblx0ICAgIGlmIChyYWRpdXMgPCB1bml0ICogdmFsdWUpIGN0eC5saW5lVG8oeDEsIHkwICsgb2Zmc2V0KTtcblx0ICAgIC8qbGVmdCByb3VuZGluZyovXG5cblx0ICAgIHZhciB5MiA9IHkwICsgcmFkaXVzO1xuXHQgICAgaWYgKHJhZGl1cyAmJiByYWRpdXMgPiAwKSBjdHguYXJjKHgxLCB5MiwgcmFkaXVzIC0gb2Zmc2V0LCAtTWF0aC5QSSAvIDIgKyBhbmdsZV9jb3JyLCAwLCBmYWxzZSk7XG5cdCAgICAvKnN0YXJ0IG9mIHJpZ2h0IHJvdW5kaW5nKi9cblxuXHQgICAgdmFyIHkzID0geTAgKyBiYXJXaWR0aCAtIHJhZGl1cyAtIChyYWRpdXMgPyAwIDogb2Zmc2V0KTtcblx0ICAgIHZhciB4MyA9IHgxICsgcmFkaXVzIC0gKHJhZGl1cyA/IG9mZnNldCA6IDApO1xuXHQgICAgY3R4LmxpbmVUbyh4MywgeTMpO1xuXHQgICAgLypyaWdodCByb3VuZGluZyovXG5cblx0ICAgIGlmIChyYWRpdXMgJiYgcmFkaXVzID4gMCkgY3R4LmFyYyh4MSwgeTMsIHJhZGl1cyAtIG9mZnNldCwgMCwgTWF0aC5QSSAvIDIgLSBhbmdsZV9jb3JyLCBmYWxzZSk7XG5cdCAgICAvKmJvdHRvbSByaWdodCBwb2ludCovXG5cblx0ICAgIHZhciB5NSA9IHkwICsgYmFyV2lkdGggLSBvZmZzZXQ7XG5cdCAgICBjdHgubGluZVRvKHgwLCB5NSk7XG5cdCAgICAvKmxpbmUgdG8gdGhlIHN0YXJ0IHBvaW50Ki9cblxuXHQgICAgaWYgKCFza2lwTGVmdCkge1xuXHQgICAgICBjdHgubGluZVRvKHgwLCB5MCArIG9mZnNldCk7XG5cdCAgICB9IC8vXHRjdHgubGluZVRvKHgwLDApOyAvL0lFIGZpeCFcblxuXG5cdCAgICByZXR1cm4gW3gzLCB5NV07XG5cdCAgfSxcblx0ICBfZHJhd0hTY2FsZXM6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzdGFydCwgZW5kLCBjZWxsV2lkdGgpIHtcblx0ICAgIHZhciB4ID0gMDtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnhBeGlzKSB7XG5cdCAgICAgIGlmICghdGhpcy5jYW52YXNlc1tcInhcIl0pIHRoaXMuY2FudmFzZXNbXCJ4XCJdID0gdGhpcy5fY3JlYXRlQ2FudmFzKFwiYXhpc194XCIpO1xuXHQgICAgICB4ID0gdGhpcy5fZHJhd0hYQXhpcyh0aGlzLmNhbnZhc2VzW1wieFwiXS5nZXRDYW52YXMoKSwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIHN0YXJ0LCBlbmQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MueUF4aXMpIHtcblx0ICAgICAgaWYgKCF0aGlzLmNhbnZhc2VzW1wieVwiXSkgdGhpcy5jYW52YXNlc1tcInlcIl0gPSB0aGlzLl9jcmVhdGVDYW52YXMoXCJheGlzX3lcIik7XG5cblx0ICAgICAgdGhpcy5fZHJhd0hZQXhpcyh0aGlzLmNhbnZhc2VzW1wieVwiXS5nZXRDYW52YXMoKSwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIGNlbGxXaWR0aCwgeCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZHJhd0hZQXhpczogZnVuY3Rpb24gKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIGNlbGxXaWR0aCwgeUF4aXNYKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnlBeGlzKSByZXR1cm47XG5cdCAgICB2YXIgdW5pdFBvcztcblx0ICAgIHZhciB4MCA9IHBhcnNlSW50KHlBeGlzWCA/IHlBeGlzWCA6IHBvaW50MC54LCAxMCkgLSAwLjU7XG5cdCAgICB2YXIgeTAgPSBwb2ludDEueSArIDAuNTtcblx0ICAgIHZhciB5MSA9IHBvaW50MC55O1xuXG5cdCAgICB0aGlzLl9kcmF3TGluZShjdHgsIHgwLCB5MCwgeDAsIHkxLCB0aGlzLl9zZXR0aW5ncy55QXhpcy5jb2xvciwgMSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvKnNjYWxlIGxhYmVscyovXG5cdCAgICAgIHZhciByaWdodCA9IHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB0aGlzLl9zZXR0aW5ncy50eXBlID09IFwiYmFySFwiICYmIHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MudmFsdWUoZGF0YVtpXSkpIDwgdGhpcy5fc2V0dGluZ3Mub3JpZ2luO1xuXG5cdCAgICAgIHVuaXRQb3MgPSB5MSArIGNlbGxXaWR0aCAvIDIgKyBpICogY2VsbFdpZHRoO1xuXHQgICAgICB0aGlzLmNhbnZhc2VzW1wieVwiXS5yZW5kZXJUZXh0QXQoXCJtaWRkbGVcIiwgcmlnaHQgPyBmYWxzZSA6IFwibGVmdFwiLCByaWdodCA/IHgwICsgNSA6IHgwIC0gNSwgdW5pdFBvcywgdGhpcy5fc2V0dGluZ3MueUF4aXMudGVtcGxhdGUoZGF0YVtpXSksIFwid2ViaXhfYXhpc19pdGVtX3lcIiwgcmlnaHQgPyAwIDogeDAgLSAxMCk7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy55QXhpcy5saW5lcy5jYWxsKHRoaXMsIGRhdGFbaV0pKSB0aGlzLl9kcmF3TGluZShjdHgsIHBvaW50MC54LCB1bml0UG9zLCBwb2ludDEueCwgdW5pdFBvcywgdGhpcy5fc2V0dGluZ3MueUF4aXMubGluZUNvbG9yLmNhbGwodGhpcywgZGF0YVtpXSksIDEpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MueUF4aXMubGluZXMuY2FsbCh0aGlzLCB7fSkpIHRoaXMuX2RyYXdMaW5lKGN0eCwgcG9pbnQwLnggKyAwLjUsIHkxICsgMC41LCBwb2ludDEueCwgeTEgKyAwLjUsIHRoaXMuX3NldHRpbmdzLnlBeGlzLmxpbmVDb2xvci5jYWxsKHRoaXMsIHt9KSwgMSk7XG5cblx0ICAgIHRoaXMuX3NldFlBeGlzVGl0bGUocG9pbnQwLCBwb2ludDEpO1xuXHQgIH0sXG5cdCAgX2RyYXdIWEF4aXM6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzdGFydCwgZW5kKSB7XG5cdCAgICB2YXIgc3RlcDtcblx0ICAgIHZhciBzY2FsZVBhcmFtID0ge307XG5cdCAgICB2YXIgYXhpcyA9IHRoaXMuX3NldHRpbmdzLnhBeGlzO1xuXHQgICAgaWYgKCFheGlzKSByZXR1cm47XG5cdCAgICB2YXIgeTAgPSBwb2ludDEueSArIDAuNTtcblx0ICAgIHZhciB4MCA9IHBvaW50MC54IC0gMC41O1xuXHQgICAgdmFyIHgxID0gcG9pbnQxLnggLSAwLjU7XG5cdCAgICB2YXIgeUF4aXNTdGFydCA9IHBvaW50MC54O1xuXG5cdCAgICB0aGlzLl9kcmF3TGluZShjdHgsIHgwLCB5MCwgeDEsIHkwLCBheGlzLmNvbG9yLCAxKTtcblxuXHQgICAgaWYgKGF4aXMuc3RlcCkgc3RlcCA9IHBhcnNlRmxvYXQoYXhpcy5zdGVwKTtcblxuXHQgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWdYQXhpcy5zdGVwID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHRoaXMuX2NvbmZpZ1hBeGlzLnN0YXJ0ID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHRoaXMuX2NvbmZpZ1hBeGlzLmVuZCA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIHNjYWxlUGFyYW0gPSB0aGlzLl9jYWxjdWxhdGVTY2FsZShzdGFydCwgZW5kKTtcblx0ICAgICAgc3RhcnQgPSBzY2FsZVBhcmFtLnN0YXJ0O1xuXHQgICAgICBlbmQgPSBzY2FsZVBhcmFtLmVuZDtcblx0ICAgICAgc3RlcCA9IHNjYWxlUGFyYW0uc3RlcDtcblx0ICAgICAgdGhpcy5fc2V0dGluZ3MueEF4aXMuZW5kID0gZW5kO1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy54QXhpcy5zdGFydCA9IHN0YXJ0O1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy54QXhpcy5zdGVwID0gc3RlcDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN0ZXAgPT09IDApIHJldHVybjtcblx0ICAgIHZhciBzdGVwSGVpZ2h0ID0gKHgxIC0geDApICogc3RlcCAvIChlbmQgLSBzdGFydCk7XG5cdCAgICB2YXIgYyA9IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkgKz0gc3RlcCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9sb2dTY2FsZUNhbGMgPyBNYXRoLnBvdygxMCwgaSkgOiBpO1xuXHQgICAgICBpZiAoc2NhbGVQYXJhbS5maXhOdW0pIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZChzY2FsZVBhcmFtLmZpeE51bSk7XG5cdCAgICAgIHZhciB4aSA9IE1hdGguZmxvb3IoeDAgKyBjICogc3RlcEhlaWdodCkgKyAwLjU7XG5cdCAgICAgIC8qY2FudmFzIGxpbmUgZml4Ki9cblxuXHQgICAgICBpZiAoIShpID09IHN0YXJ0ICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA9PSBcImF1dG9cIikgJiYgYXhpcy5saW5lcy5jYWxsKHRoaXMsIGkpKSB0aGlzLl9kcmF3TGluZShjdHgsIHhpLCB5MCwgeGksIHBvaW50MC55LCB0aGlzLl9zZXR0aW5ncy54QXhpcy5saW5lQ29sb3IuY2FsbCh0aGlzLCBpKSwgMSk7XG5cdCAgICAgIGlmIChpID09IHRoaXMuX3NldHRpbmdzLm9yaWdpbikgeUF4aXNTdGFydCA9IHhpICsgMTtcblx0ICAgICAgLypjb3JyZWN0aW9uIGZvciBKUyBmbG9hdCBjYWxjdWxhdGlvbiovXG5cblx0ICAgICAgaWYgKHN0ZXAgPCAxICYmICF0aGlzLl9sb2dTY2FsZUNhbGMpIHtcblx0ICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLm1pbihNYXRoLmZsb29yKHRoaXMuX2xvZzEwKHN0ZXApKSwgc3RhcnQgPD0gMCA/IDAgOiBNYXRoLmZsb29yKHRoaXMuX2xvZzEwKHN0YXJ0KSkpO1xuXHQgICAgICAgIHZhciBjb3JyID0gTWF0aC5wb3coMTAsIC1wb3dlcik7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogY29ycikgLyBjb3JyO1xuXHQgICAgICAgIGkgPSB2YWx1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuY2FudmFzZXNbXCJ4XCJdLnJlbmRlclRleHRBdChmYWxzZSwgdHJ1ZSwgeGksIHkwICsgMiwgYXhpcy50ZW1wbGF0ZSh2YWx1ZS50b1N0cmluZygpKSwgXCJ3ZWJpeF9heGlzX2l0ZW1feFwiKTtcblx0ICAgICAgYysrO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbnZhc2VzW1wieFwiXS5yZW5kZXJUZXh0QXQodHJ1ZSwgZmFsc2UsIHgwLCBwb2ludDEueSArIHRoaXMuX3NldHRpbmdzLnBhZGRpbmcuYm90dG9tIC0gMywgdGhpcy5fc2V0dGluZ3MueEF4aXMudGl0bGUsIFwid2ViaXhfYXhpc190aXRsZV94XCIsIHBvaW50MS54IC0gcG9pbnQwLngpO1xuXHQgICAgcmV0dXJuIHlBeGlzU3RhcnQ7XG5cdCAgfSxcblx0ICBfY29ycmVjdEJhckhQYXJhbXM6IGZ1bmN0aW9uIChjdHgsIHgsIHksIHZhbHVlLCB1bml0LCBiYXJXaWR0aCwgbWluVmFsdWUpIHtcblx0ICAgIHZhciB5YXggPSB0aGlzLl9zZXR0aW5ncy55QXhpcztcblx0ICAgIHZhciBheGlzU3RhcnQgPSB4O1xuXG5cdCAgICBpZiAoISF5YXggJiYgdGhpcy5fc2V0dGluZ3Mub3JpZ2luICE9IFwiYXV0b1wiICYmIHRoaXMuX3NldHRpbmdzLm9yaWdpbiA+IG1pblZhbHVlKSB7XG5cdCAgICAgIHggKz0gKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAtIG1pblZhbHVlKSAqIHVuaXQ7XG5cdCAgICAgIGF4aXNTdGFydCA9IHg7XG5cdCAgICAgIHZhbHVlID0gdmFsdWUgLSAodGhpcy5fc2V0dGluZ3Mub3JpZ2luIC0gbWluVmFsdWUpO1xuXG5cdCAgICAgIGlmICh2YWx1ZSA8IDApIHtcblx0ICAgICAgICB2YWx1ZSAqPSAtMTtcblx0ICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkgKyBiYXJXaWR0aCk7XG5cdCAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJKTtcblx0ICAgICAgICB4ID0gMC41O1xuXHQgICAgICAgIHkgPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgeCArPSAwLjU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgeDA6IHgsXG5cdCAgICAgIHkwOiB5LFxuXHQgICAgICBzdGFydDogYXhpc1N0YXJ0XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2RyYXdCYXJIOiBmdW5jdGlvbiAoY3R4LCBwb2ludDEsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvciwgZ3JhZGllbnQsIGlubmVyX2dyYWRpZW50KSB7XG5cdCAgICBjdHguc2F2ZSgpO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX2NvcnJlY3RCYXJIUGFyYW1zKGN0eCwgeDAsIHkwLCB2YWx1ZSwgdW5pdCwgYmFyV2lkdGgsIG1pblZhbHVlKTtcblxuXHQgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHQgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG5cdCAgICB2YXIgcG9pbnRzID0gdGhpcy5fc2V0QmFySFBvaW50cyhjdHgsIHAueDAsIHAueTAsIGJhcldpZHRoLCByYWRpdXMsIHVuaXQsIHAudmFsdWUsIHRoaXMuX3NldHRpbmdzLmJvcmRlciA/IDEgOiAwKTtcblxuXHQgICAgaWYgKGdyYWRpZW50ICYmICFpbm5lcl9ncmFkaWVudCkgY3R4LmxpbmVUbyhwb2ludDEueCwgcC55MCArICh0aGlzLl9zZXR0aW5ncy5ib3JkZXIgPyAxIDogMCkpOyAvL2ZpeCBncmFkaWVudCBzcGhyZWFkaW5nXG5cblx0ICAgIGN0eC5maWxsKCk7XG5cdCAgICBjdHgucmVzdG9yZSgpO1xuXHQgICAgdmFyIHkxID0gcC55MDtcblx0ICAgIHZhciB5MiA9IHAueTAgIT0geTAgPyB5MCA6IHBvaW50c1sxXTtcblx0ICAgIHZhciB4MSA9IHAueTAgIT0geTAgPyBwLnN0YXJ0IC0gcG9pbnRzWzBdIDogcC5zdGFydDtcblx0ICAgIHZhciB4MiA9IHAueTAgIT0geTAgPyBwLnN0YXJ0IDogcG9pbnRzWzBdO1xuXHQgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG5cdCAgfSxcblx0ICBfZHJhd0JhckhCb3JkZXI6IGZ1bmN0aW9uIChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIG1pblZhbHVlLCByYWRpdXMsIHVuaXQsIHZhbHVlLCBjb2xvcikge1xuXHQgICAgY3R4LnNhdmUoKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9jb3JyZWN0QmFySFBhcmFtcyhjdHgsIHgwLCB5MCwgdmFsdWUsIHVuaXQsIGJhcldpZHRoLCBtaW5WYWx1ZSk7XG5cblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgdGhpcy5fc2V0Qm9yZGVyU3R5bGVzKGN0eCwgY29sb3IpO1xuXG5cdCAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjk7XG5cblx0ICAgIHRoaXMuX3NldEJhckhQb2ludHMoY3R4LCBwLngwLCBwLnkwLCBiYXJXaWR0aCwgcmFkaXVzLCB1bml0LCBwLnZhbHVlLCBjdHgubGluZVdpZHRoIC8gMiwgMSk7XG5cblx0ICAgIGN0eC5zdHJva2UoKTtcblx0ICAgIGN0eC5yZXN0b3JlKCk7XG5cdCAgfSxcblx0ICBfZHJhd0JhckhHcmFkaWVudDogZnVuY3Rpb24gKGN0eCwgeDAsIHkwLCBiYXJXaWR0aCwgbWluVmFsdWUsIHJhZGl1cywgdW5pdCwgdmFsdWUsIGNvbG9yLCBpbm5lcl9ncmFkaWVudCkge1xuXHQgICAgY3R4LnNhdmUoKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9jb3JyZWN0QmFySFBhcmFtcyhjdHgsIHgwLCB5MCwgdmFsdWUsIHVuaXQsIGJhcldpZHRoLCBtaW5WYWx1ZSk7XG5cblx0ICAgIHZhciBncmFkUGFyYW0gPSB0aGlzLl9zZXRCYXJHcmFkaWVudChjdHgsIHAueDAsIHAueTAgKyBiYXJXaWR0aCwgcC54MCArIHVuaXQgKiBwLnZhbHVlLCBwLnkwLCBpbm5lcl9ncmFkaWVudCwgY29sb3IsIFwieFwiKTtcblxuXHQgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRQYXJhbS5ncmFkaWVudDtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgdGhpcy5fc2V0QmFySFBvaW50cyhjdHgsIHAueDAsIHAueTAgKyBncmFkUGFyYW0ub2Zmc2V0LCBiYXJXaWR0aCAtIGdyYWRQYXJhbS5vZmZzZXQgKiAyLCByYWRpdXMsIHVuaXQsIHAudmFsdWUsIGdyYWRQYXJhbS5vZmZzZXQpO1xuXG5cdCAgICBjdHguZmlsbCgpO1xuXHQgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0ICAgIGN0eC5yZXN0b3JlKCk7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBTdGFja2VkQmFyQ2hhcnQgPSB7XG5cdCAgLyoqXG5cdCAgKiAgIHJlbmRlcnMgYSBiYXIgY2hhcnRcblx0ICAqICAgQHBhcmFtOiBjdHggLSBjYW52YXMgb2JqZWN0XG5cdCAgKiAgIEBwYXJhbTogZGF0YSAtIG9iamVjdCB0aG9zZSBuZWVkIHRvIGJlIGRpc3BsYXllZFxuXHQgICogICBAcGFyYW06IHggLSB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuXHQgICogICBAcGFyYW06IHkgLSB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXJcblx0ICAqICAgQHBhcmFtOiBzSW5kZXggLSBpbmRleCBvZiBkcmF3aW5nIGNoYXJ0XG5cdCAgKi9cblx0ICAkcmVuZGVyX3N0YWNrZWRCYXI6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIG1heFZhbHVlLCBtaW5WYWx1ZSwgeEF4aXNZLCB4MCwgeTA7XG5cdCAgICAvKm5lY2Vzc2FyeSBpZiBtYXhWYWx1ZSAtIG1pblZhbHVlIDwgMCovXG5cblx0ICAgIHZhciB2YWx1ZUZhY3Rvcjtcblx0ICAgIC8qbWF4VmFsdWUgLSBtaW5WYWx1ZSovXG5cblx0ICAgIHZhciByZWxWYWx1ZTtcblx0ICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHZhciB0b3RhbF9oZWlnaHQgPSBwb2ludDEueSAtIHBvaW50MC55O1xuXHQgICAgdmFyIHlheCA9ICEhY29uZmlnLnlBeGlzO1xuXHQgICAgdmFyIHhheCA9ICEhY29uZmlnLnhBeGlzO1xuXG5cdCAgICB2YXIgbGltaXRzID0gdGhpcy5fZ2V0U3RhY2tlZExpbWl0cyhkYXRhKTtcblxuXHQgICAgdmFyIG9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gPT09IDA7XG5cdCAgICBtYXhWYWx1ZSA9IGxpbWl0cy5tYXg7XG5cdCAgICBtaW5WYWx1ZSA9IGxpbWl0cy5taW47XG5cdCAgICAvKmFuIGF2YWlsYWJsZSB3aWR0aCBmb3Igb25lIGJhciovXG5cblx0ICAgIHZhciBjZWxsV2lkdGggPSBNYXRoLmZsb29yKChwb2ludDEueCAtIHBvaW50MC54KSAvIGRhdGEubGVuZ3RoKTtcblx0ICAgIC8qZHJhd3MgeCBhbmQgeSBzY2FsZXMqL1xuXG5cdCAgICBpZiAoIXNJbmRleCkge1xuXHQgICAgICB4QXhpc1kgPSB0aGlzLl9kcmF3U2NhbGVzKGRhdGEsIHBvaW50MCwgcG9pbnQxLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIGNlbGxXaWR0aCk7XG5cdCAgICB9XG5cdCAgICAvKm5lY2Vzc2FyeSBmb3IgYXV0b21hdGljIHNjYWxlKi9cblxuXG5cdCAgICBpZiAoeWF4KSB7XG5cdCAgICAgIG1heFZhbHVlID0gcGFyc2VGbG9hdChjb25maWcueUF4aXMuZW5kKTtcblx0ICAgICAgbWluVmFsdWUgPSBwYXJzZUZsb2F0KGNvbmZpZy55QXhpcy5zdGFydCk7XG5cdCAgICB9XG5cdCAgICAvKnVuaXQgY2FsY3VsYXRpb24gKGJhcl9oZWlnaHQgPSB2YWx1ZSp1bml0KSovXG5cblxuXHQgICAgdmFyIHJlbGF0aXZlVmFsdWVzID0gdGhpcy5fZ2V0UmVsYXRpdmVWYWx1ZShtaW5WYWx1ZSwgbWF4VmFsdWUpO1xuXG5cdCAgICByZWxWYWx1ZSA9IHJlbGF0aXZlVmFsdWVzWzBdO1xuXHQgICAgdmFsdWVGYWN0b3IgPSByZWxhdGl2ZVZhbHVlc1sxXTtcblx0ICAgIHZhciB1bml0ID0gcmVsVmFsdWUgPyB0b3RhbF9oZWlnaHQgLyByZWxWYWx1ZSA6IDEwO1xuXHQgICAgLyphIHJlYWwgYmFyIHdpZHRoICovXG5cblx0ICAgIHZhciBiYXJXaWR0aCA9IHBhcnNlSW50KGNvbmZpZy5iYXJXaWR0aCwgMTApO1xuXHQgICAgaWYgKGJhcldpZHRoICsgNCA+IGNlbGxXaWR0aCkgYmFyV2lkdGggPSBjZWxsV2lkdGggLSA0O1xuXHQgICAgLyp0aGUgaGFsZiBvZiBkaXN0YW5jZSBiZXR3ZWVuIGJhcnMqL1xuXG5cdCAgICB2YXIgYmFyT2Zmc2V0ID0gTWF0aC5mbG9vcigoY2VsbFdpZHRoIC0gYmFyV2lkdGgpIC8gMik7XG5cdCAgICB2YXIgaW5uZXJfZ3JhZGllbnQgPSBjb25maWcuZ3JhZGllbnQgPyBjb25maWcuZ3JhZGllbnQgOiBmYWxzZTtcblx0ICAgIC8qZHJhd3MgYSBibGFjayBsaW5lIGlmIHRoZSBob3Jpem9udGFsIHNjYWxlIGlzbid0IGRlZmluZWQqL1xuXG5cdCAgICBpZiAoIXhheCkge1xuXHQgICAgICAvL3NjYWxlWSA9IHktYm90dG9tUGFkZGluZztcblx0ICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCBwb2ludDAueCwgcG9pbnQxLnkgKyAwLjUsIHBvaW50MS54LCBwb2ludDEueSArIDAuNSwgXCIjZWRlZmYwXCIsIDEpOyAvL2hhcmRjb2RlZCBjb2xvciFcblxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHZhbHVlID0gTWF0aC5hYnMocGFyc2VGbG9hdChjb25maWcudmFsdWUoZGF0YVtpXSB8fCAwKSkpO1xuXHQgICAgICBpZiAodGhpcy5fbG9nU2NhbGVDYWxjKSB2YWx1ZSA9IHRoaXMuX2xvZzEwKHZhbHVlKTtcblx0ICAgICAgLypzdGFydCBwb2ludCAoYm90dG9tIGxlZnQpKi9cblxuXHQgICAgICB4MCA9IHBvaW50MC54ICsgYmFyT2Zmc2V0ICsgaSAqIGNlbGxXaWR0aDtcblx0ICAgICAgdmFyIG5lZ1ZhbHVlID0gb3JpZ2luICYmIHZhbHVlIDwgMDtcblxuXHQgICAgICBpZiAoIXNJbmRleCkge1xuXHQgICAgICAgIHkwID0geEF4aXNZIC0gMTtcblx0ICAgICAgICBkYXRhW2ldLiRzdGFydFkgPSB5MDtcblxuXHQgICAgICAgIGlmIChvcmlnaW4pIHtcblx0ICAgICAgICAgIGlmIChuZWdWYWx1ZSkgeTAgPSB4QXhpc1kgKyAxO1xuXHQgICAgICAgICAgZGF0YVtpXS4kc3RhcnRZTiA9IHhBeGlzWSArIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHkwID0gbmVnVmFsdWUgPyBkYXRhW2ldLiRzdGFydFlOIDogZGF0YVtpXS4kc3RhcnRZO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCF2YWx1ZSB8fCBpc05hTih2YWx1ZSkpIGNvbnRpbnVlO1xuXHQgICAgICAvKmFkanVzdHMgdGhlIGZpcnN0IHRhYiB0byB0aGUgc2NhbGUqL1xuXG5cdCAgICAgIGlmICghc0luZGV4ICYmICFvcmlnaW4pIHZhbHVlIC09IG1pblZhbHVlO1xuXHQgICAgICB2YWx1ZSAqPSB2YWx1ZUZhY3Rvcjtcblx0ICAgICAgLyp0aGUgbWF4IGhlaWdodCBsaW1pdCovXG5cblx0ICAgICAgaWYgKHkwIDwgcG9pbnQwLnkgKyAxKSBjb250aW51ZTtcblxuXHQgICAgICB2YXIgY29sb3IgPSB0aGlzLl9zZXR0aW5ncy5jb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXG5cdCAgICAgIHZhciBmaXJzdFNlY3RvciA9IE1hdGguYWJzKHkwIC0gKG9yaWdpbiA/IHBvaW50MS55ICsgbWluVmFsdWUgKiB1bml0IDogcG9pbnQxLnkpKSA8IDM7XG5cdCAgICAgIC8qZHJhd2luZyBiYXIgYm9keSovXG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gY29uZmlnLmFscGhhLmNhbGwodGhpcywgZGF0YVtpXSk7XG5cdCAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuY29sb3IuY2FsbCh0aGlzLCBkYXRhW2ldKTtcblx0ICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXHQgICAgICB2YXIgeTEgPSB5MCAtIHVuaXQgKiB2YWx1ZSArIChmaXJzdFNlY3RvciA/IG5lZ1ZhbHVlID8gLTEgOiAxIDogMCk7XG5cblx0ICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3NldFN0YWtlZEJhclBvaW50cyhjdHgsIHgwIC0gKGNvbmZpZy5ib3JkZXIgPyAwLjUgOiAwKSwgeTAsIGJhcldpZHRoICsgKGNvbmZpZy5ib3JkZXIgPyAwLjUgOiAwKSwgeTEsIDAsIHBvaW50MC55KTtcblxuXHQgICAgICBjdHguZmlsbCgpO1xuXHQgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAgIC8qZ3JhZGllbnQqL1xuXG5cdCAgICAgIGlmIChpbm5lcl9ncmFkaWVudCkge1xuXHQgICAgICAgIGN0eC5zYXZlKCk7XG5cblx0ICAgICAgICB2YXIgZ3JhZFBhcmFtID0gdGhpcy5fc2V0QmFyR3JhZGllbnQoY3R4LCB4MCwgeTAsIHgwICsgYmFyV2lkdGgsIHBvaW50c1sxXSwgaW5uZXJfZ3JhZGllbnQsIGNvbG9yLCBcInlcIik7XG5cblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZFBhcmFtLmdyYWRpZW50O1xuXHQgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgICBwb2ludHMgPSB0aGlzLl9zZXRTdGFrZWRCYXJQb2ludHMoY3R4LCB4MCArIGdyYWRQYXJhbS5vZmZzZXQsIHkwLCBiYXJXaWR0aCAtIGdyYWRQYXJhbS5vZmZzZXQgKiAyLCB5MSwgY29uZmlnLmJvcmRlciA/IDEgOiAwLCBwb2ludDAueSk7XG5cdCAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgICBjdHgucmVzdG9yZSgpO1xuXHQgICAgICB9XG5cdCAgICAgIC8qZHJhd2luZyB0aGUgZ3JhZGllbnQgYm9yZGVyIG9mIGEgYmFyKi9cblxuXG5cdCAgICAgIGlmIChjb25maWcuYm9yZGVyKSB7XG5cdCAgICAgICAgY3R4LnNhdmUoKTtcblx0ICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5ib3JkZXIgPT0gXCJzdHJpbmdcIikgY3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLmJvcmRlcjtlbHNlIHRoaXMuX3NldEJvcmRlclN0eWxlcyhjdHgsIGNvbG9yKTtcblx0ICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblx0ICAgICAgICB0aGlzLl9zZXRTdGFrZWRCYXJQb2ludHMoY3R4LCB4MCAtIDAuNSwgcGFyc2VJbnQoeTAsIDEwKSArIDAuNSwgYmFyV2lkdGggKyAxLCBwYXJzZUludCh5MSwgMTApICsgMC41LCAwLCBwb2ludDAueSwgZmlyc3RTZWN0b3IpO1xuXG5cdCAgICAgICAgY3R4LnN0cm9rZSgpO1xuXHQgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHQgICAgICAvKnNldHMgYSBiYXIgbGFiZWwqL1xuXG5cdCAgICAgIHRoaXMuY2FudmFzZXNbc0luZGV4XS5yZW5kZXJUZXh0QXQoZmFsc2UsIHRydWUsIHgwICsgTWF0aC5mbG9vcihiYXJXaWR0aCAvIDIpLCBwb2ludHNbMV0gKyAoeTAgLSBwb2ludHNbMV0pIC8gMiAtIDcsIHRoaXMuX3NldHRpbmdzLmxhYmVsKGRhdGFbaV0pKTtcblx0ICAgICAgLypkZWZpbmVzIGEgbWFwIGFyZWEgZm9yIGEgYmFyKi9cblxuXHQgICAgICBtYXAuYWRkUmVjdChkYXRhW2ldLmlkLCBbeDAgLSBwb2ludDAueCwgcG9pbnRzWzFdIC0gcG9pbnQwLnksIHBvaW50c1swXSAtIHBvaW50MC54LCBkYXRhW2ldW25lZ1ZhbHVlID8gXCIkc3RhcnRZTlwiIDogXCIkc3RhcnRZXCJdIC0gcG9pbnQwLnldLCBzSW5kZXgpO1xuXHQgICAgICAvKnRoZSBzdGFydCBwb3NpdGlvbiBmb3IgdGhlIG5leHQgc2VyaWVzKi9cblxuXHQgICAgICBkYXRhW2ldW25lZ1ZhbHVlID8gXCIkc3RhcnRZTlwiIDogXCIkc3RhcnRZXCJdID0gcG9pbnRzWzFdO1xuXHQgICAgfVxuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiAgIHNldHMgcG9pbnRzIGZvciBiYXIgYW5kIHJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBib3R0b20gcmlnaHQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICAqICAgQHBhcmFtOiB4MCAtIHRoZSB4IHBvc2l0aW9uIG9mIHN0YXJ0IHBvaW50XG5cdCAgICogICBAcGFyYW06IHkwIC0gdGhlIHkgcG9zaXRpb24gb2Ygc3RhcnQgcG9pbnRcblx0ICAgKiAgIEBwYXJhbTogYmFyV2lkdGggLSBiYXIgd2lkdGhcblx0ICAgKiAgIEBwYXJhbTogcmFkaXVzIC0gdGhlIHJvdW5kaW5nIHJhZGl1cyBvZiB0aGUgdG9wXG5cdCAgICogICBAcGFyYW06IHVuaXQgLSB0aGUgdmFsdWUgZGVmaW5lcyB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBpdGVtIHZhbHVlIGFuZCBiYXIgaGVpZ2h0XG5cdCAgICogICBAcGFyYW06IHZhbHVlIC0gaXRlbSB2YWx1ZVxuXHQgICAqICAgQHBhcmFtOiBvZmZzZXQgLSB0aGUgb2Zmc2V0IGZyb20gZXhwZWN0ZWQgYmFyIGVkZ2UgKG5lY2Vzc2FyeSBmb3IgZHJhd2luZyBib3JkZXIpXG5cdCAgICogICBAcGFyYW06IG1pblkgLSB0aGUgbWluaW11bSB5IHBvc2l0aW9uIGZvciB0aGUgYmFycyAoKVxuXHQgICAqL1xuXHQgIF9zZXRTdGFrZWRCYXJQb2ludHM6IGZ1bmN0aW9uIChjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIHkxLCBvZmZzZXQsIG1pblksIHNraXBCb3R0b20pIHtcblx0ICAgIC8qc3RhcnQqL1xuXHQgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuXHQgICAgLyptYXhpbXVtIGhlaWdodCBsaW1pdCovXG5cblx0ICAgIGlmICh5MSA8IG1pblkpIHkxID0gbWluWTtcblx0ICAgIGN0eC5saW5lVG8oeDAsIHkxKTtcblx0ICAgIHZhciB4MyA9IHgwICsgYmFyV2lkdGg7XG5cdCAgICB2YXIgeTMgPSB5MTtcblx0ICAgIGN0eC5saW5lVG8oeDMsIHkzKTtcblx0ICAgIC8qcmlnaHQgcm91bmRpbmcqL1xuXG5cdCAgICAvKmJvdHRvbSByaWdodCBwb2ludCovXG5cblx0ICAgIHZhciB4NSA9IHgwICsgYmFyV2lkdGg7XG5cdCAgICBjdHgubGluZVRvKHg1LCB5MCk7XG5cdCAgICAvKmxpbmUgdG8gdGhlIHN0YXJ0IHBvaW50Ki9cblxuXHQgICAgaWYgKCFza2lwQm90dG9tKSB7XG5cdCAgICAgIGN0eC5saW5lVG8oeDAsIHkwKTtcblx0ICAgIH0gLy9cdGN0eC5saW5lVG8oeDAsMCk7IC8vSUUgZml4IVxuXG5cblx0ICAgIHJldHVybiBbeDUsIHkzXTtcblx0ICB9XG5cdH07XG5cblx0dmFyIFN0YWNrZWRCYXJIQ2hhcnQgPSB7XG5cdCAgLyoqXG5cdCAgXHQqICAgcmVuZGVycyBhIGJhciBjaGFydFxuXHQgIFx0KiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgIFx0KiAgIEBwYXJhbTogZGF0YSAtIG9iamVjdCB0aG9zZSBuZWVkIHRvIGJlIGRpc3BsYXllZFxuXHQgIFx0KiAgIEBwYXJhbTogeCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgXHQqICAgQHBhcmFtOiB5IC0gdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyXG5cdCAgXHQqICAgQHBhcmFtOiBzSW5kZXggLSBpbmRleCBvZiBkcmF3aW5nIGNoYXJ0XG5cdCAgXHQqICAgQHBhcmFtOiBtYXAgLSBtYXAgb2JqZWN0XG5cdCAgXHQqL1xuXHQgICRyZW5kZXJfc3RhY2tlZEJhckg6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIG1heFZhbHVlLCBtaW5WYWx1ZTtcblx0ICAgIC8qbmVjZXNzYXJ5IGlmIG1heFZhbHVlIC0gbWluVmFsdWUgPCAwKi9cblxuXHQgICAgdmFyIHZhbHVlRmFjdG9yO1xuXHQgICAgLyptYXhWYWx1ZSAtIG1pblZhbHVlKi9cblxuXHQgICAgdmFyIHJlbFZhbHVlO1xuXHQgICAgdmFyIHRvdGFsX3dpZHRoID0gcG9pbnQxLnggLSBwb2ludDAueDtcblx0ICAgIHZhciB5YXggPSAhIXRoaXMuX3NldHRpbmdzLnlBeGlzO1xuXG5cdCAgICB2YXIgbGltaXRzID0gdGhpcy5fZ2V0U3RhY2tlZExpbWl0cyhkYXRhKTtcblxuXHQgICAgbWF4VmFsdWUgPSBsaW1pdHMubWF4O1xuXHQgICAgbWluVmFsdWUgPSBsaW1pdHMubWluO1xuXHQgICAgLyphbiBhdmFpbGFibGUgd2lkdGggZm9yIG9uZSBiYXIqL1xuXG5cdCAgICB2YXIgY2VsbFdpZHRoID0gTWF0aC5mbG9vcigocG9pbnQxLnkgLSBwb2ludDAueSkgLyBkYXRhLmxlbmd0aCk7XG5cdCAgICAvKmRyYXdzIHggYW5kIHkgc2NhbGVzKi9cblxuXHQgICAgaWYgKCFzSW5kZXgpIHRoaXMuX2RyYXdIU2NhbGVzKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIG1pblZhbHVlLCBtYXhWYWx1ZSwgY2VsbFdpZHRoKTtcblx0ICAgIC8qbmVjZXNzYXJ5IGZvciBhdXRvbWF0aWMgc2NhbGUqL1xuXG5cdCAgICBpZiAoeWF4KSB7XG5cdCAgICAgIG1heFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLl9zZXR0aW5ncy54QXhpcy5lbmQpO1xuXHQgICAgICBtaW5WYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MueEF4aXMuc3RhcnQpO1xuXHQgICAgfVxuXHQgICAgLyp1bml0IGNhbGN1bGF0aW9uIChiYXJfaGVpZ2h0ID0gdmFsdWUqdW5pdCkqL1xuXG5cblx0ICAgIHZhciByZWxhdGl2ZVZhbHVlcyA9IHRoaXMuX2dldFJlbGF0aXZlVmFsdWUobWluVmFsdWUsIG1heFZhbHVlKTtcblxuXHQgICAgcmVsVmFsdWUgPSByZWxhdGl2ZVZhbHVlc1swXTtcblx0ICAgIHZhbHVlRmFjdG9yID0gcmVsYXRpdmVWYWx1ZXNbMV07XG5cdCAgICB2YXIgdW5pdCA9IHJlbFZhbHVlID8gdG90YWxfd2lkdGggLyByZWxWYWx1ZSA6IDEwO1xuXHQgICAgdmFyIHN0YXJ0VmFsdWUgPSAwO1xuXG5cdCAgICBpZiAoIXlheCkge1xuXHQgICAgICAvKmRlZmluZXMgc3RhcnQgdmFsdWUgZm9yIGJldHRlciByZXByZXNlbnRhdGlvbiBvZiBzbWFsbCB2YWx1ZXMqL1xuXHQgICAgICBzdGFydFZhbHVlID0gMTA7XG5cdCAgICAgIHVuaXQgPSByZWxWYWx1ZSA/ICh0b3RhbF93aWR0aCAtIHN0YXJ0VmFsdWUpIC8gcmVsVmFsdWUgOiAxMDtcblx0ICAgIH1cblx0ICAgIC8qYSByZWFsIGJhciB3aWR0aCAqL1xuXG5cblx0ICAgIHZhciBiYXJXaWR0aCA9IHBhcnNlSW50KHRoaXMuX3NldHRpbmdzLmJhcldpZHRoLCAxMCk7XG5cdCAgICBpZiAoYmFyV2lkdGggKyA0ID4gY2VsbFdpZHRoKSBiYXJXaWR0aCA9IGNlbGxXaWR0aCAtIDQ7XG5cdCAgICAvKnRoZSBoYWxmIG9mIGRpc3RhbmNlIGJldHdlZW4gYmFycyovXG5cblx0ICAgIHZhciBiYXJPZmZzZXQgPSAoY2VsbFdpZHRoIC0gYmFyV2lkdGgpIC8gMjtcblx0ICAgIC8qdGhlIHJhZGl1cyBvZiByb3VuZGluZyBpbiB0aGUgdG9wIHBhcnQgb2YgZWFjaCBiYXIqL1xuXG5cdCAgICB2YXIgcmFkaXVzID0gMDtcblx0ICAgIHZhciBpbm5lcl9ncmFkaWVudCA9IGZhbHNlO1xuXHQgICAgdmFyIGdyYWRpZW50ID0gdGhpcy5fc2V0dGluZ3MuZ3JhZGllbnQ7XG5cblx0ICAgIGlmIChncmFkaWVudCkge1xuXHQgICAgICBpbm5lcl9ncmFkaWVudCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICAvKmRyYXdzIGEgYmxhY2sgbGluZSBpZiB0aGUgaG9yaXpvbnRhbCBzY2FsZSBpc24ndCBkZWZpbmVkKi9cblxuXG5cdCAgICBpZiAoIXlheCkge1xuXHQgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHBvaW50MC54IC0gMC41LCBwb2ludDAueSwgcG9pbnQwLnggLSAwLjUsIHBvaW50MS55LCBcIiNlZGVmZjBcIiwgMSk7IC8vaGFyZGNvZGVkIGNvbG9yIVxuXG5cdCAgICB9XG5cblx0ICAgIHZhciBzZXJpZXNOdW1iZXIgPSAwO1xuXHQgICAgdmFyIHNlcmllc0luZGV4ID0gMDtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3Nlcmllcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoaSA9PSBzSW5kZXgpIHtcblx0ICAgICAgICBzZXJpZXNJbmRleCA9IHNlcmllc051bWJlcjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLl9zZXJpZXNbaV0udHlwZSA9PSBcInN0YWNrZWRCYXJIXCIpIHNlcmllc051bWJlcisrO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKCFzZXJpZXNJbmRleCkgZGF0YVtpXS4kc3RhcnRYID0gcG9pbnQwLng7XG5cdCAgICAgIHZhciB2YWx1ZSA9IE1hdGguYWJzKHBhcnNlRmxvYXQodGhpcy5fc2V0dGluZ3MudmFsdWUoZGF0YVtpXSB8fCAwKSkpO1xuXHQgICAgICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkgdmFsdWUgPSBtYXhWYWx1ZTtcblx0ICAgICAgdmFsdWUgLT0gbWluVmFsdWU7XG5cdCAgICAgIHZhbHVlICo9IHZhbHVlRmFjdG9yO1xuXHQgICAgICAvKnN0YXJ0IHBvaW50IChib3R0b20gbGVmdCkqL1xuXG5cdCAgICAgIHZhciB4MCA9IHBvaW50MC54O1xuXHQgICAgICB2YXIgeTAgPSBwb2ludDAueSArIGJhck9mZnNldCArIGkgKiBjZWxsV2lkdGg7XG5cdCAgICAgIGlmICghc2VyaWVzSW5kZXgpIGRhdGFbaV0uJHN0YXJ0WCA9IHgwO2Vsc2UgeDAgPSBkYXRhW2ldLiRzdGFydFg7XG5cdCAgICAgIGlmICghdmFsdWUgfHwgaXNOYU4odmFsdWUpKSBjb250aW51ZTtcblx0ICAgICAgLyp0YWtlcyBzdGFydCB2YWx1ZSBpbnRvIGNvbnNpZGVyYXRpb24qL1xuXG5cdCAgICAgIGlmICgheWF4KSB2YWx1ZSArPSBzdGFydFZhbHVlIC8gdW5pdDtcblxuXHQgICAgICB2YXIgY29sb3IgPSB0aGlzLl9zZXR0aW5ncy5jb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXHQgICAgICAvKmRyYXdpbmcgYmFyIGJvZHkqL1xuXG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fc2V0dGluZ3MuYWxwaGEuY2FsbCh0aGlzLCBkYXRhW2ldKTtcblx0ICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3NldHRpbmdzLmNvbG9yLmNhbGwodGhpcywgZGF0YVtpXSk7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fc2V0QmFySFBvaW50cyhjdHgsIHgwLCB5MCwgYmFyV2lkdGgsIHJhZGl1cywgdW5pdCwgdmFsdWUsIDApO1xuXG5cdCAgICAgIGlmIChncmFkaWVudCAmJiAhaW5uZXJfZ3JhZGllbnQpIGN0eC5saW5lVG8ocG9pbnQwLnggKyB0b3RhbF93aWR0aCwgeTAgKyAodGhpcy5fc2V0dGluZ3MuYm9yZGVyID8gMSA6IDApKTsgLy9maXggZ3JhZGllbnQgc3BocmVhZGluZ1xuXG5cdCAgICAgIGN0eC5maWxsKCk7XG5cblx0ICAgICAgaWYgKGlubmVyX2dyYWRpZW50KSB7XG5cdCAgICAgICAgdmFyIGdyYWRQYXJhbSA9IHRoaXMuX3NldEJhckdyYWRpZW50KGN0eCwgeDAsIHkwICsgYmFyV2lkdGgsIHgwLCB5MCwgaW5uZXJfZ3JhZGllbnQsIGNvbG9yLCBcInhcIik7XG5cblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZFBhcmFtLmdyYWRpZW50O1xuXHQgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgICBwb2ludHMgPSB0aGlzLl9zZXRCYXJIUG9pbnRzKGN0eCwgeDAsIHkwLCBiYXJXaWR0aCwgcmFkaXVzLCB1bml0LCB2YWx1ZSwgMCk7XG5cdCAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgfVxuXHQgICAgICAvKmRyYXdpbmcgdGhlIGdyYWRpZW50IGJvcmRlciBvZiBhIGJhciovXG5cblxuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuYm9yZGVyKSB7XG5cdCAgICAgICAgdGhpcy5fZHJhd0JhckhCb3JkZXIoY3R4LCB4MCwgeTAsIGJhcldpZHRoLCBtaW5WYWx1ZSwgcmFkaXVzLCB1bml0LCB2YWx1ZSwgY29sb3IpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0ICAgICAgLypzZXRzIGEgYmFyIGxhYmVsKi9cblxuXHQgICAgICB0aGlzLmNhbnZhc2VzW3NJbmRleF0ucmVuZGVyVGV4dEF0KFwibWlkZGxlXCIsIHRydWUsIGRhdGFbaV0uJHN0YXJ0WCArIChwb2ludHNbMF0gLSBkYXRhW2ldLiRzdGFydFgpIC8gMiAtIDEsIHkwICsgKHBvaW50c1sxXSAtIHkwKSAvIDIsIHRoaXMuX3NldHRpbmdzLmxhYmVsKGRhdGFbaV0pKTtcblx0ICAgICAgLypkZWZpbmVzIGEgbWFwIGFyZWEgZm9yIGEgYmFyKi9cblxuXHQgICAgICBtYXAuYWRkUmVjdChkYXRhW2ldLmlkLCBbZGF0YVtpXS4kc3RhcnRYIC0gcG9pbnQwLngsIHkwIC0gcG9pbnQwLnksIHBvaW50c1swXSAtIHBvaW50MC54LCBwb2ludHNbMV0gLSBwb2ludDAueV0sIHNJbmRleCk7XG5cdCAgICAgIC8qdGhlIHN0YXJ0IHBvc2l0aW9uIGZvciB0aGUgbmV4dCBzZXJpZXMqL1xuXG5cdCAgICAgIGRhdGFbaV0uJHN0YXJ0WCA9IHBvaW50c1swXTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIFNwbGluZSQxID0ge1xuXHQgIC8qKlxuXHQgICogICByZW5kZXJzIGEgc3BsaW5lIGNoYXJ0XG5cdCAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICogICBAcGFyYW06IGRhdGEgLSBvYmplY3QgdGhvc2UgbmVlZCB0byBiZSBkaXNwbGF5ZWRcblx0ICAqICAgQHBhcmFtOiB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogc0luZGV4IC0gaW5kZXggb2YgZHJhd2luZyBjaGFydFxuXHQgICovXG5cdCAgJHJlbmRlcl9zcGxpbmU6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIGNvbmZpZywgaSwgaXRlbXMsIGosIHBhcmFtcywgc3BhcmFtLCB4LCB4MCwgeDEsIHgyLCB5LCB5MSwgeTI7XG5cdCAgICBwYXJhbXMgPSB0aGlzLl9jYWxjdWxhdGVMaW5lUGFyYW1zKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIHNJbmRleCk7XG5cdCAgICBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIHRoaXMuX21hcFN0YXJ0ID0gcG9pbnQwO1xuXHQgICAgLyphcnJheSBvZiBhbGwgcG9pbnRzKi9cblxuXHQgICAgaXRlbXMgPSBbXTtcblx0ICAgIC8qZHJhd2luZyBhbGwgaXRlbXMqL1xuXG5cdCAgICBpZiAoZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgLypnZXR0aW5nIGFsbCBwb2ludHMqL1xuXHQgICAgICB4MCA9IGNvbmZpZy5vZmZzZXQgPyBwb2ludDAueCArIHBhcmFtcy5jZWxsV2lkdGggKiAwLjUgOiBwb2ludDAueDtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHkgPSB0aGlzLl9nZXRQb2ludFkoZGF0YVtpXSwgcG9pbnQwLCBwb2ludDEsIHBhcmFtcyk7XG5cblx0ICAgICAgICBpZiAoeSB8fCB5ID09IFwiMFwiKSB7XG5cdCAgICAgICAgICB4ID0gIWkgPyB4MCA6IHBhcmFtcy5jZWxsV2lkdGggKiBpIC0gMC41ICsgeDA7XG5cdCAgICAgICAgICBpdGVtcy5wdXNoKHtcblx0ICAgICAgICAgICAgeDogeCxcblx0ICAgICAgICAgICAgeTogeSxcblx0ICAgICAgICAgICAgdjogdGhpcy5fc2V0dGluZ3MudmFsdWUoZGF0YVtpXSksXG5cdCAgICAgICAgICAgIGluZGV4OiBpXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBzcGFyYW0gPSB0aGlzLl9nZXRTcGxpbmVQYXJhbWV0ZXJzKGl0ZW1zKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB4MSA9IGl0ZW1zW2ldLng7XG5cdCAgICAgICAgeTEgPSBpdGVtc1tpXS55O1xuXG5cdCAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICB4MiA9IGl0ZW1zW2kgKyAxXS54O1xuXHQgICAgICAgICAgeTIgPSBpdGVtc1tpICsgMV0ueTtcblxuXHQgICAgICAgICAgZm9yIChqID0geDE7IGogPCB4MjsgaisrKSB7XG5cdCAgICAgICAgICAgIHZhciBzWTEgPSB0aGlzLl9nZXRTcGxpbmVZUG9pbnQoaiwgeDEsIGksIHNwYXJhbS5hLCBzcGFyYW0uYiwgc3BhcmFtLmMsIHNwYXJhbS5kKTtcblxuXHQgICAgICAgICAgICBpZiAoc1kxIDwgcG9pbnQwLnkpIHNZMSA9IHBvaW50MC55O1xuXHQgICAgICAgICAgICBpZiAoc1kxID4gcG9pbnQxLnkpIHNZMSA9IHBvaW50MS55O1xuXG5cdCAgICAgICAgICAgIHZhciBzWTIgPSB0aGlzLl9nZXRTcGxpbmVZUG9pbnQoaiArIDEsIHgxLCBpLCBzcGFyYW0uYSwgc3BhcmFtLmIsIHNwYXJhbS5jLCBzcGFyYW0uZCk7XG5cblx0ICAgICAgICAgICAgaWYgKHNZMiA8IHBvaW50MC55KSBzWTIgPSBwb2ludDAueTtcblx0ICAgICAgICAgICAgaWYgKHNZMiA+IHBvaW50MS55KSBzWTIgPSBwb2ludDEueTtcblxuXHQgICAgICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIGosIHNZMSwgaiArIDEsIHNZMiwgY29uZmlnLmxpbmUuY29sb3IoZGF0YVtpXSksIGNvbmZpZy5saW5lLndpZHRoKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB4MiAtIDEsIHRoaXMuX2dldFNwbGluZVlQb2ludChqLCB4MSwgaSwgc3BhcmFtLmEsIHNwYXJhbS5iLCBzcGFyYW0uYywgc3BhcmFtLmQpLCB4MiwgeTIsIGNvbmZpZy5saW5lLmNvbG9yKGRhdGFbaV0pLCBjb25maWcubGluZS53aWR0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fZHJhd0l0ZW0oY3R4LCB4MSwgeTEsIGRhdGFbaXRlbXNbaV0uaW5kZXhdLCBjb25maWcubGFiZWwoZGF0YVtpdGVtc1tpXS5pbmRleF0pLCBzSW5kZXgsIG1hcCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgLypnZXRzIHNwbGluZSBwYXJhbWV0ZXIqL1xuXHQgIF9nZXRTcGxpbmVQYXJhbWV0ZXJzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG5cdCAgICB2YXIgYSxcblx0ICAgICAgICBiLFxuXHQgICAgICAgIGMsXG5cdCAgICAgICAgZCxcblx0ICAgICAgICBpLFxuXHQgICAgICAgIHMsXG5cdCAgICAgICAgdSxcblx0ICAgICAgICB2LFxuXHQgICAgICAgIGggPSBbXSxcblx0ICAgICAgICBtID0gW10sXG5cdCAgICAgICAgbiA9IHBvaW50cy5sZW5ndGg7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG5cdCAgICAgIGhbaV0gPSBwb2ludHNbaSArIDFdLnggLSBwb2ludHNbaV0ueDtcblx0ICAgICAgbVtpXSA9IChwb2ludHNbaSArIDFdLnkgLSBwb2ludHNbaV0ueSkgLyBoW2ldO1xuXHQgICAgfVxuXG5cdCAgICB1ID0gW107XG5cdCAgICB2ID0gW107XG5cdCAgICB1WzBdID0gMDtcblx0ICAgIHVbMV0gPSAyICogKGhbMF0gKyBoWzFdKTtcblx0ICAgIHZbMF0gPSAwO1xuXHQgICAgdlsxXSA9IDYgKiAobVsxXSAtIG1bMF0pO1xuXG5cdCAgICBmb3IgKGkgPSAyOyBpIDwgbiAtIDE7IGkrKykge1xuXHQgICAgICB1W2ldID0gMiAqIChoW2kgLSAxXSArIGhbaV0pIC0gaFtpIC0gMV0gKiBoW2kgLSAxXSAvIHVbaSAtIDFdO1xuXHQgICAgICB2W2ldID0gNiAqIChtW2ldIC0gbVtpIC0gMV0pIC0gaFtpIC0gMV0gKiB2W2kgLSAxXSAvIHVbaSAtIDFdO1xuXHQgICAgfVxuXG5cdCAgICBzID0gW107XG5cdCAgICBzW24gLSAxXSA9IHNbMF0gPSAwO1xuXG5cdCAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAxOyBpLS0pIHtcblx0ICAgICAgc1tpXSA9ICh2W2ldIC0gaFtpXSAqIHNbaSArIDFdKSAvIHVbaV07XG5cdCAgICB9XG5cblx0ICAgIGEgPSBbXTtcblx0ICAgIGIgPSBbXTtcblx0ICAgIGMgPSBbXTtcblx0ICAgIGQgPSBbXTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcblx0ICAgICAgYVtpXSA9IHBvaW50c1tpXS55O1xuXHQgICAgICBiW2ldID0gLWhbaV0gKiBzW2kgKyAxXSAvIDYgLSBoW2ldICogc1tpXSAvIDMgKyAocG9pbnRzW2kgKyAxXS55IC0gcG9pbnRzW2ldLnkpIC8gaFtpXTtcblx0ICAgICAgY1tpXSA9IHNbaV0gLyAyO1xuXHQgICAgICBkW2ldID0gKHNbaSArIDFdIC0gc1tpXSkgLyAoNiAqIGhbaV0pO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuXHQgICAgICBpZiAocG9pbnRzW2ldLnYgPT09IDAgJiYgcG9pbnRzW2kgKyAxXS52ID09PSAwKSB7XG5cdCAgICAgICAgYVtpXSA9IHBvaW50c1tpXS55O1xuXHQgICAgICAgIGRbaV0gPSBjW2ldID0gYltpXSA9IDA7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgYTogYSxcblx0ICAgICAgYjogYixcblx0ICAgICAgYzogYyxcblx0ICAgICAgZDogZFxuXHQgICAgfTtcblx0ICB9LFxuXG5cdCAgLypyZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzcGxpbmUgcG9pbnQgKi9cblx0ICBfZ2V0U3BsaW5lWVBvaW50OiBmdW5jdGlvbiAoeCwgeGksIGksIGEsIGIsIGMsIGQpIHtcblx0ICAgIHJldHVybiBhW2ldICsgKHggLSB4aSkgKiAoYltpXSArICh4IC0geGkpICogKGNbaV0gKyAoeCAtIHhpKSAqIGRbaV0pKTtcblx0ICB9XG5cdH07XG5cblx0dmFyIEFyZWFDaGFydCA9IHtcblx0ICAvKipcblx0ICAqICAgcmVuZGVycyBhbiBhcmVhIGNoYXJ0XG5cdCAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICogICBAcGFyYW06IGRhdGEgLSBvYmplY3QgdGhvc2UgbmVlZCB0byBiZSBkaXNwbGF5ZWRcblx0ICAqICAgQHBhcmFtOiB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogc0luZGV4IC0gaW5kZXggb2YgZHJhd2luZyBjaGFydFxuXHQgICovXG5cdCAgJHJlbmRlcl9hcmVhOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4LCBtYXApIHtcblx0ICAgIHZhciBhbGlnbiwgY29uZmlnLCBpLCBtYXBSZWN0LCBvYmosIHBhcmFtcywgcGF0aCwgcmVzMSwgcmVzMiwgeDAsIHgxLCB5MSwgeDIsIHkyLCB5MDtcblx0ICAgIHBhcmFtcyA9IHRoaXMuX2NhbGN1bGF0ZUxpbmVQYXJhbXMoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4KTtcblx0ICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzOyAvL3RoZSBzaXplIG9mIG1hcCBhcmVhXG5cblx0ICAgIG1hcFJlY3QgPSBjb25maWcuZXZlbnRSYWRpdXMgfHwgTWF0aC5mbG9vcihwYXJhbXMuY2VsbFdpZHRoIC8gMik7XG5cblx0ICAgIGlmIChkYXRhLmxlbmd0aCkge1xuXHQgICAgICAvLyBhcmVhIHBvaW50c1xuXHQgICAgICBwYXRoID0gW107IC8vdGhlIHggcG9zaXRpb24gb2YgdGhlIGZpcnN0IGl0ZW1cblxuXHQgICAgICB4MCA9ICFjb25maWcub2Zmc2V0ID8gcG9pbnQwLnggOiBwb2ludDAueCArIHBhcmFtcy5jZWxsV2lkdGggKiAwLjU7XG5cdCAgICAgIC8qXG5cdCAgICAgICBpdGVyYXRlcyBvdmVyIGFsbCBkYXRhIGl0ZW1zOlxuXHQgICAgICAgY2FsY3VsYXRlcyBbeCx5XSBmb3IgYXJlYSBwYXRoLCBhZGRzIHJlY3QgdG8gY2hhcnQgbWFwIGFuZCByZW5kZXJzIGxhYmVsc1xuXHQgICAgICAgKi9cblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIG9iaiA9IGRhdGFbaV07XG5cdCAgICAgICAgcmVzMiA9IHRoaXMuX2dldFBvaW50WShvYmosIHBvaW50MCwgcG9pbnQxLCBwYXJhbXMpO1xuXHQgICAgICAgIHgyID0geDAgKyBwYXJhbXMuY2VsbFdpZHRoICogaTtcblxuXHQgICAgICAgIGlmIChyZXMyKSB7XG5cdCAgICAgICAgICB5MiA9IF90eXBlb2YocmVzMikgPT0gXCJvYmplY3RcIiA/IHJlczIueTAgOiByZXMyO1xuXG5cdCAgICAgICAgICBpZiAoaSAmJiB0aGlzLl9zZXR0aW5ncy5maXhPdmVyZmxvdykge1xuXHQgICAgICAgICAgICByZXMxID0gdGhpcy5fZ2V0UG9pbnRZKGRhdGFbaSAtIDFdLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zKTtcblxuXHQgICAgICAgICAgICBpZiAocmVzMS5vdXQgJiYgcmVzMS5vdXQgPT0gcmVzMi5vdXQpIHtcblx0ICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHgxID0gcGFyYW1zLmNlbGxXaWR0aCAqIChpIC0gMSkgLSAwLjUgKyB4MDtcblx0ICAgICAgICAgICAgeTEgPSBfdHlwZW9mKHJlczEpID09IFwib2JqZWN0XCIgPyByZXMxLnkwIDogcmVzMTtcblxuXHQgICAgICAgICAgICBpZiAocmVzMS5vdXQpIHtcblx0ICAgICAgICAgICAgICB5MCA9IHJlczEub3V0ID09IFwibWluXCIgPyBwb2ludDEueSA6IHBvaW50MC55O1xuXHQgICAgICAgICAgICAgIHBhdGgucHVzaChbdGhpcy5fY2FsY092ZXJmbG93WCh4MSwgeDIsIHkxLCB5MiwgeTApLCB5MF0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHJlczIub3V0KSB7XG5cdCAgICAgICAgICAgICAgeTAgPSByZXMyLm91dCA9PSBcIm1pblwiID8gcG9pbnQxLnkgOiBwb2ludDAueTtcblx0ICAgICAgICAgICAgICBwYXRoLnB1c2goW3RoaXMuX2NhbGNPdmVyZmxvd1goeDEsIHgyLCB5MSwgeTIsIHkwKSwgeTBdKTtcblx0ICAgICAgICAgICAgICBpZiAoaSA9PSBkYXRhLmxlbmd0aCAtIDEgJiYgeTAgPT0gcG9pbnQwLnkpIHBhdGgucHVzaChbeDIsIHBvaW50MC55XSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKCFyZXMyLm91dCkge1xuXHQgICAgICAgICAgICBwYXRoLnB1c2goW3gyLCB5Ml0pOyAvL21hcFxuXG5cdCAgICAgICAgICAgIG1hcC5hZGRSZWN0KG9iai5pZCwgW3gyIC0gbWFwUmVjdCAtIHBvaW50MC54LCB5MiAtIG1hcFJlY3QgLSBwb2ludDAueSwgeDIgKyBtYXBSZWN0IC0gcG9pbnQwLngsIHkyICsgbWFwUmVjdCAtIHBvaW50MC55XSwgc0luZGV4KTtcblx0ICAgICAgICAgIH0gLy9sYWJlbHNcblxuXG5cdCAgICAgICAgICBpZiAoIWNvbmZpZy55QXhpcykge1xuXHQgICAgICAgICAgICBhbGlnbiA9ICFjb25maWcub2Zmc2V0ICYmIGkgPT0gZGF0YS5sZW5ndGggLSAxID8gXCJsZWZ0XCIgOiBcImNlbnRlclwiO1xuXHQgICAgICAgICAgICB0aGlzLmNhbnZhc2VzW3NJbmRleF0ucmVuZGVyVGV4dEF0KGZhbHNlLCBhbGlnbiwgeDIsIHkyIC0gY29uZmlnLmxhYmVsT2Zmc2V0LCBjb25maWcubGFiZWwob2JqKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG5cdCAgICAgICAgcGF0aC5wdXNoKFt4MiwgcG9pbnQxLnldKTtcblx0ICAgICAgICBwYXRoLnB1c2goW3BhdGhbMF1bMF0sIHBvaW50MS55XSk7XG5cdCAgICAgIH0gLy9maWxsaW5nIGFyZWFcblxuXG5cdCAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX3NldHRpbmdzLmFscGhhLmNhbGwodGhpcywgZGF0YVswXSk7XG5cdCAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9zZXR0aW5ncy5jb2xvci5jYWxsKHRoaXMsIGRhdGFbMF0pO1xuXHQgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblx0ICAgICAgdGhpcy5fcGF0aChjdHgsIHBhdGgpO1xuXG5cdCAgICAgIGN0eC5maWxsKCk7XG5cdCAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxOyAvL2JvcmRlclxuXG5cdCAgICAgIGlmIChjb25maWcuYm9yZGVyKSB7XG5cdCAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNvbmZpZy5ib3JkZXJXaWR0aCB8fCAxO1xuXHQgICAgICAgIGlmIChjb25maWcuYm9yZGVyQ29sb3IpIGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5ib3JkZXJDb2xvci5jYWxsKHRoaXMsIGRhdGFbMF0pO2Vsc2UgdGhpcy5fc2V0Qm9yZGVyU3R5bGVzKGN0eCwgY3R4LmZpbGxTdHlsZSk7XG5cdCAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG5cdCAgICAgICAgdGhpcy5fcGF0aChjdHgsIHBhdGgpO1xuXG5cdCAgICAgICAgY3R4LnN0cm9rZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICogICByZW5kZXJzIGFuIGFyZWEgY2hhcnRcblx0ICAqICAgQHBhcmFtOiBjdHggLSBjYW52YXMgb2JqZWN0XG5cdCAgKiAgIEBwYXJhbTogZGF0YSAtIG9iamVjdCB0aG9zZSBuZWVkIHRvIGJlIGRpc3BsYXllZFxuXHQgICogICBAcGFyYW06IHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcblx0ICAqICAgQHBhcmFtOiBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSBjb250YWluZXJcblx0ICAqICAgQHBhcmFtOiBzSW5kZXggLSBpbmRleCBvZiBkcmF3aW5nIGNoYXJ0XG5cdCAgKi9cblx0ICAkcmVuZGVyX3N0YWNrZWRBcmVhOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4LCBtYXApIHtcblx0ICAgIHZhciBhMCwgYTEsIGFsaWduLCBjb25maWcsIGksIGosIGxhc3RJdGVtLCBtYXBSZWN0LCBvYmosIHBhcmFtcywgcGF0aCwgeCwgeSwgeVBvcztcblx0ICAgIHBhcmFtcyA9IHRoaXMuX2NhbGN1bGF0ZUxpbmVQYXJhbXMoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4KTtcblx0ICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgLyp0aGUgdmFsdWUgdGhhdCBkZWZpbmVzIHRoZSBtYXAgYXJlYSBwb3NpdGlvbiovXG5cblx0ICAgIG1hcFJlY3QgPSBjb25maWcuZXZlbnRSYWRpdXMgfHwgTWF0aC5mbG9vcihwYXJhbXMuY2VsbFdpZHRoIC8gMik7XG5cdCAgICAvKmRyYXdpbmcgYWxsIGl0ZW1zKi9cblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgIC8vIGFyZWEgcG9pbnRzXG5cdCAgICAgIHBhdGggPSBbXTsgLy8geSBpdGVtIHBvc2l0aW9uc1xuXG5cdCAgICAgIHlQb3MgPSBbXTsgLy90aGUgeCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgaXRlbVxuXG5cdCAgICAgIHggPSAhY29uZmlnLm9mZnNldCA/IHBvaW50MC54IDogcG9pbnQwLnggKyBwYXJhbXMuY2VsbFdpZHRoICogMC41O1xuXG5cdCAgICAgIHZhciBzZXRPZmZzZXQgPSBmdW5jdGlvbiAoaSwgeSkge1xuXHQgICAgICAgIHJldHVybiBzSW5kZXggPyBkYXRhW2ldLiRzdGFydFkgPyB5IC0gcG9pbnQxLnkgKyBkYXRhW2ldLiRzdGFydFkgOiAwIDogeTtcblx0ICAgICAgfTtcblxuXHQgICAgICB2YXIgc29sdmVFcXVhdGlvbiA9IGZ1bmN0aW9uICh4LCBwMCwgcDEpIHtcblx0ICAgICAgICB2YXIgayA9IChwMS55IC0gcDAueSkgLyAocDEueCAtIHAwLngpO1xuXHQgICAgICAgIHJldHVybiBrICogeCArIHAwLnkgLSBrICogcDAueDtcblx0ICAgICAgfTtcblx0ICAgICAgLypcblx0ICAgICAgIGl0ZXJhdGVzIG92ZXIgYWxsIGRhdGEgaXRlbXM6XG5cdCAgICAgICBjYWxjdWxhdGVzIFt4LHldIGZvciBhcmVhIHBhdGgsIGFkZHMgcmVjdCB0byBjaGFydCBtYXAgYW5kIHJlbmRlcnMgbGFiZWxzXG5cdCAgICAgICAqL1xuXG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBvYmogPSBkYXRhW2ldO1xuXG5cdCAgICAgICAgaWYgKCFpKSB7XG5cdCAgICAgICAgICB5ID0gc2V0T2Zmc2V0KGksIHBvaW50MS55KTtcblx0ICAgICAgICAgIHBhdGgucHVzaChbeCwgeV0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB4ICs9IHBhcmFtcy5jZWxsV2lkdGg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgeSA9IHNldE9mZnNldChpLCB0aGlzLl9nZXRQb2ludFkob2JqLCBwb2ludDAsIHBvaW50MSwgcGFyYW1zKSk7XG5cdCAgICAgICAgeVBvcy5wdXNoKGlzTmFOKHkpICYmICFpID8gZGF0YVtpXS4kc3RhcnRZIHx8IHBvaW50MS55IDogeSk7XG5cblx0ICAgICAgICBpZiAoeSkge1xuXHQgICAgICAgICAgcGF0aC5wdXNoKFt4LCB5XSk7IC8vbWFwXG5cblx0ICAgICAgICAgIG1hcC5hZGRSZWN0KG9iai5pZCwgW3ggLSBtYXBSZWN0IC0gcG9pbnQwLngsIHkgLSBtYXBSZWN0IC0gcG9pbnQwLnksIHggKyBtYXBSZWN0IC0gcG9pbnQwLngsIHkgKyBtYXBSZWN0IC0gcG9pbnQwLnldLCBzSW5kZXgpOyAvL2xhYmVsc1xuXG5cdCAgICAgICAgICBpZiAoIWNvbmZpZy55QXhpcykge1xuXHQgICAgICAgICAgICBhbGlnbiA9ICFjb25maWcub2Zmc2V0ICYmIGxhc3RJdGVtID8gXCJsZWZ0XCIgOiBcImNlbnRlclwiO1xuXHQgICAgICAgICAgICB0aGlzLmNhbnZhc2VzW3NJbmRleF0ucmVuZGVyVGV4dEF0KGZhbHNlLCBhbGlnbiwgeCwgeSAtIGNvbmZpZy5sYWJlbE9mZnNldCwgY29uZmlnLmxhYmVsKG9iaikpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSAvLyBib3R0b20gcmlnaHQgcG9pbnRcblxuXG5cdCAgICAgIHBhdGgucHVzaChbeCwgc2V0T2Zmc2V0KGkgLSAxLCBwb2ludDEueSldKTsgLy8gbG93ZXIgYm9yZGVyIGZyb20gdGhlIGVuZCB0byBzdGFydFxuXG5cdCAgICAgIGlmIChzSW5kZXgpIHtcblx0ICAgICAgICBmb3IgKGkgPSBkYXRhLmxlbmd0aCAtIDI7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICAgIHggLT0gcGFyYW1zLmNlbGxXaWR0aDtcblx0ICAgICAgICAgIHkgPSBkYXRhW2ldLiRzdGFydFk7XG5cdCAgICAgICAgICBpZiAoeSkgcGF0aC5wdXNoKFt4LCB5XSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IC8vIGdvIHRvIHN0YXJ0IHBvaW50XG5cblxuXHQgICAgICBwYXRoLnB1c2goW3BhdGhbMF1bMF0sIHBhdGhbMF1bMV1dKTsgLy8gZmlsbGluZyBwYXRoXG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fc2V0dGluZ3MuYWxwaGEuY2FsbCh0aGlzLCBkYXRhWzBdKTtcblx0ICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3NldHRpbmdzLmNvbG9yLmNhbGwodGhpcywgZGF0YVswXSk7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgICB0aGlzLl9wYXRoKGN0eCwgcGF0aCk7XG5cblx0ICAgICAgY3R4LmZpbGwoKTsgLy8gc2V0IHkgcG9zaXRpb25zIG9mIHRoZSBuZXh0IHNlcmllc1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgeSA9IHlQb3NbaV07XG5cblx0ICAgICAgICBpZiAoIXkpIHtcblx0ICAgICAgICAgIGlmIChpID09IGRhdGEubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgICAgICB5ID0gZGF0YVtpXS4kc3RhcnRZO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgaWYgKHlQb3Nbal0pIHtcblx0ICAgICAgICAgICAgICBhMCA9IHtcblx0ICAgICAgICAgICAgICAgIHg6IHBvaW50MC54LFxuXHQgICAgICAgICAgICAgICAgeTogeVBvc1swXVxuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgYTEgPSB7XG5cdCAgICAgICAgICAgICAgICB4OiBwb2ludDAueCArIHBhcmFtcy5jZWxsV2lkdGggKiBqLFxuXHQgICAgICAgICAgICAgICAgeTogeVBvc1tqXVxuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgeSA9IHNvbHZlRXF1YXRpb24ocG9pbnQwLnggKyBwYXJhbXMuY2VsbFdpZHRoICogaSwgYTAsIGExKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGRhdGFbaV0uJHN0YXJ0WSA9IHk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIFJhZGFyID0ge1xuXHQgICRyZW5kZXJfcmFkYXI6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHgsIHksIHNJbmRleCwgbWFwKSB7XG5cdCAgICB0aGlzLl9yZW5kZXJSYWRhckNoYXJ0KGN0eCwgZGF0YSwgeCwgeSwgc0luZGV4LCBtYXApO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgcmVuZGVycyBhIHBpZSBjaGFydFxuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgKiAgIEBwYXJhbTogeCAtIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogeSAtIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuXHQgICogICBAcGFyYW06IGt5IC0gdmFsdWUgZnJvbSAwIHRvIDEgdGhhdCBkZWZpbmVzIGFuIGFuZ2xlIG9mIGluY2xpbmF0aW9uICgwPGt5PDEgLSAzRCBjaGFydClcblx0ICAqL1xuXHQgIF9yZW5kZXJSYWRhckNoYXJ0OiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4LCBtYXApIHtcblx0ICAgIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcblxuXHQgICAgdmFyIGNvb3JkID0gdGhpcy5fZ2V0UGllUGFyYW1ldGVycyhwb2ludDAsIHBvaW50MSk7XG5cdCAgICAvKnNjYWxlIHJhZGl1cyovXG5cblxuXHQgICAgdmFyIHJhZGl1cyA9IHRoaXMuX3NldHRpbmdzLnJhZGl1cyA/IHRoaXMuX3NldHRpbmdzLnJhZGl1cyA6IGNvb3JkLnJhZGl1cztcblx0ICAgIC8qc2NhbGUgY2VudGVyKi9cblxuXHQgICAgdmFyIHgwID0gdGhpcy5fc2V0dGluZ3MueCA/IHRoaXMuX3NldHRpbmdzLnggOiBjb29yZC54O1xuXHQgICAgdmFyIHkwID0gdGhpcy5fc2V0dGluZ3MueSA/IHRoaXMuX3NldHRpbmdzLnkgOiBjb29yZC55O1xuXHQgICAgLyphbmdsZXMgZm9yIGVhY2ggdW5pdCovXG5cblx0ICAgIHZhciByYXRpb1VuaXRzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByYXRpb1VuaXRzLnB1c2goMSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByYXRpb3MgPSB0aGlzLl9nZXRSYXRpb3MocmF0aW9Vbml0cywgZGF0YS5sZW5ndGgpO1xuXG5cdCAgICB0aGlzLl9tYXBTdGFydCA9IHBvaW50MDtcblx0ICAgIGlmICghc0luZGV4KSB0aGlzLl9kcmF3UmFkYXJBeGlzZXMocmF0aW9zLCB4MCwgeTAsIHJhZGl1cywgZGF0YSk7XG5cblx0ICAgIHRoaXMuX2RyYXdSYWRhckRhdGEoY3R4LCByYXRpb3MsIHgwLCB5MCwgcmFkaXVzLCBkYXRhLCBzSW5kZXgsIG1hcCk7XG5cdCAgfSxcblx0ICBfZHJhd1JhZGFyRGF0YTogZnVuY3Rpb24gKGN0eCwgcmF0aW9zLCB4LCB5LCByYWRpdXMsIGRhdGEsIHNJbmRleCwgbWFwKSB7XG5cdCAgICB2YXIgYWxwaGEwLCBhbHBoYTEsIGNvbmZpZywgaSwgbWluLCBtYXgsIHBvczAsIHBvczEsIHBvc0FyciwgcjAsIHIxLCByZWxWYWx1ZSwgc3RhcnRBbHBoYSwgdmFsdWUsIHZhbHVlMCwgdmFsdWUxLCB2YWx1ZUZhY3RvciwgdW5pdCwgdW5pdEFycjtcblx0ICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgLyp1bml0IGNhbGN1bGF0aW9uIChpdGVtX3JhZGl1c19wb3MgPSB2YWx1ZSp1bml0KSovXG5cblx0ICAgIG1pbiA9IGNvbmZpZy55QXhpcy5zdGFydDtcblx0ICAgIG1heCA9IGNvbmZpZy55QXhpcy5lbmQ7XG5cdCAgICB1bml0QXJyID0gdGhpcy5fZ2V0UmVsYXRpdmVWYWx1ZShtaW4sIG1heCk7XG5cdCAgICByZWxWYWx1ZSA9IHVuaXRBcnJbMF07XG5cdCAgICB1bml0ID0gcmVsVmFsdWUgPyByYWRpdXMgLyByZWxWYWx1ZSA6IHJhZGl1cyAvIDI7XG5cdCAgICB2YWx1ZUZhY3RvciA9IHVuaXRBcnJbMV07XG5cdCAgICBzdGFydEFscGhhID0gLU1hdGguUEkgLyAyO1xuXHQgICAgYWxwaGEwID0gYWxwaGExID0gc3RhcnRBbHBoYTtcblx0ICAgIHBvc0FyciA9IFtdO1xuXHQgICAgcG9zMSA9IDA7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICghdmFsdWUxKSB7XG5cdCAgICAgICAgdmFsdWUgPSBjb25maWcudmFsdWUoZGF0YVtpXSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX2xvZ1NjYWxlQ2FsYykgdmFsdWUgPSB0aGlzLl9sb2cxMCh2YWx1ZSk7XG5cdCAgICAgICAgLyphIHJlbGF0aXZlIHZhbHVlKi9cblxuXHQgICAgICAgIHZhbHVlMCA9IChwYXJzZUZsb2F0KHZhbHVlIHx8IDApIC0gbWluKSAqIHZhbHVlRmFjdG9yO1xuXHQgICAgICB9IGVsc2UgdmFsdWUwID0gdmFsdWUxO1xuXG5cdCAgICAgIHIwID0gTWF0aC5mbG9vcih1bml0ICogdmFsdWUwKTtcblx0ICAgICAgdmFsdWUgPSBjb25maWcudmFsdWUoaSAhPSBkYXRhLmxlbmd0aCAtIDEgPyBkYXRhW2kgKyAxXSA6IGRhdGFbMF0pO1xuXHQgICAgICBpZiAodGhpcy5fbG9nU2NhbGVDYWxjKSB2YWx1ZSA9IHRoaXMuX2xvZzEwKHZhbHVlKTtcblx0ICAgICAgdmFsdWUxID0gKHBhcnNlRmxvYXQodmFsdWUgfHwgMCkgLSBtaW4pICogdmFsdWVGYWN0b3I7XG5cdCAgICAgIHIxID0gTWF0aC5mbG9vcih1bml0ICogdmFsdWUxKTtcblx0ICAgICAgYWxwaGEwID0gYWxwaGExO1xuXHQgICAgICBhbHBoYTEgPSBpICE9IGRhdGEubGVuZ3RoIC0gMSA/IHN0YXJ0QWxwaGEgKyByYXRpb3NbaV0gLSAwLjAwMDEgOiBzdGFydEFscGhhO1xuXHQgICAgICBwb3MwID0gcG9zMSB8fCB0aGlzLl9nZXRQb3NpdGlvbkJ5QW5nbGUoYWxwaGEwLCB4LCB5LCByMCk7XG5cdCAgICAgIHBvczEgPSB0aGlzLl9nZXRQb3NpdGlvbkJ5QW5nbGUoYWxwaGExLCB4LCB5LCByMSk7XG5cdCAgICAgIC8qY3JlYXRlcyBtYXAgYXJlYSovXG5cblx0ICAgICAgLyphcmVhV2lkdGggID0gKGNvbmZpZy5ldmVudFJhZGl1c3x8KHBhcnNlSW50KGNvbmZpZy5pdGVtLnJhZGl1cy5jYWxsKHRoaXMsZGF0YVtpXSksMTApK2NvbmZpZy5pdGVtLmJvcmRlcldpZHRoKSk7XG5cdCAgICAgICBtYXAuYWRkUmVjdChkYXRhW2ldLmlkLFtwb3MwLngtYXJlYVdpZHRoLHBvczAueS1hcmVhV2lkdGgscG9zMC54K2FyZWFXaWR0aCxwb3MwLnkrYXJlYVdpZHRoXSxzSW5kZXgpOyovXG5cdCAgICAgIC8vdGhpcy5fZHJhd0xpbmUoY3R4LHBvczAueCxwb3MwLnkscG9zMS54LHBvczEueSxjb25maWcubGluZS5jb2xvci5jYWxsKHRoaXMsZGF0YVtpXSksY29uZmlnLmxpbmUud2lkdGgpXG5cblx0ICAgICAgcG9zQXJyLnB1c2gocG9zMCk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb25maWcuZmlsbCkgdGhpcy5fZmlsbFJhZGFyQ2hhcnQoY3R4LCBwb3NBcnIsIGRhdGEpO1xuXHQgICAgaWYgKCFjb25maWcuZGlzYWJsZUxpbmVzICYmIGRhdGEubGVuZ3RoID4gMikgdGhpcy5fc3Ryb2tlUmFkYXJDaGFydChjdHgsIHBvc0FyciwgZGF0YSk7XG5cdCAgICBpZiAoIWNvbmZpZy5kaXNhYmxlSXRlbXMgfHwgZGF0YS5sZW5ndGggPCAzKSB0aGlzLl9kcmF3UmFkYXJJdGVtTWFya2VycyhjdHgsIHBvc0FyciwgZGF0YSwgc0luZGV4LCBtYXApO1xuXHQgICAgcG9zQXJyID0gbnVsbDtcblx0ICB9LFxuXHQgIF9kcmF3UmFkYXJJdGVtTWFya2VyczogZnVuY3Rpb24gKGN0eCwgcG9pbnRzLCBkYXRhLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fZHJhd0l0ZW0oY3R4LCBwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnksIGRhdGFbaV0sIHRoaXMuX3NldHRpbmdzLmxhYmVsLmNhbGwodGhpcywgZGF0YSksIHNJbmRleCwgbWFwKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9maWxsUmFkYXJDaGFydDogZnVuY3Rpb24gKGN0eCwgcG9pbnRzLCBkYXRhKSB7XG5cdCAgICB2YXIgcG9zMCwgcG9zMTtcblx0ICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX3NldHRpbmdzLmFscGhhLmNhbGwodGhpcywge30pO1xuXHQgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fc2V0dGluZ3MuZmlsbC5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXHQgICAgICBwb3MwID0gcG9pbnRzW2ldO1xuXHQgICAgICBwb3MxID0gcG9pbnRzW2kgKyAxXSB8fCBwb2ludHNbMF07XG5cblx0ICAgICAgaWYgKCFpKSB7XG5cdCAgICAgICAgY3R4Lm1vdmVUbyhwb3MwLngsIHBvczAueSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjdHgubGluZVRvKHBvczEueCwgcG9zMS55KTtcblx0ICAgIH1cblxuXHQgICAgY3R4LmZpbGwoKTtcblx0ICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdCAgfSxcblx0ICBfc3Ryb2tlUmFkYXJDaGFydDogZnVuY3Rpb24gKGN0eCwgcG9pbnRzLCBkYXRhKSB7XG5cdCAgICB2YXIgcG9zMCwgcG9zMTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcG9zMCA9IHBvaW50c1tpXTtcblx0ICAgICAgcG9zMSA9IHBvaW50c1tpICsgMV0gfHwgcG9pbnRzWzBdO1xuXG5cdCAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgcG9zMC54LCBwb3MwLnksIHBvczEueCwgcG9zMS55LCB0aGlzLl9zZXR0aW5ncy5saW5lLmNvbG9yLmNhbGwodGhpcywgZGF0YVtpXSksIHRoaXMuX3NldHRpbmdzLmxpbmUud2lkdGgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2RyYXdSYWRhckF4aXNlczogZnVuY3Rpb24gKHJhdGlvcywgeCwgeSwgcmFkaXVzLCBkYXRhKSB7XG5cdCAgICB2YXIgY29uZmlnWSA9IHRoaXMuX3NldHRpbmdzLnlBeGlzO1xuXHQgICAgdmFyIGNvbmZpZ1ggPSB0aGlzLl9zZXR0aW5ncy54QXhpcztcblx0ICAgIHZhciBzdGFydCA9IGNvbmZpZ1kuc3RhcnQ7XG5cdCAgICB2YXIgZW5kID0gY29uZmlnWS5lbmQ7XG5cdCAgICB2YXIgc3RlcCA9IGNvbmZpZ1kuc3RlcDtcblx0ICAgIHZhciBzY2FsZVBhcmFtID0ge307XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fY29uZmlnWUF4aXM7XG5cblx0ICAgIGlmICh0eXBlb2YgY29uZmlnLnN0ZXAgPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgY29uZmlnLnN0YXJ0ID09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGNvbmZpZy5lbmQgPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB2YXIgbGltaXRzID0gdGhpcy5fZ2V0TGltaXRzKCk7XG5cblx0ICAgICAgc2NhbGVQYXJhbSA9IHRoaXMuX2NhbGN1bGF0ZVNjYWxlKGxpbWl0cy5taW4sIGxpbWl0cy5tYXgpO1xuXHQgICAgICBzdGFydCA9IHNjYWxlUGFyYW0uc3RhcnQ7XG5cdCAgICAgIGVuZCA9IHNjYWxlUGFyYW0uZW5kO1xuXHQgICAgICBzdGVwID0gc2NhbGVQYXJhbS5zdGVwO1xuXHQgICAgICBjb25maWdZLmVuZCA9IGVuZDtcblx0ICAgICAgY29uZmlnWS5zdGFydCA9IHN0YXJ0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdW5pdHMgPSBbXTtcblx0ICAgIHZhciBpLCBqLCBwO1xuXHQgICAgdmFyIGMgPSAwO1xuXHQgICAgdmFyIHN0ZXBIZWlnaHQgPSByYWRpdXMgKiBzdGVwIC8gKGVuZCAtIHN0YXJ0KTtcblx0ICAgIC8qY29ycmVjdGlvbiBmb3Igc21hbGwgc3RlcCovXG5cblx0ICAgIHZhciBwb3dlciwgY29ycjtcblxuXHQgICAgaWYgKHN0ZXAgPCAxKSB7XG5cdCAgICAgIHBvd2VyID0gTWF0aC5taW4odGhpcy5fbG9nMTAoc3RlcCksIHN0YXJ0IDw9IDAgPyAwIDogdGhpcy5fbG9nMTAoc3RhcnQpKTtcblx0ICAgICAgY29yciA9IE1hdGgucG93KDEwLCAtcG93ZXIpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgYW5nbGVzID0gW107XG5cdCAgICBpZiAoIXRoaXMuY2FudmFzZXNbXCJzY2FsZVwiXSkgdGhpcy5jYW52YXNlc1tcInNjYWxlXCJdID0gdGhpcy5fY3JlYXRlQ2FudmFzKFwicmFkYXJfc2NhbGVcIik7XG5cdCAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXNlc1tcInNjYWxlXCJdLmdldENhbnZhcygpO1xuXG5cdCAgICBmb3IgKGkgPSBlbmQ7IGkgPj0gc3RhcnQ7IGkgLT0gc3RlcCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9sb2dTY2FsZUNhbGMgPyBNYXRoLnBvdygxMCwgaSkgOiBpO1xuXHQgICAgICBpZiAoc2NhbGVQYXJhbS5maXhOdW0pIHZhbHVlID0gcGFyc2VGbG9hdChpKS50b0ZpeGVkKHNjYWxlUGFyYW0uZml4TnVtKTtcblx0ICAgICAgdW5pdHMucHVzaChNYXRoLmZsb29yKGMgKiBzdGVwSGVpZ2h0KSArIDAuNSk7XG5cblx0ICAgICAgaWYgKGNvcnIgJiYgIXRoaXMuX2xvZ1NjYWxlQ2FsYykge1xuXHQgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIGNvcnIpIC8gY29ycjtcblx0ICAgICAgICBpID0gdmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdW5pdFkgPSB5IC0gcmFkaXVzICsgdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG5cdCAgICAgIHRoaXMuY2FudmFzZXNbXCJzY2FsZVwiXS5yZW5kZXJUZXh0QXQoXCJtaWRkbGVcIiwgXCJsZWZ0XCIsIHgsIHVuaXRZLCBjb25maWdZLnRlbXBsYXRlKHZhbHVlLnRvU3RyaW5nKCkpLCBcIndlYml4X2F4aXNfaXRlbV95IHdlYml4X3JhZGFyXCIpO1xuXG5cdCAgICAgIGlmIChyYXRpb3MubGVuZ3RoIDwgMikge1xuXHQgICAgICAgIHRoaXMuX2RyYXdTY2FsZVNlY3RvcihjdHgsIFwiYXJjXCIsIHgsIHksIHJhZGl1cyAtIHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdLCAtTWF0aC5QSSAvIDIsIDMgKiBNYXRoLlBJIC8gMiwgaSk7XG5cblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgc3RhcnRBbHBoYSA9IC1NYXRoLlBJIC8gMjtcblx0ICAgICAgLypwb3NzaWJseSBuZWVkICB0byBtb3ZlZCBpbiBjb25maWcqL1xuXG5cdCAgICAgIHZhciBhbHBoYTAgPSBzdGFydEFscGhhO1xuXHQgICAgICB2YXIgYWxwaGExO1xuXG5cdCAgICAgIGZvciAoaiA9IDA7IGogPCByYXRpb3MubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICBpZiAoIWMpIGFuZ2xlcy5wdXNoKGFscGhhMCk7XG5cdCAgICAgICAgYWxwaGExID0gc3RhcnRBbHBoYSArIHJhdGlvc1tqXSAtIDAuMDAwMTtcblxuXHQgICAgICAgIHRoaXMuX2RyYXdTY2FsZVNlY3RvcihjdHgsIHJhdGlvcy5sZW5ndGggPiAyID8gY29uZmlnLmxpbmVTaGFwZSB8fCBcImxpbmVcIiA6IFwiYXJjXCIsIHgsIHksIHJhZGl1cyAtIHVuaXRzW3VuaXRzLmxlbmd0aCAtIDFdLCBhbHBoYTAsIGFscGhhMSwgaSwgaiwgZGF0YVtpXSk7XG5cblx0ICAgICAgICBhbHBoYTAgPSBhbHBoYTE7XG5cdCAgICAgIH1cblxuXHQgICAgICBjKys7XG5cdCAgICB9XG5cdCAgICAvKnJlbmRlcnMgcmFkaXVzIGxpbmVzIGFuZCBsYWJlbHMqL1xuXG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBhbmdsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgcCA9IHRoaXMuX2dldFBvc2l0aW9uQnlBbmdsZShhbmdsZXNbaV0sIHgsIHksIHJhZGl1cyk7XG5cdCAgICAgIGlmIChjb25maWdYLmxpbmVzLmNhbGwodGhpcywgZGF0YVtpXSwgaSkpIHRoaXMuX2RyYXdMaW5lKGN0eCwgeCwgeSwgcC54LCBwLnksIGNvbmZpZ1ggPyBjb25maWdYLmxpbmVDb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pIDogXCIjY2ZjZmNmXCIsIDEpO1xuXG5cdCAgICAgIHRoaXMuX2RyYXdSYWRhclNjYWxlTGFiZWwoY3R4LCB4LCB5LCByYWRpdXMsIGFuZ2xlc1tpXSwgY29uZmlnWCA/IGNvbmZpZ1gudGVtcGxhdGUuY2FsbCh0aGlzLCBkYXRhW2ldKSA6IFwiJm5ic3A7XCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2RyYXdTY2FsZVNlY3RvcjogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIHgsIHksIHJhZGl1cywgYTEsIGEyLCBpLCBqKSB7XG5cdCAgICB2YXIgcG9zMSwgcG9zMjtcblx0ICAgIGlmIChyYWRpdXMgPCAwKSByZXR1cm4gZmFsc2U7XG5cdCAgICBwb3MxID0gdGhpcy5fZ2V0UG9zaXRpb25CeUFuZ2xlKGExLCB4LCB5LCByYWRpdXMpO1xuXHQgICAgcG9zMiA9IHRoaXMuX2dldFBvc2l0aW9uQnlBbmdsZShhMiwgeCwgeSwgcmFkaXVzKTtcblx0ICAgIHZhciBjb25maWdZID0gdGhpcy5fc2V0dGluZ3MueUF4aXM7XG5cblx0ICAgIGlmIChjb25maWdZLmJnKSB7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcblx0ICAgICAgaWYgKHNoYXBlID09IFwiYXJjXCIpIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBhMSwgYTIsIGZhbHNlKTtlbHNlIHtcblx0ICAgICAgICBjdHgubGluZVRvKHBvczEueCwgcG9zMS55KTtcblx0ICAgICAgICBjdHgubGluZVRvKHBvczIueCwgcG9zMi55KTtcblx0ICAgICAgfVxuXHQgICAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnWS5iZyhpLCBqKTtcblx0ICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcblx0ICAgICAgY3R4LmZpbGwoKTtcblx0ICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29uZmlnWS5saW5lcy5jYWxsKHRoaXMsIGkpKSB7XG5cdCAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXHQgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgIGlmIChzaGFwZSA9PSBcImFyY1wiKSBjdHguYXJjKHgsIHksIHJhZGl1cywgYTEsIGEyLCBmYWxzZSk7ZWxzZSB7XG5cdCAgICAgICAgY3R4Lm1vdmVUbyhwb3MxLngsIHBvczEueSk7XG5cdCAgICAgICAgY3R4LmxpbmVUbyhwb3MyLngsIHBvczIueSk7XG5cdCAgICAgIH1cblx0ICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29uZmlnWS5saW5lQ29sb3IuY2FsbCh0aGlzLCBpKTtcblx0ICAgICAgY3R4LnN0cm9rZSgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2RyYXdSYWRhclNjYWxlTGFiZWw6IGZ1bmN0aW9uIChjdHgsIHgsIHksIHIsIGEsIHRleHQpIHtcblx0ICAgIGlmICghdGV4dCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgdmFyIHQgPSB0aGlzLmNhbnZhc2VzW1wic2NhbGVcIl0ucmVuZGVyVGV4dCgwLCAwLCB0ZXh0LCBcIndlYml4X2F4aXNfcmFkYXJfdGl0bGVcIiwgMSk7XG5cdCAgICB2YXIgd2lkdGggPSB0LnNjcm9sbFdpZHRoO1xuXHQgICAgdmFyIGhlaWdodCA9IHQub2Zmc2V0SGVpZ2h0O1xuXHQgICAgdmFyIGRlbHRhID0gMC4wMDE7XG5cblx0ICAgIHZhciBwb3MgPSB0aGlzLl9nZXRQb3NpdGlvbkJ5QW5nbGUoYSwgeCwgeSwgciArIDUpO1xuXG5cdCAgICB2YXIgY29ycl94ID0gMCxcblx0ICAgICAgICBjb3JyX3kgPSAwO1xuXG5cdCAgICBpZiAoYSA8IDAgfHwgYSA+IE1hdGguUEkpIHtcblx0ICAgICAgY29ycl95ID0gLWhlaWdodDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGEgPiBNYXRoLlBJIC8gMikge1xuXHQgICAgICBjb3JyX3ggPSAtd2lkdGg7XG5cdCAgICB9XG5cblx0ICAgIGlmIChNYXRoLmFicyhhICsgTWF0aC5QSSAvIDIpIDwgZGVsdGEgfHwgTWF0aC5hYnMoYSAtIE1hdGguUEkgLyAyKSA8IGRlbHRhKSB7XG5cdCAgICAgIGNvcnJfeCA9IC13aWR0aCAvIDI7XG5cdCAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGEpIDwgZGVsdGEgfHwgTWF0aC5hYnMoYSAtIE1hdGguUEkpIDwgZGVsdGEpIHtcblx0ICAgICAgY29ycl95ID0gLWhlaWdodCAvIDI7XG5cdCAgICB9XG5cblx0ICAgIHQuc3R5bGUudG9wID0gcG9zLnkgKyBjb3JyX3kgKyBcInB4XCI7XG5cdCAgICB0LnN0eWxlLmxlZnQgPSBwb3MueCArIGNvcnJfeCArIFwicHhcIjtcblx0ICAgIHQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcblx0ICAgIHQuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBTY2F0dGVyID0ge1xuXHQgIC8qKlxuXHQgICogICByZW5kZXJzIGEgZ3JhcGhpY1xuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgKiAgIEBwYXJhbTogcG9pbnQwICAtIHRvcCBsZWZ0IHBvaW50IG9mIGEgY2hhcnRcblx0ICAqICAgQHBhcmFtOiBwb2ludDEgIC0gcmlnaHQgYm90dG9tIHBvaW50IG9mIGEgY2hhcnRcblx0ICAqICAgQHBhcmFtOiBzSW5kZXggLSBpbmRleCBvZiBkcmF3aW5nIGNoYXJ0XG5cdCAgICAgKiAgIEBwYXJhbTogbWFwIC0gbWFwIG9iamVjdFxuXHQgICovXG5cdCAgJHJlbmRlcl9zY2F0dGVyOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc0luZGV4LCBtYXApIHtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MueFZhbHVlKSByZXR1cm47XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICB2YXIgbGluZXMgPSAhKGNvbmZpZy5kaXNhYmxlTGluZXMgfHwgdHlwZW9mIGNvbmZpZy5kaXNhYmxlTGluZXMgPT0gXCJ1bmRlZmluZWRcIik7XG5cdCAgICAvKm1heCBpbiBtaW4gdmFsdWVzKi9cblxuXHQgICAgdmFyIGxpbWl0c1kgPSB0aGlzLl9nZXRMaW1pdHMoKTtcblxuXHQgICAgdmFyIGxpbWl0c1ggPSB0aGlzLl9nZXRMaW1pdHMoXCJoXCIsIFwieFZhbHVlXCIpO1xuXHQgICAgLypyZW5kZXIgc2NhbGUqL1xuXG5cblx0ICAgIGlmICghc0luZGV4KSB7XG5cdCAgICAgIGlmICghdGhpcy5jYW52YXNlc1tcInhcIl0pIHRoaXMuY2FudmFzZXNbXCJ4XCJdID0gdGhpcy5fY3JlYXRlQ2FudmFzKFwiYXhpc194XCIpO1xuXHQgICAgICBpZiAoIXRoaXMuY2FudmFzZXNbXCJ5XCJdKSB0aGlzLmNhbnZhc2VzW1wieVwiXSA9IHRoaXMuX2NyZWF0ZUNhbnZhcyhcImF4aXNfeVwiKTtcblxuXHQgICAgICB0aGlzLl9kcmF3WUF4aXModGhpcy5jYW52YXNlc1tcInlcIl0uZ2V0Q2FudmFzKCksIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBsaW1pdHNZLm1pbiwgbGltaXRzWS5tYXgpO1xuXG5cdCAgICAgIHRoaXMuX2RyYXdIWEF4aXModGhpcy5jYW52YXNlc1tcInhcIl0uZ2V0Q2FudmFzKCksIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBsaW1pdHNYLm1pbiwgbGltaXRzWC5tYXgpO1xuXHQgICAgfVxuXG5cdCAgICBsaW1pdHNZID0ge1xuXHQgICAgICBtaW46IGNvbmZpZy55QXhpcy5zdGFydCxcblx0ICAgICAgbWF4OiBjb25maWcueUF4aXMuZW5kXG5cdCAgICB9O1xuXHQgICAgbGltaXRzWCA9IHtcblx0ICAgICAgbWluOiBjb25maWcueEF4aXMuc3RhcnQsXG5cdCAgICAgIG1heDogY29uZmlnLnhBeGlzLmVuZFxuXHQgICAgfTtcblxuXHQgICAgdmFyIHBhcmFtcyA9IHRoaXMuX2dldFNjYXR0ZXJQYXJhbXMoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgbGltaXRzWCwgbGltaXRzWSk7XG5cblx0ICAgIHRoaXMuX21hcFN0YXJ0ID0gcG9pbnQwO1xuXHQgICAgdmFyIGl0ZW1zID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgeCA9IHRoaXMuX2NhbGN1bGF0ZVNjYXR0ZXJJdGVtUG9zaXRpb24ocGFyYW1zLCBwb2ludDEsIHBvaW50MCwgbGltaXRzWCwgZGF0YVtpXSwgXCJYXCIpO1xuXG5cdCAgICAgIHZhciB5ID0gdGhpcy5fY2FsY3VsYXRlU2NhdHRlckl0ZW1Qb3NpdGlvbihwYXJhbXMsIHBvaW50MCwgcG9pbnQxLCBsaW1pdHNZLCBkYXRhW2ldLCBcIllcIik7XG5cblx0ICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSBjb250aW51ZTtcblx0ICAgICAgaXRlbXMucHVzaCh7XG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5LFxuXHQgICAgICAgIGluZGV4OiBpXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeDEsIHkxLCB4MiwgeTIsIGRpO1xuXG5cdCAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaXRlbXMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIGRpID0gaXRlbXNbX2ldLmluZGV4O1xuXG5cdCAgICAgIGlmIChsaW5lcykge1xuXHQgICAgICAgIHZhciBjb2xvciA9IGNvbmZpZy5saW5lLmNvbG9yLmNhbGwodGhpcywgZGF0YVtkaV0pOyAvL2xpbmUgc3RhcnQgcG9zaXRpb25cblxuXHQgICAgICAgIHgxID0gaXRlbXNbX2ldLng7XG5cdCAgICAgICAgeTEgPSBpdGVtc1tfaV0ueTtcblxuXHQgICAgICAgIGlmIChfaSA9PSBpdGVtcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICAvL2Nvbm5lY3RpbmcgbGFzdCBhbmQgZmlyc3QgaXRlbXNcblx0ICAgICAgICAgIGlmIChjb25maWcuc2hhcGUgJiYgaXRlbXMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHgyLCB5MiwgaXRlbXNbMF0ueCwgaXRlbXNbMF0ueSwgY29sb3IsIGNvbmZpZy5saW5lLndpZHRoKTsgLy9yZW5kZXIgc2hhcGUgb24gdG9wIG9mIHRoZSBsaW5lXG5cblxuXHQgICAgICAgICAgICBpZiAoIWNvbmZpZy5kaXNhYmxlSXRlbXMpIHRoaXMuX2RyYXdTY2F0dGVySXRlbShjdHgsIG1hcCwgaXRlbXNbMF0sIGRhdGFbMF0sIHNJbmRleCk7XG5cdCAgICAgICAgICAgIGlmIChjb25maWcuZmlsbCkgdGhpcy5fZmlsbFNjYXR0ZXJDaGFydChjdHgsIGl0ZW1zLCBkYXRhKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gbGluZSBiZXR3ZWVuIHR3byBwb2ludHNcblx0ICAgICAgICAgIHgyID0gaXRlbXNbX2kgKyAxXS54O1xuXHQgICAgICAgICAgeTIgPSBpdGVtc1tfaSArIDFdLnk7XG5cblx0ICAgICAgICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIsIGNvbG9yLCBjb25maWcubGluZS53aWR0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IC8vaXRlbVxuXG5cblx0ICAgICAgaWYgKCFjb25maWcuZGlzYWJsZUl0ZW1zICYmIGl0ZW1zW19pXSkge1xuXHQgICAgICAgIHRoaXMuX2RyYXdTY2F0dGVySXRlbShjdHgsIG1hcCwgaXRlbXNbX2ldLCBkYXRhW2RpXSwgc0luZGV4KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2ZpbGxTY2F0dGVyQ2hhcnQ6IGZ1bmN0aW9uIChjdHgsIHBvaW50cywgZGF0YSkge1xuXHQgICAgdmFyIHBvczAsIHBvczE7XG5cdCAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9zZXR0aW5ncy5hbHBoYS5jYWxsKHRoaXMsIHt9KTtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX3NldHRpbmdzLmZpbGwuY2FsbCh0aGlzLCBkYXRhW2ldKTtcblx0ICAgICAgcG9zMCA9IHBvaW50c1tpXTtcblx0ICAgICAgcG9zMSA9IHBvaW50c1tpICsgMV0gfHwgcG9pbnRzWzBdO1xuXG5cdCAgICAgIGlmICghaSkge1xuXHQgICAgICAgIGN0eC5tb3ZlVG8ocG9zMC54LCBwb3MwLnkpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY3R4LmxpbmVUbyhwb3MxLngsIHBvczEueSk7XG5cdCAgICB9XG5cblx0ICAgIGN0eC5maWxsKCk7XG5cdCAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHQgIH0sXG5cdCAgX2dldFNjYXR0ZXJQYXJhbXM6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBsaW1pdHNYLCBsaW1pdHNZKSB7XG5cdCAgICB2YXIgcGFyYW1zID0ge307XG5cdCAgICAvKmF2YWlsYWJsZSBzcGFjZSovXG5cblx0ICAgIHBhcmFtcy50b3RhbEhlaWdodCA9IHBvaW50MS55IC0gcG9pbnQwLnk7XG5cdCAgICAvKmF2YWlsYWJsZSB3aWR0aCovXG5cblx0ICAgIHBhcmFtcy50b3RhbFdpZHRoID0gcG9pbnQxLnggLSBwb2ludDAueDtcblx0ICAgIC8qdW5pdCBjYWxjdWxhdGlvbiAoeV9wb3NpdGlvbiA9IHZhbHVlKnVuaXQpKi9cblxuXHQgICAgdGhpcy5fY2FsY1NjYXR0ZXJVbml0KHBhcmFtcywgbGltaXRzWC5taW4sIGxpbWl0c1gubWF4LCBwYXJhbXMudG90YWxXaWR0aCwgXCJYXCIpO1xuXG5cdCAgICB0aGlzLl9jYWxjU2NhdHRlclVuaXQocGFyYW1zLCBsaW1pdHNZLm1pbiwgbGltaXRzWS5tYXgsIHBhcmFtcy50b3RhbEhlaWdodCwgXCJZXCIpO1xuXG5cdCAgICByZXR1cm4gcGFyYW1zO1xuXHQgIH0sXG5cdCAgX2RyYXdTY2F0dGVySXRlbTogZnVuY3Rpb24gKGN0eCwgbWFwLCBpdGVtLCBvYmosIHNJbmRleCkge1xuXHQgICAgdGhpcy5fZHJhd0l0ZW0oY3R4LCBpdGVtLngsIGl0ZW0ueSwgb2JqLCB0aGlzLl9zZXR0aW5ncy5sYWJlbC5jYWxsKHRoaXMsIG9iaiksIHNJbmRleCwgbWFwKTtcblx0ICB9LFxuXHQgIF9jYWxjdWxhdGVTY2F0dGVySXRlbVBvc2l0aW9uOiBmdW5jdGlvbiAocGFyYW1zLCBwb2ludDAsIHBvaW50MSwgbGltaXRzLCBvYmosIGF4aXMpIHtcblx0ICAgIC8qdGhlIHJlYWwgdmFsdWUgb2YgYW4gb2JqZWN0Ki9cblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuX3NldHRpbmdzW2F4aXMgPT0gXCJYXCIgPyBcInhWYWx1ZVwiIDogXCJ2YWx1ZVwiXS5jYWxsKHRoaXMsIG9iaik7XG5cdCAgICAvKmEgcmVsYXRpdmUgdmFsdWUqL1xuXG5cblx0ICAgIHZhciB2YWx1ZUZhY3RvciA9IHBhcmFtc1tcInZhbHVlRmFjdG9yXCIgKyBheGlzXTtcblx0ICAgIHZhciB2ID0gKHBhcnNlRmxvYXQodmFsdWUgfHwgMCkgLSBsaW1pdHMubWluKSAqIHZhbHVlRmFjdG9yO1xuXHQgICAgLyphIHZlcnRpY2FsIGNvb3JkaW5hdGUqL1xuXG5cdCAgICB2YXIgdW5pdCA9IHBhcmFtc1tcInVuaXRcIiArIGF4aXNdO1xuXHQgICAgdmFyIHBvcyA9IHBvaW50MVtheGlzLnRvTG93ZXJDYXNlKCldIC0gKGF4aXMgPT0gXCJYXCIgPyAtMSA6IDEpICogTWF0aC5mbG9vcih1bml0ICogdik7XG5cdCAgICAvKnRoZSBsaW1pdCBvZiB0aGUgbWluaW11bSB2YWx1ZSBpcyAgdGhlIG1pbmltdW0gdmlzaWJsZSB2YWx1ZSovXG5cblx0ICAgIGlmICh2IDwgMCkgcG9zID0gcG9pbnQxW2F4aXMudG9Mb3dlckNhc2UoKV07XG5cdCAgICAvKnRoZSBsaW1pdCBvZiB0aGUgbWF4aW11bSB2YWx1ZSovXG5cblx0ICAgIGlmICh2YWx1ZSA+IGxpbWl0cy5tYXgpIHBvcyA9IHBvaW50MFtheGlzLnRvTG93ZXJDYXNlKCldO1xuXHQgICAgLyp0aGUgbGltaXQgb2YgdGhlIG1pbmltdW0gdmFsdWUqL1xuXG5cdCAgICBpZiAodmFsdWUgPCBsaW1pdHMubWluKSBwb3MgPSBwb2ludDFbYXhpcy50b0xvd2VyQ2FzZSgpXTtcblx0ICAgIHJldHVybiBwb3M7XG5cdCAgfSxcblx0ICBfY2FsY1NjYXR0ZXJVbml0OiBmdW5jdGlvbiAocCwgbWluLCBtYXgsIHNpemUsIGF4aXMpIHtcblx0ICAgIHZhciByZWxhdGl2ZVZhbHVlcyA9IHRoaXMuX2dldFJlbGF0aXZlVmFsdWUobWluLCBtYXgpO1xuXG5cdCAgICBheGlzID0gYXhpcyB8fCBcIlwiO1xuXHQgICAgcFtcInJlbFZhbHVlXCIgKyBheGlzXSA9IHJlbGF0aXZlVmFsdWVzWzBdO1xuXHQgICAgcFtcInZhbHVlRmFjdG9yXCIgKyBheGlzXSA9IHJlbGF0aXZlVmFsdWVzWzFdO1xuXHQgICAgcFtcInVuaXRcIiArIGF4aXNdID0gcFtcInJlbFZhbHVlXCIgKyBheGlzXSA/IHNpemUgLyBwW1wicmVsVmFsdWVcIiArIGF4aXNdIDogMTA7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBQcmVzZXRzID0ge1xuXHQgIHByZXNldHM6IHtcblx0ICAgIFwic2ltcGxlXCI6IHtcblx0ICAgICAgaXRlbToge1xuXHQgICAgICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmZmZcIixcblx0ICAgICAgICBjb2xvcjogXCIjMmI3MTAwXCIsXG5cdCAgICAgICAgc2hhZG93OiBmYWxzZSxcblx0ICAgICAgICBib3JkZXJXaWR0aDogMlxuXHQgICAgICB9LFxuXHQgICAgICBsaW5lOiB7XG5cdCAgICAgICAgY29sb3I6IFwiIzhlY2YwM1wiLFxuXHQgICAgICAgIHdpZHRoOiAyXG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBcInBsb3RcIjoge1xuXHQgICAgICBjb2xvcjogXCIjODY2NEM2XCIsXG5cdCAgICAgIGl0ZW06IHtcblx0ICAgICAgICBib3JkZXJDb2xvcjogXCIjODY2NEM2XCIsXG5cdCAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG5cdCAgICAgICAgY29sb3I6IFwiI2ZmZmZmZlwiLFxuXHQgICAgICAgIHR5cGU6IFwiclwiLFxuXHQgICAgICAgIHNoYWRvdzogZmFsc2Vcblx0ICAgICAgfSxcblx0ICAgICAgbGluZToge1xuXHQgICAgICAgIGNvbG9yOiBcIiM4NjY0QzZcIixcblx0ICAgICAgICB3aWR0aDogMlxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgXCJkaWFtb25kXCI6IHtcblx0ICAgICAgY29sb3I6IFwiI0ZGNUM0Q1wiLFxuXHQgICAgICBpdGVtOiB7XG5cdCAgICAgICAgYm9yZGVyQ29sb3I6IFwiI0ZGNUM0Q1wiLFxuXHQgICAgICAgIGNvbG9yOiBcIiNGRjVDNENcIixcblx0ICAgICAgICB0eXBlOiBcImRcIixcblx0ICAgICAgICByYWRpdXM6IDMsXG5cdCAgICAgICAgc2hhZG93OiB0cnVlXG5cdCAgICAgIH0sXG5cdCAgICAgIGxpbmU6IHtcblx0ICAgICAgICBjb2xvcjogXCIjRkY1QzRDXCIsXG5cdCAgICAgICAgd2lkdGg6IDJcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIFwicG9pbnRcIjoge1xuXHQgICAgICBjb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgIGRpc2FibGVMaW5lczogdHJ1ZSxcblx0ICAgICAgZmlsbDogZmFsc2UsXG5cdCAgICAgIGRpc2FibGVJdGVtczogZmFsc2UsXG5cdCAgICAgIGl0ZW06IHtcblx0ICAgICAgICBjb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzFjYTFjMVwiLFxuXHQgICAgICAgIHJhZGl1czogMixcblx0ICAgICAgICBib3JkZXJXaWR0aDogMixcblx0ICAgICAgICB0eXBlOiBcInJcIlxuXHQgICAgICB9LFxuXHQgICAgICBhbHBoYTogMVxuXHQgICAgfSxcblx0ICAgIFwibGluZVwiOiB7XG5cdCAgICAgIGxpbmU6IHtcblx0ICAgICAgICBjb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgICAgd2lkdGg6IDJcblx0ICAgICAgfSxcblx0ICAgICAgaXRlbToge1xuXHQgICAgICAgIGNvbG9yOiBcIiNmZmZmZmZcIixcblx0ICAgICAgICBib3JkZXJDb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgICAgcmFkaXVzOiAyLFxuXHQgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuXHQgICAgICAgIHR5cGU6IFwiZFwiXG5cdCAgICAgIH0sXG5cdCAgICAgIGZpbGw6IGZhbHNlLFxuXHQgICAgICBkaXNhYmxlSXRlbXM6IGZhbHNlLFxuXHQgICAgICBkaXNhYmxlTGluZXM6IGZhbHNlLFxuXHQgICAgICBhbHBoYTogMVxuXHQgICAgfSxcblx0ICAgIFwiYXJlYVwiOiB7XG5cdCAgICAgIGZpbGw6IFwiIzFjYTFjMVwiLFxuXHQgICAgICBsaW5lOiB7XG5cdCAgICAgICAgY29sb3I6IFwiIzFjYTFjMVwiLFxuXHQgICAgICAgIHdpZHRoOiAxXG5cdCAgICAgIH0sXG5cdCAgICAgIGRpc2FibGVJdGVtczogdHJ1ZSxcblx0ICAgICAgYWxwaGE6IDAuMixcblx0ICAgICAgZGlzYWJsZUxpbmVzOiBmYWxzZVxuXHQgICAgfSxcblx0ICAgIFwicm91bmRcIjoge1xuXHQgICAgICBpdGVtOiB7XG5cdCAgICAgICAgcmFkaXVzOiAzLFxuXHQgICAgICAgIGJvcmRlckNvbG9yOiBcIiMxY2ExYzFcIixcblx0ICAgICAgICBib3JkZXJXaWR0aDogMSxcblx0ICAgICAgICBjb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgICAgdHlwZTogXCJyXCIsXG5cdCAgICAgICAgc2hhZG93OiBmYWxzZSxcblx0ICAgICAgICBhbHBoYTogMC42XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBcInNxdWFyZVwiOiB7XG5cdCAgICAgIGl0ZW06IHtcblx0ICAgICAgICByYWRpdXM6IDMsXG5cdCAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzAwYTQ5N1wiLFxuXHQgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuXHQgICAgICAgIGNvbG9yOiBcIiNmZmZmZmZcIixcblx0ICAgICAgICB0eXBlOiBcInNcIixcblx0ICAgICAgICBzaGFkb3c6IGZhbHNlLFxuXHQgICAgICAgIGFscGhhOiAxXG5cdCAgICAgIH0sXG5cdCAgICAgIGxpbmU6IHtcblx0ICAgICAgICBjb2xvcjogXCIjMDBhNDk3XCJcblx0ICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLypiYXIqL1xuXHQgICAgXCJjb2x1bW5cIjoge1xuXHQgICAgICBjb2xvcjogXCJSQUlOQk9XXCIsXG5cdCAgICAgIGdyYWRpZW50OiBmYWxzZSxcblx0ICAgICAgYmFyV2lkdGg6IDQ1LFxuXHQgICAgICByYWRpdXM6IDAsXG5cdCAgICAgIGFscGhhOiAxLFxuXHQgICAgICBib3JkZXI6IHRydWVcblx0ICAgIH0sXG5cdCAgICBcInN0aWNrXCI6IHtcblx0ICAgICAgYmFyV2lkdGg6IDUsXG5cdCAgICAgIGdyYWRpZW50OiBmYWxzZSxcblx0ICAgICAgY29sb3I6IFwiIzFjYTFjMVwiLFxuXHQgICAgICByYWRpdXM6IDIsXG5cdCAgICAgIGFscGhhOiAxLFxuXHQgICAgICBib3JkZXI6IGZhbHNlXG5cdCAgICB9LFxuXHQgICAgXCJhbHBoYVwiOiB7XG5cdCAgICAgIGNvbG9yOiBcIiNiOWE4ZjlcIixcblx0ICAgICAgYmFyV2lkdGg6IDcwLFxuXHQgICAgICBncmFkaWVudDogXCJmYWxsaW5nXCIsXG5cdCAgICAgIHJhZGl1czogMCxcblx0ICAgICAgYWxwaGE6IDAuNSxcblx0ICAgICAgYm9yZGVyOiB0cnVlXG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBTcGxpbmVBcmVhJDEgPSB7XG5cdCAgLyoqXG5cdCAgICogICByZW5kZXJzIGFuIHNwbGluZUFyZWEgY2hhcnRcblx0ICAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgICogICBAcGFyYW06IHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcblx0ICAgKiAgIEBwYXJhbTogaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyXG5cdCAgICogICBAcGFyYW06IHNJbmRleCAtIGluZGV4IG9mIGRyYXdpbmcgY2hhcnRcblx0ICAgKi9cblx0ICAkcmVuZGVyX3NwbGluZUFyZWE6IGZ1bmN0aW9uIChjdHgsIGRhdGEsIHBvaW50MCwgcG9pbnQxLCBzSW5kZXgsIG1hcCkge1xuXHQgICAgdmFyIGNvbG9yLFxuXHQgICAgICAgIGksXG5cdCAgICAgICAgaXRlbXMsXG5cdCAgICAgICAgaixcblx0ICAgICAgICBtYXBSZWN0LFxuXHQgICAgICAgIHBhcmFtcyxcblx0ICAgICAgICBzUGFyYW1zLFxuXHQgICAgICAgIHgsXG5cdCAgICAgICAgeDAsXG5cdCAgICAgICAgeDEsXG5cdCAgICAgICAgeDIsXG5cdCAgICAgICAgeSxcblx0ICAgICAgICB5Mixcblx0ICAgICAgICBjb25maWcgPSB0aGlzLl9zZXR0aW5ncyxcblx0ICAgICAgICBwYXRoID0gW107XG5cdCAgICBwYXJhbXMgPSB0aGlzLl9jYWxjdWxhdGVMaW5lUGFyYW1zKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIHNJbmRleCk7XG5cdCAgICBtYXBSZWN0ID0gY29uZmlnLmV2ZW50UmFkaXVzIHx8IE1hdGguZmxvb3IocGFyYW1zLmNlbGxXaWR0aCAvIDIpO1xuXHQgICAgLyphcnJheSBvZiBhbGwgcG9pbnRzKi9cblxuXHQgICAgaXRlbXMgPSBbXTtcblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgIC8qZ2V0dGluZyBhbGwgcG9pbnRzKi9cblx0ICAgICAgeDAgPSBwb2ludDAueDtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHkgPSB0aGlzLl9nZXRQb2ludFkoZGF0YVtpXSwgcG9pbnQwLCBwb2ludDEsIHBhcmFtcyk7XG5cblx0ICAgICAgICBpZiAoeSB8fCB5ID09IFwiMFwiKSB7XG5cdCAgICAgICAgICB4ID0gIWkgPyB4MCA6IHBhcmFtcy5jZWxsV2lkdGggKiBpIC0gMC41ICsgeDA7XG5cdCAgICAgICAgICBpdGVtcy5wdXNoKHtcblx0ICAgICAgICAgICAgeDogeCxcblx0ICAgICAgICAgICAgeTogeSxcblx0ICAgICAgICAgICAgaW5kZXg6IGlcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgbWFwLmFkZFJlY3QoZGF0YVtpXS5pZCwgW3ggLSBtYXBSZWN0IC0gcG9pbnQwLngsIHkgLSBtYXBSZWN0IC0gcG9pbnQwLnksIHggKyBtYXBSZWN0IC0gcG9pbnQwLngsIHkgKyBtYXBSZWN0IC0gcG9pbnQwLnldLCBzSW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHNQYXJhbXMgPSB0aGlzLl9nZXRTcGxpbmVQYXJhbWV0ZXJzKGl0ZW1zKTtcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB4MSA9IGl0ZW1zW2ldLng7XG5cblx0ICAgICAgICBpZiAoaSA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICAgIHgyID0gaXRlbXNbaSArIDFdLng7XG5cdCAgICAgICAgICB5MiA9IGl0ZW1zW2kgKyAxXS55O1xuXG5cdCAgICAgICAgICBmb3IgKGogPSB4MTsgaiA8IHgyOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIHNZMSA9IHRoaXMuX2dldFNwbGluZVlQb2ludChqLCB4MSwgaSwgc1BhcmFtcy5hLCBzUGFyYW1zLmIsIHNQYXJhbXMuYywgc1BhcmFtcy5kKTtcblxuXHQgICAgICAgICAgICBpZiAoc1kxIDwgcG9pbnQwLnkpIHNZMSA9IHBvaW50MC55O1xuXHQgICAgICAgICAgICBpZiAoc1kxID4gcG9pbnQxLnkpIHNZMSA9IHBvaW50MS55O1xuXG5cdCAgICAgICAgICAgIHZhciBzWTIgPSB0aGlzLl9nZXRTcGxpbmVZUG9pbnQoaiArIDEsIHgxLCBpLCBzUGFyYW1zLmEsIHNQYXJhbXMuYiwgc1BhcmFtcy5jLCBzUGFyYW1zLmQpO1xuXG5cdCAgICAgICAgICAgIGlmIChzWTIgPCBwb2ludDAueSkgc1kyID0gcG9pbnQwLnk7XG5cdCAgICAgICAgICAgIGlmIChzWTIgPiBwb2ludDEueSkgc1kyID0gcG9pbnQxLnk7XG5cdCAgICAgICAgICAgIHBhdGgucHVzaChbaiwgc1kxXSk7XG5cdCAgICAgICAgICAgIHBhdGgucHVzaChbaiArIDEsIHNZMl0pO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBwYXRoLnB1c2goW3gyLCB5Ml0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbG9yID0gdGhpcy5fc2V0dGluZ3MuY29sb3IuY2FsbCh0aGlzLCBkYXRhWzBdKTtcblxuXHQgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcblx0ICAgICAgICBwYXRoLnB1c2goW3gyLCBwb2ludDEueV0pO1xuXHQgICAgICAgIHBhdGgucHVzaChbcGF0aFswXVswXSwgcG9pbnQxLnldKTtcblx0ICAgICAgfSAvL2ZpbGxpbmcgYXJlYVxuXG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fc2V0dGluZ3MuYWxwaGEuY2FsbCh0aGlzLCBkYXRhWzBdKTtcblx0ICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHQgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblx0ICAgICAgdGhpcy5fcGF0aChjdHgsIHBhdGgpO1xuXG5cdCAgICAgIGN0eC5maWxsKCk7XG5cdCAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXHQgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxOyAvLyBkcmF3IGxpbmVcblxuXHQgICAgICBpZiAoY29uZmlnLmJvcmRlcikge1xuXHQgICAgICAgIGN0eC5saW5lV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMTtcblx0ICAgICAgICBpZiAoY29uZmlnLmJvcmRlckNvbG9yKSBjdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuYm9yZGVyQ29sb3IuY2FsbCh0aGlzLCBkYXRhWzBdKTtlbHNlIHRoaXMuX3NldEJvcmRlclN0eWxlcyhjdHgsIGNvbG9yKTtcblx0ICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgICAgcGF0aC5zcGxpY2UocGF0aC5sZW5ndGggLSAzKTtcblxuXHQgICAgICAgIHRoaXMuX3BhdGgoY3R4LCBwYXRoKTtcblxuXHQgICAgICAgIGN0eC5zdHJva2UoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblxuXHR2YXIgYW5pbWF0ZUR1cmF0aW9uID0gNDAwLFxuXHQgICAgY2VsbFdpZHRoID0gMzA7XG5cdHZhciBEeW5hbWljQ2hhcnQgPSB7XG5cdCAgZHluYW1pY19zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlKSBpbml0KHRoaXMpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0fTtcblx0LyoqXG5cdCAqIFNldHMgZXZlbnQgaGFuZGxlcnMgYW5kIHByb3BlcnRpZXMgZm9yIGEgc3RvY2sgY2hhcnRcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0IC0gY2hhcnQgdmlld1xuXHQgKi9cblxuXHRmdW5jdGlvbiBpbml0KGNoYXJ0KSB7XG5cdCAgaWYgKGNoYXJ0Ll9zdG9ja1JlbmRlckhhbmRsZXIpIHJldHVybjtcblx0ICB2YXIgY29uZmlnID0gY2hhcnQuX3NldHRpbmdzO1xuXHQgIGlmICghY29uZmlnLmNlbGxXaWR0aCkgY29uZmlnLmNlbGxXaWR0aCA9IGNlbGxXaWR0aDtcblx0ICBpZiAoIWNvbmZpZy5hbmltYXRlRHVyYXRpb24pIGNvbmZpZy5hbmltYXRlRHVyYXRpb24gPSBhbmltYXRlRHVyYXRpb247XG5cdCAgY29uZmlnLm9mZnNldCA9IGZhbHNlO1xuXHQgIGNoYXJ0Ll9zdG9ja1JlbmRlckhhbmRsZXIgPSBjaGFydC5hdHRhY2hFdmVudChcIm9uQmVmb3JlUmVuZGVyXCIsIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7XG5cdCAgICB2YXIgYm91bmRzID0gY2hhcnQuX2dldENoYXJ0Qm91bmRzKGNoYXJ0Ll9jb250ZW50X3dpZHRoLCBjaGFydC5fY29udGVudF9oZWlnaHQpO1xuXG5cdCAgICByZXNpemVTdG9ja0NhbnZhc2VzKGNoYXJ0KTtcblx0ICAgIGZpbHRlclN0b2NrRGF0YShkYXRhLCBib3VuZHMuc3RhcnQsIGJvdW5kcy5lbmQsIGNvbmZpZy5jZWxsV2lkdGgpO1xuXHQgICAgaWYgKHR5cGUgPT0gXCJhZGRcIikgc3RhcnRBbmltYXRpb24oY2hhcnQpO1xuXHQgIH0pO1xuXHQgIGNoYXJ0Ll9zdG9ja1hBeGlzSGFuZGxlciA9IGNoYXJ0LmF0dGFjaEV2ZW50KFwib25CZWZvcmVYQXhpc1wiLCBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgY2VsbFdpZHRoLCB5KSB7XG5cdCAgICBkcmF3WEF4aXMoY2hhcnQsIGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIGNlbGxXaWR0aCwgeSk7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSk7XG5cdH1cblx0LyoqXG5cdCAqIFN0YXJ0cyBzdG9jayBhbmltYXRpb25cblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0IC0gY2hhcnQgdmlld1xuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKGNoYXJ0KSB7XG5cdCAgdmFyIGNlbGxXaWR0aCA9IGNoYXJ0Ll9zZXR0aW5ncy5jZWxsV2lkdGg7XG5cblx0ICBpZiAoY2hhcnQuX3N0b2NrQW5pbWF0aW9uT2Zmc2V0ICE9IGNlbGxXaWR0aCkge1xuXHQgICAgY2hhcnQuX3N0b2NrQW5pbWF0aW9uT2Zmc2V0ID0gY2VsbFdpZHRoO1xuXHQgICAgY2hhcnQucmVuZGVyKCk7XG5cdCAgfVxuXG5cdCAgY2hhcnQuX3N0b2NrQW5pbWF0aW9uT2Zmc2V0ID0gMDtcblx0ICBjaGFydC5fc3RvY2tBbmltYXRpb25TdGFydCA9IG51bGw7XG5cdCAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgIWRvY3VtZW50LmhpZGRlbikgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodCkge1xuXHQgICAgYW5pbWF0ZSQyKGNoYXJ0LCB0KTtcblx0ICB9KTtcblx0ICBpZiAoIWNoYXJ0Ll9zdG9ja0FuaW1hdGVIYW5kbGVyKSBjaGFydC5fc3RvY2tBbmltYXRlSGFuZGxlciA9IGNoYXJ0LmF0dGFjaEV2ZW50KFwib25BZnRlclJlbmRlclwiLCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgYXBwbHlTdG9ja09mZnNldChjaGFydCwgZGF0YSk7XG5cdCAgfSk7XG5cdH1cblx0LyoqXG5cdCAqIEFuaW1hdGVzIGEgY2hhcnRcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0IC0gY2hhcnQgdmlld1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGltZXN0YW1wXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gYW5pbWF0ZSQyKGNoYXJ0LCB0aW1lc3RhbXApIHtcblx0ICB2YXIgcHJvZ3Jlc3MsXG5cdCAgICAgIGR1cmF0aW9uID0gY2hhcnQuX3NldHRpbmdzLmFuaW1hdGVEdXJhdGlvbixcblx0ICAgICAgY2VsbFdpZHRoID0gY2hhcnQuX3NldHRpbmdzLmNlbGxXaWR0aDtcblxuXHQgIGlmIChjZWxsV2lkdGggJiYgY2hhcnQuY291bnQoKSA+IDEpIHtcblx0ICAgIGlmICghY2hhcnQuX3N0b2NrQW5pbWF0aW9uU3RhcnQpIGNoYXJ0Ll9zdG9ja0FuaW1hdGlvblN0YXJ0ID0gdGltZXN0YW1wO1xuXHQgICAgcHJvZ3Jlc3MgPSB0aW1lc3RhbXAgLSBjaGFydC5fc3RvY2tBbmltYXRpb25TdGFydDtcblx0ICAgIGNoYXJ0Ll9zdG9ja0FuaW1hdGlvbk9mZnNldCA9IE1hdGgubWluKE1hdGgubWF4KHByb2dyZXNzIC8gZHVyYXRpb24gKiBjZWxsV2lkdGgsIDEpLCBjZWxsV2lkdGgpO1xuXHQgICAgY2hhcnQucmVuZGVyKCk7XG5cdCAgICBpZiAocHJvZ3Jlc3MgPCBkdXJhdGlvbikgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodCkge1xuXHQgICAgICBhbmltYXRlJDIoY2hhcnQsIHQpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGFuaW1hdGlvbiBvZmZzZXQgdG8gXCJzZXJpZXNcIiBhbmQgXCJ4LWF4aXNcIiBjYW52YXNlc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnQgLSBjaGFydCB2aWV3XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gZGF0YSBhcnJheVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGFwcGx5U3RvY2tPZmZzZXQoY2hhcnQsIGRhdGEpIHtcblx0ICB2YXIgY291bnQgPSBjaGFydC5jb3VudCgpLFxuXHQgICAgICBib3VuZHMgPSBjaGFydC5fZ2V0Q2hhcnRCb3VuZHMoY2hhcnQuX2NvbnRlbnRfd2lkdGgsIGNoYXJ0Ll9jb250ZW50X2hlaWdodCksXG5cdCAgICAgIGNlbGxXaWR0aCA9IGNoYXJ0Ll9zZXR0aW5ncy5jZWxsV2lkdGgsXG5cdCAgICAgIG9mZnNldCQkMSA9IGNoYXJ0Ll9zdG9ja0FuaW1hdGlvbk9mZnNldCB8fCAwLFxuXHQgICAgICBpc1Njcm9sbCA9IGRhdGEubGVuZ3RoIDwgY291bnQgfHwgKGRhdGEubGVuZ3RoIC0gMSkgKiBjZWxsV2lkdGggPiBib3VuZHMuZW5kLnggLSBib3VuZHMuc3RhcnQueDtcblxuXHQgIGZ1bmN0aW9uIHNldENhbnZhc09mZnNldChjYW52YXMsIHgwLCB4MSwgc2tpcFJpZ2h0KSB7XG5cdCAgICB2YXIgY3R4ID0gY2FudmFzLmdldENhbnZhcygpLFxuXHQgICAgICAgIGVsZW0gPSBjYW52YXMuX2NhbnZhcyxcblx0ICAgICAgICBsYWJlbHMgPSBjYW52YXMuX2NhbnZhc19sYWJlbHMsXG5cdCAgICAgICAgc2VyaWVzID0gY2FudmFzLl9jYW52YXNfc2VyaWVzOyAvLyBpZiB3ZSBuZWVkIHRvIGRpc3BsYXkgbGVzcyB2YWx1ZXMgdGhhbiB0aGV5IGFyZVxuXG5cdCAgICBpZiAob2Zmc2V0JCQxICYmIChkYXRhLmxlbmd0aCA8IGNvdW50IHx8IChkYXRhLmxlbmd0aCAtIDEpICogY2VsbFdpZHRoID4geDEgLSB4MCkpIHtcblx0ICAgICAgLy8gbW92ZSBjYW52YXMgdG8gdGhlIGxlZnRcblx0ICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gLW9mZnNldCQkMSArIFwicHhcIjtcblxuXHQgICAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgc2V0TGFiZWxzT2Zmc2V0KGxhYmVscywgb2Zmc2V0JCQxLCBzZXJpZXMpOyAvLyBjbGVhciBvdXQgb2YgdGhlIHNjYWxlIHBhcnRzXG5cblx0ICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHgwICsgb2Zmc2V0JCQxLCBlbGVtLm9mZnNldEhlaWdodCk7XG5cdCAgICAgICAgY3R4LmNsZWFyUmVjdCh4MSArIG9mZnNldCQkMSwgMCwgZWxlbS5vZmZzZXRXaWR0aCwgZWxlbS5vZmZzZXRIZWlnaHQpO1xuXHQgICAgICB9XG5cdCAgICB9IC8vIGFuaW1hdGlvbiBmb3IgdGhlIHJpZ2h0IHBhcnQgKGFkZGVkIGl0ZW0pXG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBlbGVtLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuXHQgICAgICAgIGlmICghc2tpcFJpZ2h0ICYmIG9mZnNldCQkMSAhPSBjZWxsV2lkdGgpIGN0eC5jbGVhclJlY3QoeDAgKyAoZGF0YS5sZW5ndGggLSAxKSAqIGNlbGxXaWR0aCAtIGNlbGxXaWR0aCArIG9mZnNldCQkMSwgMCwgZWxlbS5vZmZzZXRXaWR0aCwgZWxlbS5vZmZzZXRIZWlnaHQpO1xuXHQgICAgICB9IC8vIHNob3cgbGFiZWwgZm9yIHRoZSBsYXN0IGxhYmVsIGFmdGVyIGZpbmlzaGluZyBhbmltYXRpb25cblxuXG5cdCAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDEgJiYgb2Zmc2V0JCQxICYmIG9mZnNldCQkMSAhPSBjZWxsV2lkdGgpIHtcblx0ICAgICAgdmFyIGxhc3QgPSBsYWJlbHMubGVuZ3RoIC0gMTtcblx0ICAgICAgaWYgKGlzQXhpc1RpdGxlKHNlcmllcywgbGFiZWxzW2xhc3RdKSkgbGFzdCAtPSAxO1xuXHQgICAgICBsYWJlbHNbbGFzdF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGVhY2hTdG9ja0NhbnZhcyhjaGFydCwgZnVuY3Rpb24gKG5hbWUsIGNhbnZhcykge1xuXHQgICAgc2V0Q2FudmFzT2Zmc2V0KGNhbnZhcywgYm91bmRzLnN0YXJ0LngsIGJvdW5kcy5lbmQueCwgbmFtZSA9PSBcInhcIik7XG5cdCAgfSk7XG5cdCAgc2V0SHRtbE1hcFNpemVzKGNoYXJ0LCBib3VuZHMsIGlzU2Nyb2xsID8gb2Zmc2V0JCQxIDogMCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0F4aXNUaXRsZShzZXJpZXMsIGxhYmVsKSB7XG5cdCAgcmV0dXJuIHNlcmllcyA9PT0gXCJheGlzX3hcIiAmJiBsYWJlbC5jbGFzc05hbWUuaW5kZXhPZihcIndlYml4X2F4aXNfdGl0bGVfeFwiKSAhPT0gLTE7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMYWJlbHNPZmZzZXQobGFiZWxzLCBvZmZzZXQkJDEsIHNlcmllcykge1xuXHQgIGlmIChsYWJlbHMubGVuZ3RoKSB7XG5cdCAgICByZW1vdmUobGFiZWxzWzBdKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy9kb24ndCBtb3ZlIGF4aXMgdGl0bGVcblx0ICAgICAgaWYgKGlzQXhpc1RpdGxlKHNlcmllcywgbGFiZWxzW2ldKSkgY29udGludWU7XG5cdCAgICAgIGxhYmVsc1tpXS5zdHlsZS5sZWZ0ID0gbGFiZWxzW2ldLm9mZnNldExlZnQgLSBvZmZzZXQkJDEgKyBcInB4XCI7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBHZXRzIHZpc2libGUgY2hhcnQgZGF0YVxuXHQgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFuIGFycmF5IHdpdGggYWxsIGNoYXJ0IGRhdGFcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50MCAtIGEgdG9wIGxlZnQgcG9pbnQgb2YgYSBwbG90XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludDEgLSBhIGJvdHRvbSByaWdodCBwb2ludCBvZiBhIHBsb3Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNlbGxXaWR0aCAtIGEgdW5pdCB3aWR0aFxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGZpbHRlclN0b2NrRGF0YShkYXRhLCBwb2ludDAsIHBvaW50MSwgY2VsbFdpZHRoKSB7XG5cdCAgaWYgKGNlbGxXaWR0aCAmJiBkYXRhLmxlbmd0aCkge1xuXHQgICAgdmFyIGxpbWl0ID0gTWF0aC5jZWlsKChwb2ludDEueCAtIHBvaW50MC54KSAvIGNlbGxXaWR0aCk7XG5cdCAgICBpZiAoZGF0YS5sZW5ndGggPiBsaW1pdCArIDEpIGRhdGEuc3BsaWNlKDAsIGRhdGEubGVuZ3RoIC0gbGltaXQgLSAxKTtcblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIFwic2VyaWVzXCIgYW5kIFwieC1heGlzXCIgY2FudmFzZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0IC0gY2hhcnQgdmlld1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gZnVuY3Rpb24gdG8gY2FsbFxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGVhY2hTdG9ja0NhbnZhcyhjaGFydCwgZnVuYykge1xuXHQgIGlmIChjaGFydC5jYW52YXNlcykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5fc2VyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChjaGFydC5jYW52YXNlc1tpXSkgZnVuYyhpLCBjaGFydC5jYW52YXNlc1tpXSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjaGFydC5jYW52YXNlc1tcInhcIl0pIGZ1bmMoXCJ4XCIsIGNoYXJ0LmNhbnZhc2VzW1wieFwiXSk7XG5cdCAgfVxuXHR9XG5cdC8qKlxuXHQgKiBTZXQgc2l6ZXMgZm9yIGFuaW1hdGVkIGNhbnZhc2VzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydCAtIGNoYXJ0IHZpZXdcblx0ICovXG5cblxuXHRmdW5jdGlvbiByZXNpemVTdG9ja0NhbnZhc2VzKGNoYXJ0KSB7XG5cdCAgZWFjaFN0b2NrQ2FudmFzKGNoYXJ0LCBmdW5jdGlvbiAobmFtZSwgY2FudmFzKSB7XG5cdCAgICBjYW52YXMuX3Jlc2l6ZUNhbnZhcyhjaGFydC5fY29udGVudF93aWR0aCArIDIgKiBjaGFydC5fc2V0dGluZ3MuY2VsbFdpZHRoLCBjaGFydC5fY29udGVudF9oZWlnaHQpO1xuXHQgIH0pO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXQgc2l6ZXMgZm9yIGFuIGh0bWwgbWFwIG9mIGEgY2hhcnRcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0IC0gYSBjaGFydCB2aWV3XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHMgLSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHBsb3Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIGFuIG9mZnNldCB0byBhcHBseVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIHNldEh0bWxNYXBTaXplcyhjaGFydCwgYm91bmRzLCBvZmZzZXQkJDEpIHtcblx0ICBjaGFydC5fY29udGVudG9iai5faHRtbG1hcC5zdHlsZS5sZWZ0ID0gYm91bmRzLnN0YXJ0LnggLSBvZmZzZXQkJDEgKyBcInB4XCI7XG5cdCAgY2hhcnQuX2NvbnRlbnRvYmouX2h0bWxtYXAuc3R5bGUud2lkdGggPSBib3VuZHMuZW5kLnggLSBib3VuZHMuc3RhcnQueCArIG9mZnNldCQkMSArIFwicHhcIjtcblx0fVxuXHQvKipcblx0ICogUmVuZGVycyBsaW5lcyBhbmQgbGFiZWxzIG9mIGFuIHgtYXhpc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnQgLSBhIGNoYXJ0IHZpZXdcblx0ICogQHBhcmFtIHtvYmplY3R9IGN0eCAtIGEgY2FudmFzIENvbnRleHRcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBhIGRhdGEgYXJyYXlcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50MCAtIGEgdG9wIGxlZnQgcG9pbnQgb2YgYSBwbG90XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludDEgLSBhIGJvdHRvbSByaWdodCBwb2ludCBvZiBhIHBsb3Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNlbGxXaWR0aCAtIGEgd2lkdGggb2YgYSB1bml0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGFuIFwieC1heGlzXCIgbGluZVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGRyYXdYQXhpcyhjaGFydCwgY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgY2VsbFdpZHRoLCB5KSB7XG5cdCAgdmFyIGNlbnRlcixcblx0ICAgICAgaSxcblx0ICAgICAgaXNTY3JvbGwsXG5cdCAgICAgIHVuaXRQb3MsXG5cdCAgICAgIGNvbmZpZyA9IGNoYXJ0Ll9zZXR0aW5ncyxcblx0ICAgICAgeDAgPSBwb2ludDAueCAtIDAuNSxcblx0ICAgICAgeTAgPSBwYXJzZUludCh5ID8geSA6IHBvaW50MS55LCAxMCkgKyAwLjUsXG5cdCAgICAgIHgxID0gcG9pbnQxLng7XG5cdCAgaWYgKCFjb25maWcuZHluYW1pYykgcmV0dXJuIGZhbHNlO1xuXHQgIGlzU2Nyb2xsID0gKGRhdGEubGVuZ3RoIC0gMSkgKiBjZWxsV2lkdGggPiB4MSAtIHgwIHx8IGRhdGEubGVuZ3RoIDwgY2hhcnQuY291bnQoKTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB1bml0UG9zID0geDAgKyBpICogY2VsbFdpZHRoO1xuXHQgICAgY2VudGVyID0gaXNTY3JvbGwgPyBpID4gMSA6ICEhaTtcblx0ICAgIHVuaXRQb3MgPSBNYXRoLmNlaWwodW5pdFBvcykgLSAwLjU7IC8vc2NhbGUgbGFiZWxzXG5cblx0ICAgIGNoYXJ0Ll9kcmF3WEF4aXNMYWJlbCh1bml0UG9zLCB5MCwgZGF0YVtpXSwgY2VudGVyKTsgLy9kcmF3cyBhIHZlcnRpY2FsIGxpbmUgZm9yIHRoZSBob3Jpem9udGFsIHNjYWxlXG5cblxuXHQgICAgaWYgKGkgJiYgY29uZmlnLnhBeGlzLmxpbmVzLmNhbGwoY2hhcnQsIGRhdGFbaV0pKSBjaGFydC5fZHJhd1hBeGlzTGluZShjdHgsIHVuaXRQb3MsIHBvaW50MS55LCBwb2ludDAueSwgZGF0YVtpXSk7XG5cdCAgfVxuXG5cdCAgY2hhcnQuY2FudmFzZXNbXCJ4XCJdLnJlbmRlclRleHRBdCh0cnVlLCBmYWxzZSwgeDAsIHBvaW50MS55ICsgY29uZmlnLnBhZGRpbmcuYm90dG9tIC0gMywgY29uZmlnLnhBeGlzLnRpdGxlLCBcIndlYml4X2F4aXNfdGl0bGVfeFwiLCBwb2ludDEueCAtIHBvaW50MC54KTtcblxuXHQgIGNoYXJ0Ll9kcmF3TGluZShjdHgsIHgwLCB5MCwgeDEgKyAoaXNTY3JvbGwgPyBjaGFydC5fc3RvY2tBbmltYXRpb25PZmZzZXQgOiAwKSwgeTAsIGNvbmZpZy54QXhpcy5jb2xvciwgMSk7XG5cdH1cblxuXHR2YXIgYXBpJFkgPSB7XG5cdCAgbmFtZTogXCJjaGFydFwiLFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLl9zZXJpZXMgPSBbdGhpcy5fc2V0dGluZ3NdO1xuXHQgICAgdGhpcy5fbGVnZW5kX2xhYmVscyA9IFtdO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfY2hhcnRcIjtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fYWZ0ZXJfaW5pdF9jYWxsKTtcblx0ICAgIC8qcHJlc2V0Ki9cblxuXHQgICAgaWYgKGNvbmZpZy5wcmVzZXQpIHtcblx0ICAgICAgdGhpcy5fZGVmaW5lUHJlc2V0KGNvbmZpZyk7XG5cdCAgICB9IC8vIG1vdmUgc2VyaWVzIHRvIGVuZCBvZiBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgaGFzaFxuXHQgICAgLy8gc28gaXQgd2lsbCBiZSBwYXJzZWQgYWZ0ZXIgb3RoZXIgc2V0dGluZ3NcblxuXG5cdCAgICBpZiAoY29uZmlnLnNlcmllcykge1xuXHQgICAgICB2YXIgc2VyaWVzID0gY29uZmlnLnNlcmllcztcblx0ICAgICAgZGVsZXRlIGNvbmZpZy5zZXJpZXM7XG5cdCAgICAgIGNvbmZpZy5zZXJpZXMgPSBzZXJpZXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuZGF0YS5wcm92aWRlQXBpKHRoaXMsIHRydWUpO1xuXHQgIH0sXG5cdCAgX2FmdGVyX2luaXRfY2FsbDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZVVwZGF0ZWRcIiwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgYXJpYUxhYmVsOiBcImNoYXJ0XCIsXG5cdCAgICBjb2xvcjogXCJkZWZhdWx0XCIsXG5cdCAgICBhbHBoYTogXCIxXCIsXG5cdCAgICByYWRpdXM6IDAsXG5cdCAgICBsYWJlbDogZmFsc2UsXG5cdCAgICB2YWx1ZTogXCJ7b2JqLnZhbHVlfVwiLFxuXHQgICAgcGFkZGluZzoge30sXG5cdCAgICB0eXBlOiBcInBpZVwiLFxuXHQgICAgbGluZUNvbG9yOiBcIiNmZmZmZmZcIixcblx0ICAgIGNhbnQ6IDAuNSxcblx0ICAgIGJhcldpZHRoOiAzMCxcblx0ICAgIGxpbmU6IHtcblx0ICAgICAgd2lkdGg6IDIsXG5cdCAgICAgIGNvbG9yOiBcIiMxY2ExYzFcIlxuXHQgICAgfSxcblx0ICAgIGl0ZW06IHtcblx0ICAgICAgcmFkaXVzOiAzLFxuXHQgICAgICBib3JkZXJDb2xvcjogXCIjMWNhMWMxXCIsXG5cdCAgICAgIGJvcmRlcldpZHRoOiAyLFxuXHQgICAgICBjb2xvcjogXCIjZmZmZmZmXCIsXG5cdCAgICAgIGFscGhhOiAxLFxuXHQgICAgICB0eXBlOiBcInJcIixcblx0ICAgICAgc2hhZG93OiBmYWxzZVxuXHQgICAgfSxcblx0ICAgIHNoYWRvdzogZmFsc2UsXG5cdCAgICBncmFkaWVudDogZmFsc2UsXG5cdCAgICBib3JkZXI6IGZhbHNlLFxuXHQgICAgbGFiZWxPZmZzZXQ6IDIwLFxuXHQgICAgb3JpZ2luOiBcImF1dG9cIixcblx0ICAgIHNjYWxlOiBcImxpbmVhclwiXG5cdCAgfSxcblx0ICBfaWQ6IFwid2ViaXhfYXJlYV9pZFwiLFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICB3ZWJpeF9jaGFydF9sZWdlbmRfaXRlbTogZnVuY3Rpb24gKGUsIGlkLCBvYmopIHtcblx0ICAgICAgdmFyIHNlcmllcyA9IG9iai5nZXRBdHRyaWJ1dGUoXCJzZXJpZXNfaWRcIik7XG5cblx0ICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25MZWdlbmRDbGlja1wiLCBbZSwgc2VyaWVzLCBvYmpdKSkge1xuXHQgICAgICAgIGlmICh0eXBlb2Ygc2VyaWVzICE9IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fc2VyaWVzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgIHZhciBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgICAgICAgIHZhciB2YWx1ZXMgPSBjb25maWcubGVnZW5kLnZhbHVlcztcblx0ICAgICAgICAgIHZhciB0b2dnbGUgPSB2YWx1ZXMgJiYgdmFsdWVzW3Nlcmllc10udG9nZ2xlIHx8IGNvbmZpZy5sZWdlbmQudG9nZ2xlOyAvLyBoaWRlIGFjdGlvblxuXG5cdCAgICAgICAgICBpZiAodG9nZ2xlKSB7XG5cdCAgICAgICAgICAgIGlmIChvYmouY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgIT0gLTEpIHtcblx0ICAgICAgICAgICAgICB0aGlzLnNob3dTZXJpZXMoc2VyaWVzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB0aGlzLmhpZGVTZXJpZXMoc2VyaWVzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fZGJsY2xpY2s6IHt9LFxuXHQgIG9uX21vdXNlX21vdmU6IHt9LFxuXHQgIGxvY2F0ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHJldHVybiBsb2NhdGUoZSwgdGhpcy5faWQpO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICB2YXIgcmVzID0gYmFzZS5hcGkuJHNldFNpemUuY2FsbCh0aGlzLCB4LCB5KTtcblxuXHQgICAgaWYgKHJlcykge1xuXHQgICAgICBmb3IgKHZhciBjIGluIHRoaXMuY2FudmFzZXMpIHtcblx0ICAgICAgICB0aGlzLmNhbnZhc2VzW2NdLl9yZXNpemVDYW52YXModGhpcy5fY29udGVudF93aWR0aCwgdGhpcy5fY29udGVudF9oZWlnaHQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9LFxuXHQgIHR5cGVfc2V0dGVyOiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICBhc3NlcnQodGhpc1tcIiRyZW5kZXJfXCIgKyB2YWxdLCBcIkNoYXJ0IHR5cGUgaXMgbm90IHN1cHBvcnRlZCwgb3IgZXh0ZW5zaW9uIGlzIG5vdCBsb2FkZWQ6IFwiICsgdmFsKTtcblxuXHQgICAgaWYgKHR5cGVvZiB0aGlzLl9zZXR0aW5ncy5vZmZzZXQgPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy5vZmZzZXQgPSAhKHZhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcmVhXCIpICE9IC0xKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHZhbCA9PSBcInJhZGFyXCIgJiYgIXRoaXMuX3NldHRpbmdzLnlBeGlzKSB0aGlzLmRlZmluZShcInlBeGlzXCIsIHt9KTtcblxuXHQgICAgaWYgKHZhbCA9PSBcInNjYXR0ZXJcIikge1xuXHQgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnlBeGlzKSB0aGlzLmRlZmluZShcInlBeGlzXCIsIHt9KTtcblx0ICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy54QXhpcykgdGhpcy5kZWZpbmUoXCJ4QXhpc1wiLCB7fSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWw7XG5cdCAgfSxcblx0ICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlbW92ZUFsbFNlcmllcygpO1xuXHQgICAgRGVzdHJ1Y3Rpb24uZGVzdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH0sXG5cdCAgcmVtb3ZlQWxsU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNsZWFyQ2FudmFzKCk7XG5cblx0ICAgIGlmICh0aGlzLl9sZWdlbmRPYmopIHtcblx0ICAgICAgdGhpcy5fbGVnZW5kT2JqLmlubmVySFRNTCA9IFwiXCI7XG5cblx0ICAgICAgdGhpcy5fbGVnZW5kT2JqLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fbGVnZW5kT2JqKTtcblxuXHQgICAgICB0aGlzLl9sZWdlbmRPYmogPSBudWxsO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5jYW52YXNlcykge1xuXHQgICAgICB0aGlzLmNhbnZhc2VzID0ge307XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2NvbnRlbnRvYmouaW5uZXJIVE1MID0gXCJcIjtcblx0ICAgIHRoaXMuX3NlcmllcyA9IFtdO1xuXHQgIH0sXG5cdCAgY2xlYXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLmNhbnZhc2VzICYmIF90eXBlb2YodGhpcy5jYW52YXNlcykgPT0gXCJvYmplY3RcIikgZm9yICh2YXIgYyBpbiB0aGlzLmNhbnZhc2VzKSB7XG5cdCAgICAgIHRoaXMuY2FudmFzZXNbY10uY2xlYXJDYW52YXMoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKGlkLCBjaGFuZ2VzLCB0eXBlKSB7XG5cdCAgICB2YXIgYm91bmRzLCBkYXRhLCBtYXAsIHRlbXA7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSkgcmV0dXJuO1xuXHQgICAgZGF0YSA9IHRoaXMuX2dldENoYXJ0RGF0YSgpO1xuXHQgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUmVuZGVyXCIsIFtkYXRhLCB0eXBlXSkpIHJldHVybjtcblxuXHQgICAgaWYgKHRoaXMuY2FudmFzZXMgJiYgX3R5cGVvZih0aGlzLmNhbnZhc2VzKSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jYW52YXNlcykge1xuXHQgICAgICAgIHRoaXMuY2FudmFzZXNbaV0uY2xlYXJDYW52YXMoKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHRoaXMuY2FudmFzZXMgPSB7fTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmxlZ2VuZCkge1xuXHQgICAgICBpZiAoIXRoaXMuY2FudmFzZXNbXCJsZWdlbmRcIl0pIHRoaXMuY2FudmFzZXNbXCJsZWdlbmRcIl0gPSB0aGlzLl9jcmVhdGVDYW52YXMoXCJsZWdlbmRcIik7XG5cblx0ICAgICAgdGhpcy5fZHJhd0xlZ2VuZCh0aGlzLmRhdGEuZ2V0UmFuZ2UoKSwgdGhpcy5fY29udGVudF93aWR0aCwgdGhpcy5fY29udGVudF9oZWlnaHQpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9tYXAgPSBtYXAgPSBuZXcgSHRtbE1hcCh0aGlzLl9pZCk7XG5cdCAgICB0ZW1wID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICBib3VuZHMgPSB0aGlzLl9nZXRDaGFydEJvdW5kcyh0aGlzLl9jb250ZW50X3dpZHRoLCB0aGlzLl9jb250ZW50X2hlaWdodCk7XG5cblx0ICAgIGlmICh0aGlzLl9zZXJpZXMpIHtcblx0ICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX3Nlcmllcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHRoaXMuX3Nlcmllc1tfaV07XG5cdCAgICAgICAgaWYgKCF0aGlzLmNhbnZhc2VzW19pXSkgdGhpcy5jYW52YXNlc1tfaV0gPSB0aGlzLl9jcmVhdGVDYW52YXModGhpcy5uYW1lICsgXCIgXCIgKyBfaSwgXCJ6LWluZGV4OlwiICsgKDIgKyBfaSksIG51bGwsIF9pLCB0aGlzLl9zZXR0aW5ncy5hcmlhTGFiZWwpO1xuXG5cdCAgICAgICAgdGhpc1tcIiRyZW5kZXJfXCIgKyB0aGlzLl9zZXR0aW5ncy50eXBlXSh0aGlzLmNhbnZhc2VzW19pXS5nZXRDYW52YXMoKSwgZGF0YSwgYm91bmRzLnN0YXJ0LCBib3VuZHMuZW5kLCBfaSwgbWFwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBtYXAucmVuZGVyKHRoaXMuX2NvbnRlbnRvYmopO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5sYXN0Q2hpbGQuc3R5bGUuekluZGV4ID0gMTAwO1xuXG5cdCAgICB0aGlzLl9hcHBseUJvdW5kcyh0aGlzLl9jb250ZW50b2JqLmxhc3RDaGlsZCwgYm91bmRzKTtcblxuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFtkYXRhXSk7XG5cdCAgICB0aGlzLl9zZXR0aW5ncyA9IHRlbXA7IC8vIGhpZGUgaGlkZGVuIHNlcmllc1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGVnZW5kICYmIHRoaXMuX3NldHRpbmdzLmxlZ2VuZC52YWx1ZXMpIHtcblx0ICAgICAgdmFyIHNlcmllcyA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZC52YWx1ZXM7XG5cblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc2VyaWVzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICBpZiAoc2VyaWVzW19pMl0uJGhpZGRlbikgdGhpcy5oaWRlU2VyaWVzKF9pMik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9hcHBseUJvdW5kczogZnVuY3Rpb24gKGVsZW0sIGJvdW5kcykge1xuXHQgICAgdmFyIHN0eWxlID0ge307XG5cdCAgICBzdHlsZS5sZWZ0ID0gYm91bmRzLnN0YXJ0Lng7XG5cdCAgICBzdHlsZS50b3AgPSBib3VuZHMuc3RhcnQueTtcblx0ICAgIHN0eWxlLndpZHRoID0gYm91bmRzLmVuZC54IC0gYm91bmRzLnN0YXJ0Lng7XG5cdCAgICBzdHlsZS5oZWlnaHQgPSBib3VuZHMuZW5kLnkgLSBib3VuZHMuc3RhcnQueTtcblxuXHQgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuXHQgICAgICBlbGVtLnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF0gKyBcInB4XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0Q2hhcnREYXRhOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYXhpcywgYXhpc0NvbmZpZywgY29uZmlnLCBkYXRhLCBpLCBuZXdEYXRhLCBzdGFydCwgdW5pdHMsIHZhbHVlLCB2YWx1ZXNIYXNoO1xuXHQgICAgZGF0YSA9IHRoaXMuZGF0YS5nZXRSYW5nZSgpO1xuXHQgICAgYXhpcyA9IHRoaXMuX3NldHRpbmdzLnR5cGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYmFyaFwiKSAhPSAtMSA/IFwieUF4aXNcIiA6IFwieEF4aXNcIjtcblx0ICAgIGF4aXNDb25maWcgPSB0aGlzLl9zZXR0aW5nc1theGlzXTtcblxuXHQgICAgaWYgKGF4aXNDb25maWcgJiYgYXhpc0NvbmZpZy51bml0cyAmJiBfdHlwZW9mKGF4aXNDb25maWcudW5pdHMpID09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgY29uZmlnID0gYXhpc0NvbmZpZy51bml0cztcblx0ICAgICAgdW5pdHMgPSBbXTtcblxuXHQgICAgICBpZiAodHlwZW9mIGNvbmZpZy5zdGFydCAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25maWcuZW5kICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbmZpZy5uZXh0ICE9IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgICBzdGFydCA9IGNvbmZpZy5zdGFydDtcblxuXHQgICAgICAgIHdoaWxlIChzdGFydCA8PSBjb25maWcuZW5kKSB7XG5cdCAgICAgICAgICB1bml0cy5wdXNoKHN0YXJ0KTtcblx0ICAgICAgICAgIHN0YXJ0ID0gY29uZmlnLm5leHQuY2FsbCh0aGlzLCBzdGFydCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb25maWcpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0ICAgICAgICB1bml0cyA9IGNvbmZpZztcblx0ICAgICAgfVxuXG5cdCAgICAgIG5ld0RhdGEgPSBbXTtcblxuXHQgICAgICBpZiAodW5pdHMubGVuZ3RoKSB7XG5cdCAgICAgICAgdmFsdWUgPSBheGlzQ29uZmlnLnZhbHVlO1xuXHQgICAgICAgIHZhbHVlc0hhc2ggPSB7fTtcblxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB2YWx1ZXNIYXNoW3ZhbHVlKGRhdGFbaV0pXSA9IGk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc0hhc2hbdW5pdHNbaV1dICE9IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgICAgICAgZGF0YVt2YWx1ZXNIYXNoW3VuaXRzW2ldXV0uJHVuaXQgPSB1bml0c1tpXTtcblx0ICAgICAgICAgICAgbmV3RGF0YS5wdXNoKGRhdGFbdmFsdWVzSGFzaFt1bml0c1tpXV1dKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG5ld0RhdGEucHVzaCh7XG5cdCAgICAgICAgICAgICAgJHVuaXQ6IHVuaXRzW2ldXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBuZXdEYXRhO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YTtcblx0ICB9LFxuXHQgIHNlcmllc19zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChfdHlwZW9mKGNvbmZpZykgIT0gXCJvYmplY3RcIikge1xuXHQgICAgICBhc3NlcnQoY29uZmlnLCBcIkNoYXJ0IDo6IFNlcmllcyBtdXN0IGJlIGFuIGFycmF5IG9yIG9iamVjdFwiKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3BhcnNlU2V0dGluZ3MoIWNvbmZpZy5sZW5ndGggPyBjb25maWcgOiBjb25maWdbMF0pO1xuXG5cdCAgICAgIHRoaXMuX3NlcmllcyA9IFt0aGlzLl9zZXR0aW5nc107XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb25maWcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLmFkZFNlcmllcyhjb25maWdbaV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICB2YWx1ZV9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIHhWYWx1ZV9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIHlWYWx1ZV9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuZGVmaW5lKFwidmFsdWVcIiwgY29uZmlnKTtcblx0ICB9LFxuXHQgIGFscGhhX3NldHRlcjogdGVtcGxhdGUsXG5cdCAgbGFiZWxfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBsaW5lQ29sb3Jfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBib3JkZXJDb2xvcl9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIHBpZUlubmVyVGV4dF9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIGdyYWRpZW50X3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgaWYgKHR5cGVvZiBjb25maWcgIT0gXCJmdW5jdGlvblwiICYmIGNvbmZpZyAmJiBjb25maWcgPT09IHRydWUpIGNvbmZpZyA9IFwibGlnaHRcIjtcblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICBjb2xvcm1hcDoge1xuXHQgICAgXCJSQUlOQk9XXCI6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIHBvcyQkMSA9IE1hdGguZmxvb3IodGhpcy5nZXRJbmRleEJ5SWQob2JqLmlkKSAvIHRoaXMuY291bnQoKSAqIDE1MzYpO1xuXHQgICAgICBpZiAocG9zJCQxID09IDE1MzYpIHBvcyQkMSAtPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fcmFpbmJvd1tNYXRoLmZsb29yKHBvcyQkMSAvIDI1NildKHBvcyQkMSAlIDI1Nik7XG5cdCAgICB9LFxuXHQgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIGNvdW50ID0gdGhpcy5jb3VudCgpO1xuXHQgICAgICB2YXIgY29sb3JzQ291bnQgPSB0aGlzLl9kZWZDb2xvcnMubGVuZ3RoO1xuXHQgICAgICB2YXIgaSA9IHRoaXMuZ2V0SW5kZXhCeUlkKG9iai5pZCk7XG5cblx0ICAgICAgaWYgKGNvbG9yc0NvdW50ID4gY291bnQpIHtcblx0ICAgICAgICBpZiAoaSkge1xuXHQgICAgICAgICAgaWYgKGkgPCBjb2xvcnNDb3VudCAtIGNvdW50KSBpID0gdGhpcy5fZGVmQ29sb3JzQ3Vyc29yICsgMjtlbHNlIGkgPSB0aGlzLl9kZWZDb2xvcnNDdXJzb3IgKyAxO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2RlZkNvbG9yc0N1cnNvciA9IGk7XG5cdCAgICAgIH0gZWxzZSBpID0gaSAlIGNvbG9yc0NvdW50O1xuXG5cdCAgICAgIHJldHVybiB0aGlzLl9kZWZDb2xvcnNbaV07XG5cdCAgICB9XG5cdCAgfSxcblx0ICBjb2xvcl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY29sb3JtYXBbdmFsdWVdIHx8IHRlbXBsYXRlKHZhbHVlKTtcblx0ICB9LFxuXHQgIGZpbGxfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiAhdmFsdWUgfHwgdmFsdWUgPT0gXCIwXCIgPyBmYWxzZSA6IHRlbXBsYXRlKHZhbHVlKTtcblx0ICB9LFxuXHQgIF9kZWZpbmVQcmVzZXQ6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHRoaXMuZGVmaW5lKFwicHJlc2V0XCIsIG9iai5wcmVzZXQpO1xuXHQgICAgZGVsZXRlIG9iai5wcmVzZXQ7XG5cdCAgfSxcblx0ICBwcmVzZXRfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBhLCBiLCBwcmVzZXQ7XG5cdCAgICB0aGlzLmRlZmF1bHRzID0gZXhwb3J0cy5leHRlbmQoe30sIHRoaXMuZGVmYXVsdHMpO1xuXHQgICAgcHJlc2V0ID0gdGhpcy5wcmVzZXRzW3ZhbHVlXTtcblxuXHQgICAgaWYgKF90eXBlb2YocHJlc2V0KSA9PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgIGZvciAoYSBpbiBwcmVzZXQpIHtcblx0ICAgICAgICBpZiAoX3R5cGVvZihwcmVzZXRbYV0pID09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgIGlmICghdGhpcy5kZWZhdWx0c1thXSB8fCBfdHlwZW9mKHRoaXMuZGVmYXVsdHNbYV0pICE9IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgdGhpcy5kZWZhdWx0c1thXSA9IGV4cG9ydHMuZXh0ZW5kKHt9LCBwcmVzZXRbYV0pO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5kZWZhdWx0c1thXSA9IGV4cG9ydHMuZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRzW2FdKTtcblxuXHQgICAgICAgICAgICBmb3IgKGIgaW4gcHJlc2V0W2FdKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0c1thXVtiXSA9IHByZXNldFthXVtiXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0aGlzLmRlZmF1bHRzW2FdID0gcHJlc2V0W2FdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgbGVnZW5kX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgaWYgKCFjb25maWcpIHtcblx0ICAgICAgaWYgKHRoaXMuX2xlZ2VuZE9iaikge1xuXHQgICAgICAgIHRoaXMuX2xlZ2VuZE9iai5pbm5lckhUTUwgPSBcIlwiO1xuXHQgICAgICAgIHRoaXMuX2xlZ2VuZE9iaiA9IG51bGw7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmIChfdHlwZW9mKGNvbmZpZykgIT0gXCJvYmplY3RcIikgLy9hbGxvdyB0byB1c2UgdGVtcGxhdGUgc3RyaW5nIGluc3RlYWQgb2Ygb2JqZWN0XG5cdCAgICAgIGNvbmZpZyA9IHtcblx0ICAgICAgICB0ZW1wbGF0ZTogY29uZmlnXG5cdCAgICAgIH07XG5cblx0ICAgIHRoaXMuX21lcmdlU2V0dGluZ3MoY29uZmlnLCB7XG5cdCAgICAgIHdpZHRoOiAxNTAsXG5cdCAgICAgIGhlaWdodDogMTgsXG5cdCAgICAgIGxheW91dDogXCJ5XCIsXG5cdCAgICAgIGFsaWduOiBcImxlZnRcIixcblx0ICAgICAgdmFsaWduOiBcImJvdHRvbVwiLFxuXHQgICAgICB0ZW1wbGF0ZTogXCJcIixcblx0ICAgICAgdG9nZ2xlOiB0aGlzLl9zZXR0aW5ncy50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInN0YWNrZWRcIikgIT0gLTEgPyBcIlwiIDogXCJoaWRlXCIsXG5cdCAgICAgIG1hcmtlcjoge1xuXHQgICAgICAgIHR5cGU6IFwic3F1YXJlXCIsXG5cdCAgICAgICAgd2lkdGg6IDE1LFxuXHQgICAgICAgIGhlaWdodDogMTUsXG5cdCAgICAgICAgcmFkaXVzOiAzXG5cdCAgICAgIH0sXG5cdCAgICAgIG1hcmdpbjogNCxcblx0ICAgICAgcGFkZGluZzogM1xuXHQgICAgfSk7XG5cblx0ICAgIGNvbmZpZy50ZW1wbGF0ZSA9IHRlbXBsYXRlKGNvbmZpZy50ZW1wbGF0ZSk7XG5cdCAgICByZXR1cm4gY29uZmlnO1xuXHQgIH0sXG5cdCAgaXRlbV9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChfdHlwZW9mKGNvbmZpZykgIT0gXCJvYmplY3RcIikgY29uZmlnID0ge1xuXHQgICAgICBjb2xvcjogY29uZmlnLFxuXHQgICAgICBib3JkZXJDb2xvcjogY29uZmlnXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9tZXJnZVNldHRpbmdzKGNvbmZpZywgZXhwb3J0cy5leHRlbmQoe30sIHRoaXMuZGVmYXVsdHMuaXRlbSkpO1xuXG5cdCAgICB2YXIgc2V0dGluZ3MgPSBbXCJhbHBoYVwiLCBcImJvcmRlckNvbG9yXCIsIFwiY29sb3JcIiwgXCJyYWRpdXNcIiwgXCJ0eXBlXCJdO1xuXG5cdCAgICB0aGlzLl9jb252ZXJUb1RlbXBsYXRlKHNldHRpbmdzLCBjb25maWcpO1xuXG5cdCAgICByZXR1cm4gY29uZmlnO1xuXHQgIH0sXG5cdCAgbGluZV9zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChfdHlwZW9mKGNvbmZpZykgIT0gXCJvYmplY3RcIikgY29uZmlnID0ge1xuXHQgICAgICBjb2xvcjogY29uZmlnXG5cdCAgICB9O1xuXHQgICAgY29uZmlnID0gZXhwb3J0cy5leHRlbmQoY29uZmlnLCB0aGlzLmRlZmF1bHRzLmxpbmUpO1xuXHQgICAgY29uZmlnLmNvbG9yID0gdGVtcGxhdGUoY29uZmlnLmNvbG9yKTtcblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICBwYWRkaW5nX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgaWYgKF90eXBlb2YoY29uZmlnKSAhPSBcIm9iamVjdFwiKSBjb25maWcgPSB7XG5cdCAgICAgIGxlZnQ6IGNvbmZpZyxcblx0ICAgICAgcmlnaHQ6IGNvbmZpZyxcblx0ICAgICAgdG9wOiBjb25maWcsXG5cdCAgICAgIGJvdHRvbTogY29uZmlnXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9tZXJnZVNldHRpbmdzKGNvbmZpZywge1xuXHQgICAgICBsZWZ0OiA1MCxcblx0ICAgICAgcmlnaHQ6IDIwLFxuXHQgICAgICB0b3A6IDM1LFxuXHQgICAgICBib3R0b206IDQwXG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGNvbmZpZztcblx0ICB9LFxuXHQgIHhBeGlzX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgaWYgKCFjb25maWcpIHJldHVybiBmYWxzZTtcblx0ICAgIGlmIChfdHlwZW9mKGNvbmZpZykgIT0gXCJvYmplY3RcIikgY29uZmlnID0ge1xuXHQgICAgICB0ZW1wbGF0ZTogY29uZmlnXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9tZXJnZVNldHRpbmdzKGNvbmZpZywge1xuXHQgICAgICB0aXRsZTogXCJcIixcblx0ICAgICAgY29sb3I6IFwiI2VkZWZmMFwiLFxuXHQgICAgICBsaW5lQ29sb3I6IFwiI2VkZWZmMFwiLFxuXHQgICAgICB0ZW1wbGF0ZTogXCJ7b2JqfVwiLFxuXHQgICAgICBsaW5lczogdHJ1ZVxuXHQgICAgfSk7XG5cblx0ICAgIHZhciB0ZW1wbGF0ZXMgPSBbXCJsaW5lQ29sb3JcIiwgXCJ0ZW1wbGF0ZVwiLCBcImxpbmVzXCJdO1xuXG5cdCAgICB0aGlzLl9jb252ZXJUb1RlbXBsYXRlKHRlbXBsYXRlcywgY29uZmlnKTtcblxuXHQgICAgdGhpcy5fY29uZmlnWEF4aXMgPSBleHBvcnRzLmV4dGVuZCh7fSwgY29uZmlnKTtcblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICB5QXhpc19zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuX21lcmdlU2V0dGluZ3MoY29uZmlnLCB7XG5cdCAgICAgIHRpdGxlOiBcIlwiLFxuXHQgICAgICBjb2xvcjogXCIjZWRlZmYwXCIsXG5cdCAgICAgIGxpbmVDb2xvcjogXCIjZWRlZmYwXCIsXG5cdCAgICAgIHRlbXBsYXRlOiBcIntvYmp9XCIsXG5cdCAgICAgIGxpbmVzOiB0cnVlLFxuXHQgICAgICBiZzogXCIjZmZmZmZmXCJcblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgdGVtcGxhdGVzID0gW1wibGluZUNvbG9yXCIsIFwidGVtcGxhdGVcIiwgXCJsaW5lc1wiLCBcImJnXCJdO1xuXG5cdCAgICB0aGlzLl9jb252ZXJUb1RlbXBsYXRlKHRlbXBsYXRlcywgY29uZmlnKTtcblxuXHQgICAgdGhpcy5fY29uZmlnWUF4aXMgPSBleHBvcnRzLmV4dGVuZCh7fSwgY29uZmlnKTtcblx0ICAgIHJldHVybiBjb25maWc7XG5cdCAgfSxcblx0ICBfY29udmVyVG9UZW1wbGF0ZTogZnVuY3Rpb24gKGFyciwgY29uZmlnKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHQgICAgICBjb25maWdbYXJyW2ldXSA9IHRlbXBsYXRlKGNvbmZpZ1thcnJbaV1dKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jcmVhdGVDYW52YXM6IGZ1bmN0aW9uIChuYW1lLCBzdHlsZSwgY29udGFpbmVyLCBpbmRleCQkMSwgdGl0bGUpIHtcblx0ICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyIHx8IHRoaXMuX2NvbnRlbnRvYmosXG5cdCAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgIHRpdGxlOiBpc1VuZGVmaW5lZCh0aXRsZSkgPyBuYW1lIDogdGl0bGUgfHwgXCJcIixcblx0ICAgICAgc2VyaWVzOiBpbmRleCQkMSxcblx0ICAgICAgc3R5bGU6IHN0eWxlIHx8IFwiXCIsXG5cdCAgICAgIHdpZHRoOiB0aGlzLl9jb250ZW50X3dpZHRoLFxuXHQgICAgICBoZWlnaHQ6IHRoaXMuX2NvbnRlbnRfaGVpZ2h0XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIG5ldyBDYW52YXMocGFyYW1zKTtcblx0ICB9LFxuXHQgIF9kcmF3U2NhbGVzOiBmdW5jdGlvbiAoZGF0YSwgcG9pbnQwLCBwb2ludDEsIHN0YXJ0LCBlbmQsIGNlbGxXaWR0aCkge1xuXHQgICAgdmFyIGN0eCxcblx0ICAgICAgICB5ID0gMDtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnlBeGlzKSB7XG5cdCAgICAgIGlmICghdGhpcy5jYW52YXNlc1tcInlcIl0pIHRoaXMuY2FudmFzZXNbXCJ5XCJdID0gdGhpcy5fY3JlYXRlQ2FudmFzKFwiYXhpc195XCIpO1xuXHQgICAgICB5ID0gdGhpcy5fZHJhd1lBeGlzKHRoaXMuY2FudmFzZXNbXCJ5XCJdLmdldENhbnZhcygpLCBkYXRhLCBwb2ludDAsIHBvaW50MSwgc3RhcnQsIGVuZCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy54QXhpcykge1xuXHQgICAgICBpZiAoIXRoaXMuY2FudmFzZXNbXCJ4XCJdKSB0aGlzLmNhbnZhc2VzW1wieFwiXSA9IHRoaXMuX2NyZWF0ZUNhbnZhcyhcImF4aXNfeFwiKTtcblx0ICAgICAgY3R4ID0gdGhpcy5jYW52YXNlc1tcInhcIl0uZ2V0Q2FudmFzKCk7XG5cdCAgICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlWEF4aXNcIiwgW2N0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIGNlbGxXaWR0aCwgeV0pKSB0aGlzLl9kcmF3WEF4aXMoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgY2VsbFdpZHRoLCB5KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHk7XG5cdCAgfSxcblx0ICBfZHJhd1hBeGlzOiBmdW5jdGlvbiAoY3R4LCBkYXRhLCBwb2ludDAsIHBvaW50MSwgY2VsbFdpZHRoLCB5KSB7XG5cdCAgICB2YXIgaSxcblx0ICAgICAgICB1bml0UG9zLFxuXHQgICAgICAgIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzLFxuXHQgICAgICAgIHgwID0gcG9pbnQwLnggLSAwLjUsXG5cdCAgICAgICAgeTAgPSBwYXJzZUludCh5ID8geSA6IHBvaW50MS55LCAxMCkgKyAwLjUsXG5cdCAgICAgICAgeDEgPSBwb2ludDEueCxcblx0ICAgICAgICBjZW50ZXIgPSB0cnVlLFxuXHQgICAgICAgIGxhYmVsWSA9IGNvbmZpZy50eXBlID09IFwic3RhY2tlZEJhclwiID8gcG9pbnQxLnkgKyAwLjUgOiB5MDtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGNvbmZpZy5vZmZzZXQgPT09IHRydWUpIHVuaXRQb3MgPSB4MCArIGNlbGxXaWR0aCAvIDIgKyBpICogY2VsbFdpZHRoO2Vsc2Uge1xuXHQgICAgICAgIHVuaXRQb3MgPSBpID09IGRhdGEubGVuZ3RoIC0gMSAmJiAhY29uZmlnLmNlbGxXaWR0aCA/IHBvaW50MS54IDogeDAgKyBpICogY2VsbFdpZHRoO1xuXHQgICAgICAgIGNlbnRlciA9ICEhaTtcblx0ICAgICAgfVxuXHQgICAgICB1bml0UG9zID0gTWF0aC5jZWlsKHVuaXRQb3MpIC0gMC41O1xuXHQgICAgICAvKnNjYWxlIGxhYmVscyovXG5cblx0ICAgICAgdmFyIHRvcCA9IGNvbmZpZy5vcmlnaW4gIT0gXCJhdXRvXCIgJiYgY29uZmlnLnR5cGUgPT0gXCJiYXJcIiAmJiBwYXJzZUZsb2F0KGNvbmZpZy52YWx1ZShkYXRhW2ldKSkgPCBjb25maWcub3JpZ2luO1xuXG5cdCAgICAgIHRoaXMuX2RyYXdYQXhpc0xhYmVsKHVuaXRQb3MsIGxhYmVsWSwgZGF0YVtpXSwgY2VudGVyLCB0b3ApO1xuXHQgICAgICAvKmRyYXdzIGEgdmVydGljYWwgbGluZSBmb3IgdGhlIGhvcml6b250YWwgc2NhbGUqL1xuXG5cblx0ICAgICAgaWYgKChjb25maWcub2Zmc2V0IHx8IGkgfHwgY29uZmlnLmNlbGxXaWR0aCkgJiYgY29uZmlnLnhBeGlzLmxpbmVzLmNhbGwodGhpcywgZGF0YVtpXSkpIHRoaXMuX2RyYXdYQXhpc0xpbmUoY3R4LCB1bml0UG9zLCBwb2ludDEueSwgcG9pbnQwLnksIGRhdGFbaV0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbnZhc2VzW1wieFwiXS5yZW5kZXJUZXh0QXQodHJ1ZSwgZmFsc2UsIHgwLCBwb2ludDEueSArIGNvbmZpZy5wYWRkaW5nLmJvdHRvbSAtIDMsIGNvbmZpZy54QXhpcy50aXRsZSwgXCJ3ZWJpeF9heGlzX3RpdGxlX3hcIiwgcG9pbnQxLnggLSBwb2ludDAueCk7XG5cblx0ICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgeDAsIHkwLCB4MSwgeTAsIGNvbmZpZy54QXhpcy5jb2xvciwgMSk7XG5cdCAgICAvKnRoZSByaWdodCBib3JkZXIgaW4gbGluZXMgaW4gc2NhbGUgYXJlIGVuYWJsZWQqL1xuXG5cblx0ICAgIGlmICghY29uZmlnLnhBeGlzLmxpbmVzLmNhbGwodGhpcywge30pIHx8ICFjb25maWcub2Zmc2V0KSByZXR1cm47XG5cblx0ICAgIHRoaXMuX2RyYXdMaW5lKGN0eCwgeDEgKyAwLjUsIHBvaW50MS55LCB4MSArIDAuNSwgcG9pbnQwLnkgKyAwLjUsIGNvbmZpZy54QXhpcy5saW5lQ29sb3IuY2FsbCh0aGlzLCB7fSksIDEpO1xuXHQgIH0sXG5cdCAgX2RyYXdZQXhpczogZnVuY3Rpb24gKGN0eCwgZGF0YSwgcG9pbnQwLCBwb2ludDEsIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBzdGVwO1xuXHQgICAgdmFyIHNjYWxlUGFyYW0gPSB7fTtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MueUF4aXMpIHJldHVybjtcblx0ICAgIHZhciB4MCA9IHBvaW50MC54IC0gMC41O1xuXHQgICAgdmFyIHkwID0gcG9pbnQxLnk7XG5cdCAgICB2YXIgeTEgPSBwb2ludDAueTtcblx0ICAgIHZhciBsaW5lWCA9IHBvaW50MS55ICsgMC41OyAvL3RoaXMuX2RyYXdMaW5lKGN0eCx4MCx5MCx4MCx5MSx0aGlzLl9zZXR0aW5ncy55QXhpcy5jb2xvciwxKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0ZXApIHN0ZXAgPSBwYXJzZUZsb2F0KHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0ZXApO1xuXG5cdCAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZ1lBeGlzLnN0ZXAgPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdGhpcy5fY29uZmlnWUF4aXMuc3RhcnQgPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdGhpcy5fY29uZmlnWUF4aXMuZW5kID09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgc2NhbGVQYXJhbSA9IHRoaXMuX2NhbGN1bGF0ZVNjYWxlKHN0YXJ0LCBlbmQpO1xuXHQgICAgICBzdGFydCA9IHNjYWxlUGFyYW0uc3RhcnQ7XG5cdCAgICAgIGVuZCA9IHNjYWxlUGFyYW0uZW5kO1xuXHQgICAgICBzdGVwID0gc2NhbGVQYXJhbS5zdGVwO1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy55QXhpcy5lbmQgPSBlbmQ7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLnNjYWxlID09IFwibG9nYXJpdGhtaWNcIikgdGhpcy5fbG9nU2NhbGVDYWxjID0gdHJ1ZTtcblxuXHQgICAgdGhpcy5fc2V0WUF4aXNUaXRsZShwb2ludDAsIHBvaW50MSk7XG5cblx0ICAgIGlmIChzdGVwID09PSAwKSByZXR1cm47XG5cblx0ICAgIGlmIChlbmQgPT0gc3RhcnQpIHtcblx0ICAgICAgcmV0dXJuIHkwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc3RlcEhlaWdodCA9ICh5MCAtIHkxKSAqIHN0ZXAgLyAoZW5kIC0gc3RhcnQpO1xuXHQgICAgdmFyIGMgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpICs9IHN0ZXApIHtcblx0ICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbG9nU2NhbGVDYWxjID8gTWF0aC5wb3coMTAsIGkpIDogaTtcblx0ICAgICAgaWYgKHNjYWxlUGFyYW0uZml4TnVtKSB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpLnRvRml4ZWQoc2NhbGVQYXJhbS5maXhOdW0pO1xuXHQgICAgICB2YXIgeWkgPSBNYXRoLmZsb29yKHkwIC0gYyAqIHN0ZXBIZWlnaHQpICsgMC41O1xuXHQgICAgICAvKmNhbnZhcyBsaW5lIGZpeCovXG5cblx0ICAgICAgaWYgKCEoaSA9PSBzdGFydCAmJiB0aGlzLl9zZXR0aW5ncy5vcmlnaW4gPT0gXCJhdXRvXCIpICYmIHRoaXMuX3NldHRpbmdzLnlBeGlzLmxpbmVzLmNhbGwodGhpcywgaSkpIHRoaXMuX2RyYXdMaW5lKGN0eCwgeDAsIHlpLCBwb2ludDEueCwgeWksIHRoaXMuX3NldHRpbmdzLnlBeGlzLmxpbmVDb2xvci5jYWxsKHRoaXMsIGkpLCAxKTtcblx0ICAgICAgaWYgKGkgPT0gdGhpcy5fc2V0dGluZ3Mub3JpZ2luKSBsaW5lWCA9IHlpO1xuXHQgICAgICAvKmNvcnJlY3Rpb24gZm9yIEpTIGZsb2F0IGNhbGN1bGF0aW9uKi9cblxuXHQgICAgICBpZiAoc3RlcCA8IDEgJiYgIXRoaXMuX2xvZ1NjYWxlQ2FsYykge1xuXHQgICAgICAgIHZhciBwb3dlciA9IE1hdGgubWluKE1hdGguZmxvb3IodGhpcy5fbG9nMTAoc3RlcCkpLCBzdGFydCA8PSAwID8gMCA6IE1hdGguZmxvb3IodGhpcy5fbG9nMTAoc3RhcnQpKSk7XG5cdCAgICAgICAgdmFyIGNvcnIgPSBNYXRoLnBvdygxMCwgLXBvd2VyKTtcblx0ICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiBjb3JyKSAvIGNvcnI7XG5cdCAgICAgICAgaSA9IHZhbHVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYW52YXNlc1tcInlcIl0ucmVuZGVyVGV4dCgwLCB5aSAtIDUsIHRoaXMuX3NldHRpbmdzLnlBeGlzLnRlbXBsYXRlKHZhbHVlLnRvU3RyaW5nKCkpLCBcIndlYml4X2F4aXNfaXRlbV95XCIsIHBvaW50MC54IC0gNSk7XG5cdCAgICAgIGMrKztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB4MCwgeTAgKyAxLCB4MCwgeTEsIHRoaXMuX3NldHRpbmdzLnlBeGlzLmNvbG9yLCAxKTtcblxuXHQgICAgcmV0dXJuIGxpbmVYO1xuXHQgIH0sXG5cdCAgX3NldFlBeGlzVGl0bGU6IGZ1bmN0aW9uIChwb2ludDAsIHBvaW50MSkge1xuXHQgICAgdmFyIGNsYXNzTmFtZSA9IFwid2ViaXhfYXhpc190aXRsZV95XCI7XG5cdCAgICB2YXIgdGV4dCA9IHRoaXMuY2FudmFzZXNbXCJ5XCJdLnJlbmRlclRleHRBdChcIm1pZGRsZVwiLCBmYWxzZSwgMCwgcGFyc2VJbnQoKHBvaW50MS55IC0gcG9pbnQwLnkpIC8gMiArIHBvaW50MC55LCAxMCksIHRoaXMuX3NldHRpbmdzLnlBeGlzLnRpdGxlLCBjbGFzc05hbWUpO1xuXHQgICAgaWYgKHRleHQpIHRleHQuc3R5bGUubGVmdCA9IChlbnYudHJhbnNmb3JtID8gKHRleHQub2Zmc2V0SGVpZ2h0IC0gdGV4dC5vZmZzZXRXaWR0aCkgLyAyIDogMCkgKyBcInB4XCI7XG5cdCAgfSxcblx0ICBfY2FsY3VsYXRlTG9nU2NhbGU6IGZ1bmN0aW9uIChubWluLCBubWF4KSB7XG5cdCAgICB2YXIgc3RhcnRQb3dlciA9IE1hdGguZmxvb3IodGhpcy5fbG9nMTAobm1pbikpO1xuXHQgICAgdmFyIGVuZFBvd2VyID0gTWF0aC5jZWlsKHRoaXMuX2xvZzEwKG5tYXgpKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHN0YXJ0OiBzdGFydFBvd2VyLFxuXHQgICAgICBzdGVwOiAxLFxuXHQgICAgICBlbmQ6IGVuZFBvd2VyXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX25vcm1TdGVwOiBmdW5jdGlvbiAoc3RlcCkge1xuXHQgICAgdmFyIHBvd2VyID0gTWF0aC5mbG9vcih0aGlzLl9sb2cxMChzdGVwKSk7XG5cdCAgICB2YXIgY2FsY3VsU3RlcCA9IE1hdGgucG93KDEwLCBwb3dlcik7XG5cdCAgICB2YXIgc3RlcFZhbCA9IHN0ZXAgLyBjYWxjdWxTdGVwO1xuXHQgICAgc3RlcFZhbCA9IHN0ZXBWYWwgPiA1ID8gMTAgOiA1O1xuXHQgICAgcmV0dXJuIHBhcnNlSW50KHN0ZXBWYWwsIDEwKSAqIGNhbGN1bFN0ZXA7XG5cdCAgfSxcblx0ICBfY2FsY3VsYXRlU2NhbGU6IGZ1bmN0aW9uIChubWluLCBubWF4KSB7XG5cdCAgICB0aGlzLl9sb2dTY2FsZUNhbGMgPSBmYWxzZTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNjYWxlID09IFwibG9nYXJpdGhtaWNcIikge1xuXHQgICAgICB2YXIgbG9nTWluID0gTWF0aC5mbG9vcih0aGlzLl9sb2cxMChubWluKSk7XG5cdCAgICAgIHZhciBsb2dNYXggPSBNYXRoLmNlaWwodGhpcy5fbG9nMTAobm1heCkpO1xuXG5cdCAgICAgIGlmIChubWluID4gMCAmJiBubWF4ID4gMCAmJiBsb2dNYXggLSBsb2dNaW4gPiAxKSB7XG5cdCAgICAgICAgdGhpcy5fbG9nU2NhbGVDYWxjID0gdHJ1ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlTG9nU2NhbGUobm1pbiwgbm1heCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLm9yaWdpbiAhPSBcImF1dG9cIiAmJiB0aGlzLl9zZXR0aW5ncy5vcmlnaW4gPCBubWluKSBubWluID0gdGhpcy5fc2V0dGluZ3Mub3JpZ2luO1xuXHQgICAgdmFyIHN0ZXAsIHN0YXJ0LCBlbmQ7XG5cdCAgICBzdGVwID0gdGhpcy5fbm9ybVN0ZXAoKG5tYXggLSBubWluKSAvIDggfHwgMSk7XG5cdCAgICBpZiAoc3RlcCA+IE1hdGguYWJzKG5taW4pKSBzdGFydCA9IG5taW4gPCAwID8gLXN0ZXAgOiAwO2Vsc2Uge1xuXHQgICAgICB2YXIgYWJzTm1pbiA9IE1hdGguYWJzKG5taW4pO1xuXHQgICAgICB2YXIgcG93ZXJTdGFydCA9IE1hdGguZmxvb3IodGhpcy5fbG9nMTAoYWJzTm1pbikpO1xuXHQgICAgICB2YXIgbm1pblZhbCA9IGFic05taW4gLyBNYXRoLnBvdygxMCwgcG93ZXJTdGFydCk7XG5cdCAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKG5taW5WYWwgKiAxMCkgLyAxMCAqIE1hdGgucG93KDEwLCBwb3dlclN0YXJ0KSAtIHN0ZXA7XG5cblx0ICAgICAgaWYgKGFic05taW4gPiAxICYmIHN0ZXAgPiAwLjEpIHtcblx0ICAgICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB3aGlsZSAobm1pbiA8IDAgPyBzdGFydCA8PSBubWluIDogc3RhcnQgPj0gbm1pbikge1xuXHQgICAgICAgIHN0YXJ0IC09IHN0ZXA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobm1pbiA8IDApIHN0YXJ0ID0gLXN0YXJ0IC0gMiAqIHN0ZXA7XG5cdCAgICB9XG5cdCAgICBpZiAobm1heCAtIHN0YXJ0ID4gMTApIHN0ZXAgPSB0aGlzLl9ub3JtU3RlcCgobm1heCAtIHN0YXJ0KSAvIDggfHwgMSk7XG5cdCAgICBlbmQgPSBzdGFydDtcblx0ICAgIHZhciBwb3dlciA9IE1hdGguZmxvb3IodGhpcy5fbG9nMTAoc3RlcCkpO1xuXG5cdCAgICB3aGlsZSAoZW5kIDwgbm1heCkge1xuXHQgICAgICBlbmQgKz0gc3RlcDtcblx0ICAgICAgZW5kID0gcGFyc2VGbG9hdCgoZW5kICogMS4wKS50b0ZpeGVkKE1hdGguYWJzKHBvd2VyKSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kLFxuXHQgICAgICBzdGVwOiBzdGVwLFxuXHQgICAgICBmaXhOdW06IHBvd2VyIDwgMCA/IE1hdGguYWJzKHBvd2VyKSA6IDBcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfZ2V0TGltaXRzOiBmdW5jdGlvbiAob3JpZW50YXRpb24sIHZhbHVlKSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YS5fb2JqX2FycmF5KCk7XG5cblx0ICAgIHZhciBtYXhWYWx1ZSwgbWluVmFsdWU7XG5cdCAgICB2YXIgYXhpcyA9IGFyZ3VtZW50cy5sZW5ndGggJiYgb3JpZW50YXRpb24gPT0gXCJoXCIgPyB0aGlzLl9jb25maWdYQXhpcyA6IHRoaXMuX2NvbmZpZ1lBeGlzO1xuXHQgICAgdmFsdWUgPSB2YWx1ZSB8fCBcInZhbHVlXCI7XG5cblx0ICAgIGlmIChheGlzICYmIHR5cGVvZiBheGlzLmVuZCAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBheGlzLnN0YXJ0ICE9IFwidW5kZWZpbmVkXCIgJiYgYXhpcy5zdGVwKSB7XG5cdCAgICAgIG1heFZhbHVlID0gcGFyc2VGbG9hdChheGlzLmVuZCk7XG5cdCAgICAgIG1pblZhbHVlID0gcGFyc2VGbG9hdChheGlzLnN0YXJ0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG1heFZhbHVlID0gR3JvdXBNZXRob2RzLm1heCh0aGlzLl9zZXJpZXNbMF1bdmFsdWVdLCBkYXRhKTtcblx0ICAgICAgbWluVmFsdWUgPSBheGlzICYmIHR5cGVvZiBheGlzLnN0YXJ0ICE9IFwidW5kZWZpbmVkXCIgPyBwYXJzZUZsb2F0KGF4aXMuc3RhcnQpIDogR3JvdXBNZXRob2RzLm1pbih0aGlzLl9zZXJpZXNbMF1bdmFsdWVdLCBkYXRhKTtcblx0ICAgICAgaWYgKHRoaXMuX3Nlcmllcy5sZW5ndGggPiAxKSBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX3Nlcmllcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBtYXhJID0gR3JvdXBNZXRob2RzLm1heCh0aGlzLl9zZXJpZXNbaV1bdmFsdWVdLCBkYXRhKTtcblx0ICAgICAgICB2YXIgbWluSSA9IEdyb3VwTWV0aG9kcy5taW4odGhpcy5fc2VyaWVzW2ldW3ZhbHVlXSwgZGF0YSk7XG5cdCAgICAgICAgaWYgKG1heEkgPiBtYXhWYWx1ZSkgbWF4VmFsdWUgPSBtYXhJO1xuXHQgICAgICAgIGlmIChtaW5JIDwgbWluVmFsdWUpIG1pblZhbHVlID0gbWluSTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBtYXg6IG1heFZhbHVlLFxuXHQgICAgICBtaW46IG1pblZhbHVlXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2xvZzEwOiBmdW5jdGlvbiAobikge1xuXHQgICAgdmFyIG1ldGhvZF9uYW1lID0gXCJsb2dcIjtcblx0ICAgIHJldHVybiBNYXRoW21ldGhvZF9uYW1lXShuKSAvIE1hdGguTE4xMDtcblx0ICB9LFxuXHQgIF9kcmF3WEF4aXNMYWJlbDogZnVuY3Rpb24gKHgsIHksIG9iaiwgY2VudGVyLCB0b3ApIHtcblx0ICAgIGlmICghdGhpcy5fc2V0dGluZ3MueEF4aXMpIHJldHVybjtcblx0ICAgIHZhciBlbGVtID0gdGhpcy5jYW52YXNlc1tcInhcIl0ucmVuZGVyVGV4dEF0KHRvcCwgY2VudGVyLCB4LCB5IC0gKHRvcCA/IDIgOiAwKSwgdGhpcy5fc2V0dGluZ3MueEF4aXMudGVtcGxhdGUob2JqKSk7XG5cdCAgICBpZiAoZWxlbSkgZWxlbS5jbGFzc05hbWUgKz0gXCIgd2ViaXhfYXhpc19pdGVtX3hcIjtcblx0ICB9LFxuXHQgIF9kcmF3WEF4aXNMaW5lOiBmdW5jdGlvbiAoY3R4LCB4LCB5MSwgeTIsIG9iaikge1xuXHQgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy54QXhpcyB8fCAhdGhpcy5fc2V0dGluZ3MueEF4aXMubGluZXMpIHJldHVybjtcblxuXHQgICAgdGhpcy5fZHJhd0xpbmUoY3R4LCB4LCB5MSwgeCwgeTIsIHRoaXMuX3NldHRpbmdzLnhBeGlzLmxpbmVDb2xvci5jYWxsKHRoaXMsIG9iaiksIDEpO1xuXHQgIH0sXG5cdCAgX2RyYXdMaW5lOiBmdW5jdGlvbiAoY3R4LCB4MSwgeTEsIHgyLCB5MiwgY29sb3IkJDEsIHdpZHRoKSB7XG5cdCAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvciQkMTtcblx0ICAgIGN0eC5saW5lV2lkdGggPSB3aWR0aDtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblx0ICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcblx0ICAgIGN0eC5zdHJva2UoKTtcblx0ICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXHQgIH0sXG5cdCAgX2dldFJlbGF0aXZlVmFsdWU6IGZ1bmN0aW9uIChtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcblx0ICAgIHZhciByZWxWYWx1ZTtcblx0ICAgIHZhciB2YWx1ZUZhY3RvciA9IDE7XG5cblx0ICAgIGlmIChtYXhWYWx1ZSAhPSBtaW5WYWx1ZSkge1xuXHQgICAgICByZWxWYWx1ZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XG5cdCAgICB9IGVsc2UgcmVsVmFsdWUgPSBtaW5WYWx1ZTtcblxuXHQgICAgcmV0dXJuIFtyZWxWYWx1ZSwgdmFsdWVGYWN0b3JdO1xuXHQgIH0sXG5cdCAgX3JhaW5ib3c6IFtmdW5jdGlvbiAocG9zJCQxKSB7XG5cdCAgICByZXR1cm4gXCIjRkZcIiArIGNvbG9yLnRvSGV4KHBvcyQkMSAvIDIsIDIpICsgXCIwMFwiO1xuXHQgIH0sIGZ1bmN0aW9uIChwb3MkJDEpIHtcblx0ICAgIHJldHVybiBcIiNGRlwiICsgY29sb3IudG9IZXgocG9zJCQxIC8gMiArIDEyOCwgMikgKyBcIjAwXCI7XG5cdCAgfSwgZnVuY3Rpb24gKHBvcyQkMSkge1xuXHQgICAgcmV0dXJuIFwiI1wiICsgY29sb3IudG9IZXgoMjU1IC0gcG9zJCQxLCAyKSArIFwiRkYwMFwiO1xuXHQgIH0sIGZ1bmN0aW9uIChwb3MkJDEpIHtcblx0ICAgIHJldHVybiBcIiMwMEZGXCIgKyBjb2xvci50b0hleChwb3MkJDEsIDIpO1xuXHQgIH0sIGZ1bmN0aW9uIChwb3MkJDEpIHtcblx0ICAgIHJldHVybiBcIiMwMFwiICsgY29sb3IudG9IZXgoMjU1IC0gcG9zJCQxLCAyKSArIFwiRkZcIjtcblx0ICB9LCBmdW5jdGlvbiAocG9zJCQxKSB7XG5cdCAgICByZXR1cm4gXCIjXCIgKyBjb2xvci50b0hleChwb3MkJDEsIDIpICsgXCIwMEZGXCI7XG5cdCAgfV0sXG5cdCAgX2RlZkNvbG9yczogW1wiI2Y1NWI1MFwiLCBcIiNmZjZkM2ZcIiwgXCIjZmZhNTIxXCIsIFwiI2ZmYzkyN1wiLCBcIiNmZmVlNTRcIiwgXCIjZDNlMTUzXCIsIFwiIzlhY2I2MVwiLCBcIiM2M2I5NjdcIiwgXCIjMjFhNDk3XCIsIFwiIzIxYzVkYVwiLCBcIiMzZWE0ZjVcIiwgXCIjNTg2OGJmXCIsIFwiIzdiNTNjMFwiLCBcIiNhOTQzYmFcIiwgXCIjZWMzYjc3XCIsIFwiIzllYjBiOFwiXSxcblx0ICBfZGVmQ29sb3JzQ3Vyc29yOiAwLFxuXG5cdCAgLyoqXG5cdCAgKiAgIGFkZHMgc2VyaWVzIHRvIHRoZSBjaGFydCAodmFsdWUgYW5kIGNvbG9yIHByb3BlcnRpZXMpXG5cdCAgKiAgIEBwYXJhbTogb2JqIC0gb2JqIHdpdGggY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzXG5cdCAgKi9cblx0ICBhZGRTZXJpZXM6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHZhciB0ZW1wID0gZXhwb3J0cy5leHRlbmQoe30sIHRoaXMuX3NldHRpbmdzKTtcblx0ICAgIHRoaXMuX3NldHRpbmdzID0gZXhwb3J0cy5leHRlbmQoe30sIHRlbXApO1xuXG5cdCAgICB0aGlzLl9wYXJzZVNldHRpbmdzKG9iaiwge30pO1xuXG5cdCAgICB0aGlzLl9zZXJpZXMucHVzaCh0aGlzLl9zZXR0aW5ncyk7XG5cblx0ICAgIHRoaXMuX3NldHRpbmdzID0gdGVtcDtcblx0ICB9LFxuXHQgIF9nZXRBY3RpdmVTZXJpZXM6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgYSwgYXJlYXMsIGksIG9mZnNldCQkMSwgcG9zJCQxLCBzZWxlY3Rpb24sIHgsIHk7XG5cdCAgICBhcmVhcyA9IHRoaXMuX21hcC5fYXJlYXM7XG5cdCAgICBvZmZzZXQkJDEgPSBvZmZzZXQodGhpcy5fY29udGVudG9iai5faHRtbG1hcCk7XG5cdCAgICBwb3MkJDEgPSBwb3MoZSk7XG5cdCAgICB4ID0gcG9zJCQxLnggLSBvZmZzZXQkJDEueDtcblx0ICAgIHkgPSBwb3MkJDEueSAtIG9mZnNldCQkMS55O1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYXJlYXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYSA9IGFyZWFzW2ldLnBvaW50cztcblxuXHQgICAgICBpZiAoeCA8PSBhWzJdICYmIHggPj0gYVswXSAmJiB5IDw9IGFbM10gJiYgeSA+PSBhWzFdKSB7XG5cdCAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuXHQgICAgICAgICAgaWYgKGFyZWFzW2ldLmluZGV4ID4gc2VsZWN0aW9uLmluZGV4KSBzZWxlY3Rpb24gPSBhcmVhc1tpXTtcblx0ICAgICAgICB9IGVsc2Ugc2VsZWN0aW9uID0gYXJlYXNbaV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5pbmRleCA6IDA7XG5cdCAgfSxcblx0ICBoaWRlU2VyaWVzOiBmdW5jdGlvbiAoc2VyaWVzKSB7XG5cdCAgICB0aGlzLmNhbnZhc2VzW3Nlcmllc10uaGlkZUNhbnZhcygpO1xuXHQgICAgdmFyIGxlZ2VuZCA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZDtcblxuXHQgICAgaWYgKGxlZ2VuZCAmJiBsZWdlbmQudmFsdWVzICYmIGxlZ2VuZC52YWx1ZXNbc2VyaWVzXSkge1xuXHQgICAgICBsZWdlbmQudmFsdWVzW3Nlcmllc10uJGhpZGRlbiA9IHRydWU7XG5cblx0ICAgICAgdGhpcy5fZHJhd0xlZ2VuZCgpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9tYXAuaGlkZSh0aGlzLl9jb250ZW50b2JqLCBzZXJpZXMsIHRydWUpO1xuXHQgIH0sXG5cdCAgc2hvd1NlcmllczogZnVuY3Rpb24gKHNlcmllcykge1xuXHQgICAgdGhpcy5jYW52YXNlc1tzZXJpZXNdLnNob3dDYW52YXMoKTtcblx0ICAgIHZhciBsZWdlbmQgPSB0aGlzLl9zZXR0aW5ncy5sZWdlbmQ7XG5cblx0ICAgIGlmIChsZWdlbmQgJiYgbGVnZW5kLnZhbHVlcyAmJiBsZWdlbmQudmFsdWVzW3Nlcmllc10pIHtcblx0ICAgICAgZGVsZXRlIGxlZ2VuZC52YWx1ZXNbc2VyaWVzXS4kaGlkZGVuO1xuXG5cdCAgICAgIHRoaXMuX2RyYXdMZWdlbmQoKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fbWFwLmhpZGUodGhpcy5fY29udGVudG9iaiwgc2VyaWVzLCBmYWxzZSk7XG5cdCAgfSxcblxuXHQgIC8qKlxuXHQgICogICByZW5kZXJzIGxlZ2VuZCBibG9ja1xuXHQgICogICBAcGFyYW06IGN0eCAtIGNhbnZhcyBvYmplY3Rcblx0ICAqICAgQHBhcmFtOiBkYXRhIC0gb2JqZWN0IHRob3NlIG5lZWQgdG8gYmUgZGlzcGxheWVkXG5cdCAgKiAgIEBwYXJhbTogd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuXHQgICogICBAcGFyYW06IGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lclxuXHQgICovXG5cdCAgX2RyYXdMZWdlbmQ6IGZ1bmN0aW9uIChkYXRhLCB3aWR0aCkge1xuXHQgICAgLypwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGJsb2NrKi9cblx0ICAgIHZhciBpLFxuXHQgICAgICAgIGxlZ2VuZCxcblx0ICAgICAgICBsZWdlbmRDb250YWluZXIsXG5cdCAgICAgICAgbGVnZW5kSGVpZ2h0LFxuXHQgICAgICAgIGxlZ2VuZEl0ZW1zLFxuXHQgICAgICAgIGxlZ2VuZFdpZHRoLFxuXHQgICAgICAgIHN0eWxlLFxuXHQgICAgICAgIHggPSAwLFxuXHQgICAgICAgIHkgPSAwLFxuXHQgICAgICAgIGN0eCxcblx0ICAgICAgICBpdGVtQ29sb3IsXG5cdCAgICAgICAgZGlzYWJsZWQsXG5cdCAgICAgICAgaXRlbTtcblx0ICAgIGRhdGEgPSBkYXRhIHx8IFtdO1xuXHQgICAgd2lkdGggPSB3aWR0aCB8fCB0aGlzLl9jb250ZW50X3dpZHRoO1xuXHQgICAgY3R4ID0gdGhpcy5jYW52YXNlc1tcImxlZ2VuZFwiXS5nZXRDYW52YXMoKTtcblx0ICAgIC8qbGVnZW5kIGNvbmZpZyovXG5cblx0ICAgIGxlZ2VuZCA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZDtcblx0ICAgIC8qdGhlIGxlZ2VuZCBzaXplcyovXG5cblx0ICAgIHN0eWxlID0gdGhpcy5fc2V0dGluZ3MubGVnZW5kLmxheW91dCAhPSBcInhcIiA/IFwid2lkdGg6XCIgKyBsZWdlbmQud2lkdGggKyBcInB4XCIgOiBcIlwiO1xuXHQgICAgLypjcmVhdGlvbiBvZiBsZWdlbmQgY29udGFpbmVyKi9cblxuXHQgICAgaWYgKHRoaXMuX2xlZ2VuZE9iaikge1xuXHQgICAgICB0aGlzLl9sZWdlbmRPYmouaW5uZXJIVE1MID0gXCJcIjtcblxuXHQgICAgICB0aGlzLl9sZWdlbmRPYmoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9sZWdlbmRPYmopO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNhbnZhc2VzW1wibGVnZW5kXCJdLmNsZWFyQ2FudmFzKHRydWUpO1xuXHQgICAgbGVnZW5kQ29udGFpbmVyID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJjbGFzc1wiOiBcIndlYml4X2NoYXJ0X2xlZ2VuZFwiLFxuXHQgICAgICBcInN0eWxlXCI6IFwibGVmdDpcIiArIHggKyBcInB4OyB0b3A6XCIgKyB5ICsgXCJweDtcIiArIHN0eWxlXG5cdCAgICB9LCBcIlwiKTtcblxuXHQgICAgaWYgKGxlZ2VuZC5wYWRkaW5nKSB7XG5cdCAgICAgIGxlZ2VuZENvbnRhaW5lci5zdHlsZS5wYWRkaW5nID0gbGVnZW5kLnBhZGRpbmcgKyBcInB4XCI7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2xlZ2VuZE9iaiA9IGxlZ2VuZENvbnRhaW5lcjtcblxuXHQgICAgdGhpcy5fY29udGVudG9iai5hcHBlbmRDaGlsZChsZWdlbmRDb250YWluZXIpO1xuXHQgICAgLypyZW5kZXJpbmcgbGVnZW5kIHRleHQgaXRlbXMqL1xuXG5cblx0ICAgIGxlZ2VuZEl0ZW1zID0gW107XG5cdCAgICBpZiAoIWxlZ2VuZC52YWx1ZXMpIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGxlZ2VuZEl0ZW1zLnB1c2godGhpcy5fZHJhd0xlZ2VuZFRleHQobGVnZW5kQ29udGFpbmVyLCBsZWdlbmQudGVtcGxhdGUoZGF0YVtpXSksIGRhdGFbaV0uaWQpKTtcblx0ICAgIH0gZWxzZSBmb3IgKGkgPSAwOyBpIDwgbGVnZW5kLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBsZWdlbmRJdGVtcy5wdXNoKHRoaXMuX2RyYXdMZWdlbmRUZXh0KGxlZ2VuZENvbnRhaW5lciwgbGVnZW5kLnZhbHVlc1tpXS50ZXh0LCB0eXBlb2YgbGVnZW5kLnZhbHVlc1tpXS5pZCAhPSBcInVuZGVmaW5lZFwiID8gX3R5cGVvZihsZWdlbmQudmFsdWVzW2ldLmlkKSA6IGksIGxlZ2VuZC52YWx1ZXNbaV0uJGhpZGRlbikpO1xuXHQgICAgfVxuXHQgICAgaWYgKGxlZ2VuZENvbnRhaW5lci5vZmZzZXRXaWR0aCA9PT0gMCkgbGVnZW5kQ29udGFpbmVyLnN0eWxlLndpZHRoID0gXCJhdXRvXCI7XG5cdCAgICBsZWdlbmRXaWR0aCA9IGxlZ2VuZENvbnRhaW5lci5vZmZzZXRXaWR0aDtcblx0ICAgIGxlZ2VuZEhlaWdodCA9IGxlZ2VuZENvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cdCAgICAvKnRoaXMuX3NldHRpbmdzLmxlZ2VuZC53aWR0aCA9IGxlZ2VuZFdpZHRoO1xuXHQgICAgdGhpcy5fc2V0dGluZ3MubGVnZW5kLmhlaWdodCA9IGxlZ2VuZEhlaWdodDsqL1xuXG5cdCAgICAvKnNldHRpbmcgbGVnZW5kIHBvc2l0aW9uKi9cblxuXHQgICAgaWYgKGxlZ2VuZFdpZHRoIDwgd2lkdGgpIHtcblx0ICAgICAgaWYgKGxlZ2VuZC5sYXlvdXQgPT0gXCJ4XCIgJiYgbGVnZW5kLmFsaWduID09IFwiY2VudGVyXCIpIHtcblx0ICAgICAgICB4ID0gKHdpZHRoIC0gbGVnZW5kV2lkdGgpIC8gMjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChsZWdlbmQuYWxpZ24gPT0gXCJyaWdodFwiKSB7XG5cdCAgICAgICAgeCA9IHdpZHRoIC0gbGVnZW5kV2lkdGg7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobGVnZW5kLm1hcmdpbiAmJiBsZWdlbmQuYWxpZ24gIT0gXCJjZW50ZXJcIikge1xuXHQgICAgICAgIHggKz0gKGxlZ2VuZC5hbGlnbiA9PSBcImxlZnRcIiA/IDEgOiAtMSkgKiBsZWdlbmQubWFyZ2luO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChsZWdlbmRIZWlnaHQgPCB0aGlzLl9jb250ZW50X2hlaWdodCkge1xuXHQgICAgICBpZiAobGVnZW5kLnZhbGlnbiA9PSBcIm1pZGRsZVwiICYmIGxlZ2VuZC5hbGlnbiAhPSBcImNlbnRlclwiICYmIGxlZ2VuZC5sYXlvdXQgIT0gXCJ4XCIpIHkgPSAodGhpcy5fY29udGVudF9oZWlnaHQgLSBsZWdlbmRIZWlnaHQpIC8gMjtlbHNlIGlmIChsZWdlbmQudmFsaWduID09IFwiYm90dG9tXCIpIHkgPSB0aGlzLl9jb250ZW50X2hlaWdodCAtIGxlZ2VuZEhlaWdodDtcblxuXHQgICAgICBpZiAobGVnZW5kLm1hcmdpbiAmJiBsZWdlbmQudmFsaWduICE9IFwibWlkZGxlXCIpIHtcblx0ICAgICAgICB5ICs9IChsZWdlbmQudmFsaWduID09IFwidG9wXCIgPyAxIDogLTEpICogbGVnZW5kLm1hcmdpbjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBsZWdlbmRDb250YWluZXIuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG5cdCAgICBsZWdlbmRDb250YWluZXIuc3R5bGUudG9wID0geSArIFwicHhcIjtcblx0ICAgIC8qZHJhd2luZyBjb2xvcmZ1bCBtYXJrZXJzKi9cblxuXHQgICAgY3R4LnNhdmUoKTtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlZ2VuZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGl0ZW0gPSBsZWdlbmRJdGVtc1tpXTtcblxuXHQgICAgICBpZiAobGVnZW5kLnZhbHVlcyAmJiBsZWdlbmQudmFsdWVzW2ldLiRoaWRkZW4pIHtcblx0ICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG5cdCAgICAgICAgaXRlbUNvbG9yID0gbGVnZW5kLnZhbHVlc1tpXS5kaXNhYmxlQ29sb3IgPyBsZWdlbmQudmFsdWVzW2ldLmRpc2FibGVDb2xvciA6IFwiI2VkZWZmMFwiO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG5cdCAgICAgICAgaXRlbUNvbG9yID0gbGVnZW5kLnZhbHVlcyA/IGxlZ2VuZC52YWx1ZXNbaV0uY29sb3IgOiB0aGlzLl9zZXR0aW5ncy5jb2xvci5jYWxsKHRoaXMsIGRhdGFbaV0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fZHJhd0xlZ2VuZE1hcmtlcihjdHgsIGl0ZW0ub2Zmc2V0TGVmdCArIHgsIGl0ZW0ub2Zmc2V0VG9wICsgeSwgaXRlbUNvbG9yLCBpdGVtLm9mZnNldEhlaWdodCwgZGlzYWJsZWQsIGkpO1xuXHQgICAgfVxuXG5cdCAgICBjdHgucmVzdG9yZSgpO1xuXHQgICAgbGVnZW5kSXRlbXMgPSBudWxsO1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgYXBwZW5kcyBsZWdlbmQgaXRlbSB0byBsZWdlbmQgYmxvY2tcblx0ICAqICAgQHBhcmFtOiBjdHggLSBjYW52YXMgb2JqZWN0XG5cdCAgKiAgIEBwYXJhbTogb2JqIC0gZGF0YSBvYmplY3QgdGhhdCBuZWVkcyBiZWluZyByZXByZXNlbnRlZFxuXHQgICovXG5cdCAgX2RyYXdMZWdlbmRUZXh0OiBmdW5jdGlvbiAoY29udCwgdmFsdWUsIHNlcmllcywgZGlzYWJsZWQpIHtcblx0ICAgIHZhciBzdHlsZSA9IFwiXCI7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGVnZW5kLmxheW91dCA9PSBcInhcIikgc3R5bGUgPSBcImZsb2F0OmxlZnQ7XCI7XG5cdCAgICAvKnRoZSB0ZXh0IG9mIHRoZSBsZWdlbmQgaXRlbSovXG5cblx0ICAgIHZhciB0ZXh0ID0gY3JlYXRlKFwiRElWXCIsIHtcblx0ICAgICAgXCJzdHlsZVwiOiBzdHlsZSArIFwicGFkZGluZy1sZWZ0OlwiICsgKDEwICsgdGhpcy5fc2V0dGluZ3MubGVnZW5kLm1hcmtlci53aWR0aCkgKyBcInB4XCIsXG5cdCAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9jaGFydF9sZWdlbmRfaXRlbVwiICsgKGRpc2FibGVkID8gXCIgaGlkZGVuXCIgOiBcIlwiKSxcblx0ICAgICAgXCJyb2xlXCI6IFwiYnV0dG9uXCIsXG5cdCAgICAgIFwidGFiaW5kZXhcIjogXCIwXCIsXG5cdCAgICAgIFwiYXJpYS1sYWJlbFwiOiBpMThuLmFyaWFbKGRpc2FibGVkID8gXCJzaG93XCIgOiBcImhpZGVcIikgKyBcIkNoYXJ0XCJdICsgXCIgXCIgKyB2YWx1ZVxuXHQgICAgfSwgdmFsdWUpO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB0ZXh0LnNldEF0dHJpYnV0ZShcInNlcmllc19pZFwiLCBzZXJpZXMpO1xuXHQgICAgY29udC5hcHBlbmRDaGlsZCh0ZXh0KTtcblx0ICAgIHJldHVybiB0ZXh0O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgZHJhdyBsZWdlbmQgY29sb3JmdWwgbWFyZGVyXG5cdCAgKiAgIEBwYXJhbTogY3R4IC0gY2FudmFzIG9iamVjdFxuXHQgICogICBAcGFyYW06IHggLSB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyXG5cdCAgKiAgIEBwYXJhbTogeSAtIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyXG5cdCAgKiAgIEBwYXJhbTogb2JqIC0gZGF0YSBvYmplY3Qgd2hpY2ggY29sb3IgbmVlZHMgYmVpbmcgdXNlZFxuXHQgICovXG5cdCAgX2RyYXdMZWdlbmRNYXJrZXI6IGZ1bmN0aW9uIChjdHgsIHgsIHksIGNvbG9yJCQxLCBoZWlnaHQsIGRpc2FibGVkLCBpKSB7XG5cdCAgICB2YXIgcCA9IFtdO1xuXHQgICAgdmFyIG1hcmtlciA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZC5tYXJrZXI7XG5cdCAgICB2YXIgdmFsdWVzID0gdGhpcy5fc2V0dGluZ3MubGVnZW5kLnZhbHVlcztcblx0ICAgIHZhciB0eXBlID0gdmFsdWVzICYmIHZhbHVlc1tpXS5tYXJrZXJUeXBlID8gdmFsdWVzW2ldLm1hcmtlclR5cGUgOiBtYXJrZXIudHlwZTtcblxuXHQgICAgaWYgKGNvbG9yJCQxKSB7XG5cdCAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvciQkMTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGUgPT0gXCJyb3VuZFwiIHx8ICFtYXJrZXIucmFkaXVzKSB7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgY3R4LmxpbmVXaWR0aCA9IG1hcmtlci5oZWlnaHQ7XG5cdCAgICAgIGN0eC5saW5lQ2FwID0gbWFya2VyLnR5cGU7XG5cdCAgICAgIC8qc3RhcnQgb2YgbWFya2VyKi9cblxuXHQgICAgICB4ICs9IGN0eC5saW5lV2lkdGggLyAyICsgNTtcblx0ICAgICAgeSArPSBoZWlnaHQgLyAyO1xuXHQgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuXHQgICAgICB2YXIgeDEgPSB4ICsgbWFya2VyLndpZHRoIC0gbWFya2VyLmhlaWdodCArIDE7XG5cdCAgICAgIGN0eC5saW5lVG8oeDEsIHkpO1xuXHQgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAgIGN0eC5maWxsKCk7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJpdGVtXCIpIHtcblx0ICAgICAgLypjb3B5IG9mIGxpbmUqL1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubGluZSAmJiB0aGlzLl9zZXR0aW5ncy50eXBlICE9IFwic2NhdHRlclwiICYmICF0aGlzLl9zZXR0aW5ncy5kaXNhYmxlTGluZXMpIHtcblx0ICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX3Nlcmllc1tpXS5saW5lLndpZHRoO1xuXHQgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGRpc2FibGVkID8gY29sb3IkJDEgOiB0aGlzLl9zZXJpZXNbaV0ubGluZS5jb2xvci5jYWxsKHRoaXMsIHt9KTtcblx0ICAgICAgICB2YXIgeDAgPSB4ICsgNTtcblx0ICAgICAgICB2YXIgeTAgPSB5ICsgaGVpZ2h0IC8gMjtcblx0ICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG5cblx0ICAgICAgICB2YXIgX3ggPSB4MCArIG1hcmtlci53aWR0aDtcblxuXHQgICAgICAgIGN0eC5saW5lVG8oX3gsIHkwKTtcblx0ICAgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAgIH1cblx0ICAgICAgLyppdGVtIGNvcHkqL1xuXG5cblx0ICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3Nlcmllc1tpXS5pdGVtO1xuXHQgICAgICB2YXIgcmFkaXVzID0gcGFyc2VJbnQoY29uZmlnLnJhZGl1cy5jYWxsKHRoaXMsIHt9KSwgMTApIHx8IDA7XG5cdCAgICAgIHZhciBtYXJrZXJUeXBlID0gY29uZmlnLnR5cGUuY2FsbCh0aGlzLCB7fSk7XG5cblx0ICAgICAgaWYgKHJhZGl1cykge1xuXHQgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXHQgICAgICAgIGlmIChkaXNhYmxlZCkge1xuXHQgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNvbmZpZy5ib3JkZXJXaWR0aDtcblx0ICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yJCQxO1xuXHQgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yJCQxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjdHgubGluZVdpZHRoID0gY29uZmlnLmJvcmRlcldpZHRoO1xuXHQgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbmZpZy5jb2xvci5jYWxsKHRoaXMsIHt9KTtcblx0ICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5ib3JkZXJDb2xvci5jYWxsKHRoaXMsIHt9KTtcblx0ICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNvbmZpZy5hbHBoYS5jYWxsKHRoaXMsIHt9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cdCAgICAgICAgeCArPSBtYXJrZXIud2lkdGggLyAyICsgNTtcblx0ICAgICAgICB5ICs9IGhlaWdodCAvIDI7XG5cblx0ICAgICAgICB0aGlzLl9zdHJva2VDaGFydEl0ZW0oY3R4LCB4LCB5LCByYWRpdXMgKyAxLCBtYXJrZXJUeXBlKTtcblxuXHQgICAgICAgIGN0eC5maWxsKCk7XG5cdCAgICAgICAgY3R4LnN0cm9rZSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cdCAgICAgIHggKz0gNTtcblx0ICAgICAgeSArPSBoZWlnaHQgLyAyIC0gbWFya2VyLmhlaWdodCAvIDI7XG5cdCAgICAgIHAgPSBbW3ggKyBtYXJrZXIucmFkaXVzLCB5ICsgbWFya2VyLnJhZGl1cywgbWFya2VyLnJhZGl1cywgTWF0aC5QSSwgMyAqIE1hdGguUEkgLyAyLCBmYWxzZV0sIFt4ICsgbWFya2VyLndpZHRoIC0gbWFya2VyLnJhZGl1cywgeV0sIFt4ICsgbWFya2VyLndpZHRoIC0gbWFya2VyLnJhZGl1cywgeSArIG1hcmtlci5yYWRpdXMsIG1hcmtlci5yYWRpdXMsIC1NYXRoLlBJIC8gMiwgMCwgZmFsc2VdLCBbeCArIG1hcmtlci53aWR0aCwgeSArIG1hcmtlci5oZWlnaHQgLSBtYXJrZXIucmFkaXVzXSwgW3ggKyBtYXJrZXIud2lkdGggLSBtYXJrZXIucmFkaXVzLCB5ICsgbWFya2VyLmhlaWdodCAtIG1hcmtlci5yYWRpdXMsIG1hcmtlci5yYWRpdXMsIDAsIE1hdGguUEkgLyAyLCBmYWxzZV0sIFt4ICsgbWFya2VyLnJhZGl1cywgeSArIG1hcmtlci5oZWlnaHRdLCBbeCArIG1hcmtlci5yYWRpdXMsIHkgKyBtYXJrZXIuaGVpZ2h0IC0gbWFya2VyLnJhZGl1cywgbWFya2VyLnJhZGl1cywgTWF0aC5QSSAvIDIsIE1hdGguUEksIGZhbHNlXSwgW3gsIHkgKyBtYXJrZXIucmFkaXVzXV07XG5cblx0ICAgICAgdGhpcy5fcGF0aChjdHgsIHApO1xuXG5cdCAgICAgIGN0eC5zdHJva2UoKTtcblx0ICAgICAgY3R4LmZpbGwoKTtcblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgLyoqXG5cdCAgKiAgIGdldHMgdGhlIHBvaW50cyB0aG9zZSByZXByZXNlbnQgY2hhcnQgbGVmdCB0b3AgYW5kIHJpZ2h0IGJvdHRvbSBib3VuZHNcblx0ICAqICAgQHBhcmFtOiB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgY29udGFpbmVyXG5cdCAgKiAgIEBwYXJhbTogaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgY2hhcnQgY29udGFpbmVyXG5cdCAgKi9cblx0ICBfZ2V0Q2hhcnRCb3VuZHM6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG5cdCAgICB2YXIgY2hhcnRYMCwgY2hhcnRZMCwgY2hhcnRYMSwgY2hhcnRZMTtcblx0ICAgIGNoYXJ0WDAgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nLmxlZnQ7XG5cdCAgICBjaGFydFkwID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZy50b3A7XG5cdCAgICBjaGFydFgxID0gd2lkdGggLSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nLnJpZ2h0O1xuXHQgICAgY2hhcnRZMSA9IGhlaWdodCAtIHRoaXMuX3NldHRpbmdzLnBhZGRpbmcuYm90dG9tO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGVnZW5kKSB7XG5cdCAgICAgIHZhciBsZWdlbmQgPSB0aGlzLl9zZXR0aW5ncy5sZWdlbmQ7XG5cdCAgICAgIC8qbGVnZW5kIHNpemUqL1xuXG5cdCAgICAgIHZhciBsZWdlbmRXaWR0aCA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZC53aWR0aDtcblx0ICAgICAgdmFyIGxlZ2VuZEhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmxlZ2VuZC5oZWlnaHQ7XG5cdCAgICAgIC8qaWYgbGVnZW5kIGlzIGhvcml6b250YWwqL1xuXG5cdCAgICAgIGlmIChsZWdlbmQubGF5b3V0ID09IFwieFwiKSB7XG5cdCAgICAgICAgaWYgKGxlZ2VuZC52YWxpZ24gPT0gXCJjZW50ZXJcIikge1xuXHQgICAgICAgICAgaWYgKGxlZ2VuZC5hbGlnbiA9PSBcInJpZ2h0XCIpIGNoYXJ0WDEgLT0gbGVnZW5kV2lkdGg7ZWxzZSBpZiAobGVnZW5kLmFsaWduID09IFwibGVmdFwiKSBjaGFydFgwICs9IGxlZ2VuZFdpZHRoO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobGVnZW5kLnZhbGlnbiA9PSBcImJvdHRvbVwiKSB7XG5cdCAgICAgICAgICBjaGFydFkxIC09IGxlZ2VuZEhlaWdodDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY2hhcnRZMCArPSBsZWdlbmRIZWlnaHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8qdmVydGljYWwgc2NhbGUqL1xuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICAgIGlmIChsZWdlbmQuYWxpZ24gPT0gXCJyaWdodFwiKSBjaGFydFgxIC09IGxlZ2VuZFdpZHRoO2Vsc2UgaWYgKGxlZ2VuZC5hbGlnbiA9PSBcImxlZnRcIikgY2hhcnRYMCArPSBsZWdlbmRXaWR0aDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHN0YXJ0OiB7XG5cdCAgICAgICAgeDogY2hhcnRYMCxcblx0ICAgICAgICB5OiBjaGFydFkwXG5cdCAgICAgIH0sXG5cdCAgICAgIGVuZDoge1xuXHQgICAgICAgIHg6IGNoYXJ0WDEsXG5cdCAgICAgICAgeTogY2hhcnRZMVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgZ2V0cyB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB2YWx1ZXMgZm9yIHRoZSBzdGFja2VkIGNoYXJ0XG5cdCAgKiAgIEBwYXJhbTogZGF0YSAtIGRhdGEgc2V0XG5cdCAgKi9cblx0ICBfZ2V0U3RhY2tlZExpbWl0czogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgIHZhciBpLCBqLCBtYXhWYWx1ZSwgbWluVmFsdWUsIHZhbHVlO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MueUF4aXMgJiYgdHlwZW9mIHRoaXMuX3NldHRpbmdzLnlBeGlzLmVuZCAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0aGlzLl9zZXR0aW5ncy55QXhpcy5zdGFydCAhPSBcInVuZGVmaW5lZFwiICYmIHRoaXMuX3NldHRpbmdzLnlBeGlzLnN0ZXApIHtcblx0ICAgICAgbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuX3NldHRpbmdzLnlBeGlzLmVuZCk7XG5cdCAgICAgIG1pblZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLl9zZXR0aW5ncy55QXhpcy5zdGFydCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGRhdGFbaV0uJHN1bSA9IDA7XG5cdCAgICAgICAgZGF0YVtpXS4kbWluID0gSW5maW5pdHk7XG5cblx0ICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5fc2VyaWVzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHBhcnNlRmxvYXQodGhpcy5fc2VyaWVzW2pdLnZhbHVlKGRhdGFbaV0pIHx8IDApKTtcblx0ICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIGNvbnRpbnVlO1xuXHQgICAgICAgICAgaWYgKHRoaXMuX3Nlcmllc1tqXS50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInN0YWNrZWRcIikgIT0gLTEpIGRhdGFbaV0uJHN1bSArPSB2YWx1ZTtcblx0ICAgICAgICAgIGlmICh2YWx1ZSA8IGRhdGFbaV0uJG1pbikgZGF0YVtpXS4kbWluID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG5cdCAgICAgIG1pblZhbHVlID0gSW5maW5pdHk7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoZGF0YVtpXS4kc3VtID4gbWF4VmFsdWUpIG1heFZhbHVlID0gZGF0YVtpXS4kc3VtO1xuXHQgICAgICAgIGlmIChkYXRhW2ldLiRtaW4gPCBtaW5WYWx1ZSkgbWluVmFsdWUgPSBkYXRhW2ldLiRtaW47XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobWluVmFsdWUgPiAwKSBtaW5WYWx1ZSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIG1heDogbWF4VmFsdWUsXG5cdCAgICAgIG1pbjogbWluVmFsdWVcblx0ICAgIH07XG5cdCAgfSxcblxuXHQgIC8qYWRkcyBjb2xvcnMgdG8gdGhlIGdyYWRpZW50IG9iamVjdCovXG5cdCAgX3NldEJhckdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCB4MSwgeTEsIHgyLCB5MiwgdHlwZSwgcmF3Q29sb3IsIGF4aXMpIHtcblx0ICAgIHZhciBncmFkaWVudCwgb2Zmc2V0JCQxLCByZ2IsIGhzdiwgcmF3Q29sb3IwLCBzdG9wcztcblxuXHQgICAgaWYgKHR5cGUgPT0gXCJsaWdodFwiKSB7XG5cdCAgICAgIGlmIChheGlzID09IFwieFwiKSBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MSk7ZWxzZSBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgxLCB5Mik7XG5cdCAgICAgIHN0b3BzID0gW1swLCBcIiNGRkZGRkZcIl0sIFswLjksIHJhd0NvbG9yXSwgWzEsIHJhd0NvbG9yXV07XG5cdCAgICAgIG9mZnNldCQkMSA9IDI7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJmYWxsaW5nXCIgfHwgdHlwZSA9PSBcInJpc2luZ1wiKSB7XG5cdCAgICAgIGlmIChheGlzID09IFwieFwiKSBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MSk7ZWxzZSBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgxLCB5Mik7XG5cdCAgICAgIHJnYiA9IGNvbG9yLnRvUmdiKHJhd0NvbG9yKTtcblx0ICAgICAgaHN2ID0gY29sb3IucmdiVG9Ic3YocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSk7XG5cdCAgICAgIGhzdlsxXSAqPSAxIC8gMjtcblx0ICAgICAgcmF3Q29sb3IwID0gXCJyZ2IoXCIgKyBjb2xvci5oc3ZUb1JnYihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKSArIFwiKVwiO1xuXG5cdCAgICAgIGlmICh0eXBlID09IFwiZmFsbGluZ1wiKSB7XG5cdCAgICAgICAgc3RvcHMgPSBbWzAsIHJhd0NvbG9yMF0sIFswLjcsIHJhd0NvbG9yXSwgWzEsIHJhd0NvbG9yXV07XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInJpc2luZ1wiKSB7XG5cdCAgICAgICAgc3RvcHMgPSBbWzAsIHJhd0NvbG9yXSwgWzAuMywgcmF3Q29sb3JdLCBbMSwgcmF3Q29sb3IwXV07XG5cdCAgICAgIH1cblxuXHQgICAgICBvZmZzZXQkJDEgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zNztcblx0ICAgICAgb2Zmc2V0JCQxID0gMDtcblx0ICAgICAgaWYgKGF4aXMgPT0gXCJ4XCIpIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MiwgeDEsIHkxKTtlbHNlIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkxKTtcblx0ICAgICAgc3RvcHMgPSBbWzAsIFwiIzlkOWQ5ZFwiXSwgWzAuMywgXCIjZThlOGU4XCJdLCBbMC40NSwgXCIjZmZmZmZmXCJdLCBbMC41NSwgXCIjZmZmZmZmXCJdLCBbMC43LCBcIiNlOGU4ZThcIl0sIFsxLCBcIiM5ZDlkOWRcIl1dO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9ncmFkaWVudChncmFkaWVudCwgc3RvcHMpO1xuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBncmFkaWVudDogZ3JhZGllbnQsXG5cdCAgICAgIG9mZnNldDogb2Zmc2V0JCQxXG5cdCAgICB9O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAqICAgcmV0dXJucyB0aGUgeCBhbmQgeSBwb3NpdGlvblxuXHQgICogICBAcGFyYW06IGEgLSBhbmdsZVxuXHQgICogICBAcGFyYW06IHggLSBzdGFydCB4IHBvc2l0aW9uXG5cdCAgKiAgIEBwYXJhbTogeSAtIHN0YXJ0IHkgcG9zaXRpb25cblx0ICAqICAgQHBhcmFtOiByIC0gZGVzdGluYXRpb24gdG8gdGhlIHBvaW50XG5cdCAgKi9cblx0ICBfZ2V0UG9zaXRpb25CeUFuZ2xlOiBmdW5jdGlvbiAoYSwgeCwgeSwgcikge1xuXHQgICAgYSAqPSAtMTtcblx0ICAgIHggPSB4ICsgTWF0aC5jb3MoYSkgKiByO1xuXHQgICAgeSA9IHkgLSBNYXRoLnNpbihhKSAqIHI7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB4OiB4LFxuXHQgICAgICB5OiB5XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2dyYWRpZW50OiBmdW5jdGlvbiAoZ3JhZGllbnQsIHN0b3BzKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wc1tpXVswXSwgc3RvcHNbaV1bMV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3BhdGg6IGZ1bmN0aW9uIChjdHgsIHBvaW50cykge1xuXHQgICAgdmFyIGksIG1ldGhvZDtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBtZXRob2QgPSBpID8gXCJsaW5lVG9cIiA6IFwibW92ZVRvXCI7XG5cdCAgICAgIGlmIChwb2ludHNbaV0ubGVuZ3RoID4gMikgbWV0aG9kID0gXCJhcmNcIjtcblx0ICAgICAgY3R4W21ldGhvZF0uYXBwbHkoY3R4LCBwb2ludHNbaV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2FkZE1hcFJlY3Q6IGZ1bmN0aW9uIChtYXAsIGlkLCBwb2ludHMsIGJvdW5kcywgc0luZGV4KSB7XG5cdCAgICBtYXAuYWRkUmVjdChpZCwgW3BvaW50c1swXS54IC0gYm91bmRzLngsIHBvaW50c1swXS55IC0gYm91bmRzLnksIHBvaW50c1sxXS54IC0gYm91bmRzLngsIHBvaW50c1sxXS55IC0gYm91bmRzLnldLCBzSW5kZXgpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckWSA9IGV4cG9ydHMucHJvdG9VSShhcGkkWSwgUGllJDEsIEJhckNoYXJ0LCBMaW5lQ2hhcnQsIEJhckhDaGFydCwgU3RhY2tlZEJhckNoYXJ0LCBTdGFja2VkQmFySENoYXJ0LCBTcGxpbmUkMSwgQXJlYUNoYXJ0LCBSYWRhciwgU2NhdHRlciwgUHJlc2V0cywgU3BsaW5lQXJlYSQxLCBEeW5hbWljQ2hhcnQsIEdyb3VwLCBBdXRvVG9vbHRpcCwgRGF0YUxvYWRlciwgTW91c2VFdmVudHMsIEV2ZW50U3lzdGVtLCBiYXNlLnZpZXcpO1xuXG5cdGV4cG9ydHMucHJvdG9VSSh7XG5cdCAgbmFtZTogXCJyYW5nZWNoYXJ0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHRlbXBsYXRlOiBcIkdQTCB2ZXJzaW9uIGRvZXNuJ3Qgc3VwcG9ydCByYW5nZWNoYXJ0IDxicj4gWW91IG5lZWQgV2ViaXggUFJPXCJcblx0ICB9XG5cdH0sIHRlbXBsYXRlJDEudmlldyk7XG5cblx0dmFyIGFwaSRaID0ge1xuXHQgIG5hbWU6IFwiZ3JvdXBsaXN0XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIGFuaW1hdGU6IHt9XG5cdCAgfSxcblx0ICBfbGlzdENsYXNzTmFtZTogXCJ3ZWJpeF9ncm91cGxpc3RcIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5kYXRhLCBUcmVlU3RvcmUsIHRydWUpOyAvL25lZWRlZCBmb3IgZ2V0UmFuZ2VcblxuXHQgICAgdGhpcy5kYXRhLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5vcmRlci5sZW5ndGg7XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLmRhdGEucHJvdmlkZUFwaSh0aGlzLCB0cnVlKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uQ2xlYXJBbGxcIiwgYmluZCh0aGlzLl9vbkNsZWFyLCB0aGlzKSk7XG5cblx0ICAgIHRoaXMuX29uQ2xlYXIoKTtcblx0ICB9LFxuXHQgIF9vbkNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9uZXN0ZWRfY3Vyc29yID0gW107XG5cdCAgICB0aGlzLl9uZXN0ZWRfY2hhaW4gPSBbXTtcblx0ICB9LFxuXHQgICRzZXRTaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoYmFzZS5hcGkuJHNldFNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuXHQgICAgICAvL2NyaXRpY2FsIGZvciBhbmltYXRpb25zIGluIGdyb3VwIGxpc3Rcblx0ICAgICAgdGhpcy5fZGF0YW9iai5zdHlsZS53aWR0aCA9IHRoaXMuX2NvbnRlbnRfd2lkdGg7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBvbl9jbGljazoge1xuXHQgICAgd2ViaXhfbGlzdF9pdGVtOiBmdW5jdGlvbiAoZSwgaWQpIHtcblx0ICAgICAgaWYgKHRoaXMuX2luX2FuaW1hdGlvbikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbmVzdGVkX2NoYWluLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX25lc3RlZF9jaGFpbltpXSA9PSBpZCkge1xuXHQgICAgICAgICAgLy9vbmUgbGV2ZWwgdXBcblx0ICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgdGhpcy5fbmVzdGVkX2NoYWluLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YS5nZXRJdGVtKHRoaXMuX25lc3RlZF9jaGFpbltqXSkuJHRlbXBsYXRlID0gXCJcIjtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKCFpKSB7XG5cdCAgICAgICAgICAgIC8vdG9wIGxldmVsXG5cdCAgICAgICAgICAgIHRoaXMuX25lc3RlZF9jdXJzb3IgPSB0aGlzLmRhdGEuYnJhbmNoWzBdO1xuXHQgICAgICAgICAgICB0aGlzLl9uZXN0ZWRfY2hhaW4gPSBbXTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX25lc3RlZF9jdXJzb3IgPSB0aGlzLmRhdGEuYnJhbmNoW3RoaXMuX25lc3RlZF9jaGFpbltpIC0gMV1dO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX25lc3RlZF9jaGFpbi5zcGxpY2UoaSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRoaXMuX2lzX2xldmVsX2Rvd24gPSBmYWxzZTtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBvYmogPSB0aGlzLmdldEl0ZW0oaWQpO1xuXG5cdCAgICAgIGlmIChvYmouJGNvdW50KSB7XG5cdCAgICAgICAgLy9vbmUgbGV2ZWwgZG93blxuXHQgICAgICAgIHRoaXMuX2lzX2xldmVsX2Rvd24gPSB0cnVlO1xuXG5cdCAgICAgICAgdGhpcy5fbmVzdGVkX2NoYWluLnB1c2goaWQpO1xuXG5cdCAgICAgICAgb2JqLiR0ZW1wbGF0ZSA9IFwiQmFja1wiO1xuXHQgICAgICAgIHRoaXMuX25lc3RlZF9jdXJzb3IgPSB0aGlzLmRhdGEuYnJhbmNoW29iai5pZF07XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNlbGVjdCkge1xuXHQgICAgICAgICAgdGhpcy5fbm9fYW5pbWF0aW9uID0gdHJ1ZTtcblx0ICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zZWxlY3QgPT0gXCJtdWx0aXNlbGVjdFwiIHx8IHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0KSB0aGlzLnNlbGVjdChpZCwgZmFsc2UsIHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0ID09IFwidG91Y2hcIiB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5LCBlLnNoaWZ0S2V5KTsgLy9tdWx0aXNlbGVjdGlvblxuXHQgICAgICAgICAgZWxzZSB0aGlzLnNlbGVjdChpZCk7XG5cdCAgICAgICAgICB0aGlzLl9ub19hbmltYXRpb24gPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIGdldE9wZW5TdGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgcGFyZW50czogdGhpcy5fbmVzdGVkX2NoYWluLFxuXHQgICAgICBicmFuY2g6IHRoaXMuX25lc3RlZF9jdXJzb3Jcblx0ICAgIH07XG5cdCAgfSxcblx0ICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBpLCBsYXN0Q2hhaW47IC8vc3RhcnQgZmlsdGVyaW5nIHByb2Nlc3Npbmc9PlxuXG5cdCAgICB0aGlzLl9uZXN0ZWRfY2hhaW4gPSBjb3B5KHRoaXMuX25lc3RlZF9jaGFpbik7XG5cdCAgICB0aGlzLl9uZXN0ZWRfY3Vyc29yID0gY29weSh0aGlzLl9uZXN0ZWRfY3Vyc29yKTtcblxuXHQgICAgaWYgKHRoaXMuX25lc3RlZF9jaGFpbi5sZW5ndGgpIHtcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX25lc3RlZF9jaGFpbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmICghdGhpcy5kYXRhLmJyYW5jaFt0aGlzLl9uZXN0ZWRfY2hhaW5baV1dKSB7XG5cdCAgICAgICAgICB0aGlzLl9uZXN0ZWRfY2hhaW4uc3BsaWNlKGksIDEpO1xuXG5cdCAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGxhc3RDaGFpbiA9IHRoaXMuX25lc3RlZF9jaGFpbi5sZW5ndGggPyB0aGlzLl9uZXN0ZWRfY2hhaW5bdGhpcy5fbmVzdGVkX2NoYWluLmxlbmd0aCAtIDFdIDogMDtcblx0ICAgIHRoaXMuX25lc3RlZF9jdXJzb3IgPSBjb3B5KHRoaXMuZGF0YS5icmFuY2hbbGFzdENoYWluXSk7XG5cblx0ICAgIGlmICghdGhpcy5fbmVzdGVkX2N1cnNvci5sZW5ndGggJiYgdGhpcy5fbmVzdGVkX2NoYWluLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLl9uZXN0ZWRfY3Vyc29yID0gW2xhc3RDaGFpbl07XG5cblx0ICAgICAgdGhpcy5fbmVzdGVkX2NoYWluLnBvcCgpO1xuXHQgICAgfSAvLzw9IGVuZCBmaWx0ZXJpbmcgcHJvY2Vzc2luZ1xuXG5cblx0ICAgIGlmICh0aGlzLl9pbl9hbmltYXRpb24pIHtcblx0ICAgICAgcmV0dXJuIGRlbGF5KHRoaXMucmVuZGVyLCB0aGlzLCBhcmd1bWVudHMsIDEwMCk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9uZXN0ZWRfY3Vyc29yLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuZGF0YS5nZXRJdGVtKHRoaXMuX25lc3RlZF9jdXJzb3JbaV0pLiR0ZW1wbGF0ZSA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIGlmICghdGhpcy5fbmVzdGVkX2N1cnNvci5sZW5ndGgpIHRoaXMuX25lc3RlZF9jdXJzb3IgPSB0aGlzLmRhdGEuYnJhbmNoWzBdO1xuXHQgICAgdGhpcy5kYXRhLm9yZGVyID0gdG9BcnJheShbXS5jb25jYXQodGhpcy5fbmVzdGVkX2NoYWluKS5jb25jYXQodGhpcy5fbmVzdGVkX2N1cnNvcikpO1xuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGhpcy5kYXRhXSkpIHtcblx0ICAgICAgaWYgKHRoaXMuX25vX2FuaW1hdGlvbiB8fCAhdGhpcy5fZGF0YW9iai5pbm5lckhUTUwgfHwgIShhbmltYXRlLmlzU3VwcG9ydGVkKCkgJiYgdGhpcy5fc2V0dGluZ3MuYW5pbWF0ZSkgfHwgdGhpcy5fcHJldl9uZXN0ZWRfY2hhaW5fbGVuZ3RoID09IHRoaXMuX25lc3RlZF9jaGFpbi5sZW5ndGgpIHtcblx0ICAgICAgICAvLyBpZiBkYXRhb2JqIGlzIGVtcHR5IG9yIGFuaW1hdGlvbiBpcyBub3Qgc3VwcG9ydGVkXG5cdCAgICAgICAgUmVuZGVyU3RhY2sucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy9nZXRSYW5nZSAtIHJldHVybnMgYWxsIGVsZW1lbnRzXG5cdCAgICAgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVSZW5kZXJcIiwgW3RoaXMuZGF0YV0pKSB7XG5cdCAgICAgICAgICBpZiAoIXRoaXMuX2JhY2tfc2Nyb2xsX3N0YXRlcykgdGhpcy5fYmFja19zY3JvbGxfc3RhdGVzID0gW107XG5cblx0ICAgICAgICAgIHZhciBuZXh0X2RpdiA9IHRoaXMuX2RhdGFvYmouY2xvbmVOb2RlKGZhbHNlKTtcblxuXHQgICAgICAgICAgbmV4dF9kaXYuaW5uZXJIVE1MID0gdGhpcy5kYXRhLmdldFJhbmdlKCkubWFwKHRoaXMuX3RvSFRNTCwgdGhpcykuam9pbihcIlwiKTtcblx0ICAgICAgICAgIHZhciBhbmlzZXQgPSBleHBvcnRzLmV4dGVuZCh7fSwgdGhpcy5fc2V0dGluZ3MuYW5pbWF0ZSk7XG5cdCAgICAgICAgICBhbmlzZXQuZGlyZWN0aW9uID0gdGhpcy5faXNfbGV2ZWxfZG93biA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuXHQgICAgICAgICAgLypzY3JvbGwgcG9zaXRpb24gcmVzdG9yZSovXG5cblx0ICAgICAgICAgIHZhciBhbmltQXJyID0gW2Nsb25lKGFuaXNldCksIGNsb25lKGFuaXNldCldO1xuXG5cdCAgICAgICAgICBpZiAodGhpcy5faXNfbGV2ZWxfZG93bikge1xuXHQgICAgICAgICAgICB0aGlzLl9iYWNrX3Njcm9sbF9zdGF0ZXMucHVzaCh0aGlzLmdldFNjcm9sbFN0YXRlKCkpO1xuXG5cdCAgICAgICAgICAgIGlmIChUb3VjaCAmJiBUb3VjaC4kYWN0aXZlKSB7XG5cdCAgICAgICAgICAgICAgYW5pbUFyclswXS55ID0gMDtcblx0ICAgICAgICAgICAgICBhbmltQXJyWzFdLnkgPSAtdGhpcy5nZXRTY3JvbGxTdGF0ZSgpLnk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBnZXRTY3JvbGxTdGF0ZSA9IHRoaXMuX2JhY2tfc2Nyb2xsX3N0YXRlcy5wb3AoKTtcblxuXHQgICAgICAgICAgICBpZiAoVG91Y2ggJiYgVG91Y2guJGFjdGl2ZSkge1xuXHQgICAgICAgICAgICAgIGFuaW1BcnJbMF0ueSA9IC1nZXRTY3JvbGxTdGF0ZS55O1xuXHQgICAgICAgICAgICAgIGFuaW1BcnJbMV0ueSA9IC10aGlzLmdldFNjcm9sbFN0YXRlKCkueTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB2YXIgbGluZSA9IGFuaW1hdGUuZm9ybUxpbmUobmV4dF9kaXYsIHRoaXMuX2RhdGFvYmosIGFuaXNldCk7XG5cdCAgICAgICAgICAvKmtlZXBpbmcgc2Nyb2xsIHBvc2l0aW9uKi9cblxuXHQgICAgICAgICAgaWYgKFRvdWNoICYmIFRvdWNoLiRhY3RpdmUpIFRvdWNoLl9zZXRfbWF0cml4KG5leHRfZGl2LCAwLCB0aGlzLl9pc19sZXZlbF9kb3duID8gMCA6IGFuaW1BcnJbMF0ueSwgXCIwbXNcIik7XG5cdCAgICAgICAgICBhbmlzZXQubWFzdGVyID0gdGhpcztcblxuXHQgICAgICAgICAgYW5pc2V0LmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhb2JqID0gbmV4dF9kaXY7XG5cdCAgICAgICAgICAgIC8qc2Nyb2xsIHBvc2l0aW9uIHJlc3RvcmUqL1xuXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5faXNfbGV2ZWxfZG93bikge1xuXHQgICAgICAgICAgICAgIGlmIChUb3VjaCAmJiBUb3VjaC4kYWN0aXZlKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgIFRvdWNoLl9zZXRfbWF0cml4KG5leHRfZGl2LCAwLCBhbmltQXJyWzBdLnksIFwiMG1zXCIpO1xuXHQgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZXRTY3JvbGxTdGF0ZSkgdGhpcy5zY3JvbGxUbygwLCBnZXRTY3JvbGxTdGF0ZS55KTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICghKFRvdWNoICYmIFRvdWNoLiRhY3RpdmUpKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbygwLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGFuaW1hdGUuYnJlYWtMaW5lKGxpbmUpO1xuXHQgICAgICAgICAgICBhbmlzZXQubWFzdGVyID0gYW5pc2V0LmNhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5faHRtbG1hcCA9IG51bGw7IC8vY2xlYXIgbWFwLCBpdCB3aWxsIGJlIGZpbGxlZCBhdCBmaXJzdCBnZXRJdGVtTm9kZVxuXG5cdCAgICAgICAgICAgIHRoaXMuX2luX2FuaW1hdGlvbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgW10pO1xuXHQgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgdGhpcy5faW5fYW5pbWF0aW9uID0gdHJ1ZTtcblx0ICAgICAgICAgIGFuaW1hdGUobGluZSwgYW5pbUFycik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fcHJldl9uZXN0ZWRfY2hhaW5fbGVuZ3RoID0gdGhpcy5fbmVzdGVkX2NoYWluLmxlbmd0aDtcblx0ICAgIH1cblx0ICB9LFxuXHQgIHRlbXBsYXRlQmFja19zZXR0ZXI6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMudHlwZS50ZW1wbGF0ZUJhY2sgPSB0ZW1wbGF0ZShjb25maWcpO1xuXHQgIH0sXG5cdCAgdGVtcGxhdGVJdGVtX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy50eXBlLnRlbXBsYXRlSXRlbSA9IHRlbXBsYXRlKGNvbmZpZyk7XG5cdCAgfSxcblx0ICB0ZW1wbGF0ZUdyb3VwX3NldHRlcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy50eXBlLnRlbXBsYXRlR3JvdXAgPSB0ZW1wbGF0ZShjb25maWcpO1xuXHQgIH0sXG5cdCAgdHlwZToge1xuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICBpZiAob2JqLiRjb3VudCkgcmV0dXJuIGNvbW1vbi50ZW1wbGF0ZUdyb3VwKG9iaiwgY29tbW9uKTtcblx0ICAgICAgcmV0dXJuIGNvbW1vbi50ZW1wbGF0ZUl0ZW0ob2JqLCBjb21tb24pO1xuXHQgICAgfSxcblx0ICAgIGNzczogXCJncm91cFwiLFxuXHQgICAgY2xhc3NuYW1lOiBmdW5jdGlvbiAob2JqLCBjb21tb24sIG1hcmtzKSB7XG5cdCAgICAgIHJldHVybiBcIndlYml4X2xpc3RfaXRlbVwiICsgXCIgd2ViaXhfXCIgKyAob2JqLiRjb3VudCA/IFwiZ3JvdXBcIiA6IFwiaXRlbVwiKSArIChvYmouJHRlbXBsYXRlID8gXCJfYmFja1wiIDogXCJcIikgKyAobWFya3MgJiYgbWFya3Mud2ViaXhfc2VsZWN0ZWQgPyBcIiB3ZWJpeF9zZWxlY3RlZFwiIDogXCJcIikgKyAoY29tbW9uLmNzcyA/IFwiIFwiICsgY29tbW9uLmNzcyA6IFwiXCIpICsgKG9iai4kY3NzID8gXCIgXCIgKyBvYmouJGNzcyA6IFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlU3RhcnQ6IHRlbXBsYXRlKFwiPGRpdiB3ZWJpeF9sX2lkPVxcXCIjaWQjXFxcIiBjbGFzcz1cXFwie2NvbW1vbi5jbGFzc25hbWUoKX1cXFwiIHN0eWxlPVxcXCJ3aWR0aDp7Y29tbW9uLndpZHRoU2l6ZSgpfTsgaGVpZ2h0Ontjb21tb24uaGVpZ2h0U2l6ZSgpfTsgIG92ZXJmbG93OmhpZGRlbjtcXFwiIHtjb21tb24uYXJpYSgpfT5cIiksXG5cdCAgICB0ZW1wbGF0ZUJhY2s6IHRlbXBsYXRlKFwiI3ZhbHVlI1wiKSxcblx0ICAgIHRlbXBsYXRlSXRlbTogdGVtcGxhdGUoXCIjdmFsdWUjXCIpLFxuXHQgICAgdGVtcGxhdGVHcm91cDogdGVtcGxhdGUoXCIjdmFsdWUjXCIpLFxuXHQgICAgdGVtcGxhdGVFbmQ6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIGh0bWwgPSBcIlwiO1xuXHQgICAgICBpZiAob2JqLiRjb3VudCkgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X2Fycm93X2ljb24nPjwvZGl2PlwiO1xuXHQgICAgICBodG1sICs9IFwiPC9kaXY+XCI7XG5cdCAgICAgIHJldHVybiBodG1sO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgc2hvd0l0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIG9iaiwgcGFyZW50O1xuXG5cdCAgICBpZiAoaWQpIHtcblx0ICAgICAgb2JqID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgICAgcGFyZW50ID0gb2JqLiRwYXJlbnQ7XG5cdCAgICAgIGlmIChvYmouJGNvdW50KSBwYXJlbnQgPSBvYmouaWQ7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX25lc3RlZF9jdXJzb3IgPSB0aGlzLmRhdGEuYnJhbmNoW3BhcmVudCB8fCAwXTtcblx0ICAgIHRoaXMuX25lc3RlZF9jaGFpbiA9IFtdOyAvL2J1aWxkIF9uZXN0ZWRfY2hhaW5cblxuXHQgICAgd2hpbGUgKHBhcmVudCkge1xuXHQgICAgICB0aGlzLmdldEl0ZW0ocGFyZW50KS4kdGVtcGxhdGUgPSBcIkJhY2tcIjtcblxuXHQgICAgICB0aGlzLl9uZXN0ZWRfY2hhaW4udW5zaGlmdChwYXJlbnQpO1xuXG5cdCAgICAgIHBhcmVudCA9IHRoaXMuZ2V0SXRlbShwYXJlbnQpLiRwYXJlbnQ7XG5cdCAgICB9IC8vcmVuZGVyXG5cblxuXHQgICAgdGhpcy5fbm9fYW5pbWF0aW9uID0gdHJ1ZTtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB0aGlzLl9ub19hbmltYXRpb24gPSBmYWxzZTsgLy9zY3JvbGwgaWYgbmVjZXNzYXJ5XG5cblx0ICAgIFJlbmRlclN0YWNrLnNob3dJdGVtLmNhbGwodGhpcywgaWQpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckWiA9IGV4cG9ydHMucHJvdG9VSShhcGkkWiwgR3JvdXAsIGxpc3Qudmlldyk7XG5cblx0dHlwZSh2aWV3JFosIHt9KTtcblxuXHR2YXIgYXBpJF8gPSB7XG5cdCAgbmFtZTogXCJ1bml0bGlzdFwiLFxuXHQgIF9pZDogXCJ3ZWJpeF9pdGVtX2lkXCIsXG5cdCAgdW5pdGVCeV9zZXR0ZXI6IHRlbXBsYXRlLFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKGlkLCBkYXRhLCB0eXBlKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKGNvbmZpZy5pZCkpIHJldHVybjtcblx0ICAgIGlmICghY29uZmlnLnVuaXRlQnkpIHJldHVybjtcblxuXHQgICAgaWYgKGlkKSB7XG5cdCAgICAgIHZhciBjb250ID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7IC8vZ2V0IGh0bWwgZWxlbWVudCBvZiB1cGRhdGVkIGl0ZW1cblxuXHQgICAgICBpZiAoY29udCAmJiB0eXBlID09IFwidXBkYXRlXCIgJiYgdGhpcy5fc2V0dGluZ3MudW5pdGVCeS5jYWxsKHRoaXMsIGRhdGEpID09IHRoaXMuZ2V0SXRlbShpZCkuJHVuaXRWYWx1ZSkge1xuXHQgICAgICAgIHZhciB0ID0gdGhpcy5faHRtbG1hcFtpZF0gPSB0aGlzLl90b0hUTUxPYmplY3QoZGF0YSk7XG5cblx0ICAgICAgICBpbnNlcnRCZWZvcmUodCwgY29udCk7XG5cdCAgICAgICAgcmVtb3ZlKGNvbnQpO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfSAvL2Z1bGwgcmVzZXRcblxuXG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbdGhpcy5kYXRhXSkpIHtcblx0ICAgICAgdGhpcy51bml0cyA9IG51bGw7XG5cblx0ICAgICAgdGhpcy5fc2V0VW5pdHMoKTtcblxuXHQgICAgICBpZiAodGhpcy51bml0cykge1xuXHQgICAgICAgIHRoaXMuX2RhdGFvYmouaW5uZXJIVE1MID0gdGhpcy5fZ2V0VW5pdFJhbmdlKCkubWFwKHRoaXMuX3RvSFRNTCwgdGhpcykuam9pbihcIlwiKTtcblx0ICAgICAgICB0aGlzLl9odG1sbWFwID0gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclJlbmRlclwiLCBbXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRVbml0czogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG5cdCAgICBpZiAodGhpcy51bml0cykge1xuXHQgICAgICBmb3IgKHZhciBiIGluIHRoaXMudW5pdHMpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH0sXG5cdCAgZ2V0VW5pdExpc3Q6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMudW5pdHMgPyB0aGlzLnVuaXRzW2lkXSA6IG51bGw7XG5cdCAgfSxcblx0ICBfdG9IVE1MOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAvL2NoZWNrIGlmIHJlbGF0ZWQgdGVtcGxhdGUgZXhpc3Rcblx0ICAgIHZhciBtYXJrID0gdGhpcy5kYXRhLl9tYXJrc1tvYmouaWRdO1xuXHQgICAgYXNzZXJ0KCFvYmouJHRlbXBsYXRlIHx8IHRoaXMudHlwZVtcInRlbXBsYXRlXCIgKyBvYmouJHRlbXBsYXRlXSwgXCJSZW5kZXJTdGFjayA6OiBVbmtub3duIHRlbXBsYXRlOiBcIiArIG9iai4kdGVtcGxhdGUpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkl0ZW1SZW5kZXJcIiwgW29ial0pO1xuXG5cdCAgICBpZiAob2JqLiR1bml0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnR5cGUudGVtcGxhdGVTdGFydEhlYWRlcihvYmosIHRoaXMudHlwZSkgKyB0aGlzLnR5cGUudGVtcGxhdGVIZWFkZXIuY2FsbCh0aGlzLCBvYmouJHVuaXQpICsgdGhpcy50eXBlLnRlbXBsYXRlRW5kKG9iaiwgdGhpcy50eXBlKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMudHlwZS50ZW1wbGF0ZVN0YXJ0KG9iaiwgdGhpcy50eXBlLCBtYXJrKSArIChvYmouJHRlbXBsYXRlID8gdGhpcy50eXBlW1widGVtcGxhdGVcIiArIG9iai4kdGVtcGxhdGVdIDogdGhpcy50eXBlLnRlbXBsYXRlKShvYmosIHRoaXMudHlwZSkgKyB0aGlzLnR5cGUudGVtcGxhdGVFbmQob2JqLCB0aGlzLnR5cGUpO1xuXHQgIH0sXG5cdCAgX2dldFVuaXRSYW5nZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRhdGEsIGksIHUsIHVuaXQ7XG5cdCAgICBkYXRhID0gW107XG5cdCAgICB2YXIgbWluID0gdGhpcy5kYXRhLiRtaW4gfHwgMDtcblx0ICAgIHZhciBtYXggPSB0aGlzLmRhdGEuJG1heCB8fCBJbmZpbml0eTtcblx0ICAgIHZhciBjb3VudCA9IDA7XG5cblx0ICAgIGZvciAodSBpbiB0aGlzLnVuaXRzKSB7XG5cdCAgICAgIGRhdGEucHVzaCh7XG5cdCAgICAgICAgJHVuaXQ6IHVcblx0ICAgICAgfSk7XG5cdCAgICAgIHVuaXQgPSB0aGlzLnVuaXRzW3VdO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB1bml0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGNvdW50ID09IG1pbikgZGF0YSA9IFt7XG5cdCAgICAgICAgICAkdW5pdDogdVxuXHQgICAgICAgIH1dO1xuXHQgICAgICAgIGRhdGEucHVzaCh0aGlzLmdldEl0ZW0odW5pdFtpXSkpO1xuXHQgICAgICAgIGlmIChjb3VudCA9PSBtYXgpIHJldHVybiB0b0FycmF5KGRhdGEpO1xuXHQgICAgICAgIGNvdW50Kys7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRvQXJyYXkoZGF0YSk7XG5cdCAgfSxcblx0ICBfc2V0VW5pdHM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBsaXN0JCQxID0gdGhpcztcblx0ICAgIHRoaXMudW5pdHMgPSB7fTtcblx0ICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IGxpc3QkJDEuX3NldHRpbmdzLnVuaXRlQnkuY2FsbCh0aGlzLCBvYmopO1xuXG5cdCAgICAgIG9iai4kdW5pdFZhbHVlID0gcmVzdWx0O1xuXHQgICAgICBpZiAoIWxpc3QkJDEudW5pdHNbcmVzdWx0XSkgbGlzdCQkMS51bml0c1tyZXN1bHRdID0gW107XG5cdCAgICAgIGxpc3QkJDEudW5pdHNbcmVzdWx0XS5wdXNoKG9iai5pZCk7XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIHR5cGU6IHtcblx0ICAgIGhlYWRlckhlaWdodDogMjAsXG5cdCAgICB0ZW1wbGF0ZUhlYWRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPSd3ZWJpeF91bml0X2hlYWRlcl9pbm5lcic+XCIgKyB2YWx1ZSArIFwiPC9zcGFuPlwiO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlU3RhcnQ6IGZ1bmN0aW9uIChvYmosIHR5cGUsIG1hcmtzKSB7XG5cdCAgICAgIGlmIChvYmouJHVuaXQpIHJldHVybiB0eXBlLnRlbXBsYXRlU3RhcnRIZWFkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgdmFyIGNsYXNzTmFtZSA9IFwid2ViaXhfbGlzdF9pdGVtIHdlYml4X2xpc3RfXCIgKyB0eXBlLmNzcyArIFwiX2l0ZW1cIiArIChtYXJrcyAmJiBtYXJrcy53ZWJpeF9zZWxlY3RlZCA/IFwiIHdlYml4X3NlbGVjdGVkXCIgOiBcIlwiKSArIChvYmouJGNzcyA/IG9iai4kY3NzIDogXCJcIik7XG5cdCAgICAgIHZhciBzdHlsZSA9IFwid2lkdGg6XCIgKyB0eXBlLndpZHRoU2l6ZShvYmosIHR5cGUsIG1hcmtzKSArIFwiOyBoZWlnaHQ6XCIgKyB0eXBlLmhlaWdodFNpemUob2JqLCB0eXBlLCBtYXJrcykgKyBcIjsgb3ZlcmZsb3c6aGlkZGVuO1wiICsgKHR5cGUubGF5b3V0ICYmIHR5cGUubGF5b3V0ID09IFwieFwiID8gXCJmbG9hdDpsZWZ0O1wiIDogXCJcIik7XG5cdCAgICAgIHJldHVybiBcIjxkaXYgd2ViaXhfaXRlbV9pZD1cXFwiXCIgKyBvYmouaWQgKyBcIlxcXCIgY2xhc3M9XFxcIlwiICsgY2xhc3NOYW1lICsgXCJcXFwiIHN0eWxlPVxcXCJcIiArIHN0eWxlICsgXCJcXFwiIFwiICsgdHlwZS5hcmlhKG9iaiwgdHlwZSwgbWFya3MpICsgXCI+XCI7XG5cdCAgICB9LFxuXHQgICAgdGVtcGxhdGVTdGFydEhlYWRlcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgbWFya3MpIHtcblx0ICAgICAgdmFyIGNsYXNzTmFtZSA9IFwid2ViaXhfdW5pdF9oZWFkZXIgd2ViaXhfdW5pdF9cIiArIHR5cGUuY3NzICsgXCJfaGVhZGVyXCIgKyAob2JqLiRzZWxlY3RlZCA/IFwiX3NlbGVjdGVkXCIgOiBcIlwiKTtcblx0ICAgICAgdmFyIHN0eWxlID0gXCJ3aWR0aDpcIiArIHR5cGUud2lkdGhTaXplKG9iaiwgdHlwZSwgbWFya3MpICsgXCI7IGhlaWdodDpcIiArIHR5cGUuaGVhZGVySGVpZ2h0ICsgXCJweDsgb3ZlcmZsb3c6aGlkZGVuO1wiO1xuXHQgICAgICByZXR1cm4gXCI8ZGl2IHdlYml4X3VuaXRfaWQ9XFxcIlwiICsgb2JqLiR1bml0ICsgXCJcXFwiIGNsYXNzPVxcXCJcIiArIGNsYXNzTmFtZSArIFwiXFxcIiBzdHlsZT1cXFwiXCIgKyBzdHlsZSArIFwiXFxcIj5cIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnR5cGUuaGVhZGVySGVpZ2h0ID0gJGFjdGl2ZS51bml0SGVhZGVySGVpZ2h0O1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckXyA9IGV4cG9ydHMucHJvdG9VSShhcGkkXywgbGlzdC52aWV3KTtcblxuXHRpMThuLmRibGxpc3QgPSB7XG5cdCAgc2VsZWN0QWxsOiBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIHd4aS1hbmdsZS1kb3VibGUtcmlnaHQnPjwvc3Bhbj5cIixcblx0ICBzZWxlY3RPbmU6IFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLWFuZ2xlLXJpZ2h0Jz48L3NwYW4+XCIsXG5cdCAgZGVzZWxlY3RBbGw6IFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLWFuZ2xlLWRvdWJsZS1sZWZ0Jz48L3NwYW4+XCIsXG5cdCAgZGVzZWxlY3RPbmU6IFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLWFuZ2xlLWxlZnQnPjwvc3Bhbj5cIlxuXHR9O1xuXHR2YXIgYXBpJDEwID0ge1xuXHQgIG5hbWU6IFwiZGJsbGlzdFwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBib3JkZXJsZXNzOiB0cnVlXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fbW92ZWQgPSB7fTtcblx0ICAgIHRoaXMuX2luUmlnaHQgPSBiaW5kKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX21vdmVkW29iai5pZF07XG5cdCAgICB9LCB0aGlzKTtcblx0ICAgIHRoaXMuX2luTGVmdCA9IGJpbmQoZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gIXRoaXMuX21vdmVkW29iai5pZF07XG5cdCAgICB9LCB0aGlzKTtcblx0ICAgIHRoaXMuJHZpZXcuY2xhc3NOYW1lICs9IFwiIHdlYml4X2RibGxpc3RcIjtcblx0ICAgIHRoaXMuJHJlYWR5LnVuc2hpZnQodGhpcy5fc2V0TGF5b3V0KTtcblx0ICB9LFxuXHQgICRvbkxvYWQ6IGZ1bmN0aW9uIChkYXRhLCBkcml2ZXIpIHtcblx0ICAgIHRoaXMuX3VwZGF0ZUFuZFJlc2l6ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuJCQoXCJsZWZ0XCIpLmRhdGEuZHJpdmVyID0gZHJpdmVyO1xuXHQgICAgICB0aGlzLiQkKFwibGVmdFwiKS5wYXJzZShkYXRhKTtcblx0ICAgICAgdGhpcy4kJChcInJpZ2h0XCIpLmRhdGEuZHJpdmVyID0gZHJpdmVyO1xuXHQgICAgICB0aGlzLiQkKFwicmlnaHRcIikucGFyc2UoZGF0YSk7XG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fcmVmcmVzaCgpO1xuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF9nZXRCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYnV0dG9ucyA9PT0gZmFsc2UpIHJldHVybiB7XG5cdCAgICAgIHdpZHRoOiAxMFxuXHQgICAgfTtcblx0ICAgIHZhciBsb2NhbGUgPSBpMThuLmRibGxpc3Q7XG5cdCAgICB2YXIgYnV0dG9ucyA9IFt0aGlzLl9nZXRCdXR0b24oXCJkZXNlbGVjdF9hbGxcIiwgbG9jYWxlLmRlc2VsZWN0QWxsKSwgdGhpcy5fZ2V0QnV0dG9uKFwic2VsZWN0X2FsbFwiLCBsb2NhbGUuc2VsZWN0QWxsKSwgdGhpcy5fZ2V0QnV0dG9uKFwiZGVzZWxlY3Rfb25lXCIsIGxvY2FsZS5kZXNlbGVjdE9uZSksIHRoaXMuX2dldEJ1dHRvbihcInNlbGVjdF9vbmVcIiwgbG9jYWxlLnNlbGVjdE9uZSldO1xuXHQgICAgYnV0dG9ucyA9IHtcblx0ICAgICAgd2lkdGg6IDEyMCxcblx0ICAgICAgdGVtcGxhdGU6IGJ1dHRvbnMuam9pbihcIlwiKSxcblx0ICAgICAgb25DbGljazoge1xuXHQgICAgICAgIGRibGxpc3RfYnV0dG9uOiBmdW5jdGlvbiAoZSwgaWQsIHRyZykge1xuXHQgICAgICAgICAgdGhpcy5nZXRUb3BQYXJlbnRWaWV3KCkuX3VwZGF0ZV9saXN0KHRyZy5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5idXR0b25zKSBidXR0b25zLnRlbXBsYXRlID0gdGhpcy5fc2V0dGluZ3MuYnV0dG9ucztcblx0ICAgIHJldHVybiBidXR0b25zO1xuXHQgIH0sXG5cdCAgX2dldEJ1dHRvbjogZnVuY3Rpb24gKGFjdGlvbiwgbGFiZWwpIHtcblx0ICAgIHJldHVybiBcIjxidXR0b24gY2xhc3M9J2RibGxpc3RfYnV0dG9uJyBhY3Rpb249J1wiICsgYWN0aW9uICsgXCInPlwiICsgbGFiZWwgKyBcIjwvYnV0dG9uPlwiO1xuXHQgIH0sXG5cdCAgX2dldExpc3Q6IGZ1bmN0aW9uIChpZCwgYWN0aW9uLCBsYWJlbCwgYm90dG9tKSB7XG5cdCAgICB2YXIgbGlzdCA9IHtcblx0ICAgICAgdmlldzogXCJsaXN0XCIsXG5cdCAgICAgIHNlbGVjdDogXCJtdWx0aXNlbGVjdFwiLFxuXHQgICAgICBtdWx0aXNlbGVjdDogXCJ0b3VjaFwiLFxuXHQgICAgICBpZDogaWQsXG5cdCAgICAgIGFjdGlvbjogYWN0aW9uLFxuXHQgICAgICBkcmFnOiB0cnVlLFxuXHQgICAgICB0eXBlOiB7XG5cdCAgICAgICAgbWFyZ2luOiAzLFxuXHQgICAgICAgIGlkOiBpZFxuXHQgICAgICB9LFxuXHQgICAgICBvbjoge1xuXHQgICAgICAgIG9uQmVmb3JlRHJvcDogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LmZyb207XG5cdCAgICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGV4dC50bztcblx0ICAgICAgICAgIHZhciB0b3AgPSBzb3VyY2UuZ2V0VG9wUGFyZW50VmlldygpO1xuXG5cdCAgICAgICAgICBpZiAodG9wID09PSB0aGlzLmdldFRvcFBhcmVudFZpZXcoKSkge1xuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IHRhcmdldC5fc2V0dGluZ3MuYWN0aW9uICE9IFwic2VsZWN0X29uZVwiO1xuXHQgICAgICAgICAgICB0b3Auc2VsZWN0KGNvbnRleHQuc291cmNlLCBtb2RlKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb25JdGVtRGJsQ2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvcFBhcmVudFZpZXcoKS5fdXBkYXRlX2xpc3QodGhpcy5jb25maWcuYWN0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGlzdCkgZXhwb3J0cy5leHRlbmQobGlzdCwgdGhpcy5fc2V0dGluZ3MubGlzdCwgdHJ1ZSk7XG5cdCAgICBpZiAobGFiZWwpIGxpc3QgPSB7XG5cdCAgICAgIHJvd3M6IFt7XG5cdCAgICAgICAgdmlldzogXCJsYWJlbFwiLFxuXHQgICAgICAgIGxhYmVsOiBsYWJlbCxcblx0ICAgICAgICBjc3M6IFwid2ViaXhfaW5wX3RvcF9sYWJlbFwiXG5cdCAgICAgIH0sIGxpc3RdXG5cdCAgICB9O1xuXHQgICAgaWYgKGJvdHRvbSkgcmV0dXJuIHtcblx0ICAgICAgcm93czogW2xpc3QsIHtcblx0ICAgICAgICB2aWV3OiBcImxhYmVsXCIsXG5cdCAgICAgICAgaGVpZ2h0OiAyMCxcblx0ICAgICAgICBsYWJlbDogYm90dG9tLFxuXHQgICAgICAgIGNzczogXCJib3R0b21fbGFiZWxcIlxuXHQgICAgICB9XVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBsaXN0O1xuXHQgIH0sXG5cdCAgX3NldExheW91dDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNvbHMgPSBbe1xuXHQgICAgICBtYXJnaW46IDEwLFxuXHQgICAgICB0eXBlOiBcImNsZWFuXCIsXG5cdCAgICAgIGNvbHM6IFt0aGlzLl9nZXRMaXN0KFwibGVmdFwiLCBcInNlbGVjdF9vbmVcIiwgdGhpcy5fc2V0dGluZ3MubGFiZWxMZWZ0LCB0aGlzLl9zZXR0aW5ncy5sYWJlbEJvdHRvbUxlZnQpLCB0aGlzLl9nZXRCdXR0b25zKCksIHRoaXMuX2dldExpc3QoXCJyaWdodFwiLCBcImRlc2VsZWN0X29uZVwiLCB0aGlzLl9zZXR0aW5ncy5sYWJlbFJpZ2h0LCB0aGlzLl9zZXR0aW5ncy5sYWJlbEJvdHRvbVJpZ2h0KV1cblx0ICAgIH1dO1xuXHQgICAgdGhpcy5jb2xzX3NldHRlcihjb2xzKTtcblx0ICB9LFxuXHQgIF91cGRhdGVfbGlzdDogZnVuY3Rpb24gKGFjdGlvbikge1xuXHQgICAgdmFyIHRvcCA9IHRoaXM7XG5cdCAgICB2YXIgaWQgPSBudWxsO1xuXHQgICAgdmFyIG1vZGUgPSBmYWxzZTtcblxuXHQgICAgaWYgKGFjdGlvbiA9PT0gXCJzZWxlY3RfYWxsXCIpIHtcblx0ICAgICAgaWQgPSB0b3AuJCQoXCJsZWZ0XCIpLmRhdGEub3JkZXI7XG5cdCAgICAgIG1vZGUgPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwic2VsZWN0X29uZVwiKSB7XG5cdCAgICAgIGlkID0gdG9wLiQkKFwibGVmdFwiKS5nZXRTZWxlY3RlZElkKHRydWUpO1xuXHQgICAgICBtb2RlID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcImRlc2VsZWN0X2FsbFwiKSB7XG5cdCAgICAgIGlkID0gdG9wLiQkKFwicmlnaHRcIikuZGF0YS5vcmRlcjtcblx0ICAgICAgbW9kZSA9IGZhbHNlO1xuXHQgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IFwiZGVzZWxlY3Rfb25lXCIpIHtcblx0ICAgICAgaWQgPSB0b3AuJCQoXCJyaWdodFwiKS5nZXRTZWxlY3RlZElkKHRydWUpO1xuXHQgICAgICBtb2RlID0gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHRvcC5zZWxlY3QoaWQsIG1vZGUpO1xuXHQgIH0sXG5cdCAgc2VsZWN0OiBmdW5jdGlvbiAoaWQsIG1vZGUpIHtcblx0ICAgIHZhciBpO1xuXHQgICAgaWYgKF90eXBlb2YoaWQpICE9PSBcIm9iamVjdFwiKSBpZCA9IFtpZF07XG5cblx0ICAgIGlmIChtb2RlKSB7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMuX21vdmVkW2lkW2ldXSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGRlbGV0ZSB0aGlzLl9tb3ZlZFtpZFtpXV07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcmVmcmVzaCgpO1xuXG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQ2hhbmdlXCIsIFtdKTtcblx0ICB9LFxuXHQgIF91cGRhdGVBbmRSZXNpemU6IGZ1bmN0aW9uIChoYW5kbGVyLCBzaXplKSB7XG5cdCAgICBmcmVlemUoYmluZChoYW5kbGVyLCB0aGlzKSwgZmFsc2UpO1xuXHQgICAgaWYgKHNpemUgJiYgKHRoaXMuJCQoXCJsZWZ0XCIpLl9zZXR0aW5ncy5hdXRvaGVpZ2h0IHx8IHRoaXMuJCQoXCJyaWdodFwiKS5fc2V0dGluZ3MuYXV0b2hlaWdodCkpIHRoaXMucmVzaXplKCk7XG5cdCAgfSxcblx0ICBfcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGxlZnQgPSB0aGlzLiQkKFwibGVmdFwiKTtcblx0ICAgIHZhciByaWdodCA9IHRoaXMuJCQoXCJyaWdodFwiKTtcblx0ICAgIGlmIChsZWZ0KSB0aGlzLl91cGRhdGVBbmRSZXNpemUoZnVuY3Rpb24gKCkge1xuXHQgICAgICBsZWZ0LmZpbHRlcih0aGlzLl9pbkxlZnQpO1xuXHQgICAgICByaWdodC5maWx0ZXIodGhpcy5faW5SaWdodCk7XG5cdCAgICB9LCB0cnVlKTtcblx0ICB9LFxuXHQgIGZvY3VzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIVVJTWFuYWdlci5jYW5Gb2N1cyh0aGlzKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgVUlNYW5hZ2VyLnNldEZvY3VzKHRoaXMpO1xuXHQgIH0sXG5cdCAgdmFsdWVfc2V0dGVyOiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICB0aGlzLnNldFZhbHVlKHZhbCk7XG5cdCAgfSxcblx0ICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9tb3ZlZCA9IHt9O1xuXHQgICAgaWYgKF90eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoXCIsXCIpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX21vdmVkW3ZhbHVlW2ldXSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3JlZnJlc2goKTtcblx0ICB9LFxuXHQgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgdmFsdWUgPSBbXTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX21vdmVkKSB7XG5cdCAgICAgIHZhbHVlLnB1c2goa2V5KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlLmpvaW4oXCIsXCIpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMTAgPSBleHBvcnRzLnByb3RvVUkoYXBpJDEwLCBBdG9tRGF0YUxvYWRlciwgSWRTcGFjZSwgbGF5b3V0LnZpZXcpO1xuXG5cdHZhciBhcGkkMTEgPSB7XG5cdCAgbmFtZTogXCJ0cmVlXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHNjcm9sbDogXCJhdXRvXCIsXG5cdCAgICBuYXZpZ2F0aW9uOiB0cnVlXG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fdmlld29iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfdHJlZVwiOyAvL21hcCBBUEkgb2YgRGF0YVN0b3JlIG9uIHNlbGZcblxuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5kYXRhLCBUcmVlU3RvcmUsIHRydWUpO1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5vbl9jbGljaywgVHJlZUNsaWNrKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIHRoaXMuX3JlZnJlc2hfc2Nyb2xsKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvblBhcnRpYWxSZW5kZXJcIiwgdGhpcy5fcmVmcmVzaF9zY3JvbGwpO1xuXHQgICAgdGhpcy5kYXRhLnByb3ZpZGVBcGkodGhpcywgdHJ1ZSk7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRyZWVcIik7XG5cdCAgfSxcblx0ICAvL2F0dHJpYnV0ZSAsIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgSUQgc3RvcmluZ1xuXHQgIF9pZDogXCJ3ZWJpeF90bV9pZFwiLFxuXHQgIC8vc3VwcG9ydHMgY3VzdG9tIGNvbnRleHQgbWVudVxuXHQgIG9uX2NvbnRleHQ6IHt9LFxuXHQgIG9uX2RibGNsaWNrOiB7XG5cdCAgICB3ZWJpeF90cmVlX2NoZWNrYm94OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLm9uX2NsaWNrLndlYml4X3RyZWVfY2hlY2tib3gpIHJldHVybiB0aGlzLm9uX2NsaWNrLndlYml4X3RyZWVfY2hlY2tib3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgICRmaXhFZGl0b3I6IGZ1bmN0aW9uIChlZGl0b3IpIHtcblx0ICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtTm9kZShlZGl0b3IuaWQpLnF1ZXJ5U2VsZWN0b3IoXCJzcGFuXCIpO1xuXG5cdCAgICBpZiAoaXRlbSkge1xuXHQgICAgICBpZiAoaXRlbS5pbm5lckhUTUwgPT09IFwiXCIpIGl0ZW0uaW5uZXJIVE1MID0gXCImbmJzcDtcIjtcblx0ICAgICAgdmFyIHBhZGRpbmcgPSAxMDtcblx0ICAgICAgdmFyIHBvcyQkMSA9IGl0ZW0ub2Zmc2V0TGVmdDtcblx0ICAgICAgZWRpdG9yLm5vZGUuc3R5bGUud2lkdGggPSB0aGlzLiR2aWV3LnNjcm9sbFdpZHRoIC0gcG9zJCQxIC0gcGFkZGluZyArIFwicHhcIjtcblx0ICAgICAgZWRpdG9yLm5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IHBvcyQkMSArIFwicHhcIjtcblx0ICAgICAgZWRpdG9yLm5vZGUuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2NzcyBjbGFzcyB0byBhY3Rpb24gbWFwLCBmb3Igb25jbGljayBldmVudFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICB3ZWJpeF90cmVlX2l0ZW06IGZ1bmN0aW9uIChlLCBpZCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuYWN0aXZlVGl0bGUpIHtcblx0ICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICAgICAgaWYgKGl0ZW0ub3BlbikgdGhpcy5jbG9zZShpZCk7ZWxzZSB0aGlzLm9wZW4oaWQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNlbGVjdCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zZWxlY3QgPT0gXCJtdWx0aXNlbGVjdFwiIHx8IHRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0KSB7XG5cdCAgICAgICAgICB2YXIgbXVsdGltb2RlID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PSBcInRvdWNoXCI7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PSBcImxldmVsXCIgJiYgKG11bHRpbW9kZSB8fCBlLnNoaWZ0S2V5KSkge1xuXHQgICAgICAgICAgICAvL2FsbG93IG9ubHkgc2VsZWN0aW9uIG9uIHRoZSBzYW1lIGxldmVsXG5cdCAgICAgICAgICAgIHZhciBzZWxlY3QgPSB0aGlzLmdldFNlbGVjdGVkSWQodHJ1ZSlbMF07XG5cdCAgICAgICAgICAgIGlmIChzZWxlY3QgJiYgdGhpcy5nZXRQYXJlbnRJZChpZCkgIT0gdGhpcy5nZXRQYXJlbnRJZChzZWxlY3QpKSByZXR1cm47XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHRoaXMuc2VsZWN0KGlkLCBmYWxzZSwgbXVsdGltb2RlLCBlLnNoaWZ0S2V5KTsgLy9tdWx0aXNlbGVjdGlvblxuXHQgICAgICAgIH0gZWxzZSB0aGlzLnNlbGVjdChpZCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9wYXN0ZToge1xuXHQgICAgLy8gaW5zZXJ0IG5ldyBpdGVtIHdpdGggcGFzdGVkIHZhbHVlXG5cdCAgICBpbnNlcnQ6IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdCAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFNlbGVjdGVkSWQoKSB8fCBcIjBcIjtcblx0ICAgICAgdGhpcy5hZGQoe1xuXHQgICAgICAgIHZhbHVlOiB0ZXh0XG5cdCAgICAgIH0sIG51bGwsIHBhcmVudCk7XG5cdCAgICB9LFxuXHQgICAgLy8gY2hhbmdlIHZhbHVlIG9mIGVhY2ggc2VsZWN0ZWQgaXRlbVxuXHQgICAgbW9kaWZ5OiBmdW5jdGlvbiAodGV4dCkge1xuXHQgICAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUpO1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy5nZXRJdGVtKHNlbFtpXSkudmFsdWUgPSB0ZXh0O1xuXHQgICAgICAgIHRoaXMucmVmcmVzaChzZWxbaV0pO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgLy8gZG8gbm90aGluZ1xuXHQgICAgY3VzdG9tOiBmdW5jdGlvbiAoKSB7fVxuXHQgIH0sXG5cdCAgX2RyYWdfb3JkZXJfY29tcGxleDogdHJ1ZSxcblx0ICAkZHJhZ0hUTUw6IGZ1bmN0aW9uIChvYmosIGUsIGNvbnRleHQpIHtcblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90cmVlX2l0ZW0nPlwiICsgdGhpcy50eXBlLnRlbXBsYXRlKG9iaiwgdGhpcy50eXBlKSArIFwiPC9kaXY+XCI7XG5cdCAgICBpZiAoaXNBcnJheShjb250ZXh0LnNvdXJjZSkgJiYgY29udGV4dC5zb3VyY2UubGVuZ3RoID4gMSkgaHRtbCA9IHRoaXMuX3RvTXVsdGlwbGVIVE1MKGh0bWwsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgIF9jbG9zZV9icmFuY2hlczogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5jbG9zZShzb3VyY2VbaV0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NldF9kcm9wX2FyZWE6IGZ1bmN0aW9uICh0YXJnZXQsIHQpIHtcblx0ICAgIHZhciBub2RlID0gdGhpcy5nZXRJdGVtTm9kZSh0YXJnZXQpO1xuXG5cdCAgICBpZiAobm9kZSkge1xuXHQgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKERyYWdDb250cm9sLl9kcm9wSFRNTFswXSwgbm9kZSk7XG5cdCAgICB9IGVsc2UgdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChEcmFnQ29udHJvbC5fZHJvcEhUTUxbMF0pO1xuXHQgIH0sXG5cdCAgLy9jc3MgY2xhc3MgdG8gYWN0aW9uIG1hcCwgZm9yIGRibGNsaWNrIGV2ZW50XG5cdCAgdHlwZTogZXhwb3J0cy5leHRlbmQoe1xuXHQgICAgLy9ub3JtYWwgc3RhdGUgb2YgaXRlbVxuXHQgICAgdGVtcGxhdGU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICB2YXIgdGVtcGxhdGUkJDEgPSBjb21tb25bXCJ0ZW1wbGF0ZVwiICsgb2JqLmxldmVsXSB8fCBjb21tb24udGVtcGxhdGVDb21tb247XG5cdCAgICAgIHJldHVybiB0ZW1wbGF0ZSQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfSxcblx0ICAgIGNsYXNzbmFtZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uLCBtYXJrcykge1xuXHQgICAgICB2YXIgY3NzID0gXCJ3ZWJpeF90cmVlX2l0ZW1cIjtcblxuXHQgICAgICBpZiAob2JqLiRjc3MpIHtcblx0ICAgICAgICBpZiAoX3R5cGVvZihvYmouJGNzcykgPT0gXCJvYmplY3RcIikgb2JqLiRjc3MgPSBjcmVhdGVDc3Mob2JqLiRjc3MpO1xuXHQgICAgICAgIGNzcyArPSBcIiBcIiArIG9iai4kY3NzO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1hcmtzICYmIG1hcmtzLiRjc3MpIGNzcyArPSBcIiBcIiArIG1hcmtzLiRjc3M7XG5cdCAgICAgIGlmIChjb21tb24uY3NzKSBjc3MgKz0gXCIgXCIgKyBjb21tb24uY3NzO1xuXHQgICAgICByZXR1cm4gY3NzO1xuXHQgICAgfSxcblx0ICAgIGFyaWE6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgcmV0dXJuIFwicm9sZT1cXFwidHJlZWl0ZW1cXFwiXCIgKyAobWFya3MgJiYgbWFya3Mud2ViaXhfc2VsZWN0ZWQgPyBcIiBhcmlhLXNlbGVjdGVkPVxcXCJ0cnVlXFxcIiB0YWJpbmRleD1cXFwiMFxcXCJcIiA6IFwiIHRhYmluZGV4PVxcXCItMVxcXCJcIikgKyAob2JqLiRjb3VudCA/IFwiYXJpYS1leHBhbmRlZD1cXFwiXCIgKyAob2JqLm9wZW4gPyBcInRydWVcIiA6IFwiZmFsc2VcIikgKyBcIlxcXCJcIiA6IFwiXCIpICsgXCJhcmlhLWxldmVsPVxcXCJcIiArIG9iai4kbGV2ZWwgKyBcIlxcXCJcIjtcblx0ICAgIH0sXG5cdCAgICB0ZW1wbGF0ZUNvbW1vbjogdGVtcGxhdGUoXCJ7Y29tbW9uLmljb24oKX0ge2NvbW1vbi5mb2xkZXIoKX0gPHNwYW4+I3ZhbHVlIzwvc3Bhbj5cIiksXG5cdCAgICB0ZW1wbGF0ZVN0YXJ0OiB0ZW1wbGF0ZShcIjxkaXYgd2ViaXhfdG1faWQ9XFxcIiNpZCNcXFwiIGNsYXNzPVxcXCJ7Y29tbW9uLmNsYXNzbmFtZSgpfVxcXCIge2NvbW1vbi5hcmlhKCl9PlwiKSxcblx0ICAgIHRlbXBsYXRlRW5kOiB0ZW1wbGF0ZShcIjwvZGl2PlwiKSxcblx0ICAgIHRlbXBsYXRlQ29weTogdGVtcGxhdGUoXCIjdmFsdWUjXCIpXG5cdCAgfSwgVHJlZVR5cGUpXG5cdH07XG5cdHZhciB2aWV3JDExID0gZXhwb3J0cy5wcm90b1VJKGFwaSQxMSwgVHJlZVN0YXRlQ2hlY2tib3gsIEdyb3VwLCBUcmVlQVBJLCBEcmFnSXRlbSwgVHJlZURhdGFNb3ZlLCBTZWxlY3Rpb25Nb2RlbCwgS2V5c05hdmlnYXRpb24sIE1vdXNlRXZlbnRzLCBTY3JvbGxhYmxlLCBUcmVlRGF0YUxvYWRlciwgcHJvdG8udmlldywgVHJlZVJlbmRlclN0YWNrLCBDb3B5UGFzdGUsIEV2ZW50U3lzdGVtKTtcblx0dmFyIHRyZWUgPSB7XG5cdCAgYXBpOiBhcGkkMTEsXG5cdCAgdmlldzogdmlldyQxMVxuXHR9O1xuXHR0eXBlKHZpZXckMTEsIHtcblx0ICBuYW1lOiBcImxpbmVUcmVlXCIsXG5cdCAgY3NzOiBcIndlYml4TGluZVRyZWVcIixcblx0ICBpY29uOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgIHZhciBodG1sID0gXCJcIjtcblx0ICAgIHZhciBvcGVuID0gXCJcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gb2JqLiRsZXZlbDsgaSsrKSB7XG5cdCAgICAgIGlmIChpID09IG9iai4kbGV2ZWwpIG9wZW4gPSBvYmouJGNvdW50ID8gb2JqLm9wZW4gPyBcIndlYml4X3RyZWVfb3BlbiBcIiA6IFwid2ViaXhfdHJlZV9jbG9zZSBcIiA6IFwid2ViaXhfdHJlZV9ub25lIFwiO1xuXG5cdCAgICAgIHZhciBpY29uID0gY29tbW9uLl9pY29uX3NyYyhvYmosIGNvbW1vbiwgaSk7XG5cblx0ICAgICAgaWYgKGljb24pIGh0bWwgKz0gXCI8ZGl2IGNsYXNzPSdcIiArIG9wZW4gKyBcIndlYml4X3RyZWVfaW1nIHdlYml4X3RyZWVfXCIgKyBpY29uICsgXCInPjwvZGl2PlwiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgIF9pY29uX3NyYzogZnVuY3Rpb24gKG9iaiwgY29tbW9uLCBsZXZlbCkge1xuXHQgICAgdmFyIGxpbmVzID0gY29tbW9uLl90cmVlX2JyYW5jaF9yZW5kZXJfc3RhdGU7XG5cdCAgICB2YXIgdHJlZSA9IFRyZWVSZW5kZXJTdGFjay5fb2JqO1xuXG5cdCAgICBpZiAobGluZXMgPT09IDAgJiYgdHJlZSkge1xuXHQgICAgICAvL3dlIGFyZSBpbiBzdGFuZGFsb25lIHJlbmRlcmluZyBcblx0ICAgICAgLy9uZWVkIHRvIHJlY29uc3RydWN0IHJlbmRlcmluZyBzdGF0ZVxuXHQgICAgICB2YXIgbGluZXNfbGV2ZWwgPSBvYmouJGxldmVsO1xuXHQgICAgICB2YXIgYnJhbmNoX2lkID0gb2JqLmlkO1xuXHQgICAgICBsaW5lcyA9IFtdO1xuXG5cdCAgICAgIHdoaWxlIChsaW5lc19sZXZlbCkge1xuXHQgICAgICAgIHZhciBwYXJlbnRfaWQgPSB0cmVlLmdldFBhcmVudElkKGJyYW5jaF9pZCk7XG5cdCAgICAgICAgdmFyIHBicmFuY2ggPSB0cmVlLmRhdGEuYnJhbmNoW3BhcmVudF9pZF07XG5cdCAgICAgICAgaWYgKHBicmFuY2hbcGJyYW5jaC5sZW5ndGggLSAxXSA9PSBicmFuY2hfaWQpIGxpbmVzW2xpbmVzX2xldmVsXSA9IHRydWU7XG5cdCAgICAgICAgYnJhbmNoX2lkID0gcGFyZW50X2lkO1xuXHQgICAgICAgIGxpbmVzX2xldmVsLS07XG5cdCAgICAgIH0gLy9zdG9yZSBmb3IgbmV4dCByb3VuZFxuXG5cblx0ICAgICAgY29tbW9uLl90cmVlX2JyYW5jaF9yZW5kZXJfc3RhdGUgPSBsaW5lcztcblx0ICAgIH1cblxuXHQgICAgaWYgKCFsaW5lcykgcmV0dXJuIDA7IC8vbmVlZCB0byBiZSByZXBsYWNlZCB3aXRoIGltYWdlIHVybHNcblxuXHQgICAgaWYgKGxldmVsID09IG9iai4kbGV2ZWwpIHtcblx0ICAgICAgdmFyIG1vZGUgPSAzOyAvLzMtd2F5IGxpbmVcblxuXHQgICAgICBpZiAoIW9iai4kcGFyZW50KSB7XG5cdCAgICAgICAgLy90b3AgbGV2ZWxcblx0ICAgICAgICBpZiAob2JqLiRpbmRleCA9PT0gMCkgbW9kZSA9IDQ7IC8vZmlydHMgdG9wIGl0ZW1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChsaW5lc1tvYmouJGxldmVsXSkgbW9kZSA9IDI7XG5cblx0ICAgICAgaWYgKG9iai4kY291bnQpIHtcblx0ICAgICAgICBpZiAob2JqLm9wZW4pIHJldHVybiBcIm1pbnVzXCIgKyBtb2RlO2Vsc2UgcmV0dXJuIFwicGx1c1wiICsgbW9kZTtcblx0ICAgICAgfSBlbHNlIHJldHVybiBcImxpbmVcIiArIG1vZGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoIWxpbmVzW2xldmVsXSkgcmV0dXJuIFwibGluZTFcIjtcblx0ICAgICAgcmV0dXJuIFwiYmxhbmtcIjtcblx0ICAgIH1cblx0ICB9XG5cdH0pO1xuXG5cdHZhciBhcGkkMTIgPSB7XG5cdCAgbmFtZTogXCJ0cmVlbWFwXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIGFjdGl2ZUl0ZW06IGZhbHNlLFxuXHQgICAgc3ViUmVuZGVyOiB0cnVlLFxuXHQgICAgaGVhZGVyOiB0cnVlLFxuXHQgICAgaGVhZGVySGVpZ2h0OiAzNSxcblx0ICAgIHZhbHVlOiB0ZW1wbGF0ZShcIiN2YWx1ZSNcIiksXG5cdCAgICBoZWFkZXJUZW1wbGF0ZTogXCJcIixcblx0ICAgIG5hdmlnYXRpb246IHRydWVcblx0ICB9LFxuXHQgIHZhbHVlX3NldHRlcjogdGVtcGxhdGUsXG5cdCAgaGVhZGVyVGVtcGxhdGVfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICBoZWFkZXJfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gdHJ1ZSkge1xuXHQgICAgICB0aGlzLnR5cGUuaGVhZGVyID0gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLiR2aWV3LmNsYXNzTmFtZSArPSBcIiB3ZWJpeF90cmVlbWFwXCI7XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRyZWVcIik7XG5cblx0ICAgIHRoaXMuX2h0bWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcblx0ICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMuZGF0YSwgVHJlZVN0b3JlLCB0cnVlKTtcblx0ICAgIHRoaXMuZGF0YS5wcm92aWRlQXBpKHRoaXMsIHRydWUpO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25DbGVhckFsbFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5faHRtbCA9IFwiXCI7XG5cdCAgICAgIHRoaXMuJHZhbHVlcyA9IHt9O1xuXHQgICAgICB0aGlzLiR4eSA9IHt9O1xuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uS2V5UHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyk7XG5cdCAgfSxcblx0ICBfdG9IVE1MSXRlbTogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIG1hcmsgPSB0aGlzLmRhdGEuX21hcmtzW29iai5pZF07XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uSXRlbVJlbmRlclwiLCBbb2JqXSk7XG5cdCAgICB2YXIgdGVtcGxhdGUkJDEgPSBvYmouJHRlbXBsYXRlID8gdGhpcy50eXBlW1widGVtcGxhdGVcIiArIG9iai4kdGVtcGxhdGVdLmNhbGwodGhpcywgb2JqLCB0aGlzLnR5cGUsIG1hcmspIDogdGhpcy50eXBlLnRlbXBsYXRlLmNhbGwodGhpcywgb2JqLCB0aGlzLnR5cGUsIG1hcmspO1xuXHQgICAgcmV0dXJuIHRoaXMudHlwZS50ZW1wbGF0ZVN0YXJ0LmNhbGwodGhpcywgb2JqLCB0aGlzLnR5cGUsIG1hcmspICsgdGVtcGxhdGUkJDEgKyB0aGlzLnR5cGUudGVtcGxhdGVFbmQuY2FsbCh0aGlzKTtcblx0ICB9LFxuXHQgIF9yZW5kZXJIZWFkZXI6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuXHQgICAgdmFyIGhlaWdodCA9IHRoaXMuX3NldHRpbmdzLmhlYWRlckhlaWdodDtcblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90cmVlbWFwX2hlYWRlcicgc3R5bGU9J2hlaWdodDpcIiArIGhlaWdodCArIFwicHg7bGluZS1oZWlnaHQ6XCIgKyBoZWlnaHQgKyBcInB4Oyc+XCI7XG5cdCAgICBodG1sICs9IHRoaXMudHlwZS5oZWFkZXIuY2FsbCh0aGlzLCBpdGVtLCB0aGlzLnR5cGUpO1xuXHQgICAgaHRtbCArPSBcIjwvZGl2PlwiO1xuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICBfcmVuZGVyQnJhbmNoOiBmdW5jdGlvbiAocElkKSB7XG5cdCAgICB2YXIgc2l6ZXMsXG5cdCAgICAgICAgcm93LFxuXHQgICAgICAgIHZhbHVlLFxuXHQgICAgICAgIHN1bSxcblx0ICAgICAgICBsZWF2ZXMgPSBbXTtcblxuXHQgICAgaWYgKCF0aGlzLiR3aWR0aCB8fCAhdGhpcy5jb3VudCgpKSB7XG5cdCAgICAgIHRoaXMuX2h0bWwgPSBcIlwiO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIGlmICghcElkKSB7XG5cdCAgICAgIHBJZCA9IHRoaXMuY29uZmlnLmJyYW5jaCB8fCAwO1xuXHQgICAgICB0aGlzLl9odG1sID0gXCJcIjtcblx0ICAgICAgdGhpcy4kdmFsdWVzID0ge307XG5cdCAgICAgIHRoaXMuJHh5ID0ge307XG5cdCAgICAgIHRoaXMuJHh5W3BJZF0gPSB7XG5cdCAgICAgICAgd2lkdGg6IHRoaXMuJHdpZHRoLFxuXHQgICAgICAgIGhlaWdodDogdGhpcy4kaGVpZ2h0LFxuXHQgICAgICAgIHRvcDogMCxcblx0ICAgICAgICBsZWZ0OiAwXG5cdCAgICAgIH07IC8vIGhlYWRlclxuXG5cdCAgICAgIGlmIChwSWQgJiYgdGhpcy5fc2V0dGluZ3MuaGVhZGVyKSB7XG5cdCAgICAgICAgdGhpcy4keHlbcElkXS5oZWlnaHQgLT0gdGhpcy5fc2V0dGluZ3MuaGVhZGVySGVpZ2h0O1xuXHQgICAgICAgIHRoaXMuJHh5W3BJZF0udG9wID0gdGhpcy5fc2V0dGluZ3MuaGVhZGVySGVpZ2h0O1xuXHQgICAgICAgIHRoaXMuX2h0bWwgKz0gdGhpcy5fcmVuZGVySGVhZGVyKHBJZCk7XG5cdCAgICAgIH0gLy8gdmFsdWVzIGNhbGN1bGF0aW9uXG5cblxuXHQgICAgICBzdW0gPSAwO1xuXHQgICAgICB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMuZ2V0UGFyZW50SWQoaXRlbS5pZCk7XG5cblx0ICAgICAgICBpZiAoIXRoaXMuZGF0YS5icmFuY2hbaXRlbS5pZF0pIHtcblx0ICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25maWcudmFsdWUuY2FsbCh0aGlzLCBpdGVtKSAqIDE7XG5cblx0ICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuJHZhbHVlc1tpdGVtLmlkXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKHBhcmVudElkKSB7XG5cdCAgICAgICAgICAgICAgaWYgKCF0aGlzLiR2YWx1ZXNbcGFyZW50SWRdKSB0aGlzLiR2YWx1ZXNbcGFyZW50SWRdID0gMDtcblx0ICAgICAgICAgICAgICB0aGlzLiR2YWx1ZXNbcGFyZW50SWRdICs9IHZhbHVlO1xuXHQgICAgICAgICAgICAgIHBhcmVudElkID0gdGhpcy5nZXRQYXJlbnRJZChwYXJlbnRJZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHRoaXMsIGZhbHNlLCBwSWQpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmRhdGEuZWFjaENoaWxkKHBJZCwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgaWYgKHRoaXMuJHZhbHVlc1tpdGVtLmlkXSkgbGVhdmVzLnB1c2goY29weShpdGVtKSk7XG5cdCAgICB9LCB0aGlzKTtcblx0ICAgIHN1bSA9IHN1bSB8fCB0aGlzLiR2YWx1ZXNbcElkXTtcblxuXHQgICAgaWYgKGxlYXZlcy5sZW5ndGggJiYgc3VtKSB7XG5cdCAgICAgIHNpemVzID0gdGhpcy4keHlbcElkXTtcblx0ICAgICAgcm93ID0ge1xuXHQgICAgICAgIHRvcDogc2l6ZXMudG9wLFxuXHQgICAgICAgIGxlZnQ6IHNpemVzLmxlZnQsXG5cdCAgICAgICAgZHg6IHNpemVzLndpZHRoLFxuXHQgICAgICAgIGR5OiBzaXplcy5oZWlnaHQsXG5cdCAgICAgICAgc2V0OiBbXSxcblx0ICAgICAgICBzdW06IDBcblx0ICAgICAgfTtcblx0ICAgICAgcm93LmRpbSA9IE1hdGgubWluKHJvdy5keCwgcm93LmR5KTtcblx0ICAgICAgdmFyIGRlbHRhID0gcm93LmR4ICogcm93LmR5IC8gc3VtOyAvL3RvdGFsIGFyZWFcblxuXHQgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVhdmVzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIGxlYXZlc1tfaV0uJHZhbHVlID0gdGhpcy4kdmFsdWVzW2xlYXZlc1tfaV0uaWRdICogZGVsdGE7XG5cdCAgICAgIH0gLy9ub3JtYWxpemVkIHZhbHVlXG5cblxuXHQgICAgICBsZWF2ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgIHJldHVybiBhLiR2YWx1ZSA+IGIuJHZhbHVlID8gLTEgOiAxO1xuXHQgICAgICB9KTtcblx0ICAgICAgdmFyIGJhZCA9IEluZmluaXR5O1xuXHQgICAgICB2YXIgaSA9IDA7XG5cblx0ICAgICAgd2hpbGUgKGxlYXZlc1tpXSkge1xuXHQgICAgICAgIHZhciBjaGVjayA9IHRoaXMuX3dvcnN0KHJvdywgbGVhdmVzW2ldKTtcblxuXHQgICAgICAgIGlmIChjaGVjayA8IGJhZCkge1xuXHQgICAgICAgICAgcm93LnN1bSArPSBsZWF2ZXNbaV0uJHZhbHVlO1xuXHQgICAgICAgICAgcm93LnNldC5wdXNoKGxlYXZlc1tpXSk7XG5cdCAgICAgICAgICBiYWQgPSBjaGVjaztcblx0ICAgICAgICAgIGkrKztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5fcmVuZGVyUm93KHJvdyk7XG5cblx0ICAgICAgICAgIHZhciByID0ge1xuXHQgICAgICAgICAgICB0b3A6IHJvdy50b3AsXG5cdCAgICAgICAgICAgIGxlZnQ6IHJvdy5sZWZ0LFxuXHQgICAgICAgICAgICBkeDogcm93LmR4LFxuXHQgICAgICAgICAgICBkeTogcm93LmR5LFxuXHQgICAgICAgICAgICBzZXQ6IFtdLFxuXHQgICAgICAgICAgICBzdW06IDBcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgICAgIHZhciBfZGVsdGEgPSByb3cuc3VtIC8gcm93LmRpbTtcblxuXHQgICAgICAgICAgaWYgKHJvdy5keCA+IHJvdy5keSkge1xuXHQgICAgICAgICAgICByLmxlZnQgKz0gX2RlbHRhO1xuXHQgICAgICAgICAgICByLmR4IC09IF9kZWx0YTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHIudG9wICs9IF9kZWx0YTtcblx0ICAgICAgICAgICAgci5keSAtPSBfZGVsdGE7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJvdyA9IHI7XG5cdCAgICAgICAgICByb3cuZGltID0gTWF0aC5taW4ocm93LmR4LCByb3cuZHkpO1xuXHQgICAgICAgICAgYmFkID0gSW5maW5pdHk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChyb3cpIHRoaXMuX3JlbmRlclJvdyhyb3cpO1xuXHQgIH0sXG5cdCAgX3JlbmRlclJvdzogZnVuY3Rpb24gKHJvdykge1xuXHQgICAgdmFyIGksXG5cdCAgICAgICAgaWQsXG5cdCAgICAgICAgeCxcblx0ICAgICAgICB5LFxuXHQgICAgICAgIHRvcCA9IHJvdy50b3AsXG5cdCAgICAgICAgbGVmdCA9IHJvdy5sZWZ0O1xuXHQgICAgcm93Lm1vZGUgPSByb3cuZHkgPCByb3cuZHg7XG5cdCAgICByb3cuY29udHJhID0gcm93LnN1bSAvIHJvdy5kaW07XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCByb3cuc2V0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlkID0gcm93LnNldFtpXS5pZDtcblxuXHQgICAgICBpZiAocm93Lm1vZGUpIHtcblx0ICAgICAgICB4ID0gcm93LmNvbnRyYTtcblx0ICAgICAgICB5ID0gcm93LnNldFtpXS4kdmFsdWUgLyByb3cuY29udHJhO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHggPSByb3cuc2V0W2ldLiR2YWx1ZSAvIHJvdy5jb250cmE7XG5cdCAgICAgICAgeSA9IHJvdy5jb250cmE7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLiR4eVtpZF0gPSB7fTtcblx0ICAgICAgdGhpcy4keHlbaWRdLnRvcCA9IHRvcDtcblx0ICAgICAgdGhpcy4keHlbaWRdLmxlZnQgPSBsZWZ0O1xuXHQgICAgICBpZiAocm93Lm1vZGUpIHRvcCArPSB5O2Vsc2UgbGVmdCArPSB4O1xuXHQgICAgICB0aGlzLiR4eVtpZF0ud2lkdGggPSB4O1xuXHQgICAgICB0aGlzLiR4eVtpZF0uaGVpZ2h0ID0geTtcblx0ICAgICAgdGhpcy5faHRtbCArPSB0aGlzLl90b0hUTUxJdGVtKHRoaXMuZ2V0SXRlbShpZCkpO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc3ViUmVuZGVyICYmIHRoaXMuZGF0YS5icmFuY2hbaWRdKSB0aGlzLl9yZW5kZXJCcmFuY2goaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3dvcnN0OiBmdW5jdGlvbiAocm93LCBhZGQpIHtcblx0ICAgIHZhciBzID0gcm93LnN1bSArIGFkZC4kdmFsdWU7XG5cdCAgICB2YXIgYSA9IHMgKiBzIC8gKHJvdy5kaW0gKiByb3cuZGltICogYWRkLiR2YWx1ZSk7XG5cblx0ICAgIGlmIChyb3cuc2V0Lmxlbmd0aCkge1xuXHQgICAgICBhID0gTWF0aC5tYXgocm93LmRpbSAqIHJvdy5kaW0gKiByb3cuc2V0WzBdLiR2YWx1ZSAvIChzICogcyksIGEpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYSA+IDEgPyBhIDogMSAvIGE7XG5cdCAgfSxcblx0ICBfdG9IVE1MT2JqZWN0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICB0aGlzLl9odG1sRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl90b0hUTUxJdGVtKG9iaik7XG5cdCAgICByZXR1cm4gdGhpcy5faHRtbEVsZW1lbnQuZmlyc3RDaGlsZDtcblx0ICB9LFxuXHQgIHNob3dCcmFuY2g6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5fc2V0dGluZ3MuYnJhbmNoID0gaWQ7XG5cdCAgICB0aGlzLnJlZnJlc2goKTtcblx0ICB9LFxuXHQgIHJlbmRlcjogZnVuY3Rpb24gKGlkLCBkYXRhLCB0eXBlKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKHRoaXMuX3NldHRpbmdzLmlkKSB8fCB0aGlzLiRibG9ja1JlbmRlcikgcmV0dXJuO1xuXG5cdCAgICBpZiAodHlwZSA9PSBcInVwZGF0ZVwiKSB7XG5cdCAgICAgIHZhciBjb250ID0gdGhpcy5nZXRJdGVtTm9kZShpZCk7IC8vZ2V0IGh0bWwgZWxlbWVudCBvZiB1cGRhdGVkIGl0ZW1cblxuXHQgICAgICBpZiAoY29udCkge1xuXHQgICAgICAgIHZhciB0ID0gdGhpcy5faHRtbG1hcFtpZF0gPSB0aGlzLl90b0hUTUxPYmplY3QoZGF0YSk7XG5cblx0ICAgICAgICBpbnNlcnRCZWZvcmUodCwgY29udCk7XG5cdCAgICAgICAgcmVtb3ZlKGNvbnQpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5icmFuY2ggJiYgKCF0aGlzLl9zZXR0aW5ncy5icmFuY2ggfHwgdGhpcy5kYXRhLmJyYW5jaFt0aGlzLl9zZXR0aW5ncy5icmFuY2hdKSkge1xuXHQgICAgICB0aGlzLl9odG1sbWFwID0gbnVsbDtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVJlbmRlclwiLCBbXSk7XG5cblx0ICAgICAgdGhpcy5fcmVuZGVyQnJhbmNoKCk7XG5cblx0ICAgICAgdGhpcy5fZGF0YW9iai5pbm5lckhUTUwgPSB0aGlzLl9odG1sO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJSZW5kZXJcIiwgW10pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgIF9pZDogXCJ3ZWJpeF9kbV9pZFwiLFxuXHQgIG9uX2NsaWNrOiB7XG5cdCAgICB3ZWJpeF90cmVlbWFwX2l0ZW06IGZ1bmN0aW9uIChlLCBpZCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2VsZWN0KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNlbGVjdCA9PSBcIm11bHRpc2VsZWN0XCIgfHwgdGhpcy5fc2V0dGluZ3MubXVsdGlzZWxlY3QpIHRoaXMuc2VsZWN0KGlkLCBmYWxzZSwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PSBcInRvdWNoXCIsIGUuc2hpZnRLZXkpO2Vsc2UgdGhpcy5zZWxlY3QoaWQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUl0ZW0gJiYgdGhpcy5pc0JyYW5jaChpZCkpIHtcblx0ICAgICAgICB0aGlzLnNob3dCcmFuY2goaWQpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfdHJlZW1hcF9oZWFkZXJfaXRlbTogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIGlkID0gbG9jYXRlKGUsIFwid2ViaXhfZG1faGVhZGVyX2lkXCIpO1xuXHQgICAgICB0aGlzLmRlZmluZShcImJyYW5jaFwiLCBpZCk7XG5cdCAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X3RyZWVtYXBfcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5kZWZpbmUoXCJicmFuY2hcIiwgMCk7XG5cdCAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fZGJsY2xpY2s6IHt9LFxuXHQgIG9uX21vdXNlX21vdmU6IHt9LFxuXHQgIF9nZXRDc3NUZXh0OiBmdW5jdGlvbiAoc3R5bGUpIHtcblx0ICAgIHZhciBjc3MgPSBcIlwiO1xuXG5cdCAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZSkge1xuXHQgICAgICBjc3MgKz0gcHJvcGVydHkgKyBcIjpcIiArIHN0eWxlW3Byb3BlcnR5XSArIFwiO1wiO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY3NzO1xuXHQgIH0sXG5cdCAgdHlwZToge1xuXHQgICAgLy9ub3JtYWwgc3RhdGUgb2YgaXRlbVxuXHQgICAgdGVtcGxhdGU6IHRlbXBsYXRlKFwiI3ZhbHVlI1wiKSxcblx0ICAgIGhlYWRlcjogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgIHZhciBpZCA9IG9iai5pZDtcblx0ICAgICAgdmFyIHJlc2V0SWNvbiA9IFwiPGRpdiByb2xlPSdidXR0b24nIHRhYmluZGV4PScwJyBhcmlhLWxhYmVsPSdcIiArIGkxOG4uYXJpYS5yZXNldFRyZWVNYXAgKyBcIicgY2xhc3M9J3dlYml4X3RyZWVtYXBfcmVzZXQnPjwvZGl2PlwiO1xuXHQgICAgICB2YXIgYXJyID0gW107XG5cblx0ICAgICAgd2hpbGUgKGlkKSB7XG5cdCAgICAgICAgb2JqID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgICAgICBhcnIucHVzaChjb21tb24uaGVhZGVySXRlbS5jYWxsKHRoaXMsIG9iaiwgY29tbW9uKSk7XG5cdCAgICAgICAgaWQgPSB0aGlzLmdldFBhcmVudElkKGlkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGFyci5yZXZlcnNlKCk7XG5cdCAgICAgIHJldHVybiByZXNldEljb24gKyBhcnIuam9pbihcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIHd4aS1hbmdsZS1yaWdodCB3ZWJpeF90cmVlbWFwX3BhdGhfaWNvbic+PC9zcGFuPlwiKTtcblx0ICAgIH0sXG5cdCAgICBoZWFkZXJJdGVtOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB0ZW1wbGF0ZSQkMSA9IHRoaXMuY29uZmlnLmhlYWRlclRlbXBsYXRlKG9iaik7XG5cdCAgICAgIHZhciBodG1sID0gXCI8YSByb2xlPVxcXCJidXR0b25cXFwiIHRhYmluZGV4PVxcXCIwXFxcIiBhcmlhLWxhYmVsPVxcXCJcIiArIHRlbXBsYXRlJCQxICsgXCJcXFwiIHdlYml4X2RtX2hlYWRlcl9pZD1cXFwiXCIgKyBvYmouaWQgKyBcIlxcXCIgY2xhc3M9XFxcIndlYml4X3RyZWVtYXBfaGVhZGVyX2l0ZW1cXFwiPlwiO1xuXHQgICAgICBodG1sICs9IHRlbXBsYXRlJCQxO1xuXHQgICAgICBodG1sICs9IFwiPC9hPlwiO1xuXHQgICAgICByZXR1cm4gaHRtbDtcblx0ICAgIH0sXG5cdCAgICBjbGFzc25hbWU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgdmFyIGNzcyA9IFwid2ViaXhfdHJlZW1hcF9pdGVtXCI7XG5cdCAgICAgIGlmIChjb21tb24uY3NzKSBjc3MgKz0gXCIgXCIgKyBjb21tb24uY3NzO1xuXG5cdCAgICAgIGlmIChvYmouJGNzcykge1xuXHQgICAgICAgIGlmIChfdHlwZW9mKG9iai4kY3NzKSA9PSBcIm9iamVjdFwiKSBvYmouJGNzcyA9IGNyZWF0ZUNzcyhvYmouJGNzcyk7XG5cdCAgICAgICAgY3NzICs9IFwiIFwiICsgb2JqLiRjc3M7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgeHkgPSB0aGlzLiR4eVtvYmouaWRdO1xuXHQgICAgICBpZiAobWFya3MgJiYgbWFya3MuJGNzcykgY3NzICs9IFwiIFwiICsgbWFya3MuJGNzcztcblx0ICAgICAgY3NzICs9IFwiIHdlYml4X3RyZWVtYXBfbGV2ZWxfXCIgKyB0aGlzLmdldEl0ZW0ob2JqLmlkKS4kbGV2ZWw7XG5cdCAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMuZ2V0UGFyZW50SWQob2JqLmlkKTtcblx0ICAgICAgaWYgKCFwYXJlbnRJZCB8fCBwYXJlbnRJZCA9PSB0aGlzLl9zZXR0aW5ncy5icmFuY2gpIGNzcyArPSBcIiB3ZWJpeF90cmVlbWFwX2xldmVsX3RvcFwiO1xuXHQgICAgICBpZiAodGhpcy4kaGVpZ2h0IC0geHkudG9wIC0geHkuaGVpZ2h0IDwgMSkgY3NzICs9IFwiIHdlYml4X3RyZWVtYXBfaXRlbV9ib3R0b21cIjtcblx0ICAgICAgaWYgKHRoaXMuJHdpZHRoIC0geHkubGVmdCAtIHh5LndpZHRoIDwgMSkgY3NzICs9IFwiIHdlYml4X3RyZWVtYXBfaXRlbV9yaWdodFwiO1xuXG5cdCAgICAgIGlmIChjb21tb24uY3NzQ2xhc3MpIHtcblx0ICAgICAgICB2YXIgY3NzQ2xhc3MgPSBjb21tb24uY3NzQ2xhc3MuY2FsbCh0aGlzLCBvYmosIGNvbW1vbiwgbWFya3MpO1xuXG5cdCAgICAgICAgaWYgKGNzc0NsYXNzKSB7XG5cdCAgICAgICAgICBpZiAoX3R5cGVvZihjc3NDbGFzcykgPT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgICAgICBjc3MgKz0gXCIgXCIgKyBjcmVhdGVDc3MoY3NzQ2xhc3MpO1xuXHQgICAgICAgICAgfSBlbHNlIGNzcyArPSBcIiBcIiArIGNzc0NsYXNzO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBjc3M7XG5cdCAgICB9LFxuXHQgICAgdGVtcGxhdGVTdGFydDogZnVuY3Rpb24gKG9iaiwgdHlwZSwgbWFya3MpIHtcblx0ICAgICAgdmFyIHN0eWxlID0gXCJcIjtcblxuXHQgICAgICBpZiAodGhpcy4keHkpIHtcblx0ICAgICAgICB2YXIgeHkgPSB0aGlzLiR4eVtvYmouaWRdO1xuXHQgICAgICAgIHN0eWxlICs9IFwid2lkdGg6IFwiICsgeHkud2lkdGggKyBcInB4OyBoZWlnaHQ6IFwiICsgeHkuaGVpZ2h0ICsgXCJweDtcIjtcblx0ICAgICAgICBzdHlsZSArPSBcInRvcDogXCIgKyB4eS50b3AgKyBcInB4OyBsZWZ0OiBcIiArIHh5LmxlZnQgKyBcInB4O1wiO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIFwiPGRpdiByb2xlPVxcXCJ0cmVlaXRlbVxcXCIgYXJpYS1sZXZlbD1cXFwiXCIgKyBvYmouJGxldmVsICsgXCJcXFwiIFwiICsgKG1hcmtzICYmIG1hcmtzLndlYml4X3NlbGVjdGVkID8gXCJhcmlhLXNlbGVjdGVkPVxcXCJ0cnVlXFxcIiB0YWJpbmRleD1cXFwiMFxcXCJcIiA6IFwiXCIpICsgXCIgd2ViaXhfZG1faWQ9XFxcIlwiICsgb2JqLmlkICsgXCJcXFwiIGNsYXNzPVxcXCJcIiArIHR5cGUuY2xhc3NuYW1lLmNhbGwodGhpcywgb2JqLCB0eXBlLCBtYXJrcykgKyBcIlxcXCIgc3R5bGU9XFxcIlwiICsgc3R5bGUgKyBcIlxcXCI+XCI7XG5cdCAgICB9LFxuXHQgICAgdGVtcGxhdGVFbmQ6IHRlbXBsYXRlKFwiPC9kaXY+XCIpXG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQxMiA9IGV4cG9ydHMucHJvdG9VSShhcGkkMTIsIEdyb3VwLCBUcmVlQVBJLCBTZWxlY3Rpb25Nb2RlbCwgS2V5c05hdmlnYXRpb24sIE1vdXNlRXZlbnRzLCBTY3JvbGxhYmxlLCBUcmVlRGF0YUxvYWRlciwgcHJvdG8udmlldywgVHJlZVJlbmRlclN0YWNrLCBDb3B5UGFzdGUsIEV2ZW50U3lzdGVtKTtcblxuXHQvKlxuXHRcdFVJOkRhdGFWaWV3XG5cdCovXG5cdC8vICNpbmNsdWRlIHVpL2NvbXBvbmVudC5qc1xuXHQvLyAjaW5jbHVkZSBjb3JlL21vdXNlLmpzIFx0XG5cdC8vICNpbmNsdWRlIGNvcmUvZWRpdC5qcyBcblx0Ly8gI2luY2x1ZGUgY29yZS9zZWxlY3Rpb24uanMgXG5cdC8vICNpbmNsdWRlIGNvcmUvZHJhZy5qc1xuXHQvLyAjaW5jbHVkZSBjb3JlL21vdmUuanNcblx0Ly8gI2luY2x1ZGUgY29yZS92aXJ0dWFsX3JlbmRlci5qc1xuXHQvLyAjaW5jbHVkZSBjb3JlL2tleW5hdi5qc1xuXHQvLyAjaW5jbHVkZSBjb3JlL3ByaW50LmpzXG5cblx0dmFyIGFwaSQxMyA9IHtcblx0ICBuYW1lOiBcImRhdGF2aWV3XCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcuc2l6ZVRvQ29udGVudCkgLy9tZXRob2QgbmVlZCB0byBiZSBjYWxsZWQgYmVmb3JlIGRhdGEtbG9hZGVyc1xuXHQgICAgICAvL3NvIHdlIGFyZSB1c2luZyB1bnNoaWZ0IHRvIHBsYWNlIGl0IGF0IHN0YXJ0XG5cdCAgICAgIHRoaXMuJHJlYWR5LnVuc2hpZnQodGhpcy5fYWZ0ZXJfaW5pdF9jYWxsKTtcblx0ICAgIHZhciB0eXBlID0gY29uZmlnLnR5cGUgfHwgY29uZmlnLml0ZW07XG5cdCAgICB2YXIgcHJlcmVuZGVyID0gY29uZmlnLnByZXJlbmRlciB8fCB0aGlzLmRlZmF1bHRzLnByZXJlbmRlciB8fCB0eXBlICYmIHR5cGUud2lkdGggPT0gXCJhdXRvXCIgfHwgY29uZmlnLmRyYWcgPT0gXCJtb3ZlXCIgfHwgY29uZmlnLmRyYWcgPT0gXCJvcmRlclwiO1xuXHQgICAgaWYgKCFwcmVyZW5kZXIgJiYgIWNvbmZpZy5hdXRvaGVpZ2h0KSBleHBvcnRzLmV4dGVuZCh0aGlzLCBWaXJ0dWFsUmVuZGVyU3RhY2ssIHRydWUpO1xuXHQgICAgaWYgKGNvbmZpZy5hdXRvaGVpZ2h0KSBjb25maWcuc2Nyb2xsID0gZmFsc2U7XG5cblx0ICAgIGlmICh0eXBlICYmIHR5cGUudHlwZSA9PSBcInRpbGVzXCIpIHtcblx0ICAgICAgdGhpcy5fdmlld29iai5maXJzdENoaWxkLnN0eWxlLnBhZGRpbmcgPSBcIjhweFwiO1xuXHQgICAgICB0aGlzLl90aWxlc1BhZGRpbmcgPSA4O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9jb250ZW50b2JqLmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9kYXRhdmlld1wiO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xuXHQgIH0sXG5cdCAgX2FmdGVyX2luaXRfY2FsbDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHRlc3QgPSBjcmVhdGUoXCJESVZcIiwgMCwgdGhpcy50eXBlLnRlbXBsYXRlKHt9KSk7XG5cdCAgICB0ZXN0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHQgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXN0KTtcblx0ICAgIHRoaXMudHlwZS53aWR0aCA9IHRlc3Qub2Zmc2V0V2lkdGg7XG5cdCAgICB0aGlzLnR5cGUuaGVpZ2h0ID0gdGVzdC5vZmZzZXRIZWlnaHQ7XG5cdCAgICByZW1vdmUodGVzdCk7XG5cdCAgfSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgc2Nyb2xsOiB0cnVlLFxuXHQgICAgZGF0YWZldGNoOiA1MCxcblx0ICAgIG5hdmlnYXRpb246IHRydWVcblx0ICB9LFxuXHQgIF9pZDogXCJ3ZWJpeF9sX2lkXCIsXG5cdCAgX2l0ZW1DbGFzc05hbWU6IFwid2ViaXhfZGF0YXZpZXdfaXRlbVwiLFxuXHQgIF90aWxlc1BhZGRpbmc6IDAsXG5cdCAgX2RyYWdfZGlyZWN0aW9uOiBcInhcIixcblx0ICBvbl9jbGljazoge1xuXHQgICAgd2ViaXhfZGF0YXZpZXdfaXRlbTogZnVuY3Rpb24gKGUsIGlkKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zZWxlY3QpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2VsZWN0ID09IFwibXVsdGlzZWxlY3RcIiB8fCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCkgdGhpcy5zZWxlY3QoaWQsIGZhbHNlLCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PSBcInRvdWNoXCIgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSwgZS5zaGlmdEtleSk7IC8vbXVsdGlzZWxlY3Rpb25cblx0ICAgICAgICBlbHNlIHRoaXMuc2VsZWN0KGlkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgb25fZGJsY2xpY2s6IHt9LFxuXHQgIG9uX21vdXNlX21vdmU6IHt9LFxuXHQgIHR5cGU6IHtcblx0ICAgIC8vbm9ybWFsIHN0YXRlIG9mIGl0ZW1cblx0ICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZShcIiN2YWx1ZSNcIiksXG5cdCAgICAvL2luIGNhc2Ugb2YgZHluLiBsb2FkaW5nIC0gdGVtcG9yYXJ5IHNwYWNlclxuXHQgICAgdGVtcGxhdGVMb2FkaW5nOiB0ZW1wbGF0ZShcIkxvYWRpbmcuLi5cIiksXG5cdCAgICB3aWR0aDogMTYwLFxuXHQgICAgaGVpZ2h0OiA1MCxcblx0ICAgIGNsYXNzbmFtZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uLCBtYXJrcykge1xuXHQgICAgICB2YXIgY3NzID0gXCJ3ZWJpeF9kYXRhdmlld19pdGVtXCI7XG5cdCAgICAgIGlmIChjb21tb24uY3NzKSBjc3MgKz0gXCIgXCIgKyBjb21tb24uY3NzO1xuXHQgICAgICBpZiAoY29tbW9uLnR5cGUgJiYgY29tbW9uLnR5cGUudG9TdHJpbmcoKSA9PSBcInRpbGVzXCIpIGNzcyArPSBcInRpbGVzIFwiO1xuXG5cdCAgICAgIGlmIChvYmouJGNzcykge1xuXHQgICAgICAgIGlmIChfdHlwZW9mKG9iai4kY3NzKSA9PSBcIm9iamVjdFwiKSBvYmouJGNzcyA9IGNyZWF0ZUNzcyhvYmouJGNzcyk7XG5cdCAgICAgICAgY3NzICs9IFwiIFwiICsgb2JqLiRjc3M7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobWFya3MgJiYgbWFya3MuJGNzcykgY3NzICs9IFwiIFwiICsgbWFya3MuJGNzcztcblx0ICAgICAgcmV0dXJuIGNzcztcblx0ICAgIH0sXG5cdCAgICB0aWxlc1N0YXJ0OiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgaWYgKGNvbW1vbi50eXBlID09IFwidGlsZXNcIikgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwid2ViaXhfZGF0YXZpZXdfaW5uZXJfaXRlbVxcXCIgc3R5bGU9XFxcImJveC1zaXppbmc6Ym9yZGVyLWJveDsgb3ZlcmZsb3c6aGlkZGVuO1xcXCI+XCI7XG5cdCAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgfSxcblx0ICAgIHRpbGVzRW5kOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgaWYgKGNvbW1vbi50eXBlID09IFwidGlsZXNcIikgcmV0dXJuIFwiPC9kaXY+XCI7XG5cdCAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgfSxcblx0ICAgIGFyaWE6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgcmV0dXJuIFwicm9sZT1cXFwib3B0aW9uXFxcIlwiICsgKG1hcmtzICYmIG1hcmtzLndlYml4X3NlbGVjdGVkID8gXCIgYXJpYS1zZWxlY3RlZD1cXFwidHJ1ZVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiXCIgOiBcIiB0YWJpbmRleD1cXFwiLTFcXFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlU3RhcnQ6IHRlbXBsYXRlKFwiPGRpdiB3ZWJpeF9sX2lkPVxcXCIjaWQjXFxcIiBjbGFzcz1cXFwie2NvbW1vbi5jbGFzc25hbWUoKX1cXFwiIHtjb21tb24uYXJpYSgpfSBzdHlsZT1cXFwid2lkdGg6e2NvbW1vbi53aWR0aH1weDsgaGVpZ2h0Ontjb21tb24uaGVpZ2h0fXB4OyBmbG9hdDpsZWZ0OyBvdmVyZmxvdzpoaWRkZW47XFxcIj57Y29tbW9uLnRpbGVzU3RhcnQoKX1cIiksXG5cdCAgICB0ZW1wbGF0ZUVuZDogdGVtcGxhdGUoXCJ7Y29tbW9uLnRpbGVzRW5kKCl9PC9kaXY+XCIpXG5cdCAgfSxcblx0ICBfY2FsY2tfYXV0b2hlaWdodDogZnVuY3Rpb24gKHdpZHRoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MuaGVpZ2h0ID0gdGhpcy50eXBlLmhlaWdodCAqIE1hdGguY2VpbCh0aGlzLmRhdGEuY291bnQoKSAvIE1hdGguZmxvb3Iod2lkdGggLyB0aGlzLnR5cGUud2lkdGgpKTtcblx0ICB9LFxuXHQgIGF1dG9oZWlnaHRfc2V0dGVyOiBmdW5jdGlvbiAobW9kZSkge1xuXHQgICAgaWYgKG1vZGUpIHtcblx0ICAgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TdG9yZUxvYWRcIiwgYmluZCh0aGlzLnJlc2l6ZSwgdGhpcykpO1xuXHQgICAgICB0aGlzLl9jb250ZW50b2JqLnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtb2RlO1xuXHQgIH0sXG5cdCAgJGdldFNpemU6IGZ1bmN0aW9uIChkeCwgZHkpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy54Q291bnQgPiAwICYmIHRoaXMudHlwZS53aWR0aCAhPSBcImF1dG9cIiAmJiAhdGhpcy5fYXV0b3dpZHRoKSB0aGlzLl9zZXR0aW5ncy53aWR0aCA9IHRoaXMudHlwZS53aWR0aCAqIHRoaXMuX3NldHRpbmdzLnhDb3VudCArICh0aGlzLl9zY3JvbGxfeSA/IGVudi5zY3JvbGxTaXplIDogMCk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MueUNvdW50ICYmIHRoaXMudHlwZS5oZWlnaHQgIT0gXCJhdXRvXCIpIHRoaXMuX3NldHRpbmdzLmhlaWdodCA9IHRoaXMudHlwZS5oZWlnaHQgKiB0aGlzLl9zZXR0aW5ncy55Q291bnQ7XG5cdCAgICB2YXIgd2lkdGggPSB0aGlzLl9zZXR0aW5ncy53aWR0aCB8fCB0aGlzLl9jb250ZW50X3dpZHRoO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2hlaWdodCAmJiB3aWR0aCkge1xuXHQgICAgICB0aGlzLl9jYWxja19hdXRvaGVpZ2h0KHdpZHRoKTtcblxuXHQgICAgICB0aGlzLnNjcm9sbF9zZXR0ZXIoZmFsc2UpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYmFzZS5hcGkuJGdldFNpemUuY2FsbCh0aGlzLCBkeCwgZHkpO1xuXHQgIH0sXG5cdCAgX3JlY2Fsa19jb3VudHM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciByZW5kZXIgPSBmYWxzZTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnlDb3VudCAmJiB0aGlzLnR5cGUuaGVpZ2h0ID09IFwiYXV0b1wiKSB7XG5cdCAgICAgIHRoaXMudHlwZS5oZWlnaHQgPSBNYXRoLmZsb29yKCh0aGlzLl9jb250ZW50X2hlaWdodCAtIHRoaXMuX3RpbGVzUGFkZGluZykgLyB0aGlzLl9zZXR0aW5ncy55Q291bnQpO1xuXHQgICAgICByZW5kZXIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MueENvdW50ICYmICh0aGlzLnR5cGUud2lkdGggPT0gXCJhdXRvXCIgfHwgdGhpcy5fYXV0b3dpZHRoKSkge1xuXHQgICAgICB0aGlzLl9hdXRvd2lkdGggPSB0cnVlOyAvL2ZsYWcgbWFya3MgdGhhdCB3aWR0aCB3YXMgc2V0IHRvIFwiYXV0b1wiIGluaXRpYWxseVxuXG5cdCAgICAgIHRoaXMudHlwZS53aWR0aCA9IE1hdGguZmxvb3IoKHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl90aWxlc1BhZGRpbmcgKiAyKSAvIHRoaXMuX3NldHRpbmdzLnhDb3VudCk7XG5cdCAgICAgIHJlbmRlciA9IHRydWU7XG5cdCAgICB9IGVsc2UgdGhpcy5fYXV0b3dpZHRoID0gZmFsc2U7XG5cblx0ICAgIHJldHVybiByZW5kZXI7XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgIGlmIChiYXNlLmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0ICYmIHRoaXMuX2NhbGNrX2F1dG9oZWlnaHQoKSAhPSB0aGlzLl9jb250ZW50X2hlaWdodCkgcmV0dXJuIGRlbGF5KHRoaXMucmVzaXplLCB0aGlzKTtcblx0ICAgICAgaWYgKHRoaXMuX3JlY2Fsa19jb3VudHMoKSB8fCB0aGlzLl9yZW5kZXJfdmlzaWJsZV9yb3dzKSB0aGlzLnJlbmRlcigpO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMTMgPSBleHBvcnRzLnByb3RvVUkoYXBpJDEzLCBEYXRhTW92ZSwgRHJhZ0l0ZW0sIE1vdXNlRXZlbnRzLCBLZXlzTmF2aWdhdGlvbiwgU2VsZWN0aW9uTW9kZWwsIFNjcm9sbGFibGUsIEN1c3RvbVByaW50LCBwcm90by52aWV3KTtcblxuXHRpMThuLnBhZ2VyID0ge1xuXHQgIGZpcnN0OiBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIHd4aS1hbmdsZS1kb3VibGUtbGVmdCc+PC9zcGFuPlwiLFxuXHQgIGxhc3Q6IFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLWFuZ2xlLWRvdWJsZS1yaWdodCc+PC9zcGFuPlwiLFxuXHQgIG5leHQ6IFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLWFuZ2xlLXJpZ2h0Jz48L3NwYW4+XCIsXG5cdCAgcHJldjogXCI8c3BhbiBjbGFzcz0nd2ViaXhfaWNvbiB3eGktYW5nbGUtbGVmdCc+PC9zcGFuPlwiXG5cdH07XG5cdHZhciBhcGkkMTQgPSB7XG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHNpemU6IDEwLFxuXHQgICAgLy9pdGVtcyBvbiBwYWdlXG5cdCAgICBwYWdlOiAwLFxuXHQgICAgLy9jdXJyZW50IHBhZ2Vcblx0ICAgIGdyb3VwOiA1LFxuXHQgICAgdGVtcGxhdGU6IFwie2NvbW1vbi5wYWdlcygpfVwiLFxuXHQgICAgbWF4V2lkdGg6IDEwMDAwMCxcblx0ICAgIGhlaWdodDogMzAsXG5cdCAgICBib3JkZXJsZXNzOiB0cnVlXG5cdCAgfSxcblx0ICBuYW1lOiBcInBhZ2VyXCIsXG5cdCAgb25fY2xpY2s6IHtcblx0ICAgIC8vb24gcGFnaW5nIGJ1dHRvbiBjbGlja1xuXHQgICAgXCJ3ZWJpeF9wYWdlcl9pdGVtXCI6IGZ1bmN0aW9uIChlLCBpZCkge1xuXHQgICAgICB0aGlzLnNlbGVjdChpZCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkaW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xuXHQgICAgdGhpcy5kYXRhID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICB0aGlzLl9kYXRhb2JqID0gdGhpcy5fdmlld29iajtcblx0ICAgIHRoaXMuX3ZpZXdvYmouY2xhc3NOYW1lICs9IFwiIHdlYml4X3BhZ2VyXCIgKyAoY29uZmlnLmF1dG93aWR0aCA/IFwiIHdlYml4X3BhZ2VyX2F1dG9cIiA6IFwiXCIpO1xuXHQgICAgaWYgKGNvbmZpZy5tYXN0ZXIgPT09IGZhbHNlIHx8IGNvbmZpZy5tYXN0ZXIgPT09IDApIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fcmVtb3ZlX21hc3Rlcik7XG5cdCAgfSxcblx0ICBfcmVtb3ZlX21hc3RlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZWZyZXNoKCk7XG5cdCAgICB0aGlzLiRtYXN0ZXIgPSB7XG5cdCAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHt9LFxuXHQgICAgICBzZWxlY3Q6IGZ1bmN0aW9uICgpIHt9XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgc2VsZWN0OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmICh0aGlzLiRtYXN0ZXIgJiYgdGhpcy4kbWFzdGVyLm5hbWUgPT0gXCJwYWdlclwiKSByZXR1cm4gdGhpcy4kbWFzdGVyLnNlbGVjdChpZCk7IC8vaWQgLSBpZCBvZiBidXR0b24sIG51bWJlciBmb3IgcGFnZSBidXR0b25zXG5cblx0ICAgIHN3aXRjaCAoaWQpIHtcblx0ICAgICAgY2FzZSBcIm5leHRcIjpcblx0ICAgICAgICBpZCA9IHRoaXMuX3NldHRpbmdzLnBhZ2UgKyAxO1xuXHQgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgIGNhc2UgXCJwcmV2XCI6XG5cdCAgICAgICAgaWQgPSB0aGlzLl9zZXR0aW5ncy5wYWdlIC0gMTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBjYXNlIFwiZmlyc3RcIjpcblx0ICAgICAgICBpZCA9IDA7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgY2FzZSBcImxhc3RcIjpcblx0ICAgICAgICBpZCA9IHRoaXMuX3NldHRpbmdzLmxpbWl0IC0gMTtcblx0ICAgICAgICBicmVhaztcblxuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIC8vdXNlIGluY29taW5nIGlkXG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpZCA8IDApIGlkID0gMDtcblx0ICAgIGlmIChpZCA+PSB0aGlzLmRhdGEubGltaXQpIGlkID0gdGhpcy5kYXRhLmxpbWl0IC0gMTtcblx0ICAgIHZhciBvbGQgPSB0aGlzLmRhdGEucGFnZTtcblxuXHQgICAgaWYgKHRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVQYWdlQ2hhbmdlXCIsIFtpZCwgb2xkXSkpIHtcblx0ICAgICAgdGhpcy5kYXRhLnBhZ2UgPSBpZCAqIDE7IC8vbXVzdCBiZSBpbnRcblxuXHQgICAgICBpZiAodGhpcy5yZWZyZXNoKCkpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmFuaW1hdGUgfHwgIXRoaXMuX2FuaW1hdGUob2xkLCBpZCAqIDEsIHRoaXMuX3NldHRpbmdzLmFuaW1hdGUpKSB0aGlzLiRtYXN0ZXIucmVmcmVzaCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUGFnZUNoYW5nZVwiLCBbaWRdKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9pZDogXCJ3ZWJpeF9wX2lkXCIsXG5cdCAgdGVtcGxhdGVfc2V0dGVyOiB0ZW1wbGF0ZSxcblx0ICB0eXBlOiB7XG5cdCAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgcmV0dXJuIGEudGVtcGxhdGUuY2FsbCh0aGlzLCBhLCBiKTtcblx0ICAgIH0sXG5cdCAgICAvL2xpc3Qgb2YgcGFnZSBudW1iZXJzXG5cdCAgICBwYWdlczogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICB2YXIgaHRtbCA9IFwiXCI7IC8vc2tpcCByZW5kZXJpbmcgaWYgcGFnaW5nIGlzIG5vdCBmdWxseSBpbml0aWFsaXplZFxuXG5cdCAgICAgIGlmIChvYmoucGFnZSA9PSAtMSkgcmV0dXJuIFwiXCI7IC8vY3VycmVudCBwYWdlIHRha2VuIGFzIGNlbnRlciBvZiB2aWV3LCBjYWxjdWxhdGUgYm91bmRzIG9mIGdyb3VwXG5cblx0ICAgICAgb2JqLiRtaW4gPSBvYmoucGFnZSAtIE1hdGgucm91bmQoKG9iai5ncm91cCAtIDEpIC8gMik7XG5cdCAgICAgIG9iai4kbWF4ID0gb2JqLiRtaW4gKyBvYmouZ3JvdXAgKiAxIC0gMTtcblxuXHQgICAgICBpZiAob2JqLiRtaW4gPCAwKSB7XG5cdCAgICAgICAgb2JqLiRtYXggKz0gb2JqLiRtaW4gKiAtMTtcblx0ICAgICAgICBvYmouJG1pbiA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAob2JqLiRtYXggPj0gb2JqLmxpbWl0KSB7XG5cdCAgICAgICAgb2JqLiRtaW4gLT0gTWF0aC5taW4ob2JqLiRtaW4sIG9iai4kbWF4IC0gb2JqLmxpbWl0ICsgMSk7XG5cdCAgICAgICAgb2JqLiRtYXggPSBvYmoubGltaXQgLSAxO1xuXHQgICAgICB9IC8vZ2VuZXJhdGUgSFRNTCBjb2RlIG9mIGJ1dHRvbnNcblxuXG5cdCAgICAgIGZvciAodmFyIGkgPSBvYmouJG1pbiB8fCAwOyBpIDw9IG9iai4kbWF4OyBpKyspIHtcblx0ICAgICAgICBodG1sICs9IHRoaXMuYnV0dG9uKHtcblx0ICAgICAgICAgIGlkOiBpLFxuXHQgICAgICAgICAgaW5kZXg6IGkgKyAxLFxuXHQgICAgICAgICAgc2VsZWN0ZWQ6IGkgPT0gb2JqLnBhZ2UgPyBcIl9zZWxlY3RlZFwiIDogXCJcIixcblx0ICAgICAgICAgIGxhYmVsOiBpMThuLmFyaWEucGFnZSArIFwiIFwiICsgKGkgKyAxKVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGh0bWw7XG5cdCAgICB9LFxuXHQgICAgcGFnZTogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqLnBhZ2UgKyAxO1xuXHQgICAgfSxcblx0ICAgIC8vZ28tdG8tZmlyc3QgcGFnZSBidXR0b25cblx0ICAgIGZpcnN0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmJ1dHRvbih7XG5cdCAgICAgICAgaWQ6IFwiZmlyc3RcIixcblx0ICAgICAgICBpbmRleDogaTE4bi5wYWdlci5maXJzdCxcblx0ICAgICAgICBzZWxlY3RlZDogXCJcIixcblx0ICAgICAgICBsYWJlbDogaTE4bi5hcmlhLnBhZ2VzWzBdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIC8vZ28tdG8tbGFzdCBwYWdlIGJ1dHRvblxuXHQgICAgbGFzdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5idXR0b24oe1xuXHQgICAgICAgIGlkOiBcImxhc3RcIixcblx0ICAgICAgICBpbmRleDogaTE4bi5wYWdlci5sYXN0LFxuXHQgICAgICAgIHNlbGVjdGVkOiBcIlwiLFxuXHQgICAgICAgIGxhYmVsOiBpMThuLmFyaWEucGFnZXNbM11cblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgLy9nby10by1wcmV2IHBhZ2UgYnV0dG9uXG5cdCAgICBwcmV2OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmJ1dHRvbih7XG5cdCAgICAgICAgaWQ6IFwicHJldlwiLFxuXHQgICAgICAgIGluZGV4OiBpMThuLnBhZ2VyLnByZXYsXG5cdCAgICAgICAgc2VsZWN0ZWQ6IFwiXCIsXG5cdCAgICAgICAgbGFiZWw6IGkxOG4uYXJpYS5wYWdlc1sxXVxuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICAvL2dvLXRvLW5leHQgcGFnZSBidXR0b25cblx0ICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uKHtcblx0ICAgICAgICBpZDogXCJuZXh0XCIsXG5cdCAgICAgICAgaW5kZXg6IGkxOG4ucGFnZXIubmV4dCxcblx0ICAgICAgICBzZWxlY3RlZDogXCJcIixcblx0ICAgICAgICBsYWJlbDogaTE4bi5hcmlhLnBhZ2VzWzJdXG5cdCAgICAgIH0pO1xuXHQgICAgfSxcblx0ICAgIGJ1dHRvbjogdGVtcGxhdGUoXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgd2ViaXhfcF9pZD0ne29iai5pZH0nIGNsYXNzPSd3ZWJpeF9wYWdlcl9pdGVte29iai5zZWxlY3RlZH0nIGFyaWEtbGFiZWw9J3tvYmoubGFiZWx9Jz57b2JqLmluZGV4fTwvYnV0dG9uPlwiKVxuXHQgIH0sXG5cdCAgY2xvbmU6IGZ1bmN0aW9uIChwYWdlcikge1xuXHQgICAgaWYgKCFwYWdlci4kdmlldykge1xuXHQgICAgICBwYWdlci52aWV3ID0gXCJwYWdlclwiO1xuXHQgICAgICBwYWdlciA9IHVpKHBhZ2VyKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fY2xvbmUgPSBwYWdlcjtcblx0ICAgIHBhZ2VyLiRtYXN0ZXIgPSB0aGlzO1xuXG5cdCAgICB0aGlzLl9yZWZyZXNoX2Nsb25lKCk7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcyA9IHRoaXMuX3NldHRpbmdzO1xuXHQgICAgaWYgKCFzLmNvdW50KSByZXR1cm47IC8vbWF4IHBhZ2UgbnVtYmVyXG5cblx0ICAgIHMubGltaXQgPSBNYXRoLmNlaWwocy5jb3VudCAvIHMuc2l6ZSk7XG5cdCAgICB2YXIgbmV3UGFnZSA9IE1hdGgubWluKHMubGltaXQgLSAxLCBzLnBhZ2UpO1xuXHQgICAgaWYgKG5ld1BhZ2UgIT0gcy5wYWdlKSByZXR1cm4gdGhpcy4kbWFzdGVyLnNldFBhZ2UobmV3UGFnZSk7XG5cdCAgICBzLnBhZ2UgPSBuZXdQYWdlO1xuXG5cdCAgICBpZiAobmV3UGFnZSA+PSAwICYmIG5ld1BhZ2UgIT0gcy5vbGRfcGFnZSB8fCBzLmxpbWl0ICE9IHMub2xkX2xpbWl0IHx8IHMub2xkX2NvdW50ICE9IHMuY291bnQpIHtcblx0ICAgICAgLy9yZWZyZXNoIHNlbGYgb25seSBpZiBjdXJyZW50IHBhZ2Ugb3IgdG90YWwgbGltaXQgd2FzIGNoYW5nZWRcblx0ICAgICAgdGhpcy5yZW5kZXIoKTtcblxuXHQgICAgICB0aGlzLl9yZWZyZXNoX2Nsb25lKCk7XG5cblx0ICAgICAgcy5vbGRfbGltaXQgPSBzLmxpbWl0OyAvL3NhdmUgZm9yIG9uY2hhbmdlIGNoZWNrIGluIG5leHQgaXRlcmF0aW9uXG5cblx0ICAgICAgcy5vbGRfcGFnZSA9IHMucGFnZTtcblx0ICAgICAgcy5vbGRfY291bnQgPSBzLmNvdW50O1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGFwaU9ubHlfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHJldHVybiB0aGlzLiRhcGlPbmx5ID0gdmFsdWU7XG5cdCAgfSxcblx0ICBfcmVmcmVzaF9jbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX2Nsb25lKSB7XG5cdCAgICAgIHRoaXMuX2Nsb25lLl9zZXR0aW5ncy5jb3VudCA9IHRoaXMuX3NldHRpbmdzLmNvdW50O1xuXHQgICAgICB0aGlzLl9jbG9uZS5fc2V0dGluZ3MucGFnZSA9IHRoaXMuX3NldHRpbmdzLnBhZ2U7XG5cblx0ICAgICAgdGhpcy5fY2xvbmUucmVmcmVzaCgpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2FuaW1hdGU6IGZ1bmN0aW9uIChvbGQsIGlkLCBjb25maWcpIHtcblx0ICAgIGlmIChvbGQgPT0gaWQpIHJldHVybiBmYWxzZTtcblxuXHQgICAgaWYgKHRoaXMuX3BnSW5BbmltYXRpb24pIHtcblx0ICAgICAgaWYgKHRoaXMuX3BnQW5pbWF0ZVRpbWVvdXQpIHtcblx0ICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3BnQW5pbWF0ZVRpbWVvdXQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHRoaXMuX3BnQW5pbWF0ZVRpbWVvdXQgPSBkZWxheSh0aGlzLl9hbmltYXRlLCB0aGlzLCBbb2xkLCBpZCwgY29uZmlnXSwgMTAwKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRpcmVjdGlvbiA9IGlkID4gb2xkID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG5cdCAgICBpZiAoY29uZmlnLmRpcmVjdGlvbiA9PSBcInRvcFwiIHx8IGNvbmZpZy5kaXJlY3Rpb24gPT0gXCJib3R0b21cIikgZGlyZWN0aW9uID0gaWQgPiBvbGQgPyBcInRvcFwiIDogXCJib3R0b21cIjtcblx0ICAgIGlmIChjb25maWcuZmxpcCkgZGlyZWN0aW9uID0gXCJcIjsgLy9tYWtlIGNvcHkgb2YgZXhpc3Rpbmcgdmlld1xuXG5cdCAgICB2YXIgdG9wID0gMDtcblx0ICAgIHZhciBzbm9kZSA9IHRoaXMuJG1hc3Rlci5fZGF0YW9iajtcblx0ICAgIHZhciBpc0RhdGFUYWJsZSA9ICEhdGhpcy4kbWFzdGVyLl9ib2R5O1xuXG5cdCAgICBpZiAoaXNEYXRhVGFibGUpIHtcblx0ICAgICAgc25vZGUgPSB0aGlzLiRtYXN0ZXIuX2JvZHk7XG5cdCAgICAgIHRvcCA9IHNub2RlLm9mZnNldFRvcDtcblx0ICAgICAgYWRkQ3NzKHRoaXMuJG1hc3Rlci4kdmlldywgXCJ3ZWJpeF9hbmltYXRpb25cIik7XG5cdCAgICB9XG5cblx0ICAgIHZhciBvbm9kZSA9IHNub2RlLmNsb25lTm9kZSh0cnVlKTtcblx0ICAgIG9ub2RlLnN0eWxlLndpZHRoID0gc25vZGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjsgLy9yZWRyYXcgcGFnZVxuXG5cdCAgICB0aGlzLiRtYXN0ZXIucmVmcmVzaCgpOyAvL2FwcGVuZCBjb3B5IG5leHQgdG8gb3JpZ2luYWxcblxuXHQgICAgaW5zZXJ0QmVmb3JlKG9ub2RlLCBzbm9kZS5uZXh0U2libGluZywgc25vZGUucGFyZW50Tm9kZSk7XG5cdCAgICBpZiAoaXNEYXRhVGFibGUpIG9ub2RlLmNoaWxkTm9kZXNbMV0uc2Nyb2xsTGVmdCA9IHNub2RlLmNoaWxkTm9kZXNbMV0uc2Nyb2xsTGVmdDsgLy9hbmltYXRpb24gY29uZmlnXG5cblx0ICAgIHZhciBsaW5lO1xuXHQgICAgdmFyIGJhc2UkJDEgPSBjb25maWcgIT09IHRydWUgPyBjb25maWcgOiB7fTtcblx0ICAgIHZhciBhbmlzZXQgPSBleHBvcnRzLmV4dGVuZCh7XG5cdCAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuXHQgICAgICBjYWxsYmFjazogYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgYW5pc2V0LmNhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICBhbmltYXRlLmJyZWFrTGluZShsaW5lKTtcblx0ICAgICAgICB0aGlzLl9wZ0luQW5pbWF0aW9uID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKHRoaXMuJG1hc3Rlci5fYm9keSkgcmVtb3ZlQ3NzKHRoaXMuJG1hc3Rlci4kdmlldywgXCJ3ZWJpeF9hbmltYXRpb25cIik7XG5cdCAgICAgIH0sIHRoaXMpLFxuXHQgICAgICB0b3A6IHRvcCxcblx0ICAgICAga2VlcFZpZXdzOiBpc0RhdGFUYWJsZVxuXHQgICAgfSwgYmFzZSQkMSk7IC8vcnVuIGFuaW1hdGlvblxuXG5cdCAgICBsaW5lID0gYW5pbWF0ZS5mb3JtTGluZShzbm9kZSwgb25vZGUsIGFuaXNldCk7XG5cdCAgICBhbmltYXRlKFtzbm9kZSwgb25vZGVdLCBhbmlzZXQpO1xuXHQgICAgdGhpcy5fcGdJbkFuaW1hdGlvbiA9IHRydWU7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQxNCA9IGV4cG9ydHMucHJvdG9VSShhcGkkMTQsIE1vdXNlRXZlbnRzLCBTaW5nbGVSZW5kZXIsIGJhc2UudmlldywgRXZlbnRTeXN0ZW0pO1xuXG5cdHZhciBhcGkkMTUgPSB7XG5cdCAgbmFtZTogXCJjb21tZW50c1wiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBzZW5kQWN0aW9uOiBcImNsaWNrXCIsXG5cdCAgICBtb2RlOiBcImNvbW1lbnRzXCIsXG5cdCAgICBtb3JlQnV0dG9uOiB0ZW1wbGF0ZShpMThuLmNvbW1lbnRzLm1vcmVDb21tZW50cylcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLiR2aWV3LmNsYXNzTmFtZSArPSBcIiB3ZWJpeF9jb21tZW50c1wiO1xuXHQgICAgY29uZmlnLnJvd3MgPSBbdGhpcy5fY29uZmlnTGlzdChjb25maWcpXTtcblx0ICAgIGlmICghY29uZmlnLnJlYWRvbmx5KSBjb25maWcucm93cy5wdXNoKHRoaXMuX2NvbmZpZ0Zvcm0oKSk7XG5cdCAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUgPSBbXTtcblxuXHQgICAgdGhpcy5faW5pdFVzZXJzKGNvbmZpZy51c2Vycyk7XG5cblx0ICAgIHRoaXMuX2luaXRNZW51KCk7XG5cblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5fYWZ0ZXJJbml0KTtcblx0ICB9LFxuXHQgICRleHBvcnRWaWV3OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fbGlzdDtcblx0ICB9LFxuXHQgIF9hZnRlckluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIC8vIHN0b3JlIFVJIGJsb2Nrc1xuXHQgICAgdGhpcy5fbGlzdCA9IHRoaXMucXVlcnlWaWV3KHtcblx0ICAgICAgdmlldzogXCJsaXN0XCJcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fZm9ybSA9IHRoaXMucXVlcnlWaWV3KHtcblx0ICAgICAgdmlldzogXCJmb3JtXCJcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fc2VuZEJ1dHRvbiA9IHRoaXMucXVlcnlWaWV3KHtcblx0ICAgICAgdmlldzogXCJidXR0b25cIlxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9pbnB1dCA9IHRoaXMucXVlcnlWaWV3KHtcblx0ICAgICAgdmlldzogXCJ0ZXh0YXJlYVwiXG5cdCAgICB9KTsgLy9wcm92aWRlIGRhdGEtbGlrZSBBUElcblxuXHQgICAgdGhpcy5fbGlzdC5kYXRhLnByb3ZpZGVBcGkodGhpcywgdHJ1ZSk7XG5cblx0ICAgIHRoaXMuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZGF0YSA9IF90aGlzLl9saXN0LnNlcmlhbGl6ZSgpO1xuXG5cdCAgICAgIHZhciBpbmRleCQkMSA9IF90aGlzLmdldEluZGV4QnlJZChcIiRtb3JlXCIpO1xuXG5cdCAgICAgIGlmIChpbmRleCQkMSA+PSAwKSBkYXRhLnNwbGljZShpbmRleCQkMSwgMSk7XG5cdCAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfTsgLy90dW5lIGlucHV0IHpvbmVcblxuXG5cdCAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSBhdHRhY2hFdmVudChcIm9uQ2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgdmFyIHZpZXcgPSAkJChlKTtcblxuXHQgICAgICBpZiAodmlldyA9PSBfdGhpcy5faW5wdXQpIHtcblx0ICAgICAgICBfdGhpcy5fY2hhbmdlVGV4dGFyZWEodHJ1ZSk7XG5cblx0ICAgICAgICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBfdGhpcy5faW5wdXQuZm9jdXMoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIGlmICh2aWV3ICE9PSBfdGhpcy5fc2VuZEJ1dHRvbiAmJiB2aWV3ICE9PSBfdGhpcy5fbGlzdE1lbnUgJiYgKCFlIHx8IChlLnRhcmdldC5jbGFzc05hbWUgfHwgXCJcIikudG9TdHJpbmcoKS5pbmRleE9mKFwid2ViaXhfY29tbWVudHNfbWVudVwiKSA9PT0gLTEpKSB7XG5cdCAgICAgICAgX3RoaXMuX2NoYW5nZVRleHRhcmVhKCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uRGVzdHJ1Y3RcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICBkZXRhY2hFdmVudCh0aGlzLl9jbGlja0hhbmRsZXIpO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICAkb25Mb2FkOiBmdW5jdGlvbiAoZGF0YSwgZHJpdmVyKSB7XG5cdCAgICB0aGlzLl9maWxsTGlzdChkYXRhLCBkcml2ZXIpO1xuXHQgIH0sXG5cdCAgX2ZpbGxMaXN0OiBmdW5jdGlvbiAoZGF0YSwgZHJpdmVyKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgdmFyIGxpc3QkJDEgPSB0aGlzLl9saXN0IHx8IHRoaXMucXVlcnlWaWV3KHtcblx0ICAgICAgdmlldzogXCJsaXN0XCJcblx0ICAgIH0pO1xuXHQgICAgbGlzdCQkMS5kYXRhLmRyaXZlciA9IGRyaXZlcjtcblx0ICAgIHZhciBtb3JlID0gZGF0YS5tb3JlO1xuXHQgICAgZGF0YSA9IGRyaXZlci5nZXRSZWNvcmRzKGRhdGEpOyAvL3BhcnNlIG1vcmUgY29tbWVudHNcblxuXHQgICAgaWYgKHRoaXMuX21vcmVDYWxsKSB7XG5cdCAgICAgIHRoaXMuX21vcmVDYWxsID0gZmFsc2U7XG5cblx0ICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgLy9hZGQgc3BhY2VzIGFmdGVyICdtb3JlJyBidXR0b24gdG8gYWNjb21tb2RhdGUgbmV3IGRhdGFcblx0ICAgICAgICB2YXIgb3JkZXIgPSBsaXN0JCQxLmRhdGEub3JkZXIsXG5cdCAgICAgICAgICAgIHBvcyQkMSA9IDE7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1vZGUgPT0gXCJjaGF0XCIpIGxpc3QkJDEuZGF0YS5vcmRlciA9IHRvQXJyYXkoW29yZGVyWzBdXS5jb25jYXQobmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgb3JkZXIuc2xpY2UoMSkpKTtlbHNlIHtcblx0ICAgICAgICAgIHZhciBzdGFydCA9IGxpc3QkJDEuZ2V0SW5kZXhCeUlkKFwiJG1vcmVcIik7XG5cdCAgICAgICAgICBsaXN0JCQxLmRhdGEub3JkZXIgPSB0b0FycmF5KG9yZGVyLnNsaWNlKDAsIHN0YXJ0KS5jb25jYXQobmV3IEFycmF5KGRhdGEubGVuZ3RoKSwgb3JkZXIuc2xpY2Uoc3RhcnQpKSk7XG5cdCAgICAgICAgICBwb3MkJDEgPSBzdGFydDtcblx0ICAgICAgICB9IC8vcGFyc2UgaW50byBkZWZpbmVkIHBvc2l0aW9uXG5cblx0ICAgICAgICBsaXN0JCQxLnBhcnNlKHtcblx0ICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICBwb3M6IHBvcyQkMVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChtb3JlKSBkcCh0aGlzLl9saXN0KS5pZ25vcmUoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgX3RoaXMyLl9saXN0LnVwZGF0ZUl0ZW0oXCIkbW9yZVwiLCB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBtb3JlXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubW9kZSA9PSBcImNoYXRcIikgbGlzdCQkMS5zaG93SXRlbShsaXN0JCQxLmdldElkQnlJbmRleChkYXRhLmxlbmd0aCkpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFkYXRhLmxlbmd0aCB8fCAhbW9yZSkgZHAodGhpcy5fbGlzdCkuaWdub3JlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBfdGhpczIuX2xpc3QucmVtb3ZlKFwiJG1vcmVcIik7XG5cdCAgICAgIH0pO1xuXHQgICAgfSAvL25vcm1hbCBwYXJzZVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgaWYgKG1vcmUgJiYgIWxpc3QkJDEuZXhpc3RzKFwiJG1vcmVcIikpIHtcblx0ICAgICAgICAgIG1vcmUgPSB7XG5cdCAgICAgICAgICAgIGlkOiBcIiRtb3JlXCIsXG5cdCAgICAgICAgICAgIHZhbHVlOiBtb3JlXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLm1vZGUgPT0gXCJjaGF0XCIpIGRhdGEudW5zaGlmdChtb3JlKTtlbHNlIGRhdGEucHVzaChtb3JlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsaXN0JCQxLnBhcnNlKGRhdGEpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tb2RlID09IFwiY2hhdFwiKSBsaXN0JCQxLnNob3dJdGVtKGxpc3QkJDEuZ2V0TGFzdElkKCkpO1xuXHQgICAgICB9XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5faW5wdXRIZWlnaHQgPSAkYWN0aXZlLmlucHV0SGVpZ2h0ICsgNjtcblx0ICB9LFxuXHQgIGdldFVzZXJzOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdXNlcnM7XG5cdCAgfSxcblx0ICBnZXRNZW51OiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fbGlzdE1lbnU7XG5cdCAgfSxcblx0ICBzZXRDdXJyZW50VXNlcjogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB0aGlzLmNvbmZpZy5jdXJyZW50VXNlciA9IGlkO1xuXG5cdCAgICB0aGlzLl9mb3JtLmNsZWFyKCk7XG5cblx0ICAgIHRoaXMuX2xpc3QucmVmcmVzaCgpO1xuXHQgIH0sXG5cdCAgZWRpdDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUVkaXRTdGFydFwiLCBbaWRdKSkge1xuXHQgICAgICB0aGlzLl9jaGFuZ2VUZXh0YXJlYSh0cnVlKTtcblxuXHQgICAgICB2YXIgdmFsdWVzID0gdGhpcy5fbGlzdC5nZXRJdGVtKGlkKTtcblxuXHQgICAgICB0aGlzLl9mb3JtLnNldFZhbHVlcyh2YWx1ZXMpO1xuXG5cdCAgICAgIHRoaXMuX2Zvcm0uZm9jdXMoKTsgLy9zZXQgY3Vyc29yIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBhbmQgc2Nyb2xsIHRvIGJvdHRvbVxuXG5cblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLl9mb3JtLmVsZW1lbnRzLnRleHQuZ2V0SW5wdXROb2RlKCk7XG5cblx0ICAgICAgbm9kZS5zY3JvbGxUb3AgPSBub2RlLnNjcm9sbEhlaWdodDtcblx0ICAgICAgc2V0U2VsZWN0aW9uUmFuZ2Uobm9kZSwgdmFsdWVzLnRleHQubGVuZ3RoKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRWRpdFN0YXJ0XCIsIFtpZF0pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NhdmVDb21tZW50OiBmdW5jdGlvbiAoY2xlYXIpIHtcblx0ICAgIHZhciB2YWx1ZXMgPSB0aGlzLl9mb3JtLmdldFZhbHVlcygpO1xuXG5cdCAgICBpZiAodmFsdWVzLnRleHQpIHtcblx0ICAgICAgaWYgKHZhbHVlcy5pZCkgdGhpcy51cGRhdGVJdGVtKHZhbHVlcy5pZCwgdmFsdWVzKTtlbHNlIHtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcuY3VycmVudFVzZXIpIHZhbHVlcy51c2VyX2lkID0gdGhpcy5jb25maWcuY3VycmVudFVzZXI7XG5cdCAgICAgICAgdmFsdWVzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgIHRoaXMuYWRkKHZhbHVlcyk7XG5cblx0ICAgICAgICB0aGlzLl9saXN0LnNjcm9sbFRvKDAsIHRoaXMuX2xpc3QuZ2V0TGFzdElkKCkpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fZm9ybS5jbGVhcigpO1xuXG5cdCAgICAgIGlmIChjbGVhcikgdGhpcy5faW5wdXQuZ2V0SW5wdXROb2RlKCkudmFsdWUgPSBcIlwiO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3JlbW92ZUNvbW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgaWYgKHRoaXMuX2Zvcm0uZ2V0VmFsdWVzKCkuaWQgPT0gaWQpIHtcblx0ICAgICAgdGhpcy5fZm9ybS5jbGVhcigpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbW92ZShpZCk7XG5cdCAgfSxcblx0ICBfY2hhbmdlVGV4dGFyZWE6IGZ1bmN0aW9uIChpbmNyZWFzZSkge1xuXHQgICAgLy90aGlzIGJlaGF2aW91ciBpcyBvbmx5IGZvciBkZXNrdG9wLCBvdGhlcndpc2Ugd2Ugd2lsbCBuZXZlciBzZWUgdGhlIGJ1dHRvbiBvbiBtb2JpbGVcblx0ICAgIGlmIChlbnYudG91Y2gpIHJldHVybjtcblx0ICAgIHZhciB0ZXh0ID0gdGhpcy5faW5wdXQ7XG5cblx0ICAgIGlmIChpbmNyZWFzZSkge1xuXHQgICAgICB0aGlzLl9zZW5kQnV0dG9uLmdldFBhcmVudFZpZXcoKS5zaG93KCk7XG5cblx0ICAgICAgdGV4dC5kZWZpbmUoe1xuXHQgICAgICAgIGhlaWdodDogODRcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAoVUlNYW5hZ2VyLmhhc0ZvY3VzKHRoaXMuX3NlbmRCdXR0b24pKSBVSU1hbmFnZXIuc2V0Rm9jdXModGhpcy5fbGlzdCk7XG5cblx0ICAgICAgdGhpcy5fc2VuZEJ1dHRvbi5nZXRQYXJlbnRWaWV3KCkuaGlkZSgpO1xuXG5cdCAgICAgIHRleHQuZGVmaW5lKHtcblx0ICAgICAgICBoZWlnaHQ6IHRoaXMuX2lucHV0SGVpZ2h0XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB0ZXh0LnJlc2l6ZSgpO1xuXHQgIH0sXG5cdCAgX3RvZ2dsZUJ1dHRvbjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IHRoaXMuX2lucHV0LmdldFZhbHVlKCk7XG5cdCAgICBpZiAodmFsdWUgJiYgIXRoaXMuX3NlbmRCdXR0b24uaXNFbmFibGVkKCkpIHRoaXMuX3NlbmRCdXR0b24uZW5hYmxlKCk7ZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3NlbmRCdXR0b24uaXNFbmFibGVkKCkpIHRoaXMuX3NlbmRCdXR0b24uZGlzYWJsZSgpO1xuXHQgIH0sXG5cdCAgX2luaXRNZW51OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuXHQgICAgdGhpcy5fbGlzdE1lbnUgPSB1aSh7XG5cdCAgICAgIHZpZXc6IFwiY29udGV4dG1lbnVcIixcblx0ICAgICAgYXV0b3dpZHRoOiB0cnVlLFxuXHQgICAgICBwb2ludDogZmFsc2UsXG5cdCAgICAgIGRhdGE6IFt7XG5cdCAgICAgICAgaWQ6IFwiZWRpdFwiLFxuXHQgICAgICAgIGljb246IFwid3hpLXBlbmNpbFwiLFxuXHQgICAgICAgIHZhbHVlOiBpMThuLmNvbW1lbnRzW1wiZWRpdFwiXVxuXHQgICAgICB9LCB7XG5cdCAgICAgICAgaWQ6IFwicmVtb3ZlXCIsXG5cdCAgICAgICAgaWNvbjogXCJ3eGktdHJhc2hcIixcblx0ICAgICAgICB2YWx1ZTogaTE4bi5jb21tZW50c1tcInJlbW92ZVwiXVxuXHQgICAgICB9XSxcblx0ICAgICAgb246IHtcblx0ICAgICAgICBvblNob3c6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBjdHggPSBfdGhpczMuX2xpc3RNZW51LmdldENvbnRleHQoKTtcblxuXHQgICAgICAgICAgX3RoaXMzLl9saXN0LmFkZENzcyhjdHguaWQsIFwiYWN0aXZlX21lbnVcIik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIHZhciBjdHggPSBfdGhpczMuX2xpc3RNZW51LmdldENvbnRleHQoKTtcblxuXHQgICAgICAgICAgX3RoaXMzLl9saXN0LnJlbW92ZUNzcyhjdHguaWQsIFwiYWN0aXZlX21lbnVcIik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvbkl0ZW1DbGljazogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgICB2YXIgY3R4ID0gX3RoaXMzLl9saXN0TWVudS5nZXRDb250ZXh0KCk7XG5cblx0ICAgICAgICAgIGlmIChfdGhpczMuY2FsbEV2ZW50KFwib25CZWZvcmVNZW51QWN0aW9uXCIsIFtpZCwgY3R4LmlkXSkpIHtcblx0ICAgICAgICAgICAgaWYgKGlkID09IFwiZWRpdFwiKSBfdGhpczMuZWRpdChjdHguaWQpO2Vsc2UgaWYgKGlkID09IFwicmVtb3ZlXCIpIHtcblx0ICAgICAgICAgICAgICBpZiAoaTE4bi5jb21tZW50cy5jb25maXJtTWVzc2FnZSkgY29uZmlybSh7XG5cdCAgICAgICAgICAgICAgICB0ZXh0OiBpMThuLmNvbW1lbnRzLmNvbmZpcm1NZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHJlcykgX3RoaXMzLl9yZW1vdmVDb21tZW50KGN0eC5pZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfSk7ZWxzZSBfdGhpczMuX3JlbW92ZUNvbW1lbnQoY3R4LmlkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZS5wdXNoKHRoaXMuX2xpc3RNZW51KTtcblx0ICB9LFxuXHQgIF9jb25maWdGb3JtOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuXHQgICAgdmFyIGxvY2FsZSA9IGkxOG4uY29tbWVudHM7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB2aWV3OiBcImZvcm1cIixcblx0ICAgICAgbWluSGVpZ2h0OiA1MCxcblx0ICAgICAgcGFkZGluZ1g6IDEwLFxuXHQgICAgICBlbGVtZW50czogW3tcblx0ICAgICAgICB2aWV3OiBcInRleHRhcmVhXCIsXG5cdCAgICAgICAgY3NzOiBcIndlYml4X2NvbW1lbnRzX3RleHRhcmVhXCIsXG5cdCAgICAgICAgaGVpZ2h0OiB0aGlzLl9pbnB1dEhlaWdodCxcblx0ICAgICAgICBuYW1lOiBcInRleHRcIixcblx0ICAgICAgICBwbGFjZWhvbGRlcjogbG9jYWxlW1wicGxhY2Vob2xkZXJcIl0sXG5cdCAgICAgICAga2V5UHJlc3NUaW1lb3V0OiAxMDAsXG5cdCAgICAgICAgb246IHtcblx0ICAgICAgICAgIG9uVGltZWRLZXlQcmVzczogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBfdGhpczQuX3RvZ2dsZUJ1dHRvbigpO1xuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAobmV3dikge1xuXHQgICAgICAgICAgICBfdGhpczQuX3RvZ2dsZUJ1dHRvbihuZXd2KTtcblx0ICAgICAgICAgIH0sXG5cdCAgICAgICAgICBvbktleVByZXNzOiBmdW5jdGlvbiAoY29kZSwgZXYpIHtcblx0ICAgICAgICAgICAgaWYgKGNvZGUgPT0gMTMpIHtcblx0ICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gX3RoaXM0Ll9zZXR0aW5ncy5zZW5kQWN0aW9uLFxuXHQgICAgICAgICAgICAgICAgICBzaGlmdCA9IGV2LnNoaWZ0S2V5O1xuXG5cdCAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSBcImVudGVyXCIgJiYgIXNoaWZ0IHx8IGFjdGlvbiAhPT0gXCJlbnRlclwiICYmIHNoaWZ0KSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2ZW50RXZlbnQoZXYpO1xuXG5cdCAgICAgICAgICAgICAgICBfdGhpczQuX3NhdmVDb21tZW50KHRydWUpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSwge1xuXHQgICAgICAgIGhpZGRlbjogIWVudi50b3VjaCxcblx0ICAgICAgICBjb2xzOiBbe30sIHtcblx0ICAgICAgICAgIHZpZXc6IFwiYnV0dG9uXCIsXG5cdCAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcblx0ICAgICAgICAgIGNzczogXCJ3ZWJpeF9jb21tZW50c19zZW5kXCIsXG5cdCAgICAgICAgICB0eXBlOiBcImZvcm1cIixcblx0ICAgICAgICAgIHZhbHVlOiBsb2NhbGVbXCJzZW5kXCJdLFxuXHQgICAgICAgICAgYXV0b3dpZHRoOiB0cnVlLFxuXHQgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX3RoaXM0Ll9zYXZlQ29tbWVudCgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1dXG5cdCAgICAgIH1dXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2NvbmZpZ0xpc3Q6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdCAgICB2YXIgY3NzID0gXCJ3ZWJpeF9jb21tZW50c19cIjtcblx0ICAgIHZhciB0eXBlID0ge1xuXHQgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuXHQgICAgICB0ZW1wbGF0ZVN0YXR1czogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzID0gJ1wiICsgY3NzICsgXCJzdGF0dXMgXCIgKyBvYmouc3RhdHVzICsgXCInPjwvc3Bhbj5cIjtcblx0ICAgICAgfSxcblx0ICAgICAgdGVtcGxhdGVVc2VyOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgdmFyIHVzZXJzID0gX3RoaXM1LmdldFVzZXJzKCk7XG5cblx0ICAgICAgICB2YXIgdXNlciA9IHVzZXJzICYmIHVzZXJzLmV4aXN0cyhvYmoudXNlcl9pZCkgPyB1c2Vycy5nZXRJdGVtKG9iai51c2VyX2lkKSA6IHt9O1xuXHQgICAgICAgIHZhciBuYW1lID0gXCI8c3BhbiBjbGFzcyA9ICdcIiArIGNzcyArIFwibmFtZSc+XCIgKyAodXNlci52YWx1ZSB8fCBcIlwiKSArIFwiPC9zcGFuPlwiO1xuXHQgICAgICAgIHJldHVybiBuYW1lO1xuXHQgICAgICB9LFxuXHQgICAgICB0ZW1wbGF0ZU1lbnU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz0nd2ViaXhfaWNvbiB3eGktZG90cyBcIiArIGNzcyArIFwibWVudSc+PC9zcGFuPlwiO1xuXHQgICAgICB9LFxuXHQgICAgICB0ZW1wbGF0ZURhdGU6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB2YXIgZm9ybWF0ID0gd0RhdGUuZGF0ZVRvU3RyKFwiJWQgJU0sICVIOiVpXCIpO1xuXHQgICAgICAgIHJldHVybiBvYmouZGF0ZSA/IFwiPHNwYW4gY2xhc3M9J1wiICsgY3NzICsgXCJkYXRlJz5cIiArIGZvcm1hdChvYmouZGF0ZSkgKyBcIjwvc3Bhbj5cIiA6IFwiXCI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHRlbXBsYXRlTGlua3M6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB2YXIgdGV4dCA9IG9iai50ZXh0LnJlcGxhY2UoLyhodHRwcz86XFwvXFwvW15cXHNdKykvZywgZnVuY3Rpb24gKG1hdGNoKSB7XG5cdCAgICAgICAgICBtYXRjaCA9IHRlbXBsYXRlLmVzY2FwZShtYXRjaCk7XG5cdCAgICAgICAgICB2YXIgaHRtbCA9IFwiPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9J1wiICsgbWF0Y2ggKyBcIic+XCI7XG5cdCAgICAgICAgICBpZiAobWF0Y2gubWF0Y2goLy4oanBnfGpwZWd8cG5nfGdpZikkLykpIGh0bWwgKz0gXCI8aW1nIGNsYXNzPSd3ZWJpeF9jb21tZW50c19pbWFnZScgc3JjPSdcIiArIG1hdGNoICsgXCInLz5cIjtlbHNlIGh0bWwgKz0gbWF0Y2g7XG5cdCAgICAgICAgICByZXR1cm4gaHRtbCArIFwiPC9hPlwiO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0ZXh0O1xuXHQgICAgICB9LFxuXHQgICAgICB0ZW1wbGF0ZVRleHQ6IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICAgIHJldHVybiBcIjxkaXYgY2xhc3MgPSAnXCIgKyBjc3MgKyBcIm1lc3NhZ2UnPlwiICsgY29tbW9uLnRlbXBsYXRlTGlua3Mob2JqKSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHRlbXBsYXRlQXZhdGFyOiBmdW5jdGlvbiAob2JqLCBjb21tb24pIHtcblx0ICAgICAgICB2YXIgYXZhdGFyID0gXCI8ZGl2IGNsYXNzPSdcIiArIGNzcyArIFwiYXZhdGFyJz5cIjtcblxuXHQgICAgICAgIHZhciB1c2VycyA9IF90aGlzNS5nZXRVc2VycygpO1xuXG5cdCAgICAgICAgdmFyIHVzZXIgPSB1c2VycyAmJiB1c2Vycy5leGlzdHMob2JqLnVzZXJfaWQpID8gdXNlcnMuZ2V0SXRlbShvYmoudXNlcl9pZCkgOiB7fTtcblx0ICAgICAgICBpZiAodXNlci5zdGF0dXMpIGF2YXRhciArPSBjb21tb24udGVtcGxhdGVTdGF0dXModXNlcik7XG5cdCAgICAgICAgYXZhdGFyICs9IFwiPGRpdiBjbGFzcz0nXCIgKyBjc3MgKyBcImF2YXRhcl9pbWFnZSBcIjtcblx0ICAgICAgICBpZiAodXNlci5pbWFnZSkgYXZhdGFyICs9IFwiJz48aW1nIHNyYyA9ICdcIiArIHVzZXIuaW1hZ2UgKyBcIicgY2xhc3M9J1wiICsgY3NzICsgXCJwaG90byc+XCI7ZWxzZSB7XG5cdCAgICAgICAgICB2YXIgaWNvbiA9IHVzZXIudmFsdWUgPyB1c2VyLnZhbHVlWzBdLnRvVXBwZXJDYXNlKCkgOiBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIHd4aS11c2VyJz48L3NwYW4+XCI7XG5cdCAgICAgICAgICBhdmF0YXIgKz0gY3NzICsgXCJhdmF0YXJfdGV4dCc+XCIgKyBpY29uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBhdmF0YXIgKz0gXCI8L2Rpdj48L2Rpdj5cIjtcblx0ICAgICAgICByZXR1cm4gYXZhdGFyO1xuXHQgICAgICB9LFxuXHQgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICAgICAgdmFyIG1lc3NhZ2UkJDE7XG5cblx0ICAgICAgICBpZiAob2JqLmlkID09IFwiJG1vcmVcIikge1xuXHQgICAgICAgICAgbWVzc2FnZSQkMSA9IFwiPGRpdiBjbGFzcz0nd2ViaXhfY29tbWVudHNfbW9yZSc+XCIgKyBfdGhpczUuX3NldHRpbmdzLm1vcmVCdXR0b24ob2JqKSArIFwiPC9kaXY+XCI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciBhdmF0YXIgPSBjb21tb24udGVtcGxhdGVBdmF0YXIob2JqLCBjb21tb24pO1xuXHQgICAgICAgICAgdmFyIHVzZXIgPSBjb21tb24udGVtcGxhdGVVc2VyKG9iaiwgY29tbW9uKTtcblx0ICAgICAgICAgIHZhciBkYXRlID0gY29tbW9uLnRlbXBsYXRlRGF0ZShvYmosIGNvbW1vbik7XG5cdCAgICAgICAgICB2YXIgbWVudSA9IGNvbW1vbi50ZW1wbGF0ZU1lbnUob2JqLCBjb21tb24pO1xuXHQgICAgICAgICAgdmFyIHRleHQgPSBjb21tb24udGVtcGxhdGVUZXh0KG9iaiwgY29tbW9uKTtcblx0ICAgICAgICAgIG1lc3NhZ2UkJDEgPSBhdmF0YXIgKyB1c2VyICsgbWVudSArIGRhdGUgKyB0ZXh0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBtZXNzYWdlJCQxO1xuXHQgICAgICB9LFxuXHQgICAgICBjbGFzc25hbWU6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgICB2YXIgY3NzID0gbGlzdC5hcGkudHlwZS5jbGFzc25hbWUob2JqLCBjb21tb24sIG1hcmtzKTtcblx0ICAgICAgICBpZiAob2JqLnVzZXJfaWQgJiYgb2JqLnVzZXJfaWQgPT0gX3RoaXM1Ll9zZXR0aW5ncy5jdXJyZW50VXNlciB8fCAhX3RoaXM1Ll91c2Vycy5jb3VudCgpKSBjc3MgKz0gXCIgd2ViaXhfY29tbWVudHNfY3VycmVudFwiO1xuXHQgICAgICAgIHJldHVybiBjc3M7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICB0eXBlID0gZXhwb3J0cy5leHRlbmQodHlwZSwgY29uZmlnLmxpc3RJdGVtIHx8IHt9LCB0cnVlKTtcblx0ICAgIHZhciBzY2hlbWUgPSB7XG5cdCAgICAgICRpbml0OiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgaWYgKG9iai5kYXRlKSBvYmouZGF0ZSA9IGkxOG4ucGFyc2VGb3JtYXREYXRlKG9iai5kYXRlKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHNjaGVtZSA9IGV4cG9ydHMuZXh0ZW5kKHNjaGVtZSwgY29uZmlnLnNjaGVtZSB8fCB7fSwgdHJ1ZSk7XG5cdCAgICB2YXIgbGlzdENvbmZpZyA9IHtcblx0ICAgICAgdmlldzogXCJsaXN0XCIsXG5cdCAgICAgIG5hdmlnYXRpb246IGZhbHNlLFxuXHQgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICBzY2hlbWU6IHNjaGVtZSxcblx0ICAgICAgb25DbGljazoge1xuXHQgICAgICAgIFwid2ViaXhfY29tbWVudHNfbWVudVwiOiBmdW5jdGlvbiAoZXYsIGlkKSB7XG5cdCAgICAgICAgICBpZiAoX3RoaXM1Ll9saXN0TWVudS5pc1Zpc2libGUoKSkgX3RoaXM1Ll9saXN0TWVudS5oaWRlKCk7ZWxzZSB7XG5cdCAgICAgICAgICAgIF90aGlzNS5fbGlzdE1lbnUuc2V0Q29udGV4dCh7XG5cdCAgICAgICAgICAgICAgb2JqOiBfdGhpczUsXG5cdCAgICAgICAgICAgICAgaWQ6IGlkXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIF90aGlzNS5fbGlzdE1lbnUuc2hvdyhldi50YXJnZXQsIHR5cGUubWVudVBvc2l0aW9uIHx8IHtcblx0ICAgICAgICAgICAgICBwb3M6IFwibGVmdFwiLFxuXHQgICAgICAgICAgICAgIHk6IDMwLFxuXHQgICAgICAgICAgICAgIHg6IDEwXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgXCJ3ZWJpeF9jb21tZW50c19tb3JlXCI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIGlmIChfdGhpczUuY29uZmlnLnVybCAmJiBfdGhpczUuY2FsbEV2ZW50KFwib25EYXRhUmVxdWVzdFwiLCBbXSkpIHtcblx0ICAgICAgICAgICAgX3RoaXM1Ll9tb3JlQ2FsbCA9IHRydWU7XG5cblx0ICAgICAgICAgICAgdmFyIG1vcmUgPSBfdGhpczUuX2xpc3QuZ2V0SXRlbShcIiRtb3JlXCIpLnZhbHVlO1xuXG5cdCAgICAgICAgICAgIHZhciBwb3MkJDEgPSBfdGhpczUuX3NldHRpbmdzLm1vZGUgPT0gXCJjaGF0XCIgPyBtb3JlIDogX3RoaXM1Ll9saXN0LmdldEluZGV4QnlJZChcIiRtb3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgdXJsID0gcHJveHkkYS4kcGFyc2UoX3RoaXM1LmNvbmZpZy51cmwpO1xuXHQgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB7XG5cdCAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzNS5fbW9yZUNhbGwgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09IFwic3RyaW5nXCIpIHVybCA9IHVybCArICh1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIikgKyBcInBvcz1cIiArIHBvcyQkMSArIFwiJm1vcmU9XCIgKyBtb3JlO1xuXG5cdCAgICAgICAgICAgIF90aGlzNS5sb2FkKHVybCwgY2FsbGJhY2ssIHtcblx0ICAgICAgICAgICAgICBwb3M6IHBvcyQkMSxcblx0ICAgICAgICAgICAgICBtb3JlOiBtb3JlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgb246IHtcblx0ICAgICAgICBvbkFmdGVyU2Nyb2xsOiBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIC8vbWVudSBtb3ZlcyB3aXRoIHNjcm9sbFxuXHQgICAgICAgICAgdGhpcy5fbGlzdE1lbnUuaGlkZSgpO1xuXHQgICAgICAgIH0sIHRoaXMpXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBpZiAoY29uZmlnLnNhdmUpIGxpc3RDb25maWcuc2F2ZSA9IGNvbmZpZy5zYXZlO1xuXHQgICAgcmV0dXJuIGxpc3RDb25maWc7XG5cdCAgfSxcblx0ICBfaW5pdFVzZXJzOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG5cdCAgICBpZiAodmFsdWUgJiYgdmFsdWUuZ2V0SXRlbSkge1xuXHQgICAgICB0aGlzLl91c2VycyA9IHZhbHVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fdXNlcnMgPSBuZXcgRGF0YUNvbGxlY3Rpb24oKTtcblxuXHQgICAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUucHVzaCh0aGlzLl91c2Vycyk7XG5cblx0ICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy5fdXNlcnMubG9hZCh2YWx1ZSk7ZWxzZSB0aGlzLl91c2Vycy5wYXJzZSh2YWx1ZSB8fCBbXSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3VzZXJzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIF90aGlzNi5fbGlzdC5yZWZyZXNoKCk7XG5cdCAgICB9KTtcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JDE1ID0gZXhwb3J0cy5wcm90b1VJKGFwaSQxNSwgQXRvbURhdGFMb2FkZXIsIGxheW91dC52aWV3KTtcblxuXHQvLyAjaW5jbHVkZSB1aS9saXN0LmpzXG5cblx0dmFyIGFwaSQxNiA9IHtcblx0ICBuYW1lOiBcIm1lbnVcIixcblx0ICBfbGlzdENsYXNzTmFtZTogXCJ3ZWJpeF9tZW51XCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHRoaXMuZGF0YS5fc2NoZW1lX2luaXQgPSBiaW5kKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgaWYgKG9iai5kaXNhYmxlZCkgdGhpcy5kYXRhLmFkZE1hcmsob2JqLmlkLCBcIndlYml4X2Rpc2FibGVkXCIsIHRydWUsIDEsIHRydWUpO1xuXHQgICAgfSwgdGhpcyk7XG5cblx0ICAgIGlmIChjb25maWcuYXV0b3dpZHRoKSB7XG5cdCAgICAgIHRoaXMuX2F1dG93aWR0aF9zdWJtZW51ID0gdHJ1ZTtcblx0ICAgICAgZGVsZXRlIGNvbmZpZy5hdXRvd2lkdGg7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGJpbmQoZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLl9oaWRlX3N1Yl9tZW51KCk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25Nb3VzZU1vdmVcIiwgdGhpcy5fbW91c2VfbW92ZV9tZW51KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbk1vdXNlT3V0XCIsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9tZW51X3dhc19hY3RpdmF0ZWQoKSAmJiB0aGlzLl9zZXR0aW5ncy5vcGVuQWN0aW9uID09IFwiY2xpY2tcIikgcmV0dXJuO1xuXHQgICAgICBpZiAoIXRoaXMuX2NoaWxkX21lbnVfYWN0aXZlICYmIGUucmVsYXRlZFRhcmdldCkgdGhpcy5faGlkZV9zdWJfbWVudSgpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25JdGVtQ2xpY2tcIiwgZnVuY3Rpb24gKGlkLCBlLCB0cmcpIHtcblx0ICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuXG5cdCAgICAgIGlmIChpdGVtKSB7XG5cdCAgICAgICAgaWYgKGl0ZW0uJHRlbXBsYXRlKSByZXR1cm47XG5cdCAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0VG9wTWVudSgpOyAvL2lnbm9yZSBkaXNhYmxlZCBpdGVtc1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLmRhdGEuZ2V0TWFyayhpZCwgXCJ3ZWJpeF9kaXNhYmxlZFwiKSkge1xuXHQgICAgICAgICAgaWYgKCFwYXJlbnQuY2FsbEV2ZW50KFwib25NZW51SXRlbUNsaWNrXCIsIFtpZCwgZSwgdHJnXSkpIHtcblx0ICAgICAgICAgICAgZS5zaG93cG9wdXAgPSB0cnVlO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICh0aGlzICE9IHBhcmVudCkgcGFyZW50Ll9jYWxsX29uY2xpY2soaWQsIGUsIHRyZyk7IC8vY2xpY2sgb24gZ3JvdXAgLSBkbyBub3QgY2xvc2Ugc3VibWVudXNcblxuXHQgICAgICAgICAgaWYgKCFpdGVtLnN1Ym1lbnUgJiYgIXBhcmVudC5fc2hvd19jaGlsZF9vbl9jbGljaykge1xuXHQgICAgICAgICAgICBwYXJlbnQuX2hpZGVfc3ViX21lbnUodHJ1ZSk7XG5cblx0ICAgICAgICAgICAgaWYgKHBhcmVudC5faGlkZV9vbl9pdGVtX2NsaWNrKSBwYXJlbnQuaGlkZSgpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKCh0aGlzID09PSBwYXJlbnQgfHwgZW52LnRvdWNoKSAmJiBwYXJlbnQuX3NldHRpbmdzLm9wZW5BY3Rpb24gPT0gXCJjbGlja1wiKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5fbW91c2VfbW92ZV9hY3RpdmF0aW9uKGlkLCB0cmcpO1xuXHQgICAgICAgICAgICB9IC8vZG8gbm90IGNsb3NlIHBvcHVwcyB3aGVuIGNsaWNraW5nIG9uIG1lbnUgZm9sZGVyXG5cblxuXHQgICAgICAgICAgICBlLnNob3dwb3B1cCA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbktleVByZXNzXCIsIGZ1bmN0aW9uIChjb2RlKSB7XG5cdCAgICAgIGlmIChjb2RlID09PSA5KSB0aGlzLmdldFRvcE1lbnUoKS5faGlkZV9zdWJfbWVudSgpO2Vsc2UgaWYgKGNvZGUgPT09IDEzIHx8IGNvZGUgPT09IDMyKSB7XG5cdCAgICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCgpLFxuXHQgICAgICAgICAgICBub2RlO1xuXHQgICAgICAgIGlmIChzZWwpIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKHNlbCk7XG5cdCAgICAgICAgaWYgKG5vZGUpIHRyaWdnZXJFdmVudChub2RlLCBcIk1vdXNlRXZlbnRzXCIsIFwiY2xpY2tcIik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25DbGVhckFsbFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuX2hpZGRlbl9pdGVtcyA9IFtdO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmRhdGEuX2hpZGRlbl9pdGVtcyA9IFtdO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJtZW51YmFyXCIpOyAvL2NvbXBvbmVudCBjYW4gY3JlYXRlIG5ldyB2aWV3XG5cblxuXHQgICAgdGhpcy5fZGVzdHJveV93aXRoX21lID0gW107XG5cdCAgfSxcblx0ICBzaXplVG9Db250ZW50OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGF5b3V0ID09IFwieVwiKSB7XG5cdCAgICAgIHZhciB0ZXh0cyA9IFtdO1xuXHQgICAgICB2YXIgaXNTdWJtZW51ID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB0ZXh0cy5wdXNoKHRoaXMuX3RvSFRNTChvYmopKTtcblx0ICAgICAgICBpZiAob2JqLnN1Ym1lbnUpIGlzU3VibWVudSA9IHRydWU7XG5cdCAgICAgIH0sIHRoaXMpOyAvLyB0ZXh0IHdpZHRoICsgcGFkZGluZyArIGJvcmRlcnMrIGFycm93XG5cblx0ICAgICAgdGhpcy5jb25maWcud2lkdGggPSBnZXRUZXh0U2l6ZSh0ZXh0cywgdGhpcy4kdmlldy5jbGFzc05hbWUpLndpZHRoICsgOCAqIDIgKyAyICsgKGlzU3VibWVudSA/IDE1IDogMCk7XG5cdCAgICAgIHRoaXMucmVzaXplKCk7XG5cdCAgICB9IGVsc2UgYXNzZXJ0KGZhbHNlLCBcInNpemVUb0NvbnRlbnQgd2lsbCB3b3JrIGZvciB2ZXJ0aWNhbCBtZW51IG9ubHlcIik7XG5cdCAgfSxcblx0ICBnZXRUb3BNZW51OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuXHQgICAgd2hpbGUgKHBhcmVudC5fcGFyZW50X21lbnUpIHtcblx0ICAgICAgcGFyZW50ID0gJCQocGFyZW50Ll9wYXJlbnRfbWVudSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwYXJlbnQ7XG5cdCAgfSxcblx0ICBfYXV0b19oZWlnaHRfY2FsYzogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2hlaWdodCkgY291bnQgPSB0aGlzLmNvdW50KCk7XG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmNvdW50KCksXG5cdCAgICAgICAgaGVpZ2h0ID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5kYXRhLnB1bGxbdGhpcy5kYXRhLm9yZGVyW2ldXTtcblxuXHQgICAgICBpZiAoaXRlbSAmJiBpdGVtLiR0ZW1wbGF0ZSA9PSBcIlNlcGFyYXRvclwiKSB7XG5cdCAgICAgICAgaGVpZ2h0ICs9IDQ7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0KSBjb3VudCsrO1xuXHQgICAgICB9IGVsc2UgaGVpZ2h0ICs9IHRoaXMudHlwZS5oZWlnaHQ7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX29ub2ZmX3Njcm9sbChjb3VudCAmJiBjb3VudCA8IHZhbHVlLCBcInlcIik7XG5cblx0ICAgIHJldHVybiBoZWlnaHQ7XG5cdCAgfSxcblx0ICBvbl9tb3VzZV9tb3ZlOiB7fSxcblx0ICB0eXBlOiB7XG5cdCAgICBfc3VibWVudTogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqLnN1Ym1lbnUgfHwgb2JqLmRhdGEgfHwgb2JqLml0ZW07XG5cdCAgICB9LFxuXHQgICAgY3NzOiBcIm1lbnVcIixcblx0ICAgIHdpZHRoOiBcImF1dG9cIixcblx0ICAgIGFyaWE6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFya3MpIHtcblx0ICAgICAgcmV0dXJuIFwicm9sZT1cXFwibWVudWl0ZW1cXFwiXCIgKyAobWFya3MgJiYgbWFya3Mud2ViaXhfc2VsZWN0ZWQgPyBcIiBhcmlhLXNlbGVjdGVkPVxcXCJ0cnVlXFxcIiB0YWJpbmRleD1cXFwiMFxcXCJcIiA6IFwidGFiaW5kZXg9XFxcIi0xXFxcIlwiKSArIChjb21tb24uX3N1Ym1lbnUob2JqKSA/IFwiYXJpYS1oYXNwb3B1cD1cXFwidHJ1ZVxcXCJcIiA6IFwiXCIpICsgKG1hcmtzICYmIG1hcmtzLndlYml4X2Rpc2FibGVkID8gXCIgYXJpYS1kaXNhYmxlZD1cXFwidHJ1ZVxcXCJcIiA6IFwiXCIpO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlU3RhcnQ6IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgbWFyaykge1xuXHQgICAgICBpZiAob2JqLiR0ZW1wbGF0ZSA9PT0gXCJTZXBhcmF0b3JcIiB8fCBvYmouJHRlbXBsYXRlID09PSBcIlNwYWNlclwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiPGRpdiB3ZWJpeF9sX2lkPVxcXCIjaWQjXFxcIiByb2xlPVxcXCJzZXBhcmF0b3JcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcIndlYml4X2NvbnRleHRfXCIgKyBvYmouJHRlbXBsYXRlLnRvTG93ZXJDYXNlKCkgKyBcIlxcXCI+XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgbGluayA9IChvYmouaHJlZiA/IFwiIGhyZWY9J1wiICsgb2JqLmhyZWYgKyBcIicgXCIgOiBcIlwiKSArIChvYmoudGFyZ2V0ID8gXCIgdGFyZ2V0PSdcIiArIG9iai50YXJnZXQgKyBcIicgXCIgOiBcIlwiKTtcblx0ICAgICAgcmV0dXJuIGxpc3QuYXBpLnR5cGUudGVtcGxhdGVTdGFydChvYmosIGNvbW1vbiwgbWFyaykucmVwbGFjZSgvXjxkaXYvLCBcIjxhIFwiICsgbGluaykgKyAoY29tbW9uLl9zdWJtZW51KG9iaikgJiYgY29tbW9uLnN1YnNpZ24gPyBcIjxkaXYgY2xhc3M9J3dlYml4X3N1Ym1lbnVfaWNvbic+PC9kaXY+XCIgOiBcIlwiKTtcblx0ICAgIH0sXG5cdCAgICB0ZW1wbGF0ZUVuZDogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICByZXR1cm4gb2JqLiR0ZW1wbGF0ZSA9PT0gXCJTZXBhcmF0b3JcIiB8fCBvYmouJHRlbXBsYXRlID09PSBcIlNwYWNlclwiID8gXCI8L2Rpdj5cIiA6IFwiPC9hPlwiO1xuXHQgICAgfSxcblx0ICAgIHRlbXBsYXRlU2VwYXJhdG9yOiB0ZW1wbGF0ZShcIjxkaXYgY2xhc3M9J3NlcF9saW5lJz48L2Rpdj5cIiksXG5cdCAgICB0ZW1wbGF0ZVNwYWNlcjogdGVtcGxhdGUoXCI8ZGl2PjwvZGl2PlwiKVxuXHQgIH0sXG5cdCAgZ2V0TWVudTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICBpZiAoIXRoaXMuZGF0YS5wdWxsW2lkXSkge1xuXHQgICAgICBmb3IgKHZhciBzdWJpZCBpbiB0aGlzLmRhdGEucHVsbCkge1xuXHQgICAgICAgIHZhciBvYmogPSB0aGlzLmdldEl0ZW0oc3ViaWQpO1xuXG5cdCAgICAgICAgaWYgKG9iai5zdWJtZW51KSB7XG5cdCAgICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5fZ2V0X3N1Ym1lbnUob2JqKS5nZXRNZW51KGlkKTtcblxuXHQgICAgICAgICAgaWYgKHNlYXJjaCkgcmV0dXJuIHNlYXJjaDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSByZXR1cm4gdGhpcztcblx0ICB9LFxuXHQgIGdldFN1Yk1lbnU6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdmFyIG1lbnUgPSB0aGlzLmdldE1lbnUoaWQpO1xuXHQgICAgdmFyIG9iaiA9IG1lbnUuZ2V0SXRlbShpZCk7XG5cdCAgICByZXR1cm4gb2JqLnN1Ym1lbnUgPyBtZW51Ll9nZXRfc3VibWVudShvYmopIDogbnVsbDtcblx0ICB9LFxuXHQgIGdldE1lbnVJdGVtOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHJldHVybiB0aGlzLmdldE1lbnUoaWQpLmdldEl0ZW0oaWQpO1xuXHQgIH0sXG5cdCAgX2dldF9zdWJtZW51OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIHN1YiA9ICQkKGRhdGEuc3VibWVudSk7XG5cblx0ICAgIGlmICghc3ViKSB7XG5cdCAgICAgIGRhdGEuc3VibWVudSA9IHRoaXMuX2NyZWF0ZV9zdWJfbWVudShkYXRhKTtcblx0ICAgICAgc3ViID0gJCQoZGF0YS5zdWJtZW51KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN1Yjtcblx0ICB9LFxuXHQgIF9tb3VzZV9tb3ZlX21lbnU6IGZ1bmN0aW9uIChpZCwgZSwgdGFyZ2V0KSB7XG5cdCAgICBpZiAoIXRoaXMuX21lbnVfd2FzX2FjdGl2YXRlZCgpKSByZXR1cm47XG5cblx0ICAgIHRoaXMuX21vdXNlX21vdmVfYWN0aXZhdGlvbihpZCwgdGFyZ2V0KTtcblx0ICB9LFxuXHQgIF9tZW51X3dhc19hY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB0b3AgPSB0aGlzLmdldFRvcE1lbnUoKTtcblxuXHQgICAgaWYgKHRvcC5fc2V0dGluZ3Mub3BlbkFjdGlvbiA9PSBcImNsaWNrXCIpIHtcblx0ICAgICAgaWYgKGVudi50b3VjaCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB2YXIgc3ViID0gdG9wLl9vcGVuX3N1Yl9tZW51O1xuXHQgICAgICBpZiAoc3ViICYmICQkKHN1YikuaXNWaXNpYmxlKCkpIHJldHVybiB0cnVlO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH0sXG5cdCAgX21vdXNlX21vdmVfYWN0aXZhdGlvbjogZnVuY3Rpb24gKGlkLCB0YXJnZXQpIHtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgIGlmICghZGF0YSkgcmV0dXJuOyAvL2NsZWFyIGZsYWcgb2Ygc3VibWVudSB1c2FnZVxuXG5cdCAgICB0aGlzLl9jaGlsZF9tZW51X2FjdGl2ZSA9IG51bGw7IC8vaGlkZSBwcmV2aW91c2x5IG9wZW5lZCBzdWItbWVudVxuXG5cdCAgICBpZiAodGhpcy5fb3Blbl9zdWJfbWVudSAmJiBkYXRhLnN1Ym1lbnUgIT0gdGhpcy5fb3Blbl9zdWJfbWVudSkgdGhpcy5faGlkZV9zdWJfbWVudSh0cnVlKTsgLy9zaG93IHN1Ym1lbnVcblxuXHQgICAgaWYgKHRoaXMudHlwZS5fc3VibWVudShkYXRhKSAmJiAhdGhpcy5jb25maWcuaGlkZGVuKSB7XG5cdCAgICAgIHZhciBzdWIgPSB0aGlzLl9nZXRfc3VibWVudShkYXRhKTtcblxuXHQgICAgICBpZiAodGhpcy5kYXRhLmdldE1hcmsoaWQsIFwid2ViaXhfZGlzYWJsZWRcIikpIHJldHVybjtcblx0ICAgICAgc3ViLnNob3codGFyZ2V0LCB7XG5cdCAgICAgICAgcG9zOiB0aGlzLl9zZXR0aW5ncy5zdWJNZW51UG9zXG5cdCAgICAgIH0pO1xuXHQgICAgICBzdWIuX3BhcmVudF9tZW51ID0gdGhpcy5fc2V0dGluZ3MuaWQ7XG5cdCAgICAgIHRoaXMuX29wZW5fc3ViX21lbnUgPSBkYXRhLnN1Ym1lbnU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBkaXNhYmxlSXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB0aGlzLmdldE1lbnUoaWQpLmFkZENzcyhpZCwgXCJ3ZWJpeF9kaXNhYmxlZFwiKTtcblx0ICB9LFxuXHQgIGVuYWJsZUl0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5nZXRNZW51KGlkKS5yZW1vdmVDc3MoaWQsIFwid2ViaXhfZGlzYWJsZWRcIik7XG5cdCAgfSxcblx0ICBfc2V0X2l0ZW1faGlkZGVuOiBmdW5jdGlvbiAoaWQsIHN0YXRlKSB7XG5cdCAgICB2YXIgbWVudSA9IHRoaXMuZGF0YTtcblxuXHQgICAgaWYgKG1lbnUuX2hpZGRlbl9pdGVtc1tpZF0gIT0gc3RhdGUpIHtcblx0ICAgICAgbWVudS5faGlkZGVuX2l0ZW1zW2lkXSA9IHN0YXRlO1xuXHQgICAgICBtZW51LmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgcmV0dXJuICFtZW51Ll9oaWRkZW5faXRlbXNbb2JqLmlkXTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMucmVzaXplKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBoaWRlSXRlbTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgbWVudSA9IHRoaXMuZ2V0TWVudShpZCk7XG5cdCAgICBpZiAobWVudSkgbWVudS5fc2V0X2l0ZW1faGlkZGVuKGlkLCB0cnVlKTtcblx0ICB9LFxuXHQgIHNob3dJdGVtOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBtZW51ID0gdGhpcy5nZXRNZW51KGlkKTtcblxuXHQgICAgaWYgKG1lbnUpIHtcblx0ICAgICAgbWVudS5fc2V0X2l0ZW1faGlkZGVuKGlkLCBmYWxzZSk7XG5cblx0ICAgICAgcmV0dXJuIGxpc3QuYXBpLnNob3dJdGVtLmNhbGwobWVudSwgaWQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2hpZGVfc3ViX21lbnU6IGZ1bmN0aW9uIChtb2RlKSB7XG5cdCAgICBpZiAodGhpcy5fb3Blbl9zdWJfbWVudSkge1xuXHQgICAgICAvL3JlY3Vyc2l2ZSBzdWItY2xvc2luZ1xuXHQgICAgICB2YXIgc3ViID0gJCQodGhpcy5fb3Blbl9zdWJfbWVudSk7XG5cdCAgICAgIGlmIChzdWIuX2hpZGVfc3ViX21lbnUpIC8vY3VzdG9tIGNvbnRleHQgbWF5IG5vdCBoYXZlIHN1Ym1lbnVcblx0ICAgICAgICBzdWIuX2hpZGVfc3ViX21lbnUobW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgfHwgIXN1Yi5fc2hvd19vbl9tb3VzZV9vdXQpIHtcblx0ICAgICAgICBzdWIuaGlkZSgpO1xuXHQgICAgICAgIHRoaXMuX29wZW5fc3ViX21lbnUgPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY3JlYXRlX3N1Yl9tZW51OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgdmFyIGxpc3RDb25maWcgPSB7XG5cdCAgICAgIHZpZXc6IFwic3VibWVudVwiLFxuXHQgICAgICBkYXRhOiB0aGlzLnR5cGUuX3N1Ym1lbnUoZGF0YSlcblx0ICAgIH07XG5cblx0ICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuZ2V0VG9wTWVudSgpLl9zZXR0aW5ncy5zdWJtZW51Q29uZmlnO1xuXG5cdCAgICBpZiAoc2V0dGluZ3MpIGV4cG9ydHMuZXh0ZW5kKGxpc3RDb25maWcsIHNldHRpbmdzLCB0cnVlKTtcblx0ICAgIHZhciBwYXJlbnREYXRhID0gdGhpcy5nZXRNZW51SXRlbShkYXRhLmlkKTtcblx0ICAgIGlmIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuY29uZmlnKSBleHBvcnRzLmV4dGVuZChsaXN0Q29uZmlnLCBwYXJlbnREYXRhLmNvbmZpZywgdHJ1ZSk7XG5cdCAgICB2YXIgbWVudSA9IHVpKGxpc3RDb25maWcpO1xuXG5cdCAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUucHVzaChtZW51KTtcblxuXHQgICAgbWVudS5fcGFyZW50X21lbnUgPSB0aGlzO1xuXHQgICAgcmV0dXJuIG1lbnUuX3NldHRpbmdzLmlkO1xuXHQgIH0sXG5cdCAgX3NraXBfaXRlbTogZnVuY3Rpb24gKGlkLCBwcmV2LCBtb2RlKSB7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cblx0ICAgIGlmIChpdGVtLiR0ZW1wbGF0ZSA9PSBcIlNlcGFyYXRvclwiIHx8IGl0ZW0uJHRlbXBsYXRlID09IFwiU3BhY2VyXCIgfHwgdGhpcy5kYXRhLmdldE1hcmsoaWQsIFwid2ViaXhfZGlzYWJsZWRcIikpIHtcblx0ICAgICAgdmFyIGluZGV4JCQxID0gdGhpcy5nZXRJbmRleEJ5SWQoaWQpICsgKG1vZGUgPT0gXCJ1cFwiID8gLTEgOiAxKTtcblx0ICAgICAgaWQgPSBpbmRleCQkMSA+PSAwID8gdGhpcy5nZXRJZEJ5SW5kZXgoaW5kZXgkJDEpIDogbnVsbDtcblx0ICAgICAgcmV0dXJuIGlkID8gdGhpcy5fc2tpcF9pdGVtKGlkLCBwcmV2LCBtb2RlKSA6IHByZXY7XG5cdCAgICB9IGVsc2UgcmV0dXJuIGlkO1xuXHQgIH0sXG5cdCAgJHNraW46IGZ1bmN0aW9uICgpIHtcblx0ICAgIGxpc3QuYXBpLiRza2luLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLnR5cGUuaGVpZ2h0ID0gJGFjdGl2ZS5tZW51SGVpZ2h0O1xuXHQgIH0sXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHNjcm9sbDogXCJcIixcblx0ICAgIGxheW91dDogXCJ4XCIsXG5cdCAgICBtb3VzZUV2ZW50RGVsYXk6IDEwMCxcblx0ICAgIHN1Yk1lbnVQb3M6IFwiYm90dG9tXCJcblx0ICB9XG5cdH07XG5cdHZhciB2aWV3JDE2ID0gZXhwb3J0cy5wcm90b1VJKGFwaSQxNiwgbGlzdC52aWV3KTtcblx0dmFyIG1lbnUgPSB7XG5cdCAgYXBpOiBhcGkkMTYsXG5cdCAgdmlldzogdmlldyQxNlxuXHR9O1xuXG5cdHZhciBhcGkkMTcgPSB7XG5cdCAgbmFtZTogXCJzdWJtZW51XCIsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2JvZHlfY2VsbCA9IGNsb25lKHRoaXMuX2R1bW15X2NlbGxfaW50ZXJmYWNlKTtcblx0ICAgIHRoaXMuX2JvZHlfY2VsbC5fdmlldyA9IHRoaXM7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25Nb3VzZU91dFwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICBpZiAodGhpcy5nZXRUb3BNZW51KCkuX3NldHRpbmdzLm9wZW5BY3Rpb24gPT0gXCJjbGlja1wiKSByZXR1cm47XG5cdCAgICAgIGlmICghdGhpcy5fY2hpbGRfbWVudV9hY3RpdmUgJiYgIXRoaXMuX3Nob3dfb25fbW91c2Vfb3V0ICYmIGUucmVsYXRlZFRhcmdldCkgdGhpcy5oaWRlKCk7XG5cdCAgICB9KTsgLy9pbmZvcm0gcGFyZW50IHRoYXQgZm9jdXMgaXMgc3RpbGwgaW4gbWVudVxuXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25Nb3VzZU1vdmluZ1wiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9wYXJlbnRfbWVudSkgJCQodGhpcy5fcGFyZW50X21lbnUpLl9jaGlsZF9tZW51X2FjdGl2ZSA9IHRydWU7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZVNob3dcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAodGhpcy5nZXRUb3BNZW51KCkuX2F1dG93aWR0aF9zdWJtZW51ICYmIHRoaXMuc2l6ZVRvQ29udGVudCAmJiAhdGhpcy5pc1Zpc2libGUoKSkgdGhpcy5zaXplVG9Db250ZW50KCk7XG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fZGF0YW9iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWVudVwiKTtcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBtZW51LmFwaS4kc2tpbi5jYWxsKHRoaXMpO1xuXHQgICAgcG9wdXAuYXBpLiRza2luLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLnR5cGUuaGVpZ2h0ID0gJGFjdGl2ZS5tZW51SGVpZ2h0O1xuXHQgIH0sXG5cdCAgX2R1bW15X2NlbGxfaW50ZXJmYWNlOiB7XG5cdCAgICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgICAvL3dlIHNhdmluZyBoZWlnaHQgYW5kIHdpZHRoLCBhcyBsaXN0IGNhbiBoYXJkY29kZSBuZXcgdmFsdWVzXG5cdCAgICAgIHZhciBoID0gdGhpcy5fdmlldy5fc2V0dGluZ3MuaGVpZ2h0ICogMTtcblx0ICAgICAgdmFyIHcgPSB0aGlzLl92aWV3Ll9zZXR0aW5ncy53aWR0aCAqIDE7XG5cdCAgICAgIHZhciBzaXplID0gbWVudS5hcGkuJGdldFNpemUuY2FsbCh0aGlzLl92aWV3LCBkeCwgZHkpOyAvL3Jlc3RvcmluZ1xuXG5cdCAgICAgIHRoaXMuX3ZpZXcuX3NldHRpbmdzLmhlaWdodCA9IGg7XG5cdCAgICAgIHRoaXMuX3ZpZXcuX3NldHRpbmdzLndpZHRoID0gdztcblx0ICAgICAgcmV0dXJuIHNpemU7XG5cdCAgICB9LFxuXHQgICAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICAgIGlmICh0aGlzLl92aWV3Ll9zZXR0aW5ncy5zY3JvbGwpIHRoaXMuX3ZpZXcuX2JvZHlvYmouc3R5bGUuaGVpZ2h0ID0geSArIFwicHhcIjtcblx0ICAgIH0sXG5cdCAgICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXcgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy9pZ25vcmUgYm9keSBlbGVtZW50XG5cdCAgYm9keV9zZXR0ZXI6IGZ1bmN0aW9uICgpIHt9LFxuXHQgIGdldENoaWxkVmlld3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBbXTtcblx0ICB9LFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICB3aWR0aDogMTUwLFxuXHQgICAgc3ViTWVudVBvczogXCJyaWdodFwiLFxuXHQgICAgbGF5b3V0OiBcInlcIixcblx0ICAgIGF1dG9oZWlnaHQ6IHRydWVcblx0ICB9LFxuXHQgIHR5cGU6IHtcblx0ICAgIGhlaWdodDogJGFjdGl2ZS5tZW51SGVpZ2h0LFxuXHQgICAgc3Vic2lnbjogdHJ1ZVxuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMTcgPSBleHBvcnRzLnByb3RvVUkoYXBpJDE3LCBtZW51LnZpZXcsIHBvcHVwLnZpZXcpO1xuXHR2YXIgc3VibWVudSA9IHtcblx0ICBhcGk6IGFwaSQxNyxcblx0ICB2aWV3OiB2aWV3JDE3XG5cdH07XG5cblx0dmFyIGFwaSQxOCA9IHtcblx0ICBuYW1lOiBcInNpZGVtZW51XCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIGFuaW1hdGU6IHRydWUsXG5cdCAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG5cdCAgICB3aWR0aDogMjAwLFxuXHQgICAgYm9yZGVybGVzczogdHJ1ZVxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuJHZpZXcuY2xhc3NOYW1lICs9IFwiIHdlYml4X3NpZGVtZW51XCI7XG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZhdWx0cy5wYWRkaW5nID0gMDtcblx0ICB9LFxuXHQgIHBvc2l0aW9uX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgcHJldlBvc2l0aW9uID0gdGhpcy5fc2V0dGluZ3MucG9zaXRpb247XG5cdCAgICBpZiAocHJldlBvc2l0aW9uKSByZW1vdmVDc3ModGhpcy4kdmlldywgXCIgd2ViaXhfc2lkZW1lbnVfXCIgKyBwcmV2UG9zaXRpb24pO1xuXHQgICAgYWRkQ3NzKHRoaXMuJHZpZXcsIFwiIHdlYml4X3NpZGVtZW51X1wiICsgdmFsdWUpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgJGdldFNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBzaXplcyA9IHdpbmRvdyQxLmFwaS4kZ2V0U2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVzaXJlZF9zaXplcyA9IHNpemVzO1xuXHQgICAgcmV0dXJuIHNpemVzO1xuXHQgIH0sXG5cdCAgJHNldFNpemU6IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBiYXNlLmFwaS4kc2V0U2l6ZS5jYWxsKHRoaXMsIHgsIHkpO1xuXHQgICAgeCA9IHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nICogMjtcblx0ICAgIHkgPSB0aGlzLl9jb250ZW50X2hlaWdodCAtIHRoaXMuX3NldHRpbmdzLnBhZGRpbmcgKiAyO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5zdHlsZS5wYWRkaW5nID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZyArIFwicHhcIjtcblx0ICAgIHRoaXMuX2hlYWRvYmouc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgdGhpcy5fYm9keW9iai5zdHlsZS5oZWlnaHQgPSB5ICsgXCJweFwiO1xuXG5cdCAgICB0aGlzLl9ib2R5X2NlbGwuJHNldFNpemUoeCwgeSk7XG5cdCAgfSxcblx0ICBzaG93OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVTaG93XCIsIGFyZ3VtZW50cykpIHJldHVybiBmYWxzZTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmhpZGRlbiA9IGZhbHNlO1xuXHQgICAgdGhpcy5fdmlld29iai5zdHlsZS56SW5kZXggPSB0aGlzLl9zZXR0aW5ncy56SW5kZXggfHwgekluZGV4KCk7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tb2RhbCB8fCB0aGlzLl9tb2RhbCkge1xuXHQgICAgICB0aGlzLl9tb2RhbF9zZXQodHJ1ZSk7XG5cblx0ICAgICAgdGhpcy5fbW9kYWwgPSBudWxsOyAvLyBoaWRkZW5fc2V0dGVyIGhhbmRsaW5nXG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuXHQgICAgdGhpcy5fcmVuZGVyX2hpZGRlbl92aWV3cygpO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MucG9zaXRpb24pIHRoaXMuX3NldFBvc2l0aW9uKCk7XG5cdCAgICB0aGlzLl9oaWRlX3RpbWVyID0gMTtcblx0ICAgIGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5faGlkZV90aW1lciA9IDA7XG5cdCAgICB9LCB0aGlzLCBbXSwgZW52LnRvdWNoID8gNDAwIDogMTAwKTtcblxuXHQgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9mb2N1cykge1xuXHQgICAgICB0aGlzLl9wcmV2X2ZvY3VzID0gVUlNYW5hZ2VyLmdldEZvY3VzKCk7XG5cdCAgICAgIFVJTWFuYWdlci5zZXRGb2N1cyh0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKC0xID09IHN0YXRlLl9wb3B1cHMuZmluZCh0aGlzKSkgc3RhdGUuX3BvcHVwcy5wdXNoKHRoaXMpO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNob3dcIiwgW10pO1xuXHQgIH0sXG5cdCAgX3NldFBvc2l0aW9uOiBmdW5jdGlvbiAoeCkge1xuXHQgICAgdmFyIHdpZHRoLFxuXHQgICAgICAgIGhlaWdodCxcblx0ICAgICAgICBtYXhXaWR0aCxcblx0ICAgICAgICBtYXhIZWlnaHQsXG5cdCAgICAgICAgcG9zaXRpb24sXG5cdCAgICAgICAgbGVmdCA9IDAsXG5cdCAgICAgICAgdG9wID0gMCxcblx0ICAgICAgICBzdGF0ZSQkMSA9IHt9O1xuXHQgICAgdGhpcy4kdmlldy5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcblx0ICAgIG1heFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuXHQgICAgbWF4SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcblx0ICAgIHdpZHRoID0gdGhpcy5fZGVzaXJlZF9zaXplc1swXSB8fCBtYXhXaWR0aDtcblx0ICAgIGhlaWdodCA9IHRoaXMuX2Rlc2lyZWRfc2l6ZXNbMl0gfHwgbWF4SGVpZ2h0O1xuXHQgICAgYXNzZXJ0KHdpZHRoICYmIGhlaWdodCwgXCJBdHRlbXB0IHRvIHNob3cgbm90IHJlbmRlcmVkIHdpbmRvd1wiKTtcblx0ICAgIHBvc2l0aW9uID0gdGhpcy5fc2V0dGluZ3MucG9zaXRpb247XG5cblx0ICAgIGlmIChwb3NpdGlvbiA9PSBcInRvcFwiKSB7XG5cdCAgICAgIHdpZHRoID0gbWF4V2lkdGg7XG5cdCAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09IFwicmlnaHRcIikge1xuXHQgICAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdCAgICAgIGxlZnQgPSBtYXhXaWR0aCAtIHdpZHRoO1xuXHQgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PSBcImJvdHRvbVwiKSB7XG5cdCAgICAgIHdpZHRoID0gbWF4V2lkdGg7XG5cdCAgICAgIHRvcCA9IG1heEhlaWdodCAtIGhlaWdodDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUkJDEgPSB7XG5cdCAgICAgIGxlZnQ6IGxlZnQsXG5cdCAgICAgIHRvcDogdG9wLFxuXHQgICAgICB3aWR0aDogd2lkdGgsXG5cdCAgICAgIGhlaWdodDogaGVpZ2h0LFxuXHQgICAgICBtYXhXaWR0aDogbWF4V2lkdGgsXG5cdCAgICAgIG1heEhlaWdodDogbWF4SGVpZ2h0XG5cdCAgICB9O1xuXHQgICAgaWYgKHR5cGVvZiB0aGlzLl9zZXR0aW5ncy5zdGF0ZSA9PSBcImZ1bmN0aW9uXCIpIHRoaXMuX3NldHRpbmdzLnN0YXRlLmNhbGwodGhpcywgc3RhdGUkJDEpO1xuXHQgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZSQkMTtcblx0ICAgIHRoaXMuJHNldFNpemUoc3RhdGUkJDEud2lkdGgsIHN0YXRlJCQxLmhlaWdodCk7XG5cblx0ICAgIGlmICh0eXBlb2YgeCA9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMuX2lzQW5pbWF0aW9uU3VwcG9ydGVkKCkpIHtcblx0ICAgICAgcmVtb3ZlQ3NzKHRoaXMuJHZpZXcsIFwid2ViaXhfYW5pbWF0ZVwiLCB0cnVlKTsgLy8gc2V0IGluaXRpYWwgc3RhdGVcblxuXHQgICAgICB0aGlzLl9hbmltYXRlW3RoaXMuX3NldHRpbmdzLnBvc2l0aW9uXS5iZWZvcmVTaG93LmNhbGwodGhpcywgc3RhdGUkJDEpOyAvLyBzZXQgYXBwbHkgYW5pbWF0aW9uIGNzc1xuXG5cblx0ICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGFkZENzcyh0aGlzLiR2aWV3LCBcIndlYml4X2FuaW1hdGVcIiwgdHJ1ZSk7XG5cdCAgICAgIH0sIHRoaXMsIG51bGwsIDEpOyAvLyBhbmltYXRlIHBvcHVwXG5cblx0ICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2FuaW1hdGVbdGhpcy5fc2V0dGluZ3MucG9zaXRpb25dLnNob3cuY2FsbCh0aGlzLCBzdGF0ZSQkMSk7XG5cdCAgICAgIH0sIHRoaXMsIG51bGwsIDEwKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5wb3NpdGlvbiA9PT0gXCJyaWdodFwiKSBzdGF0ZSQkMS5sZWZ0ID0gc3RhdGUkJDEucmlnaHQgPyBtYXhXaWR0aCAtIHN0YXRlJCQxLndpZHRoIC0gc3RhdGUkJDEucmlnaHQgOiBtYXhXaWR0aCAtIHN0YXRlJCQxLndpZHRoO1xuXHQgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXRlJCQxLmxlZnQsIHN0YXRlJCQxLnRvcCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaXNBbmltYXRpb25TdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBhbmltYXRlLmlzU3VwcG9ydGVkKCkgJiYgdGhpcy5fc2V0dGluZ3MuYW5pbWF0ZSAmJiAhKGVudi5pc0lFICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJNU0lFIDlcIikgIT0gLTEpO1xuXHQgIH0sXG5cdCAgaGlkZGVuX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuaGlkZSh0cnVlKTtlbHNlIHRoaXMuc2hvdygpO1xuXHQgICAgcmV0dXJuICEhdmFsdWU7XG5cdCAgfSxcblx0ICBfYW5pbWF0ZToge1xuXHQgICAgbGVmdDoge1xuXHQgICAgICBiZWZvcmVTaG93OiBmdW5jdGlvbiAoc3RhdGUkJDEpIHtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLmxlZnQgPSAtc3RhdGUkJDEud2lkdGggKyBcInB4XCI7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS50b3AgPSBzdGF0ZSQkMS50b3AgKyBcInB4XCI7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNob3c6IGZ1bmN0aW9uIChzdGF0ZSQkMSkge1xuXHQgICAgICAgIHRoaXMuJHZpZXcuc3R5bGUubGVmdCA9IHN0YXRlJCQxLmxlZnQgPyBzdGF0ZSQkMS5sZWZ0ICsgXCJweFwiIDogXCIwcHhcIjtcblx0ICAgICAgfSxcblx0ICAgICAgaGlkZTogZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5sZWZ0ID0gLXN0YXRlJCQxLndpZHRoICsgXCJweFwiO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgcmlnaHQ6IHtcblx0ICAgICAgYmVmb3JlU2hvdzogZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5sZWZ0ID0gXCJhdXRvXCI7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5yaWdodCA9IC1zdGF0ZSQkMS53aWR0aCArIFwicHhcIjtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLnRvcCA9IHN0YXRlJCQxLnRvcCArIFwicHhcIjtcblx0ICAgICAgfSxcblx0ICAgICAgc2hvdzogZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5yaWdodCA9IHN0YXRlJCQxLnJpZ2h0ID8gc3RhdGUkJDEucmlnaHQgKyBcInB4XCIgOiBcIjBweFwiO1xuXHQgICAgICB9LFxuXHQgICAgICBoaWRlOiBmdW5jdGlvbiAoc3RhdGUkJDEpIHtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLnJpZ2h0ID0gLXN0YXRlJCQxLndpZHRoICsgXCJweFwiO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgdG9wOiB7XG5cdCAgICAgIGJlZm9yZVNob3c6IGZ1bmN0aW9uIChzdGF0ZSQkMSkge1xuXHQgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RhdGUkJDEubGVmdCwgc3RhdGUkJDEudG9wKTtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XG5cdCAgICAgICAgdGhpcy5fYm9keW9iai5zdHlsZS5oZWlnaHQgPSBcIjBweFwiO1xuXHQgICAgICB9LFxuXHQgICAgICBzaG93OiBmdW5jdGlvbiAoc3RhdGUkJDEpIHtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLmhlaWdodCA9IHN0YXRlJCQxLmhlaWdodCArIFwicHhcIjtcblx0ICAgICAgICB0aGlzLl9ib2R5b2JqLnN0eWxlLmhlaWdodCA9IHN0YXRlJCQxLmhlaWdodCArIFwicHhcIjtcblx0ICAgICAgfSxcblx0ICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuJHZpZXcuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcblx0ICAgICAgICB0aGlzLl9ib2R5b2JqLnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBib3R0b206IHtcblx0ICAgICAgYmVmb3JlU2hvdzogZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5sZWZ0ID0gc3RhdGUkJDEubGVmdCArIFwicHhcIjtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuXHQgICAgICAgIHZhciBib3R0b20gPSBzdGF0ZSQkMS5ib3R0b20gIT0gdW5kZWZpbmVkID8gc3RhdGUkJDEuYm90dG9tIDogc3RhdGUkJDEubWF4SGVpZ2h0IC0gc3RhdGUkJDEudG9wIC0gc3RhdGUkJDEuaGVpZ2h0O1xuXHQgICAgICAgIHRoaXMuJHZpZXcuc3R5bGUuYm90dG9tID0gYm90dG9tICsgXCJweFwiO1xuXHQgICAgICAgIHRoaXMuJHZpZXcuc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcblx0ICAgICAgfSxcblx0ICAgICAgc2hvdzogZnVuY3Rpb24gKHN0YXRlJCQxKSB7XG5cdCAgICAgICAgdGhpcy4kdmlldy5zdHlsZS5oZWlnaHQgPSBzdGF0ZSQkMS5oZWlnaHQgKyBcInB4XCI7XG5cdCAgICAgIH0sXG5cdCAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLiR2aWV3LnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIGhpZGU6IGZ1bmN0aW9uIChmb3JjZSkge1xuXHQgICAgaWYgKHRoaXMuJGRlc3RydWN0ZWQpIHJldHVybjtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tb2RhbCkgdGhpcy5fbW9kYWxfc2V0KGZhbHNlKTtcblx0ICAgIHZhciBtYXhXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcblx0ICAgIHZhciBtYXhIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG5cdCAgICBpZiAoIWZvcmNlICYmIHRoaXMuX2lzQW5pbWF0aW9uU3VwcG9ydGVkKCkgJiYgbWF4V2lkdGggPT0gdGhpcy5fc3RhdGUubWF4V2lkdGggJiYgbWF4SGVpZ2h0ID09IHRoaXMuX3N0YXRlLm1heEhlaWdodCkge1xuXHQgICAgICAvLyBjYWxsICdoaWRlJyBhbmltYXRpb24gaGFuZGxlclxuXHQgICAgICB0aGlzLl9hbmltYXRlW3RoaXMuX3NldHRpbmdzLnBvc2l0aW9uXS5oaWRlLmNhbGwodGhpcywgdGhpcy5fc3RhdGUpOyAvLyBoaWRlIHBvcHVwXG5cblxuXHQgICAgICB2YXIgdGlkID0gZXZlbnQkMSh0aGlzLiR2aWV3LCBlbnYudHJhbnNpdGlvbkVuZCwgYmluZChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5faGlkZV9jYWxsYmFjaygpO1xuXG5cdCAgICAgICAgZXZlbnRSZW1vdmUodGlkKTtcblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5faGlkZV9jYWxsYmFjaygpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b2ZvY3VzKSB7XG5cdCAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cblx0ICAgICAgaWYgKGVsICYmIHRoaXMuX3ZpZXdvYmogJiYgdGhpcy5fdmlld29iai5jb250YWlucyhlbCkpIHtcblx0ICAgICAgICBVSU1hbmFnZXIuc2V0Rm9jdXModGhpcy5fcHJldl9mb2N1cyk7XG5cdCAgICAgICAgdGhpcy5fcHJldl9mb2N1cyA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5faGlkZV9zdWJfcG9wdXBzKCk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQxOCA9IGV4cG9ydHMucHJvdG9VSShhcGkkMTgsIHBvcHVwLnZpZXcpO1xuXG5cdHZhciBhcGkkMTkgPSB7XG5cdCAgbmFtZTogXCJzaWRlYmFyXCIsXG5cdCAgZGVmYXVsdHM6IHtcblx0ICAgIHR5cGU6IFwic2lkZUJhclwiLFxuXHQgICAgYWN0aXZlVGl0bGU6IHRydWUsXG5cdCAgICBzZWxlY3Q6IHRydWUsXG5cdCAgICBzY3JvbGw6IGZhbHNlLFxuXHQgICAgY29sbGFwc2VkOiBmYWxzZSxcblx0ICAgIGNvbGxhcHNlZFdpZHRoOiA0NCxcblx0ICAgIHBvc2l0aW9uOiBcImxlZnRcIixcblx0ICAgIHdpZHRoOiAyNTAsXG5cdCAgICBtb3VzZUV2ZW50RGVsYXk6IDEwXG5cdCAgfSxcblx0ICAkc2tpbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5kZWZhdWx0cy50aXRsZUhlaWdodCA9ICRhY3RpdmUuc2lkZWJhclRpdGxlSGVpZ2h0O1xuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuJHJlYWR5LnB1c2godGhpcy5faW5pdFNpZGViYXIpO1xuXHQgICAgdGhpcy4kcmVhZHkucHVzaCh0aGlzLl9pbml0Q29udGV4dE1lbnUpO1xuXG5cdCAgICB0aGlzLmRhdGEuX3NjaGVtZV9pbml0ID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICBpZiAob2JqLmRhdGEpIG9iai5tZW51ID0gY29weShvYmouZGF0YSk7ZWxzZSBpZiAob2JqLml0ZW0pIC8veG1sIGNoaWxkIHJlY29yZHMsIGNhbiBiZSB7fSBvciBbXVxuXHQgICAgICAgIG9iai5tZW51ID0gY29weShvYmouaXRlbS5sZW5ndGggPyBvYmouaXRlbSA6IFtvYmouaXRlbV0pO1xuXHQgICAgfTtcblx0ICB9LFxuXHQgIG9uX2NvbnRleHQ6IHt9LFxuXHQgIG9uX21vdXNlX21vdmU6IHt9LFxuXHQgIF9pbml0U2lkZWJhcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fZnVsbFdpZHRoID0gdGhpcy5jb25maWcud2lkdGg7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVPcGVuXCIsIGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBpZiAoIXRoaXMuY29uZmlnLm11bHRpcGxlT3Blbikge1xuXHQgICAgICAgIHZhciBvcGVuID0gdGhpcy5nZXRPcGVuSXRlbXMoKTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3Blbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50SWQoaWQpID09IHRoaXMuZ2V0UGFyZW50SWQob3BlbltpXSkpIHRoaXMuY2xvc2Uob3BlbltpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuICF0aGlzLmNvbmZpZy5jb2xsYXBzZWQ7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkl0ZW1DbGlja1wiLCBmdW5jdGlvbiAoaWQsIGV2LCBub2RlKSB7XG5cdCAgICAgIGlmICh0aGlzLmdldFBvcHVwKCkgJiYgIXRoaXMuZ2V0UG9wdXAoKS5jb25maWcuaGlkZGVuKSBldi5zaG93cG9wdXAgPSB0cnVlO1xuXHQgICAgICBpZiAoZW52LnRvdWNoKSB0aGlzLl9zaG93UG9wdXAoaWQsIG5vZGUpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVTZWxlY3RcIiwgZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgIGlmICghdGhpcy5nZXRJdGVtKGlkKS4kY291bnQpIHtcblx0ICAgICAgICB0aGlzLmNsZWFyQ3NzKFwid2ViaXhfc2lkZWJhcl9zZWxlY3RlZFwiKTtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJTZWxlY3RcIiwgZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgIHRoaXMuX21hcmtNZW51KHRoaXMsIGlkLCAhJGFjdGl2ZS5zaWRlYmFyTWFya0FsbCk7XG5cblx0ICAgICAgdGhpcy5nZXRQb3B1cCgpLl9vbk1hc3RlclNlbGVjdChpZCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbk1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoaWQsIGV2LCBub2RlKSB7XG5cdCAgICAgIHRoaXMuX3Nob3dQb3B1cChpZCwgbm9kZSk7XG5cdCAgICB9KTtcblx0ICAgIGlmICh0aGlzLmNvbmZpZy5jb2xsYXBzZWQpIHRoaXMuY29sbGFwc2UoKTtcblx0ICB9LFxuXHQgIF9zaG93UG9wdXA6IGZ1bmN0aW9uIChpZCwgbm9kZSkge1xuXHQgICAgaWYgKHRoaXMuY29uZmlnLmNvbGxhcHNlZCkge1xuXHQgICAgICB2YXIgcG9wdXAgPSB0aGlzLmdldFBvcHVwKCk7XG5cblx0ICAgICAgaWYgKHBvcHVwKSB7XG5cdCAgICAgICAgdGhpcy5fdXBkYXRlVGl0bGUoaWQpO1xuXG5cdCAgICAgICAgdGhpcy5fdXBkYXRlTGlzdChpZCk7XG5cblx0ICAgICAgICBwb3B1cC5zaG93KG5vZGUsIHtcblx0ICAgICAgICAgIHg6IHRoaXMuY29uZmlnLnBvc2l0aW9uID09IFwibGVmdFwiID8gdGhpcy5jb25maWcuY29sbGFwc2VkV2lkdGggOiAtcG9wdXAuY29uZmlnLndpZHRoLFxuXHQgICAgICAgICAgeTogLTFcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3VwZGF0ZVRpdGxlOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBwb3B1cCA9IHRoaXMuZ2V0UG9wdXAoKTtcblx0ICAgIHZhciB0aXRsZSA9IHBvcHVwLmdldEJvZHkoKS5nZXRDaGlsZFZpZXdzKClbMF07XG5cdCAgICBpZiAoIXRpdGxlIHx8IHRpdGxlLm1hc3RlcklkID09IGlkKSByZXR1cm47XG5cdCAgICB2YXIgc2VsZWN0ZWRJZCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCgpO1xuXHQgICAgdGl0bGUubWFzdGVySWQgPSBpZDtcblx0ICAgIHRpdGxlLnBhcnNlKHRoaXMuZ2V0SXRlbShpZCkpO1xuXG5cdCAgICBpZiAoc2VsZWN0ZWRJZCAmJiB0aGlzLmdldFBhcmVudElkKHNlbGVjdGVkSWQpID09IGlkKSB7XG5cdCAgICAgIGFkZENzcyh0aXRsZS4kdmlldywgXCJ3ZWJpeF9zaWRlYmFyX3NlbGVjdGVkXCIsIHRydWUpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVtb3ZlQ3NzKHRpdGxlLiR2aWV3LCBcIndlYml4X3NpZGViYXJfc2VsZWN0ZWRcIik7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzZWxlY3RlZElkID09IGlkKSB7XG5cdCAgICAgIGFkZENzcyh0aXRsZS4kdmlldywgXCJ3ZWJpeF9zZWxlY3RlZFwiLCB0cnVlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlbW92ZUNzcyh0aXRsZS4kdmlldywgXCJ3ZWJpeF9zZWxlY3RlZFwiKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF91cGRhdGVMaXN0OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBwb3B1cCA9IHRoaXMuZ2V0UG9wdXAoKTtcblx0ICAgIHZhciBsaXN0ID0gcG9wdXAuZ2V0Qm9keSgpLmdldENoaWxkVmlld3MoKVsxXTtcblx0ICAgIGlmICghbGlzdCB8fCBsaXN0Lm1hc3RlcklkID09IGlkKSByZXR1cm47XG5cdCAgICBpZiAodGhpcy5leGlzdHMobGlzdC5tYXN0ZXJJZCkgJiYgdGhpcy5nZXRJdGVtKGxpc3QubWFzdGVySWQpLm1lbnUpIHRoaXMudXBkYXRlSXRlbShsaXN0Lm1hc3RlcklkLCB7XG5cdCAgICAgIG1lbnU6IGxpc3QuZGF0YS5zZXJpYWxpemUoKVxuXHQgICAgfSk7XG5cdCAgICBsaXN0LmNsZWFyQ3NzKFwid2ViaXhfc2lkZWJhcl9zZWxlY3RlZFwiKTtcblx0ICAgIGxpc3QubWFzdGVySWQgPSBpZDtcblx0ICAgIHZhciBzZWxlY3RlZElkID0gdGhpcy5nZXRTZWxlY3RlZElkKCk7XG5cdCAgICB2YXIgZGF0YSA9IGNvcHkodGhpcy5nZXRJdGVtKGlkKS5tZW51IHx8IFtdKTtcblx0ICAgIGxpc3QudW5zZWxlY3QoKTtcblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgIGxpc3Quc2hvdygpO1xuXHQgICAgICBsaXN0LmRhdGEuaW1wb3J0RGF0YShkYXRhKTtcblx0ICAgICAgaWYgKGxpc3QuZXhpc3RzKHNlbGVjdGVkSWQpKSBsaXN0LnNlbGVjdChzZWxlY3RlZElkKTtlbHNlIGlmIChzZWxlY3RlZElkKSB0aGlzLl9tYXJrTWVudShsaXN0LCBzZWxlY3RlZElkKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxpc3QuaGlkZSgpO1xuXHQgICAgICBsaXN0LmRhdGEuY2xlYXJBbGwoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9pbml0Q29udGV4dE1lbnU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBtYXN0ZXIgPSB0aGlzLFxuXHQgICAgICAgIGNvbmZpZyA9IG1hc3Rlci5jb25maWcsXG5cdCAgICAgICAgcG9wdXA7XG5cblx0ICAgIGlmIChjb25maWcucG9wdXApIHtcblx0ICAgICAgcG9wdXAgPSAkJChjb25maWcucG9wdXApO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXBvcHVwKSB7XG5cdCAgICAgIHZhciBkaXJDbGFzc05hbWUgPSBjb25maWcucG9zaXRpb24gPT0gXCJsZWZ0XCIgPyBcIndlYml4X3NpZGViYXJfcG9wdXBfbGVmdFwiIDogXCJ3ZWJpeF9zaWRlYmFyX3BvcHVwX3JpZ2h0XCI7XG5cdCAgICAgIHZhciBzdWJNZW51UG9zID0gY29uZmlnLnBvc2l0aW9uID09IFwibGVmdFwiID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG5cblx0ICAgICAgdmFyIG1lbnVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICB2YXIgaWNvbiA9IFwid3hpLWFuZ2xlLVwiICsgKGNvbmZpZy5wb3NpdGlvbiA9PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblx0ICAgICAgICB2YXIgYXJyb3cgPSBvYmouc3VibWVudSB8fCBvYmouZGF0YSB8fCBvYmouaXRlbSA/IFwiPGRpdiBjbGFzcz1cXFwid2ViaXhfaWNvbiBcIiArIGljb24gKyBcIlxcXCI+PC9kaXY+XCIgOiBcIlwiO1xuXHQgICAgICAgIHJldHVybiBhcnJvdyArIG9iai52YWx1ZTtcblx0ICAgICAgfTtcblxuXHQgICAgICB2YXIgcG9wdXBDb25maWcgPSB7XG5cdCAgICAgICAgdmlldzogXCJwb3B1cFwiLFxuXHQgICAgICAgIGNzczogXCJ3ZWJpeF9zaWRlYmFyX3BvcHVwIFwiICsgZGlyQ2xhc3NOYW1lICsgXCIgXCIgKyBjb25maWcuY3NzLFxuXHQgICAgICAgIGF1dG9maXQ6IGZhbHNlLFxuXHQgICAgICAgIHdpZHRoOiB0aGlzLl9mdWxsV2lkdGggLSB0aGlzLmNvbmZpZy5jb2xsYXBzZWRXaWR0aCxcblx0ICAgICAgICBib3JkZXJsZXNzOiB0cnVlLFxuXHQgICAgICAgIHBhZGRpbmc6IDAsXG5cdCAgICAgICAgYm9keToge1xuXHQgICAgICAgICAgcm93czogW3tcblx0ICAgICAgICAgICAgdmlldzogXCJ0ZW1wbGF0ZVwiLFxuXHQgICAgICAgICAgICBib3JkZXJsZXNzOiB0cnVlLFxuXHQgICAgICAgICAgICBjc3M6IFwid2ViaXhfc2lkZWJhcl9wb3B1cF90aXRsZVwiLFxuXHQgICAgICAgICAgICB0ZW1wbGF0ZTogXCIjdmFsdWUjXCIsXG5cdCAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb25maWcudGl0bGVIZWlnaHQgKyAyLFxuXHQgICAgICAgICAgICBvbkNsaWNrOiB7XG5cdCAgICAgICAgICAgICAgd2ViaXhfdGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMubWFzdGVySWQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hc3Rlci5nZXRJdGVtKGlkKS4kY291bnQpIG1hc3Rlci5zZWxlY3QoaWQpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICB2aWV3OiBcIm1lbnVcIixcblx0ICAgICAgICAgICAgc3VibWVudTogXCJkYXRhXCIsXG5cdCAgICAgICAgICAgIGxheW91dDogXCJ5XCIsXG5cdCAgICAgICAgICAgIHN1Yk1lbnVQb3M6IHN1Yk1lbnVQb3MsXG5cdCAgICAgICAgICAgIHNlbGVjdDogdHJ1ZSxcblx0ICAgICAgICAgICAgYm9yZGVybGVzczogdHJ1ZSxcblx0ICAgICAgICAgICAgYXV0b2hlaWdodDogdHJ1ZSxcblx0ICAgICAgICAgICAgY3NzOiBcIndlYml4X3NpZGViYXJfcG9wdXBfbGlzdCBcIiArIGRpckNsYXNzTmFtZSArIFwiIFwiICsgY29uZmlnLmNzcyxcblx0ICAgICAgICAgICAgdGVtcGxhdGU6IG1lbnVUZW1wbGF0ZSxcblx0ICAgICAgICAgICAgdHlwZToge1xuXHQgICAgICAgICAgICAgIHN1YnNpZ246IGZhbHNlXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHN1Ym1lbnVDb25maWc6IHtcblx0ICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuXHQgICAgICAgICAgICAgIHN1Yk1lbnVQb3M6IHN1Yk1lbnVQb3MsXG5cdCAgICAgICAgICAgICAgdGVtcGxhdGU6IG1lbnVUZW1wbGF0ZSxcblx0ICAgICAgICAgICAgICBzZWxlY3Q6IHRydWUsXG5cdCAgICAgICAgICAgICAgdHlwZToge1xuXHQgICAgICAgICAgICAgICAgc3Vic2lnbjogZmFsc2Vcblx0ICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgIGNzczogXCJ3ZWJpeF9zaWRlYmFyX3BvcHVwX2xpc3QgXCIgKyBkaXJDbGFzc05hbWUgKyBcIiBcIiArIGNvbmZpZy5jc3MsXG5cdCAgICAgICAgICAgICAgb246IHtcblx0ICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ3NzKFwid2ViaXhfc2lkZWJhcl9zZWxlY3RlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuXHQgICAgICAgICAgICAgICAgICB2YXIgc2VsID0gbWFzdGVyLmdldFNlbGVjdGVkSWQoKTtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHNlbCAmJiB0aGlzLmV4aXN0cyhzZWwpKSB0aGlzLnNlbGVjdChzZWwpO2Vsc2UgaWYgKHNlbCkgbWFzdGVyLl9tYXJrTWVudSh0aGlzLCBzZWwpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIG9uQmVmb3JlU2VsZWN0OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U3ViTWVudShpZCkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBvbkFmdGVyU2VsZWN0OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgdmFyIG1lbnUgPSBtYXN0ZXIuZ2V0UG9wdXAoKS5xdWVyeVZpZXcoe1xuXHQgICAgICAgICAgICAgICAgICAgIHZpZXc6IFwibWVudVwiXG5cdCAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbWFzdGVyLmdldFBhcmVudElkKGlkKTtcblxuXHQgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN1YiA9IG1lbnUuZ2V0TWVudShwYXJlbnQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc2VsZWN0QWxsKCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgIG1hc3Rlci5fbWFya01lbnUoc3ViLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbWFzdGVyLmdldFBhcmVudElkKHBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICBtYXN0ZXIuX21hcmtNZW51KHRoaXMsIGlkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIG9uOiB7XG5cdCAgICAgICAgICAgICAgb25CZWZvcmVTZWxlY3Q6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0U3ViTWVudShpZCkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgIG9uTWVudUl0ZW1DbGljazogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0U3ViTWVudShpZCkpIG1hc3Rlci5zZWxlY3QoaWQpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfV1cblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHBvcHVwQ29uZmlnLCBjb25maWcucG9wdXAgfHwge30sIHRydWUpO1xuXHQgICAgICBwb3B1cCA9IHVpKHBvcHVwQ29uZmlnKTtcblxuXHQgICAgICBwb3B1cC5fb25NYXN0ZXJTZWxlY3QgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5nZXRQYXJlbnRJZChpZCkgPT0gdGhpcy5tYXN0ZXJJZCkge1xuXHQgICAgICAgICAgYWRkQ3NzKHRoaXMuJHZpZXcsIFwid2ViaXhfc2lkZWJhcl9zZWxlY3RlZFwiLCB0cnVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAobWFzdGVyLmNvbmZpZy5jb2xsYXBzZWQgJiYgbWFzdGVyLmdldEl0ZW0oaWQpLiRsZXZlbCA9PSAxKSB7XG5cdCAgICAgICAgICB2YXIgdGl0bGUgPSBwb3B1cC5nZXRCb2R5KCkuZ2V0Q2hpbGRWaWV3cygpWzBdO1xuXHQgICAgICAgICAgaWYgKHRpdGxlKSBhZGRDc3ModGl0bGUuJHZpZXcsIFwid2ViaXhfc2VsZWN0ZWRcIiwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXG5cdCAgICAgIHBvcHVwLnF1ZXJ5Vmlldyh7XG5cdCAgICAgICAgdmlldzogXCJtZW51XCJcblx0ICAgICAgfSkuX3Nob3dfY2hpbGRfb25fY2xpY2sgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBwb3B1cC5hdHRhY2hFdmVudChcIm9uQmVmb3JlU2hvd1wiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBjb25maWcuY29sbGFwc2VkO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9kZXN0cm95X3dpdGhfbWUgPSBbcG9wdXBdO1xuXHQgICAgY29uZmlnLnBvcHVwSWQgPSBwb3B1cC5jb25maWcuaWQ7XG5cblx0ICAgIF9ldmVudChkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICB2YXIgdHJnID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdCAgICAgIGlmICghcG9wdXAuY29uZmlnLmhpZGRlbiAmJiAhcG9wdXAuJHZpZXcuY29udGFpbnModHJnKSAmJiAhdGhpcy4kdmlldy5maXJzdENoaWxkLmNvbnRhaW5zKHRyZykgJiYgIXBvcHVwLnF1ZXJ5Vmlldyh7XG5cdCAgICAgICAgdmlldzogXCJtZW51XCJcblx0ICAgICAgfSkuX29wZW5fc3ViX21lbnUpIHtcblx0ICAgICAgICBwb3B1cC5oaWRlKCk7XG5cdCAgICAgIH1cblx0ICAgIH0sIHtcblx0ICAgICAgYmluZDogdGhpc1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBfbWFya01lbnU6IGZ1bmN0aW9uICh2aWV3LCBzZWwsIHRvcE9ubHkpIHtcblx0ICAgIHZhciBjc3MgPSBcIndlYml4X3NpZGViYXJfc2VsZWN0ZWRcIjtcblx0ICAgIHZpZXcuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgaWYgKHRoaXMuX2lzQ2hpbGQoc2VsLCBvYmouaWQpICYmICghdG9wT25seSB8fCB0aGlzLmdldFBhcmVudElkKG9iai5pZCkgPT0gXCIwXCIpKSB2aWV3LmFkZENzcyhvYmouaWQsIGNzcyk7ZWxzZSBpZiAodmlldy5oYXNDc3Mob2JqLmlkLCBjc3MpKSB2aWV3LnJlbW92ZUNzcyhvYmouaWQsIGNzcyk7XG5cdCAgICB9LCB0aGlzKTtcblx0ICB9LFxuXHQgIF9pc0NoaWxkOiBmdW5jdGlvbiAoY2lkLCBwaWQpIHtcblx0ICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudElkKGNpZCk7XG5cdCAgICBpZiAocGlkID09IHBhcmVudCkgcmV0dXJuIHRydWU7XG5cdCAgICBpZiAocGFyZW50KSByZXR1cm4gdGhpcy5faXNDaGlsZChwYXJlbnQsIHBpZCk7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuICQkKHRoaXMuY29uZmlnLnBvcHVwSWQpO1xuXHQgIH0sXG5cdCAgcG9zaXRpb25fc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciBuZXdQb3MgPSB2YWx1ZTtcblx0ICAgIHZhciBvbGRQb3MgPSB2YWx1ZSA9PSBcImxlZnRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuXHQgICAgcmVtb3ZlQ3NzKHRoaXMuJHZpZXcsIFwid2ViaXhfc2lkZWJhcl9cIiArIG9sZFBvcyk7XG5cdCAgICBhZGRDc3ModGhpcy4kdmlldywgXCJ3ZWJpeF9zaWRlYmFyX1wiICsgbmV3UG9zLCB0cnVlKTtcblx0ICAgIHZhciBwb3B1cCA9IHRoaXMuZ2V0UG9wdXAoKTtcblxuXHQgICAgaWYgKHBvcHVwKSB7XG5cdCAgICAgIHZhciBwb3B1cEVsID0gcG9wdXAuJHZpZXc7XG5cdCAgICAgIHJlbW92ZUNzcyhwb3B1cEVsLCBcIndlYml4X3NpZGViYXJfcG9wdXBfXCIgKyBvbGRQb3MpO1xuXHQgICAgICBhZGRDc3MocG9wdXBFbCwgXCJ3ZWJpeF9zaWRlYmFyX3BvcHVwX1wiICsgbmV3UG9zLCB0cnVlKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgY29sbGFwc2U6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuZGVmaW5lKFwiY29sbGFwc2VkXCIsIHRydWUpO1xuXHQgIH0sXG5cdCAgZXhwYW5kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmluZShcImNvbGxhcHNlZFwiLCBmYWxzZSk7XG5cdCAgfSxcblx0ICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBjb2xsYXBzZWQgPSAhdGhpcy5jb25maWcuY29sbGFwc2VkO1xuXHQgICAgdGhpcy5kZWZpbmUoXCJjb2xsYXBzZWRcIiwgY29sbGFwc2VkKTtcblx0ICB9LFxuXHQgIGNvbGxhcHNlZF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHdpZHRoO1xuXG5cdCAgICBpZiAoIXZhbHVlKSB7XG5cdCAgICAgIHdpZHRoID0gdGhpcy5fZnVsbFdpZHRoO1xuXHQgICAgICB0aGlzLnR5cGUuY29sbGFwc2VkID0gZmFsc2U7XG5cdCAgICAgIGFkZENzcyh0aGlzLiR2aWV3LCBcIndlYml4X3NpZGViYXJfZXhwYW5kZWRcIiwgdHJ1ZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3aWR0aCA9IHRoaXMuY29uZmlnLmNvbGxhcHNlZFdpZHRoO1xuXHQgICAgICB0aGlzLmNsb3NlQWxsKCk7XG5cdCAgICAgIHRoaXMudHlwZS5jb2xsYXBzZWQgPSB0cnVlO1xuXHQgICAgICByZW1vdmVDc3ModGhpcy4kdmlldywgXCJ3ZWJpeF9zaWRlYmFyX2V4cGFuZGVkXCIpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmRlZmluZShcIndpZHRoXCIsIHdpZHRoKTtcblx0ICAgIHRoaXMucmVzaXplKCk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHN0YXRlID0ge1xuXHQgICAgICBjb2xsYXBzZWQ6IHRoaXMuY29uZmlnLmNvbGxhcHNlZFxuXHQgICAgfTtcblx0ICAgIGV4cG9ydHMuZXh0ZW5kKHN0YXRlLCBUcmVlQVBJLmdldFN0YXRlLmNhbGwodGhpcykpO1xuXHQgICAgcmV0dXJuIHN0YXRlO1xuXHQgIH0sXG5cdCAgc2V0U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgVHJlZUFQSS5zZXRTdGF0ZS5jYWxsKHRoaXMsIHN0YXRlKTtcblx0ICAgIHRoaXMuZGVmaW5lKFwiY29sbGFwc2VkXCIsIHN0YXRlLmNvbGxhcHNlZCk7XG5cdCAgfVxuXHR9O1xuXHR0eXBlKHRyZWUudmlldywge1xuXHQgIG5hbWU6IFwic2lkZUJhclwiLFxuXHQgIGhlaWdodDogXCJhdXRvXCIsXG5cdCAgY3NzOiBcIndlYml4X3NpZGViYXJcIixcblx0ICB0ZW1wbGF0ZTogZnVuY3Rpb24gKG9iaiwgY29tbW9uKSB7XG5cdCAgICBpZiAoY29tbW9uLmNvbGxhcHNlZCkgcmV0dXJuIGNvbW1vbi5pY29uKG9iaiwgY29tbW9uKTtcblx0ICAgIHJldHVybiBjb21tb24uYXJyb3cob2JqLCBjb21tb24pICsgY29tbW9uLmljb24ob2JqLCBjb21tb24pICsgXCI8c3Bhbj5cIiArIG9iai52YWx1ZSArIFwiPC9zcGFuPlwiO1xuXHQgIH0sXG5cdCAgYXJyb3c6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHZhciBodG1sID0gXCJcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gb2JqLiRsZXZlbDsgaSsrKSB7XG5cdCAgICAgIGlmIChpID09IG9iai4kbGV2ZWwgJiYgb2JqLiRjb3VudCkge1xuXHQgICAgICAgIHZhciBpY29uID0gXCJ3eGktYW5nbGUtXCIgKyAob2JqLm9wZW4gPyBcImRvd25cIiA6IFwibGVmdFwiKTtcblx0ICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJ3ZWJpeF9zaWRlYmFyX2Rpcl9pY29uIHdlYml4X2ljb24gXCIgKyBpY29uO1xuXHQgICAgICAgIGh0bWwgKz0gXCI8c3BhbiBjbGFzcz0nXCIgKyBjbGFzc05hbWUgKyBcIic+PC9zcGFuPlwiO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBodG1sO1xuXHQgIH0sXG5cdCAgaWNvbjogZnVuY3Rpb24gKG9iaikge1xuXHQgICAgdmFyIHN0eWxlID0gXCJcIjtcblxuXHQgICAgaWYgKG9iai4kbGV2ZWwgPiAyKSB7XG5cdCAgICAgIHN0eWxlID0gXCJzdHlsZT1cXFwicGFkZGluZy1sZWZ0OlwiICsgNDAgKiAob2JqLiRsZXZlbCAtIDIpICsgXCJweFxcXCJcIjtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9iai5pY29uKSByZXR1cm4gXCI8c3BhbiBjbGFzcz0nd2ViaXhfaWNvbiB3ZWJpeF9zaWRlYmFyX2ljb24gXCIgKyBvYmouaWNvbiArIFwiJyBcIiArIHN0eWxlICsgXCI+PC9zcGFuPlwiO1xuXHQgICAgcmV0dXJuIFwiPHNwYW4gXCIgKyBzdHlsZSArIFwiPjwvc3Bhbj5cIjtcblx0ICB9XG5cdH0pO1xuXHR2YXIgdmlldyQxOSA9IGV4cG9ydHMucHJvdG9VSShhcGkkMTksIHRyZWUudmlldyk7XG5cblx0dmFyIGFwaSQxYSA9IHtcblx0ICBuYW1lOiBcImNvbnRleHRcIlxuXHR9O1xuXHR2YXIgdmlldyQxYSA9IGV4cG9ydHMucHJvdG9VSShhcGkkMWEsIENvbnRleHRIZWxwZXIsIHBvcHVwLnZpZXcpO1xuXG5cdHZhciBhcGkkMWIgPSB7XG5cdCAgbmFtZTogXCJjb250ZXh0bWVudVwiLFxuXHQgIF9oaWRlX29uX2l0ZW1fY2xpY2s6IHRydWUsXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcuc3VibWVudUNvbmZpZykgZXhwb3J0cy5leHRlbmQoY29uZmlnLCBjb25maWcuc3VibWVudUNvbmZpZyk7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQxYiA9IGV4cG9ydHMucHJvdG9VSShhcGkkMWIsIENvbnRleHRIZWxwZXIsIHN1Ym1lbnUudmlldyk7XG5cblx0dmFyIGFwaSQxYyA9IHtcblx0ICBuYW1lOiBcInZzY3JvbGxcIixcblx0ICAkYXBpT25seTogdHJ1ZSxcblx0ICBkZWZhdWx0czoge1xuXHQgICAgc2Nyb2xsOiBcInhcIixcblx0ICAgIHNjcm9sbFN0ZXA6IDQwLFxuXHQgICAgc2Nyb2xsUG9zOiAwLFxuXHQgICAgc2Nyb2xsU2l6ZTogMTgsXG5cdCAgICBzY3JvbGxWaXNpYmxlOiAxLFxuXHQgICAgem9vbTogMVxuXHQgIH0sXG5cdCAgJGluaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIHZhciBkaXIgPSBjb25maWcuc2Nyb2xsIHx8IFwieFwiO1xuXHQgICAgdmFyIG5vZGUgPSB0aGlzLl92aWV3b2JqID0gdG9Ob2RlKGNvbmZpZy5jb250YWluZXIpO1xuXHQgICAgbm9kZS5jbGFzc05hbWUgKz0gXCIgd2ViaXhfdnNjcm9sbF9cIiArIGRpcjtcblx0ICAgIG5vZGUuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF92c2Nyb2xsX2JvZHknPjwvZGl2PlwiO1xuXG5cdCAgICBfZXZlbnQobm9kZSwgXCJzY3JvbGxcIiwgdGhpcy5fb25zY3JvbGwsIHtcblx0ICAgICAgYmluZDogdGhpc1xuXHQgICAgfSk7XG5cblx0ICAgIHRoaXMuX2xhc3Rfc2V0X3NpemUgPSAwO1xuXHQgIH0sXG5cdCAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuY29uZmlnLnNjcm9sbFBvcyA9IDA7XG5cdCAgICB0aGlzLl92aWV3b2JqW3RoaXMuY29uZmlnLnNjcm9sbCA9PSBcInhcIiA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSAwO1xuXHQgIH0sXG5cdCAgX2NoZWNrX3F1YW50dW06IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID4gMTUwMDAwMCkge1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy56b29tID0gdmFsdWUgLyAxMDAwMDAwO1xuXHQgICAgICB2YWx1ZSA9IDEwMDAwMDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy56b29tID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgc2Nyb2xsV2lkdGhfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhbHVlID0gdGhpcy5fY2hlY2tfcXVhbnR1bSh2YWx1ZSk7XG5cdCAgICB0aGlzLl92aWV3b2JqLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSB2YWx1ZSArIFwicHhcIjtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIHNjcm9sbEhlaWdodF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSB0aGlzLl9jaGVja19xdWFudHVtKHZhbHVlKTtcblx0ICAgIHRoaXMuX3ZpZXdvYmouZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSB2YWx1ZSArIFwicHhcIjtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIHNpemVUbzogZnVuY3Rpb24gKHZhbHVlLCB0b3AsIGJvdHRvbSkge1xuXHQgICAgdmFsdWUgPSB2YWx1ZSAtICh0b3AgfHwgMCkgLSAoYm90dG9tIHx8IDApO1xuXHQgICAgdmFyIHdpZHRoID0gdGhpcy5fc2V0dGluZ3Muc2Nyb2xsU2l6ZTsgLy9JRUZpeFxuXHQgICAgLy9JRSBkb2Vzbid0IHJlYWN0IG9uIHNjcm9sbC1jbGljayBpZiBpdCBoYXMgbm90IGF0IGxlYXN0IDEgcHggb2YgdmlzaWJsZSBjb250ZW50XG5cblx0ICAgIGlmIChlbnYuaXNJRSAmJiB3aWR0aCkgd2lkdGggKz0gMTtcblxuXHQgICAgaWYgKCF3aWR0aCAmJiB0aGlzLl9zZXR0aW5ncy5zY3JvbGxWaXNpYmxlICYmICFlbnYuJGN1c3RvbVNjcm9sbCkge1xuXHQgICAgICB0aGlzLl92aWV3b2JqLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcblx0ICAgICAgd2lkdGggPSAxNDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF3aWR0aCkge1xuXHQgICAgICB0aGlzLl92aWV3b2JqLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0ICAgICAgaWYgKHRvcCkgdGhpcy5fdmlld29iai5zdHlsZS5tYXJnaW5Ub3AgPSB0b3AgKyBcInB4XCI7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc3R5bGVbdGhpcy5fc2V0dGluZ3Muc2Nyb2xsID09IFwieFwiID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBNYXRoLm1heCgwLCB2YWx1ZSkgKyBcInB4XCI7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc3R5bGVbdGhpcy5fc2V0dGluZ3Muc2Nyb2xsID09IFwieFwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl0gPSB3aWR0aCArIFwicHhcIjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fbGFzdF9zZXRfc2l6ZSA9IHZhbHVlO1xuXHQgIH0sXG5cdCAgZ2V0U2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zZXR0aW5ncy5zY3JvbGxQb3MgKiB0aGlzLl9zZXR0aW5ncy56b29tKTtcblx0ICB9LFxuXHQgIGdldFNpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aGlzLl9zZXR0aW5ncy5zY3JvbGxXaWR0aCB8fCB0aGlzLl9zZXR0aW5ncy5zY3JvbGxIZWlnaHQpICogdGhpcy5fc2V0dGluZ3Muem9vbSk7XG5cdCAgfSxcblx0ICBzY3JvbGxUbzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDA7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICB2YWx1ZSA9IHZhbHVlIC8gY29uZmlnLnpvb207IC8vc2FmZXR5IGNoZWNrIGZvciBuZWdhdGl2ZSB2YWx1ZXNcblxuXHQgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAwOyAvL2FwcGx5IG5ldyBwb3NpdGlvblxuXG5cdCAgICBpZiAodmFsdWUgIT0gdGhpcy5fc2V0dGluZ3Muc2Nyb2xsUG9zKSB7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmpbY29uZmlnLnNjcm9sbCA9PSBcInhcIiA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSB2YWx1ZTtcblxuXHQgICAgICB0aGlzLl9vbnNjcm9sbF9pbm5lcih2YWx1ZSwgdHJ1ZSk7XG5cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25zY3JvbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB4ID0gdGhpcy5fdmlld29ialt0aGlzLl9zZXR0aW5ncy5zY3JvbGwgPT0gXCJ4XCIgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdO1xuXHQgICAgaWYgKE1hdGguZmxvb3IoeCkgIT0gTWF0aC5mbG9vcih0aGlzLl9zZXR0aW5ncy5zY3JvbGxQb3MpKSB0aGlzLl9vbnNjcm9sbF9pbm5lcih4LCBmYWxzZSk7XG5cdCAgfSxcblx0ICBfb25zY3JvbGxfaW5uZXI6IGZ1bmN0aW9uICh2YWx1ZSwgYXBpKSB7XG5cdCAgICAvL3NpemUgb2Ygc2Nyb2xsIGFyZWFcblx0ICAgIHZhciBoZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5zY3JvbGxXaWR0aCB8fCB0aGlzLl9zZXR0aW5ncy5zY3JvbGxIZWlnaHQ7IC8vaWYgd2Ugc2Nyb2xsZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJlYVxuXG5cdCAgICBpZiAodmFsdWUgPj0gaGVpZ2h0IC0gdGhpcy5fbGFzdF9zZXRfc2l6ZSAvIChhcGkgPyB0aGlzLl9zZXR0aW5ncy56b29tIDogMSkpIHtcblx0ICAgICAgLy9zZXQgdmFsdWUgc28gdGhlIGxhc3Qgcm93IGlzIHZpc2libGVcblx0ICAgICAgdmFsdWUgPSBNYXRoLm1heCgwLCBoZWlnaHQgLSB0aGlzLl9sYXN0X3NldF9zaXplIC8gdGhpcy5fc2V0dGluZ3Muem9vbSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3NldHRpbmdzLnNjcm9sbFBvcyA9IHZhbHVlIHx8IDA7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uU2Nyb2xsXCIsIFt0aGlzLmdldFNjcm9sbCgpXSk7XG5cdCAgfSxcblx0ICBhY3RpdmVBcmVhOiBmdW5jdGlvbiAoYXJlYSwgeF9tb2RlKSB7XG5cdCAgICB0aGlzLl94X3Njcm9sbF9tb2RlID0geF9tb2RlO1xuXG5cdCAgICBfZXZlbnQoYXJlYSwgZW52LmlzSUU4ID8gXCJtb3VzZXdoZWVsXCIgOiBcIndoZWVsXCIsIHRoaXMuX29uX3doZWVsLCB7XG5cdCAgICAgIGJpbmQ6IHRoaXMsXG5cdCAgICAgIHBhc3NpdmU6IGZhbHNlXG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fYWRkX3RvdWNoX2V2ZW50cyhhcmVhKTtcblx0ICB9LFxuXHQgIF9hZGRfdG91Y2hfZXZlbnRzOiBmdW5jdGlvbiAoYXJlYSkge1xuXHQgICAgaWYgKCFlbnYudG91Y2ggJiYgd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCkge1xuXHQgICAgICBhZGRDc3MoYXJlYSwgXCJ3ZWJpeF9zY3JvbGxfdG91Y2hfaWVcIiwgdHJ1ZSk7XG5cblx0ICAgICAgX2V2ZW50KGFyZWEsIFwicG9pbnRlcmRvd25cIiwgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PSBcInRvdWNoXCIgfHwgZS5wb2ludGVyVHlwZSA9PSBcInBlblwiKSB7XG5cdCAgICAgICAgICB0aGlzLl9zdGFydF9jb250ZXh0ID0gVG91Y2guX2dldF9jb250ZXh0X20oZSk7XG5cdCAgICAgICAgICB0aGlzLl9zdGFydF9zY3JvbGxfcG9zID0gdGhpcy5nZXRTY3JvbGwoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGV2ZW50JDEoZG9jdW1lbnQuYm9keSwgXCJwb2ludGVybW92ZVwiLCBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIHZhciBzY3JvbGw7XG5cblx0ICAgICAgICBpZiAodGhpcy5fc3RhcnRfY29udGV4dCkge1xuXHQgICAgICAgICAgdGhpcy5fY3VycmVudF9jb250ZXh0ID0gVG91Y2guX2dldF9jb250ZXh0X20oZSk7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zY3JvbGwgPT0gXCJ4XCIpIHtcblx0ICAgICAgICAgICAgc2Nyb2xsID0gdGhpcy5fY3VycmVudF9jb250ZXh0LnggLSB0aGlzLl9zdGFydF9jb250ZXh0Lng7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnNjcm9sbCA9PSBcInlcIikge1xuXHQgICAgICAgICAgICBzY3JvbGwgPSB0aGlzLl9jdXJyZW50X2NvbnRleHQueSAtIHRoaXMuX3N0YXJ0X2NvbnRleHQueTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHNjcm9sbCAmJiBNYXRoLmFicyhzY3JvbGwpID4gNSkge1xuXHQgICAgICAgICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuX3N0YXJ0X3Njcm9sbF9wb3MgLSBzY3JvbGwpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICAgIGV2ZW50JDEod2luZG93LCBcInBvaW50ZXJ1cFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXJ0X2NvbnRleHQpIHtcblx0ICAgICAgICAgIHRoaXMuX3N0YXJ0X2NvbnRleHQgPSB0aGlzLl9jdXJyZW50X2NvbnRleHQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25fd2hlZWw6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgZGlyID0gMDtcblx0ICAgIHZhciBzdGVwID0gZS5kZWx0YU1vZGUgPT09IDAgPyAzMCA6IDE7XG5cdCAgICBpZiAoZW52LmlzSUU4KSBkaXIgPSBlLmRldGFpbCA9IC1lLndoZWVsRGVsdGEgLyAzMDtcblxuXHQgICAgaWYgKGUuZGVsdGFYICYmIE1hdGguYWJzKGUuZGVsdGFYKSA+IE1hdGguYWJzKGUuZGVsdGFZKSkge1xuXHQgICAgICAvL3gtc2Nyb2xsXG5cdCAgICAgIGlmICh0aGlzLl94X3Njcm9sbF9tb2RlICYmIHRoaXMuX3NldHRpbmdzLnNjcm9sbFZpc2libGUpIGRpciA9IGUuZGVsdGFYIC8gc3RlcDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8veS1zY3JvbGxcblx0ICAgICAgaWYgKCF0aGlzLl94X3Njcm9sbF9tb2RlICYmIHRoaXMuX3NldHRpbmdzLnNjcm9sbFZpc2libGUpIHtcblx0ICAgICAgICBpZiAoaXNVbmRlZmluZWQoZS5kZWx0YVkpKSBkaXIgPSBlLmRldGFpbDtlbHNlIGRpciA9IGUuZGVsdGFZIC8gc3RlcDtcblx0ICAgICAgfVxuXHQgICAgfSAvLyBTYWZhcmkgcmVxdWlyZXMgdGFyZ2V0IHByZXNlcnZpbmdcblx0ICAgIC8vICh1c2VkIGluIF9jaGVja19yZW5kZXJlZF9jb2xzIG9mIERhdGFUYWJsZSlcblxuXG5cdCAgICBpZiAoZW52LmlzU2FmYXJpKSB0aGlzLl9zY3JvbGxfdHJnID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXHQgICAgaWYgKGRpcikgaWYgKHRoaXMuc2Nyb2xsVG8odGhpcy5nZXRTY3JvbGwoKSArIGRpciAqIHRoaXMuX3NldHRpbmdzLnNjcm9sbFN0ZXApKSByZXR1cm4gcHJldmVudEV2ZW50KGUpO1xuXHQgIH1cblx0fTtcblx0dmFyIHZpZXckMWMgPSBleHBvcnRzLnByb3RvVUkoYXBpJDFjLCBFdmVudFN5c3RlbSwgU2V0dGluZ3MpO1xuXG5cdHZhciB0ZW1wJDMgPSB7fTtcblxuXHR2YXIgTWl4aW4gPSB7XG5cdCAgZmlsdGVyQnlBbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vd2UgbmVlZCB0byB1c2UgZHluYW1pYyBmdW5jdGlvbiBjcmVhdGluZ1xuXHQgICAgdmFyIHNlcnZlciA9IGZhbHNlO1xuXHQgICAgdGhpcy5kYXRhLnNpbGVudChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZmlsdGVyKCk7XG5cdCAgICAgIHZhciBmaXJzdCA9IGZhbHNlO1xuXG5cdCAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9maWx0ZXJfZWxlbWVudHMpIHtcblx0ICAgICAgICBhc3NlcnQoa2V5LCBcImVtcHR5IGNvbHVtbiBpZCBmb3IgY29sdW1uIHdpdGggZmlsdGVyaW5nXCIpO1xuXHQgICAgICAgIGlmICghdGhpcy5pc0NvbHVtblZpc2libGUoa2V5KSkgY29udGludWU7XG5cdCAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2ZpbHRlcl9lbGVtZW50c1trZXldO1xuXHQgICAgICAgIHZhciBvcmlnaW52YWx1ZSA9IHJlY29yZFsyXS5nZXRWYWx1ZShyZWNvcmRbMF0pOyAvL3NhdmluZyBsYXN0IGZpbHRlciB2YWx1ZSwgZm9yIHVzYWdlIGluIGdldFN0YXRlXG5cblx0ICAgICAgICB2YXIgaW5wdXR2YWx1ZSA9IG9yaWdpbnZhbHVlO1xuXHQgICAgICAgIGlmIChyZWNvcmRbMV0ucHJlcGFyZSkgaW5wdXR2YWx1ZSA9IHJlY29yZFsxXS5wcmVwYXJlLmNhbGwocmVjb3JkWzJdLCBpbnB1dHZhbHVlLCByZWNvcmRbMV0sIHRoaXMpOyAvL3ByZXNlcnZlIG9yaWdpbmFsIHZhbHVlXG5cblx0ICAgICAgICByZWNvcmRbMV0udmFsdWUgPSBvcmlnaW52YWx1ZTtcblx0ICAgICAgICB2YXIgY29tcGFyZSA9IHJlY29yZFsxXS5jb21wYXJlO1xuXHQgICAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUZpbHRlclwiLCBba2V5LCBpbnB1dHZhbHVlLCByZWNvcmRbMV1dKSkgY29udGludWU7XG5cblx0ICAgICAgICBpZiAocmVjb3JkWzJdLiRzZXJ2ZXIgfHwgc2VydmVyKSB7XG5cdCAgICAgICAgICAvL2lmIG9uZSBvZiBmaWx0ZXJzIGlzIHNlcnZlciBzaWRlLCBkbyBub3QgcnVuIGFueSBjbGllbnQgc2lkZSBmaWx0ZXJzXG5cdCAgICAgICAgICBzZXJ2ZXIgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpZiAoaW5wdXR2YWx1ZSA9PT0gXCJcIikgY29udGludWU7XG5cblx0ICAgICAgICAgIGlmIChjb21wYXJlKSB7XG5cdCAgICAgICAgICAgIGNvbXBhcmUgPSB0aGlzLl9tdWx0aV9jb21wYXJlKGtleSwgY29tcGFyZSk7XG5cdCAgICAgICAgICAgIHRoaXMuZmlsdGVyKGJpbmQoZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlKG9ialtrZXldLCB2YWx1ZSwgb2JqKTtcblx0ICAgICAgICAgICAgfSwgdGhpcyksIGlucHV0dmFsdWUsIGZpcnN0KTtcblx0ICAgICAgICAgIH0gZWxzZSB0aGlzLmZpbHRlcihrZXksIGlucHV0dmFsdWUsIGZpcnN0KTtcblxuXHQgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzZXJ2ZXIpIHRoaXMuX3J1blNlcnZlckZpbHRlcigpO1xuXHQgICAgfSwgdGhpcyk7XG5cblx0ICAgIGlmICghc2VydmVyKSB7XG5cdCAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJGaWx0ZXJcIiwgW10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX211bHRpX2NvbXBhcmU6IGZ1bmN0aW9uIChrZXksIGNvbXBhcmUpIHtcblx0ICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkNvbmZpZyhrZXkpO1xuXHQgICAgdmFyIHNlcGFyYXRvciA9IGNvbHVtbiA/IGNvbHVtbi5vcHRpb25zbGlzdCA6IG51bGw7IC8vZGVmYXVsdCBtb2RlXG5cblx0ICAgIGlmICghc2VwYXJhdG9yKSByZXR1cm4gY29tcGFyZTtcblx0ICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9IFwic3RyaW5nXCIpIHNlcGFyYXRvciA9IFwiLFwiO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtVmFsdWUsIGlucHV0VmFsdWUsIG9iaikge1xuXHQgICAgICBpZiAoIWl0ZW1WYWx1ZSkgcmV0dXJuIHRydWU7XG5cdCAgICAgIHZhciBpZHMgPSBpdGVtVmFsdWUuc3BsaXQoc2VwYXJhdG9yKTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChjb21wYXJlKGlkc1tpXSwgaW5wdXRWYWx1ZSwgb2JqKSkgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfSxcblx0ICBmaWx0ZXJNb2RlX3NldHRlcjogZnVuY3Rpb24gKG1vZGUpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh0aGlzLmRhdGEuX2ZpbHRlck1vZGUsIG1vZGUsIHRydWUpO1xuXHQgIH0sXG5cdCAgZ2V0RmlsdGVyOiBmdW5jdGlvbiAoY29sdW1uSWQpIHtcblx0ICAgIHZhciBmaWx0ZXIgPSB0aGlzLl9maWx0ZXJfZWxlbWVudHNbY29sdW1uSWRdO1xuXHQgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXJbMl0uZ2V0SW5wdXROb2RlKSByZXR1cm4gZmlsdGVyWzJdLmdldElucHV0Tm9kZShmaWx0ZXJbMF0pO1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICByZWdpc3RlckZpbHRlcjogZnVuY3Rpb24gKG5vZGUsIGNvbmZpZywgb2JqKSB7XG5cdCAgICB0aGlzLl9maWx0ZXJfZWxlbWVudHNbY29uZmlnLmNvbHVtbklkXSA9IFtub2RlLCBjb25maWcsIG9ial07XG5cdCAgfSxcblx0ICBjb2xsZWN0VmFsdWVzOiBmdW5jdGlvbiAoaWQsIG1vZGUpIHtcblx0ICAgIHZhciB2YWx1ZXMgPSBbXTtcblx0ICAgIHZhciBjaGVja3MgPSB7XG5cdCAgICAgIFwiXCI6IHRydWVcblx0ICAgIH07XG5cdCAgICB2YXIgb2JqID0gdGhpcy5nZXRDb2x1bW5Db25maWcoaWQpO1xuXHQgICAgdmFyIG9wdGlvbnMgPSBtb2RlICYmIG1vZGUudmlzaWJsZSA/IG51bGwgOiBvYmoub3B0aW9ucyB8fCBvYmouY29sbGVjdGlvbjtcblxuXHQgICAgaWYgKG9wdGlvbnMpIHtcblx0ICAgICAgaWYgKF90eXBlb2Yob3B0aW9ucykgPT0gXCJvYmplY3RcIiAmJiAhb3B0aW9ucy5sb2FkTmV4dCkge1xuXHQgICAgICAgIC8vcmF3IG9iamVjdFxuXHQgICAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMpKSBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhbHVlcy5wdXNoKHtcblx0ICAgICAgICAgICAgaWQ6IG9wdGlvbnNbaV0sXG5cdCAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zW2ldXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9IGVsc2UgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcblx0ICAgICAgICAgIHZhbHVlcy5wdXNoKHtcblx0ICAgICAgICAgICAgaWQ6IGtleSxcblx0ICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNba2V5XVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZXM7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy92aWV3XG5cdCAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSBvcHRpb25zID0gJCQob3B0aW9ucyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZ2V0Qm9keSkgb3B0aW9ucyA9IG9wdGlvbnMuZ2V0Qm9keSgpO1xuXG5cdCAgICAgICAgdGhpcy5fY29sbGVjdFZhbHVlcy5jYWxsKG9wdGlvbnMsIFwiaWRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZXMsIGNoZWNrcyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB0aGlzLl9jb2xsZWN0VmFsdWVzKG9iai5pZCwgb2JqLmlkLCB2YWx1ZXMsIGNoZWNrcyk7XG5cblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgIHZhbHVlczogdmFsdWVzXG5cdCAgICB9O1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkNvbGxlY3RWYWx1ZXNcIiwgW2lkLCByZXN1bHRdKTtcblx0ICAgIHJldHVybiByZXN1bHQudmFsdWVzO1xuXHQgIH0sXG5cdCAgX2NvbGxlY3RWYWx1ZXM6IGZ1bmN0aW9uIChpZCwgdmFsdWUsIHZhbHVlcywgY2hlY2tzKSB7XG5cdCAgICB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgIHZhciB0ZXN0ID0gb2JqID8gb2JqW2lkXSA6IFwiXCI7XG5cblx0ICAgICAgaWYgKHRlc3QgIT09IHVuZGVmaW5lZCAmJiAhY2hlY2tzW3Rlc3RdKSB7XG5cdCAgICAgICAgY2hlY2tzW3Rlc3RdID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgbGluZWlkID0gb2JqW2lkXTsgLy9zcGVjaWFsIGhhbmRsaW5nIGZvciAwIHZhbHVlc1xuXHQgICAgICAgIC8vY29udmVydCB0byBzdHJpbmcgdG8gY3JlYXRlIGEgdmFsaWQgSURcblxuXHQgICAgICAgIGlmIChsaW5laWQgPT09IDApIGxpbmVpZCA9IFwiMFwiO1xuXHQgICAgICAgIHZhbHVlcy5wdXNoKHtcblx0ICAgICAgICAgIGlkOiBsaW5laWQsXG5cdCAgICAgICAgICB2YWx1ZTogb2JqW3ZhbHVlXVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9LCB0aGlzLCB0cnVlKTtcblxuXHQgICAgaWYgKHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVzWzBdLnZhbHVlID09PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwicmF3XCI7XG5cdCAgICAgIHZhbHVlcy5zb3J0KHRoaXMuZGF0YS5zb3J0aW5nLmNyZWF0ZSh7XG5cdCAgICAgICAgYXM6IHR5cGUsXG5cdCAgICAgICAgYnk6IFwidmFsdWVcIixcblx0ICAgICAgICBkaXI6IFwiYXNjXCJcblx0ICAgICAgfSkpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3J1blNlcnZlckZpbHRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblxuXHQgICAgdGhpcy5sb2FkTmV4dCgwLCAwLCAwLCAwLCAxKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgIGlmIChfdGhpcy5lZGl0U3RvcCkgX3RoaXMuZWRpdFN0b3AoKTtcblxuXHQgICAgICBfdGhpcy5jbGVhckFsbCh0cnVlKTtcblxuXHQgICAgICBfdGhpcy5wYXJzZShkYXRhKTtcblxuXHQgICAgICBfdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyRmlsdGVyXCIsIFtdKTtcblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgTWl4aW4kMSA9IHtcblx0ICBob3Zlcl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlICYmICF0aGlzLl9ob3Zlcl9pbml0aWFsaXplZCkge1xuXHQgICAgICB0aGlzLl9lbmFibGVfbW91c2VfbW92ZSgpO1xuXG5cdCAgICAgIHRoaXMuY29uZmlnLmV4cGVyaW1lbnRhbCA9IHRydWU7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbk1vdXNlTW92aW5nXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5sb2NhdGUoYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICByb3cgPSByb3cgPyByb3cucm93IDogbnVsbDtcblxuXHQgICAgICAgIGlmICh0aGlzLl9sYXN0X2hvdmVyICE9IHJvdykge1xuXHQgICAgICAgICAgaWYgKHRoaXMuX2xhc3RfaG92ZXIpIHRoaXMucmVtb3ZlUm93Q3NzKHRoaXMuX2xhc3RfaG92ZXIsIHRoaXMuX3NldHRpbmdzLmhvdmVyKTtcblx0ICAgICAgICAgIHRoaXMuX2xhc3RfaG92ZXIgPSByb3c7XG5cdCAgICAgICAgICBpZiAodGhpcy5fbGFzdF9ob3ZlcikgdGhpcy5hZGRSb3dDc3ModGhpcy5fbGFzdF9ob3ZlciwgdGhpcy5fc2V0dGluZ3MuaG92ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIGV2ZW50JDEodGhpcy4kdmlldywgXCJtb3VzZW91dFwiLCBiaW5kKGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2xhc3RfaG92ZXIgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyhlLnRhcmdldCkpIHtcblx0ICAgICAgICAgIHRoaXMucmVtb3ZlUm93Q3NzKHRoaXMuX2xhc3RfaG92ZXIsIHRoaXMuX3NldHRpbmdzLmhvdmVyKTtcblx0ICAgICAgICAgIHRoaXMuX2xhc3RfaG92ZXIgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgICB0aGlzLl9ob3Zlcl9pbml0aWFsaXplZCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIHNlbGVjdF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKCF0aGlzLnNlbGVjdCAmJiB2YWx1ZSkge1xuXHQgICAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCB0aGlzLl9zZWxlY3Rpb25zLl9jb21tb25zZWxlY3QsIHRydWUpO1xuXHQgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHZhbHVlID0gXCJyb3dcIjtlbHNlIGlmICh2YWx1ZSA9PSBcIm11bHRpc2VsZWN0XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwicm93XCI7XG5cdCAgICAgICAgdGhpcy5fc2V0dGluZ3MubXVsdGlzZWxlY3QgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGFzc2VydCh0aGlzLl9zZWxlY3Rpb25zW3ZhbHVlXSwgXCJVbmtub3duIHNlbGVjdGlvbiBtb2RlOiBcIiArIHZhbHVlKTtcblx0ICAgICAgZXhwb3J0cy5leHRlbmQodGhpcywgdGhpcy5fc2VsZWN0aW9uc1t2YWx1ZV0sIHRydWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBnZXRTZWxlY3RlZElkOiBmdW5jdGlvbiAobW9kZSkge1xuXHQgICAgcmV0dXJuIG1vZGUgPyBbXSA6IFwiXCI7IC8vZHVtbXkgcGxhY2Vob2xkZXJcblx0ICB9LFxuXHQgIGdldFNlbGVjdGVkSXRlbTogZnVuY3Rpb24gKG1vZGUpIHtcblx0ICAgIHJldHVybiBTZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZEl0ZW0uY2FsbCh0aGlzLCBtb2RlKTtcblx0ICB9LFxuXHQgIF9zZWxlY3Rpb25zOiB7XG5cdCAgICAvL3NoYXJlZCBtZXRob2RzIGZvciBhbGwgc2VsZWN0aW9uIG1vZGVsc1xuXHQgICAgX2NvbW1vbnNlbGVjdDoge1xuXHQgICAgICBfc2VsZWN0X2NzczogXCIgd2ViaXhfY2VsbF9zZWxlY3RcIixcblx0ICAgICAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9yZWluaXRfc2VsZWN0aW9uKCk7XG5cblx0ICAgICAgICB0aGlzLm9uX2NsaWNrLndlYml4X2NlbGwgPSBiaW5kKHRoaXMuX2NsaWNrX2JlZm9yZV9zZWxlY3QsIHRoaXMpOyAvL3RlbXBvcmFyeSBzdGFiLCBhY3R1YWwgaGFuZGxlcnMgbmVlZCB0byBiZSBjcmVhdGVkXG5cblx0ICAgICAgICB0aGlzLl9kYXRhX2NsZWFyZWQgPSB0aGlzLl9kYXRhX2ZpbHRlcmVkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKHRoaXMuX2RhdGFfdXBkYXRlZCwgdGhpcykpO1xuXHQgICAgICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3luY0FwcGx5XCIsIGJpbmQodGhpcy5fZGF0YV9zeW5jZWQsIHRoaXMpKTtcblx0ICAgICAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGJpbmQodGhpcy5fZGF0YV9jbGVhcmVkLCB0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25BZnRlckZpbHRlclwiLCBiaW5kKHRoaXMuX2RhdGFfZmlsdGVyZWQsIHRoaXMpKTtcblx0ICAgICAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbklkQ2hhbmdlXCIsIGJpbmQodGhpcy5faWRfY2hhbmdlZCwgdGhpcykpO1xuXHQgICAgICAgIHRoaXMuJHJlYWR5LnB1c2goU2VsZWN0aW9uTW9kZWwuX3NldF9ub3NlbGVjdCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9pZF9jaGFuZ2VkOiBmdW5jdGlvbiAob2xkaWQsIG5ld2lkKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWxlY3RlZF9yb3dzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRfcm93c1tpXSA9PSBvbGRpZCkgdGhpcy5fc2VsZWN0ZWRfcm93c1tpXSA9IG5ld2lkO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLl9zZWxlY3RlZF9hcmVhcy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fc2VsZWN0ZWRfYXJlYXNbX2ldO1xuXG5cdCAgICAgICAgICBpZiAoaXRlbS5yb3cgPT0gb2xkaWQpIHtcblx0ICAgICAgICAgICAgb2xkaWQgPSB0aGlzLl9zZWxlY3Rfa2V5KGl0ZW0pO1xuXHQgICAgICAgICAgICBpdGVtLnJvdyA9IG5ld2lkO1xuXHQgICAgICAgICAgICBuZXdpZCA9IHRoaXMuX3NlbGVjdF9rZXkoaXRlbSk7XG5cdCAgICAgICAgICAgIGl0ZW0uaWQgPSBuZXdpZDtcblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NlbGVjdGVkX3B1bGxbb2xkaWRdO1xuXHQgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZF9wdWxsW25ld2lkXSA9IHRydWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBfZGF0YV91cGRhdGVkOiBmdW5jdGlvbiAoaWQsIG9iaiwgdHlwZSkge1xuXHQgICAgICAgIGlmICh0eXBlID09IFwiZGVsZXRlXCIpIHRoaXMudW5zZWxlY3QoaWQpO1xuXHQgICAgICB9LFxuXHQgICAgICBfZGF0YV9zeW5jZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VsZWN0ZWRfYXJlYXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgIHZhciByb3cgPSB0aGlzLl9zZWxlY3RlZF9hcmVhc1tpXS5yb3c7XG5cblx0ICAgICAgICAgIGlmICghdGhpcy5leGlzdHMocm93KSkge1xuXHQgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZF9hcmVhcy5zcGxpY2UoaSwgMSk7XG5cblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3NlbGVjdGVkX3B1bGxbcm93XTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIF9yZWluaXRfc2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9saXN0IG9mIHNlbGVjdGVkIGFyZWFzXG5cdCAgICAgICAgdGhpcy5fc2VsZWN0ZWRfYXJlYXMgPSBbXTsgLy9rZXktdmFsdWUgaGFzaCBvZiBzZWxlY3RlZCBhcmVhcywgZm9yIGZhc3Qgc2VhcmNoXG5cblx0ICAgICAgICB0aGlzLl9zZWxlY3RlZF9wdWxsID0ge307IC8vdXNlZCB0byB0cmFjayBzZWxlY3RlZCBjZWxsIG9iamVjdHNcblxuXHQgICAgICAgIHRoaXMuX3NlbGVjdGVkX3Jvd3MgPSBbXTtcblx0ICAgICAgfSxcblx0ICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gKGlkLCBjb2x1bW4pIHtcblx0ICAgICAgICB2YXIga2V5O1xuXHQgICAgICAgIGlmICghaXNVbmRlZmluZWQoY29sdW1uKSkga2V5ID0gdGhpcy5fc2VsZWN0X2tleSh7XG5cdCAgICAgICAgICByb3c6IGlkLFxuXHQgICAgICAgICAgY29sdW1uOiBjb2x1bW5cblx0ICAgICAgICB9KTtlbHNlIGtleSA9IF90eXBlb2YoaWQpID09PSBcIm9iamVjdFwiID8gdGhpcy5fc2VsZWN0X2tleShpZCkgOiBpZDtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRfcHVsbFtrZXldO1xuXHQgICAgICB9LFxuXHQgICAgICBnZXRTZWxlY3RlZElkOiBmdW5jdGlvbiAoYXNBcnJheSwgcGxhaW4pIHtcblx0ICAgICAgICB2YXIgcmVzdWx0OyAvL2lmIG11bHRpcGxlIHNlbGVjdGlvbnMgd2FzIGNyZWF0ZWQgLSByZXR1cm4gYXJyYXlcblx0ICAgICAgICAvL2luIGNhc2Ugb2Ygc2luZ2xlIHNlbGVjdGlvbiwgcmV0dXJuIHZhbHVlIG9yIGFycmF5LCB3aGVuIGFzQXJyYXkgcGFyYW1ldGVyIHByb3ZpZGVkXG5cblx0ICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRfYXJlYXMubGVuZ3RoID4gMSB8fCBhc0FycmF5KSB7XG5cdCAgICAgICAgICByZXN1bHQgPSBbXS5jb25jYXQodGhpcy5fc2VsZWN0ZWRfYXJlYXMpO1xuXHQgICAgICAgICAgaWYgKHBsYWluKSBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0uaWQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3NlbGVjdGVkX2FyZWFzWzBdO1xuXHQgICAgICAgICAgaWYgKHBsYWluICYmIHJlc3VsdCkgcmV0dXJuIHJlc3VsdC5pZDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9LFxuXHQgICAgICBfaWRfdG9fc3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucm93O1xuXHQgICAgICB9LFxuXHQgICAgICBfc2VsZWN0OiBmdW5jdGlvbiAoZGF0YSwgcHJlc2VydmUpIHtcblx0ICAgICAgICB2YXIga2V5ID0gdGhpcy5fc2VsZWN0X2tleShkYXRhKTsgLy9kb24ndCBhbGxvdyBzZWxlY3Rpb24gb24gdW5uYW1lZCBjb2x1bW5zXG5cblxuXHQgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHJldHVybjtcblx0ICAgICAgICBpZiAocHJlc2VydmUgPT09IC0xKSByZXR1cm4gdGhpcy5fdW5zZWxlY3QoZGF0YSk7XG5cdCAgICAgICAgZGF0YS5pZCA9IGtleTtcblx0ICAgICAgICBkYXRhLnRvU3RyaW5nID0gdGhpcy5faWRfdG9fc3RyaW5nO1xuXHQgICAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVNlbGVjdFwiLCBbZGF0YSwgcHJlc2VydmVdKSkgcmV0dXJuIGZhbHNlOyAvL2lnbm9yZSBhcmVhLCBpZiBpdCB3YXMgYWxyZWFkeSBzZWxlY3RlZCBhbmRcblx0ICAgICAgICAvLyAtIHdlIGFyZSBwcmVzZXJ2aW5nIGV4aXN0aW5nIHNlbGVjdGlvblxuXHQgICAgICAgIC8vIC0gdGhpcyBpcyB0aGUgb25seSBzZWxlY3RlZCBhcmVhXG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gY2xlYXIgb3RoZXIgc2VsZWN0ZWQgYXJlYXNcblxuXHQgICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZF9wdWxsW2tleV0gJiYgKHByZXNlcnZlIHx8IHRoaXMuX3NlbGVjdGVkX2FyZWFzLmxlbmd0aCA9PSAxKSkgcmV0dXJuO1xuXHQgICAgICAgIGlmICghcHJlc2VydmUpIHRoaXMuX2NsZWFyX3NlbGVjdGlvbigpO1xuXG5cdCAgICAgICAgdGhpcy5fc2VsZWN0ZWRfYXJlYXMucHVzaChkYXRhKTtcblxuXHQgICAgICAgIHRoaXMuX3NlbGVjdGVkX3B1bGxba2V5XSA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU2VsZWN0XCIsIFtkYXRhLCBwcmVzZXJ2ZV0pO1xuXG5cdCAgICAgICAgdGhpcy5fZmluYWxpemVfc2VsZWN0KHRoaXMuX3Bvc3Rfc2VsZWN0KGRhdGEpKTtcblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9LFxuXHQgICAgICBfY2xlYXJfc2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZF9hcmVhcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VsZWN0ZWRfYXJlYXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVVuU2VsZWN0XCIsIFt0aGlzLl9zZWxlY3RlZF9hcmVhc1tpXV0pKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5fc2VsZWN0ZWRfcm93cy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICB0aGlzLmRhdGEucmVtb3ZlTWFyayh0aGlzLl9zZWxlY3RlZF9yb3dzW19pMl0sIFwid2ViaXhfc2VsZWN0ZWRcIik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNvbHMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zO1xuXHQgICAgICAgIGlmIChjb2xzKSBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjb2xzLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgIGNvbHNbX2kzXS4kc2VsZWN0ZWQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX3NlbGVjdGVkX2FyZWFzO1xuXG5cdCAgICAgICAgdGhpcy5fcmVpbml0X3NlbGVjdGlvbigpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZGF0YS5sZW5ndGg7IF9pNCsrKSB7XG5cdCAgICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJVblNlbGVjdFwiLCBbZGF0YVtfaTRdXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH0sXG5cdCAgICAgIHVuc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuXHQgICAgICB9LFxuXHQgICAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLnNlbGVjdFJhbmdlKCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2NsZWFyX3NlbGVjdGlvbigpKSB7XG5cdCAgICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uU2VsZWN0Q2hhbmdlXCIsIFtdKTtcblx0ICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBfdW5zZWxlY3Q6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHRoaXMuX3NlbGVjdF9rZXkoZGF0YSk7XG5cblx0ICAgICAgICBpZiAoIWtleSAmJiB0aGlzLl9zZWxlY3RlZF9hcmVhcy5sZW5ndGgpIHtcblx0ICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblx0ICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TZWxlY3RDaGFuZ2VcIiwgW10pO1xuXHQgICAgICAgIH0gLy9pZ25vcmUgYXJlYSwgaWYgaXQgd2FzIGFscmVhZHkgc2VsZWN0ZWRcblxuXG5cdCAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZF9wdWxsW2tleV0pIHJldHVybjtcblx0ICAgICAgICBpZiAoIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVVblNlbGVjdFwiLCBbZGF0YV0pKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlbGVjdGVkX2FyZWFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRfYXJlYXNbaV0uaWQgPT0ga2V5KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkX2FyZWFzLnNwbGljZShpLCAxKTtcblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkZWxldGUgdGhpcy5fc2VsZWN0ZWRfcHVsbFtrZXldO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclVuU2VsZWN0XCIsIFtkYXRhXSk7XG5cblx0ICAgICAgICB0aGlzLl9maW5hbGl6ZV9zZWxlY3QoMCwgdGhpcy5fcG9zdF91bnNlbGVjdChkYXRhKSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9hZGRfaXRlbV9zZWxlY3Q6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmFkZE1hcmsoaXRlbS5pZCwgXCJ3ZWJpeF9zZWxlY3RlZFwiLCAwLCB7XG5cdCAgICAgICAgICAkY291bnQ6IDBcblx0ICAgICAgICB9LCB0cnVlKTtcblx0ICAgICAgfSxcblx0ICAgICAgX2ZpbmFsaXplX3NlbGVjdDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgaWYgKGlkKSB0aGlzLl9zZWxlY3RlZF9yb3dzLnB1c2goaWQpO1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLl9zaWxlbnRfc2VsZWN0aW9uKSB7XG5cdCAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNlbGVjdENoYW5nZVwiLCBbXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBfY2xpY2tfYmVmb3JlX3NlbGVjdDogZnVuY3Rpb24gKGUsIGlkKSB7XG5cdCAgICAgICAgdmFyIHByZXNlcnZlID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCB0aGlzLl9zZXR0aW5ncy5tdWx0aXNlbGVjdCA9PSBcInRvdWNoXCI7XG5cdCAgICAgICAgdmFyIHJhbmdlID0gZS5zaGlmdEtleTtcblx0ICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLm11bHRpc2VsZWN0ICYmIHRoaXMuX3NldHRpbmdzLnNlbGVjdCAhPSBcIm11bHRpc2VsZWN0XCIgJiYgdGhpcy5fc2V0dGluZ3Muc2VsZWN0ICE9IFwiYXJlYVwiKSBwcmVzZXJ2ZSA9IHJhbmdlID0gZmFsc2U7XG5cblx0ICAgICAgICBpZiAocmFuZ2UgJiYgdGhpcy5fc2VsZWN0ZWRfYXJlYXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuX3NlbGVjdGVkX2FyZWFzW3RoaXMuX3NlbGVjdGVkX2FyZWFzLmxlbmd0aCAtIDFdO1xuXG5cdCAgICAgICAgICB0aGlzLl9zZWxlY3RSYW5nZShpZCwgbGFzdCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmIChwcmVzZXJ2ZSAmJiB0aGlzLl9zZWxlY3RlZF9wdWxsW3RoaXMuX3NlbGVjdF9rZXkoaWQpXSkgdGhpcy5fdW5zZWxlY3QoaWQpO2Vsc2UgdGhpcy5fc2VsZWN0KHtcblx0ICAgICAgICAgICAgcm93OiBpZC5yb3csXG5cdCAgICAgICAgICAgIGNvbHVtbjogaWQuY29sdW1uXG5cdCAgICAgICAgICB9LCBwcmVzZXJ2ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBfbWFwU2VsZWN0aW9uOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbHVtbiwgcm93KSB7XG5cdCAgICAgICAgdmFyIGNvbHMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zOyAvL3NlbGVjdGVkIGNvbHVtbnMgb25seVxuXG5cdCAgICAgICAgaWYgKGNvbHVtbikge1xuXHQgICAgICAgICAgdmFyIHRlbXAgPSBbXTtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChjb2xzW2ldLiRzZWxlY3RlZCkgdGVtcC5wdXNoKGNvbHNbaV0pO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBjb2xzID0gdGVtcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcm93cyA9IHRoaXMuZGF0YS5vcmRlcjtcblx0ICAgICAgICB2YXIgcm93X2luZCA9IDA7XG5cblx0ICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCByb3dzLmxlbmd0aDsgX2k1KyspIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKHJvd3NbX2k1XSk7XG5cdCAgICAgICAgICBpZiAoIWl0ZW0pIGNvbnRpbnVlOyAvL2R5biBsb2FkaW5nLCByb3cgaXMgbm90IGF2YWlsYWJsZVxuXG5cdCAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kYXRhLmdldE1hcmsoaXRlbS5pZCwgXCJ3ZWJpeF9zZWxlY3RlZFwiKTtcblxuXHQgICAgICAgICAgaWYgKHNlbGVjdGlvbiB8fCBjb2x1bW4pIHtcblx0ICAgICAgICAgICAgdmFyIGNvbF9pbmQgPSAwO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29scy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgIHZhciBpZCA9IGNvbHNbal0uaWQ7XG5cblx0ICAgICAgICAgICAgICBpZiAocm93IHx8IGNvbHVtbiB8fCBzZWxlY3Rpb25baWRdKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGl0ZW1baWRdID0gY2FsbGJhY2soaXRlbVtpZF0sIHJvd3NbX2k1XSwgaWQsIHJvd19pbmQsIGNvbF9pbmQpO2Vsc2UgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgcm93OiByb3dzW19pNV0sXG5cdCAgICAgICAgICAgICAgICAgIGNvbHVtbjogaWRcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBjb2xfaW5kKys7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IC8vdXNlIHNlcGFyYXRlIHJvdyBjb3VudGVyLCB0byBjb3VudCBvbmx5IHNlbGVjdGVkIHJvd3NcblxuXG5cdCAgICAgICAgICAgIHJvd19pbmQrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICByb3c6IHtcblx0ICAgICAgX3NlbGVjdF9jc3M6IFwiIHdlYml4X3Jvd19zZWxlY3RcIixcblx0ICAgICAgX3NlbGVjdF9rZXk6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEucm93O1xuXHQgICAgICB9LFxuXHQgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChyb3dfaWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgLy93aGVuIHdlIGFyZSB1c2luZyBpZCBmcm9tIG1vdXNlIGV2ZW50c1xuXHQgICAgICAgIGlmIChyb3dfaWQpIHJvd19pZCA9IHJvd19pZC50b1N0cmluZygpO1xuXHQgICAgICAgIGFzc2VydCh0aGlzLmRhdGEuZXhpc3RzKHJvd19pZCksIFwiSW5jb3JyZWN0IGlkIGluIHNlbGVjdCBjb21tYW5kOiBcIiArIHJvd19pZCk7XG5cblx0ICAgICAgICB0aGlzLl9zZWxlY3Qoe1xuXHQgICAgICAgICAgcm93OiByb3dfaWRcblx0ICAgICAgICB9LCBwcmVzZXJ2ZSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9wb3N0X3NlbGVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB0aGlzLl9hZGRfaXRlbV9zZWxlY3QoZGF0YS5yb3cpLiRyb3cgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiBkYXRhLnJvdztcblx0ICAgICAgfSxcblx0ICAgICAgdW5zZWxlY3Q6IGZ1bmN0aW9uIChyb3dfaWQpIHtcblx0ICAgICAgICB0aGlzLl91bnNlbGVjdCh7XG5cdCAgICAgICAgICByb3c6IHJvd19pZFxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBfcG9zdF91bnNlbGVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB0aGlzLmRhdGEucmVtb3ZlTWFyayhkYXRhLnJvdywgXCJ3ZWJpeF9zZWxlY3RlZFwiLCAwLCAxKTtcblx0ICAgICAgICByZXR1cm4gZGF0YS5yb3c7XG5cdCAgICAgIH0sXG5cdCAgICAgIG1hcFNlbGVjdGlvbjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX21hcFNlbGVjdGlvbihjYWxsYmFjaywgZmFsc2UsIHRydWUpO1xuXHQgICAgICB9LFxuXHQgICAgICBfc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0UmFuZ2UoYS5yb3csIGIucm93KTtcblx0ICAgICAgfSxcblx0ICAgICAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIChyb3dfaWQsIGVuZF9yb3dfaWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHByZXNlcnZlKSkgcHJlc2VydmUgPSB0cnVlO1xuXHQgICAgICAgIHZhciByb3dfc3RhcnRfaW5kID0gcm93X2lkID8gdGhpcy5nZXRJbmRleEJ5SWQocm93X2lkKSA6IDA7XG5cdCAgICAgICAgdmFyIHJvd19lbmRfaW5kID0gZW5kX3Jvd19pZCA/IHRoaXMuZ2V0SW5kZXhCeUlkKGVuZF9yb3dfaWQpIDogdGhpcy5kYXRhLm9yZGVyLmxlbmd0aCAtIDE7XG5cblx0ICAgICAgICBpZiAocm93X3N0YXJ0X2luZCA+IHJvd19lbmRfaW5kKSB7XG5cdCAgICAgICAgICB2YXIgdGVtcCA9IHJvd19zdGFydF9pbmQ7XG5cdCAgICAgICAgICByb3dfc3RhcnRfaW5kID0gcm93X2VuZF9pbmQ7XG5cdCAgICAgICAgICByb3dfZW5kX2luZCA9IHRlbXA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fc2lsZW50X3NlbGVjdGlvbiA9IHRydWU7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gcm93X3N0YXJ0X2luZDsgaSA8PSByb3dfZW5kX2luZDsgaSsrKSB7XG5cdCAgICAgICAgICB2YXIgaWQgPSB0aGlzLmdldElkQnlJbmRleChpKTtcblxuXHQgICAgICAgICAgaWYgKCFpZCkge1xuXHQgICAgICAgICAgICBpZiAocm93X2lkKSB0aGlzLnNlbGVjdChyb3dfaWQpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgdGhpcy5zZWxlY3QoaWQsIHByZXNlcnZlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9zaWxlbnRfc2VsZWN0aW9uID0gZmFsc2U7XG5cblx0ICAgICAgICB0aGlzLl9maW5hbGl6ZV9zZWxlY3QoKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGNlbGw6IHtcblx0ICAgICAgX3NlbGVjdF9rZXk6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgaWYgKCFkYXRhLmNvbHVtbikgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEucm93ICsgXCJfXCIgKyBkYXRhLmNvbHVtbjtcblx0ICAgICAgfSxcblx0ICAgICAgc2VsZWN0OiBmdW5jdGlvbiAocm93X2lkLCBjb2x1bW5faWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgYXNzZXJ0KHRoaXMuZGF0YS5leGlzdHMocm93X2lkKSwgXCJJbmNvcnJlY3QgaWQgaW4gc2VsZWN0IGNvbW1hbmQ6IFwiICsgcm93X2lkKTtcblxuXHQgICAgICAgIHRoaXMuX3NlbGVjdCh7XG5cdCAgICAgICAgICByb3c6IHJvd19pZCxcblx0ICAgICAgICAgIGNvbHVtbjogY29sdW1uX2lkXG5cdCAgICAgICAgfSwgcHJlc2VydmUpO1xuXHQgICAgICB9LFxuXHQgICAgICBfcG9zdF9zZWxlY3Q6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgdmFyIHNlbCA9IHRoaXMuX2FkZF9pdGVtX3NlbGVjdChkYXRhLnJvdyk7XG5cblx0ICAgICAgICBzZWwuJGNvdW50Kys7XG5cdCAgICAgICAgc2VsW2RhdGEuY29sdW1uXSA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEucm93O1xuXHQgICAgICB9LFxuXHQgICAgICB1bnNlbGVjdDogZnVuY3Rpb24gKHJvd19pZCwgY29sdW1uX2lkKSB7XG5cdCAgICAgICAgdGhpcy5fdW5zZWxlY3Qoe1xuXHQgICAgICAgICAgcm93OiByb3dfaWQsXG5cdCAgICAgICAgICBjb2x1bW46IGNvbHVtbl9pZFxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBfcG9zdF91bnNlbGVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB2YXIgc2VsID0gdGhpcy5fYWRkX2l0ZW1fc2VsZWN0KGRhdGEucm93KTtcblxuXHQgICAgICAgIHNlbC4kY291bnQtLTtcblx0ICAgICAgICBzZWxbZGF0YS5jb2x1bW5dID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKHNlbC4kY291bnQgPD0gMCkgdGhpcy5kYXRhLnJlbW92ZU1hcmsoZGF0YS5yb3csIFwid2ViaXhfc2VsZWN0ZWRcIik7XG5cdCAgICAgICAgcmV0dXJuIGRhdGEucm93O1xuXHQgICAgICB9LFxuXHQgICAgICBtYXBTZWxlY3Rpb246IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZWxlY3Rpb24oY2FsbGJhY2ssIGZhbHNlLCBmYWxzZSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9zZWxlY3RSYW5nZTogZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RSYW5nZShhLnJvdywgYS5jb2x1bW4sIGIucm93LCBiLmNvbHVtbik7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNlbGVjdFJhbmdlOiBmdW5jdGlvbiAocm93X2lkLCBjb2x1bW5faWQsIGVuZF9yb3dfaWQsIGVuZF9jb2x1bW5faWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHByZXNlcnZlKSkgcHJlc2VydmUgPSB0cnVlO1xuXHQgICAgICAgIHZhciByb3dfc3RhcnRfaW5kID0gcm93X2lkID8gdGhpcy5nZXRJbmRleEJ5SWQocm93X2lkKSA6IDA7XG5cdCAgICAgICAgdmFyIHJvd19lbmRfaW5kID0gZW5kX3Jvd19pZCA/IHRoaXMuZ2V0SW5kZXhCeUlkKGVuZF9yb3dfaWQpIDogdGhpcy5kYXRhLm9yZGVyLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgdmFyIGNvbF9zdGFydF9pbmQgPSBjb2x1bW5faWQgPyB0aGlzLmdldENvbHVtbkluZGV4KGNvbHVtbl9pZCkgOiAwO1xuXHQgICAgICAgIHZhciBjb2xfZW5kX2luZCA9IGVuZF9jb2x1bW5faWQgPyB0aGlzLmdldENvbHVtbkluZGV4KGVuZF9jb2x1bW5faWQpIDogdGhpcy5fY29sdW1ucy5sZW5ndGggLSAxO1xuXG5cdCAgICAgICAgaWYgKHJvd19zdGFydF9pbmQgPiByb3dfZW5kX2luZCkge1xuXHQgICAgICAgICAgdmFyIHRlbXAgPSByb3dfc3RhcnRfaW5kO1xuXHQgICAgICAgICAgcm93X3N0YXJ0X2luZCA9IHJvd19lbmRfaW5kO1xuXHQgICAgICAgICAgcm93X2VuZF9pbmQgPSB0ZW1wO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjb2xfc3RhcnRfaW5kID4gY29sX2VuZF9pbmQpIHtcblx0ICAgICAgICAgIHZhciBfdGVtcCA9IGNvbF9zdGFydF9pbmQ7XG5cdCAgICAgICAgICBjb2xfc3RhcnRfaW5kID0gY29sX2VuZF9pbmQ7XG5cdCAgICAgICAgICBjb2xfZW5kX2luZCA9IF90ZW1wO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX3NpbGVudF9zZWxlY3Rpb24gPSB0cnVlO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHJvd19zdGFydF9pbmQ7IGkgPD0gcm93X2VuZF9pbmQ7IGkrKykge1xuXHQgICAgICAgICAgZm9yICh2YXIgaiA9IGNvbF9zdGFydF9pbmQ7IGogPD0gY29sX2VuZF9pbmQ7IGorKykge1xuXHQgICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmdldElkQnlJbmRleChpKSwgdGhpcy5jb2x1bW5JZChqKSwgcHJlc2VydmUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX3NpbGVudF9zZWxlY3Rpb24gPSBmYWxzZTtcblxuXHQgICAgICAgIHRoaXMuX2ZpbmFsaXplX3NlbGVjdCgpO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY29sdW1uOiB7XG5cdCAgICAgIF9zZWxlY3RfY3NzOiBcIiB3ZWJpeF9jb2x1bW5fc2VsZWN0XCIsXG5cdCAgICAgIF9zZWxlY3Rfa2V5OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHJldHVybiBkYXRhLmNvbHVtbjtcblx0ICAgICAgfSxcblx0ICAgICAgX2lkX3RvX3N0cmluZzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbjtcblx0ICAgICAgfSxcblx0ICAgICAgLy9yZXR1cm5zIGJveC1saWtlIGFyZWEsIHdpdGggb3JkZXJlZCBzZWxlY3Rpb24gY2VsbHNcblx0ICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoY29sdW1uX2lkLCBwcmVzZXJ2ZSkge1xuXHQgICAgICAgIHRoaXMuX3NlbGVjdCh7XG5cdCAgICAgICAgICBjb2x1bW46IGNvbHVtbl9pZFxuXHQgICAgICAgIH0sIHByZXNlcnZlKTtcblx0ICAgICAgfSxcblx0ICAgICAgX3Bvc3Rfc2VsZWN0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHRoaXMuX3NldHRpbmdzLmNvbHVtbnNbdGhpcy5nZXRDb2x1bW5JbmRleChkYXRhLmNvbHVtbildLiRzZWxlY3RlZCA9IHRydWU7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9zaWxlbnRfc2VsZWN0aW9uKSB0aGlzLl9yZW5kZXJfaGVhZGVyX2FuZF9mb290ZXIoKTtcblx0ICAgICAgfSxcblx0ICAgICAgdW5zZWxlY3Q6IGZ1bmN0aW9uIChjb2x1bW5faWQpIHtcblx0ICAgICAgICB0aGlzLl91bnNlbGVjdCh7XG5cdCAgICAgICAgICBjb2x1bW46IGNvbHVtbl9pZFxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9LFxuXHQgICAgICBfcG9zdF91bnNlbGVjdDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zW3RoaXMuZ2V0Q29sdW1uSW5kZXgoZGF0YS5jb2x1bW4pXS4kc2VsZWN0ZWQgPSBudWxsO1xuXG5cdCAgICAgICAgdGhpcy5fcmVuZGVyX2hlYWRlcl9hbmRfZm9vdGVyKCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIG1hcFNlbGVjdGlvbjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX21hcFNlbGVjdGlvbihjYWxsYmFjaywgdHJ1ZSwgZmFsc2UpO1xuXHQgICAgICB9LFxuXHQgICAgICBfc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0UmFuZ2UoYS5jb2x1bW4sIGIuY29sdW1uKTtcblx0ICAgICAgfSxcblx0ICAgICAgc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIChjb2x1bW5faWQsIGVuZF9jb2x1bW5faWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHByZXNlcnZlKSkgcHJlc2VydmUgPSB0cnVlO1xuXHQgICAgICAgIHZhciBjb2x1bW5fc3RhcnRfaW5kID0gY29sdW1uX2lkID8gdGhpcy5nZXRDb2x1bW5JbmRleChjb2x1bW5faWQpIDogMDtcblx0ICAgICAgICB2YXIgY29sdW1uX2VuZF9pbmQgPSBlbmRfY29sdW1uX2lkID8gdGhpcy5nZXRDb2x1bW5JbmRleChlbmRfY29sdW1uX2lkKSA6IHRoaXMuX2NvbHVtbnMubGVuZ3RoIC0gMTtcblxuXHQgICAgICAgIGlmIChjb2x1bW5fc3RhcnRfaW5kID4gY29sdW1uX2VuZF9pbmQpIHtcblx0ICAgICAgICAgIHZhciB0ZW1wID0gY29sdW1uX3N0YXJ0X2luZDtcblx0ICAgICAgICAgIGNvbHVtbl9zdGFydF9pbmQgPSBjb2x1bW5fZW5kX2luZDtcblx0ICAgICAgICAgIGNvbHVtbl9lbmRfaW5kID0gdGVtcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9zaWxlbnRfc2VsZWN0aW9uID0gdHJ1ZTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSBjb2x1bW5fc3RhcnRfaW5kOyBpIDw9IGNvbHVtbl9lbmRfaW5kOyBpKyspIHtcblx0ICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuY29sdW1uSWQoaSksIHByZXNlcnZlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9zaWxlbnRfc2VsZWN0aW9uID0gZmFsc2U7XG5cblx0ICAgICAgICB0aGlzLl9yZW5kZXJfaGVhZGVyX2FuZF9mb290ZXIoKTtcblxuXHQgICAgICAgIHRoaXMuX2ZpbmFsaXplX3NlbGVjdCgpO1xuXHQgICAgICB9LFxuXHQgICAgICBfZGF0YV9zeW5jZWQ6IGZ1bmN0aW9uICgpIHsvL2RvIG5vdGhpbmcsIGFzIGNvbHVtbnMgYXJlIG5vdCBjaGFuZ2VkXG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBhcmVhOiB7XG5cdCAgICAgIF9zZWxlY3Rfa2V5OiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHJldHVybiBkYXRhLnJvdyArIFwiX1wiICsgZGF0YS5jb2x1bW47XG5cdCAgICAgIH0sXG5cdCAgICAgIGdldFNlbGVjdGVkSWQ6IGZ1bmN0aW9uIChhc0FycmF5KSB7XG5cdCAgICAgICAgdmFyIGFyZWEgPSB0aGlzLmdldFNlbGVjdEFyZWEoKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cblx0ICAgICAgICBpZiAoYXJlYSkge1xuXHQgICAgICAgICAgaWYgKGFzQXJyYXkgJiYgKGFyZWEuc3RhcnQucm93ICE9IGFyZWEuZW5kLnJvdyB8fCBhcmVhLnN0YXJ0LmNvbHVtbiAhPSBhcmVhLmVuZC5jb2x1bW4pKSB7XG5cdCAgICAgICAgICAgIHZhciByb3dfc3RhcnRfaW5kID0gdGhpcy5nZXRJbmRleEJ5SWQoYXJlYS5zdGFydC5yb3cpO1xuXHQgICAgICAgICAgICB2YXIgcm93X2VuZF9pbmQgPSB0aGlzLmdldEluZGV4QnlJZChhcmVhLmVuZC5yb3cpOyAvL2ZpbHRlcmluZyBpbiBwcm9jZXNzXG5cblx0ICAgICAgICAgICAgaWYgKHJvd19zdGFydF9pbmQgPT0gLTEgfHwgcm93X2VuZF9pbmQgPT0gLTEpIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIHZhciBjb2xfc3RhcnRfaW5kID0gdGhpcy5nZXRDb2x1bW5JbmRleChhcmVhLnN0YXJ0LmNvbHVtbik7XG5cdCAgICAgICAgICAgIHZhciBjb2xfZW5kX2luZCA9IHRoaXMuZ2V0Q29sdW1uSW5kZXgoYXJlYS5lbmQuY29sdW1uKTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gcm93X3N0YXJ0X2luZDsgaSA8PSByb3dfZW5kX2luZDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGNvbF9zdGFydF9pbmQ7IGogPD0gY29sX2VuZF9pbmQ7IGorKykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICByb3c6IHRoaXMuZ2V0SWRCeUluZGV4KGkpLFxuXHQgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uSWQoailcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJlYS5lbmQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBhc0FycmF5ID8gcmVzdWx0IDogcmVzdWx0WzBdO1xuXHQgICAgICB9LFxuXHQgICAgICB1bnNlbGVjdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3Vuc2VsZWN0KCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF91bnNlbGVjdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0QXJlYSgpO1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TZWxlY3RDaGFuZ2VcIiwgW10pO1xuXHQgICAgICB9LFxuXHQgICAgICBtYXBTZWxlY3Rpb246IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHZhciBzZWxlY3QgPSB0aGlzLmdldFNlbGVjdEFyZWEoKTtcblxuXHQgICAgICAgIGlmIChzZWxlY3QpIHtcblx0ICAgICAgICAgIHZhciBzaW5kID0gdGhpcy5nZXRDb2x1bW5JbmRleChzZWxlY3Quc3RhcnQuY29sdW1uKTtcblx0ICAgICAgICAgIHZhciBlaW5kID0gdGhpcy5nZXRDb2x1bW5JbmRleChzZWxlY3QuZW5kLmNvbHVtbik7XG5cdCAgICAgICAgICB2YXIgc3JvdyA9IHRoaXMuZ2V0SW5kZXhCeUlkKHNlbGVjdC5zdGFydC5yb3cpO1xuXHQgICAgICAgICAgdmFyIGVyb3cgPSB0aGlzLmdldEluZGV4QnlJZChzZWxlY3QuZW5kLnJvdyk7XG5cblx0ICAgICAgICAgIGZvciAodmFyIGkgPSBzcm93OyBpIDw9IGVyb3c7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgcmlkID0gdGhpcy5kYXRhLm9yZGVyW2ldO1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShyaWQpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSBzaW5kOyBqIDw9IGVpbmQ7IGorKykge1xuXHQgICAgICAgICAgICAgIHZhciBjaWQgPSB0aGlzLl9jb2x1bW5zW2pdLmlkO1xuXHQgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgaXRlbVtjaWRdID0gY2FsbGJhY2soaXRlbVtjaWRdLCByaWQsIGNpZCwgaSAtIHNyb3csIGogLSBzaW5kKTtlbHNlIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICByb3c6IHJpZCxcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogY2lkXG5cdCAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblx0ICAgICAgc2VsZWN0OiBmdW5jdGlvbiAocm93X2lkLCBjb2x1bW5faWQsIHByZXNlcnZlKSB7XG5cdCAgICAgICAgYXNzZXJ0KHRoaXMuZGF0YS5leGlzdHMocm93X2lkKSwgXCJJbmNvcnJlY3QgaWQgaW4gc2VsZWN0IGNvbW1hbmQ6IFwiICsgcm93X2lkKTtcblxuXHQgICAgICAgIHRoaXMuX3NlbGVjdCh7XG5cdCAgICAgICAgICByb3c6IHJvd19pZCxcblx0ICAgICAgICAgIGNvbHVtbjogY29sdW1uX2lkXG5cdCAgICAgICAgfSwgcHJlc2VydmUpO1xuXHQgICAgICB9LFxuXHQgICAgICBfc2VsZWN0UmFuZ2U6IGZ1bmN0aW9uIChpZCwgbGFzdCkge1xuXHQgICAgICAgIHRoaXMuX2V4dGVuZEFyZWFSYW5nZShpZCwgbGFzdCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIF9zZWxlY3Q6IGZ1bmN0aW9uIChjZWxsKSB7XG5cdCAgICAgICAgLy9jdHJsLXNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHlldCwgc28gaWdub3JpbmcgdGhlIHByZXNlcnZlIGZsYWdcblx0ICAgICAgICB0aGlzLmFkZFNlbGVjdEFyZWEoY2VsbCwgY2VsbCwgZmFsc2UpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9LFxuXHQgICAgICBfZGF0YV9zeW5jZWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRfYXJlYXMubGVuZ3RoKSB0aGlzLnJlZnJlc2hTZWxlY3RBcmVhKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJDIgPSB7XG5cdCAgYmxvY2tzZWxlY3Rfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSAmJiB0aGlzLl9ibG9ja19zZWxfZmxhZykge1xuXHQgICAgICBfZXZlbnQodGhpcy5fdmlld29iaiwgZW52Lm1vdXNlLm1vdmUsIHRoaXMuX2JzX21vdmUsIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBlbnYubW91c2UuZG93biwgdGhpcy5fYnNfZG93biwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cblx0ICAgICAgZXZlbnQkMShkb2N1bWVudC5ib2R5LCBlbnYubW91c2UudXAsIHRoaXMuX2JzX3VwLCB7XG5cdCAgICAgICAgYmluZDogdGhpc1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5fYmxvY2tfc2VsX2ZsYWcgPSB0aGlzLl9ic19yZWFkeSA9IHRoaXMuX2JzX3Byb2dyZXNzID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkFmdGVyU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl91cGRhdGVfYmxvY2tfc2VsZWN0aW9uKCk7XG5cdCAgICAgIH0pOyAvLyBhdXRvIHNjcm9sbFxuXG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIEF1dG9TY3JvbGwsIHRydWUpO1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVBdXRvU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnNfcHJvZ3Jlc3M7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfYmxvY2tfc2VsX2ZsYWc6IHRydWUsXG5cdCAgX2NoaWxkT2Y6IGZ1bmN0aW9uIChlLCB0YWcpIHtcblx0ICAgIHZhciBzcmMgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cblx0ICAgIHdoaWxlIChzcmMpIHtcblx0ICAgICAgaWYgKHNyYy5nZXRBdHRyaWJ1dGUgJiYgc3JjLmdldEF0dHJpYnV0ZShcIndlYml4aWdub3JlXCIpKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgIGlmIChzcmMgPT0gdGFnKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgc3JjID0gc3JjLnBhcmVudE5vZGU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9LFxuXHQgIF9ic19kb3duOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgLy8gZG8gbm90IGxpc3RlbiB0byBtb3VzZWRvd24gb2Ygc3VidmlldyBvbiBtYXN0ZXJcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zdWJ2aWV3ICYmIHRoaXMgIT0gJCQoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KSkgcmV0dXJuO1xuXG5cdCAgICBpZiAodGhpcy5fY2hpbGRPZihlLCB0aGlzLl9ib2R5KSkge1xuXHQgICAgICAvL2Rpc2FibGUgYmxvY2sgc2VsZWN0aW9uIHdoZW4gd2UgaGF2ZSBhbiBhY3RpdmUgZWRpdG9yXG5cdCAgICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC50YWdOYW1lID09IFwiSU5QVVRcIiB8fCB0aGlzLl9yc19wcm9jZXNzKSByZXR1cm47XG5cdCAgICAgIHRoaXMuX2JzX3Bvc2l0aW9uID0gb2Zmc2V0KHRoaXMuX2JvZHkpO1xuXHQgICAgICB2YXIgcG9zJCQxID0gcG9zKGUpO1xuXHQgICAgICB0aGlzLl9ic19yZWFkeSA9IFtwb3MkJDEueCAtIHRoaXMuX2JzX3Bvc2l0aW9uLngsIHBvcyQkMS55IC0gdGhpcy5fYnNfcG9zaXRpb24ueV07XG5cdCAgICAgIHByZXZlbnRFdmVudChlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9ic191cDogZnVuY3Rpb24gKGUpIHtcblx0ICAgIGlmICh0aGlzLl9ibG9ja19wYW5lbCkge1xuXHQgICAgICB0aGlzLl9ic19zZWxlY3QoXCJzZWxlY3RcIiwgdHJ1ZSwgZSk7XG5cblx0ICAgICAgdGhpcy5fYmxvY2tfcGFuZWwgPSByZW1vdmUodGhpcy5fYmxvY2tfcGFuZWwpO1xuXHQgICAgfVxuXG5cdCAgICByZW1vdmVDc3MoZG9jdW1lbnQuYm9keSwgXCJ3ZWJpeF9ub3NlbGVjdFwiKTtcblx0ICAgIHRoaXMuX2JzX3JlYWR5ID0gdGhpcy5fYnNfcHJvZ3Jlc3MgPSBmYWxzZTtcblx0ICAgIGlmICh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSkgdGhpcy5fYXV0b19zY3JvbGxfZGVsYXkgPSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5KTtcblx0ICB9LFxuXHQgIF91cGRhdGVfYmxvY2tfc2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fYnNfcHJvZ3Jlc3MpIHRoaXMuX2JzX3NlbGVjdChmYWxzZSwgZmFsc2UpO1xuXHQgIH0sXG5cdCAgX2JzX3NlbGVjdDogZnVuY3Rpb24gKG1vZGUsIHRoZWVuZCwgZSkge1xuXHQgICAgdmFyIHN0YXJ0ID0gbnVsbDtcblx0ICAgIGlmICghdGhpcy5fYnNfcmVhZHlbMl0pIHRoaXMuX2JzX3JlYWR5WzJdID0gdGhpcy5fbG9jYXRlX2NlbGxfeHkuYXBwbHkodGhpcywgdGhpcy5fYnNfcmVhZHkpO1xuXHQgICAgc3RhcnQgPSB0aGlzLl9ic19yZWFkeVsyXTtcblxuXHQgICAgdmFyIGVuZCA9IHRoaXMuX2xvY2F0ZV9jZWxsX3h5LmFwcGx5KHRoaXMsIHRoaXMuX2JzX3Byb2dyZXNzKTtcblxuXHQgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQmxvY2tTZWxlY3RcIiwgW3N0YXJ0LCBlbmQsIHRoZWVuZCwgZV0pKSByZXR1cm47XG5cblx0ICAgIGlmICgoIXRoaXMuX2JzX2RvX3NlbGVjdCB8fCB0aGlzLl9ic19kb19zZWxlY3Qoc3RhcnQsIGVuZCwgdGhlZW5kLCBlKSAhPT0gZmFsc2UpICYmIHN0YXJ0LnJvdyAmJiBlbmQucm93KSB7XG5cdCAgICAgIGlmIChtb2RlID09PSBcInNlbGVjdFwiKSB7XG5cdCAgICAgICAgdGhpcy5fY2xlYXJfc2VsZWN0aW9uKCk7XG5cblx0ICAgICAgICB0aGlzLl9zZWxlY3RSYW5nZShzdGFydCwgZW5kKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgc3RhcnR4LCBzdGFydHksIGVuZHgsIGVuZHk7XG5cblx0ICAgICAgICBpZiAobW9kZSA9PT0gXCJib3hcIikge1xuXHQgICAgICAgICAgc3RhcnR4ID0gTWF0aC5taW4odGhpcy5fYnNfcmVhZHlbMF0sIHRoaXMuX2JzX3Byb2dyZXNzWzBdKTtcblx0ICAgICAgICAgIGVuZHggPSBNYXRoLm1heCh0aGlzLl9ic19yZWFkeVswXSwgdGhpcy5fYnNfcHJvZ3Jlc3NbMF0pO1xuXHQgICAgICAgICAgc3RhcnR5ID0gTWF0aC5taW4odGhpcy5fYnNfcmVhZHlbMV0sIHRoaXMuX2JzX3Byb2dyZXNzWzFdKTtcblx0ICAgICAgICAgIGVuZHkgPSBNYXRoLm1heCh0aGlzLl9ic19yZWFkeVsxXSwgdGhpcy5fYnNfcHJvZ3Jlc3NbMV0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgc3RhcnRuID0gdGhpcy5fY2VsbFBvc2l0aW9uKHN0YXJ0LnJvdywgc3RhcnQuY29sdW1uKTtcblxuXHQgICAgICAgICAgdmFyIGVuZG4gPSB0aGlzLl9jZWxsUG9zaXRpb24oZW5kLnJvdywgZW5kLmNvbHVtbik7XG5cblx0ICAgICAgICAgIHZhciBzY3JvbGwgPSB0aGlzLmdldFNjcm9sbFN0YXRlKCk7XG5cdCAgICAgICAgICB2YXIgc3RhcnRXaWR0aCA9IHN0YXJ0bi53aWR0aDtcblx0ICAgICAgICAgIHZhciBlbmRXaWR0aCA9IGVuZG4ud2lkdGg7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl9yaWdodF93aWR0aCAmJiB0aGlzLl9ic19yZWFkeVswXSA+IHRoaXMuX2xlZnRfd2lkdGggKyB0aGlzLl9jZW50ZXJfd2lkdGgpIHtcblx0ICAgICAgICAgICAgc3RhcnRuLmxlZnQgKz0gdGhpcy5fbGVmdF93aWR0aCArIHRoaXMuX2NlbnRlcl93aWR0aDtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGVmdF93aWR0aCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fYnNfcmVhZHlbMF0gPiB0aGlzLl9sZWZ0X3dpZHRoKSB7XG5cdCAgICAgICAgICAgICAgaWYgKHN0YXJ0bi5sZWZ0IDwgc2Nyb2xsLngpIHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0V2lkdGggLT0gc2Nyb2xsLnggLSBzdGFydG4ubGVmdDtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0bi5sZWZ0ID0gdGhpcy5fbGVmdF93aWR0aDtcblx0ICAgICAgICAgICAgICB9IGVsc2Ugc3RhcnRuLmxlZnQgKz0gdGhpcy5fbGVmdF93aWR0aCAtIHNjcm9sbC54O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Ugc3RhcnRuLmxlZnQgLT0gc2Nyb2xsLng7XG5cblx0ICAgICAgICAgIGlmICh0aGlzLl9yaWdodF93aWR0aCAmJiB0aGlzLl9ic19wcm9ncmVzc1swXSA+IHRoaXMuX2xlZnRfd2lkdGggKyB0aGlzLl9jZW50ZXJfd2lkdGgpIHtcblx0ICAgICAgICAgICAgZW5kbi5sZWZ0ICs9IHRoaXMuX2xlZnRfd2lkdGggKyB0aGlzLl9jZW50ZXJfd2lkdGg7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xlZnRfd2lkdGgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2JzX3Byb2dyZXNzWzBdID4gdGhpcy5fbGVmdF93aWR0aCkge1xuXHQgICAgICAgICAgICAgIGlmIChlbmRuLmxlZnQgPCBzY3JvbGwueCkge1xuXHQgICAgICAgICAgICAgICAgZW5kV2lkdGggLT0gc2Nyb2xsLnggLSBlbmRuLmxlZnQ7XG5cdCAgICAgICAgICAgICAgICBlbmRuLmxlZnQgPSB0aGlzLl9sZWZ0X3dpZHRoO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBlbmRuLmxlZnQgKz0gdGhpcy5fbGVmdF93aWR0aCAtIHNjcm9sbC54O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2UgZW5kbi5sZWZ0IC09IHNjcm9sbC54O1xuXG5cdCAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MucHJlcmVuZGVyKSB7XG5cdCAgICAgICAgICAgIHN0YXJ0bi50b3AgLT0gdGhpcy5fc2Nyb2xsVG9wO1xuXHQgICAgICAgICAgICBlbmRuLnRvcCAtPSB0aGlzLl9zY3JvbGxUb3A7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHN0YXJ0eCA9IE1hdGgubWluKHN0YXJ0bi5sZWZ0LCBlbmRuLmxlZnQpO1xuXHQgICAgICAgICAgZW5keCA9IE1hdGgubWF4KHN0YXJ0bi5sZWZ0ICsgc3RhcnRXaWR0aCwgZW5kbi5sZWZ0ICsgZW5kV2lkdGgpO1xuXHQgICAgICAgICAgc3RhcnR5ID0gTWF0aC5taW4oc3RhcnRuLnRvcCwgZW5kbi50b3ApO1xuXHQgICAgICAgICAgZW5keSA9IE1hdGgubWF4KHN0YXJ0bi50b3AgKyBzdGFydG4uaGVpZ2h0LCBlbmRuLnRvcCArIGVuZG4uaGVpZ2h0KTtcblx0ICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCkgc3RhcnR5ICs9IHRoaXMuX2dldFRvcFNwbGl0T2Zmc2V0KHN0YXJ0KTtcblx0ICAgICAgICAgIGlmICh0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSkgdGhpcy5fYXV0b19zY3JvbGxfZGVsYXkgPSB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX2F1dG9fc2Nyb2xsX2RlbGF5KTtcblx0ICAgICAgICAgIGlmIChlKSB0aGlzLl9hdXRvX3Njcm9sbF9kZWxheSA9IGRlbGF5KHRoaXMuX2F1dG9fc2Nyb2xsLCB0aGlzLCBbcG9zKGUpXSwgMjUwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9ibG9ja19wYW5lbC5zdHlsZTtcblx0ICAgICAgICBzdHlsZS5sZWZ0ID0gc3RhcnR4ICsgXCJweFwiO1xuXHQgICAgICAgIHN0eWxlLnRvcCA9IHN0YXJ0eSArIFwicHhcIjtcblx0ICAgICAgICBzdHlsZS53aWR0aCA9IGVuZHggLSBzdGFydHggKyBcInB4XCI7XG5cdCAgICAgICAgc3R5bGUuaGVpZ2h0ID0gZW5keSAtIHN0YXJ0eSArIFwicHhcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhlZW5kKSB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJCbG9ja1NlbGVjdFwiLCBbc3RhcnQsIGVuZF0pO1xuXHQgIH0sXG5cdCAgX2JzX3N0YXJ0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9ibG9ja19wYW5lbCA9IGNyZWF0ZShcImRpdlwiLCB7XG5cdCAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF9ibG9ja19zZWxlY3Rpb25cIlxuXHQgICAgfSwgXCJcIik7XG5cblx0ICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQodGhpcy5fYmxvY2tfcGFuZWwpO1xuXHQgIH0sXG5cdCAgX2JzX21vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBpZiAodGhpcy5fYnNfcmVhZHkgIT09IGZhbHNlKSB7XG5cdCAgICAgIGlmICghdGhpcy5fYnNfcHJvZ3Jlc3MpIGFkZENzcyhkb2N1bWVudC5ib2R5LCBcIndlYml4X25vc2VsZWN0XCIpO1xuXHQgICAgICB2YXIgcG9zJCQxID0gcG9zKGUpO1xuXHQgICAgICB2YXIgcHJvZ3Jlc3MgPSBbcG9zJCQxLnggLSB0aGlzLl9ic19wb3NpdGlvbi54LCBwb3MkJDEueSAtIHRoaXMuX2JzX3Bvc2l0aW9uLnldOyAvL3ByZXZlbnQgdW5uZWNlc3NhcnkgYmxvY2sgc2VsZWN0aW9uIHdoaWxlIGRibC1jbGlja2luZ1xuXG5cdCAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9ic19yZWFkeVswXSAtIHByb2dyZXNzWzBdKSA8IDUgJiYgTWF0aC5hYnModGhpcy5fYnNfcmVhZHlbMV0gLSBwcm9ncmVzc1sxXSkgPCA1KSByZXR1cm47XG5cdCAgICAgIGlmICh0aGlzLl9ic19wcm9ncmVzcyA9PT0gZmFsc2UpIHRoaXMuX2JzX3N0YXJ0KGUpO1xuXHQgICAgICB0aGlzLl9ic19wcm9ncmVzcyA9IHByb2dyZXNzO1xuXG5cdCAgICAgIHRoaXMuX2JzX3NlbGVjdCh0aGlzLmNvbmZpZy5ibG9ja3NlbGVjdCwgZmFsc2UsIGUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2xvY2F0ZV9jZWxsX3h5OiBmdW5jdGlvbiAoeCwgeSkge1xuXHQgICAgdmFyIGluVG9wU3BsaXQgPSBmYWxzZSxcblx0ICAgICAgICByb3cgPSBudWxsLFxuXHQgICAgICAgIGNvbHVtbiA9IG51bGw7XG5cdCAgICBpZiAodGhpcy5fcmlnaHRfd2lkdGggJiYgeCA+IHRoaXMuX2xlZnRfd2lkdGggKyB0aGlzLl9jZW50ZXJfd2lkdGgpIHggKz0gdGhpcy5feF9zY3JvbGwuZ2V0U2l6ZSgpIC0gdGhpcy5fY2VudGVyX3dpZHRoIC0gdGhpcy5fbGVmdF93aWR0aCAtIHRoaXMuX3JpZ2h0X3dpZHRoO2Vsc2UgaWYgKCF0aGlzLl9sZWZ0X3dpZHRoIHx8IHggPiB0aGlzLl9sZWZ0X3dpZHRoKSB4ICs9IHRoaXMuX3hfc2Nyb2xsLmdldFNjcm9sbCgpO1xuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MudG9wU3BsaXQgJiYgdGhpcy5fcmVuZGVyX3Njcm9sbF90b3AgPiB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCkge1xuXHQgICAgICB2YXIgc3BsaXRQb3MgPSB0aGlzLl9jZWxsUG9zaXRpb24odGhpcy5nZXRJZEJ5SW5kZXgodGhpcy5fc2V0dGluZ3MudG9wU3BsaXQgLSAxKSwgdGhpcy5jb2x1bW5JZCgwKSk7XG5cblx0ICAgICAgaWYgKHNwbGl0UG9zLnRvcCArIHNwbGl0UG9zLmhlaWdodCA+IHkpIHtcblx0ICAgICAgICBpblRvcFNwbGl0ID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIWluVG9wU3BsaXQpIHkgKz0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpLnk7XG5cdCAgICBpZiAoeCA8IDApIHggPSAwO1xuXHQgICAgaWYgKHkgPCAwKSB5ID0gMDtcblx0ICAgIHZhciBjb2xzID0gdGhpcy5fc2V0dGluZ3MuY29sdW1ucztcblx0ICAgIHZhciByb3dzID0gdGhpcy5kYXRhLm9yZGVyO1xuXHQgICAgdmFyIHN1bW0gPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3VtbSArPSBjb2xzW2ldLndpZHRoO1xuXG5cdCAgICAgIGlmIChzdW1tID49IHgpIHtcblx0ICAgICAgICBjb2x1bW4gPSBjb2xzW2ldLmlkO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICghY29sdW1uKSBjb2x1bW4gPSBjb2xzW2NvbHMubGVuZ3RoIC0gMV0uaWQ7XG5cdCAgICBzdW1tID0gMDtcblx0ICAgIHZhciBzdGFydCA9IHRoaXMuZGF0YS4kbWluIHx8IDA7XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5maXhlZFJvd0hlaWdodCkge1xuXHQgICAgICByb3cgPSByb3dzW3N0YXJ0ICsgTWF0aC5mbG9vcih5IC8gdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0KV07XG5cdCAgICB9IGVsc2UgZm9yICh2YXIgX2kgPSBzdGFydDsgX2kgPCByb3dzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICBzdW1tICs9IHRoaXMuX2dldEhlaWdodEJ5SW5kZXgoX2kpO1xuXG5cdCAgICAgIGlmIChzdW1tID49IHkpIHtcblx0ICAgICAgICByb3cgPSByb3dzW19pXTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIXJvdykgcm93ID0gcm93c1tyb3dzLmxlbmd0aCAtIDFdO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgcm93OiByb3csXG5cdCAgICAgIGNvbHVtbjogY29sdW1uXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2dldFRvcFNwbGl0T2Zmc2V0OiBmdW5jdGlvbiAoY2VsbCwgYXJlYSkge1xuXHQgICAgdmFyIHkgPSAwLFxuXHQgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChjZWxsLnJvdyk7XG5cblx0ICAgIGlmIChzdGFydEluZGV4ID49IHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0KSB7XG5cdCAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuX2NlbGxQb3NpdGlvbih0aGlzLmdldElkQnlJbmRleChzdGFydEluZGV4KSwgY2VsbC5jb2x1bW4pO1xuXG5cdCAgICAgIHZhciBzcGxpdFBvcyA9IHRoaXMuX2NlbGxQb3NpdGlvbih0aGlzLmdldElkQnlJbmRleCh0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCAtIDEpLCBjZWxsLmNvbHVtbik7XG5cblx0ICAgICAgaWYgKHNwbGl0UG9zLnRvcCArIHNwbGl0UG9zLmhlaWdodCAtIHN0YXJ0UG9zLnRvcCA+IDApIHtcblx0ICAgICAgICB5ID0gc3BsaXRQb3MudG9wICsgc3BsaXRQb3MuaGVpZ2h0IC0gKHN0YXJ0UG9zLnRvcCA+IDAgfHwgIWFyZWEgPyBzdGFydFBvcy50b3AgOiAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4geTtcblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJDMgPSB7XG5cdCAgcmVzaXplUm93X3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB0aGlzLl9zZXR0aW5ncy5zY3JvbGxBbGlnblkgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3NldHRpbmdzLmZpeGVkUm93SGVpZ2h0ID0gZmFsc2U7XG5cdCAgICByZXR1cm4gdGhpcy5yZXNpemVDb2x1bW5fc2V0dGVyKHZhbHVlKTtcblx0ICB9LFxuXHQgIHJlc2l6ZUNvbHVtbl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlICYmIHRoaXMuX3JzX2luaXRfZmxhZykge1xuXHQgICAgICBfZXZlbnQodGhpcy5fdmlld29iaiwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fcnNfbW92ZSwge1xuXHQgICAgICAgIGJpbmQ6IHRoaXNcblx0ICAgICAgfSk7XG5cblx0ICAgICAgX2V2ZW50KHRoaXMuX3ZpZXdvYmosIFwibW91c2Vkb3duXCIsIHRoaXMuX3JzX2Rvd24sIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIF9ldmVudCh0aGlzLl92aWV3b2JqLCBcIm1vdXNldXBcIiwgdGhpcy5fcnNfdXAsIHtcblx0ICAgICAgICBiaW5kOiB0aGlzXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHRoaXMuX3JzX2luaXRfZmxhZyA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfcnNfaW5pdF9mbGFnOiB0cnVlLFxuXHQgIF9yc19kb3duOiBmdW5jdGlvbiAoZSkge1xuXHQgICAgLy8gZG8gbm90IGxpc3RlbiB0byBtb3VzZWRvd24gb2Ygc3VidmlldyBvbiBtYXN0ZXJcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zdWJ2aWV3ICYmIHRoaXMgIT0gJCQoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KSkgcmV0dXJuOyAvL2lmIG1vdXNlIHdhcyBuZWFyIGJvcmRlclxuXG5cdCAgICBpZiAoIXRoaXMuX3JzX3JlYWR5KSByZXR1cm47XG5cdCAgICB0aGlzLl9yc19wcm9jZXNzID0gW3BvcyhlKSwgdGhpcy5fcnNfcmVhZHlbMl1dO1xuXHQgICAgYWRkQ3NzKGRvY3VtZW50LmJvZHksIFwid2ViaXhfbm9zZWxlY3RcIik7XG5cdCAgICBkZW55U2VsZWN0KCk7XG5cdCAgfSxcblx0ICBfcnNfdXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3JzX3Byb2Nlc3MgPSBmYWxzZTtcblx0ICAgIHJlbW92ZUNzcyhkb2N1bWVudC5ib2R5LCBcIndlYml4X25vc2VsZWN0XCIpO1xuXHQgICAgYWxsb3dTZWxlY3QoKTtcblx0ICB9LFxuXHQgIF9yc19zdGFydDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3JzX3Byb2dyZXNzKSByZXR1cm47XG5cdCAgICB2YXIgZGlyID0gdGhpcy5fcnNfcmVhZHlbMF07XG5cdCAgICB2YXIgbm9kZSA9IHRoaXMuX3JzX3Byb2Nlc3NbMV07XG5cblx0ICAgIHZhciBvYmogPSB0aGlzLl9sb2NhdGUobm9kZSk7XG5cblx0ICAgIGlmICghb2JqKSByZXR1cm47XG5cdCAgICB2YXIgZXZlbnRQb3MgPSB0aGlzLl9yc19wcm9jZXNzWzBdO1xuXHQgICAgdmFyIHN0YXJ0O1xuXG5cdCAgICBpZiAoZGlyID09IFwieFwiKSB7XG5cdCAgICAgIHN0YXJ0ID0gb2Zmc2V0KG5vZGUpLnggKyB0aGlzLl9yc19yZWFkeVsxXSAtIG9mZnNldCh0aGlzLl9ib2R5KS54O1xuXHQgICAgICBldmVudFBvcyA9IGV2ZW50UG9zLng7XG5cdCAgICAgIGlmICghdGhpcy5fcnNfcmVhZHlbMV0pIG9iai5jaW5kIC09IG5vZGUucGFyZW50Tm9kZS5jb2xTcGFuIHx8IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdGFydCA9IG9mZnNldChub2RlKS55ICsgdGhpcy5fcnNfcmVhZHlbMV0gLSBvZmZzZXQodGhpcy5fYm9keSkueSArIHRoaXMuX2hlYWRlcl9oZWlnaHQ7XG5cdCAgICAgIGV2ZW50UG9zID0gZXZlbnRQb3MueTtcblx0ICAgICAgaWYgKCF0aGlzLl9yc19yZWFkeVsxXSkgb2JqLnJpbmQtLTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9iai5jaW5kID49IDAgJiYgb2JqLnJpbmQgPj0gMCkge1xuXHQgICAgICB0aGlzLl9yc19wcm9ncmVzcyA9IFtkaXIsIG9iaiwgc3RhcnRdO1xuXHQgICAgICB2YXIgcmVzaXplID0gbmV3IHVpLnJlc2l6ZWFyZWEoe1xuXHQgICAgICAgIGNvbnRhaW5lcjogdGhpcy5fdmlld29iaixcblx0ICAgICAgICBkaXI6IGRpcixcblx0ICAgICAgICBldmVudFBvczogZXZlbnRQb3MsXG5cdCAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgIGN1cnNvcjogKGRpciA9PSBcInhcIiA/IFwiY29sXCIgOiBcInJvd1wiKSArIFwiLXJlc2l6ZVwiXG5cdCAgICAgIH0pO1xuXHQgICAgICByZXNpemUuYXR0YWNoRXZlbnQoXCJvblJlc2l6ZUVuZFwiLCBiaW5kKHRoaXMuX3JzX2VuZCwgdGhpcykpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9yc19kb3duID0gdGhpcy5fcnNfcmVhZHkgPSBmYWxzZTtcblx0ICB9LFxuXHQgIF9yc19lbmQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgIGlmICh0aGlzLl9yc19wcm9ncmVzcykge1xuXHQgICAgICB2YXIgZGlyID0gdGhpcy5fcnNfcHJvZ3Jlc3NbMF07XG5cdCAgICAgIHZhciBvYmogPSB0aGlzLl9yc19wcm9ncmVzc1sxXTtcblx0ICAgICAgdmFyIG5ld3NpemUgPSByZXN1bHQgLSB0aGlzLl9yc19wcm9ncmVzc1syXTtcblxuXHQgICAgICBpZiAoZGlyID09IFwieFwiKSB7XG5cdCAgICAgICAgLy9pbiBjYXNlIG9mIHJpZ2h0IHNwbGl0IC0gZGlmZmVyZW50IHNpemluZyBsb2dpYyBhcHBsaWVkXG5cdCAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnJpZ2h0U3BsaXQgJiYgb2JqLmNpbmQgKyAxID49IHRoaXMuX3JpZ2h0U3BsaXQgJiYgb2JqLmNpbmQgIT09IHRoaXMuX2NvbHVtbnMubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgICAgb2JqLmNpbmQrKztcblx0ICAgICAgICAgIG5ld3NpemUgKj0gLTE7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuX2NvbHVtbnNbb2JqLmNpbmRdO1xuXHQgICAgICAgIHZhciBvbGR3aWR0aCA9IGNvbHVtbi53aWR0aDtcblx0ICAgICAgICBkZWxldGUgY29sdW1uLmZpbGxzcGFjZTtcblx0ICAgICAgICBkZWxldGUgY29sdW1uLmFkanVzdDtcblxuXHQgICAgICAgIHRoaXMuX3NldENvbHVtbldpZHRoKG9iai5jaW5kLCBvbGR3aWR0aCArIG5ld3NpemUsIHRydWUsIHRydWUpO1xuXG5cdCAgICAgICAgdGhpcy5fdXBkYXRlQ29sc1NpemVTZXR0aW5ncygpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciByaWQgPSB0aGlzLmdldElkQnlJbmRleChvYmoucmluZCk7XG5cblx0ICAgICAgICB2YXIgb2xkaGVpZ2h0ID0gdGhpcy5fZ2V0Um93SGVpZ2h0KHRoaXMuZ2V0SXRlbShyaWQpKTtcblxuXHQgICAgICAgIHRoaXMuc2V0Um93SGVpZ2h0KHJpZCwgb2xkaGVpZ2h0ICsgbmV3c2l6ZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9yc191cCgpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9yc19wcm9ncmVzcyA9IG51bGw7XG5cdCAgfSxcblx0ICBfcnNfbW92ZTogZnVuY3Rpb24gKGUpIHtcblx0ICAgIHZhciBjZWxsID0gbnVsbCxcblx0ICAgICAgICBjb25maWcgPSB0aGlzLl9zZXR0aW5ncztcblx0ICAgIGlmICh0aGlzLl9yc19yZWFkeSAmJiB0aGlzLl9yc19wcm9jZXNzKSByZXR1cm4gdGhpcy5fcnNfc3RhcnQoZSk7XG5cdCAgICBlID0gZSB8fCBldmVudDtcblx0ICAgIHZhciBub2RlID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXHQgICAgdmFyIG1vZGUgPSBmYWxzZTsgLy9yZXNpemUgcmVhZHkgZmxhZ1xuXG5cdCAgICBpZiAobm9kZS50YWdOYW1lID09IFwiVERcIiB8fCBub2RlLnRhZ05hbWUgPT0gXCJUQUJMRVwiKSByZXR1cm47XG5cdCAgICB2YXIgZWxlbWVudF9jbGFzcyA9IG5vZGUuY2xhc3NOYW1lIHx8IFwiXCI7XG5cdCAgICB2YXIgaW5fYm9keSA9IHR5cGVvZiBlbGVtZW50X2NsYXNzID09PSBcInN0cmluZ1wiICYmIGVsZW1lbnRfY2xhc3MuaW5kZXhPZihcIndlYml4X2NlbGxcIikgIT0gLTE7IC8vaWdub3JlIHJlc2l6ZSBpbiBjYXNlIG9mIGRyYWctbi1kcm9wIGVuYWJsZWRcblxuXHQgICAgaWYgKGluX2JvZHkgJiYgY29uZmlnLmRyYWcpIHJldHVybjtcblx0ICAgIHZhciBpbl9oZWFkZXIgPSB0eXBlb2YgZWxlbWVudF9jbGFzcyA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtZW50X2NsYXNzLmluZGV4T2YoXCJ3ZWJpeF9oY2VsbFwiKSAhPSAtMTtcblx0ICAgIHRoaXMuX3JzX3JlYWR5ID0gZmFsc2U7XG5cblx0ICAgIGlmIChpbl9ib2R5IHx8IGluX2hlYWRlcikge1xuXHQgICAgICB2YXIgZHggPSBub2RlLm9mZnNldFdpZHRoO1xuXHQgICAgICB2YXIgZHkgPSBub2RlLm9mZnNldEhlaWdodDtcblx0ICAgICAgdmFyIHBvcyQkMSA9IHBvc1JlbGF0aXZlKGUpO1xuXHQgICAgICB2YXIgcmVzaXplUm93ID0gY29uZmlnLnJlc2l6ZVJvdzsgLy8gaWYgcmVzaXplIGlzIG9ubHkgd2l0aGluIHRoZSBmaXJzdCBjb2x1bW5cblxuXHQgICAgICBpZiAoX3R5cGVvZihyZXNpemVSb3cpID09IFwib2JqZWN0XCIgJiYgcmVzaXplUm93LmhlYWRlck9ubHkpIHtcblx0ICAgICAgICBjZWxsID0gdGhpcy5fbG9jYXRlKG5vZGUpO1xuXHQgICAgICAgIGlmIChjZWxsLmNpbmQgPiAwKSByZXNpemVSb3cgPSBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpbl9ib2R5ICYmIHJlc2l6ZVJvdykge1xuXHQgICAgICAgIHJlc2l6ZVJvdyA9IF90eXBlb2YocmVzaXplUm93KSA9PSBcIm9iamVjdFwiICYmIHJlc2l6ZVJvdy5zaXplID8gcmVzaXplUm93LnNpemUgOiAzO1xuXG5cdCAgICAgICAgaWYgKHBvcyQkMS55IDwgcmVzaXplUm93KSB7XG5cdCAgICAgICAgICBpZiAoIWNlbGwpIGNlbGwgPSB0aGlzLl9sb2NhdGUobm9kZSk7IC8vIGF2b2lkIHJlc2l6ZSBoZWFkZXIgYm9yZGVyXG5cblx0ICAgICAgICAgIGlmIChjZWxsLnJpbmQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcnNfcmVhZHkgPSBbXCJ5XCIsIDAsIG5vZGVdO1xuXHQgICAgICAgICAgICBtb2RlID0gXCJyb3ctcmVzaXplXCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChkeSAtIHBvcyQkMS55IDwgcmVzaXplUm93ICsgMSkge1xuXHQgICAgICAgICAgdGhpcy5fcnNfcmVhZHkgPSBbXCJ5XCIsIGR5LCBub2RlXTtcblx0ICAgICAgICAgIG1vZGUgPSBcInJvdy1yZXNpemVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcmVzaXplQ29sdW1uID0gY29uZmlnLnJlc2l6ZUNvbHVtbjsgLy8gaWYgcmVzaXplIGlzIG9ubHkgd2l0aGluIHRoZSBoZWFkZXJcblxuXHQgICAgICBpZiAoX3R5cGVvZihyZXNpemVDb2x1bW4pID09IFwib2JqZWN0XCIgJiYgcmVzaXplQ29sdW1uLmhlYWRlck9ubHkgJiYgaW5fYm9keSkgcmVzaXplQ29sdW1uID0gZmFsc2U7XG5cblx0ICAgICAgaWYgKHJlc2l6ZUNvbHVtbikge1xuXHQgICAgICAgIHJlc2l6ZUNvbHVtbiA9IF90eXBlb2YocmVzaXplQ29sdW1uKSA9PSBcIm9iamVjdFwiICYmIHJlc2l6ZUNvbHVtbi5zaXplID8gcmVzaXplQ29sdW1uLnNpemUgOiAzO1xuXG5cdCAgICAgICAgaWYgKHBvcyQkMS54IDwgcmVzaXplQ29sdW1uKSB7XG5cdCAgICAgICAgICB0aGlzLl9yc19yZWFkeSA9IFtcInhcIiwgMCwgbm9kZV07XG5cdCAgICAgICAgICBtb2RlID0gXCJjb2wtcmVzaXplXCI7XG5cdCAgICAgICAgfSBlbHNlIGlmIChkeCAtIHBvcyQkMS54IDwgcmVzaXplQ29sdW1uICsgMSkge1xuXHQgICAgICAgICAgdGhpcy5fcnNfcmVhZHkgPSBbXCJ4XCIsIGR4LCBub2RlXTtcblx0ICAgICAgICAgIG1vZGUgPSBcImNvbC1yZXNpemVcIjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gLy9tYXJrIG9yIHVubWFyayByZXNpemluZyByZWFkeSBzdGF0ZVxuXG5cblx0ICAgIGlmICh0aGlzLl9jdXJzb3JfdGltZXIpIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yX3RpbWVyKTtcblx0ICAgIHRoaXMuX2N1cnNvcl90aW1lciA9IGRlbGF5KHRoaXMuX21hcmtfcmVzaXplX3JlYWR5LCB0aGlzLCBbbW9kZV0sIG1vZGUgPyAxMDAgOiAwKTtcblx0ICB9LFxuXHQgIF9tYXJrX3Jlc2l6ZV9yZWFkeTogZnVuY3Rpb24gKG1vZGUpIHtcblx0ICAgIGlmICh0aGlzLl9sYXN0X2N1cnNvcl9tb2RlICE9IG1vZGUpIHtcblx0ICAgICAgdGhpcy5fbGFzdF9jdXJzb3JfbW9kZSA9IG1vZGU7XG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc3R5bGUuY3Vyc29yID0gbW9kZSB8fCBcImRlZmF1bHRcIjtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0YXR0YWNoRXZlbnQoXCJvbkRhdGFUYWJsZVwiLCBmdW5jdGlvbiAodGFibGUsIGNvbmZpZykge1xuXHQgIGlmIChlbnYudG91Y2gpIHtcblx0ICAgIFRvdWNoLiRpbml0KCk7XG5cdCAgICBjb25maWcuc2Nyb2xsU2l6ZSA9IDA7IC8vIG5lZWRlZCB0byBzaG93IGRhdGF0YWJsZSBzY3JvbGxcblxuXHQgICAgaWYgKFRvdWNoLl9kaXNhYmxlZCkgVG91Y2gubGltaXQoKTtcblx0ICAgIHRhYmxlLiRyZWFkeS5wdXNoKHRhYmxlLiR0b3VjaCk7XG5cdCAgfVxuXHR9KTtcblx0dmFyIE1peGluJDQgPSB7XG5cdCAgJHRvdWNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3M7XG5cdCAgICBjb25maWcuc2Nyb2xsQWxpZ25ZID0gZmFsc2U7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBjb25maWcucHJlcmVuZGVyID09PSB0cnVlID8gdGhpcy5fdG91Y2hOYXRpdmUgOiB0aGlzLl90b3VjaCk7XG5cdCAgICB2YXIgc2Nyb2xsTW9kZSA9IFwiXCI7XG5cdCAgICBpZiAoIWNvbmZpZy5hdXRvd2lkdGggJiYgY29uZmlnLnNjcm9sbFggIT09IGZhbHNlKSBzY3JvbGxNb2RlICs9IFwieFwiO1xuXHQgICAgaWYgKCFjb25maWcuYXV0b2hlaWdodCAmJiBjb25maWcuc2Nyb2xsWSAhPT0gZmFsc2UpIHNjcm9sbE1vZGUgKz0gXCJ5XCI7XG5cblx0ICAgIHRoaXMuX2JvZHkuc2V0QXR0cmlidXRlKFwidG91Y2hfc2Nyb2xsXCIsIHNjcm9sbE1vZGUpO1xuXG5cdCAgICBUb3VjaC5faW5pdF9zY3JvbGxfbm9kZSh0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMV0uZmlyc3RDaGlsZCk7XG5cblx0ICAgIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2JvZHkuY2hpbGROb2Rlc1sxXS5maXJzdENoaWxkLCAwLCAwLCBcIjBtc1wiKTtcblxuXHQgICAgdGhpcy5fc3luY19zY3JvbGwoMCwgMCwgXCIwbXNcIik7XG5cdCAgfSxcblx0ICBfdG91Y2hOYXRpdmU6IHtcblx0ICAgIF9zY3JvbGxUb190b3VjaDogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgICAgVG91Y2guX3NldF9tYXRyaXgodGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQsIC14LCAteSwgXCIwbXNcIik7XG5cblx0ICAgICAgdGhpcy5fc3luY19zY3JvbGwoLXgsIC15LCBcIjBtc1wiKTtcblx0ICAgIH0sXG5cdCAgICBfZ2V0U2Nyb2xsU3RhdGVfdG91Y2g6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHRlbXAgPSBUb3VjaC5fZ2V0X21hdHJpeCh0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMV0uZmlyc3RDaGlsZCk7XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB4OiAtdGVtcC5lLFxuXHQgICAgICAgIHk6IC10ZW1wLmZcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVTY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvdWNoLl9zY3JvbGxfbm9kZSA9IHRoaXMuX2JvZHkuY2hpbGROb2Rlc1sxXS5maXJzdENoaWxkO1xuXG5cdCAgICAgICAgVG91Y2guX2dldF9zaXplcyhUb3VjaC5fc2Nyb2xsX25vZGUpO1xuXG5cdCAgICAgICAgVG91Y2guX3Njcm9sbF9tYXN0ZXIgPSB0aGlzO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uVG91Y2hFbmRcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvdWNoLl9zY3JvbGxfbWFzdGVyID0gbnVsbDtcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXHQgICAgX3N5bmNfc2Nyb2xsOiBmdW5jdGlvbiAoeCwgeSwgdCkge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0KSBUb3VjaC5fc2V0X21hdHJpeCh0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMF0uZmlyc3RDaGlsZCwgMCwgeSwgdCk7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5yaWdodFNwbGl0KSBUb3VjaC5fc2V0X21hdHJpeCh0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMl0uZmlyc3RDaGlsZCwgMCwgeSwgdCk7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5oZWFkZXIpIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2hlYWRlci5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQsIHgsIDAsIHQpO1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuZm9vdGVyKSBUb3VjaC5fc2V0X21hdHJpeCh0aGlzLl9mb290ZXIuY2hpbGROb2Rlc1sxXS5maXJzdENoaWxkLCB4LCAwLCB0KTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN5bmNTY3JvbGxcIiwgW3gsIHksIHRdKTtcblx0ICAgIH0sXG5cdCAgICBfc3luY19wb3M6IGZ1bmN0aW9uICgpIHt9XG5cdCAgfSxcblx0ICBfdG91Y2g6IHtcblx0ICAgIF9zY3JvbGxUb190b3VjaDogZnVuY3Rpb24gKHgsIHkpIHtcblx0ICAgICAgZGVsYXkoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlclNjcm9sbFwiLCBbe1xuXHQgICAgICAgICAgZTogLXgsXG5cdCAgICAgICAgICBmOiAteVxuXHQgICAgICAgIH1dKTtcblx0ICAgICAgfSwgdGhpcyk7XG5cdCAgICB9LFxuXHQgICAgJHNjcm9sbDoge1xuXHQgICAgICBncmF2aXR5OiAwLFxuXHQgICAgICBlbGFzdGljOiBmYWxzZVxuXHQgICAgfSxcblx0ICAgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vaWYgdGhlIHJlc3VsdCBjb2x1bW4ncyB3aWR0aCA8IGNvbnRhaW5lcidzIHdpZHRoLFxuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlckNvbHVtbkhpZGVcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3Njcm9sbFRvX3RvdWNoKDAsIDApO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQmVmb3JlU2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdCA9IFRvdWNoO1xuXHQgICAgICAgIHQuX3Njcm9sbF9ub2RlID0gdGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQ7XG5cblx0ICAgICAgICB0Ll9nZXRfc2l6ZXModC5fc2Nyb2xsX25vZGUpO1xuXG5cdCAgICAgICAgdC5fc2Nyb2xsX3N0YXQubGVmdCA9IHRoaXMuX3Njcm9sbExlZnQ7XG5cdCAgICAgICAgdC5fc2Nyb2xsX3N0YXQuaGlkZGVuID0gdGhpcy5feF9zY3JvbGwuX3NldHRpbmdzLnNjcm9sbFZpc2libGUgfHwgdGhpcy5feV9zY3JvbGwuX3NldHRpbmdzLnNjcm9sbFZpc2libGU7XG5cdCAgICAgICAgdC5fc2Nyb2xsX3N0YXQuZHkgPSB0aGlzLl9kdGFibGVfaGVpZ2h0O1xuXHQgICAgICAgIHQuX3Njcm9sbF9tYXN0ZXIgPSB0aGlzO1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJTY3JvbGxcIiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgIC8vb25BZnRlclNjcm9sbCBtYXkgYmUgdHJpZ2dlcmVkIGJ5IHNvbWUgbm9uLXRvdWNoIHJlbGF0ZWQgbG9naWNcblx0ICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xuXHQgICAgICAgIHZhciBpc1Njcm9sbFggPSB0aGlzLl9zY3JvbGxMZWZ0ICE9IC1yZXN1bHQuZTtcblx0ICAgICAgICB2YXIgaXNTY3JvbGxZID0gdGhpcy5fc2Nyb2xsVG9wICE9IC1yZXN1bHQuZjtcblx0ICAgICAgICBUb3VjaC5fc2Nyb2xsX21hc3RlciA9IG51bGw7XG5cdCAgICAgICAgVG91Y2guX2ZpeF9mID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSAwO1xuXHQgICAgICAgIHRoaXMuX3Njcm9sbExlZnQgPSAwOyAvL2lwYWQgY2FuIGRlbGF5IGNvbnRlbnQgcmVuZGVyaW5nIGlmIDNkIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWRcblx0ICAgICAgICAvL3N3aXRjaCBiYWNrIHRvIDJkXG5cblx0ICAgICAgICB2YXIgdGVtcCA9IFRvdWNoLmNvbmZpZy50cmFuc2xhdGU7XG5cdCAgICAgICAgVG91Y2guY29uZmlnLnRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlXCI7XG5cblx0ICAgICAgICB0aGlzLl9zeW5jX3Njcm9sbCh0aGlzLl94X3Njcm9sbCA/IDAgOiByZXN1bHQuZSwgMCwgXCIwbXNcIik7XG5cblx0ICAgICAgICBUb3VjaC5jb25maWcudHJhbnNsYXRlID0gdGVtcDtcblx0ICAgICAgICB0aGlzLl9zY3JvbGxMZWZ0ID0gLXJlc3VsdC5lO1xuXHQgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IC1yZXN1bHQuZjtcblxuXHQgICAgICAgIHRoaXMuX2NvcnJlY3RTY3JvbGxTaXplKCk7XG5cblx0ICAgICAgICB0aGlzLnJlbmRlcigpO1xuXG5cdCAgICAgICAgaWYgKGlzU2Nyb2xsWCkge1xuXHQgICAgICAgICAgaWYgKHRoaXMuX3hfc2Nyb2xsKSB0aGlzLl94X3Njcm9sbC5zY3JvbGxUbyh0aGlzLl9zY3JvbGxMZWZ0KTtcblx0ICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TY3JvbGxYXCIsIFtdKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNTY3JvbGxZKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5feV9zY3JvbGwpIHRoaXMuX3lfc2Nyb2xsLnNjcm9sbFRvKHRoaXMuX3Njcm9sbFRvcCk7XG5cdCAgICAgICAgICB0aGlzLmNhbGxFdmVudChcIm9uU2Nyb2xsWVwiLCBbXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICBfc3luY19zY3JvbGw6IGZ1bmN0aW9uICh4LCB5LCB0KSB7XG5cdCAgICAgIHkgKz0gdGhpcy5fc2Nyb2xsVG9wO1xuXHQgICAgICB4ICs9IHRoaXMuX3Njcm9sbExlZnQ7XG5cblx0ICAgICAgVG91Y2guX3NldF9tYXRyaXgodGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQsIHgsIHksIHQpO1xuXG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQpIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2JvZHkuY2hpbGROb2Rlc1swXS5maXJzdENoaWxkLCAwLCB5LCB0KTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnJpZ2h0U3BsaXQpIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2JvZHkuY2hpbGROb2Rlc1syXS5maXJzdENoaWxkLCAwLCB5LCB0KTtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWRlcikgVG91Y2guX3NldF9tYXRyaXgodGhpcy5faGVhZGVyLmNoaWxkTm9kZXNbMV0uZmlyc3RDaGlsZCwgeCwgMCwgdCk7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5mb290ZXIpIFRvdWNoLl9zZXRfbWF0cml4KHRoaXMuX2Zvb3Rlci5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQsIHgsIDAsIHQpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uU3luY1Njcm9sbFwiLCBbeCwgeSwgdF0pO1xuXHQgICAgfSxcblx0ICAgIF9zeW5jX3BvczogZnVuY3Rpb24gKG1hdHJpeCkge1xuXHQgICAgICBtYXRyaXguZiAtPSB0aGlzLl9zY3JvbGxUb3A7XG5cdCAgICAgIG1hdHJpeC5lIC09IHRoaXMuX3Njcm9sbExlZnQ7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXG5cdHZhciBNaXhpbiQ1ID0ge1xuXHQgICRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICBpZiAoIWlkKSB0aGlzLl9hZGp1c3RDb2x1bW5zKCk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TdHJ1Y3R1cmVMb2FkXCIsIHRoaXMuX2FkanVzdENvbHVtbnMpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU3RydWN0dXJlVXBkYXRlXCIsIHRoaXMuX3Jlc2l6ZUNvbHVtbnMpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQ29sdW1uUmVzaXplXCIsIGZ1bmN0aW9uIChhLCBiLCBjLCB1c2VyKSB7XG5cdCAgICAgIGlmICh1c2VyKSB0aGlzLl9yZXNpemVDb2x1bW5zKCk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvblJlc2l6ZVwiLCB0aGlzLl9yZXNpemVDb2x1bW5zKTtcblx0ICB9LFxuXHQgIF9hZGp1c3RDb2x1bW5zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgcmVzaXplID0gZmFsc2U7XG5cdCAgICB2YXIgY29scyA9IHRoaXMuX2NvbHVtbnM7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29scy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoY29sc1tpXS5hZGp1c3QgJiYgKGNvbHNbaV0uYWRqdXN0ID09IFwiaGVhZGVyXCIgfHwgdGhpcy5jb3VudCgpKSkgcmVzaXplID0gdGhpcy5fYWRqdXN0Q29sdW1uKGksIGNvbHNbaV0uYWRqdXN0LCB0cnVlKSB8fCByZXNpemU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXNpemUpIHtcblx0ICAgICAgdGhpcy5fdXBkYXRlQ29sc1NpemVTZXR0aW5ncyh0cnVlKTtcblxuXHQgICAgICB0aGlzLl9yZXNpemVDb2x1bW5zKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfcmVzaXplQ29sdW1uczogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNvbHMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zO1xuXHQgICAgdmFyIGZpbGwgPSBbXTtcblx0ICAgIHZhciBzdW1tID0gMDtcblx0ICAgIGlmIChjb2xzICYmICF0aGlzLl9zZXR0aW5ncy5hdXRvd2lkdGgpIGZvciAodmFyIGkgPSAwOyBpIDwgY29scy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY29sZmlsID0gY29sc1tpXS5maWxsc3BhY2U7XG5cblx0ICAgICAgaWYgKGNvbGZpbCkge1xuXHQgICAgICAgIGZpbGxbaV0gPSBjb2xmaWw7XG5cdCAgICAgICAgc3VtbSArPSBjb2xmaWwgKiAxIHx8IDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChzdW1tKSB0aGlzLl9maWxsQ29sdW1uU2l6ZShmaWxsLCBzdW1tKTtcblx0ICB9LFxuXHQgIF9maWxsQ29sdW1uU2l6ZTogZnVuY3Rpb24gKGZpbGwsIHN1bW0pIHtcblx0ICAgIHZhciBjb2xzID0gdGhpcy5fc2V0dGluZ3MuY29sdW1ucztcblx0ICAgIGlmICghY29scykgcmV0dXJuO1xuXHQgICAgdmFyIHdpZHRoID0gdGhpcy5fY29udGVudF93aWR0aCAtIHRoaXMuX3Njcm9sbFNpemVZO1xuXHQgICAgdmFyIHJlc2l6ZSA9IGZhbHNlO1xuXG5cdCAgICBpZiAod2lkdGggPiAwKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29scy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmICghZmlsbFtpXSkgd2lkdGggLT0gY29sc1tpXS53aWR0aCB8fCB0aGlzLmNvbmZpZy5jb2x1bW5XaWR0aDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmaWxsLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIGlmIChmaWxsW19pXSkge1xuXHQgICAgICAgICAgdmFyIHJlcXVlc3QgPSBNYXRoLm1pbih3aWR0aCwgTWF0aC5yb3VuZCh3aWR0aCAqIGZpbGxbX2ldIC8gc3VtbSkpO1xuXHQgICAgICAgICAgcmVzaXplID0gdGhpcy5fc2V0Q29sdW1uV2lkdGgoX2ksIHJlcXVlc3QsIHRydWUpIHx8IHJlc2l6ZTtcblx0ICAgICAgICAgIHdpZHRoID0gd2lkdGggLSBjb2xzW19pXS53aWR0aDtcblx0ICAgICAgICAgIHN1bW0gPSBzdW1tIC0gZmlsbFtfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHJlc2l6ZSkgdGhpcy5fdXBkYXRlQ29sc1NpemVTZXR0aW5ncyh0cnVlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9nZXRDb2x1bW5Db25maWdTaXplOiBmdW5jdGlvbiAoaW5kLCBoZWFkZXJzKSB7XG5cdCAgICB2YXIgY29uZmlnID0gdGhpcy5fc2V0dGluZ3MuY29sdW1uc1tpbmRdO1xuXHQgICAgdmFyIG1heCA9IGNvbmZpZy5taW5Db2x1bW5XaWR0aCB8fCAxMDsgLy9nZXQgbWF4IGRhdGEgd2lkdGhcblxuXHQgICAgaWYgKGhlYWRlcnMgIT0gXCJoZWFkZXJcIikge1xuXHQgICAgICB2YXIgY291bnQgPSB0aGlzLmRhdGEub3JkZXIubGVuZ3RoO1xuXHQgICAgICBpZiAoY29uZmlnLmFkanVzdEJhdGNoICYmIGNvbmZpZy5hZGp1c3RCYXRjaCA8IGNvdW50KSBjb3VudCA9IGNvbmZpZy5hZGp1c3RCYXRjaDtcblx0ICAgICAgdmFyIG9yZGVyID0gdGhpcy5kYXRhLm9yZGVyLnNsaWNlKDAsIGNvdW50KTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBvcmRlcltpXSA9IG9yZGVyW2ldID8gdGhpcy5fZ2V0VmFsdWUodGhpcy5nZXRJdGVtKG9yZGVyW2ldKSwgY29uZmlnLCAwKSA6IFwiXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGdldFRleHRTaXplKG9yZGVyLCBcIndlYml4X3RhYmxlX2NlbGwgd2ViaXhfY2VsbFwiKS53aWR0aCk7XG5cdCAgICB9IC8vZ2V0IG1heCBoZWFkZXIgd2lkdGhcblxuXG5cdCAgICBpZiAoaGVhZGVycyAhPSBcImRhdGFcIikge1xuXHQgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjb25maWcuaGVhZGVyLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICB2YXIgaGVhZGVyID0gY29uZmlnLmhlYWRlcltfaTJdO1xuXG5cdCAgICAgICAgaWYgKGhlYWRlcikge1xuXHQgICAgICAgICAgdmFyIHdpZHRoID0gMDtcblx0ICAgICAgICAgIGlmIChoZWFkZXIucm90YXRlKSBmb3IgKHZhciBoID0gMDsgaCA8IChoZWFkZXIucm93c3BhbiB8fCAxKTsgaCsrKSB7XG5cdCAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuX2hlYWRlcnNbaF07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB2YXIgY3NzID0gXCJ3ZWJpeF90YWJsZV9jZWxsIHdlYml4X2NlbGwgXCIgKyAoaGVhZGVyLmNzcyB8fCBcIlwiKSArIChoZWFkZXIucm90YXRlID8gXCJ3ZWJpeF9tZWFzdXJlX3JvdGF0ZVwiIDogXCJcIik7XG5cdCAgICAgICAgICB2YXIgc2l6ZSA9IGdldFRleHRTaXplKFtoZWFkZXIudGV4dF0sIGNzcywgd2lkdGgpO1xuXHQgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBoZWFkZXIucm90YXRlID8gc2l6ZS5oZWlnaHQgOiBzaXplLndpZHRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY29uZmlnLnNvcnQpIG1heCArPSAxMDsgLy8gYWRkIDEwcHggZm9yIHNvcnQgbWFya2VyXG5cdCAgICB9IC8vMXB4IHRvIGNvbXBlbnNhdGUgb2Zmc2V0V2lkdGggcm91bmRpbmdcblxuXG5cdCAgICByZXR1cm4gbWF4ICsgMSArIChlbnYuaXNJRSA/ICRhY3RpdmUubGF5b3V0UGFkZGluZy5zcGFjZSA6IDApO1xuXHQgIH0sXG5cdCAgX2FkanVzdENvbHVtbjogZnVuY3Rpb24gKGluZCwgaGVhZGVycywgaWdub3JlKSB7XG5cdCAgICBpZiAoaW5kID49IDApIHtcblx0ICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0Q29sdW1uQ29uZmlnU2l6ZShpbmQsIGhlYWRlcnMpO1xuXG5cdCAgICAgIHJldHVybiB0aGlzLl9zZXRDb2x1bW5XaWR0aChpbmQsIHdpZHRoLCBpZ25vcmUpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgYWRqdXN0Q29sdW1uOiBmdW5jdGlvbiAoaWQsIGhlYWRlcnMpIHtcblx0ICAgIHRoaXMuX2FkanVzdENvbHVtbih0aGlzLmdldENvbHVtbkluZGV4KGlkKSwgaGVhZGVycyk7XG5cdCAgfSxcblx0ICBhZGp1c3RSb3dIZWlnaHQ6IGZ1bmN0aW9uIChpZCwgc2lsZW50KSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICBpZiAoaWQpIHtcblx0ICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGlkKTtcblx0ICAgICAgdmFyIGNvbnRhaW5lcjtcblx0ICAgICAgdmFyIGQgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICAgIFwiY2xhc3NcIjogXCJ3ZWJpeF90YWJsZV9jZWxsIHdlYml4X21lYXN1cmVfc2l6ZSB3ZWJpeF9jZWxsXCJcblx0ICAgICAgfSwgXCJcIik7XG5cdCAgICAgIGQuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6XCIgKyBjb25maWcud2lkdGggKyBcInB4OyBoZWlnaHQ6MXB4OyB2aXNpYmlsaXR5OmhpZGRlbjsgcG9zaXRpb246YWJzb2x1dGU7IHRvcDowcHg7IGxlZnQ6MHB4OyBvdmVyZmxvdzpoaWRkZW47XCI7XG5cdCAgICAgIHRoaXMuJHZpZXcuYXBwZW5kQ2hpbGQoZCk7XG5cblx0ICAgICAgaWYgKGQub2Zmc2V0SGVpZ2h0IDwgMSkge1xuXHQgICAgICAgIC8vaGlkZGVuIGNvbnRhaW5lciwgaGVpZ2h0IGRldGVjdGlvbiBpcyBicm9rZW5cblx0ICAgICAgICAvL3JlYXR0YWNoIHRvIHRoZSBib2R5XG5cdCAgICAgICAgY29udGFpbmVyID0gdGhpcy4kdmlldy5jbG9uZU5vZGUodHJ1ZSk7XG5cdCAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHQgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICBkLmlubmVySFRNTCA9IHRoaXMuX2dldFZhbHVlKG9iaiwgY29uZmlnLCAwKTtcblx0ICAgICAgICBvYmouJGhlaWdodCA9IE1hdGgubWF4KGQuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9zZXR0aW5ncy5yb3dIZWlnaHQpO1xuXHQgICAgICB9LCB0aGlzKTtcblx0ICAgICAgZCA9IHJlbW92ZShkKTtcblx0ICAgICAgaWYgKGNvbnRhaW5lcikgcmVtb3ZlKGNvbnRhaW5lcik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvL3NldCBzaXplIG9mIGFycmF5IGJhc2VkIG9uIGRhdGEgc2l6ZVxuXHQgICAgICAvL2NhbiBiZSBub3QtcmVsaWFibGUgZm9yIHRyZWUtbGlrZSBjb21wb25lbnRzIGFueXdheVxuXHQgICAgICB2YXIgaGVpZ2h0c0FyciA9IG5ldyBBcnJheSh0aGlzLmRhdGEub3JkZXIubGVuZ3RoKTtcblx0ICAgICAgdmFyIGNvbHMgPSB0aGlzLmNvbmZpZy5jb2x1bW5zOyAvL3NldCAwIGFzIGluaXRpYWwgaGVpZ2h0XG5cblx0ICAgICAgdmFyIGogPSAwOyAvL2l0ZXJhdGUgdGhyb3VnaCBhbGwgcG9zc2libGUgaXRlbXNcblx0ICAgICAgLy93ZSBuZWVkIHRvIGJlIHN1cmUgdGhhdCBoZWlnaHRzQXJyIGlzIG5vdCBsZXNzZXIgdGhhbiByZWFsIGRhdGEgY291bnRcblxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhLnB1bGwpIHtcblx0ICAgICAgICAvL2VzbGludC1kaXNhYmxlLWxpbmVcblx0ICAgICAgICBoZWlnaHRzQXJyW2pdID0gMDtcblx0ICAgICAgICBqKys7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiAoaSkge1xuXHQgICAgICAgIC8vYWRqdXN0IHNpemUgZm9yIHNpbmdsZSBjb2x1bW5zXG5cdCAgICAgICAgX3RoaXMuYWRqdXN0Um93SGVpZ2h0KGNvbHNbaV0uaWQsIHRydWUpOyAvL2ZvciBlYWNoIHJvdywgc2V0IGhlaWdodCBhcyBtYXhpbXVtIGJldHdlZW4gYWxsIGNvbHVtbnNcblxuXG5cdCAgICAgICAgdmFyIGogPSAwO1xuXG5cdCAgICAgICAgX3RoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgIC8vaW5kZXggaXMgbm90IHJlbGlhYmxlIGZvciB0cmVlLWNvbXBvbmVudHMsIHVzaW5nIGEgY3VzdG9tIGNvdW50ZXJcblx0ICAgICAgICAgIGlmIChvYmouJGhlaWdodCA+IGhlaWdodHNBcnJbal0pIHtcblx0ICAgICAgICAgICAgaGVpZ2h0c0FycltqXSA9IG9iai4kaGVpZ2h0O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBvYmouJGhlaWdodCA9IGhlaWdodHNBcnJbal07XG5cdCAgICAgICAgICBqKys7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH07XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgX2xvb3AoaSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKCFzaWxlbnQpIHRoaXMucmVmcmVzaCgpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgTWl4aW4kNiA9IHtcblx0ICBtYXRoX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUpIHRoaXMuX21hdGhfaW5pdCgpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX21hdGhfcHJlZjogXCIkXCIsXG5cdCAgX21hdGhfaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKGVudi5zdHJpY3QpIHJldHVybjtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVVcGRhdGVkXCIsIGJpbmQodGhpcy5fcGFyc2Vfcm93X21hdGgsIHRoaXMpKTtcblx0ICAgIHRoaXMuZGF0YS5hdHRhY2hFdmVudChcIm9uU3RvcmVMb2FkXCIsIGJpbmQodGhpcy5fcGFyc2VfbWF0aCwgdGhpcykpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU3RydWN0dXJlTG9hZFwiLCB0aGlzLl9wYXJzZV9tYXRoKTtcblx0ICB9LFxuXHQgIF9wYXJzZV9yb3dfbWF0aDogZnVuY3Rpb24gKGlkLCBvYmosIGFjdGlvbikge1xuXHQgICAgaWYgKCFpZCB8fCBhY3Rpb24gPT0gXCJwYWludFwiKSByZXR1cm47XG5cblx0ICAgIGlmIChhY3Rpb24gPT0gXCJkZWxldGVcIikge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLl9yZW1vdmVfb2xkX3RyaWdnZXJzKG9iaiwgdGhpcy5fY29sdW1uc1tpXS5pZCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChhY3Rpb24gPT0gXCJhZGRcIikgdGhpcy5fZXhwcnNfYnlfY29sdW1ucyhvYmopO1xuXG5cdCAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgIHRoaXMuX3BhcnNlX2NlbGxfbWF0aChpZCwgdGhpcy5fY29sdW1uc1tfaV0uaWQsIGFjdGlvbiAhPT0gXCJhZGRcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9tYXRoX3JlY2FsYyA9IHt9O1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3BhcnNlX2NlbGxfbWF0aDogZnVuY3Rpb24gKHJvdywgY29sLCBfaW5uZXJfY2FsbCkge1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0ocm93KTtcblx0ICAgIHZhciB2YWx1ZTsgLy8gaWYgaXQncyBvdXRlciBjYWxsIHdlIHNob3VsZCB1c2UgaW5wdXR0ZWQgdmFsdWUgb3RoZXJ3aXNlIHRvIHRha2UgZm9ybXVsYSwgbm90IGNhbGN1bGF0ZWQgdmFsdWVcblxuXHQgICAgaWYgKF9pbm5lcl9jYWxsID09PSB0cnVlKSB2YWx1ZSA9IGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXSB8fCBpdGVtW2NvbF07ZWxzZSB7XG5cdCAgICAgIHZhbHVlID0gaXRlbVtjb2xdO1xuXHQgICAgICB0aGlzLl9tYXRoX3JlY2FsYyA9IHt9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS50b1N0cmluZygpLnN1YnN0cigwLCAxKSA9PT0gXCI9XCIpIHtcblx0ICAgICAgLy8gY2FsY3VsYXRlIG1hdGggdmFsdWVcblx0ICAgICAgaWYgKCFpdGVtW3RoaXMuX21hdGhfcHJlZiArIGNvbF0gfHwgX2lubmVyX2NhbGwgIT09IHRydWUpIGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXSA9IGl0ZW1bY29sXTtcblx0ICAgICAgaXRlbVtjb2xdID0gdGhpcy5fY2FsY3VsYXRlKHZhbHVlLCByb3csIGNvbCk7IC8vdGhpcy51cGRhdGVJdGVtKGl0ZW0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8ganVzdCBhIHN0cmluZ1xuXHQgICAgICBpZiAodHlwZW9mIGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXSAhPT0gXCJ1bmRlZmluZWRcIikgZGVsZXRlIGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXTsgLy8gcmVtb3ZlIHRyaWdnZXJzIGlmIHRoZXkgd2VyZSBzZXR0ZWQgZWFybGllclxuXG5cdCAgICAgIHRoaXMuX3JlbW92ZV9vbGRfdHJpZ2dlcnMoaXRlbSwgY29sKTtcblx0ICAgIH0gLy8gcmVjYWxjdWxhdGUgZGVwZW5kaW5nIGNlbGxzXG5cblxuXHQgICAgaWYgKHR5cGVvZiBpdGVtLmRlcGVuZHMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGl0ZW0uZGVwZW5kc1tjb2xdICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIGZvciAodmFyIGkgaW4gaXRlbS5kZXBlbmRzW2NvbF0pIHtcblx0ICAgICAgICB2YXIgbmFtZSA9IGl0ZW0uZGVwZW5kc1tjb2xdW2ldWzBdICsgXCJfX1wiICsgaXRlbS5kZXBlbmRzW2NvbF1baV1bMV07XG5cblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMuX21hdGhfcmVjYWxjW25hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICB0aGlzLl9tYXRoX3JlY2FsY1tuYW1lXSA9IHRydWU7XG5cblx0ICAgICAgICAgIHRoaXMuX3BhcnNlX2NlbGxfbWF0aChpdGVtLmRlcGVuZHNbY29sXVtpXVswXSwgaXRlbS5kZXBlbmRzW2NvbF1baV1bMV0sIHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NldF9vcmlnaW5hbF92YWx1ZTogZnVuY3Rpb24gKHJvdywgY29sKSB7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShyb3cpO1xuXHQgICAgaWYgKHR5cGVvZiBpdGVtW3RoaXMuX21hdGhfcHJlZiArIGNvbF0gIT09IFwidW5kZWZpbmVkXCIpIGl0ZW1bY29sXSA9IGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXTtcblx0ICB9LFxuXHQgIF9wYXJzZV9tYXRoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX2NvbHVtbnMgfHwgIXRoaXMuY291bnQoKSkgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9leHByc19ieV9jb2x1bW5zKCk7XG5cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgY29sID0gdGhpcy5jb2x1bW5JZChqKTtcblx0ICAgICAgdGhpcy5kYXRhLmVhY2goZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHRoaXMuX3BhcnNlX2NlbGxfbWF0aChvYmouaWQsIGNvbCk7XG5cdCAgICAgIH0sIHRoaXMpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9tYXRoX3JlY2FsYyA9IHt9O1xuXHQgIH0sXG5cdCAgX2V4cHJzX2J5X2NvbHVtbnM6IGZ1bmN0aW9uIChyb3cpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fY29sdW1uc1tpXS5tYXRoKSB7XG5cdCAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sdW1uSWQoaSk7XG5cdCAgICAgICAgdmFyIG1hdGggPSBcIj1cIiArIHRoaXMuX2NvbHVtbnNbaV0ubWF0aDtcblx0ICAgICAgICBtYXRoID0gbWF0aC5yZXBsYWNlKC9cXCRjL2csIFwiIyRjI1wiKTtcblxuXHQgICAgICAgIGlmIChyb3cpIHtcblx0ICAgICAgICAgIHJvd1tjb2xdID0gdGhpcy5fcGFyc2VfcmVsYXRpdmVfZXhwcihtYXRoLCByb3cuaWQsIGNvbCk7XG5cdCAgICAgICAgICBkZWxldGUgcm93W3RoaXMuX21hdGhfcHJlZiArIGNvbF07XG5cblx0ICAgICAgICAgIHRoaXMuX3JlbW92ZV9vbGRfdHJpZ2dlcnMocm93LCBjb2wpO1xuXHQgICAgICAgIH0gZWxzZSB0aGlzLmRhdGEuZWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICBvYmpbY29sXSA9IHRoaXMuX3BhcnNlX3JlbGF0aXZlX2V4cHIobWF0aCwgb2JqLmlkLCBjb2wpO1xuXHQgICAgICAgICAgZGVsZXRlIG9ialt0aGlzLl9tYXRoX3ByZWYgKyBjb2xdO1xuXG5cdCAgICAgICAgICB0aGlzLl9yZW1vdmVfb2xkX3RyaWdnZXJzKG9iaiwgY29sKTtcblx0ICAgICAgICB9LCB0aGlzKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3BhcnNlX3JlbGF0aXZlX2V4cHI6IGZ1bmN0aW9uIChleHByLCByb3csIGNvbCkge1xuXHQgICAgcmV0dXJuIHRlbXBsYXRlKGV4cHIpKHtcblx0ICAgICAgXCIkclwiOiByb3csXG5cdCAgICAgIFwiJGNcIjogY29sXG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIF9nZXRfY2FsY192YWx1ZTogZnVuY3Rpb24gKHJvdywgY29sKSB7XG5cdCAgICB2YXIgaXRlbTtcblx0ICAgIGlmICh0aGlzLmV4aXN0cyhyb3cpKSBpdGVtID0gdGhpcy5nZXRJdGVtKHJvdyk7ZWxzZSByZXR1cm4gXCIjb3V0X29mX3JhbmdlXCI7XG5cdCAgICB2YXIgdmFsdWUgPSBpdGVtW3RoaXMuX21hdGhfcHJlZiArIGNvbF0gfHwgaXRlbVtjb2xdIHx8IDA7XG5cdCAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cdCAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDEpICE9PSBcIj1cIikgLy8gaXQncyBhIHN0cmluZ1xuXHQgICAgICByZXR1cm4gdmFsdWU7ZWxzZSB7XG5cdCAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHZhbHVlIHNob3VsZG4ndCBiZSByZWNhbGN1bGF0ZWRcblx0ICAgICAgLy8gYW5kIHJldHVybiB2YWx1ZSBjYWxjdWxhdGVkIGVhcmxpZXJcblx0ICAgICAgLy8gY2FsY3VsYXRlIG1hdGggZXhwciB2YWx1ZSByaWdodCBub3dcblx0ICAgICAgaWYgKHR5cGVvZiBpdGVtW3RoaXMuX21hdGhfcHJlZiArIGNvbF0gPT09IFwidW5kZWZpbmVkXCIpIGl0ZW1bdGhpcy5fbWF0aF9wcmVmICsgY29sXSA9IGl0ZW1bY29sXTtcblx0ICAgICAgaXRlbVtjb2xdID0gdGhpcy5fY2FsY3VsYXRlKHZhbHVlLCByb3csIGNvbCwgdHJ1ZSk7XG5cdCAgICAgIHJldHVybiBpdGVtW2NvbF07XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2FsY3VsYXRlOiBmdW5jdGlvbiAodmFsdWUsIHJvdywgY29sLCBfaW5uZXJfY2FsbCkge1xuXHQgICAgLy8gYWRkIGNvb3JkIGluIG1hdGggdHJhY2UgdG8gZGV0ZWN0IHNlbGYtcmVmZXJlbmNlc1xuXHQgICAgaWYgKF9pbm5lcl9jYWxsID09PSB0cnVlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9pbl9tYXRoX3RyYWNlKHJvdywgY29sKSkgcmV0dXJuIFwiI3NlbGZyZWZlcmVuY2VcIjtcblx0ICAgIH0gZWxzZSB0aGlzLl9zdGFydF9tYXRoX3RyYWNlKCk7XG5cblx0ICAgIHRoaXMuX3RvX21hdGhfdHJhY2Uocm93LCBjb2wpO1xuXG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShyb3cpO1xuXHQgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7IC8vIGdldCBvcGVyYXRpb25zIGxpc3RcblxuXHQgICAgdmFyIG9wZXJhdGlvbnMgPSB0aGlzLl9nZXRfb3BlcmF0aW9ucyh2YWx1ZSk7XG5cblx0ICAgIHZhciB0cmlnZ2VycyA9IHRoaXMuX2dldF9yZWZzKHZhbHVlLCByb3cpO1xuXG5cdCAgICBpZiAob3BlcmF0aW9ucykge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VfcmVmcyh2YWx1ZSwgdHJpZ2dlcnMpO1xuXHQgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlX2FyZ3ModmFsdWUsIG9wZXJhdGlvbnMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlX3JlZnModmFsdWUsIHRyaWdnZXJzLCB0cnVlKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGV4YyA9IHRoaXMuX21hdGhfZXhjZXB0aW9uKHZhbHVlKTtcblxuXHQgICAgaWYgKGV4YyAhPT0gZmFsc2UpIHJldHVybiBleGM7IC8vIHJlbW92ZSBmcm9tIGNvb3JkIGZyb20gdHJhY2Ugd2hlbiBjYWxjdWxhdGlvbnMgd2VyZSBmaW5pc2hlZCAtIGl0J3MgaW1wb3J0YW50IVxuXG5cdCAgICB0aGlzLl9mcm9tX21hdGhfdHJhY2Uocm93LCBjb2wpOyAvLyBwcm9jZXNzIHRyaWdnZXJzIHRvIGtub3cgd2hpY2ggY2VsbHMgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZCB3aGVuIG9uZSB3YXMgY2hhbmdlZFxuXG5cblx0ICAgIHRoaXMuX3JlbW92ZV9vbGRfdHJpZ2dlcnMoaXRlbSwgY29sKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9hZGRfdHJpZ2dlcihbcm93LCBjb2xdLCB0cmlnZ2Vyc1tpXSk7XG5cdCAgICB9XG5cblx0ICAgIGV4YyA9IHRoaXMuX21hdGhfZXhjZXB0aW9uKHZhbHVlKTtcblx0ICAgIGlmIChleGMgIT09IGZhbHNlKSByZXR1cm4gZXhjOyAvLyB0aGVyZSBhcmVuJ3QgYW55IG9wZXJhdGlvbnMgaGVyZS4gcmV0dXJucyBudW1iZXIgb3IgdmFsdWUgb2YgYW5vdGhlciBjZWxsXG5cblx0ICAgIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTsgLy8gcHJvY2VzcyBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiBhbmQgZ2V0dGluZyBmaW5hbCByZXN1bHRcblxuXHQgICAgdmFsdWUgPSB0aGlzLl9jb21wdXRlKHZhbHVlLnJlcGxhY2UoL1xcJHIvZywgaXRlbS5pZCkpO1xuXHQgICAgZXhjID0gdGhpcy5fbWF0aF9leGNlcHRpb24odmFsdWUpO1xuXHQgICAgaWYgKGV4YyAhPT0gZmFsc2UpIHJldHVybiBleGM7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfZ2V0X29wZXJhdGlvbnM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgLy8gZ2V0dGluZ3Mgb3BlcmF0aW9ucyBsaXN0ICgrLSovKVxuXHQgICAgdmFyIHNwbGl0dGVyID0gLyhcXCt8LXxcXCp8XFwvKS9nO1xuXHQgICAgdmFyIG9wZXJhdGlvbnMgPSB2YWx1ZS5yZXBsYWNlKC9cXFtbXildKj9cXF0vZywgXCJcIikubWF0Y2goc3BsaXR0ZXIpO1xuXHQgICAgcmV0dXJuIG9wZXJhdGlvbnM7XG5cdCAgfSxcblxuXHQgIC8qISBnZXRzIGxpc3Qgb2YgcmVmZXJlbmNpZXMgaW4gZm9ybXVsYVxuXHQgICAqKi9cblx0ICBfZ2V0X3JlZnM6IGZ1bmN0aW9uICh2YWx1ZSwgaWQpIHtcblx0ICAgIHZhciByZWcgPSAvXFxbKFteXFxdXSspLChbXlxcXV0rKVxcXS9nO1xuXHQgICAgdmFyIGNlbGxzID0gdmFsdWUubWF0Y2gocmVnKTtcblx0ICAgIGlmIChjZWxscyA9PT0gbnVsbCkgY2VsbHMgPSBbXTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuXHQgICAgICB2YXIgdG1wID0gY2VsbDtcblx0ICAgICAgY2VsbCA9IGNlbGwuc3Vic3RyKDEsIGNlbGwubGVuZ3RoIC0gMik7XG5cdCAgICAgIGNlbGwgPSBjZWxsLnNwbGl0KFwiLFwiKTtcblx0ICAgICAgY2VsbFswXSA9IHRoaXMuX3RyaW0oY2VsbFswXSk7XG5cdCAgICAgIGNlbGxbMV0gPSB0aGlzLl90cmltKGNlbGxbMV0pO1xuXHQgICAgICBpZiAoY2VsbFswXS5zdWJzdHIoMCwgMSkgPT09IFwiOlwiKSBjZWxsWzBdID0gdGhpcy5nZXRJZEJ5SW5kZXgoY2VsbFswXS5zdWJzdHIoMSkpO1xuXHQgICAgICBpZiAoY2VsbFswXSA9PT0gXCIkclwiKSBjZWxsWzBdID0gaWQ7XG5cdCAgICAgIGlmIChjZWxsWzFdLnN1YnN0cigwLCAxKSA9PT0gXCI6XCIpIGNlbGxbMV0gPSB0aGlzLmNvbHVtbklkKGNlbGxbMV0uc3Vic3RyKDEpKTtcblx0ICAgICAgY2VsbFsyXSA9IHRtcDtcblx0ICAgICAgY2VsbHNbaV0gPSBjZWxsO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY2VsbHM7XG5cdCAgfSxcblx0ICAvLyByZXBsYWNlIGdpdmVuIGxpc3Qgb2YgcmVmZXJlbmNlcyBieSB0aGVpciB2YWx1ZXNcblx0ICBfcmVwbGFjZV9yZWZzOiBmdW5jdGlvbiAodmFsdWUsIGNlbGxzLCBjbGVhbikge1xuXHQgICAgdmFyIGRlbGwgPSBcIihcIixcblx0ICAgICAgICBkZWxyID0gXCIpXCI7XG5cdCAgICBpZiAoY2xlYW4pIGRlbGwgPSBkZWxyID0gXCJcIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY2VsbCA9IGNlbGxzW2ldO1xuXG5cdCAgICAgIHZhciBjZWxsX3ZhbHVlID0gdGhpcy5fZ2V0X2NhbGNfdmFsdWUoY2VsbFswXSwgY2VsbFsxXSk7XG5cblx0ICAgICAgaWYgKGlzTmFOKGNlbGxfdmFsdWUpKSBjZWxsX3ZhbHVlID0gXCJcXFwiXCIgKyBjZWxsX3ZhbHVlICsgXCJcXFwiXCI7XG5cdCAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShjZWxsWzJdLCBkZWxsICsgY2VsbF92YWx1ZSArIGRlbHIpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfcGFyc2VfYXJnczogZnVuY3Rpb24gKHZhbHVlLCBvcGVyYXRpb25zKSB7XG5cdCAgICB2YXIgYXJncyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG9wID0gb3BlcmF0aW9uc1tpXTtcblxuXHQgICAgICB2YXIgdGVtcCA9IHRoaXMuX3NwbGl0X2J5KHZhbHVlLCBvcCk7XG5cblx0ICAgICAgYXJncy5wdXNoKHRlbXBbMF0pO1xuXHQgICAgICB2YWx1ZSA9IHRlbXBbMV07XG5cdCAgICB9XG5cblx0ICAgIGFyZ3MucHVzaCh2YWx1ZSk7IC8vdmFyIHJlZyA9IC9eKC0/XFxkfFxcLnxcXCh8XFwpKSskLztcblxuXHQgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYXJncy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgIHZhciBhcmcgPSB0aGlzLl90cmltKGFyZ3NbX2kyXSk7IC8vXHRpZiAocmVnLnRlc3QoYXJnKSA9PT0gZmFsc2UpXG5cdCAgICAgIC8vXHRcdHJldHVybiAnJzsgLy9lcnJvclxuXG5cblx0ICAgICAgYXJnc1tfaTJdID0gYXJnO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZXhwciA9IFwiXCI7XG5cblx0ICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGFyZ3MubGVuZ3RoIC0gMTsgX2kzKyspIHtcblx0ICAgICAgZXhwciArPSBhcmdzW19pM10gKyBvcGVyYXRpb25zW19pM107XG5cdCAgICB9XG5cblx0ICAgIGV4cHIgKz0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXHQgICAgcmV0dXJuIGV4cHI7XG5cdCAgfSxcblx0ICBfY29tcHV0ZTogZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgIHZhciByZXN1bHQ7XG5cblx0ICAgIHRyeSB7XG5cdCAgICAgIHJlc3VsdCA9IHdpbmRvdy5ldmFsKGV4cHIpO1xuXHQgICAgfSBjYXRjaCAoZXgpIHtcblx0ICAgICAgYXNzZXJ0KGZhbHNlLCBcIk1hdGggZXJyb3IgaW4gZGF0YXRhYmxlPGJyPlwiICsgZXhwcik7XG5cdCAgICAgIHJlc3VsdCA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcblx0ICB9LFxuXHQgIF9zcGxpdF9ieTogZnVuY3Rpb24gKHZhbHVlLCBzcGxpdHRlcikge1xuXHQgICAgdmFyIHBvcyA9IHZhbHVlLmluZGV4T2Yoc3BsaXR0ZXIpO1xuXHQgICAgdmFyIGJlZm9yZSA9IHZhbHVlLnN1YnN0cigwLCBwb3MpO1xuXHQgICAgdmFyIGFmdGVyID0gdmFsdWUuc3Vic3RyKHBvcyArIDEpO1xuXHQgICAgcmV0dXJuIFtiZWZvcmUsIGFmdGVyXTtcblx0ICB9LFxuXHQgIF90cmltOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXiAqL2csIFwiXCIpO1xuXHQgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8gKiQvZywgXCJcIik7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICBfc3RhcnRfbWF0aF90cmFjZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fbWF0aF90cmFjZSA9IFtdO1xuXHQgIH0sXG5cdCAgX3RvX21hdGhfdHJhY2U6IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuXHQgICAgdGhpcy5fbWF0aF90cmFjZVtyb3cgKyBcIl9fXCIgKyBjb2xdID0gdHJ1ZTtcblx0ICB9LFxuXHQgIF9mcm9tX21hdGhfdHJhY2U6IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuXHQgICAgaWYgKHR5cGVvZiB0aGlzLl9tYXRoX3RyYWNlW3JvdyArIFwiX19cIiArIGNvbF0gIT09IFwidW5kZWZpbmVkXCIpIGRlbGV0ZSB0aGlzLl9tYXRoX3RyYWNlW3JvdyArIFwiX19cIiArIGNvbF07XG5cdCAgfSxcblx0ICBfaW5fbWF0aF90cmFjZTogZnVuY3Rpb24gKHJvdywgY29sKSB7XG5cdCAgICBpZiAodHlwZW9mIHRoaXMuX21hdGhfdHJhY2Vbcm93ICsgXCJfX1wiICsgY29sXSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHRydWU7ZWxzZSByZXR1cm4gZmFsc2U7XG5cdCAgfSxcblx0ICBfYWRkX3RyaWdnZXI6IGZ1bmN0aW9uIChkZXBlbmRzLCBmcm9tKSB7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShmcm9tWzBdKTtcblx0ICAgIGlmICh0eXBlb2YgaXRlbS5kZXBlbmRzID09PSBcInVuZGVmaW5lZFwiKSBpdGVtLmRlcGVuZHMgPSB7fTtcblx0ICAgIGlmICh0eXBlb2YgaXRlbS5kZXBlbmRzW2Zyb21bMV1dID09PSBcInVuZGVmaW5lZFwiKSBpdGVtLmRlcGVuZHNbZnJvbVsxXV0gPSB7fTtcblx0ICAgIGl0ZW0uZGVwZW5kc1tmcm9tWzFdXVtkZXBlbmRzWzBdICsgXCJfX1wiICsgZGVwZW5kc1sxXV0gPSBkZXBlbmRzO1xuXHQgICAgaXRlbSA9IHRoaXMuZ2V0SXRlbShkZXBlbmRzWzBdKTtcblx0ICAgIGlmICh0eXBlb2YgaXRlbS50cmlnZ2VycyA9PT0gXCJ1bmRlZmluZWRcIikgaXRlbS50cmlnZ2VycyA9IHt9O1xuXHQgICAgaWYgKHR5cGVvZiBpdGVtLnRyaWdnZXJzW2RlcGVuZHNbMV1dID09PSBcInVuZGVmaW5lZFwiKSBpdGVtLnRyaWdnZXJzW2RlcGVuZHNbMV1dID0ge307XG5cdCAgICBpdGVtLnRyaWdnZXJzW2RlcGVuZHNbMV1dW2Zyb21bMF0gKyBcIl9fXCIgKyBmcm9tWzFdXSA9IGZyb207XG5cdCAgfSxcblx0ICBfcmVtb3ZlX29sZF90cmlnZ2VyczogZnVuY3Rpb24gKGl0ZW0sIGNvbCkge1xuXHQgICAgaWYgKCFpdGVtKSByZXR1cm47XG5cdCAgICBpZiAodHlwZW9mIGl0ZW0udHJpZ2dlcnMgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybjtcblxuXHQgICAgZm9yICh2YXIgaSBpbiBpdGVtLnRyaWdnZXJzW2NvbF0pIHtcblx0ICAgICAgdmFyIGRlcGVuZCA9IGl0ZW0udHJpZ2dlcnNbY29sXVtpXTtcblx0ICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0SXRlbShkZXBlbmRbMF0pO1xuXHQgICAgICBpZiAocm93KSBkZWxldGUgcm93LmRlcGVuZHNbZGVwZW5kWzFdXVtpdGVtLmlkICsgXCJfX1wiICsgY29sXTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vIGNoZWNrIGlmIGV4Y2VwdGlvbiBzeW50YXggZXhpc3RzIGFuZCByZXR1cm5zIGV4Y2VwdGlvbiB0ZXh0IG9yIGZhbHNlXG5cdCAgX21hdGhfZXhjZXB0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHZhciByZWcgPSAvI1xcdysvO1xuXHQgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnKTtcblx0ICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPiAwKSByZXR1cm4gbWF0Y2hbMF07XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9O1xuXG5cdHZhciB0ZW1wJDQgPSB7fTtcblxuXHQvLyAjaW5jbHVkZSBjb3JlL2VkaXQuanNcblx0Ly8gI2luY2x1ZGUgdWkvaW5wdXRzLmpzXG5cblx0dmFyIE1peGluJDcgPSB7XG5cdCAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgIC8vICAgIGVkaXQgc3RhcnQgICAgICAgLy9cblx0ICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgX2dldF9lZGl0b3JfdHlwZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5Db25maWcoaWQuY29sdW1uKS5lZGl0b3I7XG5cdCAgfSxcblx0ICBnZXRFZGl0b3I6IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuXHQgICAgaWYgKCFyb3cpIHJldHVybiB0aGlzLl9sYXN0X2VkaXRvcjtcblxuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHQgICAgICBjb2x1bW4gPSByb3cuY29sdW1uO1xuXHQgICAgICByb3cgPSByb3cucm93O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gKHRoaXMuX2VkaXRvcnNbcm93XSB8fCB7fSlbY29sdW1uXTtcblx0ICB9LFxuXHQgIF9mb3JfZWFjaF9lZGl0b3I6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG5cdCAgICBmb3IgKHZhciByb3cgaW4gdGhpcy5fZWRpdG9ycykge1xuXHQgICAgICB2YXIgcm93X2VkaXRvcnMgPSB0aGlzLl9lZGl0b3JzW3Jvd107XG5cblx0ICAgICAgZm9yICh2YXIgY29sdW1uIGluIHJvd19lZGl0b3JzKSB7XG5cdCAgICAgICAgaWYgKGNvbHVtbiAhPSBcIiRjb3VudFwiKSBoYW5kbGVyLmNhbGwodGhpcywgcm93X2VkaXRvcnNbY29sdW1uXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9pbml0X2VkaXRvcjogZnVuY3Rpb24gKGlkLCB0eXBlLCBzaG93KSB7XG5cdCAgICB2YXIgcm93ID0gaWQucm93O1xuXHQgICAgdmFyIGNvbHVtbiA9IGlkLmNvbHVtbjtcblx0ICAgIHZhciBjb2xfc2V0dGluZ3MgPSB0eXBlLmNvbmZpZyA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGNvbHVtbik7IC8vc2hvdyBpdCBvdmVyIGNlbGxcblxuXHQgICAgaWYgKHNob3cgIT09IGZhbHNlKSB0aGlzLnNob3dDZWxsKHJvdywgY29sdW1uKTtcblx0ICAgIHZhciBub2RlID0gdHlwZS5yZW5kZXIoKTtcblx0ICAgIGlmICh0eXBlLiRpbmxpbmUpIG5vZGUgPSB0aGlzLl9sb2NhdGVJbnB1dChpZCk7XG5cdCAgICB0eXBlLm5vZGUgPSBub2RlO1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0ocm93KTtcblx0ICAgIHZhciBmb3JtYXQgPSBjb2xfc2V0dGluZ3MuZWRpdEZvcm1hdDtcblx0ICAgIHZhciB2YWx1ZTtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5lZGl0TWF0aCkgdmFsdWUgPSBpdGVtW1wiJFwiICsgY29sdW1uXTtcblx0ICAgIHZhbHVlID0gdmFsdWUgfHwgaXRlbVtjb2x1bW5dO1xuXHQgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkgdmFsdWUgPSBcIlwiO1xuXHQgICAgdHlwZS5zZXRWYWx1ZShmb3JtYXQgPyBmb3JtYXQodmFsdWUpIDogdmFsdWUsIGl0ZW0pO1xuXHQgICAgdHlwZS52YWx1ZSA9IGl0ZW1bY29sdW1uXTtcblxuXHQgICAgdGhpcy5fYWRkRWRpdG9yKGlkLCB0eXBlKTtcblxuXHQgICAgaWYgKCF0eXBlLiRpbmxpbmUpIHRoaXMuX3NpemVUb0NlbGwoaWQsIG5vZGUsIHRydWUpO1xuXHQgICAgaWYgKHR5cGUuYWZ0ZXJSZW5kZXIpIHR5cGUuYWZ0ZXJSZW5kZXIoKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmxpdmVWYWxpZGF0aW9uKSB7XG5cdCAgICAgIF9ldmVudCh0eXBlLm5vZGUsIFwia2V5dXBcIiwgdGhpcy5fYmluZF9saXZlX3ZhbGlkYXRpb24oaWQsIHRoaXMpKTtcblxuXHQgICAgICB0aGlzLnZhbGlkYXRlRWRpdG9yKGlkKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5vZGU7XG5cdCAgfSxcblx0ICBfYmluZF9saXZlX3ZhbGlkYXRpb246IGZ1bmN0aW9uIChpZCwgdGhhdCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhhdC52YWxpZGF0ZUVkaXRvcihpZCk7XG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgX2dldF9uZXdfdmFsdWU6IGZ1bmN0aW9uIChlZGl0b3IpIHtcblx0ICAgIHZhciBwYXJzZXIgPSB0aGlzLmdldENvbHVtbkNvbmZpZyhlZGl0b3IuY29sdW1uKS5lZGl0UGFyc2U7XG5cdCAgICB2YXIgbmV3X3ZhbHVlID0gZWRpdG9yLmdldFZhbHVlKCk7XG5cdCAgICByZXR1cm4gcGFyc2VyID8gcGFyc2VyKG5ld192YWx1ZSkgOiBuZXdfdmFsdWU7XG5cdCAgfSxcblx0ICBfc2V0X25ld192YWx1ZTogZnVuY3Rpb24gKGVkaXRvciwgbmV3X3ZhbHVlLCBjb3B5JCQxKSB7XG5cdCAgICB2YXIgaXRlbSA9IGNvcHkkJDEgPyB7fSA6IHRoaXMuZ2V0SXRlbShlZGl0b3Iucm93KTtcblx0ICAgIGl0ZW1bZWRpdG9yLmNvbHVtbl0gPSBuZXdfdmFsdWU7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZWRpdE1hdGgpIGl0ZW1bXCIkXCIgKyBlZGl0b3IuY29sdW1uXSA9IG51bGw7XG5cdCAgICByZXR1cm4gaXRlbTtcblx0ICB9LFxuXHQgIC8vcmVnaXN0ZXIgZWRpdG9yIGluIGNvbGxlY3Rpb25cblx0ICBfYWRkRWRpdG9yOiBmdW5jdGlvbiAoaWQsIHR5cGUpIHtcblx0ICAgIHZhciByb3dfZWRpdG9ycyA9IHRoaXMuX2VkaXRvcnNbaWQucm93XSA9IHRoaXMuX2VkaXRvcnNbaWQucm93XSB8fCB7fTtcblx0ICAgIHJvd19lZGl0b3JzLiRjb3VudCA9IChyb3dfZWRpdG9ycy4kY291bnQgfHwgMCkgKyAxO1xuXHQgICAgdHlwZS5yb3cgPSBpZC5yb3c7XG5cdCAgICB0eXBlLmNvbHVtbiA9IGlkLmNvbHVtbjtcblx0ICAgIHRoaXMuX2xhc3RfZWRpdG9yID0gcm93X2VkaXRvcnNbaWQuY29sdW1uXSA9IHR5cGU7XG5cdCAgICB0aGlzLl9pbl9lZGl0X21vZGUrKztcblx0ICAgIHRoaXMuX2xhc3RfZWRpdG9yX3Njcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblx0ICB9LFxuXHQgIF9yZW1vdmVFZGl0b3I6IGZ1bmN0aW9uIChlZGl0b3IpIHtcblx0ICAgIGlmICh0aGlzLl9sYXN0X2VkaXRvciA9PSBlZGl0b3IpIHRoaXMuX2xhc3RfZWRpdG9yID0gMDtcblx0ICAgIGlmIChlZGl0b3IuZGVzdHJveSkgZWRpdG9yLmRlc3Ryb3koKTtcblx0ICAgIHZhciByb3cgPSB0aGlzLl9lZGl0b3JzW2VkaXRvci5yb3ddO1xuXHQgICAgZGVsZXRlIHJvd1tlZGl0b3IuY29sdW1uXTtcblx0ICAgIHJvdy4kY291bnQtLTtcblx0ICAgIGlmICghcm93LiRjb3VudCkgZGVsZXRlIHRoaXMuX2VkaXRvcnNbZWRpdG9yLnJvd107XG5cdCAgICB0aGlzLl9pbl9lZGl0X21vZGUtLTtcblx0ICB9LFxuXHQgIF9jaGFuZ2VFZGl0b3JJZDogZnVuY3Rpb24gKG9sZGlkLCBuZXdpZCkge1xuXHQgICAgdmFyIGVkaXRvciA9IHRoaXMuX2VkaXRvcnNbb2xkaWRdO1xuXG5cdCAgICBpZiAoZWRpdG9yKSB7XG5cdCAgICAgIHRoaXMuX2VkaXRvcnNbbmV3aWRdID0gZWRpdG9yO1xuXHQgICAgICBkZWxldGUgdGhpcy5fZWRpdG9yc1tvbGRpZF07XG5cblx0ICAgICAgZm9yICh2YXIga2V5IGluIGVkaXRvcikge1xuXHQgICAgICAgIGlmIChrZXkgIT0gXCIkY291bnRcIikgZWRpdG9yW2tleV0ucm93ID0gbmV3aWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vZ2V0IGh0bWwgY2VsbCBieSBjb21iaW5lZCBpZFxuXHQgIF9sb2NhdGVfY2VsbDogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgYXJlYSxcblx0ICAgICAgICBpLFxuXHQgICAgICAgIGluZGV4LFxuXHQgICAgICAgIGosXG5cdCAgICAgICAgbm9kZSxcblx0ICAgICAgICBzcGFuLFxuXHQgICAgICAgIGNvbmZpZyA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGlkLmNvbHVtbiksXG5cdCAgICAgICAgY2VsbCA9IDA7XG5cblx0ICAgIGlmIChjb25maWcgJiYgY29uZmlnLm5vZGUgJiYgY29uZmlnLmF0dGFjaGVkKSB7XG5cdCAgICAgIGluZGV4ID0gdGhpcy5nZXRJbmRleEJ5SWQoaWQucm93KTtcblxuXHQgICAgICBpZiAodGhpcy5fc3BhbnNfcHVsbCkge1xuXHQgICAgICAgIHNwYW4gPSB0aGlzLmdldFNwYW4oaWQucm93LCBpZC5jb2x1bW4pO1xuXG5cdCAgICAgICAgaWYgKHNwYW4pIHtcblx0ICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0ICAgICAgICAgICAgYXJlYSA9IHRoaXMuX3NwYW5zX2FyZWFzW2ldO1xuXG5cdCAgICAgICAgICAgIGZvciAoaiA9IDA7ICFjZWxsICYmIGogPCBhcmVhLmNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICBub2RlID0gYXJlYS5jaGlsZE5vZGVzW2pdO1xuXHQgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcInJvd1wiKSA9PSBpbmRleCAmJiBub2RlLmdldEF0dHJpYnV0ZShcImNvbHVtblwiKSA9PSB0aGlzLmdldENvbHVtbkluZGV4KGlkLmNvbHVtbikpIGNlbGwgPSBub2RlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCFjZWxsICYmIGluZGV4ID49IGNvbmZpZy5feXIwIC0gdGhpcy5fc2V0dGluZ3MudG9wU3BsaXQgJiYgaW5kZXggPCBjb25maWcuX3lyMSkgY2VsbCA9IGNvbmZpZy5ub2RlLmNoaWxkTm9kZXNbaW5kZXggLSBjb25maWcuX3lyMCArIHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0XTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNlbGw7XG5cdCAgfSxcblx0ICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgLy8gICAgcHVibGljIG1ldGhvZHMgICAvL1xuXHQgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICBlZGl0Q2VsbDogZnVuY3Rpb24gKHJvdywgY29sdW1uLCBwcmVzZXJ2ZSwgc2hvdykge1xuXHQgICAgY29sdW1uID0gY29sdW1uIHx8IHRoaXMuX3NldHRpbmdzLmNvbHVtbnNbMF0uaWQ7XG5cdCAgICByZXR1cm4gRWRpdEFiaWxpdHkuZWRpdC5jYWxsKHRoaXMsIHtcblx0ICAgICAgcm93OiByb3csXG5cdCAgICAgIGNvbHVtbjogY29sdW1uXG5cdCAgICB9LCBwcmVzZXJ2ZSwgc2hvdyk7XG5cdCAgfSxcblx0ICBlZGl0Um93OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmIChpZCAmJiBpZC5yb3cpIGlkID0gaWQucm93O1xuXHQgICAgdmFyIG5leHQgPSBmYWxzZTtcblx0ICAgIHRoaXMuZWFjaENvbHVtbihmdW5jdGlvbiAoY29sdW1uKSB7XG5cdCAgICAgIHRoaXMuZWRpdCh7XG5cdCAgICAgICAgcm93OiBpZCxcblx0ICAgICAgICBjb2x1bW46IGNvbHVtblxuXHQgICAgICB9LCBuZXh0LCAhbmV4dCk7XG5cdCAgICAgIG5leHQgPSB0cnVlO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBlZGl0Q29sdW1uOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGlmIChpZCAmJiBpZC5jb2x1bW4pIGlkID0gaWQuY29sdW1uO1xuXHQgICAgdmFyIG5leHQgPSBmYWxzZTtcblx0ICAgIHRoaXMuZWFjaFJvdyhmdW5jdGlvbiAocm93KSB7XG5cdCAgICAgIHRoaXMuZWRpdCh7XG5cdCAgICAgICAgcm93OiByb3csXG5cdCAgICAgICAgY29sdW1uOiBpZFxuXHQgICAgICB9LCBuZXh0LCAhbmV4dCk7XG5cdCAgICAgIG5leHQgPSB0cnVlO1xuXHQgICAgfSk7XG5cdCAgfSxcblx0ICBlYWNoUm93OiBmdW5jdGlvbiAoaGFuZGxlciwgYWxsKSB7XG5cdCAgICB2YXIgb3JkZXIgPSB0aGlzLmRhdGEub3JkZXI7XG5cdCAgICBpZiAoYWxsKSBvcmRlciA9IHRoaXMuZGF0YS5fZmlsdGVyX29yZGVyIHx8IG9yZGVyO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBvcmRlcltpXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBlYWNoQ29sdW1uOiBmdW5jdGlvbiAoaGFuZGxlciwgYWxsKSB7XG5cdCAgICBmb3IgKHZhciBpIGluIHRoaXMuX2NvbHVtbnNfcHVsbCkge1xuXHQgICAgICB2YXIgY29sdW1uID0gdGhpcy5fY29sdW1uc19wdWxsW2ldO1xuXHQgICAgICBoYW5kbGVyLmNhbGwodGhpcywgY29sdW1uLmlkLCBjb2x1bW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYWxsKSB7XG5cdCAgICAgIGZvciAodmFyIF9pIGluIHRoaXMuX2hpZGRlbl9jb2x1bW5faGFzaCkge1xuXHQgICAgICAgIHZhciBfY29sdW1uID0gdGhpcy5faGlkZGVuX2NvbHVtbl9oYXNoW19pXTtcblx0ICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgX2NvbHVtbi5pZCwgX2NvbHVtbik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgLy8gICAgZWRpdCBuZXh0ICAgLy9cblx0ICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgIF9hZnRlcl9lZGl0X25leHQ6IGZ1bmN0aW9uIChlZGl0b3JfbmV4dCkge1xuXHQgICAgaWYgKHRoaXMuZ2V0U2VsZWN0ZWRJZCkge1xuXHQgICAgICAvL3NlbGVjdCByZWxhdGVkIGNlbGwgd2hlbiBwb3NzaWJsZVxuXHQgICAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUpO1xuXG5cdCAgICAgIGlmIChzZWwubGVuZ3RoID09IDEpIHtcblx0ICAgICAgICB0aGlzLl9zZWxlY3QoZWRpdG9yX25leHQpO1xuXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY3VzdG9tX3RhYl9oYW5kbGVyOiBmdW5jdGlvbiAodGFiLCBlKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZWRpdGFibGUgJiYgIXRoaXMuX2luX2VkaXRfbW9kZSkge1xuXHQgICAgICAvL2lmIHdlIGhhdmUgZm9jdXMgaW4gc29tZSBjdXN0b20gaW5wdXQgaW5zaWRlIG9mIGRhdGF0YWJsZVxuXHQgICAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQudGFnTmFtZSA9PSBcIklOUFVUXCIpIHJldHVybiB0cnVlOyAvL2luaXQgZWRpdG9yIHJlbGF0ZWQgdG8gYSBzaW5nbGUgc2VsZWN0ZWQgcm93L2NvbHVtbi9jZWxsXG5cblx0ICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKTtcblxuXHQgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCA9PSAxKSB7XG5cdCAgICAgICAgdmFyIHNlbCA9IHNlbGVjdGlvblswXTtcblx0ICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2VsZWN0ID09IFwicm93XCIpIHNlbC5jb2x1bW4gPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zW2Uuc2hpZnRLZXkgPyAwIDogdGhpcy5fc2V0dGluZ3MuY29sdW1ucy5sZW5ndGggLSAxXS5pZDtcblx0ICAgICAgICB0aGlzLmVkaXROZXh0KHRhYiwgc2VsKTtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSxcblx0ICBfZmluZF9jZWxsX25leHQ6IGZ1bmN0aW9uIChzdGFydCwgY2hlY2ssIGRpcmVjdGlvbikge1xuXHQgICAgdmFyIHJvdyA9IHRoaXMuZ2V0SW5kZXhCeUlkKHN0YXJ0LnJvdyk7XG5cdCAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW5JbmRleChzdGFydC5jb2x1bW4pO1xuXHQgICAgdmFyIG9yZGVyID0gdGhpcy5kYXRhLm9yZGVyO1xuXHQgICAgdmFyIGNvbHMgPSB0aGlzLl9jb2x1bW5zO1xuXG5cdCAgICBpZiAoZGlyZWN0aW9uKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSByb3c7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGZvciAodmFyIGogPSBjb2x1bW4gKyAxOyBqIDwgY29scy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgdmFyIGlkID0ge1xuXHQgICAgICAgICAgICByb3c6IG9yZGVyW2ldLFxuXHQgICAgICAgICAgICBjb2x1bW46IGNvbHNbal0uaWRcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgICAgIGlmIChjaGVjay5jYWxsKHRoaXMsIGlkKSAmJiAoIXRoaXMuX2NoZWNrQ2VsbE1lcmdlIHx8ICF0aGlzLl9jaGVja0NlbGxNZXJnZShzdGFydCwgaWQpKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gaWQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY29sdW1uID0gLTE7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAodmFyIF9pMiA9IHJvdzsgX2kyID49IDA7IF9pMi0tKSB7XG5cdCAgICAgICAgZm9yICh2YXIgX2ogPSBjb2x1bW4gLSAxOyBfaiA+PSAwOyBfai0tKSB7XG5cdCAgICAgICAgICB2YXIgX2lkID0ge1xuXHQgICAgICAgICAgICByb3c6IG9yZGVyW19pMl0sXG5cdCAgICAgICAgICAgIGNvbHVtbjogY29sc1tfal0uaWRcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICBpZiAoY2hlY2suY2FsbCh0aGlzLCBfaWQpKSByZXR1cm4gX2lkO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNvbHVtbiA9IGNvbHMubGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH0sXG5cdCAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAvLyAgICBzY3JvbGwgY29ycmVjdGlvbiAgICAvL1xuXHQgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgX2NvcnJlY3RfYWZ0ZXJfZm9jdXNfeTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX2luX2VkaXRfbW9kZSkge1xuXHQgICAgICBpZiAodGhpcy5faWdub3JlX2FmdGVyX2ZvY3VzX3Njcm9sbCkgdGhpcy5faWdub3JlX2FmdGVyX2ZvY3VzX3Njcm9sbCA9IGZhbHNlO2Vsc2Uge1xuXHQgICAgICAgIHRoaXMuX3lfc2Nyb2xsLnNjcm9sbFRvKHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKS55ICsgdGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQuc2Nyb2xsVG9wKTtcblxuXHQgICAgICAgIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1sxXS5maXJzdENoaWxkLnNjcm9sbFRvcCA9IDA7XG5cdCAgICAgICAgdGhpcy5faWdub3JlX2FmdGVyX2ZvY3VzX3Njcm9sbCA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jb3JyZWN0X2FmdGVyX2ZvY3VzX3g6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9pbl9lZGl0X21vZGUpIHtcblx0ICAgICAgdGhpcy5feF9zY3JvbGwuc2Nyb2xsVG8odGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLnNjcm9sbExlZnQpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NvbXBvbmVudF9zcGVjaWZpY19lZGl0X2luaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvblNjcm9sbFlcIiwgdGhpcy5fdXBkYXRlX2VkaXRvcl95X3Bvcyk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TY3JvbGxYXCIsIHRoaXMuX3VwZGF0ZV9lZGl0b3JfeV9wb3MpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uU2Nyb2xsWVwiLCB0aGlzLl9yZWZvY3VzX2lubGluZV9lZGl0b3IpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQ29sdW1uUmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5lZGl0U3RvcCgpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlckZpbHRlclwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHRoaXMuZWRpdFN0b3AoKTtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uUm93UmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5lZGl0U3RvcCgpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25BZnRlclNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCkgdGhpcy5lZGl0U3RvcCgpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMV0uZmlyc3RDaGlsZC5vbnNjcm9sbCA9IGJpbmQodGhpcy5fY29ycmVjdF9hZnRlcl9mb2N1c195LCB0aGlzKTtcblx0ICAgIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1sxXS5vbnNjcm9sbCA9IGJpbmQodGhpcy5fY29ycmVjdF9hZnRlcl9mb2N1c194LCB0aGlzKTtcblx0ICB9LFxuXHQgIF91cGRhdGVfZWRpdG9yX3lfcG9zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5faW5fZWRpdF9tb2RlKSB7XG5cdCAgICAgIHZhciBvbGQgPSB0aGlzLl9sYXN0X2VkaXRvcl9zY3JvbGw7XG5cdCAgICAgIHRoaXMuX2xhc3RfZWRpdG9yX3Njcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblx0ICAgICAgdmFyIGRpZmYgPSB0aGlzLl9sYXN0X2VkaXRvcl9zY3JvbGwueSAtIG9sZC55O1xuXG5cdCAgICAgIHRoaXMuX2Zvcl9lYWNoX2VkaXRvcihmdW5jdGlvbiAoZWRpdG9yKSB7XG5cdCAgICAgICAgaWYgKGVkaXRvci5nZXRQb3B1cCkge1xuXHQgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKGVkaXRvcik7XG5cdCAgICAgICAgICBpZiAobm9kZSkgZWRpdG9yLmdldFBvcHVwKCkuc2hvdyhub2RlKTtlbHNlIGVkaXRvci5nZXRQb3B1cCgpLnNob3coe1xuXHQgICAgICAgICAgICB4OiAtMTAwMDAsXG5cdCAgICAgICAgICAgIHk6IC0xMDAwMFxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFlZGl0b3IubGlua0lucHV0ICYmICFlZGl0b3IuJGlubGluZSkge1xuXHQgICAgICAgICAgZWRpdG9yLm5vZGUudG9wIC09IGRpZmY7XG5cdCAgICAgICAgICBlZGl0b3Iubm9kZS5zdHlsZS50b3AgPSBlZGl0b3Iubm9kZS50b3AgKyBcInB4XCI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJDggPSB7XG5cdCAgJGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX2NsZWFyX2hpZGRlbl9zdGF0ZSgpO1xuXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TdHJ1Y3R1cmVMb2FkXCIsIHRoaXMuX2hpZGVJbml0aWFsQ29sdW1ucyk7XG5cdCAgfSxcblx0ICBfY2xlYXJfaGlkZGVuX3N0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9oaWRkZW5fY29sdW1uX2hhc2ggPSB7fTtcblx0ICAgIHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIgPSB0b0FycmF5KCk7XG5cdCAgICB0aGlzLl9oaWRkZW5fc3BsaXQgPSBbMCwgMF07XG5cdCAgfSxcblx0ICBfaGlkZUluaXRpYWxDb2x1bW5zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgY29scyA9IHRoaXMuX2NvbHVtbnM7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29scy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoY29sc1tpXS5oZWFkZXIpIHRoaXMuX2dldEluaXRpYWxTcGFucyhjb2xzLCBjb2xzW2ldLmhlYWRlcik7XG5cdCAgICAgIGlmIChjb2xzW2ldLmZvb3RlcikgdGhpcy5fZ2V0SW5pdGlhbFNwYW5zKGNvbHMsIGNvbHNbaV0uZm9vdGVyKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgX2kgPSBjb2xzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcblx0ICAgICAgaWYgKGNvbHNbX2ldLmhpZGRlbikgdGhpcy5oaWRlQ29sdW1uKGNvbHNbX2ldLmlkLCB7fSwgdHJ1ZSwgdHJ1ZSk7ZWxzZSBpZiAoY29sc1tfaV0uYmF0Y2ggJiYgdGhpcy5jb25maWcudmlzaWJsZUJhdGNoICYmIGNvbHNbX2ldLmJhdGNoICE9IHRoaXMuY29uZmlnLnZpc2libGVCYXRjaCkge1xuXHQgICAgICAgIHRoaXMuaGlkZUNvbHVtbihjb2xzW19pXS5pZCwge30sIHRydWUsIHRydWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0SW5pdGlhbFNwYW5zOiBmdW5jdGlvbiAoY29scywgZWxlbWVudHMpIHtcblx0ICAgIGZvciAodmFyIGggPSAwOyBoIDwgZWxlbWVudHMubGVuZ3RoOyBoKyspIHtcblx0ICAgICAgdmFyIGxpbmUgPSBlbGVtZW50c1toXTtcblx0ICAgICAgaWYgKGxpbmUgJiYgbGluZS5jb2xzcGFuICYmICFsaW5lLiRjb2xzcGFuKSBsaW5lLiRjb2xzcGFuID0gbGluZS5jb2xzcGFuO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgbW92ZUNvbHVtbjogZnVuY3Rpb24gKGlkLCBpbmRleCkge1xuXHQgICAgdmFyIHN0YXJ0X2luZGV4ID0gdGhpcy5nZXRDb2x1bW5JbmRleChpZCk7XG5cdCAgICBpZiAoc3RhcnRfaW5kZXggPT0gaW5kZXgpIHJldHVybjsgLy9hbHJlYWR5IGluIHBsYWNlXG5cblx0ICAgIHZhciBjb2x1bW5zID0gdGhpcy5fc2V0dGluZ3MuY29sdW1ucztcblx0ICAgIHZhciBzdGFydCA9IGNvbHVtbnMuc3BsaWNlKHN0YXJ0X2luZGV4LCAxKTtcblx0ICAgIHZhciBwb3MgPSBpbmRleCAtIChpbmRleCA+IHN0YXJ0X2luZGV4ID8gMSA6IDApO1xuXHQgICAgUG93ZXJBcnJheS5pbnNlcnRBdC5jYWxsKGNvbHVtbnMsIHN0YXJ0WzBdLCBwb3MpO1xuXHQgICAgdmFyIG9yZGVyID0gdGhpcy5faGlkZGVuX2NvbHVtbl9vcmRlcjsgLy8gb3JkZXIgZXhpc3RzIGV2ZW4gaWYgY29sdW1ucyBhcmUgbm90IHJlb3JkZXJlZCwgc28gY2hlY2tpbmcgZm9yIGxlbmd0aFxuXG5cdCAgICBpZiAob3JkZXIubGVuZ3RoKSB7XG5cdCAgICAgIG9yZGVyID0gdG9BcnJheShvcmRlcik7XG5cdCAgICAgIHZhciBoaWRkZW5faW5kZXggPSBvcmRlci5maW5kKGlkKTtcblx0ICAgICAgb3JkZXIucmVtb3ZlQXQoaGlkZGVuX2luZGV4KTtcblx0ICAgICAgaWYgKHBvcyA9PT0gMCkgb3JkZXIudW5zaGlmdChpZCk7ZWxzZSB7XG5cdCAgICAgICAgb3JkZXIuaW5zZXJ0QXQoaWQsIG9yZGVyLmZpbmQoY29sdW1uc1twb3MgLSAxXS5pZCkgKyAxKTtcblx0ICAgICAgfVxuXHQgICAgfSAvL1RPRE86IHNwbGl0IGhhbmRsaW5nXG5cdCAgICAvL3dlIGNhbiBtb3ZlIHNwbGl0IGxpbmUgd2hlbiBjb2x1bW4gZHJvcHBlZCBhZnRlciBpdFxuXG5cblx0ICAgIHRoaXMuX3JlZnJlc2hfY29sdW1ucygpO1xuXHQgIH0sXG5cdCAgX2luaXRfaG9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaG9yZGVyID0gdGhpcy5faGlkZGVuX2NvbHVtbl9vcmRlcjtcblx0ICAgIHZhciBjb2xzID0gdGhpcy5fc2V0dGluZ3MuY29sdW1ucztcblxuXHQgICAgaWYgKCFob3JkZXIubGVuZ3RoKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29scy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGhvcmRlcltpXSA9IGNvbHNbaV0uaWQ7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9oaWRkZW5fc3BsaXQgPSBbdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0LCB0aGlzLl9yaWdodFNwbGl0XTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGlzQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICByZXR1cm4gIXRoaXMuX2hpZGRlbl9jb2x1bW5faGFzaFtpZF07XG5cdCAgfSxcblx0ICBoaWRlQ29sdW1uOiBmdW5jdGlvbiAoaWQsIG9wdHMsIHNpbGVudCwgbW9kZSkge1xuXHQgICAgdmFyIGNvbHMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zO1xuXHQgICAgdmFyIGhvcmRlciA9IHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXI7XG5cdCAgICB2YXIgaGhhc2ggPSB0aGlzLl9oaWRkZW5fY29sdW1uX2hhc2g7XG5cdCAgICB2YXIgY29sdW1uO1xuXHQgICAgdmFyIHNwYW4gPSAxO1xuXHQgICAgb3B0cyA9IG9wdHMgfHwge307XG5cblx0ICAgIGlmIChtb2RlICE9PSBmYWxzZSkge1xuXHQgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldENvbHVtbkluZGV4KGlkKTtcblx0ICAgICAgYXNzZXJ0KGluZGV4ICE9IC0xLCBcImhpZGVDb2x1bW46IGludmFsaWQgSUQgb3IgYWxyZWFkeSBoaWRkZW5cIik7XG5cdCAgICAgIGlmIChpbmRleCA9PT0gLTEgfHwgIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVDb2x1bW5IaWRlXCIsIFtpZF0pKSByZXR1cm47IC8vaW4gY2FzZSBvZiBzZWNvbmQgY2FsbCB0byBoaWRlIHRoZSBzYW1lIGNvbHVtbiwgY29tbWFuZCB3aWxsIGJlIGlnbm9yZWRcblxuXHQgICAgICBpZiAoaW5kZXggPT0gLTEpIHJldHVybjtcblxuXHQgICAgICB0aGlzLl9pbml0X2hvcmRlcigpO1xuXG5cdCAgICAgIGlmIChvcHRzLnNwYW5zKSB7XG5cdCAgICAgICAgdmFyIGhlYWRlciA9IGNvbHNbaW5kZXhdLmhlYWRlcjtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaGVhZGVyW2ldKSB7XG5cdCAgICAgICAgICAgIGhlYWRlcltpXS4kZ3JvdXBTcGFuID0gaGVhZGVyW2ldLmNvbHNwYW4gfHwgMTtcblx0ICAgICAgICAgICAgc3BhbiA9IE1hdGgubWF4KHNwYW4sIGhlYWRlcltpXS4kZ3JvdXBTcGFuKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaW5kZXggPCB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQpIHRoaXMuX3NldHRpbmdzLmxlZnRTcGxpdCAtPSBzcGFuO1xuXHQgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fcmlnaHRTcGxpdCkgdGhpcy5fc2V0dGluZ3MucmlnaHRTcGxpdCAtPSBzcGFuO2Vsc2UgdGhpcy5fcmlnaHRTcGxpdCAtPSBzcGFuO1xuXG5cdCAgICAgIGZvciAodmFyIF9pMiA9IGluZGV4ICsgc3BhbiAtIDE7IF9pMiA+PSBpbmRleDsgX2kyLS0pIHtcblx0ICAgICAgICB0aGlzLl9oaWRlQ29sdW1uKGluZGV4KTtcblxuXHQgICAgICAgIGNvbHVtbiA9IGNvbHMuc3BsaWNlKGluZGV4LCAxKVswXTtcblx0ICAgICAgICBoaGFzaFtjb2x1bW4uaWRdID0gY29sdW1uO1xuXHQgICAgICAgIGNvbHVtbi5feXIwID0gLTE7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuX2NvbHVtbnNfcHVsbFtjb2x1bW4uaWRdO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyQ29sdW1uSGlkZVwiLCBbaWRdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbHVtbiA9IGhoYXNoW2lkXTtcblx0ICAgICAgYXNzZXJ0KGNvbHVtbiwgXCJzaG93Q29sdW1uOiBpbnZhbGlkIElEIG9yIGFscmVhZHkgdmlzaWJsZVwiKTsgLy9pbiBjYXNlIG9mIHNlY29uZCBzaG93IGNvbW1hbmQgZm9yIGFscmVhZHkgdmlzaWJsZSBjb2x1bW4gLSBpZ25vcmluZ1xuXG5cdCAgICAgIGlmICghY29sdW1uIHx8ICF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQ29sdW1uU2hvd1wiLCBbaWRdKSkgcmV0dXJuO1xuXHQgICAgICB2YXIgcHJldiA9IG51bGw7XG5cdCAgICAgIHZhciBfaTMgPSAwO1xuXHQgICAgICB2YXIgaGluZGV4ID0gMDtcblxuXHQgICAgICBmb3IgKDsgX2kzIDwgaG9yZGVyLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICBpZiAoaG9yZGVyW19pM10gPT0gaWQpIHtcblx0ICAgICAgICAgIGhpbmRleCA9IF9pMztcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghaGhhc2hbaG9yZGVyW19pM11dKSBwcmV2ID0gaG9yZGVyW19pM107XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgX2luZGV4ID0gcHJldiA/IHRoaXMuZ2V0Q29sdW1uSW5kZXgocHJldikgKyAxIDogMDtcblxuXHQgICAgICBpZiAob3B0cy5zcGFucykge1xuXHQgICAgICAgIHZhciBfaGVhZGVyID0gY29sdW1uLmhlYWRlcjtcblxuXHQgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IF9oZWFkZXIubGVuZ3RoOyBfaTQrKykge1xuXHQgICAgICAgICAgaWYgKF9oZWFkZXJbX2k0XSkge1xuXHQgICAgICAgICAgICBfaGVhZGVyW19pNF0uY29sc3BhbiA9IF9oZWFkZXJbX2k0XS4kZ3JvdXBTcGFuIHx8IF9oZWFkZXJbX2k0XS5jb2xzcGFuO1xuXHQgICAgICAgICAgICBkZWxldGUgX2hlYWRlcltfaTRdLiRncm91cFNwYW47XG5cdCAgICAgICAgICAgIHNwYW4gPSBNYXRoLm1heChzcGFuLCBfaGVhZGVyW19pNF0uY29sc3BhbiB8fCAxKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBfaTUgPSBoaW5kZXggKyBzcGFuIC0gMTsgX2k1ID49IGhpbmRleDsgX2k1LS0pIHtcblx0ICAgICAgICB2YXIgX2NvbHVtbiA9IGhoYXNoW2hvcmRlcltfaTVdXTtcblxuXHQgICAgICAgIGlmIChfY29sdW1uKSB7XG5cdCAgICAgICAgICAvL2NhbiBiZSBhbHJlYWR5IHNob3duIGJ5IGFub3RoZXIgYWN0aW9uXG5cdCAgICAgICAgICBQb3dlckFycmF5Lmluc2VydEF0LmNhbGwoY29scywgX2NvbHVtbiwgX2luZGV4KTtcblx0ICAgICAgICAgIGRlbGV0ZSBfY29sdW1uLmhpZGRlbjtcblx0ICAgICAgICAgIGRlbGV0ZSBoaGFzaFtfY29sdW1uLmlkXTtcblx0ICAgICAgICAgIHRoaXMuX2NvbHVtbnNfcHVsbFtfY29sdW1uLmlkXSA9IF9jb2x1bW47XG5cdCAgICAgICAgfSBlbHNlIHNwYW4tLTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChoaW5kZXggPCB0aGlzLl9oaWRkZW5fc3BsaXRbMF0pIHRoaXMuX3NldHRpbmdzLmxlZnRTcGxpdCArPSBzcGFuO1xuXHQgICAgICBpZiAoaGluZGV4ID49IHRoaXMuX2hpZGRlbl9zcGxpdFsxXSkgdGhpcy5fc2V0dGluZ3MucmlnaHRTcGxpdCArPSBzcGFuO2Vsc2UgdGhpcy5fcmlnaHRTcGxpdCArPSBzcGFuO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJDb2x1bW5TaG93XCIsIFtpZF0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29sdW1uLmhlYWRlcikgdGhpcy5fZml4Q29sc3BhbnNIaWRkZW4oY29sdW1uLCBtb2RlICE9PSBmYWxzZSA/IDAgOiAxLCBcImhlYWRlclwiKTtcblx0ICAgIGlmIChjb2x1bW4uZm9vdGVyKSB0aGlzLl9maXhDb2xzcGFuc0hpZGRlbihjb2x1bW4sIG1vZGUgIT09IGZhbHNlID8gMCA6IDEsIFwiZm9vdGVyXCIpO1xuXHQgICAgaWYgKCFzaWxlbnQpIHRoaXMuX3JlZnJlc2hfY29sdW1ucygpO1xuXHQgIH0sXG5cdCAgX2ZpeENvbHNwYW5zSGlkZGVuOiBmdW5jdGlvbiAoY29uZmlnLCBtb2QsIGVsTmFtZSkge1xuXHQgICAgZm9yICh2YXIgaSA9IGNvbmZpZ1tlbE5hbWVdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgIHZhciBpbmQgPSB0aGlzLl9oaWRkZW5fY29sdW1uX29yZGVyO1xuXHQgICAgICB2YXIgc3BhblNvdXJjZSxcblx0ICAgICAgICAgIGlzSGlkZGVuID0gZmFsc2UsXG5cdCAgICAgICAgICBzcGFuU2l6ZSA9IDA7XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbmQubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICB2YXIgY29sQ29uZmlnID0gdGhpcy5nZXRDb2x1bW5Db25maWcoaW5kW2pdKTtcblx0ICAgICAgICB2YXIgZWwgPSBjb2xDb25maWdbZWxOYW1lXVtpXTtcblxuXHQgICAgICAgIGlmICghdGhpcy5pc0NvbHVtblZpc2libGUoaW5kW2pdKSkge1xuXHQgICAgICAgICAgLy9oaWRkZW4gY29sdW1uXG5cdCAgICAgICAgICBpZiAoZWwgJiYgZWwuJGNvbHNwYW4gJiYgc3BhblNpemUgPD0gMCkge1xuXHQgICAgICAgICAgICAvL3N0YXJ0IG9mIGNvbHNwYW4gaW4gaGlkZGVuXG5cdCAgICAgICAgICAgIHNwYW5TaXplID0gZWwuY29sc3BhbiA9IGVsLiRjb2xzcGFuO1xuXHQgICAgICAgICAgICBpc0hpZGRlbiA9IHNwYW5Tb3VyY2UgPSBlbDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHNwYW5Tb3VyY2UgJiYgc3BhblNpemUgPiAwKSB7XG5cdCAgICAgICAgICAgIC8vaGlkZGVuIGNvbHVtbiBpbiBjb2xzcGFuLCBkZWNyZWFzZSBjb2xzcGFuIHNpemVcblx0ICAgICAgICAgICAgc3BhblNvdXJjZS5jb2xzcGFuLS07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vdmlzaWJsZSBjb2x1bW5cblx0ICAgICAgICAgIGlmIChpc0hpZGRlbiAmJiBzcGFuU2l6ZSA+IDAgJiYgc3BhblNvdXJjZSAmJiBzcGFuU291cmNlLmNvbHNwYW4gPiAwKSB7XG5cdCAgICAgICAgICAgIC8vYml0IHN0YXJ0IG9mIGNvbHNwYW4gaXMgaGlkZGVuXG5cdCAgICAgICAgICAgIGVsID0gY29sQ29uZmlnW2VsTmFtZV1baV0gPSBzcGFuU291cmNlO1xuXHQgICAgICAgICAgICBzcGFuU291cmNlID0gZWw7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGVsICYmIGVsLiRjb2xzcGFuICYmIHNwYW5TaXplIDw9IDApIHtcblx0ICAgICAgICAgICAgLy92aXNpYmxlIHN0YXJ0IG9mIGNvbHNwYW5cblx0ICAgICAgICAgICAgc3BhblNpemUgPSBlbC5jb2xzcGFuID0gZWwuJGNvbHNwYW47XG5cdCAgICAgICAgICAgIHNwYW5Tb3VyY2UgPSBlbDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaXNIaWRkZW4gPSBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHNwYW5TaXplLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIHJlZnJlc2hDb2x1bW5zOiBmdW5jdGlvbiAoY29sdW1ucywgcmVzZXQpIHtcblx0ICAgIHRoaXMuX2R0YWJsZV9jb2x1bW5fcmVmcmVzaCA9IHRydWU7XG5cblx0ICAgIGlmIChjb2x1bW5zICYmIGNvbHVtbnMgIT0gdGhpcy5jb25maWcuY29sdW1ucyB8fCByZXNldCkge1xuXHQgICAgICB0aGlzLl9jbGVhcl9oaWRkZW5fc3RhdGUoKTtcblxuXHQgICAgICB0aGlzLl9maWx0ZXJfZWxlbWVudHMgPSB7fTtcblx0ICAgICAgaWYgKGNvbHVtbnMpIHRoaXMuX3JpZ2h0U3BsaXQgPSBjb2x1bW5zLmxlbmd0aCAtICh0aGlzLmNvbmZpZy5yaWdodFNwbGl0IHx8IDApO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9jb2x1bW5zX3B1bGwgPSB7fTsgLy9jbGVhciByZW5kZXJlZCBkYXRhXG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY29sID0gdGhpcy5fY29sdW1uc1tpXTtcblx0ICAgICAgdGhpcy5fY29sdW1uc19wdWxsW2NvbC5pZF0gPSBjb2w7XG5cdCAgICAgIGNvbC5hdHRhY2hlZCA9IGNvbC5ub2RlID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgMzsgX2k2KyspIHtcblx0ICAgICAgdGhpcy5faGVhZGVyLmNoaWxkTm9kZXNbX2k2XS5pbm5lckhUTUwgPSBcIlwiO1xuXHQgICAgICB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbX2k2XS5maXJzdENoaWxkLmlubmVySFRNTCA9IFwiXCI7XG5cdCAgICB9IC8vcmVuZGVyIG5ldyBzdHJ1Y3R1cmVcblxuXG5cdCAgICB0aGlzLl9jb2x1bW5zID0gdGhpcy5jb25maWcuY29sdW1ucyA9IGNvbHVtbnMgfHwgdGhpcy5jb25maWcuY29sdW1ucztcblx0ICAgIHRoaXMuX3JpZ2h0U3BsaXQgPSB0aGlzLl9jb2x1bW5zLmxlbmd0aCAtIHRoaXMuX3NldHRpbmdzLnJpZ2h0U3BsaXQ7XG5cdCAgICB0aGlzLl9kdGFibGVfZnVsbHlfcmVhZHkgPSAwO1xuXG5cdCAgICB0aGlzLl9kZWZpbmVfc3RydWN0dXJlKCk7XG5cblx0ICAgIHRoaXMuY2FsbEV2ZW50KFwib25TdHJ1Y3R1cmVVcGRhdGVcIik7XG5cblx0ICAgIHRoaXMuX3VwZGF0ZV9zY3JvbGwoKTtcblxuXHQgICAgdGhpcy5yZW5kZXIoKTtcblx0ICAgIHRoaXMuX2R0YWJsZV9jb2x1bW5fcmVmcmVzaCA9IDA7XG5cdCAgfSxcblx0ICBfcmVmcmVzaF9jb2x1bW5zOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLl9kdGFibGVfZnVsbHlfcmVhZHkgPSAwO1xuXHQgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0cnVjdHVyZVVwZGF0ZVwiKTtcblxuXHQgICAgdGhpcy5fYXBwbHlfaGVhZGVycygpO1xuXG5cdCAgICB0aGlzLnJlbmRlcigpO1xuXHQgIH0sXG5cdCAgc2hvd0NvbHVtbjogZnVuY3Rpb24gKGlkLCBvcHRzLCBzaWxlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLmhpZGVDb2x1bW4oaWQsIG9wdHMsIHNpbGVudCwgZmFsc2UpO1xuXHQgIH0sXG5cdCAgc2hvd0NvbHVtbkJhdGNoOiBmdW5jdGlvbiAoYmF0Y2gsIG1vZGUpIHtcblx0ICAgIHZhciBwcmVzZXJ2ZSA9IHR5cGVvZiBtb2RlICE9IFwidW5kZWZpbmVkXCI7XG5cdCAgICBtb2RlID0gbW9kZSAhPT0gZmFsc2U7XG5cdCAgICB0aGlzLmVhY2hDb2x1bW4oZnVuY3Rpb24gKGlkLCBjb2wpIHtcblx0ICAgICAgaWYgKGNvbC5iYXRjaCkge1xuXHQgICAgICAgIHZhciBoaWRkZW4gPSB0aGlzLl9oaWRkZW5fY29sdW1uX2hhc2hbY29sLmlkXTtcblx0ICAgICAgICBpZiAoIW1vZGUpIGhpZGRlbiA9ICFoaWRkZW47XG5cdCAgICAgICAgaWYgKGNvbC5iYXRjaCA9PSBiYXRjaCAmJiBoaWRkZW4pIHRoaXMuaGlkZUNvbHVtbihjb2wuaWQsIHtcblx0ICAgICAgICAgIHNwYW5zOiB0cnVlXG5cdCAgICAgICAgfSwgdHJ1ZSwgIW1vZGUpO2Vsc2UgaWYgKCFwcmVzZXJ2ZSAmJiBjb2wuYmF0Y2ggIT0gYmF0Y2ggJiYgIWhpZGRlbikgdGhpcy5oaWRlQ29sdW1uKGNvbC5pZCwge1xuXHQgICAgICAgICAgc3BhbnM6IHRydWVcblx0ICAgICAgICB9LCB0cnVlLCBtb2RlKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdHJ1ZSk7XG5cblx0ICAgIHRoaXMuX3JlZnJlc2hfY29sdW1ucygpO1xuXHQgIH1cblx0fTtcblxuXHR2YXIgTWl4aW4kOSA9IHtcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uQWZ0ZXJTY3JvbGxcIiwgdGhpcy5fc2V0X2ZvY3VzYWJsZV9pdGVtKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkZvY3VzXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgYWRkQ3NzKHRoaXMuJHZpZXcsIFwid2ViaXhfZHRhYmxlX2ZvY3VzZWRcIik7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJsdXJcIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICByZW1vdmVDc3ModGhpcy4kdmlldywgXCJ3ZWJpeF9kdGFibGVfZm9jdXNlZFwiKTtcblx0ICAgIH0pO1xuXHQgIH0sXG5cdCAgX3NldF9mb2N1c2FibGVfaXRlbTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHNlbCA9IHRoaXMuX2dldFZpc2libGVTZWxlY3Rpb24oKTtcblxuXHQgICAgaWYgKCFzZWwpIHtcblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLl9kYXRhb2JqLnF1ZXJ5U2VsZWN0b3IoXCIud2ViaXhfY2VsbFwiKTtcblxuXHQgICAgICBpZiAobm9kZSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfZ2V0VmlzaWJsZVNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0ZWRJZCh0cnVlKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuaXNDb2x1bW5WaXNpYmxlKHNlbFtpXS5jb2x1bW4pKSByZXR1cm4gdGhpcy5nZXRJdGVtTm9kZShzZWxbaV0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIG1vdmVTZWxlY3Rpb246IGZ1bmN0aW9uIChtb2RlLCBkZXRhaWxzLCBmb2N1cykge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmRpc2FibGVkKSByZXR1cm47XG5cdCAgICBkZXRhaWxzID0gZGV0YWlscyB8fCB7fTsgLy9nZXQgZXhpc3Rpbmcgc2VsZWN0aW9uIGFzIGFycmF5XG5cblx0ICAgIHZhciB0ID0gdGhpcy5nZXRTZWxlY3RlZElkKHRydWUpO1xuXHQgICAgdmFyIGluZGV4JCQxID0gdC5sZW5ndGggLSAxO1xuXHQgICAgdmFyIHByZXNlcnZlID0gdGhpcy5fc2V0dGluZ3MubXVsdGlzZWxlY3QgfHwgdGhpcy5fc2V0dGluZ3MuYXJlYXNlbGVjdCA/IGRldGFpbHMuc2hpZnQgOiBmYWxzZTsgLy9jaGFuZ2UgZGVmYXVsdHMgaW4gY2FzZSBvZiBtdWx0aXNlbGVjdGlvblxuXG5cdCAgICBpZiAodC5sZW5ndGggPiAxICYmIHRoaXMuX3NldHRpbmdzLnNlbGVjdCAhPT0gXCJjZWxsXCIpIHtcblx0ICAgICAgdCA9IHQuc29ydChiaW5kKGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZ2V0SW5kZXhCeUlkKGEucm93KSA+IHRoaXMuZ2V0SW5kZXhCeUlkKGIucm93KSB8fCB0aGlzLmdldENvbHVtbkluZGV4KGEuY29sdW1uKSA+IHRoaXMuZ2V0Q29sdW1uSW5kZXgoYi5jb2x1bW4pKSByZXR1cm4gMTtlbHNlIHJldHVybiAtMTtcblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgICBpZiAobW9kZSA9PSBcInVwXCIgfHwgbW9kZSA9PSBcImxlZnRcIiB8fCBtb2RlID09IFwidG9wXCIgfHwgbW9kZSA9PSBcInBndXBcIikgaW5kZXgkJDEgPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5kZXgkJDEgPCAwICYmIHRoaXMuY291bnQoKSkge1xuXHQgICAgICAvL25vIHNlbGVjdGlvblxuXHQgICAgICBpZiAobW9kZSA9PSBcImRvd25cIiB8fCBtb2RlID09IFwicmlnaHRcIikgbW9kZSA9IFwidG9wXCI7ZWxzZSBpZiAobW9kZSA9PSBcInVwXCIgfHwgbW9kZSA9PSBcImxlZnRcIikgbW9kZSA9IFwiYm90dG9tXCI7ZWxzZSByZXR1cm47XG5cdCAgICAgIGluZGV4JCQxID0gMDtcblx0ICAgICAgdCA9IFt7XG5cdCAgICAgICAgcm93OiAxLFxuXHQgICAgICAgIGNvbHVtbjogMVxuXHQgICAgICB9XTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGluZGV4JCQxID49IDApIHtcblx0ICAgICAgdmFyIHJvdyA9IHRbaW5kZXgkJDFdLnJvdztcblx0ICAgICAgdmFyIGNvbHVtbiA9IHRbaW5kZXgkJDFdLmNvbHVtbjtcblxuXHQgICAgICBpZiAobW9kZSA9PSBcInRvcFwiIHx8IG1vZGUgPT0gXCJib3R0b21cIikge1xuXHQgICAgICAgIGlmIChyb3cpIHtcblx0ICAgICAgICAgIC8vIGZpcnN0L2xhc3Qgcm93IHNldHRpbmdcblx0ICAgICAgICAgIGlmIChtb2RlID09IFwidG9wXCIpIHJvdyA9IHRoaXMuZGF0YS5nZXRGaXJzdElkKCk7ZWxzZSBpZiAobW9kZSA9PSBcImJvdHRvbVwiKSByb3cgPSB0aGlzLmRhdGEuZ2V0TGFzdElkKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGNvbHVtbikge1xuXHQgICAgICAgICAgLy8gZmlyc3QvbGFzdCBjb2x1bW4gc2V0dGluZ1xuXHQgICAgICAgICAgaW5kZXgkJDEgPSAwO1xuXHQgICAgICAgICAgaWYgKG1vZGUgPT0gXCJib3R0b21cIikgaW5kZXgkJDEgPSB0aGlzLmNvbmZpZy5jb2x1bW5zLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbklkKGluZGV4JCQxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSBcInVwXCIgfHwgbW9kZSA9PSBcImRvd25cIiB8fCBtb2RlID09IFwicGd1cFwiIHx8IG1vZGUgPT0gXCJwZ2Rvd25cIikge1xuXHQgICAgICAgIGlmIChyb3cpIHtcblx0ICAgICAgICAgIC8vaXQgc2VlbXMgcm93J3MgY2FuIGJlIHNlbGV0ZWRcblx0ICAgICAgICAgIHZhciBfaW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChyb3cpO1xuXG5cdCAgICAgICAgICB2YXIgc3RlcCA9IDE7XG5cdCAgICAgICAgICBpZiAobW9kZSA9PSBcInBndXBcIiB8fCBtb2RlID09IFwicGdkb3duXCIpIHN0ZXAgPSB0aGlzLl9wYWdlciA/IHRoaXMuX3BhZ2VyLmNvbmZpZy5zaXplIDogTWF0aC5yb3VuZCh0aGlzLl9kdGFibGVfb2Zmc2V0X2hlaWdodCAvIHRoaXMuX3NldHRpbmdzLnJvd0hlaWdodCk7IC8vZ2V0IG5ldyBzZWxlY3Rpb24gcm93XG5cblx0ICAgICAgICAgIGlmIChtb2RlID09IFwidXBcIiB8fCBtb2RlID09IFwicGd1cFwiKSBfaW5kZXggLT0gc3RlcDtlbHNlIGlmIChtb2RlID09IFwiZG93blwiIHx8IG1vZGUgPT0gXCJwZ2Rvd25cIikgX2luZGV4ICs9IHN0ZXA7IC8vY2hlY2sgdGhhdCB3ZSBpbiB2YWxpZCByb3cgcmFuZ2VcblxuXHQgICAgICAgICAgaWYgKF9pbmRleCA8IDApIF9pbmRleCA9IDA7XG5cdCAgICAgICAgICBpZiAoX2luZGV4ID49IHRoaXMuZGF0YS5vcmRlci5sZW5ndGgpIF9pbmRleCA9IHRoaXMuZGF0YS5vcmRlci5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgcm93ID0gdGhpcy5nZXRJZEJ5SW5kZXgoX2luZGV4KTtcblx0ICAgICAgICAgIGlmICghcm93ICYmIHRoaXMuX3NldHRpbmdzLnBhZ2VyKSB0aGlzLnNob3dJdGVtQnlJbmRleChfaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChtb2RlID09IFwicmlnaHRcIiB8fCBtb2RlID09IFwibGVmdFwiKSB7XG5cdCAgICAgICAgaWYgKGNvbHVtbiAmJiB0aGlzLmNvbmZpZy5zZWxlY3QgIT0gXCJyb3dcIikge1xuXHQgICAgICAgICAgLy9pdCBzZWVtcyBjb2x1bW4ncyBjYW4gYmUgc2VsZWN0ZWRcblx0ICAgICAgICAgIHZhciBfaW5kZXgyID0gdGhpcy5nZXRDb2x1bW5JbmRleChjb2x1bW4pOyAvL2dldCBuZXcgc2VsZWN0ZWQgY29sdW1uXG5cblxuXHQgICAgICAgICAgaWYgKG1vZGUgPT0gXCJyaWdodFwiKSBfaW5kZXgyKys7ZWxzZSBpZiAobW9kZSA9PSBcImxlZnRcIikgX2luZGV4Mi0tOyAvL2NoZWNrIHRoYXQgcmVzdWx0IGNvbHVtbiBpbmRleCBpcyBpbiB2YWxpZCByYW5nZVxuXG5cdCAgICAgICAgICBpZiAoX2luZGV4MiA8IDApIF9pbmRleDIgPSAwO1xuXHQgICAgICAgICAgaWYgKF9pbmRleDIgPj0gdGhpcy5jb25maWcuY29sdW1ucy5sZW5ndGgpIF9pbmRleDIgPSB0aGlzLmNvbmZpZy5jb2x1bW5zLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbHVtbklkKF9pbmRleDIpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoKHRoaXMub3BlbiB8fCB0aGlzLl9zdWJWaWV3U3RvcmFnZSkgJiYgbW9kZSA9PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4ocm93KSA6IHRoaXMub3BlblN1Yihyb3cpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoKHRoaXMuY2xvc2UgfHwgdGhpcy5fc3ViVmlld1N0b3JhZ2UpICYmIG1vZGUgPT0gXCJsZWZ0XCIpIHtcblx0ICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlID8gdGhpcy5jbG9zZShyb3cpIDogdGhpcy5jbG9zZVN1Yihyb3cpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhc3NlcnQoZmFsc2UsIFwiTm90IHN1cHBvcnRlZCBzZWxlY3Rpb24gbW92aW5nIG1vZGVcIik7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHJvdykge1xuXHQgICAgICAgIHRoaXMuc2hvd0NlbGwocm93LCBjb2x1bW4pO1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLnNlbGVjdCkge1xuXHQgICAgICAgICAgLy9zd2l0Y2ggb24gY2VsbCBvciByb3cgc2VsZWN0aW9uIGJ5IGRlZmF1bHRcblx0ICAgICAgICAgIGV4cG9ydHMuZXh0ZW5kKHRoaXMsIHRoaXMuX3NlbGVjdGlvbnMuX2NvbW1vbnNlbGVjdCwgdHJ1ZSk7XG5cdCAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5zZWxlY3QgPSB0aGlzLm9wZW4gfHwgdGhpcy5fc3ViVmlld1N0b3JhZ2UgPyBcInJvd1wiIDogXCJjZWxsXCI7XG5cdCAgICAgICAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCB0aGlzLl9zZWxlY3Rpb25zW3RoaXMuX3NldHRpbmdzLnNlbGVjdF0sIHRydWUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBjZWxsID0ge1xuXHQgICAgICAgICAgcm93OiByb3csXG5cdCAgICAgICAgICBjb2x1bW46IGNvbHVtblxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBpZiAocHJlc2VydmUgJiYgdGhpcy5fc2V0dGluZ3Muc2VsZWN0ID09IFwiYXJlYVwiKSB7XG5cdCAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuX3NlbGVjdGVkX2FyZWFzW3RoaXMuX3NlbGVjdGVkX2FyZWFzLmxlbmd0aCAtIDFdO1xuXG5cdCAgICAgICAgICB0aGlzLl9leHRlbmRBcmVhUmFuZ2UoY2VsbCwgbGFzdCwgbW9kZSwgZGV0YWlscyk7XG5cdCAgICAgICAgfSBlbHNlIHRoaXMuX3NlbGVjdChjZWxsLCBwcmVzZXJ2ZSk7XG5cblx0ICAgICAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmNsaXBib2FyZCAmJiBmb2N1cyAhPT0gZmFsc2UpIHtcblx0ICAgICAgICAgIHZhciBub2RlID0gdGhpcy5nZXRJdGVtTm9kZShjZWxsKTtcblx0ICAgICAgICAgIGlmIChub2RlKSBub2RlLmZvY3VzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH07XG5cblx0dmFyIERyYWdPcmRlciQxID0ge1xuXHQgIF9hZGRfY3NzOiBmdW5jdGlvbiAoc291cmNlKSB7XG5cdCAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLl9kcmFnX2NvbnRleHQ7XG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnByZXJlbmRlcikgc291cmNlID0gW2NvbnRleHQuc3RhcnRdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0SXRlbU5vZGUoe1xuXHQgICAgICAgICAgcm93OiBzb3VyY2VbaV0sXG5cdCAgICAgICAgICBjaW5kOiBqXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKG5vZGUpIGFkZENzcyhub2RlLCBcIndlYml4X2ludmlzaWJsZVwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuZGF0YS5hZGRNYXJrKHNvdXJjZVtpXSwgXCJ3ZWJpeF9pbnZpc2libGVcIiwgMSwgMSwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfcmVtb3ZlX2NzczogZnVuY3Rpb24gKHNvdXJjZSkge1xuXHQgICAgdmFyIGNvbnRleHQgPSBEcmFnQ29udHJvbC5fZHJhZ19jb250ZXh0O1xuXHQgICAgaWYgKCF0aGlzLl9zZXR0aW5ncy5wcmVyZW5kZXIpIHNvdXJjZSA9IFtjb250ZXh0LnN0YXJ0XTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKHtcblx0ICAgICAgICAgIHJvdzogc291cmNlW2ldLFxuXHQgICAgICAgICAgY2luZDogalxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIGlmIChub2RlKSByZW1vdmVDc3Mobm9kZSwgXCJ3ZWJpeF9pbnZpc2libGVcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmRhdGEucmVtb3ZlTWFyayhzb3VyY2VbaV0sIFwid2ViaXhfaW52aXNpYmxlXCIsIDEpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3NldF9kcm9wX2FyZWE6IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY29sdW1uID0gdGhpcy5fY29sdW1uc1tpXTtcblx0ICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldEl0ZW1Ob2RlKHtcblx0ICAgICAgICByb3c6IHRhcmdldCxcblx0ICAgICAgICBjaW5kOiBpXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIGlmIChub2RlKSB7XG5cdCAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShEcmFnQ29udHJvbC5fZHJvcEhUTUxbaV0sIG5vZGUpO1xuXHQgICAgICB9IGVsc2UgY29sdW1uLm5vZGUuYXBwZW5kQ2hpbGQoRHJhZ0NvbnRyb2wuX2Ryb3BIVE1MW2ldKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9pbml0X2Ryb3BfYXJlYTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRyb3BBcmVhID0gW107XG5cdCAgICB2YXIgY291bnQgPSB0aGlzLl9jb2x1bW5zLmxlbmd0aDtcblx0ICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ICAgIG5vZGUuY2xhc3NOYW1lID0gXCJ3ZWJpeF9kcm9wX2FyZWFcIjtcblx0ICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0ICsgXCJweFwiO1xuXHQgICAgbm9kZS5pbm5lckhUTUwgPSB0aGlzLiRkcm9wSFRNTCgpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgZHJvcEFyZWEucHVzaChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkcm9wQXJlYTtcblx0ICB9XG5cdH07XG5cdHZhciBNaXhpbiRhID0ge1xuXHQgIGRyYWdfc2V0dGVyOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIC8vIGRpc2FibGUgZHJhZy1uLWRyb3AgZm9yIGZyb3plbiByb3dzXG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25CZWZvcmVEcmFnXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jaGVja0RyYWdUb3BTcGxpdChjb250ZXh0LnNvdXJjZSk7XG5cdCAgICB9KTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkJlZm9yZURyYWdJblwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY2hlY2tEcmFnVG9wU3BsaXQoY29udGV4dC50YXJnZXQpO1xuXG5cdCAgICAgIGlmICghcmVzdWx0ICYmIERyYWdDb250cm9sLl9kcm9wSFRNTCkge1xuXHQgICAgICAgIHJlbW92ZShEcmFnQ29udHJvbC5fZHJvcEhUTUwpO1xuXHQgICAgICAgIHRoaXMuX21hcmtlZF9pdGVtX2lkID0gRHJhZ0NvbnRyb2wuX2Ryb3BIVE1MID0gbnVsbDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9KTtcblx0ICAgIERyYWdJdGVtLmRyYWdfc2V0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuXHQgICAgaWYgKHZhbHVlID09IFwib3JkZXJcIiB8fCB2YWx1ZSA9PSBcIm1vdmVcIikgZXhwb3J0cy5leHRlbmQodGhpcywgRHJhZ09yZGVyJDEsIHRydWUpO1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH0sXG5cdCAgX2NoZWNrRHJhZ1RvcFNwbGl0OiBmdW5jdGlvbiAoaWRzKSB7XG5cdCAgICB2YXIgaSxcblx0ICAgICAgICBpbmRleCQkMSxcblx0ICAgICAgICBmcm96ZW4gPSBmYWxzZTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0ICYmIGlkcykge1xuXHQgICAgICBpZiAoIWlzQXJyYXkoaWRzKSkgaWRzID0gW2lkc107XG5cblx0ICAgICAgZm9yIChpID0gMDsgIWZyb3plbiAmJiBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaW5kZXgkJDEgPSB0aGlzLmdldEluZGV4QnlJZChpZHNbaV0pO1xuXHQgICAgICAgIGZyb3plbiA9IGluZGV4JCQxID49IDAgJiYgaW5kZXgkJDEgPCB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gIWZyb3plbjtcblx0ICB9LFxuXHQgIF90b0hUTUw6IGZ1bmN0aW9uIChvYmopIHtcblx0ICAgIHZhciB3aWR0aCA9IHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl9zY3JvbGxTaXplWTtcblx0ICAgIHZhciBodG1sID0gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9kZF9kcmFnJyBzdHlsZT0nd2lkdGg6XCIgKyB3aWR0aCArIFwicHg7Jz5cIjtcblx0ICAgIHZhciBjb2xzID0gdGhpcy5fc2V0dGluZ3MuY29sdW1ucztcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKG9iaiwgY29sc1tpXSk7XG5cblx0ICAgICAgaHRtbCArPSBcIjxkaXYgc3R5bGU9J3dpZHRoOlwiICsgY29sc1tpXS53aWR0aCArIFwicHg7Jz5cIiArIHZhbHVlICsgXCI8L2Rpdj5cIjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGh0bWwgKyBcIjwvZGl2PlwiO1xuXHQgIH0sXG5cdCAgZ2V0SGVhZGVyTm9kZTogZnVuY3Rpb24gKGNvbHVtbl9pZCwgcm93X2luZGV4KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0SGVhZGVyTm9kZShjb2x1bW5faWQsIHJvd19pbmRleCwgdGhpcy5faGVhZGVyKTtcblx0ICB9LFxuXHQgIGdldEZvb3Rlck5vZGU6IGZ1bmN0aW9uIChjb2x1bW5faWQsIHJvd19pbmRleCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2dldEhlYWRlck5vZGUoY29sdW1uX2lkLCByb3dfaW5kZXgsIHRoaXMuX2Zvb3Rlcik7XG5cdCAgfSxcblx0ICBfZ2V0SGVhZGVyTm9kZTogZnVuY3Rpb24gKGNvbHVtbl9pZCwgcm93X2luZGV4LCBncm91cCkge1xuXHQgICAgaWYgKHRoaXMuaXNDb2x1bW5WaXNpYmxlKGNvbHVtbl9pZCkpIHtcblx0ICAgICAgdmFyIGluZCA9IHRoaXMuZ2V0Q29sdW1uSW5kZXgoY29sdW1uX2lkKTtcblx0ICAgICAgdmFyIGhpbmQgPSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgPiBpbmQgPyAwIDogdGhpcy5fcmlnaHRTcGxpdCA8PSBpbmQgPyAyIDogMTtcblx0ICAgICAgcm93X2luZGV4ID0gcm93X2luZGV4IHx8IDA7XG5cdCAgICAgIHZhciByb3dzID0gZ3JvdXAuY2hpbGROb2Rlc1toaW5kXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlRSXCIpO1xuXG5cdCAgICAgIGlmIChyb3dzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBub2RlcyA9IHJvd3Nbcm93X2luZGV4ICsgMV0uY2hpbGROb2RlcztcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChub2Rlc1tpXS5nZXRBdHRyaWJ1dGUoXCJjb2x1bW5cIikgPT0gaW5kKSByZXR1cm4gbm9kZXNbaV0uZmlyc3RDaGlsZDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfSxcblx0ICBnZXRJdGVtTm9kZTogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICBpZiAoaWQgJiYgIWlkLmhlYWRlcikge1xuXHQgICAgICB2YXIgcm93ID0gaWQucm93IHx8IGlkO1xuXHQgICAgICB2YXIgcm93aW5kZXggPSB0eXBlb2YgaWQucmluZCA9PT0gXCJudW1iZXJcIiA/IGlkLnJpbmQgOiB0aGlzLmdldEluZGV4QnlJZChyb3cpO1xuXG5cdCAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2dldF95X3JhbmdlKCk7XG5cblx0ICAgICAgdmFyIG1pblJvdyA9IHN0YXRlWzBdIC0gdGhpcy5fc2V0dGluZ3MudG9wU3BsaXQ7IC8vcm93IG5vdCB2aXNpYmxlXG5cblx0ICAgICAgaWYgKHJvd2luZGV4IDwgbWluUm93ICYmIHJvd2luZGV4ID4gc3RhdGVbMV0pIHJldHVybjsgLy9nZXQgdmlzaWJsZSBjb2x1bW5cblxuXHQgICAgICB2YXIgeF9yYW5nZSA9IHRoaXMuX2dldF94X3JhbmdlKCk7XG5cblx0ICAgICAgdmFyIGNvbGluZGV4ID0gdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0ID8gMCA6IHhfcmFuZ2VbMF07XG5cdCAgICAgIHZhciBzcGVjaWZpYyA9IHR5cGVvZiBpZC5jaW5kID09PSBcIm51bWJlclwiO1xuXG5cdCAgICAgIGlmIChpZC5jb2x1bW4gfHwgc3BlY2lmaWMpIHtcblx0ICAgICAgICBjb2xpbmRleCA9IHNwZWNpZmljID8gaWQuY2luZCA6IHRoaXMuZ2V0Q29sdW1uSW5kZXgoaWQuY29sdW1uKTsgLy9jb2x1bW4gbm90IHZpc2libGVcblxuXHQgICAgICAgIGlmIChjb2xpbmRleCA8IHRoaXMuX3JpZ2h0U3BsaXQgJiYgY29saW5kZXggPj0gdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0ICYmIChjb2xpbmRleCA8IHhfcmFuZ2VbMF0gfHwgY29saW5kZXggPiB4X3JhbmdlWzFdKSkgcmV0dXJuO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuX3NldHRpbmdzLmNvbHVtbnNbY29saW5kZXhdO1xuXG5cdCAgICAgIGlmIChjb2x1bW4uYXR0YWNoZWQgJiYgY29sdW1uLm5vZGUpIHtcblx0ICAgICAgICBpZiAocm93ID09PSBcIiR3ZWJpeC1kcm9wXCIpIHJldHVybiBEcmFnQ29udHJvbC5fZHJvcEhUTUxbY29saW5kZXhdO1xuXHQgICAgICAgIHZhciBub2RlSW5kZXggPSByb3dpbmRleCA8IHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0IHx8IHRoaXMuX3NldHRpbmdzLnByZXJlbmRlciA/IHJvd2luZGV4IDogcm93aW5kZXggLSBtaW5Sb3c7XG5cdCAgICAgICAgdmFyIG5vZGVzID0gY29sdW1uLm5vZGUuY2hpbGROb2Rlcztcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4obm9kZXMubGVuZ3RoLCBub2RlSW5kZXggKyAxKTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChub2Rlc1tpXS5jbGFzc05hbWUgPT09IFwid2ViaXhfZHJvcF9hcmVhXCIpIG5vZGVJbmRleCsrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBub2Rlc1tub2RlSW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaXNEcmFnZ2FibGU6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICB2YXIgbm9kZU5hbWUgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KS5ub2RlTmFtZTtcblx0ICAgIHJldHVybiBub2RlTmFtZSAhPSBcIklOUFVUXCIgJiYgbm9kZU5hbWUgIT0gXCJURVhUQVJFQVwiO1xuXHQgIH0sXG5cdCAgZHJhZ0NvbHVtbl9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIGNvbnRyb2w7IC8vd2lsbCBiZSBkZWZpbmVkIGJlbG93XG5cblx0ICAgIGlmICh2YWx1ZSA9PSBcIm9yZGVyXCIpIHtcblx0ICAgICAgY29udHJvbCA9IHtcblx0ICAgICAgICAkZHJhZzogYmluZChmdW5jdGlvbiAocywgZSkge1xuXHQgICAgICAgICAgaWYgKCF0aGlzLl9pc0RyYWdnYWJsZShlKSB8fCB0aGlzLl9yc19wcm9jZXNzKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICB2YXIgaWQgPSB0aGlzLmxvY2F0ZShlKTtcblx0ICAgICAgICAgIGlmICghaWQgfHwgIXRoaXMuY2FsbEV2ZW50KFwib25CZWZvcmVDb2x1bW5EcmFnXCIsIFtpZC5jb2x1bW4sIGVdKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgRHJhZ0NvbnRyb2wuX2RyYWdfY29udGV4dCA9IHtcblx0ICAgICAgICAgICAgZnJvbTogY29udHJvbCxcblx0ICAgICAgICAgICAgc3RhcnQ6IGlkLFxuXHQgICAgICAgICAgICBjdXN0b206IFwiY29sdW1uX2RuZFwiXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGlkLmNvbHVtbik7XG5cdCAgICAgICAgICB0aGlzLl9yZWxhdGl2ZV9jb2x1bW5fZHJhZyA9IHBvc1JlbGF0aXZlKGUpO1xuXHQgICAgICAgICAgdGhpcy5fbGltaXRfY29sdW1uX2RyYWcgPSBjb2x1bW4ud2lkdGg7XG5cdCAgICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9kZF9kcmFnX2NvbHVtbicgc3R5bGU9J3dpZHRoOlwiICsgY29sdW1uLndpZHRoICsgXCJweCc+XCIgKyAoY29sdW1uLmhlYWRlclswXS50ZXh0IHx8IFwiJm5ic3A7XCIpICsgXCI8L2Rpdj5cIjtcblx0ICAgICAgICB9LCB0aGlzKSxcblx0ICAgICAgICAkZHJhZ1BvczogYmluZChmdW5jdGlvbiAocG9zJCQxLCBlLCBub2RlKSB7XG5cdCAgICAgICAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLmdldENvbnRleHQoKTtcblx0ICAgICAgICAgIHZhciBib3ggPSBvZmZzZXQodGhpcy4kdmlldyk7XG5cdCAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0ICAgICAgICAgIHZhciBodG1sID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChwb3MkJDEueCwgYm94LnkgKyAxKTtcblx0ICAgICAgICAgIHZhciBpZCA9IGh0bWwgPyB0aGlzLmxvY2F0ZShodG1sKSA6IG51bGw7XG5cdCAgICAgICAgICB2YXIgc3RhcnQgPSBEcmFnQ29udHJvbC5nZXRDb250ZXh0KCkuc3RhcnQuY29sdW1uO1xuXG5cdCAgICAgICAgICBpZiAoaWQgJiYgaWQuY29sdW1uICE9IHN0YXJ0ICYmICghdGhpcy5fY29sdW1uX2RuZF90ZW1wX2Jsb2NrIHx8IGlkLmNvbHVtbiAhPSB0aGlzLl9sYXN0X3NvcnRfZG5kX25vZGUpKSB7XG5cdCAgICAgICAgICAgIC8vaWdub3JlIG5vcm1hbCBkbmQgLCBhbmQgZG5kIGZyb20gb3RoZXIgY29tcG9uZW50c1xuXHQgICAgICAgICAgICBpZiAoY29udGV4dC5jdXN0b20gPT0gXCJjb2x1bW5fZG5kXCIgJiYgJCQoaHRtbCkgPT0gdGhpcykge1xuXHQgICAgICAgICAgICAgIGlmICghdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZUNvbHVtbkRyb3BPcmRlclwiLCBbc3RhcnQsIGlkLmNvbHVtbiwgZV0pKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgdmFyIHN0YXJ0X2luZGV4ID0gdGhpcy5nZXRDb2x1bW5JbmRleChzdGFydCk7XG5cdCAgICAgICAgICAgICAgdmFyIGVuZF9pbmRleCA9IHRoaXMuZ2V0Q29sdW1uSW5kZXgoaWQuY29sdW1uKTsgLy9vbiB0b3VjaCBkZXZpY2VzIHdlIG5lZWQgdG8gcHJlc2VydmUgZHJhZy1zdGFydCBlbGVtZW50IHRpbGwgdGhlIGVuZCBvZiBkbmRcblxuXHQgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdUYXJnZXQgPSBlLnRhcmdldDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdUYXJnZXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgICAgICAgICAgICAgdGhpcy4kdmlldy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2RyYWdUYXJnZXQpO1xuXHQgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgIHRoaXMubW92ZUNvbHVtbihzdGFydCwgZW5kX2luZGV4ICsgKHN0YXJ0X2luZGV4IDwgZW5kX2luZGV4ID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgICB0aGlzLl9sYXN0X3NvcnRfZG5kX25vZGUgPSBpZC5jb2x1bW47XG5cdCAgICAgICAgICAgICAgdGhpcy5fY29sdW1uX2RuZF90ZW1wX2Jsb2NrID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoaWQgJiYgaWQuY29sdW1uID09IHN0YXJ0KSB7XG5cdCAgICAgICAgICAgIC8vZmxhZyBwcmV2ZW50IGZsaWNrZXJpbmcganVzdCBhZnRlciBjb2x1bW4gbW92ZVxuXHQgICAgICAgICAgICB0aGlzLl9jb2x1bW5fZG5kX3RlbXBfYmxvY2sgPSBmYWxzZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHQgICAgICAgICAgcG9zJCQxLnggPSBwb3MkJDEueCAtIHRoaXMuX3JlbGF0aXZlX2NvbHVtbl9kcmFnLng7XG5cdCAgICAgICAgICBwb3MkJDEueSA9IGJveC55O1xuXHQgICAgICAgICAgaWYgKHBvcyQkMS54IDwgYm94LngpIHBvcyQkMS54ID0gYm94Lng7ZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBtYXggPSBib3gueCArIHRoaXMuJHZpZXcub2Zmc2V0V2lkdGggLSB0aGlzLl9zY3JvbGxTaXplWSAtIHRoaXMuX2xpbWl0X2NvbHVtbl9kcmFnO1xuXHQgICAgICAgICAgICBpZiAocG9zJCQxLnggPiBtYXgpIHBvcyQkMS54ID0gbWF4O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgRHJhZ0NvbnRyb2wuX3NraXAgPSB0cnVlO1xuXHQgICAgICAgIH0sIHRoaXMpLFxuXHQgICAgICAgICRkcmFnRGVzdHJveTogYmluZChmdW5jdGlvbiAoYSwgbm9kZSkge1xuXHQgICAgICAgICAgcmVtb3ZlKG5vZGUpOyAvL2NsZWFuIGRuZCBzb3VyY2UgZWxlbWVudFxuXG5cdCAgICAgICAgICBpZiAodGhpcy5fZHJhZ1RhcmdldCkgcmVtb3ZlKHRoaXMuX2RyYWdUYXJnZXQpO1xuXHQgICAgICAgICAgdmFyIGlkID0gRHJhZ0NvbnRyb2wuZ2V0Q29udGV4dCgpLnN0YXJ0O1xuXHQgICAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyQ29sdW1uRHJvcE9yZGVyXCIsIFtpZC5jb2x1bW4sIHRoaXMuX2xhc3Rfc29ydF9kbmRfbm9kZSwgYV0pO1xuXHQgICAgICAgIH0sIHRoaXMpLFxuXHQgICAgICAgICRkcm9wOiBmdW5jdGlvbiAoKSB7fVxuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuXHQgICAgICBjb250cm9sID0ge1xuXHQgICAgICAgIF9pbm5lcl9kcmFnX29ubHk6IHRydWUsXG5cdCAgICAgICAgJGRyYWc6IGJpbmQoZnVuY3Rpb24gKHMsIGUpIHtcblx0ICAgICAgICAgIGlmICghdGhpcy5faXNEcmFnZ2FibGUoZSkgfHwgdGhpcy5fcnNfcHJvY2VzcykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgdmFyIGlkID0gdGhpcy5sb2NhdGUoZSk7XG5cdCAgICAgICAgICBpZiAoIWlkIHx8ICF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQ29sdW1uRHJhZ1wiLCBbaWQuY29sdW1uLCBlXSkpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgIERyYWdDb250cm9sLl9kcmFnX2NvbnRleHQgPSB7XG5cdCAgICAgICAgICAgIGZyb206IGNvbnRyb2wsXG5cdCAgICAgICAgICAgIHN0YXJ0OiBpZCxcblx0ICAgICAgICAgICAgY3VzdG9tOiBcImNvbHVtbl9kbmRcIlxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmdldENvbHVtbkNvbmZpZyhpZC5jb2x1bW4pLmhlYWRlcjtcblx0ICAgICAgICAgIHZhciB0ZXh0ID0gXCImbmJzcDtcIjtcblxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGhlYWRlcltpXSkge1xuXHQgICAgICAgICAgICAgIHRleHQgPSBoZWFkZXJbaV0udGV4dDtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF9kZF9kcmFnX2NvbHVtbic+XCIgKyB0ZXh0ICsgXCI8L2Rpdj5cIjtcblx0ICAgICAgICB9LCB0aGlzKSxcblx0ICAgICAgICAkZHJvcDogYmluZChmdW5jdGlvbiAocywgdCwgZSkge1xuXHQgICAgICAgICAgdmFyIHRhcmdldCA9IGU7IC8vb24gdG91Y2ggZGV2aWNlcyBldmVudCBkb2Vzbid0IHBvaW50IHRvIHRoZSBhY3R1YWwgZHJvcCB0YXJnZXRcblxuXHQgICAgICAgICAgaWYgKGUudG91Y2hlcyAmJiB0aGlzLl9kcmFnX2NvbHVtbl9sYXN0KSB0YXJnZXQgPSB0aGlzLl9kcmFnX2NvbHVtbl9sYXN0O1xuXHQgICAgICAgICAgdmFyIGlkID0gdGhpcy5sb2NhdGUodGFyZ2V0KTtcblx0ICAgICAgICAgIGlmICghaWQpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgIHZhciBzdGFydCA9IERyYWdDb250cm9sLmdldENvbnRleHQoKS5zdGFydC5jb2x1bW47XG5cblx0ICAgICAgICAgIGlmIChzdGFydCAhPSBpZC5jb2x1bW4pIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlQ29sdW1uRHJvcFwiLCBbc3RhcnQsIGlkLmNvbHVtbiwgZV0pKSByZXR1cm47XG5cdCAgICAgICAgICAgIHZhciBzdGFydF9pbmRleCA9IHRoaXMuZ2V0Q29sdW1uSW5kZXgoc3RhcnQpO1xuXHQgICAgICAgICAgICB2YXIgZW5kX2luZGV4ID0gdGhpcy5nZXRDb2x1bW5JbmRleChpZC5jb2x1bW4pO1xuXHQgICAgICAgICAgICB0aGlzLm1vdmVDb2x1bW4oc3RhcnQsIGVuZF9pbmRleCArIChzdGFydF9pbmRleCA8IGVuZF9pbmRleCA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25BZnRlckNvbHVtbkRyb3BcIiwgW3N0YXJ0LCBpZC5jb2x1bW4sIGVdKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LCB0aGlzKSxcblx0ICAgICAgICAkZHJhZ0luOiBiaW5kKGZ1bmN0aW9uIChzLCB0LCBlKSB7XG5cdCAgICAgICAgICB2YXIgY29udGV4dCA9IERyYWdDb250cm9sLmdldENvbnRleHQoKTsgLy9pZ25vcmUgbm9ybWFsIGRuZCAsIGFuZCBkbmQgZnJvbSBvdGhlciBjb21wb25lbnRzXG5cblx0ICAgICAgICAgIGlmIChjb250ZXh0LmN1c3RvbSAhPSBcImNvbHVtbl9kbmRcIiB8fCBjb250ZXh0LmZyb20gIT0gY29udHJvbCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuXHQgICAgICAgICAgd2hpbGUgKCh0YXJnZXQuY2xhc3NOYW1lIHx8IFwiXCIpLmluZGV4T2YoXCJ3ZWJpeF9oY2VsbFwiKSA9PSAtMSkge1xuXHQgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0ICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLl9kcmFnX2NvbHVtbl9sYXN0KSB7XG5cdCAgICAgICAgICAgIC8vbmV3IHRhcmdldFxuXHQgICAgICAgICAgICBpZiAodGhpcy5fZHJhZ19jb2x1bW5fbGFzdCkgcmVtb3ZlQ3NzKHRoaXMuX2RyYWdfY29sdW1uX2xhc3QsIFwid2ViaXhfZGRfb3Zlcl9jb2x1bW5cIik7XG5cdCAgICAgICAgICAgIGFkZENzcyh0YXJnZXQsIFwid2ViaXhfZGRfb3Zlcl9jb2x1bW5cIik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIHJldHVybiB0aGlzLl9kcmFnX2NvbHVtbl9sYXN0ID0gdGFyZ2V0O1xuXHQgICAgICAgIH0sIHRoaXMpLFxuXHQgICAgICAgICRkcmFnRGVzdHJveTogYmluZChmdW5jdGlvbiAoYSwgaCkge1xuXHQgICAgICAgICAgaWYgKHRoaXMuX2RyYWdfY29sdW1uX2xhc3QpIHJlbW92ZUNzcyh0aGlzLl9kcmFnX2NvbHVtbl9sYXN0LCBcIndlYml4X2RkX292ZXJfY29sdW1uXCIpO1xuXHQgICAgICAgICAgcmVtb3ZlKGgpO1xuXHQgICAgICAgIH0sIHRoaXMpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICBEcmFnQ29udHJvbC5hZGREcmFnKHRoaXMuX2hlYWRlciwgY29udHJvbCk7XG5cdCAgICAgIERyYWdDb250cm9sLmFkZERyb3AodGhpcy5faGVhZGVyLCBjb250cm9sLCB0cnVlKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJGIgPSB7XG5cdCAgY2xlYXJWYWxpZGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBmb3IgKHZhciBpIGluIHRoaXMuZGF0YS5fbWFya3MpIHtcblx0ICAgICAgdGhpcy5fY2xlYXJfaW52YWxpZF9jc3MoaSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuZGF0YS5jbGVhck1hcmsoXCJ3ZWJpeF9pbnZhbGlkXCIsIHRydWUpO1xuXHQgIH0sXG5cdCAgX21hcmtfaW52YWxpZDogZnVuY3Rpb24gKGlkLCBkZXRhaWxzKSB7XG5cdCAgICB0aGlzLl9jbGVhcl9pbnZhbGlkX2NzcyhpZCk7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBkZXRhaWxzKSB7XG5cdCAgICAgIHRoaXMuYWRkQ2VsbENzcyhpZCwga2V5LCBcIndlYml4X2ludmFsaWRfY2VsbFwiKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5hZGRDc3MoaWQsIFwid2ViaXhfaW52YWxpZFwiKTtcblx0ICB9LFxuXHQgIF9jbGVhcl9pbnZhbGlkOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMuX2NsZWFyX2ludmFsaWRfY3NzKGlkKTtcblxuXHQgICAgdGhpcy5yZW1vdmVDc3MoaWQsIFwid2ViaXhfaW52YWxpZFwiKTtcblx0ICB9LFxuXHQgIF9jbGVhcl9pbnZhbGlkX2NzczogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgbWFyayA9IHRoaXMuZGF0YS5nZXRNYXJrKGlkLCBcIiRjZWxsQ3NzXCIpO1xuXG5cdCAgICBpZiAobWFyaykge1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gbWFyaykge1xuXHQgICAgICAgIG1hcmtba2V5XSA9IG1hcmtba2V5XS5yZXBsYWNlKFwid2ViaXhfaW52YWxpZF9jZWxsXCIsIFwiXCIpLnJlcGxhY2UoXCIgIFwiLCBcIiBcIik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LFxuXHQgIGFkZFJvd0NzczogZnVuY3Rpb24gKGlkLCBjc3MsIHNpbGVudCkge1xuXHQgICAgdGhpcy5hZGRDc3MoaWQsIGNzcywgc2lsZW50KTtcblx0ICB9LFxuXHQgIHJlbW92ZVJvd0NzczogZnVuY3Rpb24gKGlkLCBjc3MsIHNpbGVudCkge1xuXHQgICAgdGhpcy5yZW1vdmVDc3MoaWQsIGNzcywgc2lsZW50KTtcblx0ICB9LFxuXHQgIGFkZENlbGxDc3M6IGZ1bmN0aW9uIChpZCwgbmFtZSwgY3NzLCBzaWxlbnQpIHtcblx0ICAgIHZhciBtYXJrID0gdGhpcy5kYXRhLmdldE1hcmsoaWQsIFwiJGNlbGxDc3NcIik7XG5cdCAgICB2YXIgbmV3bWFyayA9IG1hcmsgfHwge307XG5cdCAgICB2YXIgc3R5bGUgPSBuZXdtYXJrW25hbWVdIHx8IFwiXCI7XG5cdCAgICBuZXdtYXJrW25hbWVdID0gc3R5bGUucmVwbGFjZShjc3MsIFwiXCIpLnJlcGxhY2UoXCIgIFwiLCBcIiBcIikgKyBcIiBcIiArIGNzcztcblx0ICAgIGlmICghbWFyaykgdGhpcy5kYXRhLmFkZE1hcmsoaWQsIFwiJGNlbGxDc3NcIiwgZmFsc2UsIG5ld21hcmssIHRydWUpO1xuXHQgICAgaWYgKCFzaWxlbnQpIHRoaXMucmVmcmVzaChpZCk7XG5cdCAgfSxcblx0ICByZW1vdmVDZWxsQ3NzOiBmdW5jdGlvbiAoaWQsIG5hbWUsIGNzcywgc2lsZW50KSB7XG5cdCAgICB2YXIgbWFyayA9IHRoaXMuZGF0YS5nZXRNYXJrKGlkLCBcIiRjZWxsQ3NzXCIpO1xuXG5cdCAgICBpZiAobWFyaykge1xuXHQgICAgICB2YXIgc3R5bGUgPSBtYXJrW25hbWVdIHx8IFwiXCI7XG5cdCAgICAgIGlmIChzdHlsZSkgbWFya1tuYW1lXSA9IHN0eWxlLnJlcGxhY2UoY3NzLCBcIlwiKS5yZXBsYWNlKFwiICBcIiwgXCIgXCIpO1xuXHQgICAgICBpZiAoIXNpbGVudCkgdGhpcy5yZWZyZXNoKGlkKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJGMgPSB7XG5cdCAgX3ByZVByaW50OiBmdW5jdGlvbiAob3B0aW9ucywgaHRtbE9ubHkpIHtcblx0ICAgIGlmIChvcHRpb25zLnNjcm9sbCAmJiAhaHRtbE9ubHkpIHJldHVybiB0cnVlO1xuXHQgICAgb3B0aW9ucy5oZWFkZXIgPSBpc1VuZGVmaW5lZChvcHRpb25zLmhlYWRlcikgPyB0aGlzLmNvbmZpZy5oZWFkZXIgPyB0cnVlIDogZmFsc2UgOiBvcHRpb25zLmhlYWRlcjtcblx0ICAgIG9wdGlvbnMuZm9vdGVyID0gaXNVbmRlZmluZWQob3B0aW9ucy5mb290ZXIpID8gdGhpcy5jb25maWcuZm9vdGVyID8gdHJ1ZSA6IGZhbHNlIDogb3B0aW9ucy5mb290ZXI7XG5cdCAgICBvcHRpb25zLnhDb3JyZWN0aW9uID0gb3B0aW9ucy54Q29ycmVjdGlvbiB8fCAwOyAvL3NwcmVhZHNoZWV0XG5cdCAgfSxcblx0ICBfZmluZEluZGV4OiBmdW5jdGlvbiAoYXJyLCBmdW5jKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gLTE7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyByZXN1bHQgPCAwICYmIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKGZ1bmMoYXJyW2ldKSkgcmVzdWx0ID0gaTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9LFxuXHQgIF9nZXRUYWJsZUhlYWRlcjogZnVuY3Rpb24gKGJhc2UsIGNvbHVtbnMsIGdyb3VwKSB7XG5cdCAgICB2YXIgc3BhbnMgPSB7fSxcblx0ICAgICAgICBzdGFydCA9IDA7XG5cdCAgICBiYXNlLmZvckVhY2goYmluZChmdW5jdGlvbiAodGFibGVBcnJheSwgdGlkKSB7XG5cdCAgICAgIHZhciByb3cgPSB0YWJsZUFycmF5WzBdLFxuXHQgICAgICAgICAgaGVhZGVyQXJyYXkgPSBbXSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHJvdy5sZW5ndGg7XG5cdCAgICAgIHJvdy5mb3JFYWNoKGJpbmQoZnVuY3Rpb24gKGNlbGwsIGNpZCkge1xuXHQgICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2NpZCArIHN0YXJ0XTtcblxuXHQgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgY29sdW1uW2dyb3VwXS5sZW5ndGg7IGgrKykge1xuXHQgICAgICAgICAgdmFyIGhlYWRlciA9IGNvbHVtbltncm91cF1baF07XG5cdCAgICAgICAgICBpZiAoIWhlYWRlciAmJiAhKHNwYW5zW3RpZF0gJiYgc3BhbnNbdGlkXVtoXSkpIGNvbnRpbnVlO1xuXHQgICAgICAgICAgaGVhZGVyID0gY29weShoZWFkZXIgfHwge1xuXHQgICAgICAgICAgICB0ZXh0OiBcIlwiXG5cdCAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgaWYgKHNwYW5zW3RpZF0gJiYgc3BhbnNbdGlkXVtoXSAmJiBjaWQgPT09IDApIHtcblx0ICAgICAgICAgICAgaGVhZGVyLmNvbHNwYW4gPSBzcGFuc1t0aWRdW2hdO1xuXHQgICAgICAgICAgICBzcGFuc1t0aWRdW2hdID0gMDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGhlYWRlci5jb2xzcGFuKSB7XG5cdCAgICAgICAgICAgIHZhciBjb2xzcGFuID0gTWF0aC5taW4oaGVhZGVyLmNvbHNwYW4sIGxlbmd0aCAtIGNpZCk7XG5cdCAgICAgICAgICAgIHNwYW5zW3RpZCArIDFdID0gc3BhbnNbdGlkICsgMV0gfHwge307XG5cdCAgICAgICAgICAgIHNwYW5zW3RpZCArIDFdW2hdID0gaGVhZGVyLmNvbHNwYW4gLSBjb2xzcGFuO1xuXHQgICAgICAgICAgICBoZWFkZXIuY29sc3BhbiA9IGNvbHNwYW47XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChoZWFkZXIucm93c3BhbiAmJiBsZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgaGVhZGVyLmhlaWdodCA9IChoZWFkZXIuaGVpZ2h0IHx8IHRoaXMuY29uZmlnLmhlYWRlclJvd0hlaWdodCkgKiBoZWFkZXIucm93c3Bhbjtcblx0ICAgICAgICAgICAgaGVhZGVyLnJvd3NwYW4gPSBudWxsO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB2YXIgaGNlbGwgPSB7XG5cdCAgICAgICAgICAgIHR4dDogaGVhZGVyLnJvdGF0ZSA/IHRoaXMuZ2V0SGVhZGVyTm9kZShjb2x1bW4uaWQsIGgpLmlubmVySFRNTCA6IGhlYWRlci50ZXh0IHx8IChoZWFkZXIuY29udGVudElkID8gdGhpcy5nZXRIZWFkZXJDb250ZW50KGhlYWRlci5jb250ZW50SWQpLmdldFZhbHVlKCkgOiBcIlwiKSxcblx0ICAgICAgICAgICAgY2xhc3NOYW1lOiBcIndlYml4X2hjZWxsIFwiICsgXCJ3ZWJpeF9cIiArIGdyb3VwICsgXCJfY2VsbCBcIiArIChoZWFkZXIuY3NzIHx8IFwiXCIpLFxuXHQgICAgICAgICAgICBzdHlsZToge1xuXHQgICAgICAgICAgICAgIGhlaWdodDogKGhlYWRlci5oZWlnaHQgfHwgdGhpcy5jb25maWcuaGVhZGVyUm93SGVpZ2h0KSArIFwicHhcIixcblx0ICAgICAgICAgICAgICB3aWR0aDogaGVhZGVyLmNvbHNwYW4gPyBcImF1dG9cIiA6IGNvbHVtbi53aWR0aCArIFwicHhcIlxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBzcGFuOiBoZWFkZXIuY29sc3BhbiB8fCBoZWFkZXIucm93c3BhbiA/IHtcblx0ICAgICAgICAgICAgICBjb2xzcGFuOiBoZWFkZXIuY29sc3BhbiB8fCAxLFxuXHQgICAgICAgICAgICAgIHJvd3NwYW46IGhlYWRlci5yb3dzcGFuIHx8IDFcblx0ICAgICAgICAgICAgfSA6IG51bGxcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgICBoZWFkZXJBcnJheVtoXSA9IGhlYWRlckFycmF5W2hdIHx8IFtdO1xuXHQgICAgICAgICAgaGVhZGVyQXJyYXlbaF1bY2lkXSA9IGhjZWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSwgdGhpcykpO1xuXHQgICAgICBpZiAoZ3JvdXAgPT0gXCJoZWFkZXJcIikgYmFzZVt0aWRdID0gaGVhZGVyQXJyYXkuY29uY2F0KHRhYmxlQXJyYXkpO2Vsc2UgYmFzZVt0aWRdID0gdGFibGVBcnJheS5jb25jYXQoaGVhZGVyQXJyYXkpO1xuXHQgICAgICBzdGFydCArPSBsZW5ndGg7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICByZXR1cm4gYmFzZTtcblx0ICB9LFxuXHQgIF9nZXRUYWJsZUFycmF5OiBmdW5jdGlvbiAob3B0aW9ucywgYmFzZSwgc3RhcnQpIHtcblx0ICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb25maWcuY29sdW1ucztcblx0ICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGVkSWQodHJ1ZSk7XG5cblx0ICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuX2dldFBhZ2VXaWR0aChvcHRpb25zKTtcblxuXHQgICAgdmFyIHJpZ2h0UmVzdHJpY3Rpb24gPSAwO1xuXHQgICAgdmFyIGJvdHRvbVJlc3RyaWN0aW9uID0gMDtcblx0ICAgIHZhciB0YWJsZUFycmF5ID0gW107XG5cdCAgICB2YXIgbmV3VGFibGVTdGFydCA9IDA7XG5cdCAgICBzdGFydCA9IHN0YXJ0IHx8IDAgKyBvcHRpb25zLnhDb3JyZWN0aW9uO1xuXHQgICAgYmFzZSA9IGJhc2UgfHwgW107XG5cdCAgICB0aGlzLmVhY2hSb3coYmluZChmdW5jdGlvbiAocm93KSB7XG5cdCAgICAgIHZhciB3aWR0aCA9IDA7XG5cdCAgICAgIHZhciByb3dJdGVtID0gdGhpcy5nZXRJdGVtKHJvdyk7XG5cdCAgICAgIHZhciByb3dJbmRleCA9IHRoaXMuZ2V0SW5kZXhCeUlkKHJvdyk7XG5cdCAgICAgIHZhciBjb2xyb3cgPSBbXTtcblx0ICAgICAgdmFyIGRhdGFyb3cgPSBmYWxzZTtcblxuXHQgICAgICBmb3IgKHZhciBjID0gc3RhcnQ7IGMgPCBjb2x1bW5zLmxlbmd0aDsgYysrKSB7XG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNbY10uaWQ7XG5cdCAgICAgICAgdmFyIGNvbEluZGV4ID0gdGhpcy5nZXRDb2x1bW5JbmRleChjb2x1bW4pIC0gc3RhcnQ7XG5cblx0ICAgICAgICBpZiAoY29sdW1uc1tjXSkge1xuXHQgICAgICAgICAgd2lkdGggKz0gY29sdW1uc1tjXS53aWR0aDtcblxuXHQgICAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGggJiYgYyA+IHN0YXJ0KSB7XG5cdCAgICAgICAgICAgIC8vICdjPnN0YXJ0JyBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgbG9uZyBjb2x1bW4gd2lsbCBoYXZlIHRvIGZpdCB0aGUgcGFnZVxuXHQgICAgICAgICAgICBuZXdUYWJsZVN0YXJ0ID0gYztcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IFwic2VsZWN0aW9uXCIgfHwgb3B0aW9ucy5kYXRhID09IFwic2VsZWN0aW9uXCIgJiYgdGhpcy5fZmluZEluZGV4KHNlbCwgZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gb2JqLmNvbHVtbiA9PSBjb2x1bW4gJiYgb2JqLnJvdyA9PSByb3c7XG5cdCAgICAgICAgICB9KSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIHNwYW47XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmdldFNwYW4pIHNwYW4gPSB0aGlzLmdldFNwYW4ocm93LCBjb2x1bW4pOyAvL2NoZWNrIHNwYW4gZnJvbSBwcmV2aW91cyB0YWJsZVxuXG5cdCAgICAgICAgICAgIGlmIChzcGFuICYmIHRoaXMuZ2V0Q29sdW1uSW5kZXgoY29sdW1uKSA9PT0gc3RhcnQpIHtcblx0ICAgICAgICAgICAgICB2YXIgc3BhblN0YXJ0ID0gdGhpcy5nZXRDb2x1bW5JbmRleChzcGFuWzFdKTtcblxuXHQgICAgICAgICAgICAgIGlmIChzcGFuU3RhcnQgPCBzdGFydCkge1xuXHQgICAgICAgICAgICAgICAgc3BhblsyXSA9IHNwYW5bMl0gLSAoc3RhcnQgLSBzcGFuU3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgc3Bhbls0XSA9IHNwYW5bNF0gPyBzcGFuWzRdIDogcm93SXRlbVtzcGFuWzFdXSA/IHRoaXMuZ2V0VGV4dChyb3csIHNwYW5bMV0pIDogbnVsbDtcblx0ICAgICAgICAgICAgICAgIHNwYW5bMV0gPSBjb2x1bW47XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFzcGFuIHx8IHNwYW4gJiYgc3BhblswXSA9PSByb3cgJiYgc3BhblsxXSA9PSBjb2x1bW4pIHtcblx0ICAgICAgICAgICAgICB2YXIgY2VsbFZhbHVlID0gc3BhbiAmJiBzcGFuWzRdID8gc3Bhbls0XSA6IHRoaXMuX2NvbHVtbnNfcHVsbFtjb2x1bW5dID8gdGhpcy5nZXRUZXh0KHJvdywgY29sdW1uKSA6IFwiXCI7XG5cdCAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q3NzKHJvdywgY29sdW1uKSArIFwiIFwiICsgKGNvbHVtbnNbY10uY3NzIHx8IFwiXCIpICsgKHNwYW4gPyBcIiB3ZWJpeF9kdGFibGVfc3BhbiBcIiArIChzcGFuWzVdIHx8IFwiXCIpIDogXCJcIik7XG5cdCAgICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuXHQgICAgICAgICAgICAgICAgaGVpZ2h0OiBzcGFuICYmIHNwYW5bM10gPiAxID8gXCJhdXRvXCIgOiAocm93SXRlbS4kaGVpZ2h0IHx8IHRoaXMuY29uZmlnLnJvd0hlaWdodCkgKyBcInB4XCIsXG5cdCAgICAgICAgICAgICAgICB3aWR0aDogc3BhbiAmJiBzcGFuWzJdID4gMSA/IFwiYXV0b1wiIDogY29sdW1uc1tjXS53aWR0aCArIFwicHhcIlxuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgY29scm93LnB1c2goe1xuXHQgICAgICAgICAgICAgICAgdHh0OiBjZWxsVmFsdWUsXG5cdCAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0ICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcblx0ICAgICAgICAgICAgICAgIHNwYW46IHNwYW4gPyB7XG5cdCAgICAgICAgICAgICAgICAgIGNvbHNwYW46IHNwYW5bMl0sXG5cdCAgICAgICAgICAgICAgICAgIHNwYW5TdGFydDogdGhpcy5nZXRDb2x1bW5JbmRleChzcGFuWzFdKSxcblx0ICAgICAgICAgICAgICAgICAgcm93c3Bhbjogc3BhblszXVxuXHQgICAgICAgICAgICAgICAgfSA6IG51bGxcblx0ICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgIGlmIChjZWxsVmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJpZ2h0UmVzdHJpY3Rpb24gPSBNYXRoLm1heChjb2xJbmRleCArIDEsIHJpZ2h0UmVzdHJpY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgYm90dG9tUmVzdHJpY3Rpb24gPSBNYXRoLm1heChyb3dJbmRleCArIDEsIGJvdHRvbVJlc3RyaWN0aW9uKTtcblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICBkYXRhcm93ID0gZGF0YXJvdyB8fCAhIWNlbGxWYWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChzcGFuKSB7XG5cdCAgICAgICAgICAgICAgY29scm93LnB1c2goe1xuXHQgICAgICAgICAgICAgICAgJGluc3BhbjogdHJ1ZVxuXHQgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgIHJpZ2h0UmVzdHJpY3Rpb24gPSBNYXRoLm1heChjb2xJbmRleCArIDEsIHJpZ2h0UmVzdHJpY3Rpb24pO1xuXHQgICAgICAgICAgICAgIGJvdHRvbVJlc3RyaWN0aW9uID0gTWF0aC5tYXgocm93SW5kZXggKyAxLCBib3R0b21SZXN0cmljdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIW9wdGlvbnMuc2tpcHJvd3MgfHwgZGF0YXJvdykgdGFibGVBcnJheS5wdXNoKGNvbHJvdyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cblx0ICAgIGlmIChib3R0b21SZXN0cmljdGlvbiAmJiByaWdodFJlc3RyaWN0aW9uKSB7XG5cdCAgICAgIGlmIChvcHRpb25zLnRyaW0pIHtcblx0ICAgICAgICB0YWJsZUFycmF5Lmxlbmd0aCA9IGJvdHRvbVJlc3RyaWN0aW9uO1xuXHQgICAgICAgIHRhYmxlQXJyYXkgPSB0YWJsZUFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IGl0ZW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgaWYgKGl0ZW1baV0uc3BhbiAmJiBpdGVtW2ldLnNwYW4uY29sc3Bhbikge1xuXHQgICAgICAgICAgICAgIGl0ZW1baV0uc3Bhbi5jb2xzcGFuID0gTWF0aC5taW4oaXRlbVtpXS5zcGFuLmNvbHNwYW4sIGl0ZW0ubGVuZ3RoIC0gaSk7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaXRlbS5sZW5ndGggPSByaWdodFJlc3RyaWN0aW9uO1xuXHQgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBiYXNlLnB1c2godGFibGVBcnJheSk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChuZXdUYWJsZVN0YXJ0KSB0aGlzLl9nZXRUYWJsZUFycmF5KG9wdGlvbnMsIGJhc2UsIG5ld1RhYmxlU3RhcnQpO2Vsc2Uge1xuXHQgICAgICAvL2tlZXAgdGhpcyBvcmRlciBhcyBsb2dpYyByZWxpZXMgb24gdGhlIGZpcnN0IGRhdGEgcm93XG5cdCAgICAgIGlmIChvcHRpb25zLmZvb3RlcikgYmFzZSA9IHRoaXMuX2dldFRhYmxlSGVhZGVyKGJhc2UsIGNvbHVtbnMsIFwiZm9vdGVyXCIpO1xuXHQgICAgICBpZiAob3B0aW9ucy5oZWFkZXIpIGJhc2UgPSB0aGlzLl9nZXRUYWJsZUhlYWRlcihiYXNlLCBjb2x1bW5zLCBcImhlYWRlclwiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBiYXNlO1xuXHQgIH0sXG5cdCAgX2dldFRhYmxlSFRNTDogZnVuY3Rpb24gKHRhYmxlRGF0YSwgb3B0aW9ucykge1xuXHQgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZShcImRpdlwiKTtcblx0ICAgIHRhYmxlRGF0YS5mb3JFYWNoKGJpbmQoZnVuY3Rpb24gKHRhYmxlLCBpKSB7XG5cdCAgICAgIHZhciB0YWJsZUhUTUwgPSBjcmVhdGUoXCJ0YWJsZVwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3RhYmxlX3ByaW50IFwiICsgdGhpcy4kdmlldy5jbGFzc05hbWUgKyAob3B0aW9ucy5ib3JkZXJsZXNzID8gXCIgYm9yZGVybGVzc1wiIDogXCJcIiksXG5cdCAgICAgICAgXCJzdHlsZVwiOiBcImJvcmRlci1jb2xsYXBzZTpjb2xsYXBzZVwiLFxuXHQgICAgICAgIFwiaWRcIjogdGhpcy4kdmlldy5nZXRBdHRyaWJ1dGUoXCJpZFwiKVxuXHQgICAgICB9KTtcblx0ICAgICAgdGFibGUuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG5cdCAgICAgICAgdmFyIHRyID0gY3JlYXRlKFwidHJcIik7XG5cdCAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcblx0ICAgICAgICAgIGlmICghY2VsbC4kaW5zcGFuKSB7XG5cdCAgICAgICAgICAgIHZhciB0ZCA9IGNyZWF0ZShcInRkXCIpO1xuXHQgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBjZWxsLnR4dDtcblx0ICAgICAgICAgICAgdGQuY2xhc3NOYW1lID0gY2VsbC5jbGFzc05hbWU7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNlbGwuc3R5bGUpIHtcblx0ICAgICAgICAgICAgICB0ZC5zdHlsZVtrZXldID0gY2VsbC5zdHlsZVtrZXldO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGNlbGwuc3Bhbikge1xuXHQgICAgICAgICAgICAgIHRkLmNvbFNwYW4gPSBjZWxsLnNwYW4uY29sc3Bhbjtcblx0ICAgICAgICAgICAgICB0ZC5yb3dTcGFuID0gY2VsbC5zcGFuLnJvd3NwYW47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGFibGVIVE1MLmFwcGVuZENoaWxkKHRyKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0YWJsZUhUTUwpO1xuXG5cdCAgICAgIGlmIChpICsgMSA8IHRhYmxlRGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYnIgPSBjcmVhdGUoXCJESVZcIiwge1xuXHQgICAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X3ByaW50X3BhZ2VicmVha1wiXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJyKTtcblx0ICAgICAgfVxuXHQgICAgfSwgdGhpcykpO1xuXHQgICAgcmV0dXJuIGNvbnRhaW5lcjtcblx0ICB9XG5cdH07XG5cblx0dmFyIE1peGluJGQgPSB7XG5cdCAgJGV4cG9ydFZpZXc6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICBpZiAodGhpcy5pc0JyYW5jaE9wZW4pIC8vdHJlZXRhYmxlXG5cdCAgICAgIGV4cG9ydHMuZXh0ZW5kKG9wdGlvbnMsIHtcblx0ICAgICAgICBmaWx0ZXJIVE1MOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgaWYgKG9wdGlvbnMuZXhwb3J0X21vZGUgIT09IFwiZXhjZWxcIiB8fCBvcHRpb25zLmRhdGFPbmx5IHx8ICFvcHRpb25zLnN0eWxlcykgcmV0dXJuIHRoaXM7ZWxzZSB7XG5cdCAgICAgIC8vZXhjZWwgZXhwb3J0IHdpdGggc3R5bGVzXG5cdCAgICAgIG9wdGlvbnMuZGF0YU9ubHkgPSB0cnVlO1xuXHQgICAgICBvcHRpb25zLmhlaWdodHMgPSBpc1VuZGVmaW5lZChvcHRpb25zLmhlaWdodHMpID8gXCJhbGxcIiA6IG9wdGlvbnMuaGVpZ2h0cztcblx0ICAgICAgdmFyIGRhdGEgPSB0b0V4Y2VsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICBkYXRhWzBdLnN0eWxlcyA9IHRoaXMuX2dldEV4cG9ydFN0eWxlcyhvcHRpb25zKTtcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YU9ubHk7XG5cdCAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldEV4cG9ydFN0eWxlczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb25maWcuY29sdW1ucyxcblx0ICAgICAgICBzdHlsZXMgPSBbXTtcblx0ICAgIHRoaXMuX3N0eWxlX2hhc2ggPSB0aGlzLl9zdHlsZV9oYXNoIHx8IHt9O1xuXHQgICAgaWYgKG9wdGlvbnMuZG9jSGVhZGVyKSBzdHlsZXMgPSBbe1xuXHQgICAgICAwOiB0aGlzLl9nZXRFeHBvcnREb2NTdHlsZShvcHRpb25zLmRvY0hlYWRlci5jc3MpXG5cdCAgICB9LCB7XG5cdCAgICAgIDA6IHt9XG5cdCAgICB9XTtcblx0ICAgIGlmIChvcHRpb25zLmhlYWRlciAhPT0gZmFsc2UpIHN0eWxlcyA9IHRoaXMuX2dldEV4cG9ydEhTdHlsZXMob3B0aW9ucywgXCJoZWFkZXJcIiwgc3R5bGVzKTtcblx0ICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgdmFyIHJvdyA9IHt9O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjZWxsQ3NzID0gdGhpcy5nZXRDc3Mob2JqLmlkLCBjb2x1bW5zW2ldLmlkKTtcblx0ICAgICAgICB2YXIgY29sdW1uQ3NzID0gY29sdW1uc1tpXS5ub2RlLmNsYXNzTmFtZTtcblx0ICAgICAgICB2YXIgc3BhbkNzcyA9IFwiXCI7XG5cdCAgICAgICAgdmFyIGV2ZW5Dc3MgPSB0aGlzLmdldEluZGV4QnlJZChvYmouaWQpICUgMiA/IFwiZXZlblwiIDogXCJvZGRcIjsgLy9mb3Igc2tpbnMgbGlrZSBtZXRybywgd2ViLCBhaXJcblxuXHQgICAgICAgIHZhciBzcGFuID0gbnVsbDtcblx0ICAgICAgICB2YXIgbm9kZSA9IG51bGw7XG5cblx0ICAgICAgICBpZiAodGhpcy5fc3BhbnNfcHVsbCAmJiAoc3BhbiA9IHRoaXMuZ2V0U3BhbihvYmouaWQsIGNvbHVtbnNbaV0uaWQpKSkge1xuXHQgICAgICAgICAgbm9kZSA9IHRoaXMuZ2V0U3Bhbk5vZGUoe1xuXHQgICAgICAgICAgICByb3c6IHNwYW5bMF0sXG5cdCAgICAgICAgICAgIGNvbHVtbjogc3BhblsxXVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICBzcGFuQ3NzID0gXCJ3ZWJpeF9kdGFibGVfc3BhbiBcIiArIChzcGFuWzVdIHx8IFwiXCIpO1xuXHQgICAgICAgIH0gZWxzZSBub2RlID0gdGhpcy5nZXRJdGVtTm9kZSh7XG5cdCAgICAgICAgICByb3c6IG9iai5pZCxcblx0ICAgICAgICAgIGNvbHVtbjogY29sdW1uc1tpXS5pZFxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKCFub2RlKSB7XG5cdCAgICAgICAgICBub2RlID0gY3JlYXRlKFwiZGl2XCIsIHtcblx0ICAgICAgICAgICAgXCJjbGFzc1wiOiBjZWxsQ3NzLFxuXHQgICAgICAgICAgICBzdHlsZTogXCJ2aXNpYmlsaXR5OmhpZGRlblwiXG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIHZhciBjbm9kZSA9IGNvbHVtbnNbaV0ubm9kZTtcblxuXHQgICAgICAgICAgaWYgKCFjb2x1bW5zW2ldLmF0dGFjaGVkKSB7XG5cdCAgICAgICAgICAgIGNub2RlID0gY3JlYXRlKFwiZGl2XCIsIHtcblx0ICAgICAgICAgICAgICBcImNsYXNzXCI6IGNvbHVtbkNzcyxcblx0ICAgICAgICAgICAgICBzdHlsZTogXCJ2aXNpYmlsaXR5OmhpZGRlblwiXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQoY25vZGUpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBjbm9kZS5hcHBlbmRDaGlsZChub2RlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByb3dbaV0gPSB0aGlzLl9nZXRFeHBvcnRDZWxsU3R5bGUobm9kZSwgW2NlbGxDc3MsIGNvbHVtbkNzcywgc3BhbkNzcywgZXZlbkNzc10uam9pbihcIjpcIikpO1xuXHQgICAgICB9XG5cblx0ICAgICAgc3R5bGVzW3N0eWxlcy5sZW5ndGhdID0gcm93O1xuXHQgICAgfSwgdGhpcyk7XG5cdCAgICBpZiAob3B0aW9ucy5mb290ZXIgIT09IGZhbHNlICYmIHRoaXMuY29uZmlnLmZvb3Rlcikgc3R5bGVzID0gdGhpcy5fZ2V0RXhwb3J0SFN0eWxlcyhvcHRpb25zLCBcImZvb3RlclwiLCBzdHlsZXMpO1xuXHQgICAgaWYgKG9wdGlvbnMuZG9jRm9vdGVyKSBzdHlsZXMgPSBzdHlsZXMuY29uY2F0KFt7XG5cdCAgICAgIDA6IHt9XG5cdCAgICB9LCB7XG5cdCAgICAgIDA6IHRoaXMuX2dldEV4cG9ydERvY1N0eWxlKG9wdGlvbnMuZG9jRm9vdGVyLmNzcylcblx0ICAgIH1dKTtcblx0ICAgIHJldHVybiBzdHlsZXM7XG5cdCAgfSxcblx0ICBfZ2V0RXhwb3J0SFN0eWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGdyb3VwLCBzdHlsZXMpIHtcblx0ICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb25maWcuY29sdW1ucyxcblx0ICAgICAgICBocyA9IFtdOyAvL3NwYW5zXG5cblx0ICAgIGZvciAodmFyIGggPSAwOyBoIDwgY29sdW1uc1swXVtncm91cF0ubGVuZ3RoOyBoKyspIHtcblx0ICAgICAgdmFyIGhyb3cgPSB7fTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgaGVhZGVyID0gY29sdW1uc1tpXVtncm91cF1baF07IC8vVG9EbzptYWtlIHN1cmUgaXQgaXMgcmVuZGVyZWQgYW5kIGF0dGFjaGVkXG5cblx0ICAgICAgICBpZiAoaGVhZGVyKSB7XG5cdCAgICAgICAgICAvL2NhbiBiZSBudWxsXG5cdCAgICAgICAgICB2YXIgY2lkID0gaGVhZGVyLmNvbHNwYW4gPyBjb2x1bW5zW2kgKyBoZWFkZXIuY29sc3BhbiAtIDFdLmlkIDogY29sdW1uc1tpXS5pZDtcblx0ICAgICAgICAgIHZhciBub2RlID0gZ3JvdXAgPT0gXCJoZWFkZXJcIiA/IHRoaXMuZ2V0SGVhZGVyTm9kZShjaWQsIGgpIDogdGhpcy5nZXRGb290ZXJOb2RlKGNpZCwgaCk7XG5cblx0ICAgICAgICAgIGlmIChub2RlKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gW25vZGUucGFyZW50Tm9kZS5jbGFzc05hbWUsIGhlYWRlci5jc3MgfHwgXCJcIiwgXCJ3ZWJpeF9oY2VsbFwiLCBncm91cF07XG5cdCAgICAgICAgICAgIGhyb3dbaV0gPSB0aGlzLl9nZXRFeHBvcnRDZWxsU3R5bGUobm9kZSwgbmFtZS5qb2luKFwiOlwiKSk7XG5cdCAgICAgICAgICAgIGlmIChoZWFkZXIuY29sc3BhbiB8fCBoZWFkZXIucm93c3BhbikgaHMucHVzaChbaCwgaSwge1xuXHQgICAgICAgICAgICAgIGNvbHNwYW46IGhlYWRlci5jb2xzcGFuIC0gMSB8fCAwLFxuXHQgICAgICAgICAgICAgIHJvd3NwYW46IGhlYWRlci5yb3dzcGFuIC0gMSB8fCAwXG5cdCAgICAgICAgICAgIH0sIGhyb3dbaV1dKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBocy5sZW5ndGg7IHMrKykge1xuXHQgICAgICAgICAgICB2YXIgc3QgPSBoc1tzXVsyXSxcblx0ICAgICAgICAgICAgICAgIGhzYyA9IGhzW3NdWzFdLFxuXHQgICAgICAgICAgICAgICAgaHNyID0gaHNbc11bMF07XG5cdCAgICAgICAgICAgIGlmIChoc2MgKyBzdC5jb2xzcGFuID49IGkgJiYgaHNyICsgc3Qucm93c3BhbiA+PSBoKSBocm93W2ldID0gaHNbc11bM107XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgc3R5bGVzW3N0eWxlcy5sZW5ndGhdID0gaHJvdztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHN0eWxlcztcblx0ICB9LFxuXHQgIF9nZXRFeHBvcnRDZWxsU3R5bGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG5cdCAgICBpZiAodGhpcy5fc3R5bGVfaGFzaFtuYW1lXSkgcmV0dXJuIHRoaXMuX3N0eWxlX2hhc2hbbmFtZV07ZWxzZSB7XG5cdCAgICAgIHZhciBiYXNlID0gdGhpcy5fZ2V0UnVsZXMobm9kZSk7XG5cblx0ICAgICAgdmFyIHJ1bGVzID0ge1xuXHQgICAgICAgIGZvbnQ6IHt9LFxuXHQgICAgICAgIGFsaWdubWVudDoge30sXG5cdCAgICAgICAgYm9yZGVyOiB7fVxuXHQgICAgICB9OyAvL2ZvbnRcblxuXHQgICAgICBydWxlcy5mb250Lm5hbWUgPSBiYXNlW1wiZm9udC1mYW1pbHlcIl0ucmVwbGFjZSgvLC4qJC8sIFwiXCIpOyAvLyBjdXQgb2ZmIGZhbGxiYWNrIGZvbnQ7XG5cblx0ICAgICAgcnVsZXMuZm9udC5zeiA9IGJhc2VbXCJmb250LXNpemVcIl0ucmVwbGFjZShcInB4XCIsIFwiXCIpICogMC43NTsgLy9weCB0byBwdCBjb252ZXJzaW9uXG5cblx0ICAgICAgcnVsZXMuZm9udC5jb2xvciA9IHtcblx0ICAgICAgICByZ2I6IGNvbG9yLnJnYlRvSGV4KGJhc2VbXCJjb2xvclwiXSlcblx0ICAgICAgfTtcblx0ICAgICAgaWYgKGJhc2VbXCJmb250LXdlaWdodFwiXSAhPT0gXCJub3JtYWxcIikgcnVsZXMuZm9udC5ib2xkID0gdHJ1ZTtcblx0ICAgICAgaWYgKGJhc2VbXCJ0ZXh0LWRlY29yYXRpb24tbGluZVwiXSA9PT0gXCJ1bmRlcmxpbmVcIikgcnVsZXMuZm9udC51bmRlcmxpbmUgPSB0cnVlO1xuXHQgICAgICBpZiAoYmFzZVtcImZvbnQtc3R5bGVcIl0gPT09IFwiaXRhbGljXCIpIHJ1bGVzLmZvbnQuaXRhbGljID0gdHJ1ZTtcblx0ICAgICAgaWYgKGJhc2VbXCJ0ZXh0LWRlY29yYXRpb24tbGluZVwiXSA9PT0gXCJsaW5lLXRocm91Z2hcIikgcnVsZXMuZm9udC5zdHJpa2UgPSB0cnVlOyAvL2FsaWdubWVudFxuXG5cdCAgICAgIHJ1bGVzLmFsaWdubWVudC5ob3Jpem9udGFsID0gYmFzZVtcInRleHQtYWxpZ25cIl07XG5cdCAgICAgIHJ1bGVzLmFsaWdubWVudC52ZXJ0aWNhbCA9IGJhc2VbXCJoZWlnaHRcIl0gPT0gYmFzZVtcImxpbmUtaGVpZ2h0XCJdID8gXCJjZW50ZXJcIiA6IFwidG9wXCI7XG5cdCAgICAgIGlmIChiYXNlW1wid2hpdGUtc3BhY2VcIl0gPT0gXCJub3JtYWxcIikgcnVsZXMuYWxpZ25tZW50LndyYXBUZXh0ID0gdHJ1ZTsgLy9yb3RhdGVkIGhlYWRlclxuXG5cdCAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQgJiYgbm9kZS5maXJzdENoaWxkLmNsYXNzTmFtZSAmJiBub2RlLmZpcnN0Q2hpbGQuY2xhc3NOYW1lLmluZGV4T2YoXCJ3ZWJpeF9yb3RhdGVcIikgIT09IC0xKSBydWxlcy5hbGlnbm1lbnQudGV4dFJvdGF0aW9uID0gOTA7IC8vYmFja2dyb3VuZFxuXG5cdCAgICAgIHZhciBiZyA9IGNvbG9yLnJnYlRvSGV4KGJhc2VbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdKSB8fCBcIkZGRkZGRlwiO1xuXHQgICAgICBydWxlcy5maWxsID0ge1xuXHQgICAgICAgIGZnQ29sb3I6IHtcblx0ICAgICAgICAgIHJnYjogYmdcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIGlmIChiYXNlW1wiYmFja2dyb3VuZC1pbWFnZVwiXS5pbmRleE9mKFwiZ3JhZGllbnRcIikgIT09IC0xKSAvL2FpciBza2lucyB1c2UgZ3JhZGllbnQgZm9yIGhlYWRlclxuXHQgICAgICAgIHJ1bGVzLmZpbGwgPSB7XG5cdCAgICAgICAgICBmZ0NvbG9yOiB7XG5cdCAgICAgICAgICAgIHJnYjogY29sb3IucmdiVG9IZXgoYmFzZVtcImJhY2tncm91bmQtaW1hZ2VcIl0uc3Vic3RyaW5nKGJhc2VbXCJiYWNrZ3JvdW5kLWltYWdlXCJdLmxhc3RJbmRleE9mKFwiKFwiKSkpXG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTsgLy9ib3JkZXJzXG5cblx0ICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT0gXCJURFwiKSAvL2JvcmRlcnMgZm9yIGhlYWRlciBhcmUgc2V0IGZvciBwYXJlbnQgdGQsIHNvIHdlIGNoYW5nZSBiYXNlIHJ1bGVzIGhlcmVcblx0ICAgICAgICBiYXNlID0gdGhpcy5fZ2V0UnVsZXMobm9kZS5wYXJlbnROb2RlKTtcblx0ICAgICAgaWYgKGJhc2VbXCJib3JkZXItcmlnaHQtd2lkdGhcIl0gIT09IFwiMHB4XCIpIHJ1bGVzLmJvcmRlci5yaWdodCA9IHtcblx0ICAgICAgICBzdHlsZTogXCJ0aGluXCIsXG5cdCAgICAgICAgY29sb3I6IHtcblx0ICAgICAgICAgIHJnYjogY29sb3IucmdiVG9IZXgoYmFzZVtcImJvcmRlci1yaWdodC1jb2xvclwiXSkgfHwgYmdcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIGlmIChiYXNlW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiXSAhPT0gXCIwcHhcIikgcnVsZXMuYm9yZGVyLmJvdHRvbSA9IHtcblx0ICAgICAgICBzdHlsZTogXCJ0aGluXCIsXG5cdCAgICAgICAgY29sb3I6IHtcblx0ICAgICAgICAgIHJnYjogY29sb3IucmdiVG9IZXgoYmFzZVtcImJvcmRlci1ib3R0b20tY29sb3JcIl0pIHx8IGJnXG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgICBpZiAoYmFzZVtcImJvcmRlci1sZWZ0LXdpZHRoXCJdICE9PSBcIjBweFwiKSBydWxlcy5ib3JkZXIubGVmdCA9IHtcblx0ICAgICAgICBzdHlsZTogXCJ0aGluXCIsXG5cdCAgICAgICAgY29sb3I6IHtcblx0ICAgICAgICAgIHJnYjogY29sb3IucmdiVG9IZXgoYmFzZVtcImJvcmRlci1sZWZ0LWNvbG9yXCJdKSB8fCBiZ1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgICAgaWYgKGJhc2VbXCJib3JkZXItdG9wLXdpZHRoXCJdICE9PSBcIjBweFwiKSBydWxlcy5ib3JkZXIudG9wID0ge1xuXHQgICAgICAgIHN0eWxlOiBcInRoaW5cIixcblx0ICAgICAgICBjb2xvcjoge1xuXHQgICAgICAgICAgcmdiOiBjb2xvci5yZ2JUb0hleChiYXNlW1wiYm9yZGVyLXRvcC1jb2xvclwiXSkgfHwgYmdcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIHRoaXMuX3N0eWxlX2hhc2hbbmFtZV0gPSBydWxlcztcblx0ICAgICAgcmV0dXJuIHJ1bGVzO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldEV4cG9ydERvY1N0eWxlOiBmdW5jdGlvbiAoY3NzKSB7XG5cdCAgICBjc3MgPSBleHBvcnRzLmV4dGVuZChjc3MgfHwge30sIHtcblx0ICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0ICAgICAgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiLFxuXHQgICAgICBcInRleHQtYWxpZ25cIjogXCJsZWZ0XCJcblx0ICAgIH0pO1xuXHQgICAgdmFyIGNzc1N0ciA9IFwiXCI7XG5cblx0ICAgIGZvciAodmFyIGkgaW4gY3NzKSB7XG5cdCAgICAgIGNzc1N0ciArPSBpICsgXCI6XCIgKyBjc3NbaV0gKyBcIjtcIjtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5vZGUgPSBjcmVhdGUoXCJkaXZcIiwge1xuXHQgICAgICBzdHlsZTogY3NzU3RyXG5cdCAgICB9KTtcblxuXHQgICAgdGhpcy5fYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuXHQgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0RXhwb3J0Q2VsbFN0eWxlKG5vZGUsIGNzc1N0cik7XG5cblx0ICAgIHJlbW92ZShub2RlKTtcblx0ICAgIHJldHVybiBzdHlsZTtcblx0ICB9LFxuXHQgIF9nZXRSdWxlczogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgIHZhciBzdHlsZSA9IHt9O1xuXHQgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO2Vsc2Ugc3R5bGUgPSBub2RlLmN1cnJlbnRTdHlsZTtcblx0ICAgIHJldHVybiBzdHlsZTtcblx0ICB9XG5cdH07XG5cblx0dmFyIHRlbXAkNSA9IHt9O1xuXG5cdHZhciB0ZW1wJDYgPSB7fTtcblxuXHR2YXIgdGVtcCQ3ID0ge307XG5cblx0dmFyIGFwaSQxZCA9IHtcblx0ICBuYW1lOiBcImRhdGF0YWJsZVwiLFxuXHQgIGRlZmF1bHRzOiB7XG5cdCAgICBsZWZ0U3BsaXQ6IDAsXG5cdCAgICByaWdodFNwbGl0OiAwLFxuXHQgICAgdG9wU3BsaXQ6IDAsXG5cdCAgICBjb2x1bW5XaWR0aDogMTAwLFxuXHQgICAgbWluQ29sdW1uV2lkdGg6IDIwLFxuXHQgICAgbWluQ29sdW1uSGVpZ2h0OiAyNixcblx0ICAgIHByZXJlbmRlcjogZmFsc2UsXG5cdCAgICBhdXRvaGVpZ2h0OiBmYWxzZSxcblx0ICAgIGF1dG93aWR0aDogZmFsc2UsXG5cdCAgICBoZWFkZXI6IHRydWUsXG5cdCAgICBmaXhlZFJvd0hlaWdodDogdHJ1ZSxcblx0ICAgIHNjcm9sbEFsaWduWTogdHJ1ZSxcblx0ICAgIHNjcm9sbFg6IHRydWUsXG5cdCAgICBzY3JvbGxZOiB0cnVlLFxuXHQgICAgZGF0YWZldGNoOiA1MCxcblx0ICAgIG5hdmlnYXRpb246IHRydWVcblx0ICB9LFxuXHQgICRza2luOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRlZmF1bHRzLnJvd0hlaWdodCA9ICRhY3RpdmUucm93SGVpZ2h0O1xuXHQgICAgdGhpcy5kZWZhdWx0cy5oZWFkZXJSb3dIZWlnaHQgPSAkYWN0aXZlLmJhckhlaWdodCAtICRhY3RpdmUuYm9yZGVyV2lkdGggKiAyO1xuXHQgIH0sXG5cdCAgb25fY2xpY2s6IHtcblx0ICAgIHdlYml4X3JpY2hmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfSxcblx0ICAgIHdlYml4X3RhYmxlX2NoZWNrYm94OiBmdW5jdGlvbiAoZSwgaWQpIHtcblx0ICAgICAgaWQgPSB0aGlzLmxvY2F0ZShlKTtcblx0ICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQucm93KTtcblx0ICAgICAgdmFyIGNvbCA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGlkLmNvbHVtbik7XG5cdCAgICAgIHZhciB0cmcgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7IC8vcmVhZCBhY3R1YWwgdmFsdWUgZnJvbSBIVE1MIHRhZyB3aGVuIHBvc3NpYmxlXG5cdCAgICAgIC8vYXMgaXQgY2FuIGJlIGFmZmVjdGVkIGJ5IGRibC1jbGlja3NcblxuXHQgICAgICB2YXIgY2hlY2sgPSB0cmcudHlwZSA9PSBcImNoZWNrYm94XCIgPyB0cmcuY2hlY2tlZCA6IGl0ZW1baWQuY29sdW1uXSAhPSBjb2wuY2hlY2tWYWx1ZTtcblx0ICAgICAgdmFyIHZhbHVlID0gY2hlY2sgPyBjb2wuY2hlY2tWYWx1ZSA6IGNvbC51bmNoZWNrVmFsdWU7XG5cdCAgICAgIHZhciB1cGRhdGUgPSB7fTtcblx0ICAgICAgdXBkYXRlW2lkLmNvbHVtbl0gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy51cGRhdGVJdGVtKGlkLnJvdywgdXBkYXRlLCB0aGlzLl9zZXR0aW5ncy5jaGVja2JveFJlZnJlc2ggPyBcInVwZGF0ZVwiIDogXCJzYXZlXCIpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQ2hlY2tcIiwgW2lkLnJvdywgaWQuY29sdW1uLCB2YWx1ZV0pO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9LFxuXHQgICAgd2ViaXhfdGFibGVfcmFkaW86IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgIHZhciBpZCA9IHRoaXMubG9jYXRlKGUpO1xuXHQgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZC5yb3cpO1xuXHQgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW5Db25maWcoaWQuY29sdW1uKTtcblx0ICAgICAgdGhpcy5lYWNoUm93KGZ1bmN0aW9uIChyb3dpZCkge1xuXHQgICAgICAgIHZhciBpdGVtID0gdGhpcy5kYXRhLnB1bGxbcm93aWRdO1xuXHQgICAgICAgIGlmIChpdGVtICYmIGl0ZW1baWQuY29sdW1uXSA9PSBjb2wuY2hlY2tWYWx1ZSkgaXRlbVtpZC5jb2x1bW5dID0gY29sLnVuY2hlY2tWYWx1ZTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGl0ZW1baWQuY29sdW1uXSA9IGNvbC5jaGVja1ZhbHVlO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQ2hlY2tcIiwgW2lkLnJvdywgaWQuY29sdW1uLCB0cnVlXSk7XG5cdCAgICAgIHRoaXMucmVmcmVzaCgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBvbl9kYmxjbGljazoge1xuXHQgICAgd2ViaXhfdGFibGVfY2hlY2tib3g6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub25fY2xpY2sud2ViaXhfdGFibGVfY2hlY2tib3guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIG9uX2NvbnRleHQ6IHt9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLm9uX2NsaWNrID0gZXhwb3J0cy5leHRlbmQoe30sIHRoaXMub25fY2xpY2spO1xuXHQgICAgdmFyIGh0bWwgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3NzX2hlYWRlcic+PGRpdiBjbGFzcz0nd2ViaXhfaHNfbGVmdCc+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfaHNfY2VudGVyJz48L2Rpdj48ZGl2IGNsYXNzPSd3ZWJpeF9oc19yaWdodCc+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfc3NfYm9keSc+PGRpdiBjbGFzcz0nd2ViaXhfc3NfbGVmdCc+PGRpdiBjbGFzcz0nd2ViaXhfc3NfY2VudGVyX3Njcm9sbCc+PC9kaXY+PC9kaXY+XCI7XG5cdCAgICBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfc3NfY2VudGVyJz48ZGl2IGNsYXNzPSd3ZWJpeF9zc19jZW50ZXJfc2Nyb2xsJyByb2xlPSdyb3dncm91cCc+PC9kaXY+PC9kaXY+XCI7XG5cdCAgICBodG1sICs9IFwiPGRpdiBjbGFzcz0nd2ViaXhfc3NfcmlnaHQnPjxkaXYgY2xhc3M9J3dlYml4X3NzX2NlbnRlcl9zY3JvbGwnPjwvZGl2PjwvZGl2PjwvZGl2PlwiO1xuXHQgICAgaHRtbCArPSBcIjxkaXYgY2xhc3M9J3dlYml4X3NzX2hzY3JvbGwnIHJvbGU9J3Njcm9sbGJhcicgYXJpYS1vcmllbnRhdGlvbj0naG9yaXpvbnRhbCc+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfc3NfZm9vdGVyJz48ZGl2IGNsYXNzPSd3ZWJpeF9oc19sZWZ0Jz48L2Rpdj48ZGl2IGNsYXNzPSd3ZWJpeF9oc19jZW50ZXInPjwvZGl2PjxkaXYgY2xhc3M9J3dlYml4X2hzX3JpZ2h0Jz48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSd3ZWJpeF9zc192c2Nyb2xsX2hlYWRlcic+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfc3NfdnNjcm9sbCcgcm9sZT0nc2Nyb2xsYmFyJyBhcmlhLW9yaWVudGF0aW9uPSd2ZXJ0aWNhbCc+PC9kaXY+PGRpdiBjbGFzcz0nd2ViaXhfc3NfdnNjcm9sbF9mb290ZXInPjwvZGl2PlwiO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5pbm5lckhUTUwgPSBodG1sO1xuXHQgICAgdGhpcy5fdG9wX2lkID0gdGhpcy5fY29udGVudG9iai5pZCA9IHRoaXMubmFtZSArIHVpZCgpO1xuXHQgICAgdGhpcy5fY29udGVudG9iai5jbGFzc05hbWUgKz0gXCIgd2ViaXhfZHRhYmxlXCI7XG5cdCAgICB0aGlzLl9kYXRhb2JqID0gdGhpcy5fY29udGVudG9iajtcblx0ICAgIHRoaXMuX2hlYWRlciA9IHRoaXMuX2NvbnRlbnRvYmouZmlyc3RDaGlsZDtcblx0ICAgIHRoaXMuX2JvZHkgPSB0aGlzLl9oZWFkZXIubmV4dFNpYmxpbmc7XG5cdCAgICB0aGlzLl9mb290ZXIgPSB0aGlzLl9ib2R5Lm5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xuXG5cdCAgICB0aGlzLl92aWV3b2JqLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncmlkXCIpO1xuXG5cdCAgICBpZiAoIWNvbmZpZy5lZGl0YWJsZSkgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlYWRvbmx5XCIsIFwidHJ1ZVwiKTtcblx0ICAgIHRoaXMuZGF0YS5wcm92aWRlQXBpKHRoaXMsIHRydWUpO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25QYXJzZVwiLCBiaW5kKHRoaXMuX2NhbGxfb25wYXJzZSwgdGhpcykpO1xuXHQgICAgdGhpcy4kcmVhZHkucHVzaCh0aGlzLl9maXJzdF9yZW5kZXIpO1xuXHQgICAgdGhpcy5fY29sdW1ucyA9IFtdO1xuXHQgICAgdGhpcy5faGlkZGVuX2NvbHVtbl9vcmRlciA9IFtdO1xuXHQgICAgdGhpcy5faGVhZGVycyA9IFtdO1xuXHQgICAgdGhpcy5fZm9vdGVycyA9IFtdO1xuXHQgICAgdGhpcy5fcm93c19jYWNoZSA9IFtdO1xuXHQgICAgdGhpcy5fYWN0aXZlX2hlYWRlcnMgPSB7fTtcblx0ICAgIHRoaXMuX2ZpbHRlcl9lbGVtZW50cyA9IHt9O1xuXHQgICAgdGhpcy5faGVhZGVyX2hlaWdodCA9IHRoaXMuX2Zvb3Rlcl9oZWlnaHQgPSAwOyAvL2NvbXBvbmVudCBjYW4gY3JlYXRlIG5ldyB2aWV3XG5cblx0ICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZSA9IFtdO1xuXHQgICAgdGhpcy5kYXRhLmF0dGFjaEV2ZW50KFwib25TZXJ2ZXJDb25maWdcIiwgYmluZCh0aGlzLl9jb25maWdfdGFibGVfZnJvbV9maWxlLCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblNlcnZlck9wdGlvbnNcIiwgYmluZCh0aGlzLl9jb25maWdfb3B0aW9uc19mcm9tX2ZpbGUsIHRoaXMpKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvblZpZXdTaG93XCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdGhpcy5fcmVzdG9yZV9zY3JvbGxfc3RhdGUoKTtcblxuXHQgICAgICB0aGlzLl9yZWZyZXNoX2FueV9oZWFkZXJfY29udGVudCgpO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvbkNsZWFyQWxsXCIsIGJpbmQoZnVuY3Rpb24gKHNvZnQpIHtcblx0ICAgICAgaWYgKCFzb2Z0KSB7XG5cdCAgICAgICAgdGhpcy5fc2Nyb2xsTGVmdCA9IHRoaXMuX3Njcm9sbFRvcCA9IDA7XG5cdCAgICAgICAgaWYgKHRoaXMuX3hfc2Nyb2xsKSB0aGlzLl94X3Njcm9sbC5yZXNldCgpO1xuXHQgICAgICAgIGlmICh0aGlzLl95X3Njcm9sbCkgdGhpcy5feV9zY3JvbGwucmVzZXQoKTtcblxuXHQgICAgICAgIHRoaXMuX3NldExlZnRTY3JvbGwoMCk7XG5cdCAgICAgIH1cblx0ICAgIH0sIHRoaXMpKTtcblx0ICAgIHRoaXMuYXR0YWNoRXZlbnQoXCJvbkRlc3RydWN0XCIsIHRoaXMuX2NsZWFuX2NvbmZpZ19zdHJ1Y3QpO1xuXHQgICAgdGhpcy5hdHRhY2hFdmVudChcIm9uS2V5UHJlc3NcIiwgdGhpcy5fb25LZXlQcmVzcyk7XG5cdCAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TY3JvbGxZXCIsIHRoaXMuX2FkanVzdF9yb3dzKTtcblx0ICAgIGNhbGxFdmVudChcIm9uRGF0YVRhYmxlXCIsIFt0aGlzLCBjb25maWddKTtcblx0ICB9LFxuXHQgIF9yZW5kZXJfaW5pdGlhbDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fc2Nyb2xsU2l6ZVggPSB0aGlzLl9zY3JvbGxTaXplWSA9IGVudi5zY3JvbGxTaXplO1xuXHQgICAgYWRkU3R5bGUoXCIjXCIgKyB0aGlzLl90b3BfaWQgKyBcIiAud2ViaXhfY2VsbCB7IGhlaWdodDpcIiArIHRoaXMuX3NldHRpbmdzLnJvd0hlaWdodCArIFwicHg7IGxpbmUtaGVpZ2h0OlwiICsgKHRoaXMuX3NldHRpbmdzLnJvd0xpbmVIZWlnaHQgfHwgdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0KSArIFwicHg7XCIgKyAodGhpcy5fc2V0dGluZ3MuZml4ZWRSb3dIZWlnaHQgPyBcIlwiIDogXCJ3aGl0ZS1zcGFjZTpub3JtYWw7XCIpICsgXCIgfVwiKTtcblx0ICAgIGFkZFN0eWxlKFwiI1wiICsgdGhpcy5fdG9wX2lkICsgXCIgLndlYml4X2hjZWxsIHsgaGVpZ2h0OlwiICsgdGhpcy5fc2V0dGluZ3MuaGVhZGVyUm93SGVpZ2h0ICsgXCJweDsgbGluZS1oZWlnaHQ6XCIgKyB0aGlzLl9zZXR0aW5ncy5oZWFkZXJSb3dIZWlnaHQgKyBcInB4O31cIik7XG5cblx0ICAgIHRoaXMuX3JlbmRlcl9pbml0aWFsID0gZnVuY3Rpb24gKCkge307XG5cdCAgfSxcblx0ICBfZmlyc3RfcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlTG9hZFwiLCBiaW5kKHRoaXMuX3JlZnJlc2hfYW55X2hlYWRlcl9jb250ZW50LCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN5bmNBcHBseVwiLCBiaW5kKHRoaXMuX3JlZnJlc2hfYW55X2hlYWRlcl9jb250ZW50LCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9LCB0aGlzKSk7XG5cdCAgICB0aGlzLmRhdGEuYXR0YWNoRXZlbnQoXCJvblN0b3JlVXBkYXRlZFwiLCBiaW5kKHRoaXMuX3JlZnJlc2hfdHJhY2tpbmdfaGVhZGVyX2NvbnRlbnQsIHRoaXMpKTtcblx0ICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLnJlbmRlcigpO1xuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiAoaWQsIGRhdGEsIG1vZGUpIHtcblx0ICAgIC8vcHVyZSBkYXRhIHNhdmluZyBjYWxsXG5cdCAgICBpZiAobW9kZSA9PSBcInNhdmVcIikgcmV0dXJuOyAvL2R1cmluZyBkbmQgd2UgbXVzdCBub3QgcmVwYWludCBhbnl0aGluZyBpbiBtb2JpbGUgd2Via2l0XG5cblx0ICAgIGlmIChtb2RlID09IFwibW92ZVwiKSB7XG5cdCAgICAgIHZhciBjb250ZXh0ID0gRHJhZ0NvbnRyb2wuZ2V0Q29udGV4dCgpO1xuXHQgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmZyYWdpbGUpIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLl9jb2x1bW5zLmxlbmd0aCkge1xuXHQgICAgICB2YXIgY29scyA9IHRoaXMuX3NldHRpbmdzLmNvbHVtbnM7XG5cblx0ICAgICAgaWYgKCFjb2xzIHx8ICFjb2xzLmxlbmd0aCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvQ29uZmlnICYmIHRoaXMuZGF0YS5vcmRlci5sZW5ndGggJiYgIXRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIubGVuZ3RoKSB7XG5cdCAgICAgICAgICB0aGlzLl9kdGFibGVfZnVsbHlfcmVhZHkgPSAwO1xuXG5cdCAgICAgICAgICB0aGlzLl9hdXRvRGV0ZWN0Q29uZmlnKCk7XG5cdCAgICAgICAgfSBlbHNlIHJldHVybjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2RlZmluZV9zdHJ1Y3R1cmUoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSh0aGlzLl9zZXR0aW5ncy5pZCkgfHwgdGhpcy4kYmxvY2tSZW5kZXIpIHJldHVybiB0aGlzLl9yZW5kZXJfaW5pdGlhbCgpOyAvL0Nocm9tZSAzNCwgQ3VzdG9tIEZvbnQgbG9hZGluZyBidWdcblxuXHQgICAgdmFyIGZhc3RfbW9kZSA9IHRoaXMuY29uZmlnLmV4cGVyaW1lbnRhbCAmJiAhdGhpcy5fc2V0dGluZ3Muc3VidmlldzsgLy9yZXBsYWNlIG11bHRpcGxlIGF0b21pYyB1cGRhdGVzIGJ5IHNpbmdsZSBiaWcgcmVwYWludFxuXG5cdCAgICBpZiAoaWQgJiYgZGF0YSAhPSAtMSAmJiAobW9kZSA9PSBcInBhaW50XCIgfHwgbW9kZSA9PSBcInVwZGF0ZVwiKSAmJiAhZmFzdF9tb2RlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9yZW5kZXJfdGltZXIpIGNsZWFyVGltZW91dCh0aGlzLl9yZW5kZXJfdGltZXIpO1xuXG5cdCAgICAgIGlmICghdGhpcy5fcmVuZGVyX3RpbWVyIHx8IHRoaXMuX3JlbmRlcl90aW1lcl9pZCA9PSBpZCkge1xuXHQgICAgICAgIHRoaXMuX3JlbmRlcl90aW1lcl9pZCA9IGlkO1xuXHQgICAgICAgIHRoaXMuX3JlbmRlcl90aW1lciA9IGRlbGF5KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIC8vaWYgb25seSBvbmUgY2FsbCAtIHJlcGFpbnQgc2luZ2xlIGl0ZW1cblx0ICAgICAgICAgIHRoaXMucmVuZGVyKGlkLCAtMSwgbW9kZSk7XG5cdCAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fcmVuZGVyX3RpbWVyX2lkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZW5kZXJfdGltZXIgPSBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAvL2lmIHRoZXIgd2FzIGEgc2VyaWUgb2YgY2FsbHMgLSByZXBsYWNlIHRoZW0gd2l0aCBzaW5nbGUgZnVsbCByZXBhaW50XG5cdCAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgICAgIH0sIHRoaXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9yZW5kZXJfdGltZXIpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlbmRlcl90aW1lcik7XG5cdCAgICAgIHRoaXMuX3JlbmRlcl90aW1lciA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmNhbGxFdmVudChcIm9uQmVmb3JlUmVuZGVyXCIsIFt0aGlzLmRhdGFdKSkge1xuXHQgICAgICB0aGlzLl9yZW5kZXJfaW5pdGlhbCgpO1xuXG5cdCAgICAgIGlmICghdGhpcy5fZHRhYmxlX2Z1bGx5X3JlYWR5KSB0aGlzLl9hcHBseV9oZWFkZXJzKCk7XG5cblx0ICAgICAgaWYgKHRoaXMuX2NvbnRlbnRfd2lkdGgpIHtcblx0ICAgICAgICBpZiAoZmFzdF9tb2RlICYmIChtb2RlID09IFwicGFpbnRcIiB8fCBtb2RlID09IFwidXBkYXRlXCIpICYmIGlkKSB0aGlzLl9yZXBhaW50X3NpbmdsZV9yb3coaWQpO2Vsc2UgdGhpcy5fY2hlY2tfcmVuZGVyZWRfY29scyh0cnVlLCB0cnVlKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghaWQgfHwgbW9kZSAhPSBcInVwZGF0ZVwiKSB7XG5cdCAgICAgICAgdGhpcy5fZHRhYmxlX2hlaWdodCA9IHRoaXMuX2dldF90b3RhbF9oZWlnaHQoKTtcblxuXHQgICAgICAgIHRoaXMuX3NldF9zcGxpdF9zaXplc195KCk7XG5cdCAgICAgIH0gLy9kb24ndCBkZXBlbmQgb24gaGlkZGVuIHJvd3Mvcm9sdW1uc1xuXG5cblx0ICAgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbGNvdW50XCIsIE1hdGgubWF4KHRoaXMuX2hpZGRlbl9jb2x1bW5fb3JkZXIubGVuZ3RoLCB0aGlzLl9jb2x1bW5zLmxlbmd0aCkpO1xuXG5cdCAgICAgIHRoaXMuX3ZpZXdvYmouc2V0QXR0cmlidXRlKFwiYXJpYS1yb3djb3VudFwiLCB0aGlzLmRhdGEuY291bnQoKSk7XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyUmVuZGVyXCIsIFt0aGlzLmRhdGFdKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRDb2x1bW5Db25maWc6IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNfcHVsbFtpZF0gfHwgdGhpcy5faGlkZGVuX2NvbHVtbl9oYXNoW2lkXTtcblx0ICB9LFxuXHQgIF9jb25maWdfb3B0aW9uc19mcm9tX2ZpbGU6IGZ1bmN0aW9uIChjb2xscykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGNvbGxzKSB7XG5cdCAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkNvbmZpZyhrZXkpO1xuXHQgICAgICBhc3NlcnQoY29sdW1uLCBcIk9ycGhhbiBjb2xsZWN0aW9uOiBcIiArIGtleSk7XG5cdCAgICAgIHZhciB0ZW1wID0gbmV3IERhdGFDb2xsZWN0aW9uKHtcblx0ICAgICAgICBkYXRhOiBjb2xsc1trZXldXG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHRoaXMuX2Rlc3Ryb3lfd2l0aF9tZS5wdXNoKHRlbXApO1xuXG5cdCAgICAgIHRoaXMuX2JpbmRfY29sbGVjdGlvbih0ZW1wLCBjb2x1bW4pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgLy94bWwgaGFzIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIHN0cnVjdHVyZSwgZml4aW5nXG5cdCAgX2NvbmZpZ190YWJsZV9mcm9tX2ZpbGU6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0ICAgIGlmIChjb25maWcuY29sdW1ucyAmJiB0aGlzLl9kdGFibGVfZnVsbHlfcmVhZHkpIHRoaXMucmVmcmVzaENvbHVtbnMobnVsbCwgdHJ1ZSk7XG5cdCAgfSxcblx0ICBfZGVmaW5lX3N0cnVjdHVyZTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmNvbHVtbnMpIHtcblx0ICAgICAgdGhpcy5fY29sdW1ucyA9IHRoaXMuX3NldHRpbmdzLmNvbHVtbnM7XG5cdCAgICAgIHRoaXMuX2NvbHVtbnNfcHVsbCA9IHt9O1xuXG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjb2wgPSB0aGlzLl9jb2x1bW5zW2ldO1xuXHQgICAgICAgIHRoaXMuX2NvbHVtbnNfcHVsbFtjb2wuaWRdID0gY29sO1xuXHQgICAgICAgIHZhciBmb3JtYXQgPSBjb2wuY3NzRm9ybWF0O1xuXHQgICAgICAgIGlmIChmb3JtYXQpIGNvbC5jc3NGb3JtYXQgPSB0b0Z1bmN0b3IoZm9ybWF0LCB0aGlzLiRzY29wZSk7XG5cdCAgICAgICAgY29sLndpZHRoID0gY29sLndpZHRoIHx8IHRoaXMuX3NldHRpbmdzLmNvbHVtbldpZHRoO1xuXHQgICAgICAgIGlmICh0eXBlb2YgY29sLmZvcm1hdCA9PSBcInN0cmluZ1wiKSBjb2wuZm9ybWF0ID0gaTE4bltjb2wuZm9ybWF0XSB8fCB3aW5kb3dbY29sLmZvcm1hdF07XG5cblx0ICAgICAgICBpZiAoY29sLm51bWJlckZvcm1hdCkge1xuXHQgICAgICAgICAgdmFyIG5mb3JtYXQgPSBjb2wubnVtYmVyRm9ybWF0O1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBuZm9ybWF0ID09PSBcInN0cmluZ1wiKSBjb2wubnVtYmVyRm9ybWF0ID0gbmZvcm1hdCA9IE51bWJlciQxLmdldENvbmZpZyhuZm9ybWF0KTtcblx0ICAgICAgICAgIGNvbC5mb3JtYXQgPSBOdW1iZXIkMS5udW1Ub1N0cihuZm9ybWF0KTtcblxuXHQgICAgICAgICAgY29sLmVkaXRGb3JtYXQgPSBjb2wuZWRpdEZvcm1hdCB8fCBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBOdW1iZXIkMS5mb3JtYXQodmFsLCBuZm9ybWF0KTtcblx0ICAgICAgICAgIH07XG5cblx0ICAgICAgICAgIGNvbC5lZGl0UGFyc2UgPSBjb2wuZWRpdFBhcnNlIHx8IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE51bWJlciQxLnBhcnNlKHZhbCwgbmZvcm1hdCk7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0gLy9kZWZhdWx0IHNldHRpbmdzIGZvciBjaGVja2JveGVzIGFuZCByYWRpb3NcblxuXG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNvbC5jaGVja1ZhbHVlKSkgY29sLmNoZWNrVmFsdWUgPSAxO1xuXHQgICAgICAgIGlmIChpc1VuZGVmaW5lZChjb2wudW5jaGVja1ZhbHVlKSkgY29sLnVuY2hlY2tWYWx1ZSA9IDA7XG5cdCAgICAgICAgaWYgKGNvbC5jc3MgJiYgX3R5cGVvZihjb2wuY3NzKSA9PSBcIm9iamVjdFwiKSBjb2wuY3NzID0gY3JlYXRlQ3NzKGNvbC5jc3MpO1xuXHQgICAgICAgIHZhciByYXdUZW1wbGF0ZSA9IGNvbC50ZW1wbGF0ZTtcblxuXHQgICAgICAgIGlmIChyYXdUZW1wbGF0ZSkge1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiByYXdUZW1wbGF0ZSA9PSBcInN0cmluZ1wiKSByYXdUZW1wbGF0ZSA9IHJhd1RlbXBsYXRlLnJlcGxhY2UoLyNcXCR2YWx1ZSMvZywgXCIjXCIgKyBjb2wuaWQgKyBcIiNcIik7XG5cdCAgICAgICAgICBjb2wudGVtcGxhdGUgPSB0ZW1wbGF0ZShyYXdUZW1wbGF0ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5fbm9ybWFsaXplX2hlYWRlcnMoXCJoZWFkZXJcIiwgdGhpcy5faGVhZGVycyk7XG5cblx0ICAgICAgdGhpcy5fbm9ybWFsaXplX2hlYWRlcnMoXCJmb290ZXJcIiwgdGhpcy5fZm9vdGVycyk7XG5cblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblN0cnVjdHVyZUxvYWRcIiwgW10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2RlZmluZV9zdHJ1Y3R1cmVfYW5kX3JlbmRlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fYXBwbHlfaGVhZGVycygpO1xuXHQgIH0sXG5cdCAgX2NsZWFuX2NvbmZpZ19zdHJ1Y3Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vcmVtb3ZlIGNvbHVtbiB0ZWNobmljYWwgaW5mbyBmcm9tIHRoZSBjb2x1bW5cblx0ICAgIC8vaXQgYWxsb3dzIHRvIHJldXNlIHRoZSBzYW1lIGNvbmZpZyBvYmplY3QgZm9yIG5ldyBncmlkXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZGVsZXRlIHRoaXMuX2NvbHVtbnNbaV0uYXR0YWNoZWQ7XG5cdCAgICAgIGRlbGV0ZSB0aGlzLl9jb2x1bW5zW2ldLm5vZGU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfYXBwbHlfaGVhZGVyczogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5fcmlnaHRTcGxpdCA9IHRoaXMuX2NvbHVtbnMubGVuZ3RoIC0gdGhpcy5fc2V0dGluZ3MucmlnaHRTcGxpdDtcblx0ICAgIHRoaXMuX2R0YWJsZV93aWR0aCA9IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoIXRoaXMuX2NvbHVtbnNbaV0ubm9kZSkge1xuXHQgICAgICAgIHZhciB0ZW1wID0gY3JlYXRlKFwiRElWXCIpO1xuXHQgICAgICAgIHRlbXAuc3R5bGUud2lkdGggPSB0aGlzLl9jb2x1bW5zW2ldLndpZHRoICsgXCJweFwiO1xuXHQgICAgICAgIHRoaXMuX2NvbHVtbnNbaV0ubm9kZSA9IHRlbXA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaSA+PSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgJiYgaSA8IHRoaXMuX3JpZ2h0U3BsaXQpIHRoaXMuX2R0YWJsZV93aWR0aCArPSB0aGlzLl9jb2x1bW5zW2ldLndpZHRoO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbWFya3MgPSBbXTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnJpZ2h0U3BsaXQpIHtcblx0ICAgICAgdmFyIG5yID0gdGhpcy5fY29sdW1ucy5sZW5ndGggLSB0aGlzLl9zZXR0aW5ncy5yaWdodFNwbGl0O1xuXHQgICAgICBtYXJrc1tucl0gPSBcIiB3ZWJpeF9maXJzdFwiO1xuXHQgICAgICBtYXJrc1tuciAtIDFdID0gXCIgd2ViaXhfbGFzdFwiO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0KSB7XG5cdCAgICAgIHZhciBubCA9IHRoaXMuX3NldHRpbmdzLmxlZnRTcGxpdDtcblx0ICAgICAgbWFya3NbbmxdID0gXCIgd2ViaXhfZmlyc3RcIjtcblx0ICAgICAgbWFya3NbbmwgLSAxXSA9IFwiIHdlYml4X2xhc3RcIjtcblx0ICAgIH1cblxuXHQgICAgbWFya3NbMF0gPSAobWFya3NbMF0gfHwgXCJcIikgKyBcIiB3ZWJpeF9maXJzdCB3ZWJpeF9zZWxlY3RfbWFya1wiO1xuXHQgICAgdmFyIGxhc3RfaW5kZXggPSB0aGlzLl9jb2x1bW5zLmxlbmd0aCAtIDE7XG5cdCAgICBtYXJrc1tsYXN0X2luZGV4XSA9IChtYXJrc1tsYXN0X2luZGV4XSB8fCBcIlwiKSArIFwiIHdlYml4X2xhc3RcIjtcblxuXHQgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5fY29sdW1uc1tfaV0ubm9kZTtcblx0ICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5cIiwgX2kpO1xuXHQgICAgICBub2RlLmNsYXNzTmFtZSA9IFwid2ViaXhfY29sdW1uIFwiICsgKHRoaXMuX2NvbHVtbnNbX2ldLmNzcyB8fCBcIlwiKSArIChtYXJrc1tfaV0gfHwgXCJcIik7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2NyZWF0ZV9zY3JvbGxzKCk7XG5cblx0ICAgIHRoaXMuX3NldF9jb2x1bW5zX3Bvc2l0aW9ucygpO1xuXG5cdCAgICB0aGlzLl9zZXRfc3BsaXRfc2l6ZXNfeCgpO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJfaGVhZGVyX2FuZF9mb290ZXIoKTtcblxuXHQgICAgdGhpcy5fZHRhYmxlX2Z1bGx5X3JlYWR5ID0gdHJ1ZTtcblx0ICB9LFxuXHQgIF9zZXRfY29sdW1uc19wb3NpdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBsZWZ0ID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjb2x1bW4gPSB0aGlzLl9jb2x1bW5zW2ldO1xuXHQgICAgICBpZiAoaSA9PSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgfHwgaSA9PSB0aGlzLl9yaWdodFNwbGl0KSBsZWZ0ID0gMDtcblxuXHQgICAgICBpZiAoY29sdW1uLm5vZGUpIHtcblx0ICAgICAgICBjb2x1bW4ubm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcblxuXHQgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgfHwgdGhpcy5fc2V0dGluZ3MucmlnaHRTcGxpdCkge1xuXHQgICAgICAgICAgcmVtb3ZlKGNvbHVtbi5ub2RlKTtcblx0ICAgICAgICAgIGNvbHVtbi5hdHRhY2hlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGxlZnQgKz0gY29sdW1uLndpZHRoO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX3JlbmRlcl9oZWFkZXJfYW5kX2Zvb3RlcjogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLl9oZWFkZXJfZml4X3dpZHRoKSB0aGlzLl9oZWFkZXJfZml4X3dpZHRoID0gMDtcblx0ICAgIHRoaXMuX2hlYWRlcl9oZWlnaHQgPSB0aGlzLl9mb290ZXJfaGVpZ2h0ID0gMDtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWRlcikge1xuXHQgICAgICB0aGlzLl9yZWZyZXNoSGVhZGVyQ29udGVudCh0aGlzLl9oZWFkZXIsIDAsIDEpO1xuXG5cdCAgICAgIHRoaXMuX25vcm1hbGl6ZV9oZWFkZXJzKFwiaGVhZGVyXCIsIHRoaXMuX2hlYWRlcnMpO1xuXG5cdCAgICAgIHRoaXMuX2hlYWRlcl9oZWlnaHQgPSB0aGlzLl9oZWFkZXJzLl9zdW1tO1xuXG5cdCAgICAgIHRoaXMuX3JlbmRlcl9oZWFkZXJfc2VjdGlvbih0aGlzLl9oZWFkZXIsIFwiaGVhZGVyXCIsIHRoaXMuX2hlYWRlcnMpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZm9vdGVyKSB7XG5cdCAgICAgIHRoaXMuX3JlZnJlc2hIZWFkZXJDb250ZW50KHRoaXMuX2Zvb3RlciwgMCwgMSk7XG5cblx0ICAgICAgdGhpcy5fbm9ybWFsaXplX2hlYWRlcnMoXCJmb290ZXJcIiwgdGhpcy5fZm9vdGVycyk7XG5cblx0ICAgICAgdGhpcy5fZm9vdGVyX2hlaWdodCA9IHRoaXMuX2Zvb3RlcnMuX3N1bW07XG5cblx0ICAgICAgdGhpcy5fcmVuZGVyX2hlYWRlcl9zZWN0aW9uKHRoaXMuX2Zvb3RlciwgXCJmb290ZXJcIiwgdGhpcy5fZm9vdGVycyk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucmVmcmVzaEhlYWRlckNvbnRlbnQoZmFsc2UsIGZhbHNlKTtcblxuXHQgICAgdGhpcy5fc2l6ZV9oZWFkZXJfZm9vdGVyX2ZpeCgpO1xuXG5cdCAgICBpZiAodGhpcy5fbGFzdF9zb3J0ZWQpIHRoaXMubWFya1NvcnRpbmcodGhpcy5fbGFzdF9zb3J0ZWQsIHRoaXMuX2xhc3Rfb3JkZXIpO1xuXHQgIH0sXG5cdCAgX2dldEhlYWRlckhlaWdodDogZnVuY3Rpb24gKGhlYWRlciwgY29sdW1uLCBpbmQpIHtcblx0ICAgIHZhciB3aWR0aCA9IDA7XG5cdCAgICB2YXIgY29sc3BhbiA9IGhlYWRlci5jb2xzcGFuIHx8IDE7XG5cdCAgICB2YXIgY3NzID0gXCJ3ZWJpeF9oY2VsbCBcIiArIChoZWFkZXIuY3NzIHx8IFwiXCIpO1xuXHQgICAgaWYgKGhlYWRlci5yb3RhdGUpIGNzcyArPSBcIiB3ZWJpeF9tZWFzdXJlX3JvdGF0ZVwiO2Vsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzcGFuOyBpKyspIHtcblx0ICAgICAgd2lkdGggKz0gdGhpcy5fY29sdW1uc1tpbmQgKyBpXSA/IHRoaXMuX2NvbHVtbnNbaW5kICsgaV0ud2lkdGggOiB0aGlzLmNvbmZpZy5jb2x1bW5XaWR0aDtcblx0ICAgIH1cblx0ICAgIHZhciBzaXplID0gZ2V0VGV4dFNpemUoW2hlYWRlci50ZXh0XSwgY3NzLCB3aWR0aCk7IC8vKzEgdG8gY29tcGVuc2F0ZSBmb3Igc2Nyb2xsSGVpZ2h0IHJvdW5kaW5nXG5cblx0ICAgIHJldHVybiAoaGVhZGVyLnJvdGF0ZSA/IHNpemUud2lkdGggOiBzaXplLmhlaWdodCkgKyAxO1xuXHQgIH0sXG5cdCAgX25vcm1hbGl6ZV9oZWFkZXJzOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaGVpZ2h0cykge1xuXHQgICAgdmFyIHJvd3MgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRhdGEgPSB0aGlzLl9jb2x1bW5zW2ldW2NvbGxlY3Rpb25dO1xuXG5cdCAgICAgIGlmICghZGF0YSB8fCBfdHlwZW9mKGRhdGEpICE9IFwib2JqZWN0XCIgfHwgIWRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpKSB7XG5cdCAgICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBcImhlYWRlclwiKSBkYXRhID0gdGhpcy5fY29sdW1uc1tpXS5pZDtlbHNlIGRhdGEgPSBcIlwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGRhdGEgPSBbZGF0YV07XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICBpZiAoX3R5cGVvZihkYXRhW2pdKSAhPSBcIm9iamVjdFwiKSBkYXRhW2pdID0ge1xuXHQgICAgICAgICAgdGV4dDogZGF0YVtqXVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGRhdGFbal0gJiYgZGF0YVtqXS5oZWlnaHQpIGhlaWdodHNbal0gPSBkYXRhW2pdLmhlaWdodDtcblx0ICAgICAgICBpZiAoZGF0YVtqXSAmJiBkYXRhW2pdLmF1dG9oZWlnaHQpIGhlaWdodHNbal0gPSB0aGlzLl9nZXRIZWFkZXJIZWlnaHQoZGF0YVtqXSwgdGhpcy5fY29sdW1uc1tpXSwgaSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByb3dzID0gTWF0aC5tYXgocm93cywgZGF0YS5sZW5ndGgpO1xuXHQgICAgICB0aGlzLl9jb2x1bW5zW2ldW2NvbGxlY3Rpb25dID0gZGF0YTtcblx0ICAgIH1cblxuXHQgICAgaGVpZ2h0cy5fc3VtbSA9IHJvd3M7XG5cblx0ICAgIGZvciAodmFyIF9pMiA9IHJvd3MgLSAxOyBfaTIgPj0gMDsgX2kyLS0pIHtcblx0ICAgICAgaGVpZ2h0c1tfaTJdID0gaGVpZ2h0c1tfaTJdIHx8IHRoaXMuX3NldHRpbmdzLmhlYWRlclJvd0hlaWdodDtcblx0ICAgICAgaGVpZ2h0cy5fc3VtbSArPSBoZWlnaHRzW19pMl0gKiAxO1xuXHQgICAgfSAvL3NldCBudWxsIHRvIGNlbGxzIGluY2x1ZGVkIGluIGNvbHxyb3cgc3BhbnNcblxuXG5cdCAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgdmFyIGNvbCA9IHRoaXMuX2NvbHVtbnNbX2kzXVtjb2xsZWN0aW9uXTtcblxuXHQgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgY29sLmxlbmd0aDsgX2orKykge1xuXHQgICAgICAgIGlmIChjb2xbX2pdICYmIGNvbFtfal0ucm93c3BhbikgZm9yICh2YXIgeiA9IDE7IHogPCBjb2xbX2pdLnJvd3NwYW47IHorKykge1xuXHQgICAgICAgICAgY29sW19qICsgel0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29sW19qXSAmJiBjb2xbX2pdLmNvbHNwYW4pIGZvciAodmFyIF96ID0gMTsgX3ogPCBjb2xbX2pdLmNvbHNwYW47IF96KyspIHtcblx0ICAgICAgICAgIHRoaXMuX2NvbHVtbnNbX2kzICsgX3pdW2NvbGxlY3Rpb25dW19qXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IC8vYXV0by1yb3dzcGFuIGNlbGxzLCB3aGljaCBoYXMgbm90IGVub3VnaCBoZWFkZXIgbGluZXNcblxuXG5cdCAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgX2k0KyspIHtcblx0ICAgICAgdmFyIF9kYXRhID0gdGhpcy5fY29sdW1uc1tfaTRdW2NvbGxlY3Rpb25dO1xuXG5cdCAgICAgIGlmIChfZGF0YS5sZW5ndGggPCByb3dzKSB7XG5cdCAgICAgICAgdmFyIGVuZCA9IF9kYXRhLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgX2RhdGFbZW5kXS5yb3dzcGFuID0gcm93cyAtIF9kYXRhLmxlbmd0aCArIDE7XG5cblx0ICAgICAgICBmb3IgKHZhciBfajIgPSBlbmQgKyAxOyBfajIgPCByb3dzOyBfajIrKykge1xuXHQgICAgICAgICAgX2RhdGFbX2oyXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByb3dzO1xuXHQgIH0sXG5cdCAgX2ZpbmRfaGVhZGVyX2NvbnRlbnQ6IGZ1bmN0aW9uIChzZWMsIGlkKSB7XG5cdCAgICB2YXIgYWxsdGQgPSBzZWMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJURFwiKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGx0ZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAoYWxsdGRbaV0uZ2V0QXR0cmlidXRlKFwiYWN0aXZlX2lkXCIpID09IGlkKSByZXR1cm4gYWxsdGRbaV07XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRIZWFkZXJDb250ZW50OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHZhciBvYmogPSB0aGlzLl9maW5kX2hlYWRlcl9jb250ZW50KHRoaXMuX2hlYWRlciwgaWQpO1xuXG5cdCAgICBpZiAoIW9iaikgb2JqID0gdGhpcy5fZmluZF9oZWFkZXJfY29udGVudCh0aGlzLl9mb290ZXIsIGlkKTtcblxuXHQgICAgaWYgKG9iaikge1xuXHQgICAgICB2YXIgY29uZmlnID0gdGhpcy5fYWN0aXZlX2hlYWRlcnNbaWRdO1xuXHQgICAgICB2YXIgdHlwZSQkMSA9IGRhdGFmaWx0ZXJbY29uZmlnLmNvbnRlbnRdO1xuXHQgICAgICB2YXIgX2Jhc2UgPSB7XG5cdCAgICAgICAgdHlwZTogdHlwZSQkMSxcblx0ICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKHRleHQpIHtcblx0ICAgICAgICAgIHJldHVybiB0eXBlJCQxLmdldFZhbHVlKG9iaiwgdGV4dCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHlwZSQkMS5zZXRWYWx1ZShvYmosIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICAgIGlmICh0eXBlJCQxLmdldEhlbHBlcikgZXhwb3J0cy5leHRlbmQoX2Jhc2UsIHR5cGUkJDEuZ2V0SGVscGVyKG9iaiwgY29uZmlnKSk7XG5cdCAgICAgIHJldHVybiBfYmFzZTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zdW1tX25leHQ6IGZ1bmN0aW9uIChoZWlnaHRzLCBzdGFydCwgaSkge1xuXHQgICAgdmFyIHN1bW0gPSBpID8gLTEgOiAwO1xuXHQgICAgaSArPSBzdGFydDtcblxuXHQgICAgZm9yIChzdGFydDsgc3RhcnQgPCBpOyBzdGFydCsrKSB7XG5cdCAgICAgIHN1bW0gKz0gaGVpZ2h0c1tzdGFydF0gKyAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc3VtbTtcblx0ICB9LFxuXHQgIF9yZW5kZXJfc3ViaGVhZGVyOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgd2lkdGgsIG5hbWUsIGhlaWdodHMpIHtcblx0ICAgIGlmIChzdGFydCA9PSBlbmQpIHJldHVybiBcIlwiO1xuXHQgICAgdmFyIGh0bWwgPSBcIjx0YWJsZSByb2xlPSdwcmVzZW50YXRpb24nIHN0eWxlPSd3aWR0aDpcIiArIHdpZHRoICsgXCJweCcgY2VsbHNwYWNpbmc9JzAnIGNlbGxwYWRkaW5nPScwJz5cIjtcblx0ICAgIGh0bWwgKz0gXCI8dHIgY2xhc3M9J3dlYml4X3NpemVfcm93Jz5cIjtcblxuXHQgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0ICAgICAgaHRtbCArPSBcIjx0ZCBzdHlsZT0nd2lkdGg6XCIgKyB0aGlzLl9jb2x1bW5zW2ldLndpZHRoICsgXCJweDsnPjwvdGQ+XCI7XG5cdCAgICB9XG5cblx0ICAgIGh0bWwgKz0gXCI8L3RyPlwiO1xuXHQgICAgdmFyIGNvdW50ID0gdGhpcy5fY29sdW1uc1swXVtuYW1lXS5sZW5ndGg7XG5cblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuXHQgICAgICBodG1sICs9IFwiPHRyIHNlY3Rpb249J1wiICsgbmFtZSArIFwiJyByb2xlPSdyb3cnPlwiO1xuXG5cdCAgICAgIGZvciAodmFyIF9pNSA9IHN0YXJ0OyBfaTUgPCBlbmQ7IF9pNSsrKSB7XG5cdCAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX2NvbHVtbnNbX2k1XVtuYW1lXVtqXTtcblx0ICAgICAgICBpZiAoaGVhZGVyID09PSBudWxsKSBjb250aW51ZTtcblxuXHQgICAgICAgIGlmIChoZWFkZXIuY29udGVudCkge1xuXHQgICAgICAgICAgaGVhZGVyLmNvbnRlbnRJZCA9IGhlYWRlci5jb250ZW50SWQgfHwgdWlkKCk7XG5cdCAgICAgICAgICBoZWFkZXIuY29sdW1uSWQgPSB0aGlzLl9jb2x1bW5zW19pNV0uaWQ7XG5cdCAgICAgICAgICBoZWFkZXIuZm9ybWF0ID0gdGhpcy5fY29sdW1uc1tfaTVdLmZvcm1hdDtcblx0ICAgICAgICAgIGFzc2VydChkYXRhZmlsdGVyLCBcIkZpbHRlcmluZyBleHRlbnNpb24gd2FzIG5vdCBpbmNsdWRlZFwiKTtcblx0ICAgICAgICAgIGFzc2VydChkYXRhZmlsdGVyW2hlYWRlci5jb250ZW50XSwgXCJVbmtub3duIGNvbnRlbnQgdHlwZTogXCIgKyBoZWFkZXIuY29udGVudCk7XG5cdCAgICAgICAgICBoZWFkZXIudGV4dCA9IGRhdGFmaWx0ZXJbaGVhZGVyLmNvbnRlbnRdLnJlbmRlcih0aGlzLCBoZWFkZXIpO1xuXHQgICAgICAgICAgdGhpcy5fYWN0aXZlX2hlYWRlcnNbaGVhZGVyLmNvbnRlbnRJZF0gPSBoZWFkZXI7XG5cdCAgICAgICAgICB0aGlzLl9oYXNfYWN0aXZlX2hlYWRlcnMgPSB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGh0bWwgKz0gXCI8dGQgIHJvbGU9J3ByZXNlbnRhdGlvbicgY29sdW1uPSdcIiArIChoZWFkZXIuY29sc3BhbiA/IGhlYWRlci5jb2xzcGFuIC0gMSArIF9pNSA6IF9pNSkgKyBcIidcIjtcblx0ICAgICAgICB2YXIgaGNzcyA9IFwiXCI7XG5cdCAgICAgICAgaWYgKF9pNSA9PSBzdGFydCkgaGNzcyArPSBcIndlYml4X2ZpcnN0XCI7XG5cdCAgICAgICAgdmFyIGNvbHVtbl9wb3MgPSBfaTUgKyAoaGVhZGVyLmNvbHNwYW4gPyBoZWFkZXIuY29sc3BhbiAtIDEgOiAwKTtcblx0ICAgICAgICBpZiAoY29sdW1uX3BvcyA+PSBlbmQgLSAxKSBoY3NzICs9IFwiIHdlYml4X2xhc3RcIjtcblx0ICAgICAgICBpZiAoaGVhZGVyLnJvd3NwYW4gJiYgaiArIGhlYWRlci5yb3dzcGFuID09PSBjb3VudCB8fCBqID09PSBjb3VudCAtIDEpIGhjc3MgKz0gXCIgd2ViaXhfbGFzdF9yb3dcIjtcblx0ICAgICAgICBpZiAoaGNzcykgaHRtbCArPSBcIiBjbGFzcz1cXFwiXCIgKyBoY3NzICsgXCJcXFwiXCI7XG5cdCAgICAgICAgdmFyIGNlbGxfaGVpZ2h0ID0gaGVpZ2h0c1tqXTtcblx0ICAgICAgICB2YXIgc2hlaWdodCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGhlYWRlci5jb250ZW50SWQpIGh0bWwgKz0gXCIgYWN0aXZlX2lkPSdcIiArIGhlYWRlci5jb250ZW50SWQgKyBcIidcIjtcblx0ICAgICAgICBpZiAoaGVhZGVyLmNvbHNwYW4pIGh0bWwgKz0gXCIgY29sc3Bhbj0nXCIgKyBoZWFkZXIuY29sc3BhbiArIFwiJ1wiO1xuXG5cdCAgICAgICAgaWYgKGhlYWRlci5yb3dzcGFuKSB7XG5cdCAgICAgICAgICBodG1sICs9IFwiIHJvd3NwYW49J1wiICsgaGVhZGVyLnJvd3NwYW4gKyBcIidcIjtcblx0ICAgICAgICAgIGNlbGxfaGVpZ2h0ID0gdGhpcy5fc3VtbV9uZXh0KHRoaXMuX2hlYWRlcnMsIGosIGhlYWRlci5yb3dzcGFuKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY2VsbF9oZWlnaHQgIT0gdGhpcy5fc2V0dGluZ3MuaGVhZGVyUm93SGVpZ2h0KSBzaGVpZ2h0ID0gXCIgc3R5bGU9J2xpbmUtaGVpZ2h0OlwiICsgY2VsbF9oZWlnaHQgKyBcInB4OyBoZWlnaHQ6XCIgKyBjZWxsX2hlaWdodCArIFwicHg7J1wiO1xuXHQgICAgICAgIHZhciBjc3MgPSBcIndlYml4X2hjZWxsXCI7XG5cdCAgICAgICAgdmFyIGhlYWRlcl9jc3MgPSBoZWFkZXIuY3NzO1xuXG5cdCAgICAgICAgaWYgKGhlYWRlcl9jc3MpIHtcblx0ICAgICAgICAgIGlmIChfdHlwZW9mKGhlYWRlcl9jc3MpID09IFwib2JqZWN0XCIpIGhlYWRlci5jc3MgPSBoZWFkZXJfY3NzID0gY3JlYXRlQ3NzKGhlYWRlcl9jc3MpO1xuXHQgICAgICAgICAgY3NzICs9IFwiIFwiICsgaGVhZGVyX2Nzcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodGhpcy5fY29sdW1uc1tfaTVdLiRzZWxlY3RlZCkgY3NzICs9IFwiIHdlYml4X3NlbF9oY2VsbFwiO1xuXHQgICAgICAgIGh0bWwgKz0gXCI+PGRpdiByb2xlPSdjb2x1bW5oZWFkZXInIGNsYXNzPSdcIiArIGNzcyArIFwiJ1wiICsgc2hlaWdodCArIFwiPlwiO1xuXHQgICAgICAgIHZhciB0ZXh0ID0gaGVhZGVyLnRleHQgPT09IFwiXCIgPyBcIiZuYnNwO1wiIDogaGVhZGVyLnRleHQ7XG5cdCAgICAgICAgaWYgKGhlYWRlci5yb3RhdGUpIHRleHQgPSBcIjxkaXYgY2xhc3M9J3dlYml4X3JvdGF0ZScgc3R5bGU9J3dpZHRoOlwiICsgKGNlbGxfaGVpZ2h0IC0gMTApICsgXCJweDsgdHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgXCIgKyAoY2VsbF9oZWlnaHQgLSAxNSkgLyAyICsgXCJweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2VudGVyIFwiICsgKGNlbGxfaGVpZ2h0IC0gMTUpIC8gMiArIFwicHg7Jz5cIiArIHRleHQgKyBcIjwvZGl2PlwiO1xuXHQgICAgICAgIGh0bWwgKz0gdGV4dCArIFwiPC9kaXY+PC90ZD5cIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIGh0bWwgKz0gXCI8L3RyPlwiO1xuXHQgICAgfVxuXG5cdCAgICBodG1sICs9IFwiPC90cj48L3RhYmxlPlwiO1xuXHQgICAgcmV0dXJuIGh0bWw7XG5cdCAgfSxcblx0ICBzaG93SXRlbUJ5SW5kZXg6IGZ1bmN0aW9uIChyb3dfaW5kLCBjb2x1bW5faW5kKSB7XG5cdCAgICB2YXIgcGFnZXIgPSB0aGlzLl9zZXR0aW5ncy5wYWdlcjtcblxuXHQgICAgaWYgKHBhZ2VyKSB7XG5cdCAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmZsb29yKHJvd19pbmQgLyBwYWdlci5zaXplKTtcblx0ICAgICAgaWYgKHRhcmdldCAhPSBwYWdlci5wYWdlKSAkJChwYWdlci5pZCkuc2VsZWN0KHRhcmdldCk7XG5cdCAgICB9IC8vcGFyYW1ldGVyIHdpbGwgYmUgc2V0IHRvIC0xLCB0byBtYXJrIHRoYXQgc2Nyb2xsIG5lZWQgbm90IHRvIGJlIGFkanVzdGVkXG5cblxuXHQgICAgdmFyIHNjcm9sbCA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblxuXHQgICAgaWYgKHJvd19pbmQgIT0gLTEpIHtcblx0ICAgICAgdmFyIHN0YXRlID0gdGhpcy5fZ2V0X3lfcmFuZ2UoKTtcblxuXHQgICAgICBpZiAocm93X2luZCA8IHN0YXRlWzBdICsgMSB8fCByb3dfaW5kID49IHN0YXRlWzFdIC0gMSkge1xuXHQgICAgICAgIC8vbm90IHZpc2libGUgY3VycmVudGx5XG5cdCAgICAgICAgdmFyIHN1bW0gPSB0aGlzLl9nZXRIZWlnaHRCeUluZGV4U3VtbShwYWdlciA/IHRoaXMuZGF0YS4kbWluIDogMCwgcm93X2luZCk7XG5cblx0ICAgICAgICBpZiAocm93X2luZCA8IHN0YXRlWzBdICsgMSkge1xuXHQgICAgICAgICAgLy9zY3JvbGwgdG9wIC0gc2hvdyByb3cgYXQgdG9wIG9mIHNjcmVlblxuXHQgICAgICAgICAgc3VtbSA9IE1hdGgubWF4KDAsIHN1bW0gLSAxKSAtIHRoaXMuX3RvcF9zcGxpdF9oZWlnaHQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vc2Nyb2xsIGJvdHRvbSAtIHNob3cgcm93IGF0IGJvdHRvbSBvZiBzY3JlZW5cblx0ICAgICAgICAgIHN1bW0gKz0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleChyb3dfaW5kKSAtIHRoaXMuX2R0YWJsZV9vZmZzZXRfaGVpZ2h0OyAvL2JlY2F1c2Ugb2Ygcm93IHJvdW5kaW5nIHdlIG5lZXQgdG8gc2Nyb2xsIHNvbWUgZXh0cmFcblx0ICAgICAgICAgIC8vVE9ETzogY3JlYXRlIGEgYmV0dGVyIGhldXJpc3RpY1xuXG5cdCAgICAgICAgICBpZiAocm93X2luZCA+IDApIHN1bW0gKz0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleChyb3dfaW5kIC0gMSkgLSAxO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHNjcm9sbC55ID0gc3VtbTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoY29sdW1uX2luZCAhPSAtMSkge1xuXHQgICAgICAvL2lnbm9yZSBzcGxpdCBjb2x1bW5zIC0gdGhleSBhcmUgYWx3YXlzIHZpc2libGVcblx0ICAgICAgaWYgKGNvbHVtbl9pbmQgPCB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQpIHJldHVybjtcblx0ICAgICAgaWYgKGNvbHVtbl9pbmQgPj0gdGhpcy5fcmlnaHRTcGxpdCkgcmV0dXJuOyAvL3Zlcnkgc2ltaWxhciB0byB5LWxvZ2ljIGFib3ZlXG5cblx0ICAgICAgdmFyIF9zdGF0ZSA9IHRoaXMuX2dldF94X3JhbmdlKCk7XG5cblx0ICAgICAgaWYgKGNvbHVtbl9pbmQgPCBfc3RhdGVbMF0gKyAxIHx8IGNvbHVtbl9pbmQgPj0gX3N0YXRlWzFdIC0gMSkge1xuXHQgICAgICAgIC8vbm90IHZpc2libGUgY3VycmVudGx5XG5cdCAgICAgICAgdmFyIF9zdW1tID0gMDtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQ7IGkgPCBjb2x1bW5faW5kOyBpKyspIHtcblx0ICAgICAgICAgIF9zdW1tICs9IHRoaXMuX2NvbHVtbnNbaV0ud2lkdGg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qanNsOmlnbm9yZSovXG5cblxuXHQgICAgICAgIGlmIChjb2x1bW5faW5kIDwgX3N0YXRlWzBdICsgMSkgOyBlbHNlIHtcblx0ICAgICAgICAgIC8vc2Nyb2xsIHRvIHJpZ2h0IGJvcmRlclxuXHQgICAgICAgICAgX3N1bW0gKz0gdGhpcy5fY29sdW1uc1tjb2x1bW5faW5kXS53aWR0aCAtIHRoaXMuX2NlbnRlcl93aWR0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLypqc2w6ZW5kKi9cblxuXG5cdCAgICAgICAgc2Nyb2xsLnggPSBfc3VtbTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLnNjcm9sbFRvKHNjcm9sbC54LCBzY3JvbGwueSk7XG5cdCAgfSxcblx0ICBzaG93Q2VsbDogZnVuY3Rpb24gKHJvdywgY29sdW1uKSB7XG5cdCAgICBpZiAoIWNvbHVtbiB8fCAhcm93KSB7XG5cdCAgICAgIC8vaWYgY29sdW1uIG9yIHJvdyBub3QgcHJvdmlkZWQgLSB0YWtlIGZyb20gY3VycmVudCBzZWxlY3Rpb25cblx0ICAgICAgdmFyIHQgPSB0aGlzLmdldFNlbGVjdGVkSWQodHJ1ZSk7XG5cblx0ICAgICAgaWYgKHQubGVuZ3RoID09IDEpIHtcblx0ICAgICAgICBjb2x1bW4gPSBjb2x1bW4gfHwgdFswXS5jb2x1bW47XG5cdCAgICAgICAgcm93ID0gcm93IHx8IHRbMF0ucm93O1xuXHQgICAgICB9XG5cdCAgICB9IC8vY29udmVydCBpZCB0byBpbmRleFxuXG5cblx0ICAgIGNvbHVtbiA9IGNvbHVtbiA/IHRoaXMuZ2V0Q29sdW1uSW5kZXgoY29sdW1uKSA6IC0xO1xuXHQgICAgcm93ID0gcm93ID8gdGhpcy5nZXRJbmRleEJ5SWQocm93KSA6IC0xO1xuXHQgICAgdGhpcy5zaG93SXRlbUJ5SW5kZXgocm93LCBjb2x1bW4pO1xuXHQgIH0sXG5cdCAgc2Nyb2xsVG86IGZ1bmN0aW9uICh4LCB5KSB7XG5cdCAgICBpZiAoIXRoaXMuX3hfc2Nyb2xsKSByZXR1cm47XG5cdCAgICBpZiAodGhpcy5fc2Nyb2xsVG9fdG91Y2gpIHJldHVybiB0aGlzLl9zY3JvbGxUb190b3VjaCh4LCB5KTtcblx0ICAgIGlmICh4ICE9PSBudWxsKSB0aGlzLl94X3Njcm9sbC5zY3JvbGxUbyh4KTtcblx0ICAgIGlmICh5ICE9PSBudWxsKSB0aGlzLl95X3Njcm9sbC5zY3JvbGxUbyh5KTtcblx0ICB9LFxuXHQgIGdldFNjcm9sbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fZ2V0U2Nyb2xsU3RhdGVfdG91Y2gpIHJldHVybiB0aGlzLl9nZXRTY3JvbGxTdGF0ZV90b3VjaCgpO1xuXHQgICAgdmFyIGRpZmYgPSB0aGlzLl9yZW5kZXJfc2Nyb2xsX3NoaWZ0ID8gMCA6IHRoaXMuX3JlbmRlcl9zY3JvbGxfZGlmZiB8fCAwO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgeDogdGhpcy5fc2Nyb2xsTGVmdCB8fCAwLFxuXHQgICAgICB5OiB0aGlzLl9zY3JvbGxUb3AgKyBkaWZmXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgc2hvd0l0ZW06IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgdGhpcy5zaG93SXRlbUJ5SW5kZXgodGhpcy5nZXRJbmRleEJ5SWQoaWQpLCAtMSk7XG5cdCAgfSxcblx0ICBfcmVuZGVyX2hlYWRlcl9zZWN0aW9uOiBmdW5jdGlvbiAoc2VjLCBuYW1lLCBoZWlnaHRzKSB7XG5cdCAgICB2YXIgaGVhZGVyID0gc2VjLmNoaWxkTm9kZXM7XG5cdCAgICBoZWFkZXJbMF0uaW5uZXJIVE1MID0gdGhpcy5fcmVuZGVyX3N1YmhlYWRlcigwLCB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQsIHRoaXMuX2xlZnRfd2lkdGgsIG5hbWUsIGhlaWdodHMpO1xuXHQgICAgaGVhZGVyWzFdLmlubmVySFRNTCA9IHRoaXMuX3JlbmRlcl9zdWJoZWFkZXIodGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0LCB0aGlzLl9yaWdodFNwbGl0LCB0aGlzLl9kdGFibGVfd2lkdGgsIG5hbWUsIGhlaWdodHMpO1xuXHQgICAgaGVhZGVyWzJdLmlubmVySFRNTCA9IHRoaXMuX3JlbmRlcl9zdWJoZWFkZXIodGhpcy5fcmlnaHRTcGxpdCwgdGhpcy5fY29sdW1ucy5sZW5ndGgsIHRoaXMuX3JpZ2h0X3dpZHRoLCBuYW1lLCBoZWlnaHRzKTtcblx0ICAgIGlmICh0aGlzLl9kdGFibGVfY29sdW1uX3JlZnJlc2gpIGhlYWRlclsxXS5zY3JvbGxMZWZ0ID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpLng7XG5cdCAgICBoZWFkZXJbMV0ub25zY3JvbGwgPSBiaW5kKHRoaXMuX3Njcm9sbF93aXRoX2hlYWRlciwgdGhpcyk7XG5cdCAgfSxcblx0ICBfc2Nyb2xsX3dpdGhfaGVhZGVyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgYWN0aXZlID0gdGhpcy5nZXRTY3JvbGxTdGF0ZSgpLng7XG5cdCAgICB2YXIgaGVhZGVyID0gdGhpcy5faGVhZGVyLmNoaWxkTm9kZXNbMV0uc2Nyb2xsTGVmdDtcblx0ICAgIGlmIChoZWFkZXIgIT0gYWN0aXZlKSB0aGlzLnNjcm9sbFRvKGhlYWRlciwgbnVsbCk7XG5cdCAgfSxcblx0ICBfcmVmcmVzaF90cmFja2luZ19oZWFkZXJfY29udGVudDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZWZyZXNoSGVhZGVyQ29udGVudCh0cnVlLCB0cnVlKTtcblx0ICB9LFxuXHQgIF9yZWZyZXNoX2FueV9oZWFkZXJfY29udGVudDogZnVuY3Rpb24gKCkge1xuXHQgICAgdGhpcy5yZWZyZXNoSGVhZGVyQ29udGVudChmYWxzZSwgdHJ1ZSk7XG5cdCAgfSxcblx0ICAvL1tERVBSRUNBVEVdIC0gdjMuMCwgbW92ZSB0byBwcml2YXRlXG5cdCAgcmVmcmVzaEhlYWRlckNvbnRlbnQ6IGZ1bmN0aW9uICh0cmFja2VkT25seSwgcHJlc2VydmUsIGlkKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGVhZGVyKSB7XG5cdCAgICAgIGlmIChwcmVzZXJ2ZSkgdGhpcy5fcmVmcmVzaEhlYWRlckNvbnRlbnQodGhpcy5faGVhZGVyLCB0cmFja2VkT25seSwgMSwgaWQpO1xuXG5cdCAgICAgIHRoaXMuX3JlZnJlc2hIZWFkZXJDb250ZW50KHRoaXMuX2hlYWRlciwgdHJhY2tlZE9ubHksIDAsIGlkKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmZvb3Rlcikge1xuXHQgICAgICBpZiAocHJlc2VydmUpIHRoaXMuX3JlZnJlc2hIZWFkZXJDb250ZW50KHRoaXMuX2Zvb3RlciwgdHJhY2tlZE9ubHksIDEsIGlkKTtcblxuXHQgICAgICB0aGlzLl9yZWZyZXNoSGVhZGVyQ29udGVudCh0aGlzLl9mb290ZXIsIHRyYWNrZWRPbmx5LCAwLCBpZCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICByZWZyZXNoRmlsdGVyOiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIHRoaXMucmVmcmVzaEhlYWRlckNvbnRlbnQoZmFsc2UsIHRydWUsIGlkKTtcblx0ICB9LFxuXHQgIF9yZWZyZXNoSGVhZGVyQ29udGVudDogZnVuY3Rpb24gKHNlYywgY2VsbFRyYWNrT25seSwgZ2V0T25seSwgYnlJZCkge1xuXHQgICAgaWYgKHRoaXMuX2hhc19hY3RpdmVfaGVhZGVycyAmJiBzZWMpIHtcblx0ICAgICAgdmFyIGFsbHRkID0gc2VjLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiVERcIik7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGx0ZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChhbGx0ZFtpXS5nZXRBdHRyaWJ1dGUoXCJhY3RpdmVfaWRcIikpIHtcblx0ICAgICAgICAgIHZhciBvYmogPSB0aGlzLl9hY3RpdmVfaGVhZGVyc1thbGx0ZFtpXS5nZXRBdHRyaWJ1dGUoXCJhY3RpdmVfaWRcIildO1xuXG5cdCAgICAgICAgICBpZiAoYnlJZCAmJiBieUlkICE9IG9iai5jb2x1bW5JZCkgY29udGludWU7XG5cdCAgICAgICAgICB2YXIgY29udGVudCA9IGRhdGFmaWx0ZXJbb2JqLmNvbnRlbnRdO1xuXG5cdCAgICAgICAgICBpZiAoZ2V0T25seSkge1xuXHQgICAgICAgICAgICBpZiAoY29udGVudC5nZXRWYWx1ZSkge1xuXHQgICAgICAgICAgICAgIG9iai52YWx1ZSA9IGNvbnRlbnQuZ2V0VmFsdWUoYWxsdGRbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCFjZWxsVHJhY2tPbmx5IHx8IGNvbnRlbnQudHJhY2tDZWxscykge1xuXHQgICAgICAgICAgICBjb250ZW50LnJlZnJlc2godGhpcywgYWxsdGRbaV0sIG9iaik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBoZWFkZXJDb250ZW50OiBbXSxcblx0ICBfc2V0X3NpemVfc2Nyb2xsX2FyZWE6IGZ1bmN0aW9uIChvYmosIGhlaWdodCwgaGR4KSB7XG5cdCAgICBpZiAodGhpcy5fc2Nyb2xsU2l6ZVkpIHtcblx0ICAgICAgb2JqLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgMSkgLSAxICsgXCJweFwiO1xuXHQgICAgICBvYmouc3R5bGUud2lkdGggPSAodGhpcy5fcmlnaHRTcGxpdCA/IDAgOiBoZHgpICsgdGhpcy5fc2Nyb2xsU2l6ZVkgLSAxICsgXCJweFwiOyAvLyB0ZW1wLiBmaXg6IENocm9tZSBbRElSVFldXG5cblx0ICAgICAgaWYgKGVudi5pc1dlYktpdCkgdmFyIHcgPSBvYmoub2Zmc2V0V2lkdGg7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXHQgICAgfSBlbHNlIG9iai5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgfSxcblx0ICBfc2l6ZV9oZWFkZXJfZm9vdGVyX2ZpeDogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWRlcikgdGhpcy5fc2V0X3NpemVfc2Nyb2xsX2FyZWEodGhpcy5faGVhZGVyX3Njcm9sbCwgdGhpcy5faGVhZGVyX2hlaWdodCwgdGhpcy5faGVhZGVyX2ZpeF93aWR0aCk7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZm9vdGVyKSB0aGlzLl9zZXRfc2l6ZV9zY3JvbGxfYXJlYSh0aGlzLl9mb290ZXJfc2Nyb2xsLCB0aGlzLl9mb290ZXJfaGVpZ2h0LCB0aGlzLl9oZWFkZXJfZml4X3dpZHRoKTtcblx0ICB9LFxuXHQgIF91cGRhdGVfc2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgaGFzWCA9ICEodGhpcy5fc2V0dGluZ3MuYXV0b3dpZHRoIHx8IHRoaXMuX3NldHRpbmdzLnNjcm9sbFggPT09IGZhbHNlKTtcblx0ICAgIHRoaXMuX3Njcm9sbFNpemVYID0gaGFzWCA/IGVudi5zY3JvbGxTaXplIDogMDtcblx0ICAgIHZhciBoYXNZID0gISh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0IHx8IHRoaXMuX3NldHRpbmdzLnNjcm9sbFkgPT09IGZhbHNlKTtcblx0ICAgIHRoaXMuX3Njcm9sbFNpemVZID0gaGFzWSA/IGVudi5zY3JvbGxTaXplIDogMDtcblx0ICAgIGlmIChlbnYudG91Y2gpIGhhc1ggPSBoYXNZID0gZmFsc2U7XG5cblx0ICAgIGlmICh0aGlzLl94X3Njcm9sbCkge1xuXHQgICAgICB0aGlzLl94X3Njcm9sbC5fc2V0dGluZ3Muc2Nyb2xsU2l6ZSA9IHRoaXMuX3Njcm9sbFNpemVYO1xuXHQgICAgICB0aGlzLl94X3Njcm9sbC5fc2V0dGluZ3Muc2Nyb2xsVmlzaWJsZSA9IGhhc1g7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl95X3Njcm9sbCkge1xuXHQgICAgICB0aGlzLl95X3Njcm9sbC5fc2V0dGluZ3Muc2Nyb2xsU2l6ZSA9IHRoaXMuX3Njcm9sbFNpemVZO1xuXHQgICAgICB0aGlzLl95X3Njcm9sbC5fc2V0dGluZ3Muc2Nyb2xsVmlzaWJsZSA9IGhhc1k7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY3JlYXRlX3Njcm9sbHM6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XG5cdCAgICB0aGlzLl9zY3JvbGxMZWZ0ID0gMDtcblx0ICAgIHZhciBzY3J4LCBzY3J5O1xuXHQgICAgc2NyeCA9IHNjcnkgPSAxO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG9oZWlnaHQgfHwgdGhpcy5fc2V0dGluZ3Muc2Nyb2xsWSA9PT0gZmFsc2UpIHNjcnkgPSB0aGlzLl9zY3JvbGxTaXplWSA9IDA7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuYXV0b3dpZHRoIHx8IHRoaXMuX3NldHRpbmdzLnNjcm9sbFggPT09IGZhbHNlKSBzY3J4ID0gdGhpcy5fc2Nyb2xsU2l6ZVggPSAwO1xuXHQgICAgaWYgKGVudi50b3VjaCkgc2NyeCA9IHNjcnkgPSAwO1xuXG5cdCAgICBpZiAoIXRoaXMuX3hfc2Nyb2xsKSB7XG5cdCAgICAgIHRoaXMuX3hfc2Nyb2xsID0gdWkoe1xuXHQgICAgICAgIHZpZXc6IFwidnNjcm9sbFwiLFxuXHQgICAgICAgIGNvbnRhaW5lcjogdGhpcy5fZm9vdGVyLnByZXZpb3VzU2libGluZyxcblx0ICAgICAgICBzY3JvbGxXaWR0aDogdGhpcy5fZHRhYmxlX3dpZHRoLFxuXHQgICAgICAgIHNjcm9sbFNpemU6IHRoaXMuX3Njcm9sbFNpemVYLFxuXHQgICAgICAgIHNjcm9sbFZpc2libGU6IHNjcnhcblx0ICAgICAgfSk7IC8vZml4IGZvciBzY3JvbGwgc3BhY2Ugb24gTWFjXG5cblx0ICAgICAgaWYgKHNjcnggJiYgIXRoaXMuX3Njcm9sbFNpemVYICYmICFlbnYuJGN1c3RvbVNjcm9sbCkgdGhpcy5feF9zY3JvbGwuX3ZpZXdvYmouc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cblx0ICAgICAgdGhpcy5feF9zY3JvbGwuYXR0YWNoRXZlbnQoXCJvblNjcm9sbFwiLCBiaW5kKHRoaXMuX29uc2Nyb2xsX3gsIHRoaXMpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCF0aGlzLl95X3Njcm9sbCkge1xuXHQgICAgICB0aGlzLl9oZWFkZXJfc2Nyb2xsID0gdGhpcy5fZm9vdGVyLm5leHRTaWJsaW5nO1xuXHQgICAgICB2YXIgdnNjcm9sbF92aWV3ID0gdGhpcy5faGVhZGVyX3Njcm9sbC5uZXh0U2libGluZztcblx0ICAgICAgdGhpcy5fZm9vdGVyX3Njcm9sbCA9IHZzY3JvbGxfdmlldy5uZXh0U2libGluZztcblx0ICAgICAgdGhpcy5feV9zY3JvbGwgPSB1aSh7XG5cdCAgICAgICAgdmlldzogXCJ2c2Nyb2xsXCIsXG5cdCAgICAgICAgY29udGFpbmVyOiB2c2Nyb2xsX3ZpZXcsXG5cdCAgICAgICAgc2Nyb2xsSGVpZ2h0OiAxMDAsXG5cdCAgICAgICAgc2Nyb2xsOiBcInlcIixcblx0ICAgICAgICBzY3JvbGxTaXplOiB0aGlzLl9zY3JvbGxTaXplWSxcblx0ICAgICAgICBzY3JvbGxWaXNpYmxlOiBzY3J5XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHRoaXMuX3lfc2Nyb2xsLmFjdGl2ZUFyZWEodGhpcy5fYm9keSk7XG5cblx0ICAgICAgdGhpcy5feF9zY3JvbGwuYWN0aXZlQXJlYSh0aGlzLl9ib2R5LCB0cnVlKTtcblxuXHQgICAgICB0aGlzLl95X3Njcm9sbC5hdHRhY2hFdmVudChcIm9uU2Nyb2xsXCIsIGJpbmQodGhpcy5fb25zY3JvbGxfeSwgdGhpcykpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fY29udGVudF93aWR0aCkgdGhpcy5jYWxsRXZlbnQoXCJvblJlc2l6ZVwiLCBbdGhpcy5fY29udGVudF93aWR0aCwgdGhpcy5fY29udGVudF9oZWlnaHRdKTtcblx0ICAgIGlmIChlbnYuJGN1c3RvbVNjcm9sbCkgdGVtcCQxLmVuYWJsZSh0aGlzKTtcblxuXHQgICAgdGhpcy5fY3JlYXRlX3Njcm9sbHMgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICB9LFxuXHQgIGNvbHVtbklkOiBmdW5jdGlvbiAoaW5kZXgkJDEpIHtcblx0ICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2luZGV4JCQxXS5pZDtcblx0ICB9LFxuXHQgIGdldENvbHVtbkluZGV4OiBmdW5jdGlvbiAoaWQpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fY29sdW1uc1tpXS5pZCA9PSBpZCkgcmV0dXJuIGk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAtMTtcblx0ICB9LFxuXHQgIF9nZXROb2RlQm94OiBmdW5jdGlvbiAocmlkLCBjaWQpIHtcblx0ICAgIHZhciB4cyA9IDAsXG5cdCAgICAgICAgeGUgPSAwLFxuXHQgICAgICAgIHllID0gMCxcblx0ICAgICAgICB5cyA9IDA7XG5cdCAgICB2YXIgaTtcblx0ICAgIHZhciB6b25lID0gMDtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKHRoaXMuX3JpZ2h0U3BsaXQgPT0gaSB8fCB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgPT0gaSkge1xuXHQgICAgICAgIHhzID0gMDtcblx0ICAgICAgICB6b25lKys7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5fY29sdW1uc1tpXS5pZCA9PSBjaWQpIGJyZWFrO1xuXHQgICAgICB4cyArPSB0aGlzLl9jb2x1bW5zW2ldLndpZHRoO1xuXHQgICAgfVxuXG5cdCAgICB4ZSArPSB0aGlzLl9jb2x1bW5zW2ldLndpZHRoO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kYXRhLm9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmICh0aGlzLmRhdGEub3JkZXJbaV0gPT0gcmlkKSBicmVhaztcblx0ICAgICAgeXMgKz0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleChpKTtcblx0ICAgIH1cblxuXHQgICAgeWUgKz0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleChpKTtcblx0ICAgIHJldHVybiBbeHMsIHhlLCB5cyAtIHRoaXMuX3Njcm9sbFRvcCwgeWUsIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1t6b25lXV07XG5cdCAgfSxcblx0ICBfaWRfdG9fc3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5yb3c7XG5cdCAgfSxcblx0ICBsb2NhdGU6IGZ1bmN0aW9uIChub2RlLCBpZE9ubHkpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zdWJ2aWV3ICYmIHRoaXMgIT0gJCQobm9kZSkpIHJldHVybiBudWxsO1xuXHQgICAgbm9kZSA9IG5vZGUudGFyZ2V0IHx8IG5vZGUuc3JjRWxlbWVudCB8fCBub2RlO1xuXG5cdCAgICB3aGlsZSAobm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSkge1xuXHQgICAgICBpZiAobm9kZSA9PT0gdGhpcy4kdmlldykgYnJlYWs7XG5cblx0ICAgICAgdmFyIGNzID0gX2dldENsYXNzTmFtZShub2RlKS50b1N0cmluZygpO1xuXG5cdCAgICAgIHZhciBwb3MkJDEgPSBudWxsO1xuXG5cdCAgICAgIGlmIChjcy5pbmRleE9mKFwid2ViaXhfY2VsbFwiKSAhPSAtMSkge1xuXHQgICAgICAgIHBvcyQkMSA9IHRoaXMuX2xvY2F0ZShub2RlKTtcblx0ICAgICAgICBpZiAocG9zJCQxKSBwb3MkJDEucm93ID0gdGhpcy5kYXRhLm9yZGVyW3BvcyQkMS5yaW5kXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjcy5pbmRleE9mKFwid2ViaXhfaGNlbGxcIikgIT0gLTEpIHtcblx0ICAgICAgICBwb3MkJDEgPSB0aGlzLl9sb2NhdGUobm9kZSk7XG5cdCAgICAgICAgaWYgKHBvcyQkMSkgcG9zJCQxLmhlYWRlciA9IHRydWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoY3MuaW5kZXhPZihcIndlYml4X2Ryb3BfYXJlYVwiKSAhPSAtMSkge1xuXHQgICAgICAgIHBvcyQkMSA9IHRoaXMuX2xvY2F0ZShub2RlKTtcblx0ICAgICAgICBpZiAocG9zJCQxKSBwb3MkJDEucm93ID0gcG9zJCQxLnJpbmQgPSBcIiR3ZWJpeC1kcm9wXCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocG9zJCQxKSB7XG5cdCAgICAgICAgaWYgKGlkT25seSkgcmV0dXJuIHBvcyQkMS5oZWFkZXIgPyBudWxsIDogcG9zJCQxLnJvdztcblx0ICAgICAgICBwb3MkJDEuY29sdW1uID0gdGhpcy5fY29sdW1uc1twb3MkJDEuY2luZF0uaWQ7XG5cdCAgICAgICAgcG9zJCQxLnRvU3RyaW5nID0gdGhpcy5faWRfdG9fc3RyaW5nO1xuXHQgICAgICAgIHJldHVybiBwb3MkJDE7XG5cdCAgICAgIH1cblxuXHQgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9LFxuXHQgIF9sb2NhdGU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICB2YXIgY2RpdiA9IG5vZGUucGFyZW50Tm9kZTtcblx0ICAgIGlmICghY2RpdikgcmV0dXJuIG51bGw7XG5cdCAgICB2YXIgY29sdW1uID0gKG5vZGUuZ2V0QXR0cmlidXRlKFwiY29sdW1uXCIpIHx8IGNkaXYuZ2V0QXR0cmlidXRlKFwiY29sdW1uXCIpKSAqIDE7XG5cdCAgICB2YXIgcmluZCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1yb3dpbmRleFwiKTtcblx0ICAgIHZhciByb3cgPSBub2RlLmdldEF0dHJpYnV0ZShcInJvd1wiKSB8fCAocmluZCA/IHJpbmQgLSAxIDogMCk7XG5cdCAgICB2YXIgc3BhbiA9IChub2RlLmdldEF0dHJpYnV0ZShcImNvbHNwYW5cIikgfHwgY2Rpdi5nZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIpKSAqIDE7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICByaW5kOiByb3csXG5cdCAgICAgIGNpbmQ6IGNvbHVtbixcblx0ICAgICAgc3Bhbjogc3BhblxuXHQgICAgfTtcblx0ICB9LFxuXHQgIF9jb3JyZWN0U2Nyb2xsU2l6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGNlbnRlciA9IC10aGlzLl9jZW50ZXJfd2lkdGg7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBjZW50ZXIgKz0gdGhpcy5fY29sdW1uc1tpXS53aWR0aDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2Nyb2xsTGVmdCA9IE1hdGgubWluKHRoaXMuX3Njcm9sbExlZnQsIE1hdGgubWF4KDAsIGNlbnRlcikpO1xuXHQgIH0sXG5cdCAgX3VwZGF0ZUNvbHNTaXplU2V0dGluZ3M6IGZ1bmN0aW9uIChzaWxlbnQpIHtcblx0ICAgIGlmICghdGhpcy5fZHRhYmxlX2Z1bGx5X3JlYWR5KSByZXR1cm47XG5cblx0ICAgIHRoaXMuX2NvcnJlY3RTY3JvbGxTaXplKCk7XG5cblx0ICAgIHRoaXMuX3NldF9jb2x1bW5zX3Bvc2l0aW9ucygpO1xuXG5cdCAgICB0aGlzLl9zZXRfc3BsaXRfc2l6ZXNfeCgpO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJfaGVhZGVyX2FuZF9mb290ZXIoKTtcblxuXHQgICAgaWYgKCFzaWxlbnQpIHRoaXMuX2NoZWNrX3JlbmRlcmVkX2NvbHMoZmFsc2UsIGZhbHNlKTtcblx0ICB9LFxuXHQgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbiAoY29sLCB3aWR0aCwgc2tpcF91cGRhdGUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9zZXRDb2x1bW5XaWR0aCh0aGlzLmdldENvbHVtbkluZGV4KGNvbCksIHdpZHRoLCBza2lwX3VwZGF0ZSk7XG5cdCAgfSxcblx0ICBfc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uIChjb2wsIHdpZHRoLCBza2lwX3VwZGF0ZSwgYnlfdXNlcikge1xuXHQgICAgaWYgKGlzTmFOKHdpZHRoKSB8fCBjb2wgPCAwKSByZXR1cm47XG5cdCAgICB2YXIgY29sdW1uID0gdGhpcy5fY29sdW1uc1tjb2xdO1xuXHQgICAgaWYgKGNvbHVtbi5taW5XaWR0aCAmJiB3aWR0aCA8IGNvbHVtbi5taW5XaWR0aCkgd2lkdGggPSBjb2x1bW4ubWluV2lkdGg7ZWxzZSBpZiAod2lkdGggPCB0aGlzLl9zZXR0aW5ncy5taW5Db2x1bW5XaWR0aCkgd2lkdGggPSB0aGlzLl9zZXR0aW5ncy5taW5Db2x1bW5XaWR0aDtcblx0ICAgIHZhciBvbGQgPSBjb2x1bW4ud2lkdGg7XG5cblx0ICAgIGlmIChvbGQgIT0gd2lkdGgpIHtcblx0ICAgICAgaWYgKGNvbCA+PSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgJiYgY29sIDwgdGhpcy5fcmlnaHRTcGxpdCkgdGhpcy5fZHRhYmxlX3dpZHRoICs9IHdpZHRoIC0gb2xkO1xuXHQgICAgICBjb2x1bW4ud2lkdGggPSB3aWR0aDtcblx0ICAgICAgaWYgKGNvbHVtbi5ub2RlKSAvL21ldGhvZCBjYW4gYmUgY2FsbGVkIGZyb20gb25TdHJ1Y3RMb2FkXG5cdCAgICAgICAgY29sdW1uLm5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtlbHNlIHJldHVybiBmYWxzZTtcblx0ICAgICAgaWYgKCFza2lwX3VwZGF0ZSkgdGhpcy5fdXBkYXRlQ29sc1NpemVTZXR0aW5ncygpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQ29sdW1uUmVzaXplXCIsIFtjb2x1bW4uaWQsIHdpZHRoLCBvbGQsICEhYnlfdXNlcl0pO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH0sXG5cdCAgX2dldFJvd0hlaWdodDogZnVuY3Rpb24gKHJvdykge1xuXHQgICAgcmV0dXJuIChyb3cuJGhlaWdodCB8fCB0aGlzLl9zZXR0aW5ncy5yb3dIZWlnaHQpICsgKHJvdy4kc3Vib3BlbiA/IHJvdy4kc3ViSGVpZ2h0IDogMCk7XG5cdCAgfSxcblx0ICBfZ2V0SGVpZ2h0QnlJbmRleDogZnVuY3Rpb24gKGluZGV4JCQxKSB7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmRhdGEub3JkZXJbaW5kZXgkJDFdO1xuXHQgICAgaWYgKCFpZCkgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnJvd0hlaWdodDtcblx0ICAgIHJldHVybiB0aGlzLl9nZXRSb3dIZWlnaHQodGhpcy5kYXRhLnB1bGxbaWRdKTtcblx0ICB9LFxuXHQgIF9nZXRIZWlnaHRCeUluZGV4U3VtbTogZnVuY3Rpb24gKGluZGV4MSwgaW5kZXgyKSB7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3MuZml4ZWRSb3dIZWlnaHQpIHJldHVybiAoaW5kZXgyIC0gaW5kZXgxKSAqIHRoaXMuX3NldHRpbmdzLnJvd0hlaWdodDtlbHNlIHtcblx0ICAgICAgdmFyIHN1bW0gPSAwO1xuXG5cdCAgICAgIGZvciAoOyBpbmRleDEgPCBpbmRleDI7IGluZGV4MSsrKSB7XG5cdCAgICAgICAgc3VtbSArPSB0aGlzLl9nZXRIZWlnaHRCeUluZGV4KGluZGV4MSk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gc3VtbTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9jZWxsUG9zaXRpb246IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xuXHQgICAgdmFyIHRvcDtcblxuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHQgICAgICBjb2x1bW4gPSByb3cuY29sdW1uO1xuXHQgICAgICByb3cgPSByb3cucm93O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShyb3cpO1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGNvbHVtbik7XG5cdCAgICB2YXIgbGVmdCA9IDA7XG5cdCAgICB2YXIgcGFyZW50ID0gMDtcblxuXHQgICAgZm9yICh2YXIgaW5kZXgkJDEgPSAwOyBpbmRleCQkMSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpbmRleCQkMSsrKSB7XG5cdCAgICAgIGlmIChpbmRleCQkMSA9PSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQgfHwgaW5kZXgkJDEgPT0gdGhpcy5fcmlnaHRTcGxpdCkgbGVmdCA9IDA7XG5cdCAgICAgIHZhciBsZWZ0Y29sdW1uID0gdGhpcy5fY29sdW1uc1tpbmRleCQkMV07XG5cblx0ICAgICAgaWYgKGxlZnRjb2x1bW4uaWQgPT0gY29sdW1uKSB7XG5cdCAgICAgICAgdmFyIHNwbGl0X2NvbHVtbiA9IGluZGV4JCQxIDwgdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0ID8gMCA6IGluZGV4JCQxID49IHRoaXMuX3JpZ2h0U3BsaXQgPyAyIDogMTtcblx0ICAgICAgICBwYXJlbnQgPSB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbc3BsaXRfY29sdW1uXS5maXJzdENoaWxkO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cblx0ICAgICAgbGVmdCArPSBsZWZ0Y29sdW1uLndpZHRoO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5nZXRJbmRleEJ5SWQocm93KSA8IHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0KSB0b3AgPSB0aGlzLl9nZXRIZWlnaHRCeUluZGV4U3VtbSgwLCB0aGlzLmdldEluZGV4QnlJZChyb3cpKTtlbHNlIHRvcCA9IHRoaXMuX2dldEhlaWdodEJ5SW5kZXhTdW1tKCh0aGlzLl9yZW5kZXJfc2Nyb2xsX3RvcCB8fCAwKSAtIHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0LCB0aGlzLmdldEluZGV4QnlJZChyb3cpKSArICh0aGlzLl9yZW5kZXJfc2Nyb2xsX3NoaWZ0IHx8IDApO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgcGFyZW50OiBwYXJlbnQsXG5cdCAgICAgIHRvcDogdG9wLFxuXHQgICAgICBsZWZ0OiBsZWZ0LFxuXHQgICAgICB3aWR0aDogY29uZmlnLndpZHRoLFxuXHQgICAgICBoZWlnaHQ6IGl0ZW0uJGhlaWdodCB8fCB0aGlzLl9zZXR0aW5ncy5yb3dIZWlnaHRcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfZ2V0X3RvdGFsX2hlaWdodDogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBhZ2VyID0gdGhpcy5fc2V0dGluZ3MucGFnZXI7XG5cdCAgICB2YXIgc3RhcnQgPSAwO1xuXHQgICAgdmFyIG1heCA9IHRoaXMuZGF0YS5vcmRlci5sZW5ndGg7XG5cblx0ICAgIGlmIChwYWdlcikge1xuXHQgICAgICBzdGFydCA9IHBhZ2VyLnNpemUgKiBwYWdlci5wYWdlO1xuXHQgICAgICBtYXggPSBNYXRoLm1pbihtYXgsIHN0YXJ0ICsgcGFnZXIuc2l6ZSk7XG5cblx0ICAgICAgaWYgKHBhZ2VyLmxldmVsKSB7XG5cdCAgICAgICAgc3RhcnQgPSB0aGlzLmRhdGEuJG1pbjtcblx0ICAgICAgICBtYXggPSB0aGlzLmRhdGEuJG1heDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleFN1bW0oc3RhcnQsIG1heCk7XG5cdCAgfSxcblx0ICBzZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uIChyb3dJZCwgaGVpZ2h0KSB7XG5cdCAgICBpZiAoaXNOYU4oaGVpZ2h0KSkgcmV0dXJuO1xuXHQgICAgaWYgKGhlaWdodCA8IHRoaXMuX3NldHRpbmdzLm1pbkNvbHVtbkhlaWdodCkgaGVpZ2h0ID0gdGhpcy5fc2V0dGluZ3MubWluQ29sdW1uSGVpZ2h0O1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0ocm93SWQpO1xuXHQgICAgdmFyIG9sZF9oZWlnaHQgPSBpdGVtLiRoZWlnaHQgfHwgdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0O1xuXG5cdCAgICBpZiAob2xkX2hlaWdodCAhPSBoZWlnaHQpIHtcblx0ICAgICAgaXRlbS4kaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgICB0aGlzLmNvbmZpZy5maXhlZFJvd0hlaWdodCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLnJlbmRlcigpO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uUm93UmVzaXplXCIsIFtyb3dJZCwgaGVpZ2h0LCBvbGRfaGVpZ2h0XSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25zY3JvbGxfeTogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICB2YXIgc2Nyb2xsQ2hhbmdlID0gdGhpcy5fc2Nyb2xsVG9wICE9PSB2YWx1ZTtcblx0ICAgIHRoaXMuX3Njcm9sbFRvcCA9IHZhbHVlO1xuXG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLnByZXJlbmRlcikge1xuXHQgICAgICB0aGlzLl9jaGVja19yZW5kZXJlZF9jb2xzKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgY29udHMgPSB0aGlzLl9ib2R5LmNoaWxkTm9kZXM7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGNvbnRzW2ldLnNjcm9sbFRvcCA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbnYuJGN1c3RvbVNjcm9sbCkgdGVtcCQxLl91cGRhdGVfc2Nyb2xsKHRoaXMuX2JvZHkpO1xuXG5cdCAgICBpZiAoc2Nyb2xsQ2hhbmdlKSB7XG5cdCAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25TY3JvbGxZXCIsIFtdKTtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU2Nyb2xsXCIsIFtdKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIF9zZXRMZWZ0U2Nyb2xsOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1sxXS5zY3JvbGxMZWZ0ID0gdGhpcy5fc2Nyb2xsTGVmdCA9IHZhbHVlO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmhlYWRlcikgdGhpcy5faGVhZGVyLmNoaWxkTm9kZXNbMV0uc2Nyb2xsTGVmdCA9IHZhbHVlO1xuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmZvb3RlcikgdGhpcy5fZm9vdGVyLmNoaWxkTm9kZXNbMV0uc2Nyb2xsTGVmdCA9IHZhbHVlO1xuXHQgIH0sXG5cdCAgX29uc2Nyb2xsX3g6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdmFyIHNjcm9sbENoYW5nZSA9IHRoaXMuX3Njcm9sbExlZnQgIT09IHZhbHVlO1xuXG5cdCAgICB0aGlzLl9zZXRMZWZ0U2Nyb2xsKHZhbHVlKTtcblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLnByZXJlbmRlciA9PT0gZmFsc2UpIHRoaXMuX2NoZWNrX3JlbmRlcmVkX2NvbHModGhpcy5fbWluaW1pemVfZG9tX2NoYW5nZXMgPyBmYWxzZSA6IHRydWUpO1xuXHQgICAgaWYgKGVudi4kY3VzdG9tU2Nyb2xsKSB0ZW1wJDEuX3VwZGF0ZV9zY3JvbGwodGhpcy5fYm9keSk7XG5cblx0ICAgIGlmIChzY3JvbGxDaGFuZ2UpIHtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblNjcm9sbFhcIiwgW10pO1xuXHQgICAgICB0aGlzLmNhbGxFdmVudChcIm9uQWZ0ZXJTY3JvbGxcIiwgW10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2dldF94X3JhbmdlOiBmdW5jdGlvbiAoZnVsbCkge1xuXHQgICAgaWYgKGZ1bGwpIHJldHVybiBbMCwgdGhpcy5fY29sdW1ucy5sZW5ndGhdO1xuXHQgICAgdmFyIHQgPSB0aGlzLl9zY3JvbGxMZWZ0O1xuXHQgICAgdmFyIHhpbmQgPSB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQ7XG5cblx0ICAgIHdoaWxlICh0ID4gMCAmJiB0aGlzLl9jb2x1bW5zLmxlbmd0aCAtIDEgPiB4aW5kKSB7XG5cdCAgICAgIHQgLT0gdGhpcy5fY29sdW1uc1t4aW5kXS53aWR0aDtcblx0ICAgICAgeGluZCsrO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeGVuZCA9IHhpbmQ7XG5cdCAgICBpZiAodCAmJiB4aW5kID4gMCkgeGluZC0tO1xuXHQgICAgdCArPSB0aGlzLl9jZW50ZXJfd2lkdGg7XG5cblx0ICAgIHdoaWxlICh0ID4gMCAmJiB4ZW5kIDwgdGhpcy5fcmlnaHRTcGxpdCkge1xuXHQgICAgICB0IC09IHRoaXMuX2NvbHVtbnNbeGVuZF0ud2lkdGg7XG5cdCAgICAgIHhlbmQrKztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFt4aW5kLCB4ZW5kXTtcblx0ICB9LFxuXHQgIGdldFZpc2libGVDb3VudDogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fZHRhYmxlX29mZnNldF9oZWlnaHQgLyB0aGlzLmNvbmZpZy5yb3dIZWlnaHQpO1xuXHQgIH0sXG5cdCAgLy9yZXR1cm5zIGluZm8gYWJvdXQgeS1zY3JvbGwgcG9zaXRpb25cblx0ICBfZ2V0X3lfcmFuZ2U6IGZ1bmN0aW9uIChmdWxsKSB7XG5cdCAgICB2YXIgdCA9IHRoaXMuX3Njcm9sbFRvcDtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICB2YXIgZW5kID0gdGhpcy5jb3VudCgpOyAvL2FwcGx5IHBhZ2VyLCBpZiBkZWZpbmVkXG5cblx0ICAgIHZhciBwYWdlciA9IHRoaXMuX3NldHRpbmdzLnBhZ2VyO1xuXG5cdCAgICBpZiAocGFnZXIpIHtcblx0ICAgICAgc3RhcnQgPSBwYWdlci5wYWdlICogcGFnZXIuc2l6ZTtcblx0ICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBzdGFydCArIHBhZ2VyLnNpemUpO1xuXG5cdCAgICAgIGlmIChwYWdlci5sZXZlbCkge1xuXHQgICAgICAgIHN0YXJ0ID0gdGhpcy5kYXRhLiRtaW47XG5cdCAgICAgICAgZW5kID0gdGhpcy5kYXRhLiRtYXg7XG5cdCAgICAgIH1cblx0ICAgIH0gLy9pbiBjYXNlIG9mIGF1dG9oZWlnaHQgLSByZXF1ZXN0IGZ1bGwgcmVuZGVyaW5nXG5cblxuXHQgICAgaWYgKHRoaXMuX3NldHRpbmdzLmF1dG9oZWlnaHQpIHJldHVybiBbc3RhcnQsIGVuZCwgMF07XG5cdCAgICBpZiAoZnVsbCkgcmV0dXJuIFtzdGFydCwgZW5kLCAwXTtcblx0ICAgIHZhciB4aW5kID0gc3RhcnQ7XG5cdCAgICB2YXIgdG9wU3BsaXQgPSB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCB8fCAwO1xuXHQgICAgaWYgKHRvcFNwbGl0KSB4aW5kICs9IHRvcFNwbGl0O1xuXHQgICAgdmFyIHJvd0hlaWdodCA9IHRoaXMuX3NldHRpbmdzLmZpeGVkUm93SGVpZ2h0ID8gdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0IDogMDtcblxuXHQgICAgaWYgKHJvd0hlaWdodCkge1xuXHQgICAgICB2YXIgZGVwID0gTWF0aC5jZWlsKHQgLyByb3dIZWlnaHQpO1xuXHQgICAgICB0IC09IGRlcCAqIHJvd0hlaWdodDtcblx0ICAgICAgeGluZCArPSBkZXA7XG5cdCAgICB9IGVsc2Ugd2hpbGUgKHQgPiAwKSB7XG5cdCAgICAgIHQgLT0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleCh4aW5kKTtcblx0ICAgICAgeGluZCsrO1xuXHQgICAgfSAvL2hvdyBtdWNoIG9mIHRoZSBmaXJzdCBjZWxsIGlzIHNjcm9sbGVkIG91dFxuXG5cblx0ICAgIHZhciB4ZGVmID0geGluZCA+IDAgJiYgdCA/IC0odGhpcy5fZ2V0SGVpZ2h0QnlJbmRleCh4aW5kIC0gMSkgKyB0KSA6IDA7XG5cdCAgICB2YXIgeGVuZCA9IHhpbmQ7XG5cdCAgICBpZiAodCkgeGluZC0tO1xuXHQgICAgdCArPSAodGhpcy5fZHRhYmxlX29mZnNldF9oZWlnaHQgfHwgdGhpcy5fY29udGVudF9oZWlnaHQpIC0gKHRoaXMuX3RvcF9zcGxpdF9oZWlnaHQgfHwgMCk7XG5cblx0ICAgIGlmIChyb3dIZWlnaHQpIHtcblx0ICAgICAgdmFyIF9kZXAgPSBNYXRoLmNlaWwodCAvIHJvd0hlaWdodCk7XG5cblx0ICAgICAgdCAtPSBfZGVwICogcm93SGVpZ2h0O1xuXHQgICAgICB4ZW5kICs9IF9kZXA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3aGlsZSAodCA+IDAgJiYgeGVuZCA8IGVuZCkge1xuXHQgICAgICAgIHQgLT0gdGhpcy5fZ2V0SGVpZ2h0QnlJbmRleCh4ZW5kKTtcblx0ICAgICAgICB4ZW5kKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHhlbmQgPiBlbmQpIHhlbmQgPSBlbmQ7XG5cdCAgICByZXR1cm4gW3hpbmQsIHhlbmQsIHhkZWZdO1xuXHQgIH0sXG5cdCAgX3JlcGFpbnRfc2luZ2xlX3JvdzogZnVuY3Rpb24gKGlkKSB7XG5cdCAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG5cdCAgICB2YXIgcm93aW5kZXggPSB0aGlzLmdldEluZGV4QnlJZChpZCk7XG5cblx0ICAgIHZhciBzdGF0ZSA9IHRoaXMuX2dldF95X3JhbmdlKCk7XG5cblx0ICAgIHZhciBmcmVlemUgPSB0aGlzLmNvbmZpZy50b3BTcGxpdDtcblx0ICAgIHZhciBmcmVlemVDc3MgPSBcIlwiO1xuXG5cdCAgICBpZiAocm93aW5kZXggPj0gZnJlZXplKSB7XG5cdCAgICAgIC8vcm93IG5vdCB2aXNpYmxlXG5cdCAgICAgIGlmIChyb3dpbmRleCA8IHN0YXRlWzBdIHx8IHJvd2luZGV4ID49IHN0YXRlWzFdKSByZXR1cm47XG5cdCAgICAgIHJvd2luZGV4IC09IHN0YXRlWzBdIC0gZnJlZXplO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZnJlZXplQ3NzID0gcm93aW5kZXggPT0gZnJlZXplIC0gMSA/IFwiIHdlYml4X3RvcGNlbGwgd2ViaXhfbGFzdF90b3BjZWxsXCIgOiBcIiB3ZWJpeF90b3BjZWxsXCI7XG5cdCAgICB9IC8vZ2V0IHZpc2libGUgY29sdW1uXG5cblxuXHQgICAgdmFyIHhfcmFuZ2UgPSB0aGlzLl9nZXRfeF9yYW5nZSgpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuX2NvbHVtbnNbaV07IC8vY29sdW1uIG5vdCB2aXNpYmxlXG5cblx0ICAgICAgaWYgKGkgPCB0aGlzLl9yaWdodFNwbGl0ICYmIGkgPj0gdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0ICYmIChpIDwgeF9yYW5nZVswXSB8fCBpID4geF9yYW5nZVsxXSkpIGNvbHVtbi5feXIwID0gLTk5OTsgLy9lbnN1cmUgdGhhdCBjb2x1bW4gd2lsbCBub3QgYmUgcmV1c2VkXG5cblx0ICAgICAgaWYgKGNvbHVtbi5hdHRhY2hlZCAmJiBjb2x1bW4ubm9kZSkge1xuXHQgICAgICAgIHZhciBub2RlID0gY29sdW1uLm5vZGUuY2hpbGROb2Rlc1tyb3dpbmRleF07XG5cdCAgICAgICAgaWYgKCFub2RlKSBjb250aW51ZTtcblxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKGl0ZW0sIHRoaXMuX2NvbHVtbnNbaV0sIDApO1xuXG5cdCAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0ICAgICAgICBub2RlLmNsYXNzTmFtZSA9IHRoaXMuX2dldENzcyh0aGlzLl9jb2x1bW5zW2ldLCB2YWx1ZSwgaXRlbSwgaWQpICsgZnJlZXplQ3NzO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2hlY2tfcmVuZGVyZWRfY29sczogZnVuY3Rpb24gKHhfc2Nyb2xsLCBmb3JjZSkge1xuXHQgICAgaWYgKCF0aGlzLl9jb2x1bW5zLmxlbmd0aCkgcmV0dXJuO1xuXHQgICAgaWYgKGZvcmNlKSB0aGlzLl9jbGVhckNvbHVtbkNhY2hlKCk7XG5cblx0ICAgIHZhciB4ciA9IHRoaXMuX2dldF94X3JhbmdlKHRoaXMuX3NldHRpbmdzLnByZXJlbmRlcik7XG5cblx0ICAgIHZhciB5ciA9IHRoaXMuX2dldF95X3JhbmdlKHRoaXMuX3NldHRpbmdzLnByZXJlbmRlciA9PT0gdHJ1ZSk7XG5cblx0ICAgIGlmICh4X3Njcm9sbCkge1xuXHQgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0OyBpIDwgeHJbMF07IGkrKykge1xuXHQgICAgICAgIHRoaXMuX2hpZGVDb2x1bW4oaSwgZm9yY2UpO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgX2k2ID0geHJbMV07IF9pNiA8IHRoaXMuX3JpZ2h0U3BsaXQ7IF9pNisrKSB7XG5cdCAgICAgICAgdGhpcy5faGlkZUNvbHVtbihfaTYsIGZvcmNlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9yZW5kZXJfZnVsbF9yb3dzID0gW107XG5cblx0ICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHRoaXMuX3NldHRpbmdzLmxlZnRTcGxpdDsgX2k3KyspIHtcblx0ICAgICAgdGhpcy5fcmVuZGVyQ29sdW1uKF9pNywgeXIsIGZvcmNlKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgX2k4ID0geHJbMF07IF9pOCA8IHhyWzFdOyBfaTgrKykge1xuXHQgICAgICB0aGlzLl9yZW5kZXJDb2x1bW4oX2k4LCB5ciwgZm9yY2UsIF9pOCA9PSB4clswXSk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIF9pOSA9IHRoaXMuX3JpZ2h0U3BsaXQ7IF9pOSA8IHRoaXMuX2NvbHVtbnMubGVuZ3RoOyBfaTkrKykge1xuXHQgICAgICB0aGlzLl9yZW5kZXJDb2x1bW4oX2k5LCB5ciwgZm9yY2UpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9jaGVja19hbmRfcmVuZGVyX2Z1bGxfcm93cyh5clswXSwgeXJbMV0sIGZvcmNlKTtcblxuXHQgICAgdGhpcy5fY2hlY2tfbG9hZF9uZXh0KHlyKTtcblx0ICB9LFxuXHQgIF9kZWxldGVfZnVsbF9yb3dzOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuXHQgICAgdGhpcy5fcm93c19jYWNoZV9zdGFydCA9IHN0YXJ0O1xuXHQgICAgdGhpcy5fcm93c19jYWNoZV9lbmQgPSBlbmQ7XG5cdCAgICByZW1vdmUodGhpcy5fcm93c19jYWNoZSk7XG5cdCAgICB0aGlzLl9yb3dzX2NhY2hlID0gW107XG5cdCAgfSxcblx0ICBfYWRqdXN0X3Jvd3M6IGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5wcmVyZW5kZXIgJiYgdGhpcy5fcm93c19ib2R5KSB7XG5cdCAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKTtcblx0ICAgICAgdGhpcy5fcm93c19ib2R5LnN0eWxlLnRvcCA9IFwiLVwiICsgKHN0YXRlLnkgfHwgMCkgKyBcInB4XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2hlY2tfYW5kX3JlbmRlcl9mdWxsX3Jvd3M6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBmb3JjZSkge1xuXHQgICAgaWYgKHRoaXMuX3Jvd3NfYm9keSkgdGhpcy5fcm93c19ib2R5LnN0eWxlLnRvcCA9IHRoaXMuX3JlbmRlcl9zY3JvbGxfc2hpZnQgKyBcInB4XCI7XG5cblx0ICAgIGlmICghZm9yY2UgJiYgc3RhcnQgPT0gdGhpcy5fcm93c19jYWNoZV9zdGFydCAmJiBlbmQgPT0gdGhpcy5fcm93c19jYWNoZV9lbmQpIHtcblx0ICAgICAgaWYgKHRoaXMuY29uZmlnLnRvcFNwbGl0KSB7XG5cdCAgICAgICAgLy9kb24ndCBtb3ZlIHNwbGl0IHJvd3Ncblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JlbmRlcl9mdWxsX3Jvd3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciByb3cgPSB0aGlzLl9yb3dzX2NhY2hlW2ldO1xuXG5cdCAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyX2Z1bGxfcm93c1tpXS5pbmRleCA8IHRoaXMuY29uZmlnLnRvcFNwbGl0KSB7XG5cdCAgICAgICAgICAgIHJvdy5zdHlsZS50b3AgPSB0aGlzLl9yZW5kZXJfZnVsbF9yb3dzW2ldLnRvcCAtIHRoaXMuX3JlbmRlcl9zY3JvbGxfc2hpZnQgKyBcInB4XCI7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9kZWxldGVfZnVsbF9yb3dzKHN0YXJ0LCBlbmQpO1xuXG5cdCAgICBpZiAodGhpcy5fcmVuZGVyX2Z1bGxfcm93X3NvbWUpIHRoaXMuX3JlbmRlcl9mdWxsX3Jvd19zb21lID0gZmFsc2U7ZWxzZSByZXR1cm47XG5cblx0ICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgdGhpcy5fcmVuZGVyX2Z1bGxfcm93cy5sZW5ndGg7IF9pMTArKykge1xuXHQgICAgICB2YXIgaW5mbyA9IHRoaXMuX3JlbmRlcl9mdWxsX3Jvd3NbX2kxMF07XG5cdCAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGluZm8uaWQpO1xuXHQgICAgICB2YXIgdmFsdWU7XG5cblx0ICAgICAgaWYgKHR5cGVvZiBpdGVtLiRyb3cgPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBpdGVtLiRyb3cuY2FsbCh0aGlzLCBpdGVtLCB0aGlzLnR5cGUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoaXRlbSwgdGhpcy5nZXRDb2x1bW5Db25maWcoaXRlbS4kcm93KSwgX2kxMCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgX3JvdyA9IHRoaXMuX3Jvd3NfY2FjaGVbX2kxMF0gPSBjcmVhdGUoXCJESVZcIiwgbnVsbCwgdmFsdWUpO1xuXG5cdCAgICAgIF9yb3cuY2xhc3NOYW1lID0gXCJ3ZWJpeF9jZWxsIFwiICsgKGl0ZW0uJHN1YiA/IFwid2ViaXhfZHRhYmxlX3N1YlwiICsgKHRoaXMuX3NldHRpbmdzLnN1YnZpZXcgPyBcInZpZXdcIiA6IFwicm93XCIpIDogXCJ3ZWJpeF9kdGFibGVfY29scm93XCIgKyAoaXRlbS4kcm93ID8gXCIgd2ViaXhfdG9wY2VsbFwiICsgKHRoaXMuZGF0YS5nZXRNYXJrKGl0ZW0uaWQsIFwid2ViaXhfc2VsZWN0ZWRcIikgPyBcIiB3ZWJpeF9zZWxlY3RlZFwiIDogXCJcIikgOiBcIlwiKSk7XG5cblx0ICAgICAgX3Jvdy5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5cIiwgMCk7XG5cblx0ICAgICAgX3Jvdy5zZXRBdHRyaWJ1dGUoXCJyb3dcIiwgaW5mby5pbmRleCk7XG5cblx0ICAgICAgdmFyIGhlaWdodCA9IGl0ZW0uJGhlaWdodCB8fCB0aGlzLl9zZXR0aW5ncy5yb3dIZWlnaHQ7XG5cdCAgICAgIGlmIChpdGVtLiRzdWJvcGVuKSBfcm93LnN0eWxlLmhlaWdodCA9IGl0ZW0uJHN1YkhlaWdodCArIFwicHhcIjtlbHNlIF9yb3cuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuXHQgICAgICBfcm93LnN0eWxlLnBhZGRpbmdSaWdodCA9IGVudi5zY3JvbGxTaXplICsgXCJweFwiO1xuXHQgICAgICB2YXIgdG9wRGVsdGEgPSB0aGlzLl9yZW5kZXJfZnVsbF9yb3dzW19pMTBdLmluZGV4IDwgdGhpcy5jb25maWcudG9wU3BsaXQgPyAtdGhpcy5fcmVuZGVyX3Njcm9sbF9zaGlmdCA6IDA7XG5cdCAgICAgIF9yb3cuc3R5bGUudG9wID0gdG9wRGVsdGEgKyBpbmZvLnRvcCArIChpdGVtLiRzdWJvcGVuID8gaGVpZ2h0IC0gMSA6IDApICsgXCJweFwiO1xuXG5cdCAgICAgIGlmICghdGhpcy5fcm93c19ib2R5KSB7XG5cdCAgICAgICAgdGhpcy5fcm93c19ib2R5ID0gY3JlYXRlKFwiRElWXCIpO1xuXHQgICAgICAgIHRoaXMuX3Jvd3NfYm9keS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0ICAgICAgICB0aGlzLl9yb3dzX2JvZHkuc3R5bGUudG9wID0gdGhpcy5fcmVuZGVyX3Njcm9sbF9zaGlmdCArIFwicHhcIjtcblxuXHQgICAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQodGhpcy5fcm93c19ib2R5KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX3Jvd3NfYm9keS5hcHBlbmRDaGlsZChfcm93KTtcblxuXHQgICAgICB0aGlzLmF0dGFjaEV2ZW50KFwib25TeW5jU2Nyb2xsXCIsIGZ1bmN0aW9uICh4LCB5LCB0KSB7XG5cdCAgICAgICAgVG91Y2guX3NldF9tYXRyaXgodGhpcy5fcm93c19ib2R5LCAwLCB5LCB0KTtcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zdWJ2aWV3KSB0aGlzLmNhbGxFdmVudChcIm9uU3ViVmlld1JlbmRlclwiLCBbaXRlbSwgX3Jvd10pO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX2NoZWNrX2xvYWRfbmV4dDogZnVuY3Rpb24gKHlyKSB7XG5cdCAgICB2YXIgcGFnaW5nID0gdGhpcy5fc2V0dGluZ3MucGFnZXI7XG5cdCAgICB2YXIgZmV0Y2ggPSB0aGlzLl9zZXR0aW5ncy5kYXRhZmV0Y2g7XG5cdCAgICB2YXIgZGlyZWN0aW9uID0gIXRoaXMuX2xhc3RfdmFsaWRfcmVuZGVyX3BvcyB8fCB5clswXSA+PSB0aGlzLl9sYXN0X3ZhbGlkX3JlbmRlcl9wb3M7XG5cdCAgICB0aGlzLl9sYXN0X3ZhbGlkX3JlbmRlcl9wb3MgPSB5clswXTtcblxuXHQgICAgaWYgKHRoaXMuX2RhdGFfcmVxdWVzdF9mbGFnKSB7XG5cdCAgICAgIGlmIChwYWdpbmcgJiYgKCFmZXRjaCB8fCBmZXRjaCA+PSBwYWdpbmcuc2l6ZSkpIGlmICh0aGlzLl9jaGVja19yb3dzKFswLCBwYWdpbmcuc2l6ZSAqIHBhZ2luZy5wYWdlXSwgTWF0aC5tYXgoZmV0Y2gsIHBhZ2luZy5zaXplKSwgdHJ1ZSkpIHJldHVybiB0aGlzLl9kYXRhX3JlcXVlc3RfZmxhZyA9IG51bGw7XG5cblx0ICAgICAgdGhpcy5fcnVuX2xvYWRfbmV4dCh0aGlzLl9kYXRhX3JlcXVlc3RfZmxhZywgZGlyZWN0aW9uKTtcblxuXHQgICAgICB0aGlzLl9kYXRhX3JlcXVlc3RfZmxhZyA9IG51bGw7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubG9hZGFoZWFkKSB0aGlzLl9jaGVja19yb3dzKHlyLCB0aGlzLl9zZXR0aW5ncy5sb2FkYWhlYWQsIGRpcmVjdGlvbik7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2hlY2tfcm93czogZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBkaXIpIHtcblx0ICAgIHZhciBzdGFydCA9IHZpZXdbMV07XG5cdCAgICB2YXIgZW5kID0gc3RhcnQgKyBjb3VudDtcblxuXHQgICAgaWYgKCFkaXIpIHtcblx0ICAgICAgc3RhcnQgPSB2aWV3WzBdIC0gY291bnQ7XG5cdCAgICAgIGVuZCA9IHZpZXdbMF07XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcblx0ICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy5kYXRhLm9yZGVyLmxlbmd0aCAtIDEpO1xuXHQgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHQgICAgICBpZiAoIXRoaXMuZGF0YS5vcmRlcltpXSkge1xuXHQgICAgICAgIGlmICghcmVzdWx0KSByZXN1bHQgPSB7XG5cdCAgICAgICAgICBzdGFydDogaSxcblx0ICAgICAgICAgIGNvdW50OiBlbmQgLSBzdGFydFxuXHQgICAgICAgIH07ZWxzZSB7XG5cdCAgICAgICAgICByZXN1bHQubGFzdCA9IGk7XG5cdCAgICAgICAgICByZXN1bHQuY291bnQgPSBpIC0gc3RhcnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgdGhpcy5fcnVuX2xvYWRfbmV4dChyZXN1bHQsIGRpcik7XG5cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfcnVuX2xvYWRfbmV4dDogZnVuY3Rpb24gKGNvbmYsIGRpcmVjdGlvbikge1xuXHQgICAgdmFyIGNvdW50ID0gTWF0aC5tYXgoY29uZi5jb3VudCwgdGhpcy5fc2V0dGluZ3MuZGF0YWZldGNoIHx8IHRoaXMuX3NldHRpbmdzLmxvYWRhaGVhZCB8fCAwKTtcblx0ICAgIHZhciBzdGFydCA9IGRpcmVjdGlvbiA/IGNvbmYuc3RhcnQgOiBjb25mLmxhc3QgLSBjb3VudCArIDE7XG5cdCAgICBpZiAodGhpcy5fbWF5YmVfbG9hZGluZ19hbHJlYWR5KGNvbmYuY291bnQsIGNvbmYuc3RhcnQpKSByZXR1cm47XG5cdCAgICB0aGlzLmxvYWROZXh0KGNvdW50LCBzdGFydCk7XG5cdCAgfSxcblx0ICAvLyBuZWNlc3NhcnkgZm9yIHNhZmFyaSBvbmx5XG5cdCAgX3ByZXNlcnZlU2Nyb2xsVGFyZ2V0OiBmdW5jdGlvbiAoY29sdW1uTm9kZSkge1xuXHQgICAgaWYgKGVudi5pc1NhZmFyaSkge1xuXHQgICAgICB2YXIgaSxcblx0ICAgICAgICAgIG5vZGUsXG5cdCAgICAgICAgICBuZXdOb2RlLFxuXHQgICAgICAgICAgc2Nyb2xsLFxuXHQgICAgICAgICAgZGlyID0gW3RoaXMuX3hfc2Nyb2xsLCB0aGlzLl95X3Njcm9sbF07XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IDI7IGkrKykge1xuXHQgICAgICAgIHNjcm9sbCA9IGRpcltpXTtcblxuXHQgICAgICAgIGlmIChzY3JvbGwgJiYgc2Nyb2xsLl9zY3JvbGxfdHJnICYmIHNjcm9sbC5fc2Nyb2xsX3RyZy5wYXJlbnROb2RlID09IGNvbHVtbk5vZGUpIHtcblx0ICAgICAgICAgIG5vZGUgPSBzY3JvbGwuX3Njcm9sbF90cmc7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fc2Nyb2xsV2hlZWxUcmcpIHJlbW92ZSh0aGlzLl9zY3JvbGxXaGVlbFRyZyk7XG5cdCAgICAgICAgdGhpcy5fc2Nyb2xsV2hlZWxUcmcgPSBub2RlO1xuXHQgICAgICAgIG5ld05vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKTsgLy8gcmVxdWlyZWQgZm9yIF9oaWRlQ29sdW1uXG5cblx0ICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIG5vZGUpO1xuXHQgICAgICAgIHRoaXMuX3Njcm9sbFdoZWVsVHJnLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuXHQgICAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQodGhpcy5fc2Nyb2xsV2hlZWxUcmcpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfaGlkZUNvbHVtbjogZnVuY3Rpb24gKGluZGV4JCQxKSB7XG5cdCAgICB2YXIgY29sID0gdGhpcy5fY29sdW1uc1tpbmRleCQkMV07IC8vIHByZXNlcnZlIHRhcmdldCBub2RlIGZvciBTYWZhcmkgd2hlZWwgZXZlbnRcblxuXHQgICAgdGhpcy5fcHJlc2VydmVTY3JvbGxUYXJnZXQoY29sLm5vZGUpO1xuXG5cdCAgICByZW1vdmUoY29sLm5vZGUpO1xuXHQgICAgY29sLmF0dGFjaGVkID0gZmFsc2U7XG5cdCAgfSxcblx0ICBfY2xlYXJDb2x1bW5DYWNoZTogZnVuY3Rpb24gKCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX2NvbHVtbnNbaV0uX3lyMCA9IC0xO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fcm93c19jYWNoZS5sZW5ndGgpIHtcblx0ICAgICAgcmVtb3ZlKHRoaXMuX3Jvd3NfY2FjaGUpO1xuXHQgICAgICB0aGlzLl9yb3dzX2NhY2hlID0gW107XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRUZXh0OiBmdW5jdGlvbiAocm93X2lkLCBjb2x1bW5faWQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSh0aGlzLmdldEl0ZW0ocm93X2lkKSwgdGhpcy5nZXRDb2x1bW5Db25maWcoY29sdW1uX2lkKSwgMCk7XG5cdCAgfSxcblx0ICBnZXRDc3M6IGZ1bmN0aW9uIChyb3dfaWQsIGNvbHVtbl9pZCkge1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0ocm93X2lkKTtcblx0ICAgIHJldHVybiB0aGlzLl9nZXRDc3ModGhpcy5nZXRDb2x1bW5Db25maWcoY29sdW1uX2lkKSwgaXRlbVtjb2x1bW5faWRdLCBpdGVtLCByb3dfaWQpO1xuXHQgIH0sXG5cdCAgX2dldENzczogZnVuY3Rpb24gKGNvbmZpZywgdmFsdWUsIGl0ZW0sIGlkKSB7XG5cdCAgICB2YXIgY3NzID0gXCJ3ZWJpeF9jZWxsXCI7XG5cblx0ICAgIGlmIChjb25maWcuY3NzRm9ybWF0KSB7XG5cdCAgICAgIHZhciBwZXJfY3NzID0gY29uZmlnLmNzc0Zvcm1hdCh2YWx1ZSwgaXRlbSwgaWQsIGNvbmZpZy5pZCk7XG5cblx0ICAgICAgaWYgKHBlcl9jc3MpIHtcblx0ICAgICAgICBpZiAoX3R5cGVvZihwZXJfY3NzKSA9PSBcIm9iamVjdFwiKSBjc3MgKz0gXCIgXCIgKyBjcmVhdGVDc3MocGVyX2Nzcyk7ZWxzZSBjc3MgKz0gXCIgXCIgKyBwZXJfY3NzO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciByb3dfY3NzID0gaXRlbS4kY3NzO1xuXG5cdCAgICBpZiAocm93X2Nzcykge1xuXHQgICAgICBpZiAoX3R5cGVvZihyb3dfY3NzKSA9PSBcIm9iamVjdFwiKSBpdGVtLiRjc3MgPSByb3dfY3NzID0gY3JlYXRlQ3NzKHJvd19jc3MpO1xuXHQgICAgICBjc3MgKz0gXCIgXCIgKyByb3dfY3NzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbWFyayA9IHRoaXMuZGF0YS5fbWFya3NbaWRdO1xuXG5cdCAgICBpZiAobWFyaykge1xuXHQgICAgICBpZiAobWFyay4kY3NzKSBjc3MgKz0gXCIgXCIgKyBtYXJrLiRjc3M7XG5cblx0ICAgICAgaWYgKG1hcmsuJGNlbGxDc3MpIHtcblx0ICAgICAgICB2YXIgbWFya19tYXJrZXIgPSBtYXJrLiRjZWxsQ3NzW2NvbmZpZy5pZF07XG5cdCAgICAgICAgaWYgKG1hcmtfbWFya2VyKSBjc3MgKz0gXCIgXCIgKyBtYXJrX21hcmtlcjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoaXRlbS4kY2VsbENzcykge1xuXHQgICAgICB2YXIgY3NzX21hcmtlciA9IGl0ZW0uJGNlbGxDc3NbY29uZmlnLmlkXTtcblxuXHQgICAgICBpZiAoY3NzX21hcmtlcikge1xuXHQgICAgICAgIGlmIChfdHlwZW9mKGNzc19tYXJrZXIpID09IFwib2JqZWN0XCIpIGNzc19tYXJrZXIgPSBjcmVhdGVDc3MoY3NzX21hcmtlcik7XG5cdCAgICAgICAgY3NzICs9IFwiIFwiICsgY3NzX21hcmtlcjtcblx0ICAgICAgfVxuXHQgICAgfSAvL2NlbGwtc2VsZWN0aW9uXG5cblxuXHQgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5kYXRhLmdldE1hcmsoaXRlbS5pZCwgXCJ3ZWJpeF9zZWxlY3RlZFwiKTtcblx0ICAgIGlmIChzZWxlY3RlZCAmJiAoc2VsZWN0ZWQuJHJvdyB8fCBzZWxlY3RlZFtjb25maWcuaWRdKSB8fCBjb25maWcuJHNlbGVjdGVkKSBjc3MgKz0gdGhpcy5fc2VsZWN0X2Nzcztcblx0ICAgIHJldHVybiBjc3M7XG5cdCAgfSxcblx0ICBfZ2V0VmFsdWU6IGZ1bmN0aW9uIChpdGVtLCBjb25maWcsIGkpIHtcblx0ICAgIGlmICghaXRlbSkgcmV0dXJuIFwiXCI7XG5cdCAgICB2YXIgdmFsdWU7XG5cdCAgICB2YWx1ZSA9IGl0ZW1bY29uZmlnLmlkXTtcblx0ICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB2YWx1ZSA9IFwiXCI7XG5cdCAgICBpZiAoY29uZmlnLmZvcm1hdCkgdmFsdWUgPSBjb25maWcuZm9ybWF0KHZhbHVlKTtcblx0ICAgIGlmIChjb25maWcudGVtcGxhdGUpIHZhbHVlID0gY29uZmlnLnRlbXBsYXRlKGl0ZW0sIHRoaXMudHlwZSwgdmFsdWUsIGNvbmZpZywgaSk7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfSxcblx0ICAvL3dlIGRvbid0IHVzZSByZW5kZXItc3RhY2ssIGJ1dCBzdGlsbCBuZWVkIGEgcGxhY2UgZm9yIGNvbW1vbiBoZWxwZXJzXG5cdCAgLy9zbyBjcmVhdGluZyBhIHNpbXBsZSBcInR5cGVcIiBob2xkZXJcblx0ICB0eXBlOiB7XG5cdCAgICBjaGVja2JveDogZnVuY3Rpb24gKG9iaiwgY29tbW9uLCB2YWx1ZSwgY29uZmlnKSB7XG5cdCAgICAgIHZhciBjaGVja2VkID0gdmFsdWUgPT0gY29uZmlnLmNoZWNrVmFsdWUgPyBcImNoZWNrZWQ9XFxcInRydWVcXFwiXCIgOiBcIlwiO1xuXHQgICAgICByZXR1cm4gXCI8aW5wdXQgY2xhc3M9J3dlYml4X3RhYmxlX2NoZWNrYm94JyB0eXBlPSdjaGVja2JveCcgXCIgKyBjaGVja2VkICsgXCI+XCI7XG5cdCAgICB9LFxuXHQgICAgcmFkaW86IGZ1bmN0aW9uIChvYmosIGNvbW1vbiwgdmFsdWUsIGNvbmZpZykge1xuXHQgICAgICB2YXIgY2hlY2tlZCA9IHZhbHVlID09IGNvbmZpZy5jaGVja1ZhbHVlID8gXCJjaGVja2VkPVxcXCJ0cnVlXFxcIlwiIDogXCJcIjtcblx0ICAgICAgcmV0dXJuIFwiPGlucHV0IGNsYXNzPSd3ZWJpeF90YWJsZV9yYWRpbycgdHlwZT0ncmFkaW8nIFwiICsgY2hlY2tlZCArIFwiPlwiO1xuXHQgICAgfSxcblx0ICAgIGVkaXRJY29uOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPSd3ZWJpeF9pY29uIHd4aS1wZW5jaWwnPjwvc3Bhbj5cIjtcblx0ICAgIH0sXG5cdCAgICB0cmFzaEljb246IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9J3dlYml4X2ljb24gd3hpLXRyYXNoJz48L3NwYW4+XCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICB0eXBlX3NldHRlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICBpZiAoIXRoaXMudHlwZXMgfHwgIXRoaXMudHlwZXNbdmFsdWVdKSB0eXBlKHRoaXMsIHZhbHVlKTtlbHNlIHtcblx0ICAgICAgdGhpcy50eXBlID0gY2xvbmUodGhpcy50eXBlc1t2YWx1ZV0pO1xuXHQgICAgICBpZiAodGhpcy50eXBlLmNzcykgdGhpcy5fY29udGVudG9iai5jbGFzc05hbWUgKz0gXCIgXCIgKyB0aGlzLnR5cGUuY3NzO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMudHlwZS5vbl9jbGljaykgZXhwb3J0cy5leHRlbmQodGhpcy5vbl9jbGljaywgdGhpcy50eXBlLm9uX2NsaWNrKTtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9LFxuXHQgIF9yZW5kZXJDb2x1bW46IGZ1bmN0aW9uIChpbmRleCQkMSwgeXIsIGZvcmNlLCBzaW5nbGUkJDEpIHtcblx0ICAgIHZhciBjb2wgPSB0aGlzLl9jb2x1bW5zW2luZGV4JCQxXTtcblxuXHQgICAgaWYgKCFjb2wuYXR0YWNoZWQpIHtcblx0ICAgICAgdmFyIHNwbGl0X2NvbHVtbiA9IGluZGV4JCQxIDwgdGhpcy5fc2V0dGluZ3MubGVmdFNwbGl0ID8gMCA6IGluZGV4JCQxID49IHRoaXMuX3JpZ2h0U3BsaXQgPyAyIDogMTtcblxuXHQgICAgICB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbc3BsaXRfY29sdW1uXS5maXJzdENoaWxkLmFwcGVuZENoaWxkKGNvbC5ub2RlKTtcblxuXHQgICAgICBjb2wuYXR0YWNoZWQgPSB0cnVlO1xuXHQgICAgICBjb2wuc3BsaXQgPSBzcGxpdF9jb2x1bW47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX3JlbmRlcl9zY3JvbGxfdG9wID0geXJbMF07XG5cdCAgICB0aGlzLl9yZW5kZXJfc2Nyb2xsX3NoaWZ0ID0gMDtcblx0ICAgIHRoaXMuX3JlbmRlcl9zY3JvbGxfZGlmZiA9IHlyWzJdOyAvL2lmIGNvbHVtbnMgbm90IGFsaWduZWQgZHVyaW5nIHNjcm9sbCAtIHNldCBjb3JyZWN0IHNjcm9sbCB0b3AgdmFsdWUgZm9yIGVhY2ggY29sdW1uXG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5zY3JvbGxBbGlnblkpIHtcblx0ICAgICAgaWYgKHlyWzFdID09IHRoaXMuZGF0YS5vcmRlci5sZW5ndGggfHwgdGhpcy5kYXRhLiRwYWdlc2l6ZSAmJiB5clsxXSAlIHRoaXMuZGF0YS4kcGFnZXNpemUgPT09IDApIHtcblx0ICAgICAgICBjb2wubm9kZS5zdHlsZS50b3AgPSAodGhpcy5fcmVuZGVyX3Njcm9sbF9zaGlmdCA9IHlyWzJdKSArIFwicHhcIjtcblx0ICAgICAgfSBlbHNlIGlmIChjb2wuX3lyMikgY29sLm5vZGUuc3R5bGUudG9wID0gXCIwcHhcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3JlbmRlcl9zY3JvbGxfc2hpZnQgPSB5clsyXTtcblx0ICAgICAgY29sLm5vZGUuc3R5bGUudG9wID0geXJbMl0gKyBcInB4XCI7XG5cdCAgICB9XG5cblx0ICAgIGlmICghZm9yY2UgJiYgY29sLl95cjAgPT0geXJbMF0gJiYgY29sLl95cjEgPT0geXJbMV0gJiYgKCF0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCB8fCBjb2wuX3JlbmRlcl9zY3JvbGxfc2hpZnQgPT0gdGhpcy5fcmVuZGVyX3Njcm9sbF9zaGlmdCkpIHJldHVybiAwO1xuXHQgICAgdmFyIGh0bWwgPSBcIlwiO1xuXHQgICAgdmFyIGNvbmZpZyA9IHRoaXMuX3NldHRpbmdzLmNvbHVtbnNbaW5kZXgkJDFdO1xuXHQgICAgdmFyIHN0YXRlID0ge1xuXHQgICAgICByb3c6IHRoaXMuX3NldHRpbmdzLnJvd0hlaWdodCxcblx0ICAgICAgdG90YWw6IDAsXG5cdCAgICAgIHNpbmdsZTogc2luZ2xlJCQxXG5cdCAgICB9O1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0OyBpKyspIHtcblx0ICAgICAgaHRtbCArPSB0aGlzLl9yZW5kZXJfc2luZ2xlX2NlbGwoaSwgY29uZmlnLCB5ciwgc3RhdGUsIC10aGlzLl9yZW5kZXJfc2Nyb2xsX3NoaWZ0LCBpbmRleCQkMSk7XG5cdCAgICB9IC8vIGlnbm9yZSBub3QgYXZhaWxhYmxlIHJvd3MgaW4gdG9wLXNwbGl0IGFyZWFcblxuXG5cdCAgICB0aGlzLl9kYXRhX3JlcXVlc3RfZmxhZyA9IG51bGw7XG5cblx0ICAgIGZvciAodmFyIF9pMTEgPSBNYXRoLm1heCh5clswXSwgdGhpcy5fc2V0dGluZ3MudG9wU3BsaXQpOyBfaTExIDwgeXJbMV07IF9pMTErKykge1xuXHQgICAgICBodG1sICs9IHRoaXMuX3JlbmRlcl9zaW5nbGVfY2VsbChfaTExLCBjb25maWcsIHlyLCBzdGF0ZSwgLTEsIGluZGV4JCQxKTtcblx0ICAgIH0gLy8gcHJlc2VydmUgdGFyZ2V0IG5vZGUgZm9yIFNhZmFyaSB3aGVlbCBldmVudFxuXG5cblx0ICAgIHRoaXMuX3ByZXNlcnZlU2Nyb2xsVGFyZ2V0KGNvbC5ub2RlKTtcblxuXHQgICAgY29sLm5vZGUuaW5uZXJIVE1MID0gaHRtbDtcblx0ICAgIGNvbC5feXIwID0geXJbMF07XG5cdCAgICBjb2wuX3lyMSA9IHlyWzFdO1xuXHQgICAgY29sLl95cjIgPSB5clsyXTtcblx0ICAgIGNvbC5fcmVuZGVyX3Njcm9sbF9zaGlmdCA9IHRoaXMuX3JlbmRlcl9zY3JvbGxfc2hpZnQ7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9LFxuXHQgIF9yZW5kZXJfc2luZ2xlX2NlbGw6IGZ1bmN0aW9uIChpLCBjb25maWcsIHlyLCBzdGF0ZSwgdG9wLCBpbmRleCQkMSkge1xuXHQgICAgdmFyIGlkID0gdGhpcy5kYXRhLm9yZGVyW2ldO1xuXHQgICAgdmFyIGl0ZW0gPSB0aGlzLmRhdGEuZ2V0SXRlbShpZCk7XG5cdCAgICB2YXIgaHRtbCA9IFwiXCI7XG5cblx0ICAgIGlmIChpdGVtKSB7XG5cdCAgICAgIHZhciBhcmlhID0gXCIgcm9sZT0nZ3JpZGNlbGwnIGFyaWEtcm93aW5kZXg9J1wiICsgKGkgKyAxKSArIFwiJyBhcmlhLWNvbGluZGV4PSdcIiArICh0aGlzLmdldENvbHVtbkluZGV4KGNvbmZpZy5pZCkgKyAxKSArIFwiJ1wiICsgKGl0ZW0uJGNvdW50IHx8IGl0ZW0uJHN1YiA/IFwiIGFyaWEtZXhwYW5kZWQ9J1wiICsgKGl0ZW0ub3BlbiB8fCBpdGVtLiRzdWJvcGVuID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpICsgXCInXCIgOiBcIlwiKSArIChpdGVtLiRsZXZlbCA/IFwiIGFyaWEtbGV2ZWw9J1wiICsgaXRlbS4kbGV2ZWwgKyBcIidcIiA6IFwiXCIpO1xuXG5cdCAgICAgIGlmIChzdGF0ZS5zaW5nbGUgJiYgaXRlbS4kcm93KSB7XG5cdCAgICAgICAgdGhpcy5fcmVuZGVyX2Z1bGxfcm93X3NvbWUgPSB0cnVlO1xuXG5cdCAgICAgICAgdGhpcy5fcmVuZGVyX2Z1bGxfcm93cy5wdXNoKHtcblx0ICAgICAgICAgIHRvcDogc3RhdGUudG90YWwsXG5cdCAgICAgICAgICBpZDogaXRlbS5pZCxcblx0ICAgICAgICAgIGluZGV4OiBpXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoIWl0ZW0uJHN1Yikge1xuXHQgICAgICAgICAgdmFyIHJvd0hlaWdodCA9IGl0ZW0uJGhlaWdodCB8fCBzdGF0ZS5yb3c7XG5cdCAgICAgICAgICBzdGF0ZS50b3RhbCArPSByb3dIZWlnaHQ7XG5cdCAgICAgICAgICByZXR1cm4gXCI8ZGl2XCIgKyBhcmlhICsgXCIgY2xhc3M9J3dlYml4X2NlbGwnIHN0eWxlPSdoZWlnaHQ6XCIgKyByb3dIZWlnaHQgKyBcInB4Oyc+PC9kaXY+XCI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoaXRlbSwgY29uZmlnLCBpKTtcblxuXHQgICAgICB2YXIgY3NzID0gdGhpcy5fZ2V0Q3NzKGNvbmZpZywgdmFsdWUsIGl0ZW0sIGlkKTtcblxuXHQgICAgICB2YXIgYXJpYVNlbGVjdCA9IFwiIGFyaWEtc2VsZWN0ZWQ9J3RydWUnIHRhYmluZGV4PScwJ1wiO1xuXG5cdCAgICAgIGlmIChjc3MuaW5kZXhPZihcInNlbGVjdFwiKSAhPT0gLTEpIHtcblx0ICAgICAgICAvL2luIGNhc2Ugb2Ygcm93L2NvbHVtbiBzZWxlY3Rpb24gLSBtYWtlIG9ubHkgZmlyc3QgY2VsbCBmb2N1c2FibGVcblx0ICAgICAgICBpZiAoY3NzLmluZGV4T2YoXCJyb3dcIikgIT09IC0xKSB7XG5cdCAgICAgICAgICB2YXIgeHIgPSB0aGlzLl9nZXRfeF9yYW5nZSgpO1xuXG5cdCAgICAgICAgICBpZiAoeHJbMF0gPT09IGluZGV4JCQxKSBhcmlhICs9IGFyaWFTZWxlY3Q7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjc3MuaW5kZXhPZihcImNvbFwiKSAhPT0gLTEpIHtcblx0ICAgICAgICAgIGlmIChpID09PSB5clswXSkgYXJpYSArPSBhcmlhU2VsZWN0O1xuXHQgICAgICAgIH0gZWxzZSBhcmlhICs9IGFyaWFTZWxlY3Q7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaXNPcGVuID0gISFpdGVtLiRzdWJvcGVuO1xuXHQgICAgICB2YXIgbWFyZ2luID0gaXNPcGVuID8gXCJtYXJnaW4tYm90dG9tOlwiICsgaXRlbS4kc3ViSGVpZ2h0ICsgXCJweDtcIiA6IFwiXCI7XG5cblx0ICAgICAgaWYgKHRvcCA+PSAwKSB7XG5cdCAgICAgICAgaWYgKHRvcCA+IDApIG1hcmdpbiArPSBcInRvcDpcIiArIHRvcCArIFwicHg7J1wiO1xuXHQgICAgICAgIGNzcyA9IFwid2ViaXhfdG9wY2VsbCBcIiArIGNzcztcblx0ICAgICAgICBpZiAoaSA9PSB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCAtIDEpIGNzcyA9IFwid2ViaXhfbGFzdF90b3BjZWxsIFwiICsgY3NzO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGl0ZW0uJGhlaWdodCkge1xuXHQgICAgICAgIGh0bWwgPSBcIjxkaXZcIiArIGFyaWEgKyBcIiBjbGFzcz0nXCIgKyBjc3MgKyBcIicgc3R5bGU9J2hlaWdodDpcIiArIGl0ZW0uJGhlaWdodCArIFwicHg7XCIgKyBtYXJnaW4gKyBcIic+XCIgKyB2YWx1ZSArIFwiPC9kaXY+XCI7XG5cdCAgICAgICAgc3RhdGUudG90YWwgKz0gaXRlbS4kaGVpZ2h0IC0gc3RhdGUucm93O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGh0bWwgPSBcIjxkaXZcIiArIGFyaWEgKyBcIiBjbGFzcz0nXCIgKyBjc3MgKyBcIidcIiArIChtYXJnaW4gPyBcIiBzdHlsZT0nXCIgKyBtYXJnaW4gKyBcIidcIiA6IFwiXCIpICsgXCI+XCIgKyB2YWx1ZSArIFwiPC9kaXY+XCI7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaXNPcGVuKSBzdGF0ZS50b3RhbCArPSBpdGVtLiRzdWJIZWlnaHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBodG1sID0gXCI8ZGl2IHJvbGU9J2dyaWRjZWxsJyBjbGFzcz0nd2ViaXhfY2VsbCc+PC9kaXY+XCI7XG5cdCAgICAgIGlmICghdGhpcy5fZGF0YV9yZXF1ZXN0X2ZsYWcpIHRoaXMuX2RhdGFfcmVxdWVzdF9mbGFnID0ge1xuXHQgICAgICAgIHN0YXJ0OiBpLFxuXHQgICAgICAgIGNvdW50OiB5clsxXSAtIGlcblx0ICAgICAgfTtlbHNlIHRoaXMuX2RhdGFfcmVxdWVzdF9mbGFnLmxhc3QgPSBpO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS50b3RhbCArPSBzdGF0ZS5yb3c7XG5cdCAgICByZXR1cm4gaHRtbDtcblx0ICB9LFxuXHQgIF9zZXRfc3BsaXRfc2l6ZXNfeTogZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCF0aGlzLl9jb2x1bW5zLmxlbmd0aCB8fCBpc05hTih0aGlzLl9jb250ZW50X2hlaWdodCAqIDEpKSByZXR1cm47XG5cdCAgICBkZWJ1Z19zaXplX2JveCh0aGlzLCBbXCJ5LXNpemluZ1wiXSwgdHJ1ZSk7XG5cdCAgICB2YXIgd2FudGVkX2hlaWdodCA9IHRoaXMuX2R0YWJsZV9oZWlnaHQgKyAodGhpcy5fc2Nyb2xsU2l6ZVggPyB0aGlzLl9zY3JvbGxTaXplWCA6IDApO1xuXHQgICAgaWYgKCh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0IHx8IHRoaXMuX3NldHRpbmdzLnlDb3VudCkgJiYgdGhpcy5yZXNpemUoKSkgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl95X3Njcm9sbC5zaXplVG8odGhpcy5fY29udGVudF9oZWlnaHQsIHRoaXMuX2hlYWRlcl9oZWlnaHQsIHRoaXMuX2Zvb3Rlcl9oZWlnaHQpO1xuXG5cdCAgICB0aGlzLl95X3Njcm9sbC5kZWZpbmUoXCJzY3JvbGxIZWlnaHRcIiwgd2FudGVkX2hlaWdodCk7XG5cblx0ICAgIHRoaXMuX3RvcF9zcGxpdF9oZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCA/IHRoaXMuX2dldEhlaWdodEJ5SW5kZXhTdW1tKDAsIHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0KSA6IDA7XG5cdCAgICB0aGlzLl9kdGFibGVfb2Zmc2V0X2hlaWdodCA9IE1hdGgubWF4KDAsIHRoaXMuX2NvbnRlbnRfaGVpZ2h0IC0gdGhpcy5fc2Nyb2xsU2l6ZVggLSB0aGlzLl9oZWFkZXJfaGVpZ2h0IC0gdGhpcy5fZm9vdGVyX2hlaWdodCk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1tpXS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9kdGFibGVfb2Zmc2V0X2hlaWdodCArIFwicHhcIjtcblx0ICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnByZXJlbmRlcikgdGhpcy5fYm9keS5jaGlsZE5vZGVzW2ldLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZHRhYmxlX2hlaWdodCArIFwicHhcIjtlbHNlIHRoaXMuX2JvZHkuY2hpbGROb2Rlc1tpXS5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IHRoaXMuX2R0YWJsZV9vZmZzZXRfaGVpZ2h0ICsgXCJweFwiO1xuXHQgICAgfSAvL3ByZXZlbnQgZmxvYXQgb3ZlcmZsb3csIHdoZW4gd2UgaGF2ZSBzcGxpdCBhbmQgdmVyeSBzbWFsbFxuXG5cblx0ICAgIHRoaXMuX2hlYWRlci5zdHlsZS5oZWlnaHQgPSB0aGlzLl9oZWFkZXJfaGVpZ2h0ICsgXCJweFwiO1xuXHQgIH0sXG5cdCAgX3NldF9zcGxpdF9zaXplc194OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAoIXRoaXMuX2NvbHVtbnMubGVuZ3RoKSByZXR1cm47XG5cdCAgICB2YXIgaW5kZXgkJDEgPSAwO1xuXHQgICAgdGhpcy5fbGVmdF93aWR0aCA9IDA7XG5cdCAgICB0aGlzLl9yaWdodF93aWR0aCA9IDA7XG5cdCAgICB0aGlzLl9jZW50ZXJfd2lkdGggPSAwO1xuXG5cdCAgICB3aGlsZSAoaW5kZXgkJDEgPCB0aGlzLl9zZXR0aW5ncy5sZWZ0U3BsaXQpIHtcblx0ICAgICAgdGhpcy5fbGVmdF93aWR0aCArPSB0aGlzLl9jb2x1bW5zW2luZGV4JCQxXS53aWR0aDtcblx0ICAgICAgaW5kZXgkJDErKztcblx0ICAgIH1cblxuXHQgICAgaW5kZXgkJDEgPSB0aGlzLl9jb2x1bW5zLmxlbmd0aCAtIDE7XG5cblx0ICAgIHdoaWxlIChpbmRleCQkMSA+PSB0aGlzLl9yaWdodFNwbGl0KSB7XG5cdCAgICAgIHRoaXMuX3JpZ2h0X3dpZHRoICs9IHRoaXMuX2NvbHVtbnNbaW5kZXgkJDFdLndpZHRoO1xuXHQgICAgICBpbmRleCQkMS0tO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIXRoaXMuX2NvbnRlbnRfd2lkdGgpIHJldHVybjtcblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvd2lkdGggJiYgdGhpcy5yZXNpemUoKSkgcmV0dXJuO1xuXHQgICAgdGhpcy5fY2VudGVyX3dpZHRoID0gdGhpcy5fY29udGVudF93aWR0aCAtIHRoaXMuX3JpZ2h0X3dpZHRoIC0gdGhpcy5fbGVmdF93aWR0aCAtIHRoaXMuX3Njcm9sbFNpemVZO1xuXHQgICAgdGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSB0aGlzLl9kdGFibGVfd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMF0uc3R5bGUud2lkdGggPSB0aGlzLl9sZWZ0X3dpZHRoICsgXCJweFwiO1xuXHQgICAgdGhpcy5fYm9keS5jaGlsZE5vZGVzWzFdLnN0eWxlLndpZHRoID0gdGhpcy5fY2VudGVyX3dpZHRoICsgXCJweFwiO1xuXHQgICAgdGhpcy5fYm9keS5jaGlsZE5vZGVzWzJdLnN0eWxlLndpZHRoID0gdGhpcy5fcmlnaHRfd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9oZWFkZXIuY2hpbGROb2Rlc1swXS5zdHlsZS53aWR0aCA9IHRoaXMuX2xlZnRfd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9oZWFkZXIuY2hpbGROb2Rlc1sxXS5zdHlsZS53aWR0aCA9IHRoaXMuX2NlbnRlcl93aWR0aCArIFwicHhcIjtcblx0ICAgIHRoaXMuX2hlYWRlci5jaGlsZE5vZGVzWzJdLnN0eWxlLndpZHRoID0gdGhpcy5fcmlnaHRfd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9mb290ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS53aWR0aCA9IHRoaXMuX2xlZnRfd2lkdGggKyBcInB4XCI7XG5cdCAgICB0aGlzLl9mb290ZXIuY2hpbGROb2Rlc1sxXS5zdHlsZS53aWR0aCA9IHRoaXMuX2NlbnRlcl93aWR0aCArIFwicHhcIjtcblx0ICAgIHRoaXMuX2Zvb3Rlci5jaGlsZE5vZGVzWzJdLnN0eWxlLndpZHRoID0gdGhpcy5fcmlnaHRfd2lkdGggKyBcInB4XCI7XG5cdCAgICB2YXIgZGVsdGEgPSB0aGlzLl9jZW50ZXJfd2lkdGggLSB0aGlzLl9kdGFibGVfd2lkdGg7XG5cdCAgICBpZiAoZGVsdGEgPCAwKSBkZWx0YSA9IDA7IC8vbmVnYXRpdmUgaGVhZGVyIHNwYWNlIGhhcyBub3Qgc2Vuc2VcblxuXHQgICAgaWYgKGRlbHRhICE9IHRoaXMuX2hlYWRlcl9maXhfd2lkdGgpIHtcblx0ICAgICAgdGhpcy5faGVhZGVyX2ZpeF93aWR0aCA9IGRlbHRhO1xuXG5cdCAgICAgIHRoaXMuX3NpemVfaGVhZGVyX2Zvb3Rlcl9maXgoKTtcblx0ICAgIH0gLy8gdGVtcC4gZml4OiBDaHJvbWUgW0RJUlRZXVxuXG5cblx0ICAgIGlmIChlbnYuaXNXZWJLaXQpIHtcblx0ICAgICAgdmFyIHcgPSB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMF0ub2Zmc2V0V2lkdGg7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5cdCAgICAgIHcgPSB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMV0ub2Zmc2V0V2lkdGg7XG5cdCAgICAgIHcgPSB0aGlzLl9ib2R5LmNoaWxkTm9kZXNbMV0uZmlyc3RDaGlsZC5vZmZzZXRXaWR0aDtcblx0ICAgICAgdyA9IHRoaXMuX2JvZHkuY2hpbGROb2Rlc1syXS5vZmZzZXRXaWR0aDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5feF9zY3JvbGwuc2l6ZVRvKHRoaXMuX2NvbnRlbnRfd2lkdGggLSB0aGlzLl9zY3JvbGxTaXplWSk7XG5cblx0ICAgIHRoaXMuX3hfc2Nyb2xsLmRlZmluZShcInNjcm9sbFdpZHRoXCIsIHRoaXMuX2R0YWJsZV93aWR0aCArIHRoaXMuX2xlZnRfd2lkdGggKyB0aGlzLl9yaWdodF93aWR0aCk7XG5cdCAgfSxcblx0ICAkZ2V0U2l6ZTogZnVuY3Rpb24gKGR4LCBkeSkge1xuXHQgICAgaWYgKCh0aGlzLl9zZXR0aW5ncy5hdXRvaGVpZ2h0IHx8IHRoaXMuX3NldHRpbmdzLnlDb3VudCkgJiYgdGhpcy5fc2V0dGluZ3MuY29sdW1ucykge1xuXHQgICAgICAvL2lmIGxpbWl0IHNldCAtIHVzZSBpdFxuXHQgICAgICB2YXIgZGVzaXJlZCA9ICh0aGlzLl9zZXR0aW5ncy55Q291bnQgfHwgMCkgKiB0aGlzLl9zZXR0aW5ncy5yb3dIZWlnaHQ7IC8vZWxzZSB0cnkgdG8gdXNlIGFjdHVhbCByZW5kZXJlZCBzaXplXG5cdCAgICAgIC8vaWYgY29tcG9uZW50IGludmlzaWJsZSAtIHRoaXMgaXMgbm90IHZhbGlkLCBzbyBmYWxsYmFjayB0byBhbGwgcm93c1xuXG5cdCAgICAgIGlmICghZGVzaXJlZCkgZGVzaXJlZCA9IHRoaXMuaXNWaXNpYmxlKCkgPyB0aGlzLl9kdGFibGVfaGVpZ2h0IDogdGhpcy5jb3VudCgpICogdGhpcy5fc2V0dGluZ3Mucm93SGVpZ2h0OyAvL2FkZCBzY3JvbGwgYW5kIGNoZWNrIG1pbkhlaWdodCBsaW1pdFxuXG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLmhlaWdodCA9IE1hdGgubWF4KGRlc2lyZWQgKyAodGhpcy5fc2Nyb2xsU2l6ZVggPyB0aGlzLl9zY3JvbGxTaXplWCA6IDApIC0gMSwgdGhpcy5fc2V0dGluZ3MubWluSGVpZ2h0IHx8IDApICsgdGhpcy5faGVhZGVyX2hlaWdodCArIHRoaXMuX2Zvb3Rlcl9oZWlnaHQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9zZXR0aW5ncy5hdXRvd2lkdGggJiYgdGhpcy5fc2V0dGluZ3MuY29sdW1ucykgdGhpcy5fc2V0dGluZ3Mud2lkdGggPSBNYXRoLm1heCh0aGlzLl9kdGFibGVfd2lkdGggKyB0aGlzLl9sZWZ0X3dpZHRoICsgdGhpcy5fcmlnaHRfd2lkdGggKyB0aGlzLl9zY3JvbGxTaXplWSwgdGhpcy5fc2V0dGluZ3MubWluV2lkdGggfHwgMCk7XG5cdCAgICB2YXIgbWlud2lkdGggPSB0aGlzLl9sZWZ0X3dpZHRoICsgdGhpcy5fcmlnaHRfd2lkdGggKyB0aGlzLl9zY3JvbGxTaXplWTtcblx0ICAgIHZhciBzaXplcyA9IGJhc2UuYXBpLiRnZXRTaXplLmNhbGwodGhpcywgZHgsIGR5KTtcblx0ICAgIHNpemVzWzBdID0gTWF0aC5tYXgoc2l6ZXNbMF0gfHwgbWlud2lkdGgpO1xuXHQgICAgcmV0dXJuIHNpemVzO1xuXHQgIH0sXG5cdCAgX3Jlc3RvcmVfc2Nyb2xsX3N0YXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5feF9zY3JvbGwgJiYgIWVudi50b3VjaCkge1xuXHQgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFNjcm9sbFN0YXRlKCk7XG5cdCAgICAgIHRoaXMuX3hfc2Nyb2xsLl9sYXN0X3Njcm9sbF9wb3MgPSB0aGlzLl95X3Njcm9sbC5fbGFzdF9zY3JvbGxfcG9zID0gLTE7XG5cdCAgICAgIHRoaXMuc2Nyb2xsVG8oc3RhdGUueCwgc3RhdGUueSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICAkc2V0U2l6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIG9sZHcgPSB0aGlzLl9jb250ZW50X3dpZHRoO1xuXHQgICAgdmFyIG9sZGggPSB0aGlzLl9jb250ZW50X2hlaWdodDtcblxuXHQgICAgaWYgKGJhc2UuYXBpLiRzZXRTaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcblx0ICAgICAgaWYgKHRoaXMuX2R0YWJsZV9mdWxseV9yZWFkeSkge1xuXHQgICAgICAgIHRoaXMuY2FsbEV2ZW50KFwib25SZXNpemVcIiwgW3RoaXMuX2NvbnRlbnRfd2lkdGgsIHRoaXMuX2NvbnRlbnRfaGVpZ2h0LCBvbGR3LCBvbGRoXSk7XG5cblx0ICAgICAgICB0aGlzLl9zZXRfc3BsaXRfc2l6ZXNfeCgpO1xuXG5cdCAgICAgICAgdGhpcy5fc2V0X3NwbGl0X3NpemVzX3koKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMucmVuZGVyKCk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfb25faGVhZGVyX2NsaWNrOiBmdW5jdGlvbiAoY29sdW1uKSB7XG5cdCAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW5Db25maWcoY29sdW1uKTtcblx0ICAgIGlmICghY29sLnNvcnQpIHJldHVybjtcblx0ICAgIHZhciBvcmRlciA9IFwiYXNjXCI7XG5cdCAgICBpZiAoY29sLmlkID09IHRoaXMuX2xhc3Rfc29ydGVkKSBvcmRlciA9IHRoaXMuX2xhc3Rfb3JkZXIgPT0gXCJhc2NcIiA/IFwiZGVzY1wiIDogXCJhc2NcIjtcblxuXHQgICAgdGhpcy5fc29ydChjb2wuaWQsIG9yZGVyLCBjb2wuc29ydCk7XG5cdCAgfSxcblx0ICBtYXJrU29ydGluZzogZnVuY3Rpb24gKGNvbHVtbiwgb3JkZXIpIHtcblx0ICAgIGlmICghdGhpcy5fc29ydF9zaWduKSB0aGlzLl9zb3J0X3NpZ24gPSBjcmVhdGUoXCJESVZcIik7XG5cdCAgICB2YXIgcGFyZW50ID0gdGhpcy5fc29ydF9zaWduLnBhcmVudE5vZGU7XG5cblx0ICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgcGFyZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc29ydFwiKTtcblx0ICAgICAgcGFyZW50LnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xuXHQgICAgfVxuXG5cdCAgICByZW1vdmUodGhpcy5fc29ydF9zaWduKTtcblxuXHQgICAgaWYgKG9yZGVyKSB7XG5cdCAgICAgIHZhciBjZWxsID0gdGhpcy5fZ2V0X2hlYWRlcl9jZWxsKHRoaXMuZ2V0Q29sdW1uSW5kZXgoY29sdW1uKSk7XG5cblx0ICAgICAgaWYgKGNlbGwpIHtcblx0ICAgICAgICB0aGlzLl9zb3J0X3NpZ24uY2xhc3NOYW1lID0gXCJ3ZWJpeF9zc19zb3J0X1wiICsgb3JkZXI7XG5cdCAgICAgICAgY2VsbC5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0ICAgICAgICBjZWxsLmFwcGVuZENoaWxkKHRoaXMuX3NvcnRfc2lnbik7XG5cdCAgICAgICAgY2VsbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNvcnRcIiwgb3JkZXIgKyBcImVuZGluZ1wiKTtcblx0ICAgICAgICBjZWxsLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2xhc3Rfc29ydGVkID0gY29sdW1uO1xuXHQgICAgICB0aGlzLl9sYXN0X29yZGVyID0gb3JkZXI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9sYXN0X3NvcnRlZCA9IHRoaXMuX2xhc3Rfb3JkZXIgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgc2Nyb2xsX3NldHRlcjogZnVuY3Rpb24gKG1vZGUpIHtcblx0ICAgIGlmICh0eXBlb2YgbW9kZSA9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIHRoaXMuX3NldHRpbmdzLnNjcm9sbFggPSBtb2RlLmluZGV4T2YoXCJ4XCIpICE9IC0xO1xuXHQgICAgICB0aGlzLl9zZXR0aW5ncy5zY3JvbGxZID0gbW9kZS5pbmRleE9mKFwieVwiKSAhPSAtMTtcblx0ICAgICAgcmV0dXJuIG1vZGU7XG5cdCAgICB9IGVsc2UgcmV0dXJuIHRoaXMuX3NldHRpbmdzLnNjcm9sbFggPSB0aGlzLl9zZXR0aW5ncy5zY3JvbGxZID0gbW9kZTtcblx0ICB9LFxuXHQgIF9nZXRfaGVhZGVyX2NlbGw6IGZ1bmN0aW9uIChjb2x1bW4pIHtcblx0ICAgIHZhciBjZWxscyA9IHRoaXMuX2hlYWRlci5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlREXCIpO1xuXG5cdCAgICB2YXIgbWF5YmUgPSBudWxsO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChjZWxsc1tpXS5nZXRBdHRyaWJ1dGUoXCJjb2x1bW5cIikgPT0gY29sdW1uICYmICFjZWxsc1tpXS5nZXRBdHRyaWJ1dGUoXCJhY3RpdmVfaWRcIikpIHtcblx0ICAgICAgICBtYXliZSA9IGNlbGxzW2ldLmZpcnN0Q2hpbGQ7XG5cdCAgICAgICAgaWYgKChjZWxsc1tpXS5jb2xTcGFuIHx8IDApIDwgMikgcmV0dXJuIG1heWJlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXliZTtcblx0ICB9LFxuXHQgIF9zb3J0OiBmdW5jdGlvbiAoY29sX2lkLCBkaXJlY3Rpb24sIHR5cGUkJDEpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCBcImFzY1wiO1xuXHQgICAgdGhpcy5tYXJrU29ydGluZyhjb2xfaWQsIGRpcmVjdGlvbik7XG5cblx0ICAgIGlmICh0eXBlJCQxID09IFwic2VydmVyXCIpIHtcblx0ICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvbkJlZm9yZVNvcnRcIiwgW2NvbF9pZCwgZGlyZWN0aW9uLCB0eXBlJCQxXSk7XG5cdCAgICAgIHRoaXMubG9hZE5leHQoMCwgMCwgMCwgMCwgMSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIF90aGlzLmNsZWFyQWxsKHRydWUpO1xuXG5cdCAgICAgICAgX3RoaXMucGFyc2UoZGF0YSk7XG5cblx0ICAgICAgICBfdGhpcy5jYWxsRXZlbnQoXCJvbkFmdGVyU29ydFwiLCBbY29sX2lkLCBkaXJlY3Rpb24sIHR5cGUkJDFdKTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodHlwZSQkMSA9PSBcInRleHRcIikge1xuXHQgICAgICAgIHRoaXMuZGF0YS5lYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgIG9iai4kdGV4dCA9IHRoaXMuZ2V0VGV4dChvYmouaWQsIGNvbF9pZCk7XG5cdCAgICAgICAgfSwgdGhpcyk7XG5cdCAgICAgICAgdHlwZSQkMSA9IFwic3RyaW5nXCI7XG5cdCAgICAgICAgY29sX2lkID0gXCIkdGV4dFwiO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiB0eXBlJCQxID09IFwiZnVuY3Rpb25cIikgdGhpcy5kYXRhLnNvcnQodHlwZSQkMSwgZGlyZWN0aW9uKTtlbHNlIHRoaXMuZGF0YS5zb3J0KGNvbF9pZCwgZGlyZWN0aW9uLCB0eXBlJCQxIHx8IFwic3RyaW5nXCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgX21vdXNlRXZlbnRDYWxsOiBmdW5jdGlvbiAoY3NzX2NhbGwsIGUsIGlkLCB0cmcpIHtcblx0ICAgIHZhciBmdW5jdG9yLCBpLCByZXM7XG5cblx0ICAgIGlmIChjc3NfY2FsbC5sZW5ndGgpIHtcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGNzc19jYWxsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZnVuY3RvciA9IHRvRnVuY3Rvcihjc3NfY2FsbFtpXSwgdGhpcy4kc2NvcGUpO1xuXHQgICAgICAgIHJlcyA9IGZ1bmN0b3IuY2FsbCh0aGlzLCBlLCBpZCwgdHJnKTtcblx0ICAgICAgICBpZiAocmVzID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICAvL2JlY2F1c2Ugd2UgdXNpbmcgbm9uLXN0YW5kYXJkIHJlbmRlcmluZyBtb2RlbCwgY3VzdG9tIGxvZ2ljIGZvciBtb3VzZSBkZXRlY3Rpb24gbmVlZCB0byBiZSB1c2VkXG5cdCAgX21vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlLCBoYXNoLCBuYW1lLCBwYWlyKSB7XG5cdCAgICBlID0gZSB8fCBldmVudDtcblx0ICAgIHZhciB0cmcgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cdCAgICBpZiAodGhpcy5fc2V0dGluZ3Muc3VidmlldyAmJiB0aGlzICE9ICQkKHRyZykpIHJldHVybjsgLy9kZWZpbmUgc29tZSB2YXJzLCB3aGljaCB3aWxsIGJlIHVzZWQgYmVsb3dcblxuXHQgICAgdmFyIGNzcyA9IFwiXCIsXG5cdCAgICAgICAgY3NzX2NhbGwgPSBbXSxcblx0ICAgICAgICBmb3VuZCA9IGZhbHNlLFxuXHQgICAgICAgIGlkID0gbnVsbCxcblx0ICAgICAgICByZXM7IC8vbG9vcCB0aHJvdWdoIGFsbCBwYXJlbnRzXG5cblx0ICAgIHdoaWxlICh0cmcgJiYgdHJnLnBhcmVudE5vZGUgJiYgdHJnICE9IHRoaXMuX3ZpZXdvYmoucGFyZW50Tm9kZSkge1xuXHQgICAgICB2YXIgdHJnQ3NzID0gX2dldENsYXNzTmFtZSh0cmcpO1xuXG5cdCAgICAgIGlmIChjc3MgPSB0cmdDc3MpIHtcblx0ICAgICAgICBjc3MgPSBjc3MudG9TdHJpbmcoKS5zcGxpdChcIiBcIik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gY3NzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICBpZiAoaGFzaFtjc3NbaV1dKSBjc3NfY2FsbC5wdXNoKGhhc2hbY3NzW2ldXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRyZy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSAmJiAhaWQpIHtcblx0ICAgICAgICB2YXIgY29sdW1uID0gdHJnLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKFwiY29sdW1uXCIpIHx8IHRyZy5nZXRBdHRyaWJ1dGUoXCJjb2x1bW5cIik7XG5cblx0ICAgICAgICBpZiAoY29sdW1uKSB7XG5cdCAgICAgICAgICAvL3dlIG5lZWQgdG8gaWdub3JlIFREIC0gd2hpY2ggaXMgaGVhZGVyfGZvb3RlclxuXHQgICAgICAgICAgdmFyIGlzQm9keSA9IHRyZy5wYXJlbnROb2RlLnRhZ05hbWUgPT0gXCJESVZcIjsgLy9jb2x1bW4gYWxyZWFkeSBoaWRkZW4gb3IgcmVtb3ZlZFxuXG5cdCAgICAgICAgICBpZiAoIXRoaXMuX2NvbHVtbnNbY29sdW1uXSkgcmV0dXJuO1xuXHQgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXG5cdCAgICAgICAgICBpZiAoaXNCb2R5KSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCQkMSA9IHRyZy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcInJvd1wiKSB8fCB0cmcuZ2V0QXR0cmlidXRlKFwicm93XCIpO1xuXG5cdCAgICAgICAgICAgIGlmICghaW5kZXgkJDEpIHtcblx0ICAgICAgICAgICAgICAvL2NsaWNrIGV2ZW50IG9jY3VycyBvbiBjb2x1bW4gaG9sZGVyLCB3ZSBjYW4ndCBkZXRlY3QgY2VsbFxuXHQgICAgICAgICAgICAgIGlmICh0cmcuZ2V0QXR0cmlidXRlKFwiY29sdW1uXCIpKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgaW5kZXgkJDEgPSBpbmRleCh0cmcpO1xuXHQgICAgICAgICAgICAgIGlmIChpbmRleCQkMSA+PSB0aGlzLl9zZXR0aW5ncy50b3BTcGxpdCAmJiAhdGhpcy5fc2V0dGluZ3MucHJlcmVuZGVyKSBpbmRleCQkMSArPSB0aGlzLl9jb2x1bW5zW2NvbHVtbl0uX3lyMCAtIHRoaXMuX3NldHRpbmdzLnRvcFNwbGl0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5faXRlbV9jbGlja2VkID0gaWQgPSB7XG5cdCAgICAgICAgICAgICAgcm93OiB0aGlzLmRhdGEub3JkZXJbaW5kZXgkJDFdLFxuXHQgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5fY29sdW1uc1tjb2x1bW5dLmlkXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlkLnRvU3RyaW5nID0gdGhpcy5faWRfdG9fc3RyaW5nO1xuXHQgICAgICAgICAgfSBlbHNlIHRoaXMuX2l0ZW1fY2xpY2tlZCA9IGlkID0ge1xuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuX2NvbHVtbnNbY29sdW1uXS5pZFxuXHQgICAgICAgICAgfTsgLy9zb21lIGN1c3RvbSBjc3MgaGFuZGxlcnMgd2FzIGZvdW5kXG5cblxuXHQgICAgICAgICAgcmVzID0gdGhpcy5fbW91c2VFdmVudENhbGwoY3NzX2NhbGwsIGUsIGlkLCB0cmcpO1xuXHQgICAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHJldHVybjsgLy9jYWxsIGlubmVyIGhhbmRsZXJcblxuXHQgICAgICAgICAgaWYgKGlzQm9keSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jYWxsRXZlbnQoXCJvblwiICsgbmFtZSwgW2lkLCBlLCB0cmddKSAmJiBwYWlyKSB7XG5cdCAgICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnQoXCJvblwiICsgcGFpciwgW2lkLCBlLCB0cmddKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwiSXRlbUNsaWNrXCIpIHtcblx0ICAgICAgICAgICAgdmFyIGlzSGVhZGVyID0gdHJnLnBhcmVudE5vZGUucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJzZWN0aW9uXCIpID09IFwiaGVhZGVyXCI7XG5cdCAgICAgICAgICAgIGlmIChpc0hlYWRlciAmJiB0aGlzLmNhbGxFdmVudChcIm9uSGVhZGVyQ2xpY2tcIiwgW2lkLCBlLCB0cmddKSkgdGhpcy5fb25faGVhZGVyX2NsaWNrKGlkLmNvbHVtbik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGNzc19jYWxsID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgdHJnID0gdHJnLnBhcmVudE5vZGU7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX21vdXNlRXZlbnRDYWxsKGNzc19jYWxsLCBlLCBpZCwgdGhpcy4kdmlldyk7XG5cblx0ICAgIHJldHVybiBmb3VuZDsgLy9yZXR1cm5zIHRydWUgaWYgaXRlbSB3YXMgbG9jYXRlZCBhbmQgZXZlbnQgd2FzIHRyaWdnZXJlZFxuXHQgIH0sXG5cdCAgX2dldF90b29sdGlwX2RhdGE6IGZ1bmN0aW9uICh0LCBlKSB7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmxvY2F0ZShlKTtcblx0ICAgIGlmICghaWQpIHJldHVybiBudWxsO1xuXHQgICAgdmFyIHRvb2x0aXAgPSBUb29sdGlwQ29udHJvbC5fdG9vbHRpcDtcblx0ICAgIHZhciBkYXRhO1xuXG5cdCAgICBpZiAoaWQuaGVhZGVyKSB7XG5cdCAgICAgIHZhciBub2RlID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXHQgICAgICB2YXIgcG9zJCQxO1xuXHQgICAgICB2YXIgY2luZCA9IGlkLmNpbmQgLSAoaWQuc3BhbiA/IGlkLnNwYW4gLSAxIDogMCk7XG5cdCAgICAgIHZhciByaW5kID0gLTE7XG5cblx0ICAgICAgd2hpbGUgKG5vZGUgJiYgIXBvcyQkMSkge1xuXHQgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdCAgICAgICAgcG9zJCQxID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzZWN0aW9uXCIpO1xuXHQgICAgICB9XG5cblx0ICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmluZCsrO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuX2NvbHVtbnNbY2luZF1bcG9zJCQxXVtyaW5kXTtcblx0ICAgICAgaWYgKGNvbmZpZy50b29sdGlwKSB0b29sdGlwLnR5cGUudGVtcGxhdGUgPSB0ZW1wbGF0ZShjb25maWcudG9vbHRpcCA9PT0gdHJ1ZSA/IFwiI3RleHQjXCIgOiBjb25maWcudG9vbHRpcCk7ZWxzZSByZXR1cm4gbnVsbDtcblx0ICAgICAgZGF0YSA9IGNvbmZpZztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBfY29uZmlnID0gdG9vbHRpcC50eXBlLmNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQ29uZmlnKGlkLmNvbHVtbik7XG5cblx0ICAgICAgdmFyIGRlZiA9ICFfY29uZmlnLnRvb2x0aXAgfHwgX2NvbmZpZy50b29sdGlwID09PSB0cnVlOyAvL2VtcHR5IHRvb2x0aXAgLSBpZ25vcmluZ1xuXG5cdCAgICAgIGlmICghX2NvbmZpZy50b29sdGlwICYmIF9jb25maWcudG9vbHRpcCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQgICAgICBpZiAoZGVmICYmICF0aGlzLl9zZXR0aW5ncy50b29sdGlwLnRlbXBsYXRlKSB7XG5cdCAgICAgICAgZGF0YSA9IHRoaXMuZ2V0VGV4dChpZC5yb3csIGlkLmNvbHVtbikudG9TdHJpbmcoKTtcblx0ICAgICAgfSBlbHNlIGlmICghZGVmKSB7XG5cdCAgICAgICAgdmFyIGFyZWEgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KS5nZXRBdHRyaWJ1dGUoXCJ3ZWJpeF9hcmVhXCIpO1xuXG5cdCAgICAgICAgaWYgKGFyZWEpIHtcblx0ICAgICAgICAgIHRvb2x0aXAudHlwZS50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChvYmosIGNvbW1vbikge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzID0gb2JqW19jb25maWcuaWRdO1xuXHQgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoX2NvbmZpZy50b29sdGlwKS5jYWxsKHRoaXMsIG9iaiwgY29tbW9uLCB2YWx1ZXNbYXJlYV0sIGFyZWEpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9IGVsc2UgdG9vbHRpcC50eXBlLnRlbXBsYXRlID0gdGVtcGxhdGUoX2NvbmZpZy50b29sdGlwKTtcblx0ICAgICAgfSBlbHNlIHRvb2x0aXAudHlwZS50ZW1wbGF0ZSA9IHRlbXBsYXRlKHRoaXMuX3NldHRpbmdzLnRvb2x0aXAudGVtcGxhdGUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YSB8fCB0aGlzLmdldEl0ZW0oaWQucm93KTtcblx0ICB9LFxuXHQgIHNob3dPdmVybGF5OiBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgaWYgKCF0aGlzLl9kYXRhdGFibGVfb3ZlcmxheSkge1xuXHQgICAgICB2YXIgdCA9IGNyZWF0ZShcIkRJVlwiLCB7XG5cdCAgICAgICAgXCJjbGFzc1wiOiBcIndlYml4X292ZXJsYXlcIlxuXHQgICAgICB9LCBcIlwiKTtcblxuXHQgICAgICB0aGlzLl9ib2R5LmFwcGVuZENoaWxkKHQpO1xuXG5cdCAgICAgIHRoaXMuX2RhdGF0YWJsZV9vdmVybGF5ID0gdDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fZGF0YXRhYmxlX292ZXJsYXkuaW5uZXJIVE1MID0gbWVzc2FnZTtcblx0ICB9LFxuXHQgIGhpZGVPdmVybGF5OiBmdW5jdGlvbiAoKSB7XG5cdCAgICBpZiAodGhpcy5fZGF0YXRhYmxlX292ZXJsYXkpIHtcblx0ICAgICAgcmVtb3ZlKHRoaXMuX2RhdGF0YWJsZV9vdmVybGF5KTtcblx0ICAgICAgdGhpcy5fZGF0YXRhYmxlX292ZXJsYXkgPSBudWxsO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgbWFwQ2VsbHM6IGZ1bmN0aW9uIChzdGFydHJvdywgc3RhcnRjb2wsIG51bXJvd3MsIG51bWNvbHMsIGNhbGxiYWNrLCBnZXRPbmx5KSB7XG5cdCAgICBpZiAoc3RhcnRyb3cgPT09IG51bGwgJiYgdGhpcy5kYXRhLm9yZGVyLmxlbmd0aCA+IDApIHN0YXJ0cm93ID0gdGhpcy5kYXRhLm9yZGVyWzBdO1xuXHQgICAgaWYgKHN0YXJ0Y29sID09PSBudWxsKSBzdGFydGNvbCA9IHRoaXMuY29sdW1uSWQoMCk7XG5cdCAgICBpZiAobnVtcm93cyA9PT0gbnVsbCkgbnVtcm93cyA9IHRoaXMuZGF0YS5vcmRlci5sZW5ndGg7XG5cdCAgICBpZiAobnVtY29scyA9PT0gbnVsbCkgbnVtY29scyA9IHRoaXMuX3NldHRpbmdzLmNvbHVtbnMubGVuZ3RoO1xuXHQgICAgaWYgKCF0aGlzLmV4aXN0cyhzdGFydHJvdykpIHJldHVybjtcblx0ICAgIHN0YXJ0cm93ID0gdGhpcy5nZXRJbmRleEJ5SWQoc3RhcnRyb3cpO1xuXHQgICAgc3RhcnRjb2wgPSB0aGlzLmdldENvbHVtbkluZGV4KHN0YXJ0Y29sKTtcblx0ICAgIGlmIChzdGFydGNvbCA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bXJvd3MgJiYgc3RhcnRyb3cgKyBpIDwgdGhpcy5kYXRhLm9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciByb3dfaW5kID0gc3RhcnRyb3cgKyBpO1xuXHQgICAgICB2YXIgcm93X2lkID0gdGhpcy5kYXRhLm9yZGVyW3Jvd19pbmRdO1xuXG5cdCAgICAgIGlmIChyb3dfaWQpIHtcblx0ICAgICAgICAvL2R5biBsb2FkaW5nXG5cdCAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0ocm93X2lkKTtcblxuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtY29scyAmJiBzdGFydGNvbCArIGogPCB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICB2YXIgY29sX2luZCA9IHN0YXJ0Y29sICsgajtcblx0ICAgICAgICAgIHZhciBjb2xfaWQgPSB0aGlzLmNvbHVtbklkKGNvbF9pbmQpO1xuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGl0ZW1bY29sX2lkXSwgcm93X2lkLCBjb2xfaWQsIGksIGopO1xuXHQgICAgICAgICAgaWYgKCFnZXRPbmx5KSBpdGVtW2NvbF9pZF0gPSByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSxcblx0ICBfY2FsbF9vbnBhcnNlOiBmdW5jdGlvbiAoZHJpdmVyLCBkYXRhKSB7XG5cdCAgICBpZiAoIXRoaXMuX3NldHRpbmdzLmNvbHVtbnMgJiYgZHJpdmVyLmdldENvbmZpZykgdGhpcy5kZWZpbmUoXCJjb2x1bW5zXCIsIGRyaXZlci5nZXRDb25maWcoZGF0YSkpO1xuXHQgIH0sXG5cdCAgX2F1dG9EZXRlY3RDb25maWc6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciB0ZXN0ID0gdGhpcy5nZXRJdGVtKHRoaXMuZ2V0Rmlyc3RJZCgpKTtcblx0ICAgIHZhciByZXMgPSB0aGlzLl9zZXR0aW5ncy5jb2x1bW5zID0gW107XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiB0ZXN0KSB7XG5cdCAgICAgIGlmIChrZXkgIT0gXCJpZFwiICYmIGtleVswXSAhPSBcIiRcIikgcmVzLnB1c2goe1xuXHQgICAgICAgIGlkOiBrZXksXG5cdCAgICAgICAgaGVhZGVyOiBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSksXG5cdCAgICAgICAgc29ydDogXCJzdHJpbmdcIixcblx0ICAgICAgICBlZGl0b3I6IFwidGV4dFwiXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocmVzLmxlbmd0aCkgcmVzWzBdLmZpbGxzcGFjZSA9IHRydWU7XG5cdCAgICBpZiAodHlwZW9mIHRoaXMuX3NldHRpbmdzLnNlbGVjdCA9PSBcInVuZGVmaW5lZFwiKSB0aGlzLmRlZmluZShcInNlbGVjdFwiLCBcInJvd1wiKTtcblx0ICB9XG5cdH07IC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfZmlsdGVyLmpzXG5cdC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfc2VsZWN0aW9uLmpzXG5cdC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfYmxvY2tzZWxlY3QuanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9yZXNpemUuanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9wYWdpbmcuanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9jbGlwYm9hcmQuanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9zdGF0ZS5qc1xuXHQvLyAjaW5jbHVkZSB1aS9kYXRhdGFibGUvZGF0YXRhYmxlX3RvdWNoLmpzXG5cdC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfc2l6ZS5qc1xuXHQvLyAjaW5jbHVkZSB1aS9kYXRhdGFibGUvZGF0YXRhYmxlX21hdGguanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9lZGl0LmpzXG5cdC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfY29sdW1ucy5qc1xuXHQvLyAjaW5jbHVkZSB1aS9kYXRhdGFibGUvZGF0YXRhYmxlX2tleW5hdi5qc1xuXHQvLyAjaW5jbHVkZSB1aS9kYXRhdGFibGUvZGF0YXRhYmxlX2RuZC5qc1xuXHQvLyAjaW5jbHVkZSB1aS9kYXRhdGFibGUvZGF0YXRhYmxlX3ZhbGlkYXRpb24uanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9zcGFya2xpbmVzLmpzXG5cdC8vICNpbmNsdWRlIHVpL2RhdGF0YWJsZS9kYXRhdGFibGVfcHJpbnQuanNcblx0Ly8gI2luY2x1ZGUgdWkvZGF0YXRhYmxlL2RhdGF0YWJsZV9leHBvcnQuanNcblxuXHR2YXIgdmlldyQxZCA9IGV4cG9ydHMucHJvdG9VSShhcGkkMWQsIHRlbXAkMywgRGF0YVN0YXRlLCBUYWJsZVBhc3RlLCBEYXRhTW92ZSwgRWRpdEFiaWxpdHksIEtleXNOYXZpZ2F0aW9uLCBQYWdpbmdBYmlsaXR5LCBDdXN0b21QcmludCwgTWl4aW4kYywgVmFsaWRhdGVDb2xsZWN0aW9uLCBNaXhpbiRiLCBNaXhpbiRkLCBEcmFnSXRlbSwgTWl4aW4kYSwgTWl4aW4kOSwgTWl4aW4kOCwgTWl4aW4kNywgTWl4aW4kNiwgdGVtcCQ0LCBNaXhpbiQ1LCBNaXhpbiQ0LCBNaXhpbiQzLCB0ZW1wJDUsIE1peGluJDIsIE1peGluJDEsIE1peGluLCB0ZW1wJDYsIHRlbXAkNywgQXV0b1Rvb2x0aXAsIEdyb3VwLCBEYXRhTWFya3MsIERhdGFMb2FkZXIsIE1vdXNlRXZlbnRzLCBNYXBDb2xsZWN0aW9uLCBiYXNlLnZpZXcsIEV2ZW50U3lzdGVtLCBTZXR0aW5ncyk7XG5cdHZhciBkYXRhdGFibGUgPSB7XG5cdCAgYXBpOiBhcGkkMWQsXG5cdCAgdmlldzogdmlldyQxZFxuXHR9O1xuXG5cdHZhciBhcGkkMWUgPSB7XG5cdCAgbmFtZTogXCJ0cmVldGFibGVcIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5kYXRhLCBUcmVlU3RvcmUsIHRydWUpO1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy50eXBlLCBUcmVlVHlwZSk7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBUcmVlRGF0YU1vdmUsIHRydWUpO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gVHJlZUNsaWNrKSB7XG5cdCAgICAgIGlmICghdGhpcy5vbl9jbGlja1trZXldKSB0aGlzLm9uX2NsaWNrW2tleV0gPSB0aGlzLl91bndyYXBfaWQoVHJlZUNsaWNrW2tleV0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnR5cGUudHJlZXRhYmxlID0gdGVtcGxhdGUoXCJ7Y29tbW9uLnNwYWNlKCl9e2NvbW1vbi5pY29uKCl9IHtjb21tb24uZm9sZGVyKCl9XCIpO1xuXG5cdCAgICB0aGlzLnR5cGUudHJlZWNoZWNrYm94ID0gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICBpZiAob2JqLmluZGV0ZXJtaW5hdGUgJiYgIW9iai5ub2NoZWNrYm94KSByZXR1cm4gXCI8ZGl2IGNsYXNzPSd3ZWJpeF90cmVlX2NoZWNrYm94IHdlYml4X2luZGV0ZXJtaW5hdGUnPjwvZGl2PlwiO2Vsc2UgcmV0dXJuIFRyZWVUeXBlLmNoZWNrYm94LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLmRhdGEucHJvdmlkZUFwaSh0aGlzLCB0cnVlKTtcblxuXHQgICAgdGhpcy5fdmlld29iai5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidHJlZWdyaWRcIik7XG5cdCAgfSxcblx0ICBfZHJhZ19vcmRlcl9jb21wbGV4OiBmYWxzZSxcblx0ICBfdW53cmFwX2lkOiBmdW5jdGlvbiAob3JpZ2luYWwpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZSwgaWQpIHtcblx0ICAgICAgaWQgPSBpZC5yb3c7XG5cdCAgICAgIHJldHVybiBvcmlnaW5hbC5jYWxsKHRoaXMsIGUsIGlkKTtcblx0ICAgIH07XG5cdCAgfSxcblx0ICBfY2xvc2VfYnJhbmNoZXM6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICB2YXIgc291cmNlID0gIXRoaXMuX3NldHRpbmdzLnByZXJlbmRlciA/IFtjb250ZXh0LnN0YXJ0XSA6IGNvbnRleHQuc291cmNlO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLmNsb3NlKHNvdXJjZVtpXSk7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHN0YXRlID0gRGF0YVN0YXRlLmdldFN0YXRlLmNhbGwodGhpcyk7XG5cdCAgICBleHBvcnRzLmV4dGVuZChzdGF0ZSwgVHJlZUFQSS5nZXRTdGF0ZS5jYWxsKHRoaXMpKTtcblx0ICAgIHJldHVybiBzdGF0ZTtcblx0ICB9LFxuXHQgIHNldFN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcblx0ICAgIGlmIChUcmVlQVBJLnNldFN0YXRlLmNhbGwodGhpcywgc3RhdGUpKSB7XG5cdCAgICAgIC8vcnVuIGdyaWQtc3RhdGUgb25seSB3aGVuIHRyZWUgY29tcG9uZW50IHdhcyBmdWxseSBsb2FkZWQgXG5cdCAgICAgIERhdGFTdGF0ZS5zZXRTdGF0ZS5jYWxsKHRoaXMsIHN0YXRlKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGNsaXBib2FyZF9zZXR0ZXI6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5fcGFzdGUsIFRyZWVUYWJsZVBhc3RlKTtcblx0ICAgIHJldHVybiBUYWJsZVBhc3RlLmNsaXBib2FyZF9zZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdCAgfSxcblx0ICBfcnVuX2xvYWRfbmV4dDogZnVuY3Rpb24gKGNvbmYsIGRpcmVjdGlvbikge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25mLnN0YXJ0OyBpKyspIHtcblx0ICAgICAgdmFyIGlkID0gdGhpcy5kYXRhLm9yZGVyW2ldO1xuXHQgICAgICBpZiAoaWQgJiYgdGhpcy5nZXRJdGVtKGlkKS4kbGV2ZWwgIT0gMSkgY29uZi5zdGFydC0tO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZGF0YXRhYmxlLmFwaS5fcnVuX2xvYWRfbmV4dC5jYWxsKHRoaXMsIGNvbmYsIGRpcmVjdGlvbik7XG5cdCAgfVxuXHR9O1xuXHR2YXIgdmlldyQxZSA9IGV4cG9ydHMucHJvdG9VSShhcGkkMWUsIFRyZWVBUEksIFRyZWVTdGF0ZUNoZWNrYm94LCBUcmVlRGF0YUxvYWRlciwgZGF0YXRhYmxlLnZpZXcpO1xuXG5cdC8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246IDAgKi9cblxuXHQvKiBlc2xpbnQgbm8taW5uZXItZGVjbGFyYXRpb25zOiAwICovXG5cblx0e1xuXHQgIHZhciBnZXRfaW5zcGVjdG9yX2NvbmZpZyA9IGZ1bmN0aW9uICh2aWV3KSB7XG5cdCAgICB2YXIgdmFsdWVzID0ge307XG5cdCAgICB2YXIgb3B0aW9ucyA9IFtdO1xuXHQgICAgdmlldyA9ICQkKHZpZXcpO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdmlldy5jb25maWcpIHtcblx0ICAgICAgaWYgKGlnbm9yZVtrZXldKSBjb250aW51ZTtcblx0ICAgICAgaWYgKF90eXBlb2Yodmlldy5jb25maWdba2V5XSkgPT0gXCJvYmplY3RcIikgY29udGludWU7XG5cdCAgICAgIGlmICh0eXBlb2Ygdmlldy5jb25maWdba2V5XSA9PSBcInVuZGVmaW5lZFwiKSBjb250aW51ZTtcblx0ICAgICAgaWYgKHR5cGVvZiB2aWV3LmNvbmZpZ1trZXldID09IFwiZnVuY3Rpb25cIikgY29udGludWU7XG5cdCAgICAgIGlmIChrZXkgPT0gXCJ2aWV3XCIgfHwga2V5ID09IFwiaWRcIikgb3B0aW9ucy5wdXNoKHtcblx0ICAgICAgICBsYWJlbDoga2V5LFxuXHQgICAgICAgIGlkOiBrZXlcblx0ICAgICAgfSk7ZWxzZSBvcHRpb25zLnB1c2goe1xuXHQgICAgICAgIGxhYmVsOiBrZXksXG5cdCAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG5cdCAgICAgICAgaWQ6IGtleVxuXHQgICAgICB9KTtcblx0ICAgICAgaWYgKHZpZXcuZGVmYXVsdHNba2V5XSA9PSB2aWV3LmNvbmZpZ1trZXldKSBvcHRpb25zW29wdGlvbnMubGVuZ3RoIC0gMV0uY3NzID0ge1xuXHQgICAgICAgIFwiY29sb3JcIjogXCIjODg4XCJcblx0ICAgICAgfTtcblx0ICAgICAgdmFsdWVzW2tleV0gPSB2aWV3LmNvbmZpZ1trZXldO1xuXHQgICAgfVxuXG5cdCAgICBvcHRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgaWYgKCFhLmNzcyAmJiBiLmNzcykgcmV0dXJuIC0xO1xuXHQgICAgICBpZiAoYS5jc3MgJiYgIWIuY3NzKSByZXR1cm4gMTtcblx0ICAgICAgcmV0dXJuIGEuaWQgPiBiLmlkID8gMSA6IGEuaWQgPT0gYi5pZCA/IDAgOiAtMTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZWxlbWVudHM6IG9wdGlvbnMsXG5cdCAgICAgIGRhdGE6IHZhbHVlcyxcblx0ICAgICAgaGVhZDogXCIgW1wiICsgdmlldy5uYW1lICsgXCJdIDxzdHJvbmc+XCIgKyB2aWV3Ll9zZXR0aW5ncy5pZCArIFwiPC9zdHJvbmc+XCJcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIHZhciBjcmVhdGVfaW5zcGVjdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgaWYgKCEkJChcIndlYml4X2RlYnVnX2luc3BlY3Rvcl93aW5cIikpIHVpKHtcblx0ICAgICAgaWQ6IFwid2ViaXhfZGVidWdfaW5zcGVjdG9yX3dpblwiLFxuXHQgICAgICB2aWV3OiBcIndpbmRvd1wiLFxuXHQgICAgICB0b3A6IDIsXG5cdCAgICAgIGxlZnQ6IDAsXG5cdCAgICAgIHdpZHRoOiAzNTAsXG5cdCAgICAgIGhlaWdodDogMzUwLFxuXHQgICAgICBoZWFkOiBmYWxzZSxcblx0ICAgICAgYXV0b2ZpdDogZmFsc2UsXG5cdCAgICAgIGJvZHk6IHtcblx0ICAgICAgICBjb2xzOiBbe1xuXHQgICAgICAgICAgd2lkdGg6IDEwXG5cdCAgICAgICAgfSwge1xuXHQgICAgICAgICAgdHlwZTogXCJjbGVhblwiLFxuXHQgICAgICAgICAgcm93czogW3tcblx0ICAgICAgICAgICAgdmlldzogXCJ0b29sYmFyXCIsXG5cdCAgICAgICAgICAgIGVsZW1lbnRzOiBbe1xuXHQgICAgICAgICAgICAgIHZpZXc6IFwibGFiZWxcIixcblx0ICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcblx0ICAgICAgICAgICAgICBpZDogXCJ3ZWJpeF9kZWJ1Z19pbnNwZWN0b3JfaGVhZFwiXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICB2aWV3OiBcImJ1dHRvblwiLFxuXHQgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXG5cdCAgICAgICAgICAgICAgdmFsdWU6IFwiSGlkZVwiLFxuXHQgICAgICAgICAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG5cdCAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHNob3dfaW5zcGVjdG9yKCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XVxuXHQgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICBpZDogXCJ3ZWJpeF9kZWJ1Z19pbnNwZWN0b3JcIixcblx0ICAgICAgICAgICAgbmFtZVdpZHRoOiAxNTAsXG5cdCAgICAgICAgICAgIHZpZXc6IFwicHJvcGVydHlcIixcblx0ICAgICAgICAgICAgc2Nyb2xsOiBcInlcIixcblx0ICAgICAgICAgICAgZWxlbWVudHM6IFtdLFxuXHQgICAgICAgICAgICBvbjoge1xuXHQgICAgICAgICAgICAgIG9uYWZ0ZXJlZGl0c3RvcDogZnVuY3Rpb24gKHN0YXRlLCBlZGl0b3IpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vbGQgPT0gc3RhdGUudmFsdWUpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiIHx8IHZhbHVlID09PSBcImZhbHNlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJ0cnVlXCI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICB2YXIgaW50dmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXHQgICAgICAgICAgICAgICAgICBpZiAoaW50dmFsdWUgPT0gdmFsdWUpIHZhbHVlID0gaW50dmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gJCQodGhpcy5jb25maWcudmlldyk7XG5cdCAgICAgICAgICAgICAgICB2aWV3LmRlZmluZShlZGl0b3IuaWQsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh2aWV3LnJlZnJlc2hDb2x1bW5zKSB2aWV3LnJlZnJlc2hDb2x1bW5zKCk7ZWxzZSBpZiAodmlldy5yZWZyZXNoKSB2aWV3LnJlZnJlc2goKTtcblx0ICAgICAgICAgICAgICAgIHZpZXcucmVzaXplKCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XVxuXHQgICAgICAgIH1dXG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICB2YXIgc2hvd19pbnNwZWN0b3IgPSBmdW5jdGlvbiAodmlldywgZXYpIHtcblx0ICAgIGNyZWF0ZV9pbnNwZWN0b3IoKTtcblx0ICAgIHZhciB3aW4gPSAkJChcIndlYml4X2RlYnVnX2luc3BlY3Rvcl93aW5cIik7XG5cblx0ICAgIGlmICh2aWV3KSB7XG5cdCAgICAgIHZhciBjb25maWcgPSBnZXRfaW5zcGVjdG9yX2NvbmZpZyh2aWV3KTtcblx0ICAgICAgdmFyIHdpbnggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuXHQgICAgICB2YXIgd2lueSA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXHQgICAgICB2YXIgcG9zJCQxID0gZXYgPyBwb3MoZXYpIDoge1xuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogMFxuXHQgICAgICB9O1xuXHQgICAgICB3aW4uZGVmaW5lKFwiaGVpZ2h0XCIsIE1hdGgubWF4KDM1MCwgd2lueSAtIDQpKTtcblx0ICAgICAgd2luLnJlc2l6ZSgpO1xuXHQgICAgICB2YXIgcHJvcHMgPSAkJChcIndlYml4X2RlYnVnX2luc3BlY3RvclwiKTtcblx0ICAgICAgcHJvcHMuZGVmaW5lKFwiZWxlbWVudHNcIiwgY29uZmlnLmVsZW1lbnRzKTtcblx0ICAgICAgcHJvcHMuZGVmaW5lKFwidmlld1wiLCB2aWV3KTtcblx0ICAgICAgd2luLnNob3coe1xuXHQgICAgICAgIHg6IHBvcyQkMS54ID4gd2lueCAvIDIgPyAwIDogd2lueCAtIDM3MCxcblx0ICAgICAgICB5OiAwXG5cdCAgICAgIH0pO1xuXHQgICAgICAkJChcIndlYml4X2RlYnVnX2luc3BlY3RvclwiKS5zZXRWYWx1ZXMoY29uZmlnLmRhdGEpO1xuXHQgICAgICAkJChcIndlYml4X2RlYnVnX2luc3BlY3Rvcl9oZWFkXCIpLnNldFZhbHVlKGNvbmZpZy5oZWFkKTtcblx0ICAgIH0gZWxzZSB3aW4uaGlkZSgpO1xuXHQgIH07XG5cblx0ICB2YXIgaW5maSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID49IDEwMDAwMCkgcmV0dXJuIFwiQW55XCI7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblxuXHQgIHZhciBsb2dfbGV2ZWwgPSBmdW5jdGlvbiAoZGF0YSwgcHJlZml4LCBub3cpIHtcblx0ICAgIHdpbmRvdy5jb25zb2xlLmxvZygoZGF0YSA9PSBub3cgPyBcIj4+XCIgOiBcIiAgXCIpICsgcHJlZml4ICsgZGF0YS5uYW1lICsgXCIgLyBcIiArIGRhdGEuY29uZmlnLmlkKTtcblx0ICAgIHByZWZpeCArPSBcIiAgXCI7XG5cdCAgICBpZiAoZGF0YS5fY2VsbHMpIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5fY2VsbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgbG9nX2xldmVsKGRhdGEuX2NlbGxzW2ldLCBwcmVmaXgsIG5vdyk7XG5cdCAgICB9XG5cdCAgICBpZiAoZGF0YS5faGVhZF9jZWxsKSBsb2dfbGV2ZWwoZGF0YS5faGVhZF9jZWxsLCBwcmVmaXgsIG5vdyk7XG5cdCAgICBpZiAoZGF0YS5fYm9keV9jZWxsKSBsb2dfbGV2ZWwoZGF0YS5fYm9keV9jZWxsLCBwcmVmaXgsIG5vdyk7XG5cdCAgfTtcblxuXHQgIGF0dGFjaEV2ZW50KFwib25Mb2FkRXJyb3JcIiwgZnVuY3Rpb24gKHhodHRwLCBvd25lcikge1xuXHQgICAgdmFyIHRleHQ7IC8veGh0dHAgY2FuIGJlIG9mIGJsb2Igb3IgYXJyYXlidWZmZXIgdHlwZSwgb3IganVzdCBlbXB0eSBpbiBjYXNlIG9mIG5vIGRhdGFcblxuXHQgICAgdHJ5IHtcblx0ICAgICAgdGV4dCA9IHhodHRwLnJlc3BvbnNlVGV4dDtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgdGV4dCA9IFwiXCI7XG5cdCAgICB9XG5cblx0ICAgIHRleHQgPSB0ZXh0IHx8IFwiW0VNUFRZIERBVEFdXCI7XG5cdCAgICB2YXIgZXJyb3JfdGV4dCA9IFwiRGF0YSBsb2FkaW5nIGVycm9yLCBjaGVjayBjb25zb2xlIGZvciBkZXRhaWxzXCI7XG5cdCAgICBpZiAodGV4dC5pbmRleE9mKFwiPD9waHBcIikgPT09IDApIGVycm9yX3RleHQgPSBcIlBIUCBzdXBwb3J0IG1pc3NlZFwiO2Vsc2UgaWYgKHRleHQuaW5kZXhPZihcIldFQklYX0VSUk9SOlwiKSA9PT0gMCkgZXJyb3JfdGV4dCA9IHRleHQucmVwbGFjZShcIldFQklYX0VSUk9SOlwiLCBcIlwiKTtcblx0ICAgIG1lc3NhZ2Uoe1xuXHQgICAgICB0eXBlOiBcImRlYnVnXCIsXG5cdCAgICAgIHRleHQ6IGVycm9yX3RleHQsXG5cdCAgICAgIGV4cGlyZTogLTFcblx0ICAgIH0pO1xuXG5cdCAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcblx0ICAgICAgdmFyIGxvZ2dlciA9IHdpbmRvdy5jb25zb2xlO1xuXHQgICAgICBsb2dnZXIubG9nKFwiRGF0YSBsb2FkaW5nIGVycm9yXCIpO1xuXHQgICAgICBsb2dnZXIubG9nKFwiT2JqZWN0OlwiLCBvd25lcik7XG5cdCAgICAgIGxvZ2dlci5sb2coXCJSZXNwb25zZTpcIiwgdGV4dCk7XG5cdCAgICAgIGlmICh4aHR0cCkgbG9nZ2VyLmxvZyhcIlhIVFRQOlwiLCB4aHR0cCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgcmVhZHkoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIHBhdGggPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXG5cdCAgICBpZiAocGF0aC5pbmRleE9mKFwiZmlsZTpcIikgPT09IDApIHtcblx0ICAgICAgbWVzc2FnZSh7XG5cdCAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuXHQgICAgICAgIHRleHQ6IFwiUGxlYXNlIG9wZW4gc2FtcGxlIGJ5IGh0dHAsPGJyPm5vdCBhcyBmaWxlOi8vXCIsXG5cdCAgICAgICAgZXhwaXJlOiAtMVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICB2YXIgaWdub3JlID0ge1xuXHQgICAgXCJfaW5uZXJcIjogdHJ1ZSxcblx0ICAgIFwiYXdpZHRoXCI6IHRydWUsXG5cdCAgICBcImNoZWlnaHRcIjogdHJ1ZSxcblx0ICAgIFwiYmhlaWdodFwiOiB0cnVlLFxuXHQgICAgXCJhaGVpZ2h0XCI6IHRydWVcblx0ICB9O1xuXHQgIHZhciB1aUNvbmZpZyA9IHtcblx0ICAgIHZpZXc6IFwiY29udGV4dG1lbnVcIixcblx0ICAgIGlkOiBcIndlYml4OmRlYnVnbWVudVwiLFxuXHQgICAgb246IHtcblx0ICAgICAgb25CZWZvcmVTaG93OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgIGlmICghZS5jdHJsS2V5KSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgdmFyIHZpZXcgPSBsb2NhdGUoZSwgXCJ2aWV3X2lkXCIpO1xuXHQgICAgICAgIGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIHRoaXMuY29uZmlnLmxhc3RUYXJnZXQgPSB2aWV3O1xuXHQgICAgICAgIGJsb2NrRXZlbnQoKTtcblx0ICAgICAgICBkZWxheShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB1bmJsb2NrRXZlbnQoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSxcblx0ICAgICAgb25TaG93OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHZpZXcgPSAkJCh0aGlzLmNvbmZpZy5sYXN0VGFyZ2V0KTtcblx0ICAgICAgICB2YXIgaW5mbyA9IFwiPHNwYW4gc3R5bGU9J2NvbG9yOiM4ODgnPlwiICsgdmlldy5fc2V0dGluZ3MuaWQgKyBcIjxzdXAgc3R5bGU9J2Zsb2F0OnJpZ2h0Jz5bXCIgKyB2aWV3Lm5hbWUgKyBcIl08L3N1cD48L3NwYW4+XCI7XG5cdCAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3ZWJpeF9kZWJ1Z19jbXhcIikuaW5uZXJIVE1MID0gaW5mbztcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIGRhdGE6IFtcIjxkaXYgaWQ9J3dlYml4X2RlYnVnX2NteCc+PC9kaXY+XCIsIHtcblx0ICAgICAgaWQ6IFwiaW5zcGVjdFwiLFxuXHQgICAgICB2YWx1ZTogXCJJbnNwZWN0XCJcblx0ICAgIH0sIHtcblx0ICAgICAgaWQ6IFwiZG9jc1wiLFxuXHQgICAgICB2YWx1ZTogXCJEb2N1bWVudGF0aW9uXCJcblx0ICAgIH0sIHtcblx0ICAgICAgdmFsdWU6IFwiTG9nIHRvIENvbnNvbGVcIixcblx0ICAgICAgc3VibWVudTogW3tcblx0ICAgICAgICBpZDogXCJzaXplXCIsXG5cdCAgICAgICAgdmFsdWU6IFwiU2l6ZXNcIlxuXHQgICAgICB9LCB7XG5cdCAgICAgICAgaWQ6IFwidHJlZVwiLFxuXHQgICAgICAgIHZhbHVlOiBcIlRyZWVcIlxuXHQgICAgICB9LCB7XG5cdCAgICAgICAgaWQ6IFwiZHVtcFwiLFxuXHQgICAgICAgIHZhbHVlOiBcIkR1bXBcIlxuXHQgICAgICB9XVxuXHQgICAgfV0sXG5cdCAgICBjbGljazogZnVuY3Rpb24gKGlkLCBldikge1xuXHQgICAgICAvL21peGluZyB0d28gb2JqZWN0IHJlc3VsdCBpbiBjb25mdXNpb25cblx0ICAgICAgdmFyIG9iaiA9ICQkKHRoaXMuY29uZmlnLmxhc3RUYXJnZXQpO1xuXG5cdCAgICAgIGlmIChpZCA9PSBcImR1bXBcIikge1xuXHQgICAgICAgIHdpbmRvdy5jb25zb2xlLmluZm8oXCJcXG5cIiArIG9iai5uYW1lICsgXCIgLyBcIiArIG9iai5jb25maWcuaWQpO1xuXHQgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhcIlxcblZpZXc6IFwiLCBvYmosIFwiLCBDb25maWc6IFwiLCBvYmouY29uZmlnLCBcIiwgRGF0YTogXCIsIG9iai5kYXRhKTtcblx0ICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cob2JqLiR2aWV3KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpZCA9PSBcInRyZWVcIikge1xuXHQgICAgICAgIHZhciBub3cgPSBvYmo7XG5cblx0ICAgICAgICB3aGlsZSAob2JqLmdldFBhcmVudFZpZXcoKSkge1xuXHQgICAgICAgICAgb2JqID0gb2JqLmdldFBhcmVudFZpZXcoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCJcIik7XG5cdCAgICAgICAgbG9nX2xldmVsKG9iaiwgXCJcIiwgbm93KTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpZCA9PSBcInNpemVcIikge1xuXHQgICAgICAgIHdpbmRvdy5jb25zb2xlLmluZm8oXCJcIik7XG5cdCAgICAgICAgd2luZG93LmNvbnNvbGUuaW5mbyhcIlxcblwiICsgb2JqLm5hbWUgKyBcIiAvIFwiICsgb2JqLmNvbmZpZy5pZCk7XG5cdCAgICAgICAgd2luZG93LmNvbnNvbGUuaW5mbyhcIlxcblttaW5dICAgXCIsIG9iai5jb25maWcud2lkdGgsIFwiIHggXCIsIG9iai5jb25maWcuaGVpZ2h0KTtcblx0ICAgICAgICB2YXIgc2l6ZXMgPSBvYmouJGdldFNpemUoMCwgMCk7XG5cdCAgICAgICAgd2luZG93LmNvbnNvbGUuaW5mbyhcIlttYXhdICAgIFwiLCBpbmZpKHNpemVzWzFdKSwgXCIgeCBcIiwgaW5maShzaXplc1szXSkgKyAob2JqLmNvbmZpZy5hdXRvaGVpZ2h0ID8gXCIsIGF1dG8gaGVpZ2h0XCIgOiBcIlwiKSk7XG5cdCAgICAgICAgd2luZG93LmNvbnNvbGUuaW5mbyhcIltncmF2aXR5XSAgIFwiLCBvYmouY29uZmlnLmdyYXZpdHkpO1xuXHQgICAgICAgIHdpbmRvdy5jb25zb2xlLmluZm8oXCJcXG5bY29udGVudF0gICAgXCIsIG9iai5fY29udGVudF93aWR0aCwgXCIgeCBcIiwgb2JqLl9jb250ZW50X2hlaWdodCk7XG5cdCAgICAgICAgd2luZG93LmNvbnNvbGUuaW5mbyhcIltsYXN0IHNldF0gICBcIiwgb2JqLl9sYXN0X3NpemVbMF0sIFwiIHggXCIsIG9iai5fbGFzdF9zaXplWzFdKTtcblx0ICAgICAgICBpZiAob2JqLl9zZXR0aW5ncy5faW5uZXIpIHdpbmRvdy5jb25zb2xlLmluZm8oXCJcXG5bYm9yZGVyc10gICBcIiwgXCJsZWZ0OlwiLCAhb2JqLl9zZXR0aW5ncy5faW5uZXIubGVmdCwgXCJcXHR0b3A6XCIsICFvYmouX3NldHRpbmdzLl9pbm5lci50b3AsIFwiXFx0cmlnaHQ6XCIsICFvYmouX3NldHRpbmdzLl9pbm5lci5yaWdodCwgXCJcXHRib3R0b206XCIsICFvYmouX3NldHRpbmdzLl9pbm5lci5ib3R0b20pO2Vsc2Ugd2luZG93LmNvbnNvbGUuaW5mbyhcIlxcbltib3JkZXJzXSAgIG5vbmVcIik7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaWQgPT0gXCJkb2NzXCIpIHdpbmRvdy5vcGVuKFwiaHR0cDovL2RvY3Mud2ViaXguY29tL2FwaV9fcmVmc19fdWkuXCIgKyBvYmoubmFtZSArIFwiLmh0bWxcIiwgXCJfX2JsYW5rXCIpO1xuXG5cdCAgICAgIGlmIChpZCA9PSBcImluc3BlY3RcIikge1xuXHQgICAgICAgIHNob3dfaW5zcGVjdG9yKHRoaXMuY29uZmlnLmxhc3RUYXJnZXQsIGV2KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgcmVhZHkoZnVuY3Rpb24gKCkge1xuXHQgICAgdWlDb25maWcubWFzdGVyID0gZG9jdW1lbnQuYm9keTtcblx0ICAgIHVpKHVpQ29uZmlnKTtcblx0ICB9KTtcblx0fVxuXG5cdHZhciBEYXRhUmVjb3JkID0gZXhwb3J0cy5wcm90byh7XG5cdCAgbmFtZTogXCJEYXRhUmVjb3JkXCIsXG5cdCAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICB0aGlzLmRhdGEgPSBjb25maWcgfHwge307XG5cdCAgICB2YXIgaWQgPSBjb25maWcgJiYgY29uZmlnLmlkID8gY29uZmlnLmlkIDogdWlkKCk7XG5cdCAgICB0aGlzLl9zZXR0aW5ncyA9IHtcblx0ICAgICAgaWQ6IGlkXG5cdCAgICB9O1xuXHQgICAgdWkudmlld3NbaWRdID0gdGhpcztcblx0ICB9LFxuXHQgIGdldFZhbHVlczogZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZGF0YTtcblx0ICB9LFxuXHQgIHNldFZhbHVlczogZnVuY3Rpb24gKGRhdGEsIHVwZGF0ZSkge1xuXHQgICAgdGhpcy5kYXRhID0gdXBkYXRlID8gZXhwb3J0cy5leHRlbmQodGhpcy5kYXRhLCBkYXRhLCB0cnVlKSA6IGRhdGE7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQ2hhbmdlXCIsIFtkYXRhXSk7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmluZFJlcXVlc3RcIik7XG5cdCAgfVxuXHR9LCBFdmVudFN5c3RlbSwgQmFzZUJpbmQsIEF0b21EYXRhTG9hZGVyLCBTZXR0aW5ncyk7XG5cblx0dmFyIERhdGFWYWx1ZSA9IGV4cG9ydHMucHJvdG8oe1xuXHQgIG5hbWU6IFwiRGF0YVZhbHVlXCIsXG5cdCAgaXNWaXNpYmxlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9LFxuXHQgICRpbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdCAgICBpZiAoIWNvbmZpZyB8fCBpc1VuZGVmaW5lZChjb25maWcudmFsdWUpKSB0aGlzLmRhdGEgPSBjb25maWcgfHwgXCJcIjtcblx0ICAgIHZhciBpZCA9IGNvbmZpZyAmJiBjb25maWcuaWQgPyBjb25maWcuaWQgOiB1aWQoKTtcblx0ICAgIHRoaXMuX3NldHRpbmdzID0ge1xuXHQgICAgICBpZDogaWRcblx0ICAgIH07XG5cdCAgICB1aS52aWV3c1tpZF0gPSB0aGlzO1xuXHQgIH0sXG5cdCAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgdGhpcy5kYXRhID0gdmFsdWU7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQ2hhbmdlXCIsIFt2YWx1ZV0pO1xuXHQgIH0sXG5cdCAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmRhdGE7XG5cdCAgfSxcblx0ICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB0aGlzLmNhbGxFdmVudChcIm9uQmluZFJlcXVlc3RcIik7XG5cdCAgfVxuXHR9LCBFdmVudFN5c3RlbSwgQmFzZUJpbmQpO1xuXG5cdHZhciBUcmVlQ29sbGVjdGlvbiA9IGV4cG9ydHMucHJvdG8oe1xuXHQgIG5hbWU6IFwiVHJlZUNvbGxlY3Rpb25cIixcblx0ICAkaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgZXhwb3J0cy5leHRlbmQodGhpcy5kYXRhLCBUcmVlU3RvcmUsIHRydWUpO1xuXHQgICAgdGhpcy5kYXRhLnByb3ZpZGVBcGkodGhpcywgdHJ1ZSk7XG5cdCAgICBleHBvcnRzLmV4dGVuZCh0aGlzLCBUcmVlRGF0YU1vdmUsIHRydWUpO1xuXHQgIH1cblx0fSwgVHJlZURhdGFMb2FkZXIsIERhdGFDb2xsZWN0aW9uKTtcblxuXHQvLy0tLS0tLS0tLS0tLS0tLS1cblxuXHRleHBvcnRzLkRhdGUgPSB3RGF0ZTtcblx0ZXhwb3J0cy5OdW1iZXIgPSBOdW1iZXIkMTtcblx0ZXhwb3J0cy5wcm9taXNlID0gRGVmZXJyZWQ7XG5cdGV4cG9ydHMuRGF0YUNvbGxlY3Rpb24gPSBEYXRhQ29sbGVjdGlvbjtcblx0ZXhwb3J0cy5EYXRhUmVjb3JkID0gRGF0YVJlY29yZDtcblx0ZXhwb3J0cy5EYXRhVmFsdWUgPSBEYXRhVmFsdWU7XG5cdGV4cG9ydHMuVHJlZUNvbGxlY3Rpb24gPSBUcmVlQ29sbGVjdGlvbjtcblx0ZXhwb3J0cy5BY3RpdmVDb250ZW50ID0gQWN0aXZlQ29udGVudDtcblx0ZXhwb3J0cy5BdG9tRGF0YUxvYWRlciA9IEF0b21EYXRhTG9hZGVyO1xuXHRleHBvcnRzLkF0b21SZW5kZXIgPSBBdG9tUmVuZGVyO1xuXHRleHBvcnRzLkF1dG9TY3JvbGwgPSBBdXRvU2Nyb2xsO1xuXHRleHBvcnRzLkF1dG9Ub29sdGlwID0gQXV0b1Rvb2x0aXA7XG5cdGV4cG9ydHMuQmFzZUJpbmQgPSBCYXNlQmluZDtcblx0ZXhwb3J0cy5CaW5kU291cmNlID0gQmluZFNvdXJjZTtcblx0ZXhwb3J0cy5DYW52YXMgPSBDYW52YXM7XG5cdGV4cG9ydHMuQ29kZVBhcnNlciA9IENvZGVQYXJzZXI7XG5cdGV4cG9ydHMuQ29sbGVjdGlvbkJpbmQgPSBDb2xsZWN0aW9uQmluZDtcblx0ZXhwb3J0cy5Db250ZXh0SGVscGVyID0gQ29udGV4dEhlbHBlcjtcblx0ZXhwb3J0cy5Db3B5UGFzdGUgPSBDb3B5UGFzdGU7XG5cdGV4cG9ydHMuQ3VzdG9tUHJpbnQgPSBDdXN0b21QcmludDtcblx0ZXhwb3J0cy5DdXN0b21TY3JvbGwgPSB0ZW1wJDE7XG5cdGV4cG9ydHMuRGF0YU1hcmtzID0gRGF0YU1hcmtzO1xuXHRleHBvcnRzLkRhdGFNb3ZlID0gRGF0YU1vdmU7XG5cdGV4cG9ydHMuRGF0YUxvYWRlciA9IERhdGFMb2FkZXI7XG5cdGV4cG9ydHMuRGF0YVN0YXRlID0gRGF0YVN0YXRlO1xuXHRleHBvcnRzLkRhdGFTdG9yZSA9IERhdGFTdG9yZTtcblx0ZXhwb3J0cy5EZXN0cnVjdGlvbiA9IERlc3RydWN0aW9uO1xuXHRleHBvcnRzLkRyYWdDb250cm9sID0gRHJhZ0NvbnRyb2w7XG5cdGV4cG9ydHMuRHJhZ0l0ZW0gPSBEcmFnSXRlbTtcblx0ZXhwb3J0cy5EcmFnT3JkZXIgPSBEcmFnT3JkZXI7XG5cdGV4cG9ydHMuRWRpdEFiaWxpdHkgPSBFZGl0QWJpbGl0eTtcblx0ZXhwb3J0cy5FdmVudFN5c3RlbSA9IEV2ZW50U3lzdGVtO1xuXHRleHBvcnRzLkZsZXhMYXlvdXQgPSBGbGV4TGF5b3V0O1xuXHRleHBvcnRzLkdyb3VwID0gR3JvdXA7XG5cdGV4cG9ydHMuR3JvdXBNZXRob2RzID0gR3JvdXBNZXRob2RzO1xuXHRleHBvcnRzLkdyb3VwU3RvcmUgPSBHcm91cFN0b3JlO1xuXHRleHBvcnRzLkhUTUxPcHRpb25zID0gSFRNTE9wdGlvbnM7XG5cdGV4cG9ydHMuSHRtbE1hcCA9IEh0bWxNYXA7XG5cdGV4cG9ydHMuSWRTcGFjZSA9IElkU3BhY2U7XG5cdGV4cG9ydHMuS2V5c05hdmlnYXRpb24gPSBLZXlzTmF2aWdhdGlvbjtcblx0ZXhwb3J0cy5NYXBDb2xsZWN0aW9uID0gTWFwQ29sbGVjdGlvbjtcblx0ZXhwb3J0cy5Nb2RhbGl0eSA9IE1vZGFsaXR5O1xuXHRleHBvcnRzLk1vdXNlRXZlbnRzID0gTW91c2VFdmVudHM7XG5cdGV4cG9ydHMuTW92YWJsZSA9IE1vdmFibGU7XG5cdGV4cG9ydHMuTmF2aWdhdGlvbkJ1dHRvbnMgPSBOYXZpZ2F0aW9uQnV0dG9ucztcblx0ZXhwb3J0cy5PdmVybGF5Qm94ID0gT3ZlcmxheUJveDtcblx0ZXhwb3J0cy5QYWdpbmdBYmlsaXR5ID0gUGFnaW5nQWJpbGl0eTtcblx0ZXhwb3J0cy5Qcm9ncmVzc0JhciA9IFByb2dyZXNzQmFyO1xuXHRleHBvcnRzLlJlY29yZEJpbmQgPSBSZWNvcmRCaW5kO1xuXHRleHBvcnRzLlJlbmRlclN0YWNrID0gUmVuZGVyU3RhY2s7XG5cdGV4cG9ydHMuUmVzaXplQXJlYSA9IFJlc2l6ZUFyZWE7XG5cdGV4cG9ydHMuU2luZ2xlUmVuZGVyID0gU2luZ2xlUmVuZGVyO1xuXHRleHBvcnRzLlNjcm9sbGFibGUgPSBTY3JvbGxhYmxlO1xuXHRleHBvcnRzLlNlbGVjdGlvbk1vZGVsID0gU2VsZWN0aW9uTW9kZWw7XG5cdGV4cG9ydHMuU2V0dGluZ3MgPSBTZXR0aW5ncztcblx0ZXhwb3J0cy5TcGFya2xpbmVzID0gU3BhcmtsaW5lcztcblx0ZXhwb3J0cy5UYWJsZVBhc3RlID0gVGFibGVQYXN0ZTtcblx0ZXhwb3J0cy5Ub29sdGlwQ29udHJvbCA9IFRvb2x0aXBDb250cm9sO1xuXHRleHBvcnRzLlRvdWNoID0gVG91Y2g7XG5cdGV4cG9ydHMuVHJlZUFQSSA9IFRyZWVBUEk7XG5cdGV4cG9ydHMuVHJlZUNsaWNrID0gVHJlZUNsaWNrO1xuXHRleHBvcnRzLlRyZWVEYXRhTG9hZGVyID0gVHJlZURhdGFMb2FkZXI7XG5cdGV4cG9ydHMuVHJlZURhdGFNb3ZlID0gVHJlZURhdGFNb3ZlO1xuXHRleHBvcnRzLlRyZWVSZW5kZXJTdGFjayA9IFRyZWVSZW5kZXJTdGFjaztcblx0ZXhwb3J0cy5UcmVlU3RhdGVDaGVja2JveCA9IFRyZWVTdGF0ZUNoZWNrYm94O1xuXHRleHBvcnRzLlRyZWVTdG9yZSA9IFRyZWVTdG9yZTtcblx0ZXhwb3J0cy5UcmVlVGFibGVQYXN0ZSA9IFRyZWVUYWJsZVBhc3RlO1xuXHRleHBvcnRzLlRyZWVUeXBlID0gVHJlZVR5cGU7XG5cdGV4cG9ydHMuVUlNYW5hZ2VyID0gVUlNYW5hZ2VyO1xuXHRleHBvcnRzLlVuZG8gPSBVbmRvO1xuXHRleHBvcnRzLlVwbG9hZERyaXZlciA9IFVwbG9hZERyaXZlcjtcblx0ZXhwb3J0cy5WYWxpZGF0ZUNvbGxlY3Rpb24gPSBWYWxpZGF0ZUNvbGxlY3Rpb247XG5cdGV4cG9ydHMuVmFsaWRhdGVEYXRhID0gVmFsaWRhdGVEYXRhO1xuXHRleHBvcnRzLlZhbHVlQmluZCA9IFZhbHVlQmluZDtcblx0ZXhwb3J0cy5WYWx1ZXMgPSBWYWx1ZXM7XG5cdGV4cG9ydHMuVmlydHVhbFJlbmRlclN0YWNrID0gVmlydHVhbFJlbmRlclN0YWNrO1xuXHRleHBvcnRzLlZSZW5kZXJTdGFjayA9IFZSZW5kZXJTdGFjaztcblx0ZXhwb3J0cy5odG1sID0gaHRtbCQxO1xuXHRleHBvcnRzLnNraW4gPSBza2luJDU7XG5cdGV4cG9ydHMuZGVidWcgPSBkZWJ1Zztcblx0ZXhwb3J0cy5pMThuID0gaTE4bjtcblx0ZXhwb3J0cy5yZWFkeSA9IHJlYWR5O1xuXHRleHBvcnRzLmVudiA9IGVudjtcblx0ZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuXHRleHBvcnRzLmNzdiA9IGNzdiQxO1xuXHRleHBvcnRzLmNsaXBidWZmZXIgPSBjbGlwYnVmZmVyO1xuXHRleHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5O1xuXHRleHBvcnRzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuXHRleHBvcnRzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cdGV4cG9ydHMudHlwZSA9IHR5cGU7XG5cdGV4cG9ydHMubWFya3VwID0gbWFya3VwO1xuXHRleHBvcnRzLmVkaXRvcnMgPSBlZGl0b3JzO1xuXHRleHBvcnRzLmFuaW1hdGUgPSBhbmltYXRlO1xuXHRleHBvcnRzLnByaW50ID0gcHJpbnQ7XG5cdGV4cG9ydHMucnVsZXMgPSBydWxlcztcblx0ZXhwb3J0cy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuXHRleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uJDE7XG5cdGV4cG9ydHMubmFtZSA9IG5hbWUkMTtcblx0ZXhwb3J0cy5sZXZlbF9pbiA9IGxldmVsX2luO1xuXHRleHBvcnRzLmxldmVsX291dCA9IGxldmVsX291dDtcblx0ZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuXHRleHBvcnRzLmNvcHkgPSBjb3B5O1xuXHRleHBvcnRzLnNpbmdsZSA9IHNpbmdsZTtcblx0ZXhwb3J0cy5iaW5kID0gYmluZDtcblx0ZXhwb3J0cy5leGVjID0gZXhlYztcblx0ZXhwb3J0cy53cmFwID0gd3JhcDtcblx0ZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXHRleHBvcnRzLmRlbGF5ID0gZGVsYXk7XG5cdGV4cG9ydHMub25jZSA9IG9uY2U7XG5cdGV4cG9ydHMudWlkID0gdWlkO1xuXHRleHBvcnRzLnRvTm9kZSA9IHRvTm9kZTtcblx0ZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblx0ZXhwb3J0cy50b0Z1bmN0b3IgPSB0b0Z1bmN0b3I7XG5cdGV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cdGV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXHRleHBvcnRzLlBvd2VyQXJyYXkgPSBQb3dlckFycmF5O1xuXHRleHBvcnRzLl9ldmVudHNfZmluYWxfZGVzdHJ1Y3RvciA9IF9ldmVudHNfZmluYWxfZGVzdHJ1Y3Rvcjtcblx0ZXhwb3J0cy5fZXZlbnQgPSBfZXZlbnQ7XG5cdGV4cG9ydHMuZXZlbnQgPSBldmVudCQxO1xuXHRleHBvcnRzLmV2ZW50UmVtb3ZlID0gZXZlbnRSZW1vdmU7XG5cdGV4cG9ydHMuY2FsbEV2ZW50ID0gY2FsbEV2ZW50O1xuXHRleHBvcnRzLmF0dGFjaEV2ZW50ID0gYXR0YWNoRXZlbnQ7XG5cdGV4cG9ydHMuZGV0YWNoRXZlbnQgPSBkZXRhY2hFdmVudDtcblx0ZXhwb3J0cy5ibG9ja0V2ZW50ID0gYmxvY2tFdmVudDtcblx0ZXhwb3J0cy51bmJsb2NrRXZlbnQgPSB1bmJsb2NrRXZlbnQ7XG5cdGV4cG9ydHMubWFwRXZlbnQgPSBtYXBFdmVudDtcblx0ZXhwb3J0cy5oYXNFdmVudCA9IGhhc0V2ZW50O1xuXHRleHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblx0ZXhwb3J0cy50b1BORyA9IHRvUE5HO1xuXHRleHBvcnRzLnRvQ1NWID0gdG9DU1Y7XG5cdGV4cG9ydHMudG9QREYgPSB0b1BERjtcblx0ZXhwb3J0cy50b0V4Y2VsID0gdG9FeGNlbDtcblx0ZXhwb3J0cy5hbGVydCA9IGFsZXJ0O1xuXHRleHBvcnRzLmNvbmZpcm0gPSBjb25maXJtO1xuXHRleHBvcnRzLm1vZGFsYm94ID0gbW9kYWxib3g7XG5cdGV4cG9ydHMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdGV4cG9ydHMuZWRpdFN0b3AgPSBlZGl0U3RvcDtcblx0ZXhwb3J0cy5hamF4ID0gYWpheDtcblx0ZXhwb3J0cy5qc29ucCA9IGpzb25wO1xuXHRleHBvcnRzLkRhdGFEcml2ZXIgPSBEYXRhRHJpdmVyO1xuXHRleHBvcnRzLmRwID0gZHA7XG5cdGV4cG9ydHMuRGF0YVByb2Nlc3NvciA9IERhdGFQcm9jZXNzb3I7XG5cdGV4cG9ydHMucmVtb3RlID0gcmVtb3RlO1xuXHRleHBvcnRzLnJlcXVpcmUgPSByZXF1aXJlO1xuXHRleHBvcnRzLnByb3h5ID0gcHJveHkkYTtcblx0ZXhwb3J0cy5zZW5kID0gc2VuZDtcblx0ZXhwb3J0cy51aSA9IHVpO1xuXHRleHBvcnRzLiQkID0gJCQ7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=